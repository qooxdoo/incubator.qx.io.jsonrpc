(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.test.Part": {},
      "qx.test.io.part.MockLoader": {},
      "qx.Part": {},
      "qx.io.part.Package": {},
      "qx.io.part.ClosurePart": {},
      "qx.test.io.part.MockPackage": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
  qooxdoo - the new era of web development
  
  http://qooxdoo.org
  
  Copyright:
    2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
  License:
       MIT: https://opensource.org/licenses/MIT
    See the LICENSE file in the project's top-level directory for details.
  
  Authors:
    * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.PART_FILES)
   *
   * @asset(qx/test/*)
   */
  qx.Class.define("qx.test.io.part.ClosurePart", {
    extend: qx.dev.unit.TestCase,
    include: qx.test.io.MRemoteTest,
    members: {
      __dummyLoader: null,
      __timeout: null,
      __loader: null,
      setUp: function setUp() {
        qx.test.PART_FILES = [];
        qx.test.Part.LOAD_ORDER = [];
        this.__dummyLoader = new qx.test.io.part.MockLoader();
        this.__loader = new qx.Part(this.__dummyLoader);
        qx.Part.$$instance = this.__loader;
        this.__timeout = qx.Part.TIMEOUT;
        qx.Part.TIMEOUT = 3000;
      },
      tearDown: function tearDown() {
        qx.Part.$$instance = undefined;
        qx.Part.TIMEOUT = this.__timeout;
      },
      loadPackage: function loadPackage(part, pkg) {
        pkg.loadClosure(this.__loader.notifyPackageResult, this.__loader);
      },
      "test: load part with one package": function testLoadPartWithOnePackage() {
        var pkg = new qx.io.part.Package([this.getUrl("qx/test/part/file1-closure.js")], "p1");
        var part = new qx.io.part.ClosurePart("juhu", [pkg], this.__loader);

        this.__loader.addToPackage(pkg);

        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertEquals("complete", readyState);
            self.assertJsonEquals(["file1-closure"], qx.test.PART_FILES);
          });
        });
        this.wait();
      },
      "test: load part with two packages": function testLoadPartWithTwoPackages() {
        var pkg1 = new qx.io.part.Package([this.getUrl("qx/test/part/file1-closure.js")], "p1");
        var pkg2 = new qx.io.part.Package([this.getUrl("qx/test/part/file2-closure.js")], "p2");
        var part = new qx.io.part.ClosurePart("juhu", [pkg1, pkg2], this.__loader);

        this.__loader.addToPackage(pkg1);

        this.__loader.addToPackage(pkg2);

        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertJsonEquals(["file1-closure", "file2-closure"], qx.test.PART_FILES);
          });
        });
        this.wait();
      },
      "test: load part with two packages and one already loading": function testLoadPartWithTwoPackagesAndOneAlreadyLoading() {
        var pkg1 = new qx.test.io.part.MockPackage("p1", null, null, null, true);
        var pkg2 = new qx.test.io.part.MockPackage("p2", null, null, null, true);
        var part = new qx.io.part.ClosurePart("juhu", [pkg1, pkg2], this.__loader);

        this.__loader.addToPackage(pkg1);

        this.__loader.addToPackage(pkg2);

        this.loadPackage(part, pkg2);
        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertJsonEquals(["p1", "p2"], qx.test.Part.LOAD_ORDER);
          });
        });
        this.wait();
      },
      "test: load part with two packages and both already loading": function testLoadPartWithTwoPackagesAndBothAlreadyLoading() {
        var pkg1 = new qx.test.io.part.MockPackage("p1", null, null, null, true);
        var pkg2 = new qx.test.io.part.MockPackage("p2", null, null, null, true);
        var part = new qx.io.part.ClosurePart("juhu", [pkg1, pkg2], this.__loader);

        this.__loader.addToPackage(pkg1);

        this.__loader.addToPackage(pkg2);

        this.loadPackage(part, pkg1);
        this.loadPackage(part, pkg2);
        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertJsonEquals(["p1", "p2"], qx.test.Part.LOAD_ORDER);
          });
        });
        this.wait();
      },
      "test: load part with three packages and delay": function testLoadPartWithThreePackagesAndDelay() {
        var pkg1 = new qx.test.io.part.MockPackage("p1", 200, null, null, true);
        var pkg2 = new qx.test.io.part.MockPackage("p2", null, null, null, true);
        var pkg3 = new qx.test.io.part.MockPackage("p3", 100, null, null, true);

        this.__loader.addToPackage(pkg1);

        this.__loader.addToPackage(pkg2);

        this.__loader.addToPackage(pkg3);

        var part = new qx.io.part.ClosurePart("juhu", [pkg1, pkg2, pkg3], this.__loader);
        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertJsonEquals(["p1", "p2", "p3"], qx.test.Part.LOAD_ORDER);
          });
        });
        this.wait();
      },
      "test: load part with two packages and delay first part": function testLoadPartWithTwoPackagesAndDelayFirstPart() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        }

        var pkg1 = new qx.test.io.part.MockPackage("p1", 100, null, null, true);
        var pkg2 = new qx.test.io.part.MockPackage("p2", null, null, null, true);
        var part = new qx.io.part.ClosurePart("juhu", [pkg1, pkg2], this.__loader);

        this.__loader.addToPackage(pkg1);

        this.__loader.addToPackage(pkg2);

        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertJsonEquals(["p1", "p2"], qx.test.Part.LOAD_ORDER);
          });
        });
        this.wait();
      },
      "test: load part with an error package": function testLoadPartWithAnErrorPackage() {
        var pkg1 = new qx.test.io.part.MockPackage("file211-closure", null, true, null, true);
        var part = new qx.io.part.ClosurePart("juhu", [pkg1], this.__loader);

        this.__loader.addToPackage(pkg1);

        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertEquals("error", readyState);
            self.assertJsonEquals([], qx.test.Part.LOAD_ORDER);
          });
        });
        this.wait();
      },
      "test: load part with a loaded package should not reload the package again": function testLoadPartWithALoadedPackageShouldNotReloadThePackageAgain() {
        var pkg1 = new qx.test.io.part.MockPackage("p1", null, null, "complete", true);
        var part = new qx.io.part.ClosurePart("juhu", [pkg1], this.__loader);
        var self = this;

        pkg1.load = function () {
          self.resume(function () {
            self.fail();
          });
        };

        part.load(function (readyState) {
          self.resume(function () {
            self.assertEquals("complete", readyState);
          });
        });
        this.wait();
      },
      "test: load a part with preloaded package": function testLoadAPartWithPreloadedPackage() {
        var pkg = new qx.test.io.part.MockPackage("p1", null, null, null, true);
        var part = new qx.io.part.ClosurePart("juhu", [pkg], this.__loader);

        this.__loader.addToPackage(pkg);

        var self = this;
        setTimeout(function () {
          part.load(function (readyState) {
            self.resume(function () {
              self.assertEquals("complete", readyState);
              self.assertJsonEquals(["p1"], qx.test.Part.LOAD_ORDER);
            });
          });
        }, 100);
        part.preload();

        pkg.loadClosure = function () {
          self.resume(function () {
            self.fail("load called twice!");
          });
        };

        this.wait();
      }
    }
  });
  qx.test.io.part.ClosurePart.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /*
   * This is just extracting a common structure that is used by various test
   * classes to initialize qx.Part()
   */
  qx.Bootstrap.define("qx.test.io.part.MockLoader", {
    construct: function construct() {},
    members: {
      parts: {
        "b": ["b"]
      },
      packages: {
        "b": {
          uris: []
        }
      },
      boot: "b"
    }
  });
  qx.test.io.part.MockLoader.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Part": {},
      "qx.test.Part": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Bootstrap.define("qx.test.io.part.MockPackage", {
    construct: function construct(id, delay, error, readyState, useClosure) {
      this.id = id;
      this.delay = delay || 0;
      this.error = !!error;
      this.readyState = readyState || "initialized";
      this.useClosure = !!useClosure;
    },
    members: {
      getReadyState: function getReadyState() {
        return this.readyState;
      },
      getId: function getId() {
        return this.id;
      },
      load: function load(notifyPackageResult, self) {
        var pkg = this;
        this._loadWithClosure = false;
        pkg.readyState = "loading";
        setTimeout(function () {
          if (pkg.error) {
            pkg.readyState = "error";
          } else {
            if (pkg.useClosure) {
              qx.Part.$$notifyLoad(pkg.id, function () {
                qx.test.Part.LOAD_ORDER.push(pkg.id);
              });
            } else {
              qx.test.Part.LOAD_ORDER.push(pkg.id);
            }

            pkg.readyState = "complete";
          }

          notifyPackageResult.call(self, pkg);
        }, pkg.delay);
      },
      saveClosure: function saveClosure(closure) {
        if (this.readyState == "error") {
          return;
        }

        if (!this._loadWithClosure) {
          this.execute();
        } else {
          this.__readyState = "cached";

          this.__notifyPackageResult(this);
        }
      },
      execute: function execute() {
        qx.test.Part.LOAD_ORDER.push(this.id);
      },
      loadClosure: function loadClosure(notifyPackageResult, self) {
        var pkg = this;
        this._loadWithClosure = true;
        this.__notifyPackageResult = qx.Bootstrap.bind(notifyPackageResult, self);
        pkg.readyState = "loading";
        setTimeout(function () {
          if (pkg.error) {
            pkg.readyState = "error";
          } else {
            qx.Part.$$notifyLoad(pkg.id, function () {
              qx.test.Part.LOAD_ORDER.push(pkg.id);
            });
            pkg.readyState = "cached";
          }

          notifyPackageResult.call(self, pkg);
        }, pkg.delay);
      }
    }
  });
  qx.test.io.part.MockPackage.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.test.io.part.MockLoader": {},
      "qx.io.part.Package": {},
      "qx.bom.client.Engine": {},
      "qx.Part": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
  qooxdoo - the new era of web development
  
  http://qooxdoo.org
  
  Copyright:
    2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
  License:
       MIT: https://opensource.org/licenses/MIT
    See the LICENSE file in the project's top-level directory for details.
  
  Authors:
    * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.PART_FILES)
   *
   * @asset(qx/test/*)
   */
  qx.Class.define("qx.test.io.part.Package", {
    extend: qx.dev.unit.TestCase,
    include: qx.test.io.MRemoteTest,
    members: {
      __dummyLoader: null,
      setUp: function setUp() {
        qx.test.PART_FILES = [];
        this.__dummyLoader = new qx.test.io.part.MockLoader();
      },
      createPackage: function createPackage(urls, hash, loaded) {
        return new qx.io.part.Package(urls, hash, loaded);
      },
      "test: load a package with one JS file": function testLoadAPackageWithOneJSFile() {
        var urls = [this.getUrl("qx/test/part/file1.js")];
        var pkg = this.createPackage(urls, "1", false);
        this.assertEquals("initialized", pkg.getReadyState());
        pkg.load(function () {
          this.resume(function () {
            this.assertEquals("complete", pkg.getReadyState());
            this.assertEquals("file1", qx.test.PART_FILES[0]);
          }, this);
        }, this);
        this.assertEquals("loading", pkg.getReadyState());
        this.wait();
      },
      "test: load several files": function testLoadSeveralFiles() {
        var urls = [this.getUrl("qx/test/part/file1.js"), this.getUrl("qx/test/part/file2.js"), this.getUrl("qx/test/part/file3.js")];
        var pkg = this.createPackage(urls, "1", false);
        pkg.load(function () {
          this.resume(function () {
            this.assertJsonEquals(["file1", "file2", "file3"], qx.test.PART_FILES);
          }, this);
        }, this);
        this.wait();
      },
      "test: delay the first file - test load order": function testDelayTheFirstFileTestLoadOrder() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        }

        var urls = [this.getUrl("qx/test/part/delay.php") + "?sleep=0.3", this.getUrl("qx/test/part/file2.js"), this.getUrl("qx/test/part/file3.js")];
        var pkg = this.createPackage(urls, "1", false);
        pkg.load(function () {
          this.resume(function () {
            this.assertJsonEquals(["file1", "file2", "file3"], qx.test.PART_FILES);
          }, this);
        }, this);
        this.wait();
      },
      "test: if one of the files fails to load, no load event should be fired": function testIfOneOfTheFilesFailsToLoadNoLoadEventShouldBeFired() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        } // test don't work in IE, Safari 3 and Opera


        if (qx.core.Environment.get("engine.name") == "opera" || qx.core.Environment.get("engine.name") == "mshtml") {
          return;
        }

        var urls = [this.getUrl("qx/test/part/file1.js"), this.getUrl("qx/test/xmlhttp/404.php"), this.getUrl("qx/test/part/file3.js")];
        var pkg = this.createPackage(urls, "1", false);
        pkg.load(function () {
          this.resume(function () {
            this.assertEquals("error", pkg.getReadyState());
          }, this);
        }, this);
        this.wait();
      },
      "test: loading a closure package with load() should execute the closure": function testLoadingAClosurePackageWithLoadShouldExecuteTheClosure() {
        var urls = [this.getUrl("qx/test/part/file1-closure.js")];
        var pkg = this.createPackage(urls, "p1", false);
        var loader = new qx.Part(this.__dummyLoader);
        qx.Part.$$instance = loader;
        loader.addToPackage(pkg);
        pkg.load(function () {
          this.resume(function () {
            this.assertJsonEquals(["file1-closure"], qx.test.PART_FILES);
          }, this);
        }, this);
        this.wait();
      },
      "test: loading a closure package with loadClosure() should not execute the closure": function testLoadingAClosurePackageWithLoadClosureShouldNotExecuteTheClosure() {
        var urls = [this.getUrl("qx/test/part/file1-closure.js")];
        var pkg = this.createPackage(urls, "p1", false);
        var loader = new qx.Part(this.__dummyLoader);
        qx.Part.$$instance = loader;
        loader.addToPackage(pkg);
        pkg.loadClosure(function () {
          this.resume(function () {
            this.assertEquals("cached", pkg.getReadyState());
            this.assertJsonEquals([], qx.test.PART_FILES);
            pkg.execute();
            this.assertJsonEquals(["file1-closure"], qx.test.PART_FILES);
          }, this);
        }, this);
        this.wait();
      },
      "test: loading a non existing file with loadClosure() should timeout": function testLoadingANonExistingFileWithLoadClosureShouldTimeout() {
        var pkg = this.createPackage(["___foo.js"], "p1", false);
        var loader = new qx.Part(this.__dummyLoader);
        qx.Part.$$instance = loader;
        loader.addToPackage(pkg);
        var oldTimeout = qx.Part.TIMEOUT;
        qx.Part.TIMEOUT = 300;
        pkg.loadClosure(function () {
          this.resume(function () {
            this.assertEquals("error", pkg.getReadyState());
            this.assertJsonEquals([], qx.test.PART_FILES);
          }, this);
        }, this);
        qx.Part.TIMEOUT = oldTimeout;
        this.wait();
      }
    }
  });
  qx.test.io.part.Package.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.test.Part": {},
      "qx.test.io.part.MockLoader": {},
      "qx.Part": {},
      "qx.io.part.Part": {},
      "qx.test.io.part.MockPackage": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
  qooxdoo - the new era of web development
  
  http://qooxdoo.org
  
  Copyright:
    2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
  License:
       MIT: https://opensource.org/licenses/MIT
    See the LICENSE file in the project's top-level directory for details.
  
  Authors:
    * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/*)
   */
  qx.Class.define("qx.test.io.part.Part", {
    extend: qx.dev.unit.TestCase,
    include: qx.test.io.MRemoteTest,
    members: {
      __loader: null,
      setUp: function setUp() {
        qx.test.Part.LOAD_ORDER = [];
        this.__dummyLoader = new qx.test.io.part.MockLoader();
        this.__loader = new qx.Part(this.__dummyLoader);
        qx.Part.$$instance = this.__loader;
      },
      tearDown: function tearDown() {
        this.__loader = null;
        qx.Part.$$instance = undefined;
      },
      createPart: function createPart(name, pkgs, loader) {
        return new qx.io.part.Part(name, pkgs, loader);
      },
      "test: load part with one package": function testLoadPartWithOnePackage() {
        var pkg = new qx.test.io.part.MockPackage("1");
        var part = this.createPart("1", [pkg], this.__loader);
        this.assertEquals("initialized", part.getReadyState());
        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertEquals("complete", readyState);
            self.assertEquals("complete", part.getReadyState());
          });
        });
        this.assertEquals("loading", part.getReadyState());
        this.wait();
      },
      "test: load part with several packages": function testLoadPartWithSeveralPackages() {
        var packages = [new qx.test.io.part.MockPackage("a"), new qx.test.io.part.MockPackage("b"), new qx.test.io.part.MockPackage("c")];
        var part = this.createPart("1", packages, this.__loader);
        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertJsonEquals(["a", "b", "c"], qx.test.Part.LOAD_ORDER);
          });
        });
        this.wait();
      },
      "test: delay loading of second package should preserve order": function testDelayLoadingOfSecondPackageShouldPreserveOrder() {
        var packages = [new qx.test.io.part.MockPackage("a"), new qx.test.io.part.MockPackage("b", 100), new qx.test.io.part.MockPackage("c")];
        var part = this.createPart("1", packages, this.__loader);
        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertJsonEquals(["a", "b", "c"], qx.test.Part.LOAD_ORDER);
          });
        });
        this.wait();
      },
      "test: one already loaded package should not be loaded again and preserve order": function testOneAlreadyLoadedPackageShouldNotBeLoadedAgainAndPreserveOrder() {
        var packages = [new qx.test.io.part.MockPackage("a", 0, false, "complete"), new qx.test.io.part.MockPackage("b"), new qx.test.io.part.MockPackage("c")]; // fail if it is loaded again

        var self = this;
        var oldLoadPackage = this.__loader.loadPackage;

        this.__loader.loadPackage = function (pkg) {
          if (pkg == packages[0]) {
            self.fail();
          } else {
            oldLoadPackage.call(this, pkg);
          }
        };

        var part = this.createPart("1", packages, this.__loader);
        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertJsonEquals(["b", "c"], // a is already loaded
            qx.test.Part.LOAD_ORDER);
          });
        });
        this.wait();
      },
      "test: a currently loading package should not be loaded again and should preserve order": function testACurrentlyLoadingPackageShouldNotBeLoadedAgainAndShouldPreserveOrder() {
        var packages = [new qx.test.io.part.MockPackage("a", 0, false, "complete"), new qx.test.io.part.MockPackage("b"), new qx.test.io.part.MockPackage("c")];
        packages[1].load(this.__loader.notifyPackageResult, this.__loader); // now in loading state

        var part = this.createPart("1", packages, this.__loader);
        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertJsonEquals(["b", "c"], // a has already been loaded
            qx.test.Part.LOAD_ORDER);
          });
        });
        this.wait();
      },
      "test: error loading second package should set 'error' status on callback": function testErrorLoadingSecondPackageShouldSetErrorStatusOnCallback() {
        var packages = [new qx.test.io.part.MockPackage("a"), new qx.test.io.part.MockPackage("b", 0, true), new qx.test.io.part.MockPackage("c")];
        var part = this.createPart("1", packages, this.__loader);
        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            this.assertEquals("error", readyState);
            this.assertEquals("error", part.getReadyState());
          });
        });
        this.wait();
      },
      "test: loading a loaded part again should not reload the packages": function testLoadingALoadedPartAgainShouldNotReloadThePackages() {
        var packages = [new qx.test.io.part.MockPackage("a"), new qx.test.io.part.MockPackage("b"), new qx.test.io.part.MockPackage("c")];
        var part = this.createPart("1", packages, this.__loader);
        var self = this;
        part.load(function (readyState) {
          self.__loader.loadPackage = function () {
            self.fail();
          };

          part.load(function (readyState) {
            self.resume(function () {
              this.assertEquals("complete", readyState);
            });
          });
        });
        this.wait();
      },
      "test: loading an error part again should not reload the packages": function testLoadingAnErrorPartAgainShouldNotReloadThePackages() {
        var packages = [new qx.test.io.part.MockPackage("a"), new qx.test.io.part.MockPackage("b", 0, true), new qx.test.io.part.MockPackage("c")];
        var part = this.createPart("1", packages, this.__loader);
        var self = this;
        part.load(function (readyState) {
          self.__loader.loadPackage = function () {
            self.fail();
          };

          part.load(function (readyState) {
            self.resume(function () {
              self.assertEquals("error", readyState);
            });
          });
        });
        this.wait();
      },
      "test: load part with several packages including wrapped": function testLoadPartWithSeveralPackagesIncludingWrapped() {
        var packages = [new qx.test.io.part.MockPackage("a", null, null, null, true), new qx.test.io.part.MockPackage("b"), new qx.test.io.part.MockPackage("c", null, null, null, true)];

        this.__loader.addToPackage(packages[0]);

        this.__loader.addToPackage(packages[1]);

        this.__loader.addToPackage(packages[2]);

        var part = this.createPart("1", packages, this.__loader);
        var self = this;
        part.load(function (readyState) {
          self.resume(function () {
            self.assertJsonEquals(["a", "b", "c"], qx.test.Part.LOAD_ORDER);
          });
        });
        this.wait();
      }
    }
  });
  qx.test.io.part.Part.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.event.Timer": {},
      "qx.lang.Json": {},
      "qx.io.remote.Request": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
  qooxdoo - the new era of web development
  
  http://qooxdoo.org
  
  Copyright:
    2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
  License:
       MIT: https://opensource.org/licenses/MIT
    See the LICENSE file in the project's top-level directory for details.
  
  Authors:
    * Fabian Jakobs (fjakobs)
    * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /*
  */

  /**
   *
   * @asset(qx/test/*)
   */
  qx.Class.define("qx.test.io.remote.AbstractRequest", {
    type: "abstract",
    extend: qx.dev.unit.TestCase,
    include: qx.test.io.MRemoteTest,
    members: {
      _requests: null,
      setUp: function setUp() {
        this._requests = [];

        for (var i = 0; i < 10; i++) {
          var request = this._createRequest();

          request.addListener("aborted", this.responseError, this);
          request.addListener("failed", this.responseError, this);
          request.addListener("timeout", this.responseError, this);
          this._requests[i] = request;
        }
      },
      _createRequest: function _createRequest() {
        throw new Error("Abstract method call");
      },
      _getRequests: function _getRequests() {
        return this._requests;
      },
      tearDown: function tearDown() {
        this._disposeArray("_requests");
      },
      responseError: function responseError(e) {
        var request = e;
        var type = e.getType();
        qx.event.Timer.once(function () {
          this.resume(function () {
            this.fail("Response error: " + type + " " + request.getStatusCode());
          }, this);
        }, this);
      },
      testAsynchronous: function testAsynchronous() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        }

        var completedCount = 0;

        for (var i = 0; i < this._requests.length; i++) {
          var request = this._requests[i];
          request.setParameter("test", "test" + i);
          request.addListener("completed", function (e) {
            completedCount++;
            var response = qx.lang.Json.parse(e.getContent());
            request = e.getTarget();
            this.assertEquals(request.getParameter("test"), response["test"]);
          }, this);
          request.send();
        }

        var that = this;
        this.wait(5000, function () {
          that.assertEquals(i, completedCount);
        });
      },
      testAbortedOnException: function testAbortedOnException() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        }

        var url = this.getUrl("qx/test/xmlhttp/echo_get_request.php");
        var request = new qx.io.remote.Request(url, "GET", "text/plain");
        request.addListener("failed", this.responseError, this);
        request.addListener("timeout", this.responseError, this);
        request.addListener("completed", function (e) {
          throw new Error("Expected exception.");
        }, this);
        request.addListener("aborted", function (e) {
          this.resume(function () {
            this.assertEquals(request, e.getTarget());
            request.dispose();
          }, this);
        }, this);
        request.send();
        this.wait(2000);
      }
    }
  });
  qx.test.io.remote.AbstractRequest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.io.remote.AbstractRequest": {
        "require": true
      },
      "qx.io.remote.Request": {},
      "qx.bom.client.Engine": {},
      "qx.lang.Json": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
  qooxdoo - the new era of web development
  
  http://qooxdoo.org
  
  Copyright:
    2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
  License:
       MIT: https://opensource.org/licenses/MIT
    See the LICENSE file in the project's top-level directory for details.
  
  Authors:
    * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /*
  */

  /**
   *
   * @asset(qx/test/*)
   */
  qx.Class.define("qx.test.io.remote.RequestIframe", {
    extend: qx.test.io.remote.AbstractRequest,
    members: {
      // Overridden
      _createRequest: function _createRequest() {
        var url = this.getUrl("qx/test/xmlhttp/echo_form_request.php");
        return new qx.io.remote.Request(url, "GET", "text/plain").set({
          fileUpload: true
        });
      },
      testAsynchronous: function testAsynchronous() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        }

        var completedCount = 0;

        for (var i = 0; i < this._requests.length; i++) {
          var request = this._requests[i],
              emptyContent;
          request.setParameter("test", "test" + i);
          request.addListener("completed", function (e) {
            completedCount++; // Skip test when response is empty. Occuring seemingly randomly
            // in IE when many requests are made.
            //
            // May be due to timing issue showing under rare and obscure
            // circumstances (clean cache, build variant, fresh browser window).

            if (qx.core.Environment.get("engine.name") === "mshtml" && e.getContent() === "" && !emptyContent) {
              this.warn("Skipping test due to empty content in one of the request's response");
              emptyContent = true;
              return;
            }

            if (!emptyContent) {
              var response = qx.lang.Json.parse(e.getContent());
              request = e.getTarget();
              this.assertEquals(request.getParameter("test"), response["test"]);
            }
          }, this);
          request.send();
        }

        var that = this;
        this.wait(5000, function () {
          that.assertEquals(i, completedCount);
        });
      },
      testAsynchronousSingle: function testAsynchronousSingle() {
        var request = this._requests[0];
        request.setParameter("test", "affe");
        request.addListener("completed", function (e) {
          var response = qx.lang.Json.parse(e.getContent());
          this.assertEquals("affe", response["test"]);
        }, this);
        request.send();
      }
    }
  });
  qx.test.io.remote.RequestIframe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.io.remote.AbstractRequest": {
        "require": true
      },
      "qx.io.remote.Request": {},
      "qx.lang.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
  qooxdoo - the new era of web development
  
  http://qooxdoo.org
  
  Copyright:
    2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
  License:
       MIT: https://opensource.org/licenses/MIT
    See the LICENSE file in the project's top-level directory for details.
  
  Authors:
    * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /*
  */

  /**
   *
   * @asset(qx/test/*)
   */
  qx.Class.define("qx.test.io.remote.RequestXhr", {
    extend: qx.test.io.remote.AbstractRequest,
    members: {
      // Overridden
      _createRequest: function _createRequest() {
        var url = this.getUrl("qx/test/xmlhttp/echo_get_request.php");
        return new qx.io.remote.Request(url, "GET", "text/plain");
      },
      testSynchronous: function testSynchronous() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        }

        var completedCount = 0;

        for (var i = 0; i < this._getRequests().length; i++) {
          var request = this._getRequests()[i];

          request.setAsynchronous(false);
          request.setParameter("test", "test" + i);
          request.addListener("completed", function (e) {
            completedCount++;
            var response = qx.lang.Json.parse(e.getContent());
            request = e.getTarget();
            this.assertEquals(request.getParameter("test"), response["test"]);
          }, this);
          request.send();
        }

        this.assertEquals(i, completedCount, "Test doesn't run synchronous!");
      },
      testSynchronousAndAsynchronousMix: function testSynchronousAndAsynchronousMix() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        }

        var asynchronousRequest = this._getRequests()[0];

        var synchronousRequest = this._getRequests()[1];

        asynchronousRequest.setParameter("test", "asynchronousRequest");
        asynchronousRequest.setParameter("sleep", 1);
        synchronousRequest.setParameter("test", "synchronousRequest");
        synchronousRequest.setAsynchronous(false);
        var asynchronousRequestFinished = false;
        var synchronousRequestFinished = false;
        asynchronousRequest.addListener("completed", function (e) {
          //this.resume(function()
          //{
          asynchronousRequestFinished = true;
          var response = qx.lang.Json.parse(e.getContent());
          var request = e.getTarget();
          this.assertEquals(request.getParameter("test"), response["test"]); //}, this);
        }, this);
        synchronousRequest.addListener("completed", function (e) {
          synchronousRequestFinished = true;
          var response = qx.lang.Json.parse(e.getContent());
          var request = e.getTarget();
          this.assertEquals(request.getParameter("test"), response["test"]);
        }, this);
        asynchronousRequest.send();
        synchronousRequest.send();
        var that = this;
        this.wait(5000, function () {
          that.assertTrue(asynchronousRequestFinished);
          that.assertTrue(synchronousRequestFinished);
        });
      },
      testGetResponseHeader: function testGetResponseHeader() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        }

        var request = new qx.io.remote.Request(); // Response header is "juhu"

        request.setUrl(this.getUrl("qx/test/xmlhttp/send_known_header.php"));
        request.addListener("completed", function (e) {
          this.resume(function () {
            this.assertEquals("kinners", e.getResponseHeader("juhu"), "Exact case match");
            this.assertEquals("kinners", e.getResponseHeader("Juhu"), "Case insensitive match");
          }, this);
        }, this);
        var that = this;
        window.setTimeout(function () {
          request.send();
        }, 1000);
        this.wait(5000);
      }
    }
  });
  qx.test.io.remote.RequestXhr.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.io.remote.Request": {},
      "qx.io.remote.Rpc": {},
      "qx.event.Registration": {},
      "qx.io.remote.Response": {},
      "qx.lang.Type": {},
      "qx.lang.Json": {},
      "qx.dev.unit.RequirementError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.io.remote.Rpc", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      setUpFakeRequest: function setUpFakeRequest() {
        var req = this.request = new qx.io.remote.Request(); // In prototype chain

        req.setState = req.getSequenceNumber = req.setData = req.send = function () {}; // Stub


        this.stub(req);
        req.addListener.restore();
        req.dispatchEvent.restore();
        req.getSequenceNumber.returns(undefined); // Inject

        this.injectStub(qx.io.remote, "Request", req);
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();
      },
      "test: send request": function testSendRequest() {
        this.setUpFakeRequest();
        var rpc = new qx.io.remote.Rpc("/foo");
        rpc.callAsync();
        this.assertCalledOnce(this.request.send);
      },
      "test: request data for params with date contains date literal when convert dates": function testRequestDataForParamsWithDateContainsDateLiteralWhenConvertDates() {
        this.setUpFakeRequest();
        var obj = {
          date: new Date(Date.UTC(2020, 0, 1, 0, 0, 0, 123))
        },
            msg,
            data;
        var rpc = new qx.io.remote.Rpc();
        this.stub(rpc, "_isConvertDates").returns(true);
        this.stub(rpc, "createRpcData").returns({
          "params": obj
        });
        rpc.callAsync();
        data = this.request.setData.getCall(0).args[0];
        msg = "Must contain converted date literal";
        this.assertMatch(data, /"new Date\(Date.UTC\(2020,0,1,0,0,0,123\)\)"/, msg);
      },
      "test: request data for params with nested date contains date literal when convert dates": function testRequestDataForParamsWithNestedDateContainsDateLiteralWhenConvertDates() {
        this.setUpFakeRequest();
        var obj = {
          nested: {
            date: new Date(Date.UTC(2020, 0, 1, 0, 0, 0, 123))
          }
        },
            msg,
            data;
        var rpc = new qx.io.remote.Rpc();
        this.stub(rpc, "_isConvertDates").returns(true);
        this.stub(rpc, "createRpcData").returns({
          "params": obj
        });
        rpc.callAsync();
        data = this.request.setData.getCall(0).args[0];
        msg = "Must contain converted date literal";
        this.assertMatch(data, /"new Date\(Date.UTC\(2020,0,1,0,0,0,123\)\)"/, msg);
      },
      "test: response contains date from literal when convert dates": function testResponseContainsDateFromLiteralWhenConvertDates() {
        this.setUpFakeRequest();
        var rpc = new qx.io.remote.Rpc(),
            req = this.request,
            evt = qx.event.Registration.createEvent("completed", qx.io.remote.Response),
            str = '{"result": {"date": new Date(Date.UTC(2020,0,1,0,0,0,123))} }',
            that = this;
        this.stub(rpc, "_isConvertDates").returns(true);
        var callback = this.spy(function (result) {
          var msg = "Expected value to be date but found " + typeof result.date;
          that.assertTrue(qx.lang.Type.isDate(result.date), msg);
        });
        rpc.callAsync(callback); // Fake JSON-like (JavaScript) response

        evt.setContent(str);
        req.dispatchEvent(evt);
        this.assertCalled(callback);
      },
      "test: response contains date from literal when convert dates and json response": function testResponseContainsDateFromLiteralWhenConvertDatesAndJsonResponse() {
        this.setUpFakeRequest();
        var rpc = new qx.io.remote.Rpc(),
            req = this.request,
            evt = qx.event.Registration.createEvent("completed", qx.io.remote.Response),
            str = '{"result": {"date": "new Date(Date.UTC(2020,0,1,0,0,0,123))"} }',
            that = this;
        this.stub(rpc, "_isConvertDates").returns(true);
        this.stub(rpc, "_isResponseJson").returns(true);
        this.spy(qx.lang.Json, "parse");
        var callback = this.spy(function (result) {
          var msg;
          that.assertCalled(qx.lang.Json.parse);
          msg = "Expected value to be date but found " + typeof result.date;
          that.assertTrue(qx.lang.Type.isDate(result.date), msg);
        });
        rpc.callAsync(callback); // Fake JSON (String) response

        evt.setContent(str);
        req.dispatchEvent(evt);
        this.assertCalled(callback);
      },
      "test: response is parsed as JSON": function testResponseIsParsedAsJSON() {
        this.setUpFakeRequest();
        var rpc = new qx.io.remote.Rpc(),
            req = this.request,
            evt = qx.event.Registration.createEvent("completed", qx.io.remote.Response),
            str = '{"result": { "json" : true} }',
            that = this;
        this.stub(rpc, "_isConvertDates").returns(false);
        this.spy(qx.lang.Json, "parse");
        var callback = this.spy(function (result) {
          that.assertCalledWith(qx.lang.Json.parse, str);
        });
        rpc.callAsync(callback); // Fake JSON (String) response

        evt.setContent(str);
        req.dispatchEvent(evt);
        this.assertCalled(callback);
      },
      "test: response is not parsed when already object": function testResponseIsNotParsedWhenAlreadyObject() {
        this.setUpFakeRequest();
        var rpc = new qx.io.remote.Rpc(),
            req = this.request,
            evt = qx.event.Registration.createEvent("completed", qx.io.remote.Response),
            obj = {
          "result": {
            "json": true
          }
        },
            that = this;
        this.stub(rpc, "_isConvertDates").returns(false);
        this.spy(qx.lang.Json, "parse");
        var callback = this.spy(function (result) {
          that.assertNotCalled(qx.lang.Json.parse);
        });
        rpc.callAsync(callback); // Object response

        evt.setContent(obj);
        req.dispatchEvent(evt);
        this.assertCalled(callback);
      },
      //
      // isConvertDates()
      //
      "test: isConvertDates() returns true when Rpc true": function testIsConvertDatesReturnsTrueWhenRpcTrue() {
        var rpc = new qx.io.remote.Rpc();
        this.stub(qx.io.remote.Rpc, "CONVERT_DATES", true);
        this.assertEquals(true, rpc._isConvertDates());
      },
      skip: function skip(msg) {
        throw new qx.dev.unit.RequirementError(null, msg);
      }
    }
  });
  qx.test.io.remote.Rpc.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.io.remote.transport.Iframe": {},
      "qx.lang.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
  qooxdoo - the new era of web development
  
  http://qooxdoo.org
  
  Copyright:
    2010 1&1 Internet AG, Germany, http://www.1und1.de
  
  License:
       MIT: https://opensource.org/licenses/MIT
    See the LICENSE file in the project's top-level directory for details.
  
  Authors:
    * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /*
  */

  /**
   *
   * @asset(qx/test/xmlhttp/echo_get_request.php)
   */
  qx.Class.define("qx.test.io.remote.transport.Iframe", {
    extend: qx.dev.unit.TestCase,
    include: qx.test.io.MRemoteTest,
    members: {
      setUp: function setUp() {
        this.request = new qx.io.remote.transport.Iframe();
      },
      testGetIframeHtmlContent: function testGetIframeHtmlContent() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        }

        this.request.addListener("completed", function () {
          this.resume(function () {
            var response = this.request.getIframeHtmlContent();
            this.assertNotNull(response, "Response is 'null'!");
            this.assertNotEquals("", response, "Response is empty!");
            response = qx.lang.Json.parse(response);
            this.assertEquals("my_param=expected", response["_data_"], "Response is wrong!");
          }, this);
        }, this); // Send request

        this.request.setUrl(this.getUrl("qx/test/xmlhttp/echo_get_request.php"));
        this.request.setParameters({
          my_param: "expected"
        });
        this.request.send();
        this.wait();
      }
    }
  });
  qx.test.io.remote.transport.Iframe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.io.remote.transport.XmlHttp": {},
      "qx.util.AliasManager": {},
      "qx.event.Timer": {},
      "qx.util.ResourceManager": {},
      "qx.lang.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
  qooxdoo - the new era of web development
  
  http://qooxdoo.org
  
  Copyright:
    2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
  License:
       MIT: https://opensource.org/licenses/MIT
    See the LICENSE file in the project's top-level directory for details.
  
  Authors:
    * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /*
  */

  /**
   *
   * @asset(qx/test/*)
   */
  qx.Class.define("qx.test.io.remote.transport.XmlHttp", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.request = new qx.io.remote.transport.XmlHttp();
        this.request.addListener("aborted", this.responseError, this);
        this.request.addListener("failed", this.responseError, this);
        this.request.addListener("timeout", this.responseError, this);
        this.resourceBase = qx.util.AliasManager.getInstance().resolve("qx/test/");
      },
      tearDown: function tearDown() {
        this.request.dispose();
      },
      responseError: function responseError(e) {
        var request = e.getTarget();
        var type = e.getType();
        qx.event.Timer.once(function () {
          this.resume(function () {
            this.fail("Response error: " + type + " " + request.getStatusCode() + " " + request.getStatusText());
          }, this);
        }, this);
      },
      getUrl: function getUrl(path) {
        return qx.util.ResourceManager.getInstance().toUri(path);
      },
      isLocal: function isLocal() {
        return window.location.protocol == "file:";
      },
      needsPHPWarning: function needsPHPWarning() {
        this.warn("This test can only be run from a web server with PHP support.");
      },
      testSetHeader: function testSetHeader() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        }

        this.request.setUrl(this.getUrl("qx/test/xmlhttp/echo_header.php"));
        this.request.getRequestHeaders()["foo"] = "bar";
        this.request.setRequestHeader("juhu", "kinners");
        this.request.addListener("completed", function (e) {
          this.resume(function () {
            var response = qx.lang.Json.parse(this.request.getResponseText().toLowerCase());
            this.assertEquals("kinners", response["juhu"]);
            this.assertEquals("bar", response["foo"]);
          }, this);
        }, this);
        var that = this;
        window.setTimeout(function () {
          that.request.send();
        }, 250);
        this.wait(7500);
      },
      testGetResponseHeader: function testGetResponseHeader() {
        if (this.isLocal()) {
          this.needsPHPWarning();
          return;
        }

        this.request.setUrl(this.getUrl("qx/test/xmlhttp/send_known_header.php"));
        this.request.addListener("completed", function (e) {
          this.resume(function () {
            var juhu = this.request.getResponseHeader("juhu") || this.request.getResponseHeader("Juhu");
            this.assertEquals("kinners", juhu);
          }, this);
        }, this);
        var that = this;
        window.setTimeout(function () {
          that.request.send();
        }, 250);
        this.wait(7500);
      }
    }
  });
  qx.test.io.remote.transport.XmlHttp.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Class": {},
      "qx.core.Object": {},
      "qx.util.Uri": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /* ************************************************************************
  ************************************************************************ */

  /**
   * @ignore(Klass)
   * @asset(qx/test/xmlhttp/*)
   */

  /**
   * Tests asserting shared behavior of io.request.* classes. Also provides
   * common helpers.
   *
   * It should be noted that tests defined here fake an ideal transport. The
   * transport itself is tested elsewhere (see {@link qx.test.bom.request}).
   */
  qx.Mixin.define("qx.test.io.request.MRequest", {
    members: {
      setUpKlass: function setUpKlass() {
        qx.Class.define("Klass", {
          extend: qx.core.Object,
          properties: {
            affe: {
              init: true
            }
          }
        });
      },
      //
      // General
      //
      "test: dispose transport on destruct": function testDisposeTransportOnDestruct() {
        this.req.dispose();
        this.wait(100, function () {
          this.assertCalled(this.transport.dispose);
        }, this);
      },
      "test: getTransport()": function testGetTransport() {
        this.assertEquals(this.transport, this.req.getTransport());
      },
      //
      // Send
      //
      "test: send() GET": function testSendGET() {
        this.req.send();
        this.assertCalledWith(this.transport.open, "GET", "url");
        this.assertCalled(this.transport.send);
      },
      "test: drop fragment from URL": function testDropFragmentFromURL() {
        this.req.setUrl("example.com#fragment");
        this.req.send();
        this.assertCalledWith(this.transport.open, "GET", "example.com");
      },
      //
      // Abort
      //
      "test: abort request": function testAbortRequest() {
        this.req.abort();
        this.assertCalled(this.transport.abort);
      },
      //
      // Data
      //
      "test: not send data with GET request": function testNotSendDataWithGETRequest() {
        this.req.setRequestData("str");
        this.req.send();
        this.assertCalledWith(this.transport.send, undefined);
      },
      "test: append string data to URL with GET request": function testAppendStringDataToURLWithGETRequest() {
        this.req.setRequestData("str");
        this.req.send();
        this.assertCalledWith(this.transport.open, "GET", "url?str");
      },
      "test: append obj data to URL with GET request": function testAppendObjDataToURLWithGETRequest() {
        this.req.setRequestData({
          affe: true
        });
        this.req.send();
        this.assertCalledWith(this.transport.open, "GET", "url?affe=true");
      },
      "test: append qooxdoo obj data to URL with GET request": function testAppendQooxdooObjDataToURLWithGETRequest() {
        this.setUpKlass();
        var obj = new Klass();
        this.req.setRequestData(obj);
        this.req.send();
        this.assertCalledWith(this.transport.open, "GET", "url?affe=true");
        obj.dispose();
      },
      "test: append FormData to URL with POST request": function testAppendFormDataToURLWithPOSTRequest() {
        if (!window.FormData) {
          this.skip("FormData API not supported");
        }

        if (!this.req.setMethod) {
          this.skip("POST requests not supported by this transport");
        }

        var formData = new FormData();
        formData.append("foo", "bar");
        formData.append("baz", "qux");
        this.req.setMethod("POST");
        this.req.setRequestData(formData);
        this.req.send();
        this.assertCalledWith(this.transport.send, formData);
      },
      //
      // Header and Params
      //
      "test: set request header": function testSetRequestHeader() {
        this.req.setRequestHeader("key", "value");
        this.req.send();
        this.assertCalledWith(this.transport.setRequestHeader, "key", "value");
      },
      "test: set request header does not append": function testSetRequestHeaderDoesNotAppend() {
        var stub = this.transport.setRequestHeader.withArgs("key", "value");
        this.req.setRequestHeader("key", "value");
        this.req.setRequestHeader("key", "value");
        this.req.send();
        this.assertCalledOnce(stub.withArgs("key", "value"));
      },
      "test: get request header": function testGetRequestHeader() {
        this.req.setRequestHeader("key", "value");
        this.assertEquals("value", this.req.getRequestHeader("key"));
      },
      "test: remove request header": function testRemoveRequestHeader() {
        var stub;
        this.req.setRequestHeader("key", "value");
        this.req.removeRequestHeader("key");
        stub = this.transport.setRequestHeader.withArgs("key", "value");
        this.req.send();
        this.assertNotCalled(stub);
      },
      "test: get all request headers": function testGetAllRequestHeaders() {
        this.req.setRequestHeader("key", "value");
        this.req.setRequestHeader("otherkey", "value");
        this.assertEquals("value", this.req._getAllRequestHeaders()["key"]);
        this.assertEquals("value", this.req._getAllRequestHeaders()["otherkey"]);
      },
      "test: get all request headers includes configuration dependent headers": function testGetAllRequestHeadersIncludesConfigurationDependentHeaders() {
        this.req.setRequestHeader("key", "value");

        this.req._getConfiguredRequestHeaders = function () {
          return {
            "otherkey": "value"
          };
        };

        this.assertEquals("value", this.req._getAllRequestHeaders()["key"]);
        this.assertEquals("value", this.req._getAllRequestHeaders()["otherkey"]);
      },
      "test: not append cache parameter to URL": function testNotAppendCacheParameterToURL() {
        this.req.send();
        var msg = "nocache parameter must not be set";
        this.assertFalse(/\?nocache/.test(this.transport.open.args[0][1]), msg);
      },
      "test: append nocache parameter to URL": function testAppendNocacheParameterToURL() {
        this.req.setCache(false);
        this.req.send();
        var msg = "nocache parameter must be set to number";
        this.assertTrue(/\?nocache=\d{13,}/.test(this.transport.open.args[0][1]), msg);
      },
      //
      // Events
      //
      "test: fire readyStateChange": function testFireReadyStateChange() {
        var req = this.req,
            readystatechange = this.spy();
        req.addListener("readyStateChange", readystatechange);
        this.respond();
        this.assertCalledOnce(readystatechange);
      },
      "test: fire success": function testFireSuccess() {
        var req = this.req,
            success = this.spy();
        req.addListener("success", success);
        this.respond();
        this.assertCalledOnce(success);
      },
      "test: not fire success on erroneous status": function testNotFireSuccessOnErroneousStatus() {
        var req = this.req,
            success = this.spy();
        req.addListener("success", success);
        this.respond(500);
        this.assertNotCalled(success);
      },
      "test: fire load": function testFireLoad() {
        var req = this.req,
            load = this.spy();
        req.addListener("load", load);
        this.respond();
        this.assertCalledOnce(load);
      },
      "test: fire loadEnd": function testFireLoadEnd() {
        var req = this.req,
            loadEnd = this.spy();
        req.addListener("loadEnd", loadEnd);
        this.respond();
        this.assertCalledOnce(loadEnd);
      },
      "test: fire abort": function testFireAbort() {
        var req = this.req,
            abort = this.spy();
        req.addListener("abort", abort);
        this.transport.onabort();
        this.assertCalledOnce(abort);
      },
      "test: fire timeout": function testFireTimeout() {
        var req = this.req,
            transport = this.transport,
            timeout = this.spy();
        req.setTimeout(100);
        req.send();
        req.addListener("timeout", timeout);
        transport.ontimeout();
        this.assertEquals(100, transport.timeout);
        this.assertCalledOnce(timeout);
      },
      "test: fire error": function testFireError() {
        var req = this.req,
            error = this.spy();
        req.addListener("error", error);
        this.respondError();
        this.assertCalledOnce(error);
      },
      "test: fire statusError": function testFireStatusError() {
        var req = this.req,
            statusError = this.spy();
        req.addListener("statusError", statusError);
        this.respond(500);
        this.assertCalledOnce(statusError);
      },
      "test: fire fail on erroneous status": function testFireFailOnErroneousStatus() {
        var req = this.req,
            fail = this.spy();
        req.addListener("fail", fail);
        this.respond(500);
        this.assertCalledOnce(fail);
      },
      "test: fire fail on network error": function testFireFailOnNetworkError() {
        var req = this.req,
            fail = this.spy();
        req.addListener("fail", fail);
        this.respondError();
        this.assertCalledOnce(fail);
      },
      "test: fire fail on timeout": function testFireFailOnTimeout() {
        var req = this.req,
            fail = this.spy();
        req.addListener("fail", fail);
        this.timeout();
        this.assertCalledOnce(fail);
      },
      "test: fire changePhase": function testFireChangePhase() {
        var req = this.req,
            that = this;
        this.assertEventFired(req, "changePhase", function () {
          that.respond();
        }, function (evt) {
          that.assertMatch(evt.getData(), "load|success");
        });
      },
      //
      // Phase
      //
      "test: phase is unsent": function testPhaseIsUnsent() {
        this.assertEquals("unsent", this.req.getPhase());
      },
      "test: phase was open before send": function testPhaseWasOpenBeforeSend() {
        var req = this.req,
            phases = [];
        req.addListener("changePhase", function () {
          phases.push(req.getPhase());
        });
        req.setUrl("/url");
        req.send();
        this.assertArrayEquals(["opened", "sent"], phases);
      },
      "test: phase is sent": function testPhaseIsSent() {
        var req = this.req;
        req.setUrl("/url");
        req.send();
        this.assertEquals("sent", req.getPhase());
      },
      "test: phase is loading": function testPhaseIsLoading() {
        var req = this.req,
            transport = this.transport;
        transport.readyState = 3;
        transport.onreadystatechange();
        this.assertEquals("loading", req.getPhase());
      },
      "test: phase is load intermediately": function testPhaseIsLoadIntermediately() {
        var req = this.req,
            transport = this.transport,
            phases = [];
        req.addListener("changePhase", function () {
          phases.push(req.getPhase());
        });
        transport.readyState = 4;
        transport.onreadystatechange(); // phases = ["load", "statusError"]

        this.assertEquals("load", phases[0]);
      },
      "test: phase is success": function testPhaseIsSuccess() {
        var req = this.req;
        this.respond();
        this.assertEquals("success", req.getPhase());
      },
      // Error handling
      "test: phase is statusError": function testPhaseIsStatusError() {
        var req = this.req;
        this.respond(500);
        this.assertEquals("statusError", req.getPhase());
      },
      "test: phase is abort": function testPhaseIsAbort() {
        var req = this.req,
            transport = this.transport;
        req.abort();
        transport.onabort(); // Transport switches to readyState DONE on abort

        transport.readyState = 4;
        transport.onreadystatechange();
        this.assertEquals("abort", req.getPhase());
      },
      "test: phase is abort when from cache": function testPhaseIsAbortWhenFromCache() {
        var req = this.req,
            transport = this.transport;
        req.abort();
        transport.onabort(); // Synchronously served from cached

        transport.status = 304; // Transport switches to readyState DONE on abort

        transport.readyState = 4;
        transport.onreadystatechange();
        this.assertEquals("abort", req.getPhase());
      },
      "test: phase is abort on readyState DONE when aborted before": function testPhaseIsAbortOnReadyStateDONEWhenAbortedBefore() {
        var req = this.req,
            transport = this.transport;
        req.addListener("readyStateChange", function () {
          if (req.getReadyState() == 4) {
            this.assertEquals("abort", req.getPhase());
          }
        }, this);
        req.send();
        req.abort(); // Transport switches to readyState DONE on abort

        transport.readyState = 4;
        transport.onreadystatechange();
        transport.onabort();
      },
      "test: phase is abort on readyState DONE when aborting loading": function testPhaseIsAbortOnReadyStateDONEWhenAbortingLoading() {
        var req = this.req,
            transport = this.transport;
        req.addListener("readyStateChange", function () {
          if (req.getReadyState() == 4) {
            this.assertEquals("abort", req.getPhase());
          }
        }, this);
        req.send(); // Loading

        transport.readyState = 3;
        transport.onreadystatechange(); // Abort loading

        req.abort(); // Transport switches to readyState DONE on abort

        transport.readyState = 4;
        transport.onreadystatechange();
        transport.onabort();
      },
      "test: phase is abort on loadEnd when aborted before": function testPhaseIsAbortOnLoadEndWhenAbortedBefore() {
        var req = this.req,
            transport = this.transport;
        req.addListener("loadEnd", function () {
          this.assertEquals("abort", req.getPhase());
        }, this);
        req.send();
        req.abort(); // Transport fires "onloadend" on abort

        transport.readyState = 4;
        transport.onloadend();
        transport.onabort();
      },
      "test: phase is timeout": function testPhaseIsTimeout() {
        var req = this.req;
        this.timeout();
        this.assertEquals("timeout", req.getPhase());
      },
      getFakeReq: function getFakeReq() {
        return this.getRequests().slice(-1)[0];
      },
      noCache: function noCache(url) {
        return qx.util.Uri.appendParamsToUrl(url, "nocache=" + new Date().valueOf());
      },
      respond: function respond(status, error) {
        var transport = this.transport;
        transport.status = typeof status === "undefined" ? 200 : status;
        transport.readyState = 4;
        transport.onreadystatechange();

        (function () {
          if (error === "timeout") {
            transport.ontimeout();
            return;
          }

          if (error === "network") {
            transport.onerror();
            return;
          }

          transport.onload();
        })();

        transport.onloadend();
      },
      respondError: function respondError() {
        this.respond(0, "network");
      },
      timeout: function timeout() {
        this.respond(0, "timeout");
      }
    }
  });
  qx.test.io.request.MRequest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.request.MRequest": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.io.request.Jsonp": {},
      "qx.bom.request.Jsonp": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /**
   * Tests asserting behavior
   *
   * - special to io.request.Jsonp and
   * - common to io.request.* (see {@link qx.test.io.request.MRequest})
   *
   * Tests defined in MRequest run with appropriate context, i.e.
   * a transport that is an instance of qx.bom.request.Jsonp
   * (see {@link #setUpFakeTransport}).
   *
   */
  qx.Class.define("qx.test.io.request.Jsonp", {
    extend: qx.dev.unit.TestCase,
    include: [qx.test.io.request.MRequest, qx.dev.unit.MMock],
    members: {
      setUp: function setUp() {
        this.setUpRequest();
        this.setUpFakeTransport();
      },
      setUpRequest: function setUpRequest() {
        this.req && this.req.dispose();
        this.req = new qx.io.request.Jsonp();
        this.req.setUrl("url");
      },
      // Also called in shared tests, i.e. shared tests
      // use appropriate transport
      setUpFakeTransport: function setUpFakeTransport() {
        this.transport = this.injectStub(qx.io.request.Jsonp.prototype, "_createTransport", this.deepStub(new qx.bom.request.Jsonp()));
        this.setUpRequest();
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();
        this.req.dispose(); // May fail in IE

        try {
          qx.Class.undefine("Klass");
        } catch (e) {}
      },
      //
      // General (cont.)
      //
      "test: set url property on construct": function testSetUrlPropertyOnConstruct() {
        var req = new qx.io.request.Jsonp("url");
        this.assertEquals("url", req.getUrl());
        req.dispose();
      },
      //
      // Callback management
      //
      "test: setCallbackParam()": function testSetCallbackParam() {
        var req = this.req,
            transport = this.transport;
        req.setCallbackParam("method");
        this.assertCalledWith(transport.setCallbackParam, "method");
      },
      "test: setCallbackName()": function testSetCallbackName() {
        var req = this.req,
            transport = this.transport;
        req.setCallbackName("myCallback");
        this.assertCalledWith(transport.setCallbackName, "myCallback");
      }
    }
  });
  qx.test.io.request.Jsonp.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.io.request.Jsonp": {},
      "qx.util.Uri": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/jsonp_primitive.php)
   */
  qx.Class.define("qx.test.io.request.JsonpWithRemote", {
    extend: qx.dev.unit.TestCase,
    include: [qx.test.io.MRemoteTest, qx.dev.unit.MRequirements],
    members: {
      setUp: function setUp() {
        this.require(["http"]);
      },
      tearDown: function tearDown() {
        this.req.dispose();
      },
      "test: fetch json": function testFetchJson() {
        var req = this.req = new qx.io.request.Jsonp(),
            url = this.noCache(this.getUrl("qx/test/jsonp_primitive.php"));
        req.addListener("load", function (e) {
          this.resume(function () {
            this.assertObject(req.getResponse());
            this.assertTrue(req.getResponse()["boolean"]);
          }, this);
        }, this);
        req.setUrl(url);
        req.send();
        this.wait();
      },
      noCache: function noCache(url) {
        return qx.util.Uri.appendParamsToUrl(url, "nocache=" + new Date().valueOf());
      }
    }
  });
  qx.test.io.request.JsonpWithRemote.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.request.MRequest": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.io.request.Xhr": {},
      "qx.io.request.authentication.Basic": {},
      "qx.util.Base64": {},
      "qx.type.BaseError": {},
      "qx.event.Registration": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /* ************************************************************************
  
  ************************************************************************ */

  /**
   * @ignore(Klass)
   * @asset(qx/test/xmlhttp/*)
   */

  /**
   * Tests asserting behavior
   *
   * - special to io.request.Xhr and
   * - common to io.request.* (see {@link qx.test.io.request.MRequest})
   *
   * Tests defined in MRequest run with appropriate context, i.e.
   * a transport that is an instance of qx.bom.request.Xhr
   * (see {@link #setUpFakeTransport}).
   *
   */
  qx.Class.define("qx.test.io.request.Xhr", {
    extend: qx.dev.unit.TestCase,
    include: [qx.test.io.request.MRequest, qx.dev.unit.MMock, qx.dev.unit.MRequirements],
    members: {
      setUp: function setUp() {
        this.setUpRequest();
        this.setUpFakeTransport();
      },
      setUpRequest: function setUpRequest() {
        this.req && this.req.dispose();
        this.req = new qx.io.request.Xhr();
        this.req.setUrl("url");
      },
      setUpFakeTransport: function setUpFakeTransport() {
        if (this.transport && this.transport.send.restore) {
          return;
        }

        this.transport = this.injectStub(qx.io.request.Xhr.prototype, "_createTransport");
        this.setUpRequest();
      },
      setUpFakeServer: function setUpFakeServer() {
        // Not fake transport
        this.getSandbox().restore();
        this.useFakeServer();
        this.setUpRequest();
        this.server = this.getServer();
        this.server.respondWith("GET", "/found", [200, {
          "Content-Type": "text/html"
        }, "FOUND"]);
        this.server.respondWith("GET", "/found.json", [200, {
          "Content-Type": "application/json; charset=utf-8"
        }, "JSON"]);
        this.server.respondWith("GET", "/found.other", [200, {
          "Content-Type": "application/other"
        }, "OTHER"]);
      },
      setUpFakeXhr: function setUpFakeXhr() {
        // Not fake transport
        this.getSandbox().restore();
        this.useFakeXMLHttpRequest();
        this.setUpRequest();
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();
        this.req.dispose(); // May fail in IE

        try {
          qx.Class.undefine("Klass");
        } catch (e) {}
      },
      //
      // General (cont.)
      //
      "test: set url property on construct": function testSetUrlPropertyOnConstruct() {
        var req = new qx.io.request.Xhr("url");
        this.assertEquals("url", req.getUrl());
        req.dispose();
      },
      "test: set method property on construct": function testSetMethodPropertyOnConstruct() {
        var req = new qx.io.request.Xhr("url", "POST");
        this.assertEquals("POST", req.getMethod());
        req.dispose();
      },
      //
      // Send (cont.)
      //
      "test: send POST request": function testSendPOSTRequest() {
        this.setUpFakeTransport();
        this.req.setMethod("POST");
        this.req.send();
        this.assertCalledWith(this.transport.open, "POST");
      },
      "test: send sync request": function testSendSyncRequest() {
        this.require(["http"]);

        this.setUpFakeTransport();
        this.req.setAsync(false);
        this.req.send();
        this.assertCalledWith(this.transport.open, "GET", "url", false);
        this.assertCalled(this.transport.send);
      },
      //
      // Data (cont.)
      //
      "test: set content type urlencoded for POST request with body when no type given": function testSetContentTypeUrlencodedForPOSTRequestWithBodyWhenNoTypeGiven() {
        this.setUpFakeTransport();
        this.req.setMethod("POST");
        this.req.setRequestData("Affe");
        this.req.send();
        this.assertCalledWith(this.transport.setRequestHeader, "Content-Type", "application/x-www-form-urlencoded");
      },
      "test: not set content type urlencoded for POST request with body when type given": function testNotSetContentTypeUrlencodedForPOSTRequestWithBodyWhenTypeGiven() {
        var msg;
        this.setUpFakeTransport();
        this.req.setMethod("POST");
        this.req.setRequestData("Affe");
        this.req.setRequestHeader("Content-Type", "application/json");
        this.req.send();
        msg = "Must not set content type urlencoded when other type given";
        this.assert(!this.transport.setRequestHeader.calledWith("Content-Type", "application/x-www-form-urlencoded"), msg);
      },
      "test: send string data with POST request": function testSendStringDataWithPOSTRequest() {
        this.setUpFakeTransport();
        this.req.setMethod("POST");
        this.req.setRequestData("str");
        this.req.send();
        this.assertCalledWith(this.transport.send, "str");
      },
      "test: send obj data with POST request": function testSendObjDataWithPOSTRequest() {
        this.setUpFakeTransport();
        this.req.setMethod("POST");
        this.req.setRequestData({
          "af fe": true
        });
        this.req.send();
        this.assertCalledWith(this.transport.send, "af+fe=true");
      },
      "test: send qooxdoo obj data with POST request": function testSendQooxdooObjDataWithPOSTRequest() {
        this.setUpFakeTransport();
        this.setUpKlass();
        var obj = new Klass();
        this.req.setMethod("POST");
        this.req.setRequestData(obj);
        this.req.send();
        this.assertCalledWith(this.transport.send, "affe=true");
        obj.dispose();
      },
      "test: send blob data with POST request": function testSendBlobDataWithPOSTRequest() {
        if (typeof window.Blob == "undefined") {
          this.skip("Blob constructor not available");
        }

        var blob = new window.Blob(['abc123'], {
          type: 'text/plain'
        });
        this.setUpFakeTransport();
        this.req.setMethod("POST");
        this.req.setRequestData(blob);
        this.req.send();
        this.assertCalledWith(this.transport.send, blob);
      },
      "test: send array buffer data with POST request": function testSendArrayBufferDataWithPOSTRequest() {
        if (typeof window.ArrayBuffer == "undefined") {
          this.skip("ArrayBuffer constructor not available");
        }

        var array = new window.ArrayBuffer(512);
        this.setUpFakeTransport();
        this.req.setMethod("POST");
        this.req.setRequestData(array);
        this.req.send();
        this.assertCalledWith(this.transport.send, array);
      },
      "test: serialize data": function testSerializeData() {
        var req = this.req,
            data = {
          "abc": "def",
          "uvw": "xyz"
        },
            contentType = "application/json";
        this.assertNull(req._serializeData(null));
        this.assertEquals("leaveMeIntact", req._serializeData("leaveMeIntact"));
        this.assertEquals("abc=def&uvw=xyz", req._serializeData(data));
        req.setRequestHeader("Content-Type", "arbitrary/contentType");
        this.assertEquals("abc=def&uvw=xyz", req._serializeData(data));
        req.setRequestHeader("Content-Type", contentType);
        this.assertEquals('{"abc":"def","uvw":"xyz"}', req._serializeData(data));
        req.setRequestHeader("Content-Type", contentType);
        this.assertEquals('[1,2,3]', req._serializeData([1, 2, 3]));
      },
      //
      // Header and Params (cont.)
      //
      "test: set requested-with header": function testSetRequestedWithHeader() {
        this.setUpFakeTransport();
        this.req.send();
        this.assertCalledWith(this.transport.setRequestHeader, "X-Requested-With", "XMLHttpRequest");
      },
      "test: not set requested-with header when cross-origin": function testNotSetRequestedWithHeaderWhenCrossOrigin() {
        this.setUpFakeTransport();
        var spy = this.transport.setRequestHeader.withArgs("X-Requested-With", "XMLHttpRequest");
        this.req.setUrl("http://example.com");
        this.req.send();
        this.assertNotCalled(spy);
      },
      "test: set cache control header": function testSetCacheControlHeader() {
        this.setUpFakeTransport();
        this.req.setCache("no-cache");
        this.req.send();
        this.assertCalledWith(this.transport.setRequestHeader, "Cache-Control", "no-cache");
      },
      "test: set accept header": function testSetAcceptHeader() {
        this.setUpFakeTransport();
        this.req.setAccept("application/json");
        this.req.send();
        this.assertCalledWith(this.transport.setRequestHeader, "Accept", "application/json");
      },
      "test: override response content type": function testOverrideResponseContentType() {
        this.setUpFakeTransport();
        this.req.overrideResponseContentType("text/plain;charset=Shift-JIS");
        this.assertCalledWith(this.transport.overrideMimeType, "text/plain;charset=Shift-JIS");
      },
      "test: get response content type": function testGetResponseContentType() {
        this.stub(this.req, "getResponseHeader");
        this.req.getResponseContentType();
        this.assertCalledWith(this.req.getResponseHeader, "Content-Type");
      },
      //
      // Handler
      //
      // Documentation only
      "test: event handler receives request": function testEventHandlerReceivesRequest() {
        this.setUpFakeTransport();
        var req = this.req,
            transport = this.transport,
            that = this;
        transport.readyState = 4;
        transport.status = 200;
        transport.responseText = "Affe";
        req.addListener("success", function (e) {
          that.assertEquals(e.getTarget(), req);
          that.assertEquals("Affe", e.getTarget().getResponseText());
        });
        transport.onreadystatechange();
      },
      // Documentation only
      "test: event handler's this is request": function testEventHandlerSThisIsRequest() {
        this.setUpFakeTransport();
        var req = this.req,
            transport = this.transport,
            that = this;
        transport.readyState = 4;
        transport.status = 200;
        transport.responseText = "Affe";
        req.addListener("success", function () {
          that.assertEquals(this, req);
          that.assertEquals("Affe", this.getResponseText());
        });
        transport.onreadystatechange();
      },
      //
      // Properties
      //
      "test: sync XHR properties for every readyState": function testSyncXHRPropertiesForEveryReadyState() {
        this.require(["http"]);

        this.setUpFakeServer();
        var req = this.req,
            server = this.server,
            readyStates = [],
            statuses = [];
        req.setUrl("/found");
        req.setMethod("GET");
        readyStates.push(req.getReadyState());
        req.addListener("readyStateChange", function () {
          readyStates.push(req.getReadyState());
          statuses.push(req.getStatus());
        }, this);
        req.send();
        server.respond();
        this.assertArrayEquals([0, 1, 2, 3, 4], readyStates);
        this.assertArrayEquals([0, 200, 200, 200], statuses);
        this.assertEquals("text/html", req.getResponseHeader("Content-Type"));
        this.assertEquals("OK", req.getStatusText());
        this.assertEquals("FOUND", req.getResponseText());
      },
      //
      // Response
      //
      "test: get response": function testGetResponse() {
        this.setUpFakeTransport();
        var req = this.req,
            transport = this.transport;
        transport.readyState = 4;
        transport.status = 200;
        transport.responseText = "Affe";
        transport.onreadystatechange();
        this.assertEquals("Affe", req.getResponse());
      },
      "test: get response on 400 status": function testGetResponseOn400Status() {
        this.setUpFakeTransport();
        var req = this.req,
            transport = this.transport;
        transport.readyState = 4;
        transport.status = 400;
        transport.responseText = "Affe";
        transport.onreadystatechange();
        this.assertEquals("Affe", req.getResponse());
      },
      "test: get response by change event": function testGetResponseByChangeEvent() {
        this.setUpFakeTransport();
        var req = this.req,
            transport = this.transport,
            that = this;
        transport.readyState = 4;
        transport.status = 200;
        transport.responseText = "Affe";
        this.assertEventFired(req, "changeResponse", function () {
          transport.onreadystatechange();
        }, function (e) {
          that.assertEquals("Affe", e.getData());
        });
      },
      //
      // Parsing
      //
      "test: _getParsedResponse": function test_getParsedResponse() {
        var req = this.req,
            json = '{"animals": 3}',
            contentType = "application/json",
            stubbedParser = req._createResponseParser();

        req._transport.responseText = json;
        this.stub(req, "getResponseContentType").returns(contentType); // replace real parser with stub

        this.stub(stubbedParser, "parse");
        req._parser = stubbedParser;

        req._getParsedResponse();

        this.assertCalledWith(stubbedParser.parse, json, contentType);
      },
      "test: setParser": function testSetParser() {
        var req = this.req,
            customParser = function customParser() {},
            stubbedParser = req._createResponseParser(); // replace real parser with stub


        this.stub(stubbedParser, "setParser");
        req._parser = stubbedParser;
        req.setParser(customParser);
        this.assertCalledWith(stubbedParser.setParser, customParser);
      },
      //
      // Auth
      //
      "test: basic auth": function testBasicAuth() {
        this.setUpFakeTransport();
        var transport = this.transport,
            auth,
            call,
            key,
            credentials;
        auth = new qx.io.request.authentication.Basic("affe", "geheim");
        this.req.setAuthentication(auth);
        this.req.send();
        call = transport.setRequestHeader.getCall(1);
        key = "Authorization";
        credentials = /Basic\s(.*)/.exec(call.args[1])[1];
        this.assertEquals(key, call.args[0]);
        this.assertEquals("affe:geheim", qx.util.Base64.decode(credentials));
      },
      //
      // Promise
      //
      "test: send with promise sends the request": function testSendWithPromiseSendsTheRequest() {
        this.req.sendWithPromise();
        this.assertCalledOnce(this.transport.send);
      },
      "test: send with promise succeeds": function testSendWithPromiseSucceeds() {
        this.setUpFakeTransport();
        var req = this.req;
        req.sendWithPromise(this).then(this.resumeHandler(function (result) {
          this.assertEquals(req, result);
          this.assertEquals(200, req.getStatus());
        }, this));
        var transport = this.transport;
        transport.readyState = 4;
        transport.status = 200;
        transport.onreadystatechange();
        this.wait(10000);
      },
      "test: send with promise fails with statusError": function testSendWithPromiseFailsWithStatusError() {
        this.setUpFakeTransport();
        var req = this.req;
        req.sendWithPromise(this).then(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "Promise has been fulfilled but should have been rejected.");
        })).catch(this.resumeHandler(function (result) {
          this.assertInstance(result, qx.type.BaseError);
          this.assertEquals("statusError: 404: Affe.", result.toString());
        }, this));
        var transport = this.transport;
        transport.readyState = 4;
        transport.status = 404;
        transport.statusText = "Affe";
        transport.onreadystatechange();
        this.wait(1000);
      },
      "test: send with promise fails with error": function testSendWithPromiseFailsWithError() {
        this.setUpFakeTransport();
        var req = this.req;
        req.sendWithPromise(this).then(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "Promise has been fulfilled but should have been rejected.");
        })).catch(this.resumeHandler(function (result) {
          this.assertInstance(result, qx.type.BaseError);
          this.assertEquals("error: Request failed.", result.toString());
        }, this));
        var transport = this.transport;
        transport.readyState = 4;
        transport.status = 0;
        transport.onerror();
        this.wait(1000);
      },
      "test: send with promise fails with timeout": function testSendWithPromiseFailsWithTimeout() {
        this.setUpFakeTransport();
        var req = this.req;
        req.sendWithPromise(this).then(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "Promise has been fulfilled but should have been rejected.");
        })).catch(this.resumeHandler(function (result) {
          this.assertInstance(result, qx.type.BaseError);
          this.assertEquals("timeout: Request failed with timeout after 1 ms.", result.toString());
        }, this));
        req.setTimeout(1);
        this.transport.ontimeout();
        this.wait(5000);
      },
      "test: setled promise has no extra listeners": function testSetledPromiseHasNoExtraListeners() {
        this.setUpFakeTransport();
        var req = this.req;
        var promise = req.sendWithPromise(this); // cache the number of listeners before setling the promise

        var listeners = qx.event.Registration.serializeListeners(req);
        promise.catch(this.resumeHandler(function () {
          var length = qx.event.Registration.serializeListeners(req).length;
          this.assertNotEquals(length, listeners.length, "The number of listeners remains the same before and after setling the promise.");
        }));
        this.transport.ontimeout();
        this.wait(5000);
      },
      "test: aborted request rejects the promise": function testAbortedRequestRejectsThePromise() {
        this.setUpFakeTransport();
        var req = this.req;
        req.sendWithPromise(this).then(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "Promise has been fulfilled but should have been rejected.");
        })).catch(this.resumeHandler(function (result) {
          this.assertInstance(result, qx.type.BaseError);
          this.assertEquals("abort: Request aborted.", result.toString());
        }, this));
        this.transport.onabort();
        this.wait(5000);
      },
      "test: parseError rejects the promise": function testParseErrorRejectsThePromise() {
        this.setUpFakeTransport();
        var req = this.req;

        var stubbedParser = req._createResponseParser(); // replace real parser with stub


        var stub = this.stub(stubbedParser, "parse");
        stub.throws();
        req._parser = stubbedParser;
        req.sendWithPromise(this).then(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "Promise has been fulfilled but should have been rejected.");
        })).catch(this.resumeHandler(function (result) {
          this.assertInstance(result, qx.type.BaseError);
          this.assertEquals("parseError: Error parsing the response.", result.toString());
        }, this));
        var transport = this.transport;
        transport.readyState = 4;
        transport.status = 200;
        transport.onreadystatechange();
        this.wait(5000);
      },
      "test: canceled promise with abort() in finally does not reject other promises": function testCanceledPromiseWithAbortInFinallyDoesNotRejectOtherPromises() {
        this.setUpFakeTransport();
        var req = this.req;
        var promise = req.sendWithPromise(this); // this path is canceled. We don't expect anything from it

        var promise1 = promise.then(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "This path should not be fulfilled.");
        }, this)).catch(this.resumeHandler(function (result) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "This path should not be rejected.");
        }, this)) // except that we want to abort when is finished
        .finally(function () {
          req.abort();
        }); // this path should keep going

        promise.then(this.resumeHandler(function (result) {
          this.assertEquals(req, result);
        }, this)).catch(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "Promise has been rejected but should have been fulfilled.");
        }, this));
        promise1.cancel();
        var transport = this.transport;
        transport.readyState = 4;
        transport.status = 200;
        transport.onreadystatechange();
        this.wait(5000);
      },
      "test: canceled promise path does not affect other listeners": function testCanceledPromisePathDoesNotAffectOtherListeners() {
        this.setUpFakeTransport();
        var req = this.req;
        var promise = req.sendWithPromise(this); // this path is canceled. We don't expect anything from it

        var promise1 = promise.then(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "promise1 should not be fulfilled.");
        })).catch(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "promise1 should not be rejected.");
        }, this)); // this path should keep going

        promise.then(this.resumeHandler(function (result) {
          this.assertEquals(req, result);
        }, this));
        promise1.cancel();
        var transport = this.transport;
        transport.readyState = 4;
        transport.status = 200;
        transport.onreadystatechange();
        this.wait(5000);
      },
      "test: canceled promise aborts pending request": function testCanceledPromiseAbortsPendingRequest() {
        this.setUpFakeTransport();
        var req = this.req;
        var promise = req.sendWithPromise(this).then(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "promise should not be fulfilled.");
        })).catch(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "promise should not be rejected.");
        })).finally(this.resumeHandler(function () {
          this.assertEquals("abort", req.getPhase());
        }));
        var transport = this.transport;
        transport.readyState = 2;
        transport.onreadystatechange();
        promise.cancel();
        this.wait(5000);
      },
      "test: settled promise does not set phase to abort": function testSettledPromiseDoesNotSetPhaseToAbort() {
        this.setUpFakeTransport();
        var req = this.req;
        req.sendWithPromise(this).then(this.resumeHandler(function (_) {
          this.assertEquals("success", req.getPhase());
        })).catch(this.resumeHandler(function (_) {
          throw new qx.type.BaseError("Error in sendWithPromise()", "promise should not be rejected.");
        })).finally(function () {
          this.assertEquals("success", req.getPhase());
        });
        var transport = this.transport;
        transport.readyState = 4;
        transport.status = 200;
        transport.onreadystatechange();
        this.wait(5000);
      },
      "test: returned promise is bound to request": function testReturnedPromiseIsBoundToRequest() {
        this.setUpFakeTransport();
        var req = this.req;
        req.sendWithPromise().catch(this.resumeHandler(function (_) {
          this.assertIdentical(req, this);
        }));
        this.transport.onerror();
        this.wait(5000);
      },
      "test: returned promise is bound to caller": function testReturnedPromiseIsBoundToCaller() {
        this.setUpFakeTransport(this);
        var self = this;
        this.req.sendWithPromise(this).catch(this.resumeHandler(function (_) {
          this.assertIdentical(self, this);
        }));
        this.transport.onerror();
        this.wait(5000);
      }
    }
  });
  qx.test.io.request.Xhr.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.io.request.Xhr": {},
      "qx.event.Timer": {},
      "qx.util.Uri": {},
      "qx.bom.client.Engine": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.io.request.XhrWithRemote", {
    extend: qx.dev.unit.TestCase,
    include: [qx.test.io.MRemoteTest, qx.dev.unit.MRequirements],
    members: {
      setUp: function setUp() {
        this.req = new qx.io.request.Xhr();

        this.require(["http"]);
      },
      tearDown: function tearDown() {
        this.req.dispose();
      },
      "test: fetch resource": function testFetchResource() {
        var req = this.req,
            url = this.noCache(this.getUrl("qx/test/xmlhttp/sample.txt"));
        req.addListener("success", function (e) {
          this.resume(function () {
            this.assertEquals("SAMPLE", e.getTarget().getResponseText());
          }, this);
        }, this);
        req.setUrl(url);
        req.send();
        this.wait();
      },
      "test: recycle request": function testRecycleRequest() {
        var req = new qx.io.request.Xhr(),
            url1 = this.noCache(this.getUrl("qx/test/xmlhttp/sample.txt") + "?1"),
            url2 = this.noCache(this.getUrl("qx/test/xmlhttp/sample.txt") + "?2"),
            count = 0;
        req.addListener("success", function () {
          count++;

          if (count == 2) {
            this.resume();
          } else {
            req.setUrl(url2);
            req.send();
          }
        }, this);
        req.setUrl(url1);
        req.send();
        this.wait();
      },
      "test: progress phases": function testProgressPhases() {
        var req = this.req,
            phases = [],
            expectedPhases = ["opened", "sent", "loading", "load", "success"],
            url = this.getUrl("qx/test/xmlhttp/sample.txt");
        req.addListener("changePhase", function () {
          phases.push(req.getPhase());

          if (req.getPhase() === "success") {
            this.resume(function () {
              this.assertArrayEquals(expectedPhases, phases);
            }, this);
          }
        }, this);
        req.setUrl(url);
        req.send();
        this.wait();
      },
      "test: progress phases when abort after send": function testProgressPhasesWhenAbortAfterSend() {
        var req = this.req,
            phases = [],
            expectedPhases = ["opened", "sent", "abort"],
            url = this.getUrl("qx/test/xmlhttp/sample.txt");
        req.addListener("changePhase", function () {
          phases.push(req.getPhase());

          if (req.getPhase() === "abort") {
            this.assertArrayEquals(expectedPhases, phases);
          }
        }, this);
        req.setUrl(url);
        req.send();
        req.abort();
      },
      "test: progress phases when abort after loading": function testProgressPhasesWhenAbortAfterLoading() {
        // Note:
        //   * Breaks on Windows 7 and OS X in every browser because the loading phase
        //     is never entered
        //   * Also breaks on Windows 10 in every browser
        this.require(["noIe", "noWin7", "noOsx", "noWin10"]);

        var req = this.req,
            phases = [],
            expectedPhases = ["opened", "sent", "loading", "abort"],
            url = this.noCache(this.getUrl("qx/test/xmlhttp/loading.php")) + "&duration=100";
        req.addListener("changePhase", function () {
          phases.push(req.getPhase());

          if (req.getPhase() === "abort") {
            this.resume(function () {
              this.assertArrayEquals(expectedPhases, phases);
            });
          }
        }, this);
        req.setUrl(url);
        req.send(); // Abort loading. Give remote some time to respond.

        qx.event.Timer.once(function () {
          req.abort();
        }, this, 500);
        this.wait();
      },
      "test: timeout": function testTimeout() {
        var req = this.req,
            url = this.noCache(this.getUrl("qx/test/xmlhttp/loading.php")) + "&duration=100";
        req.addListener("timeout", function () {
          this.resume(function () {
            this.assertEquals("timeout", req.getPhase());
          });
        }, this);
        req.setUrl(url);
        req.setTimeout(0.001);
        req.send();
        this.wait();
      },
      "test: timeout with header call": function testTimeoutWithHeaderCall() {
        var req = this.req,
            url = this.noCache(this.getUrl("qx/test/xmlhttp/loading.php")) + "&duration=100";
        req.addListener("timeout", function () {
          this.resume(function () {
            try {
              req.getResponseHeader("X-UI-My-Header");
              throw new Error("DOM exception expected!");
            } catch (ex) {}
          });
        }, this);
        req.setUrl(url);
        req.setTimeout(0.001);
        req.send();
        this.wait();
      },
      // "test: fetch resources simultaneously": function() {
      //   this.require(["php"]);
      //
      //   var count = 1,
      //       upTo = 20,
      //       startedAt = new Date(),
      //       duration = 0;
      //
      //   for (var i=0; i<upTo; i++) {
      //     var req = new qx.io.request.Xhr(),
      //         url = this.noCache(this.getUrl("qx/test/xmlhttp/loading.php")) + "&duration=6";
      //
      //     req.addListener("success", function() {
      //       this.resume(function() {
      //         // In seconds
      //         duration = (new Date() - startedAt) / 1000;
      //         this.debug("Request #" + count + " completed (" +  duration + ")");
      //         if (count == upTo) {
      //           return;
      //         }
      //
      //         ++count;
      //         this.wait(6000 + 1000);
      //       }, this);
      //     }, this);
      //
      //     req.setUrl(url);
      //     req.send();
      //   }
      //
      //   // Provided two concurrent requests are made (each 6s), 20 requests
      //   // (i.e. 10 packs of requests) should complete after 60s
      //   this.wait(60000 + 1000);
      // },
      noCache: function noCache(url) {
        return qx.util.Uri.appendParamsToUrl(url, "nocache=" + new Date().valueOf());
      },
      hasNoIe: function hasNoIe() {
        return !(qx.core.Environment.get("engine.name") == "mshtml");
      }
    }
  });
  qx.test.io.request.XhrWithRemote.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.io.request.Xhr": {},
      "qx.io.request.AbstractRequest": {},
      "qx.io.rest.Resource": {},
      "qx.lang.Function": {},
      "qx.lang.Json": {},
      "qx.core.Environment": {},
      "qx.dev.unit.RequirementError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/xmlhttp/*)
   */
  qx.Class.define("qx.test.io.rest.Resource", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements, qx.dev.unit.MMock],
    members: {
      setUp: function setUp() {
        this.setUpDoubleRequest();
        this.setUpResource();
      },
      setUpDoubleRequest: function setUpDoubleRequest() {
        // Restore Xhr when wrapped before
        if (typeof qx.io.request.Xhr.restore == "function") {
          qx.io.request.Xhr.restore();
        }

        var req = this.req = new qx.io.request.Xhr(); // Stub request methods, leave event system intact

        req = this.shallowStub(req, qx.io.request.AbstractRequest); // Inject double and return

        this.injectStub(qx.io.request, "Xhr", req); // Remember request for later disposal

        this.__reqs = this.__reqs || [];

        this.__reqs.push(this.req);

        return req;
      },
      setUpResource: function setUpResource() {
        this.res && this.res.dispose();
        var res = this.res = new qx.io.rest.Resource(); // Default routes

        res.map("get", "GET", "/photos");
        res.map("post", "POST", "/photos");
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();
        this.res.dispose();

        this.__reqs.forEach(function (req) {
          req.dispose();
        });
      },
      //
      // Configuration
      //
      "test: configure request receives pre-configured but unsent request": function testConfigureRequestReceivesPreConfiguredButUnsentRequest() {
        var res = this.res,
            req = this.req;
        res.configureRequest(qx.lang.Function.bind(function (req) {
          this.assertCalledWith(req.setMethod, "GET");
          this.assertCalled(req.setUrl, "/photos");
          this.assertNotCalled(req.send);
        }, this));
        res.get();
      },
      "test: configure request receives invocation details": function testConfigureRequestReceivesInvocationDetails() {
        var res = this.res,
            req = this.req,
            params = {},
            data = {},
            callback;
        callback = this.spy(qx.lang.Function.bind(function (req, _action, _params, _data) {
          this.assertEquals("get", _action, "Unexpected action");
          this.assertEquals(params, _params, "Unexpected params");
          this.assertEquals(data, _data, "Unexpected data");
        }, this));
        res.configureRequest(callback);
        res.get(params, data);
        this.assertCalled(callback);
      },
      //
      // Route
      //
      "test: map action": function testMapAction() {
        var res = this.res,
            params;
        params = res._getRequestConfig("get");
        this.assertEquals("GET", params.method);
        this.assertEquals("/photos", params.url);
      },
      "test: map action when base URL": function testMapActionWhenBaseURL() {
        var res = this.res,
            params;
        res.setBaseUrl("http://example.com");
        params = res._getRequestConfig("get");
        this.assertEquals("http://example.com/photos", params.url);
      },
      "test: map existing action": function testMapExistingAction() {
        var res = this.res,
            params;
        res.map("post", "GET", "/articles");
        params = res._getRequestConfig("post");
        this.assertEquals("/articles", params.url);
      },
      "test: map action creates method": function testMapActionCreatesMethod() {
        var res = this.res,
            req = this.req;
        this.assertFunction(res.get);
      },
      "test: map action throws when existing method": function testMapActionThrowsWhenExistingMethod() {
        this.require(["debug"]);

        var res = this.res,
            req = this.req; // For whatever reason

        res.popular = function () {};

        this.assertException(function () {
          res.map("popular", "GET", "/photos/popular");
        }, Error);
      },
      "test: map action does not throw when existing method is empty": function testMapActionDoesNotThrowWhenExistingMethodIsEmpty() {
        this.require(["debug"]);

        var res = this.res,
            req = this.req; // For documentation purposes

        res.get = function () {};

        res.map("get", "GET", "/photos/popular");
      },
      "test: dynamically created action forwards arguments": function testDynamicallyCreatedActionForwardsArguments() {
        var res = this.res,
            req = this.req;
        this.spy(res, "invoke");
        res.get({}, 1, 2, 3);
        this.assertCalledWith(res.invoke, "get", {}, 1, 2, 3);
      },
      "test: dynamically created action returns what invoke returns": function testDynamicallyCreatedActionReturnsWhatInvokeReturns() {
        var id = 1;
        this.stub(this.res, "invoke").returns(id);
        this.assertEquals(id, this.res.get());
      },
      "test: map actions from description": function testMapActionsFromDescription() {
        var req = this.req,
            description,
            res,
            check = {},
            params;
        description = {
          get: {
            method: "GET",
            url: "/photos"
          },
          create: {
            method: "POST",
            url: "/photos",
            check: check
          }
        };
        res = new qx.io.rest.Resource(description);
        params = res._getRequestConfig("get");
        this.assertEquals("GET", params.method);
        this.assertEquals("/photos", params.url);
        params = res._getRequestConfig("create");
        this.assertEquals("POST", params.method);
        this.assertEquals("/photos", params.url);
        this.assertEquals(check, params.check);
        res.dispose();
      },
      "test: map action from description throws with non-object": function testMapActionFromDescriptionThrowsWithNonObject() {
        this.require(["debug"]);

        this.assertException(function () {
          var res = new qx.io.rest.Resource([]);
        });
      },
      "test: map action from description throws with incomplete route": function testMapActionFromDescriptionThrowsWithIncompleteRoute() {
        this.require(["debug"]);

        this.res.dispose();
        this.assertException(function () {
          var description = {
            get: {
              method: "GET"
            }
          };
          this.res = new qx.io.rest.Resource(description);
        }, Error, "URL must be string for route 'get'");
      },
      //
      // Invoke
      //
      "test: invoke action generically": function testInvokeActionGenerically() {
        var res = this.res,
            req = this.req,
            result;
        result = res.invoke("get");
        this.assertSend();
      },
      "test: invoke action": function testInvokeAction() {
        var res = this.res,
            req = this.req;
        res.get();
        this.assertSend();
      },
      "test: invoke action returns id of request": function testInvokeActionReturnsIdOfRequest() {
        var res = this.res,
            req = this.req;
        this.assertNumber(res.invoke("get"));
      },
      "test: invoke action while other is in progress": function testInvokeActionWhileOtherIsInProgress() {
        var res = this.res,
            req1,
            req2;
        req1 = this.req;
        res.get();
        this.setUpDoubleRequest();
        req2 = this.req;
        res.post();
        this.assertCalledOnce(req1.send);
        this.assertCalledOnce(req2.send);
      },
      "test: invoke same action handles multiple requests": function testInvokeSameActionHandlesMultipleRequests() {
        var res = this.res,
            req1,
            req2,
            getSuccess = this.spy();
        res.addListener("getSuccess", getSuccess);
        req1 = this.req;
        res.get();
        this.setUpDoubleRequest();
        req2 = this.req;
        res.get();
        this.respond("", req1);
        this.respond("", req2);
        this.assertCalledTwice(getSuccess);
      },
      "test: invoke action with positional params": function testInvokeActionWithPositionalParams() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}");
        res.get({
          id: "1"
        });
        this.assertCalledWith(req.setUrl, "/photos/1");
      },
      "test: invoke action with positional params that evaluate to false": function testInvokeActionWithPositionalParamsThatEvaluateToFalse() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}");
        res.get({
          id: 0
        });
        this.assertCalledWith(req.setUrl, "/photos/0");
      },
      "test: invoke action with non-string params": function testInvokeActionWithNonStringParams() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}");
        res.get({
          id: 1
        });
        this.assertCalledWith(req.setUrl, "/photos/1");
      },
      "test: invoke action with params and data": function testInvokeActionWithParamsAndData() {
        var res = this.res,
            req = this.req;
        res.map("put", "PUT", "/articles/{id}");
        res.put({
          id: "1"
        }, {
          article: '{title: "Affe"}'
        }); // Note that with method GET, parameters are appended to the URLs query part.
        // Please refer to the API docs of qx.io.request.AbstractRequest#requestData.
        //
        // res.get({id: "1"}, {lang: "de"});
        // --> /articles/1/?lang=de

        this.assertCalledWith(req.setRequestData, {
          article: '{title: "Affe"}'
        });
      },
      "test: invoke action with multiple positional params": function testInvokeActionWithMultiplePositionalParams() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}/comments/{commentId}");
        res.get({
          id: "1",
          commentId: "2"
        });
        this.assertCalledWith(req.setUrl, "/photos/1/comments/2");
      },
      "test: invoke action with positional params in query": function testInvokeActionWithPositionalParamsInQuery() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}/comments?id={commentId}");
        res.get({
          id: "1",
          commentId: "2"
        });
        this.assertCalledWith(req.setUrl, "/photos/1/comments?id=2");
      },
      "test: invoke action with undefined params": function testInvokeActionWithUndefinedParams() {
        var res = this.res,
            req = this.req;
        res.get();
        this.assertCalled(req.send);
      },
      "test: invoke action with null params": function testInvokeActionWithNullParams() {
        var res = this.res,
            req = this.req;
        res.get(null);
        this.assertCalled(req.send);
      },
      "test: invoke action when content type json": function testInvokeActionWhenContentTypeJson() {
        var res = this.res,
            req = this.req;
        req.setRequestHeader.restore();
        req.getRequestHeader.restore();
        res.configureRequest(function (req) {
          req.setRequestHeader("Content-Type", "application/json");
        });
        this.spy(qx.lang.Json, "stringify");
        var data = {
          location: "Karlsruhe"
        };
        res.map("post", "POST", "/photos/{id}/meta");
        res.post({
          id: 1
        }, data);
        this.assertCalledWith(req.setRequestData, '{"location":"Karlsruhe"}');
        this.assertCalledWith(qx.lang.Json.stringify, data);
      },
      "test: invoke action when content type json and get": function testInvokeActionWhenContentTypeJsonAndGet() {
        var res = this.res,
            req = this.req;
        req.setMethod.restore();
        req.getMethod.restore();
        this.spy(qx.lang.Json, "stringify");
        req.getRequestHeader.withArgs("Content-Type").returns("application/json");
        res.get();
        this.assertNotCalled(qx.lang.Json.stringify);
      },
      "test: invoke action for url with port": function testInvokeActionForUrlWithPort() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "http://example.com:8080/photos/{id}");
        res.get({
          id: "1"
        });
        this.assertCalledWith(req.setUrl, "http://example.com:8080/photos/1");
      },
      "test: invoke action for relative url": function testInvokeActionForRelativeUrl() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "{page}");
        res.get({
          page: "index"
        });
        this.assertCalledWith(req.setUrl, "index");
      },
      "test: invoke action for relative url with dots": function testInvokeActionForRelativeUrlWithDots() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "../{page}");
        res.get({
          page: "index"
        });
        this.assertCalledWith(req.setUrl, "../index");
      },
      "test: invoke action for route with check": function testInvokeActionForRouteWithCheck() {
        var res = this.res;
        res.map("get", "GET", "/photos/zoom/{id}", {
          id: /\d+/
        });
        res.get({
          id: "123"
        });
        this.assertSend("GET", "/photos/zoom/123");
      },
      "test: invoke action fills in empty string when missing param and no default": function testInvokeActionFillsInEmptyStringWhenMissingParamAndNoDefault() {
        var res = this.res;
        res.map("get", "GET", "/photos/{tag}");
        res.get();
        this.assertSend("GET", "/photos/");
      },
      "test: invoke action fills in default when missing param": function testInvokeActionFillsInDefaultWhenMissingParam() {
        var res = this.res;
        res.map("get", "GET", "/photos/{tag=recent}/{size}");
        res.get({
          size: "large"
        });
        this.assertSend("GET", "/photos/recent/large");
      },
      "test: invoke action throws when missing required positional param": function testInvokeActionThrowsWhenMissingRequiredPositionalParam() {
        var res = this.res; // Require positional param

        res.map("get", "GET", "/photos/{tag}", {
          tag: qx.io.rest.Resource.REQUIRED
        });
        this.assertException(function () {
          res.get();
        }, Error, "Missing parameter 'tag'");
      },
      "test: invoke action throws when missing required request param": function testInvokeActionThrowsWhenMissingRequiredRequestParam() {
        var res = new qx.io.rest.Resource(); // Require request body param

        res.map("post", "POST", "/photos/", {
          photo: qx.io.rest.Resource.REQUIRED
        });
        this.assertException(function () {
          res.post();
        }, Error, "Missing parameter 'photo'");
      },
      "test: invoke action throws when param not match check": function testInvokeActionThrowsWhenParamNotMatchCheck() {
        var res = this.res;
        res.map("get", "GET", "/photos/{id}", {
          id: /\d+/
        });
        this.assertException(function () {
          res.get({
            id: "FAIL"
          });
        }, Error, "Parameter 'id' is invalid");
      },
      "test: invoke action ignores invalid check in production": function testInvokeActionIgnoresInvalidCheckInProduction() {
        this.require(["debug"]);

        var res = this.res;
        var setting = this.stub(qx.core.Environment, "get").withArgs("qx.debug");
        setting.returns(false); // Invalid check

        res.map("get", "GET", "/photos/{id}", {
          id: ""
        });
        res.get({
          id: 1
        });
      },
      //
      // Abort
      //
      "test: abort action": function testAbortAction() {
        var res = this.res,
            req = this.req;
        res.get();
        res.abort("get");
        this.assertCalledOnce(req.abort);
      },
      "test: abort action when multiple requests": function testAbortActionWhenMultipleRequests() {
        var res = this.res,
            req1,
            req2;
        req1 = this.setUpDoubleRequest();
        res.get();
        req2 = this.setUpDoubleRequest();
        res.get();
        res.abort("get");
        this.assertCalledOnce(req1.abort);
        this.assertCalledOnce(req2.abort);
      },
      "test: abort by action id": function testAbortByActionId() {
        var res = this.res,
            req = this.req;
        var id = res.get();
        res.abort(id);
        this.assertCalledOnce(req.abort);
      },
      //
      // Helper
      //
      "test: refresh action": function testRefreshAction() {
        var res = this.res,
            req = this.req;
        res.get();
        this.assertSend();
        res.refresh("get");
        this.assertSend();
      },
      "test: refresh action replaying previous params": function testRefreshActionReplayingPreviousParams() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}");
        res.get({
          id: "1"
        });
        this.assertSend("GET", "/photos/1");
        res.refresh("get");
        this.assertSend("GET", "/photos/1");
      },
      "test: poll action": function testPollAction() {
        var res = this.res,
            sandbox = this.getSandbox();
        sandbox.useFakeTimers();
        this.spy(res._resource, "refresh");
        res.poll("get", 10);
        this.respond();
        sandbox.clock.tick(20);
        this.assertCalledWith(res._resource.refresh, "get");
        this.assertCalledOnce(res._resource.refresh);
      },
      "test: not poll action when no response received yet": function testNotPollActionWhenNoResponseReceivedYet() {
        var res = this.res,
            sandbox = this.getSandbox();
        sandbox.useFakeTimers();
        this.spy(res, "refresh");
        res.poll("get", 10);
        sandbox.clock.tick(20);
        this.assertNotCalled(res.refresh);
      },
      "test: poll action immediately": function testPollActionImmediately() {
        var res = this.res;
        this.spy(res._resource, "invoke");
        res.poll("get", 10, undefined, true);
        this.assertCalled(res._resource.invoke);
      },
      "test: poll action sets initial params": function testPollActionSetsInitialParams() {
        var res = this.res;
        res.map("get", "GET", "/photos/{id}");
        this.stub(res._resource, "invoke");
        res.poll("get", 10, {
          id: "1"
        }, true);
        this.assertCalledWith(res._resource.invoke, "get", {
          id: "1"
        });
      },
      "test: poll action replaying previous params": function testPollActionReplayingPreviousParams() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}");
        res.get({
          id: "1"
        });
        this.assertSend("GET", "/photos/1");
        res.poll("get");
        this.assertSend("GET", "/photos/1");
      },
      "test: poll action repeatedly ends previous timer": function testPollActionRepeatedlyEndsPreviousTimer() {
        var res = this.res,
            sandbox = this.getSandbox(),
            msg;
        sandbox.useFakeTimers();
        this.stub(res._resource, "refresh");
        res.poll("get", 10);
        this.respond();
        sandbox.clock.tick(20);
        res.poll("get", 100);
        this.respond();
        sandbox.clock.tick(100);
        this.assertCalledTwice(res._resource.refresh);
      },
      "test: poll many actions": function testPollManyActions() {
        var res = this.res,
            sandbox = this.getSandbox(),
            spy,
            get,
            post;
        this.stub(this.req, "dispose");
        sandbox.useFakeTimers();
        spy = this.spy(res._resource, "refresh");
        get = spy.withArgs("get");
        post = spy.withArgs("post");
        res.poll("get", 10);
        res.poll("post", 10);
        this.respond();
        sandbox.clock.tick(20);
        this.assertCalledOnce(get);
        this.assertCalledOnce(post);
        this.req.dispose.restore();
        this.req.dispose();
      },
      "test: end poll action": function testEndPollAction() {
        var res = this.res,
            sandbox = this.getSandbox(),
            timer;
        sandbox.useFakeTimers();
        this.spy(res._resource, "refresh");
        timer = res.poll("get", 10);
        this.respond(); // 10ms invoke, 20ms refresh, 30ms refresh

        sandbox.clock.tick(30);
        timer.stop();
        sandbox.clock.tick(100);
        this.assertCalledTwice(res._resource.refresh);
      },
      "test: end poll action does not end polling of other action": function testEndPollActionDoesNotEndPollingOfOtherAction() {
        var res = this.res,
            sandbox = this.getSandbox(),
            timer,
            spy;
        sandbox.useFakeTimers();
        spy = this.spy(res._resource, "refresh").withArgs("get");
        this.respond();
        res.poll("get", 10);
        timer = res.poll("post", 10);
        sandbox.clock.tick(20);
        timer.stop();
        sandbox.clock.tick(10);
        this.assertCalledTwice(spy);
      },
      "test: restart poll action": function testRestartPollAction() {
        var res = this.res,
            sandbox = this.getSandbox(),
            timer;
        sandbox.useFakeTimers();
        this.respond();
        timer = res.poll("get", 10);
        sandbox.clock.tick(10);
        timer.stop();
        this.spy(res._resource, "refresh");
        timer.restart();
        sandbox.clock.tick(10);
        this.assertCalled(res._resource.refresh);
      },
      "test: long poll action": function testLongPollAction() {
        var res = this.res,
            req = this.req,
            responses = [];
        this.stub(req, "dispose");
        res.addListener("getSuccess", function (e) {
          responses.push(e.getData());
        }, this);
        res.longPoll("get"); // longPoll() sets up new request when receiving a response

        this.respond("1");
        this.respond("2");
        this.respond("3");
        this.assertArrayEquals(["1", "2", "3"], responses);
      },
      "test: throttle long poll": function testThrottleLongPoll() {
        var res = this.res,
            req = this.req;
        this.stub(req, "dispose");
        this.spy(res, "refresh");
        this.stub(qx.io.rest.Resource, "POLL_THROTTLE_COUNT", "3");
        res.longPoll("get"); // A number of immediate responses, above count

        for (var i = 0; i < 4; i++) {
          this.respond();
        }

        res.refresh = function () {
          throw new Error("With throttling in effect, must not make new request.");
        }; // Throttling


        this.respond();
      },
      "test: not throttle long poll when not received within limit": function testNotThrottleLongPollWhenNotReceivedWithinLimit() {
        var res = this.res,
            req = this.req,
            sandbox = this.getSandbox();
        this.stub(req, "dispose");
        sandbox.useFakeTimers();
        res.longPoll("get"); // A number of delayed responses, above count

        for (var i = 0; i < 31; i++) {
          sandbox.clock.tick(101);
          this.respond();
        }

        this.spy(res, "refresh");
        sandbox.clock.tick(101);
        this.respond();
        this.assertCalled(res.refresh);
      },
      "test: not throttle long poll when not received subsequently": function testNotThrottleLongPollWhenNotReceivedSubsequently() {
        var res = this.res,
            req = this.req,
            sandbox = this.getSandbox();
        this.stub(req, "dispose");
        sandbox.useFakeTimers();
        res.longPoll("get"); // A number of immediate responses

        for (var i = 0; i < 30; i++) {
          this.respond();
        } // Delayed response


        sandbox.clock.tick(101);
        this.respond(); // More immediate responses, total count above limit

        this.spy(res, "refresh");

        for (i = 0; i < 10; i++) {
          this.respond();
        }

        this.assertCallCount(res.refresh, 10);
      },
      "test: end long poll action": function testEndLongPollAction() {
        var res = this.res,
            req = this.req,
            handlerId,
            msg;
        this.stub(req, "dispose");
        this.spy(res._resource, "refresh");
        handlerId = res.longPoll("get");
        this.respond();
        this.respond();
        res.removeListenerById(handlerId);
        this.respond();
        this.assertCalledTwice(res._resource.refresh);
      },
      //
      // Events
      //
      "test: fire actionSuccess": function testFireActionSuccess() {
        var res = this.res,
            req = this.req,
            that = this;
        res.get();
        this.assertEventFired(res, "getSuccess", function () {
          that.respond("Affe");
        }, function (e) {
          that.assertEquals("Affe", e.getData());
          that.assertEquals("get", e.getAction());
          that.assertIdentical(req, e.getRequest());
          that.assertInteger(e.getId());
        });
      },
      "test: fire success": function testFireSuccess() {
        var res = this.res,
            req = this.req,
            that = this;
        res.get();
        this.assertEventFired(res, "success", function () {
          that.respond("Affe");
        }, function (e) {
          that.assertEquals("Affe", e.getData());
          that.assertEquals("get", e.getAction());
          that.assertIdentical(req, e.getRequest());
          that.assertInteger(e.getId());
        });
      },
      "test: fire actionError": function testFireActionError() {
        var res = this.res,
            req = this.req,
            that = this;
        res.get();
        this.assertEventFired(res, "getError", function () {
          that.respondError("statusError");
        }, function (e) {
          that.assertEquals("statusError", e.getPhase());
          that.assertIdentical(req, e.getRequest());
        });
      },
      "test: fire error": function testFireError() {
        var res = this.res,
            req = this.req,
            that = this;
        res.get();
        this.assertEventFired(res, "error", function () {
          that.respondError("statusError");
        }, function (e) {
          that.assertEquals("statusError", e.getPhase());
          that.assertIdentical(req, e.getRequest());
        });
      },
      //
      // Dispose
      //
      "test: dispose requests": function testDisposeRequests() {
        var res = this.res,
            req1,
            req2;
        req1 = this.req;
        res.get();
        this.setUpDoubleRequest();
        req2 = this.req;
        res.post();
        this.spy(req1, "dispose");
        this.spy(req2, "dispose");
        res.dispose();
        this.assertCalled(req1.dispose);
        this.assertCalled(req2.dispose);
      },
      "test: dispose requests of same action": function testDisposeRequestsOfSameAction() {
        var res = this.res,
            req1,
            req2;
        req1 = this.req;
        res.get();
        this.setUpDoubleRequest();
        req2 = this.req;
        res.get();
        this.spy(req1, "dispose");
        this.spy(req2, "dispose");
        res.dispose();
        this.assertCalled(req1.dispose);
        this.assertCalled(req2.dispose);
      },
      "test: dispose request on loadEnd": function testDisposeRequestOnLoadEnd() {
        var res = this.res,
            req = this.req;
        this.spy(req, "dispose");
        res.get();
        this.respond();
        setTimeout(function () {
          this.resume(function () {
            this.assertCalledOnce(req.dispose);
          }, this);
        }.bind(this), 100);
        this.wait();
      },
      assertSend: function assertSend(method, url) {
        var req = this.req;
        method = method || "GET";
        url = url || "/photos";
        this.assertCalledWith(req.setMethod, method);
        this.assertCalledWith(req.setUrl, url);
        this.assertCalled(req.send);
      },
      skip: function skip(msg) {
        throw new qx.dev.unit.RequirementError(null, msg);
      },
      hasDebug: function hasDebug() {
        return true;
      },
      // Fake response
      respond: function respond(response, req) {
        var req = req || this.req;
        response = response || "";
        req.isDone.returns(true);
        req.getPhase.returns("success");
        req.getResponse.returns(response);
        req.fireEvent("success");
        req.fireEvent("loadEnd");
      },
      // Fake erroneous response
      respondError: function respondError(phase) {
        var req = this.req;
        phase = phase || "statusError";
        req.getPhase.returns(phase);
        req.fireEvent("fail");
        req.fireEvent("loadEnd");
      }
    }
  });
  qx.test.io.rest.Resource.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.io.rest.Resource": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/xmlhttp/random.php)
   * @asset(qx/test/xmlhttp/long_poll.php)
   * @asset(qx/test/xmlhttp/sample.txt)
   */
  qx.Class.define("qx.test.io.rest.ResourceWithRemote", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements, qx.test.io.MRemoteTest],
    members: {
      setUp: function setUp() {
        this.require(["http"]);

        this.res = new qx.io.rest.Resource();
      },
      tearDown: function tearDown() {
        this.res.dispose();
      },
      "test: invoke action and handle response": function testInvokeActionAndHandleResponse() {
        // Handles GET
        var url = this.getUrl("qx/test/xmlhttp/sample.txt"),
            res = this.res;
        res.map("get", "GET", url);
        res.addListener("getSuccess", function (e) {
          this.resume(function () {
            this.assertEquals("SAMPLE", e.getData());
          }, this);
        }, this);
        res.get();
        this.wait();
      },
      "test: invoke action and handle failure": function testInvokeActionAndHandleFailure() {
        this.require(["http"]);

        var url = "/not-found",
            res = this.res;
        res.map("get", "GET", url);
        res.addListener("error", function (e) {
          this.resume(function () {
            this.assertEquals("statusError", e.getPhase());
            this.assertEquals("get", e.getAction());
          }, this);
        }, this);
        res.get();
        this.wait();
      },
      "test: poll action": function testPollAction() {
        // Handles GET
        var url = this.getUrl("qx/test/xmlhttp/random.php"),
            res = this.res,
            count = 0,
            previousResponse = "";
        res.map("get", "GET", url); // Response headers must contain explicit cache control for this
        // to work in IE

        res.addListener("getSuccess", function (e) {
          var response = e.getData();
          count++;
          this.assert(response.length === 32, "Response must be MD5");
          this.assertNotEquals(previousResponse, response, "Response must be different from previous");
          previousResponse = response;

          if (count >= 10) {
            this.resume();
          }
        }, this);
        res.poll("get", 100);
        this.wait();
      },
      "test: long poll": function testLongPoll() {
        var res = this.res,
            url = this.getUrl("qx/test/xmlhttp/long_poll.php"),
            count = 0,
            responses = [];
        res.map("get", "GET", url);
        res.addListener("getSuccess", function (e) {
          var response = e.getData();
          responses.push(response);

          if (++count >= 5) {
            this.resume(function () {
              this.assert(parseFloat(responses[4]) > parseFloat(responses[0]), "Must increase");
            }, this);
          }
        }, this);
        res.longPoll("get");
        this.wait();
      }
    }
  });
  qx.test.io.rest.ResourceWithRemote.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.lang.Array": {},
      "qx.data.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.lang.Array", {
    extend: qx.dev.unit.TestCase,
    members: {
      /**
       * Array tests
       *
       */
      testAppend: function testAppend() {
        this.assertNotUndefined(qx.lang.Array.append);
        var a = [1, 2, 3];
        qx.lang.Array.append(a, [4, 5, 6]);
        this.assertJsonEquals(a, [1, 2, 3, 4, 5, 6]);
        var a = [1, 2, 3];
        qx.lang.Array.append(a, new qx.data.Array([4, 5, 6]));
        this.assertJsonEquals(a, [1, 2, 3, 4, 5, 6]);
        var a = new qx.data.Array([1, 2, 3]);
        qx.lang.Array.append(a, [4, 5, 6]);
        this.assertJsonEquals(a.toArray(), [1, 2, 3, 4, 5, 6]);
        a.dispose();
        var error = false;

        try {
          qx.lang.Array.append(a, 1);
        } catch (ex) {
          error = true;
        }

        this.assert(error);
      },
      testExclude: function testExclude() {
        var a = [1, 2, 3, 4, 5];
        qx.lang.Array.exclude(a, [2, 4]);
        this.assertJsonEquals([1, 3, 5], a);
        var a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        qx.lang.Array.exclude(a, [1, 2, 3]);
        this.assertJsonEquals([0, 4, 5, 6, 7, 8, 9], a);
        var a = [1, 2, 3, 4, 5];
        qx.lang.Array.exclude(a, new qx.data.Array([1, 3, 5]));
        this.assertJsonEquals([2, 4], a);
        var a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        qx.lang.Array.exclude(a, new qx.data.Array([1, 2, 3]));
        this.assertJsonEquals([0, 4, 5, 6, 7, 8, 9], a);
        var a = new qx.data.Array([1, 2, 3, 4, 5]);
        qx.lang.Array.exclude(a, [1, 3, 5]);
        this.assertJsonEquals([2, 4], a.toArray());
        a.dispose();
        var a = new qx.data.Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
        qx.lang.Array.exclude(a, [1, 2, 3]);
        this.assertJsonEquals([0, 4, 5, 6, 7, 8, 9], a.toArray());
        a.dispose();
      },
      testMinNumeric: function testMinNumeric() {
        var a = [-3, -2, -1, 0, 1, 2, 3];
        var result = qx.lang.Array.min(a);
        this.assertEquals(-3, result);
      },
      testMaxNumeric: function testMaxNumeric() {
        var a = [-3, -2, -1, 0, 1, 2, 3];
        var result = qx.lang.Array.max(a);
        this.assertEquals(3, result);
      },
      testMinMixed: function testMinMixed() {
        var a = [-3, -2, -1, 0, 1, 2, 3, 'foo', 'bar', undefined, null];
        var result = qx.lang.Array.min(a);
        this.assertEquals(-3, result);
      },
      testMaxMixed: function testMaxMixed() {
        var a = [-3, -2, -1, 0, 1, 2, 3, 'foo', 'bar', undefined, null];
        var result = qx.lang.Array.max(a);
        this.assertEquals(3, result);
      },
      testMinEmpty: function testMinEmpty() {
        var a = [];
        var result = qx.lang.Array.min(a);
        this.assertEquals(null, result);
      },
      testMaxEmpty: function testMaxEmpty() {
        var a = [];
        var result = qx.lang.Array.max(a);
        this.assertEquals(null, result);
      },
      testRemove: function testRemove() {
        var a = [-3, -2, -1, 0, 1, 2, 3];
        qx.lang.Array.remove(a, 2);
        this.assertJsonEquals(a, [-3, -2, -1, 0, 1, 3]);
        this.assertEquals(6, a.length);
        var da = new qx.data.Array([-3, -2, -1, 0, 1, 2, 3]);
        qx.lang.Array.remove(da, 2);
        this.assertJsonEquals(da.toArray(), [-3, -2, -1, 0, 1, 3]);
        this.assertEquals(6, da.length);
      },
      testRemoveAt: function testRemoveAt() {
        var a = [-3, -2, -1, 0, 1, 2, 3];
        qx.lang.Array.removeAt(a, 3);
        this.assertJsonEquals(a, [-3, -2, -1, 1, 2, 3]);
        this.assertEquals(6, a.length);
      },
      testRemoveAll: function testRemoveAll() {
        var a = [-3, -2, -1, 0, 1, 2, 3];
        qx.lang.Array.removeAll(a);
        this.assertJsonEquals(a, []);
        this.assertEquals(0, a.length);
      },
      testContains: function testContains() {
        var a = [-3, -2, -1, 0, 1, 2, 3];
        var da = new qx.data.Array(a);
        this.assertTrue(a.includes(-2));
        this.assertFalse(a.includes(-10));
        this.assertTrue(da.includes(-2));
        this.assertFalse(da.includes(-10));
        da.dispose();
      },
      testEquals: function testEquals() {
        var a = [-3, -2, -1, 0, 1, 2, 3];
        var da = new qx.data.Array(a);
        this.assertFalse(da.toArray() === a);
        this.assertTrue(qx.lang.Array.equals(a, da));
        this.assertTrue(qx.lang.Array.equals(da, a));
        this.assertFalse(qx.lang.Array.equals(a, [4, 5, 6]));
      },
      testReplace: function testReplace() {
        var a = [1, 2, 3];
        var tmp = qx.lang.Array.replace(a, ["one", "two", "three"]);
        this.assertTrue(a === tmp);
        this.assertArrayEquals(["one", "two", "three"], a);
      },
      testToNativeArray: function testToNativeArray() {
        var da = new qx.data.Array([1, 2, 3]);
        var na = qx.lang.Array.toNativeArray(da);
        this.assertTrue(da.toArray() === na);
        na = qx.lang.Array.toNativeArray(da, true);
        this.assertTrue(da.toArray() !== na);
        this.assertArrayEquals([1, 2, 3], na);
      }
    }
  });
  qx.test.lang.Array.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.lang.Function": {},
      "qx.core.Object": {},
      "qx.core.AssertionError": {},
      "qx.event.GlobalError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.Name.*)
   */
  qx.Class.define("qx.test.lang.Function", {
    extend: qx.dev.unit.TestCase,
    members: {
      testGlobalEval: function testGlobalEval() {
        qx.lang.Function.globalEval("var JUHU=12;");
        this.assertEquals(12, window.JUHU);

        try {
          delete window.JUHU;
        } catch (e) {
          window.JUHU = null;
        }
      },
      testFunctionWrap: function testFunctionWrap() {
        var context = null;
        var result = 0;

        var add = function add(a, b) {
          context = this;
          return a + b;
        };

        context = null;
        result = add(1, 2);
        this.assertEquals(context, window);
        this.assertEquals(3, result);
        context = null;
        var boundAdd = qx.lang.Function.bind(add, this);
        result = boundAdd(1, 3);
        this.assertEquals(context, this);
        this.assertEquals(4, result);
        context = null;
        var addOne = qx.lang.Function.bind(add, this, 1);
        result = addOne(4);
        this.assertEquals(context, this);
        this.assertEquals(5, result);
      },
      testBindWithDisposedContext: function testBindWithDisposedContext() {
        if (!this.isDebugOn()) {
          return;
        }

        var obj = new qx.core.Object();
        obj.dispose();

        var callback = function callback() {};

        var bound = qx.lang.Function.bind(callback, obj);
        this.assertException(function () {
          bound();
        }, qx.core.AssertionError);
      },
      testBindWithUndefinedArguments: function testBindWithUndefinedArguments() {
        var undef;

        var callback = function callback(undef, arg) {
          this.assertTrue(arg);
        };

        var bound = qx.lang.Function.bind(callback, this, undef, true);
        bound();
      },
      testCreateDelayGlobalError: function testCreateDelayGlobalError() {
        var fail = function fail() {
          throw new Error("fail");
        };

        var onError = function onError() {
          this.resume(function () {
            qx.event.GlobalError.setErrorHandler(null, null);
          });
        };

        qx.event.GlobalError.setErrorHandler(onError, this);
        var delayed = qx.lang.Function.create(fail, {
          self: this,
          delay: 20
        });
        delayed();
        this.wait(100);
      },
      testGetName: function testGetName() {
        qx.Class.define("qx.test.Name", {
          extend: qx.core.Object,
          construct: function construct() {},
          properties: {
            prop: {}
          },
          statics: {
            foo: function foo() {}
          },
          members: {
            bar: function bar() {}
          },
          destruct: function destruct() {}
        });
        var name = new qx.test.Name();
        this.assertEquals("qx.test.Name.constructor()", qx.lang.Function.getName(qx.test.Name));
        this.assertEquals("qx.test.Name.destruct()", qx.lang.Function.getName(qx.test.Name.$$destructor));
        name.setProp(1);
        name.getProp();
        this.assertEquals("qx.test.Name.prototype.setProp()", qx.lang.Function.getName(name.setProp));
        this.assertEquals("qx.test.Name.prototype.getProp()", qx.lang.Function.getName(name.getProp));
        this.assertEquals("qx.test.Name.foo()", qx.lang.Function.getName(qx.test.Name.foo));
        this.assertEquals("qx.test.Name.prototype.bar()", qx.lang.Function.getName(name.bar));
        this.assertEquals("anonymous()", qx.lang.Function.getName(function () {}));

        function named() {}

        ; // the variable optimizer renames the "named" function. Only perform this
        // test if variable optimization is off.

        if (named.toString().indexOf("named") !== -1) {
          this.assertEquals("named()", qx.lang.Function.getName(named));
        }
      }
    }
  });
  qx.test.lang.Function.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.lang.Json": {},
      "qx.dev.unit.RequirementError": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "engine.version": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.lang.Json", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        // Test either native (when available) or emulated JSON,
        // see [BUG #5037]
        this.JSON = qx.lang.Json;
      },
      testStringifyArray: function testStringifyArray() {
        var text = this.JSON.stringify(['e', {
          pluribus: 'unum'
        }]);
        this.assertEquals('["e",{"pluribus":"unum"}]', text);
      },
      testFormattingString: function testFormattingString() {
        var str = this.JSON.stringify(['e', {
          pluribus: 'unum'
        }], null, '\t');
        var expected = /[\n\t"e",\n\t{\n\t\t"pluribus":\s?"unum"\n\t}\n]/;
        this.assertMatch(str, expected);
      },
      testFormattingNumber: function testFormattingNumber() {
        var str = this.JSON.stringify(['e', {
          pluribus: 'unum'
        }], null, 2);
        var expected = /[\n  "e",\n  {\n    "pluribus":\s"unum"\n  }\n]/;
        this.assertMatch(str, expected);
      },
      testReplacer: function testReplacer() {
        var obj = [new Date(0), "foo"];
        var self = this;

        var replacer = function replacer(key, value) {
          return this[key] instanceof Date ? 'Date(' + this[key].getTime() + ')' : value;
        };

        var json = this.JSON.stringify(obj, replacer);
        this.assertEquals('["Date(0)","foo"]', json);
      },
      // Uncovers browser bug found in Firefox >=3.5 && < 4, see
      // https://bugzilla.mozilla.org/show_bug.cgi?id=509184
      testReplacerNestedObject: function testReplacerNestedObject() {
        var obj = {
          "prop": "value"
        };

        var replacer = function replacer(key, value) {
          if (value == "value") {
            return "replaced";
          }

          return value;
        };

        var json = this.JSON.stringify(obj, replacer);
        this.assertMatch(json, /replaced/);
      },
      testReplacerWhiteList: function testReplacerWhiteList() {
        var list = ["name"];
        var text = this.JSON.stringify({
          name: "Peter",
          last: "Pan"
        }, list);
        this.assertEquals('{"name":"Peter"}', text);
      },
      testStringifyObject: function testStringifyObject() {
        this.assertEquals('{"test":123}', this.JSON.stringify({
          test: 123
        }));
      },
      testStringifyDate: function testStringifyDate() {
        var data = {
          start: new Date(0)
        };
        this.assertMatch(this.JSON.stringify(data), new RegExp('\{"start":"1970\-01\-01T00:00:00\(\.0*)?Z"\}'));
      },
      testCustomDateSerializer: function testCustomDateSerializer() {
        var date = new Date(0);

        date.toJSON = function (key) {
          return this.valueOf();
        };

        var result = this.JSON.stringify(date); // Expected '0' but found '0'! in Opera
        // this.assertEquals("0", result);

        this.assert("0".charCodeAt() == result.charCodeAt());
      },
      testToJson: function testToJson() {
        var obj = {
          toJSON: function toJSON(key) {
            return "##";
          }
        };
        this.assertEquals('"##"', this.JSON.stringify(obj));
      },
      testToJsonKey: function testToJsonKey() {
        // Known to fail in some browsers:
        //
        // Firefox: toJSON is passed no parameter, i.e. key is undefined
        //          undefined + "" is "undefined" in Firefox
        //
        // IE 8:    toJSON is passed the string "\u0082\u0000\u0000\u0000",
        //          which is the equivalent of "BREAK PERMITTED HERE" and two
        //          "NUL".
        //
        if (this.isFirefox() || this.isIe8()) {
          throw new qx.dev.unit.RequirementError();
        }

        var obj = {
          toJSON: function toJSON(key) {
            return "#" + key + "#";
          }
        };
        var str = this.JSON.stringify({
          juhu: obj
        });
        this.assertMatch(str, /#juhu#/);
      },
      testStringifyRecursiveObject: function testStringifyRecursiveObject() {
        var obj = {};
        obj.foo = obj;
        this.assertException(function () {
          var text = this.JSON.stringify(obj);
        });
        obj = [];
        obj[0] = obj;
        this.assertException(function () {
          var text = this.JSON.stringify(obj);
        });
      },
      testIgnoreNamedPropertiesInArrays: function testIgnoreNamedPropertiesInArrays() {
        var data = [1, "foo"];
        data.juhu = "kinners"; // must be ignored

        this.assertEquals('[1,"foo"]', this.JSON.stringify(data));
      },
      testIgnoreFunction: function testIgnoreFunction() {
        var data = {
          juhu: "kinners",
          foo: function foo() {}
        };
        this.assertEquals('{"juhu":"kinners"}', this.JSON.stringify(data));
      },
      testSimpleParse: function testSimpleParse() {
        var data = this.JSON.parse('{"juhu":"kinners","age":23,"foo":[1,2,3]}'); // check keys

        this.assertEquals(["juhu", "foo", "age"].sort().toString(), Object.keys(data).sort().toString()); // check values

        this.assertEquals("kinners", data.juhu);
        this.assertEquals(23, data.age);
        this.assertArrayEquals([1, 2, 3], data.foo);
      },
      testParseNumber: function testParseNumber() {
        this.assertEquals(1234, this.JSON.parse("1234"));
        this.assertEquals(1234, this.JSON.parse(" 1234"));
      },
      testParseRevive: function testParseRevive() {
        var json = '{"prop": "value"}';
        var obj = this.JSON.parse(json, function (key, value) {
          if (value == "value") {
            return "revived";
          }

          return value;
        });
        this.assertEquals("revived", obj.prop);
      },
      isIe8: function isIe8() {
        return qx.core.Environment.get("engine.name") === "mshtml" && (qx.core.Environment.get("engine.version") == 8 || qx.core.Environment.get("browser.documentmode") == 8);
      },
      isFirefox: function isFirefox() {
        return qx.core.Environment.get("engine.name") === "gecko";
      }
    }
  });
  qx.test.lang.Json.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.lang.Number": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Markus Bader (mbgonicus)
  
  ************************************************************************ */
  qx.Class.define("qx.test.lang.Number", {
    extend: qx.dev.unit.TestCase,
    members: {
      testEquals: function testEquals() {
        this.assertNotUndefined(qx.lang.Number);
        this.assertFunction(qx.lang.Number.equals); // Check integers

        this.assertTrue(qx.lang.Number.equals(1, 1));
        this.assertFalse(qx.lang.Number.equals(1, 0)); // Check floats

        this.assertTrue(qx.lang.Number.equals(1.5, 1.5));
        this.assertTrue(qx.lang.Number.equals(0.30000000000000004, 0.3));
        this.assertFalse(qx.lang.Number.equals(1.5, 1.500000001));
      }
    }
  });
  qx.test.lang.Number.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.lang.Object": {},
      "qx.core.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.lang.Object", {
    extend: qx.dev.unit.TestCase,
    members: {
      testObject: function testObject() {
        this.assertNotUndefined(qx.lang.Object);
      },
      testEmpty: function testEmpty() {
        var object = {
          a: 1
        };
        qx.lang.Object.empty(object);
        this.assertTrue(qx.lang.Object.isEmpty(object));
        var object = {};
        qx.lang.Object.empty(object);
        this.assertTrue(qx.lang.Object.isEmpty(object));
      },
      testIsEmpty: function testIsEmpty() {
        this.assertEquals(true, qx.lang.Object.isEmpty({}));
        this.assertEquals(false, qx.lang.Object.isEmpty({
          a: undefined
        }));
        this.assertEquals(false, qx.lang.Object.isEmpty({
          a: null
        }));
        this.assertEquals(false, qx.lang.Object.isEmpty({
          a: 1
        }));
      },
      testGetLength: function testGetLength() {
        var object = {};
        this.assertEquals(0, qx.lang.Object.getLength(object));
        var object = {
          a: 1
        };
        this.assertEquals(1, qx.lang.Object.getLength(object));
        var object = {
          a: undefined,
          b: null,
          c: 1
        };
        this.assertEquals(3, qx.lang.Object.getLength(object));
      },
      testGetKeys: function testGetKeys() {
        var object = {
          a: undefined,
          b: null,
          c: 1
        };
        this.assertArrayEquals(["a", "b", "c"].sort(), Object.keys(object).sort());
        var object = {};
        this.assertArrayEquals([], Object.keys(object));
        var object = {
          "isPrototypeOf": 1,
          "hasOwnProperty": 1,
          "toLocaleString": 1,
          "toString": 1,
          "valueOf": 1
        };
        this.assertArrayEquals(["isPrototypeOf", "hasOwnProperty", "toLocaleString", "toString", "valueOf"].sort(), Object.keys(object).sort());
      },
      testGetValues: function testGetValues() {
        var object = {
          a: undefined,
          b: null,
          c: 1
        };
        this.assertArrayEquals([undefined, null, 1].sort(), qx.lang.Object.getValues(object).sort());
        var object = {};
        this.assertArrayEquals([], qx.lang.Object.getValues(object));
        var object = {
          "isPrototypeOf": 1,
          "hasOwnProperty": 2,
          "toLocaleString": 3,
          "toString": 4,
          "valueOf": 5
        };
        this.assertArrayEquals([1, 2, 3, 4, 5].sort(), qx.lang.Object.getValues(object).sort());
      },
      testMergeWith: function testMergeWith() {
        var original = {
          a: 0
        };
        var o1 = {
          a: 2,
          b: 1
        };
        qx.lang.Object.mergeWith(original, o1, true); // check the original

        this.assertEquals(2, original.a);
        this.assertEquals(1, original.b);
      },
      testMergeWithCarefully: function testMergeWithCarefully() {
        var original = {
          a: 0
        };
        var o1 = {
          a: 2,
          b: 1
        };
        qx.lang.Object.mergeWith(original, o1, false); // check the original

        this.assertEquals(0, original.a);
        this.assertEquals(1, original.b);
      },
      testClone: function testClone() {
        var original = {
          a: 12,
          b: true,
          c: "affe"
        };
        var clone = qx.lang.Object.clone(original);
        clone.a = 14;
        original.b = false;
        clone.c = "AFFE"; // check the original

        this.assertEquals(12, original.a);
        this.assertEquals(false, original.b);
        this.assertEquals("affe", original.c); // check the clone

        this.assertEquals(14, clone.a);
        this.assertEquals(true, clone.b);
        this.assertEquals("AFFE", clone.c);
      },
      testCloneDeep: function testCloneDeep() {
        var original = {
          a: {
            b: 0
          }
        };
        var clone = qx.lang.Object.clone(original, true); // change the original

        original.a.b = 1;
        this.assertEquals(0, clone.a.b);
        original = {
          a: [{
            b: 0
          }]
        };
        clone = qx.lang.Object.clone(original, true); // change the original

        original.a[0].b = 1;
        this.assertEquals(0, clone.a[0].b);
        original = [];
        original.push({
          a: {
            b: 0
          }
        });
        clone = qx.lang.Object.clone(original, true);
        this.assertEquals(0, clone[0].a.b);
        original[0].a.b = 1;
        this.assertEquals(0, clone[0].a.b);
      },
      testInvert: function testInvert() {
        this.assertNotUndefined(qx.lang.Object.invert);
        var Obj = qx.lang.Object;
        this.assertJsonEquals({
          a: "1",
          "2": "b"
        }, Obj.invert({
          1: "a",
          b: 2
        }));
      },
      testGetKeyFromValue: function testGetKeyFromValue() {
        var obj = {
          a: 123
        };
        this.assertEquals("a", qx.lang.Object.getKeyFromValue(obj, 123));
      },
      testContains: function testContains() {
        this.assertTrue(qx.lang.Object.contains({
          a: 1
        }, 1));
      },
      testFromArray: function testFromArray() {
        var array = ["a", "b"];
        var obj = qx.lang.Object.fromArray(array);
        this.assertTrue(obj.a);
        this.assertTrue(obj.b);
      },

      /**
       * Some behavior, which must be consistent in all browsers for some
       * assertions to work.
       */
      testObjectAssertions: function testObjectAssertions() {
        var objConstructor = {}.constructor;
        this.assertIdentical({
          a: 12
        }.constructor, objConstructor);
        this.assertIdentical(new Object().constructor, objConstructor);
        var qxObj = new qx.core.Object();
        this.assertNotIdentical(qxObj.constructor, objConstructor);
        this.assertNotIdentical(1 .constructor, objConstructor);
        this.assertNotIdentical("Juhu".constructor, objConstructor);
        this.assertNotIdentical(/abc/.constructor, objConstructor);
        qxObj.dispose();
      },
      testEquals: function testEquals() {
        var a = {
          a: 'text',
          b: [0, 1]
        };
        var b = {
          a: 'text',
          b: [0, 1]
        };
        var c = {
          a: 'text',
          b: 0
        };
        var d = {
          a: 'text',
          b: false
        };
        var e = {
          a: 'text',
          b: [1, 0]
        };
        var f = {
          a: 'text',
          b: [1, 0],
          f: function f() {
            this.f = this.b;
          }
        };
        var g = {
          a: 'text',
          b: [1, 0],
          f: function f() {
            this.f = this.b;
          }
        };
        var h = {
          a: 'text',
          b: [1, 0],
          f: function f() {
            this.a = this.b;
          }
        };
        var i = {
          a: 'text',
          c: {
            b: [1, 0],
            f: function f() {
              this.a = this.b;
            }
          }
        };
        var j = {
          a: 'text',
          c: {
            b: [1, 0],
            f: function f() {
              this.a = this.b;
            }
          }
        };
        var k = {
          a: 'text',
          b: null
        };
        var l = {
          a: 'text',
          b: undefined
        };
        this.assertTrue(qx.lang.Object.equals(a, b));
        this.assertFalse(qx.lang.Object.equals(a, c));
        this.assertFalse(qx.lang.Object.equals(c, d));
        this.assertFalse(qx.lang.Object.equals(a, e));
        this.assertFalse(qx.lang.Object.equals(f, g));
        this.assertFalse(qx.lang.Object.equals(h, g));
        this.assertFalse(qx.lang.Object.equals(i, j));
        this.assertFalse(qx.lang.Object.equals(d, k));
        this.assertFalse(qx.lang.Object.equals(k, l));
        this.assertFalse(qx.lang.Object.equals({}, null));
        this.assertFalse(qx.lang.Object.equals({}, undefined));
        this.assertTrue(qx.lang.Object.equals('qooxdoo', 'qooxdoo'));
        this.assertTrue(qx.lang.Object.equals(5, 5));
        this.assertFalse(qx.lang.Object.equals(5, 10));
        this.assertFalse(qx.lang.Object.equals(1, '1'));
        this.assertTrue(qx.lang.Object.equals([], []));
        this.assertTrue(qx.lang.Object.equals([1, 2], [1, 2]));
        this.assertFalse(qx.lang.Object.equals([1, 2], [2, 1]));
        this.assertFalse(qx.lang.Object.equals([1, 2], [1, 2, 3]));
        this.assertTrue(qx.lang.Object.equals(new Date("03/31/2014"), new Date("03/31/2014")));
        this.assertFalse(qx.lang.Object.equals({
          1: {
            name: "mhc",
            age: 28
          },
          2: {
            name: "arb",
            age: 26
          }
        }, {
          1: {
            name: "mhc",
            age: 28
          },
          2: {
            name: "arb",
            age: 27
          }
        }));
        this.assertFalse(qx.lang.Object.equals(function (x) {
          return x;
        }, function (y) {
          return y + 2;
        }));
      }
    }
  });
  qx.test.lang.Object.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.lang.String": {},
      "qx.lang.Array": {},
      "qx.bom.String": {},
      "qx.xml.String": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.lang.Function": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "engine.version": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.lang.String", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock],
    members: {
      testString: function testString() {
        this.assertNotUndefined(qx.lang.String);
      },
      testFormat: function testFormat() {
        this.assertNotUndefined(qx.lang.String.format);
        var Str = qx.lang.String;
        this.assertEquals("1-2", Str.format("%1-%2", [1, 2]));
        this.assertEquals("2-1", Str.format("%2-%1", [1, 2]));
        this.assertEquals("1-2", Str.format("%1-%2", ["1", "2"]));
        this.assertEquals("2-1", Str.format("%2-%1", ["1", "2"]));
        this.assertEquals("1-2-3-4-5-6-7-8-9-10-11", Str.format("%1-%2-%3-%4-%5-%6-%7-%8-%9-%10-%11", ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"])); // test .replace() short hands: http://bclary.com/2004/11/07/#a-15.5.4.11

        this.assertEquals("foo $& bar", Str.format("foo %1 bar", ["$&"]));
        this.assertEquals("foo $` bar", Str.format("foo %1 bar", ["$`"]));
        this.assertEquals("foo $' bar", Str.format("foo %1 bar", ["$'"]));
        this.assertEquals("foo $1 bar", Str.format("foo %1 bar", ["$1"]));
        this.assertEquals("foo $22 bar", Str.format("foo %1 bar", ["$22"]));
        this.assertEquals("foo $& bar $&", Str.format("foo %1 bar %2", ["$&", "$&"]));
      },
      testRepeat: function testRepeat() {
        this.assertEquals("", qx.lang.String.repeat("", 10));
        this.assertEquals("", qx.lang.String.repeat("1", 0));
        this.assertEquals("1111", qx.lang.String.repeat("1", 4));
        this.assertEquals("123123123", qx.lang.String.repeat("123", 3));
        this.assertEquals("üüüü", qx.lang.String.repeat("ü", 4));
      },
      testPad: function testPad() {
        this.assertNotUndefined(qx.lang.String.pad);
        var Str = qx.lang.String;
        this.assertEquals("------", Str.pad("", 6, '-'));
        this.assertEquals("---123", Str.pad("123", 6, '-'));
        this.assertEquals("----123", Str.pad("123", 7, '-'));
        this.assertEquals("    123", Str.pad("123", 7, ' '));
        this.assertEquals("0000123", Str.pad("123", 7));
        this.assertEquals("123", Str.pad("123", 2, '-'));
        this.assertEquals("123", Str.pad("123", 3, '-'));
      },
      testAppend: function testAppend() {
        this.assertNotUndefined(qx.lang.Array.append);
        var a = [1, 2, 3];
        qx.lang.Array.append(a, [4, 5, 6]);
        this.assertJsonEquals(a, [1, 2, 3, 4, 5, 6]);
        var error = false;

        try {
          qx.lang.Array.append(a, 1);
        } catch (ex) {
          error = true;
        }

        this.assert(error);
      },
      testStartsWith: function testStartsWith() {
        var String = qx.lang.String;
        this.assertTrue(String.startsWith("123", "1"));
        this.assertTrue(String.startsWith("123", "123"));
        this.assertTrue(String.startsWith("1231", "1"));
        this.assertFalse(String.startsWith("123", "3"));
        this.assertFalse(String.startsWith("123", "4"));
      },
      testEscape: function testEscape() {
        // escape HTML
        this.assertEquals("\n", qx.bom.String.escape("\n"));
        this.assertEquals("Hello", qx.bom.String.escape("Hello"));
        this.assertEquals("juhu &lt;&gt;", qx.bom.String.escape("juhu <>"));
        this.assertEquals("&lt;div id='1'&gt;&amp;nbsp; &euro;&lt;/div&gt;", qx.bom.String.escape("<div id='1'>&nbsp; €</div>")); // textToHtml

        this.assertEquals("&lt;div id='1'&gt;<br> &nbsp;&amp;nbsp; &euro;&lt;/div&gt;", qx.bom.String.fromText("<div id='1'>\n  &nbsp; €</div>")); // htmlToText

        this.assertEquals("<div id='1'>\n \u00A0&nbsp; €</div>", qx.bom.String.toText("&lt;div id='1'&gt;<br> &nbsp;&amp;nbsp;  \n   &euro;&lt;/div&gt;")); // unescape HTML

        this.assertEquals("\n", qx.bom.String.unescape("\n"));
        this.assertEquals("Hello", qx.bom.String.unescape("Hello"));
        this.assertEquals("juhu <>", qx.bom.String.unescape("juhu &lt;&gt;"));
        this.assertEquals("<div id='1'>&nbsp; €</div>", qx.bom.String.unescape("&lt;div id='1'&gt;&amp;nbsp; &euro;&lt;/div&gt;"));
        this.assertEquals(">&zzzz;x", qx.bom.String.unescape("&gt;&zzzz;x"));
        this.assertEquals("€", qx.bom.String.unescape("&#x20AC;"));
        this.assertEquals("€", qx.bom.String.unescape("&#X20AC;")); // escape XML

        this.assertEquals("\n", qx.xml.String.escape("\n"));
        this.assertEquals("Hello", qx.xml.String.escape("Hello"));
        this.assertEquals("juhu &lt;&gt;", qx.xml.String.escape("juhu <>"));
        this.assertEquals("&lt;div id=&apos;1&apos;&gt;&amp;nbsp; &#8364;&lt;/div&gt;", qx.xml.String.escape("<div id='1'>&nbsp; €</div>"));
        this.assertEquals("&quot;bread&quot; &amp; &quot;butter&quot;", qx.xml.String.escape('"bread" & "butter"')); // unescape XML

        this.assertEquals("\n", qx.xml.String.unescape("\n"));
        this.assertEquals("Hello", qx.xml.String.unescape("Hello"));
        this.assertEquals("juhu <>", qx.xml.String.unescape("juhu &lt;&gt;"));
        this.assertEquals("<div id='1'>&nbsp; €</div>", qx.xml.String.unescape("&lt;div id=&apos;1&apos;&gt;&amp;nbsp; &#8364;&lt;/div&gt;"));
        this.assertEquals('"bread" & "butter"', qx.xml.String.unescape("&quot;bread&quot; &amp; &quot;butter&quot;"));
      },
      testCapitalize: function testCapitalize() {
        this.assertEquals("Alibaba", qx.lang.String.capitalize("alibaba"));
        this.assertEquals("Über", qx.lang.String.capitalize("über"));
        this.assertEquals("Aüber", qx.lang.String.capitalize("aüber"));
        this.assertEquals("Die-Über", qx.lang.String.capitalize("die-über"));
        this.assertEquals("Die Über", qx.lang.String.capitalize("die über"));
      },
      testCamelCase: function testCamelCase() {
        this.assertEquals("paddingTop", qx.lang.String.camelCase("padding-top"));
        this.assertEquals("ILikeCookies", qx.lang.String.camelCase("I-like-cookies"));
        this.assertEquals("iLikeCookies", qx.lang.String.camelCase("i-like-cookies"));
      },
      testHyphenate: function testHyphenate() {
        this.assertEquals("padding-top", qx.lang.String.hyphenate("paddingTop"));
        this.assertEquals("-i-like-cookies", qx.lang.String.hyphenate("ILikeCookies"));
        this.assertEquals("i-like-cookies", qx.lang.String.hyphenate("iLikeCookies"));
      },
      // Check for bug #7234
      testCombineCamelCaseAndHyphenate: function testCombineCamelCaseAndHyphenate() {
        qx.lang.String.hyphenate("padding-top");
        this.assertEquals("paddingTop", qx.lang.String.camelCase("padding-top"));
        qx.lang.String.camelCase("marginTop");
        this.assertEquals("margin-top", qx.lang.String.hyphenate("marginTop"));
      },
      testClean: function testClean() {
        var str = "  a  b\tc\rd\fe\vf\n\ng\nh\ri ";
        var cleanStr = "a b c d e f g h i"; // IE sees \v as "v"

        if (qx.core.Environment.get("engine.name") == "mshtml" && !(parseFloat(qx.core.Environment.get("engine.version")) >= 9 && qx.core.Environment.get("browser.documentmode") >= 9)) {
          cleanStr = "a b c d evf g h i";
        }

        this.assertEquals(cleanStr, qx.lang.String.clean(str));
      },
      testQuote: function testQuote() {
        this.assertEquals('"abc \\"defg\\" hij"', qx.lang.String.quote('abc "defg" hij'));
        this.assertEquals('"abc \\\\defg\\\\ hij"', qx.lang.String.quote('abc \\defg\\ hij'));
        this.assertEquals('"abc \\"defg\\\\ hij"', qx.lang.String.quote('abc "defg\\ hij'));
      },
      testTrim: function testTrim() {
        var str = "     foo bar     ";
        this.assertIdentical(qx.lang.String.trimLeft(str), "foo bar     ");
        this.assertIdentical(qx.lang.String.trimRight(str), "     foo bar");
      },
      testStripScripts: function testStripScripts() {
        var str = "This is a <script>foobar</script>test";
        this.assertIdentical(qx.lang.String.stripScripts(str), "This is a test");
        var spy = this.spy(qx.lang.Function, "globalEval");
        str = "This is a test with<script>console.log('foobar');</script> script";
        this.assertIdentical(qx.lang.String.stripScripts(str, true), "This is a test with script");
        this.assertCalledOnce(spy);
        spy.restore();
      }
    }
  });
  qx.test.lang.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.util.StringEscape": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Escaping and unescaping of XML strings.
   */
  qx.Class.define("qx.xml.String", {
    statics: {
      /** Mapping of XML entity names to the corresponding char code */
      TO_CHARCODE: {
        "quot": 34,
        // " - double-quote
        "amp": 38,
        // &
        "lt": 60,
        // <
        "gt": 62,
        // >
        "apos": 39 // XML apostrophe

      },

      /** Mapping of char codes to XML entity names */
      FROM_CHARCODE: {
        34: "quot",
        // " - double-quote
        38: "amp",
        // &
        60: "lt",
        // <
        62: "gt",
        // >
        39: "apos" // XML apostrophe

      },

      /**
       * Escapes the characters in a <code>String</code> using XML entities.
       *
       * For example: <tt>"bread" & "butter"</tt> =>
       * <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</tt>.
       *
       * Supports only the four basic XML entities (gt, lt, quot, amp).
       * Does not support DTDs or external entities.
       * Note that unicode characters greater than 0x7f are currently escaped to their numerical \\u equivalent.
       *
       * @param str {String} the string to be escaped
       * @return {String} the escaped string
       */
      escape: function escape(str) {
        return qx.util.StringEscape.escape(str, this.FROM_CHARCODE);
      },

      /**
       * Unescapes a string containing XML entity escapes to a string
       * containing the actual Unicode characters corresponding to the
       * escapes.
       *
       * Supports only the four basic XML entities (gt, lt, quot, amp).
       * Does not support DTDs or external entities.
       *
       * @param str {String} the string to be unescaped
       * @return {String} the unescaped string
       */
      unescape: function unescape(str) {
        return qx.util.StringEscape.unescape(str, this.TO_CHARCODE);
      }
    }
  });
  qx.xml.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.lang.Type": {},
      "qx.locale.LocalizedString": {},
      "qx.type.BaseString": {},
      "qx.type.BaseArray": {},
      "qx.core.Object": {},
      "qx.Promise": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.lang.Type", {
    extend: qx.dev.unit.TestCase,
    members: {
      testIsString: function testIsString() {
        var Type = qx.lang.Type;
        this.assertTrue(Type.isString(""));
        this.assertTrue(Type.isString("Juhu"));
        this.assertTrue(Type.isString(new String("Juhu")));
        this.assertTrue(Type.isString(new qx.locale.LocalizedString("Juhu")));
        this.assertTrue(Type.isString(new qx.type.BaseString("juhu")));
        this.assertFalse(Type.isString());
        this.assertFalse(Type.isString(function () {}));
        this.assertFalse(Type.isString(null));
        this.assertFalse(Type.isString(2));
        this.assertFalse(Type.isString({}));
        this.assertFalse(Type.isString([]));
        this.assertFalse(Type.isString(/juhu/)); // test IE issue with a null returned from DOM

        this.assertFalse(Type.isString(document.getElementById("ReturenedNull")));
      },
      testIsArray: function testIsArray() {
        var Type = qx.lang.Type;
        this.assertTrue(Type.isArray([]));
        this.assertTrue(Type.isArray(new Array()));
        this.assertTrue(Type.isArray(new qx.type.BaseArray()));
        this.assertFalse(Type.isArray());
        this.assertFalse(Type.isArray(function () {}));
        this.assertFalse(Type.isArray(""));
        this.assertFalse(Type.isArray(null));
        this.assertFalse(Type.isArray(2));
        this.assertFalse(Type.isArray({}));
        this.assertFalse(Type.isArray(true));
        this.assertFalse(Type.isArray(/juhu/)); // test IE issue with a null returned from DOM

        this.assertFalse(Type.isArray(document.getElementById("ReturenedNull")));
      },
      testIsObject: function testIsObject() {
        var Type = qx.lang.Type;
        this.assertTrue(Type.isObject({}));
        this.assertTrue(Type.isObject(new Object()));
        var qxObj = new qx.core.Object();
        this.assertTrue(Type.isObject(qxObj));
        qxObj.dispose();
        this.assertFalse(Type.isObject(), "undefined is not an object");
        this.assertFalse(Type.isObject(function () {}), "function is not an object");
        this.assertFalse(Type.isObject(""), "string is not an object");
        this.assertFalse(Type.isObject(null), "null is not an object");
        this.assertFalse(Type.isObject(undefined), "undefined is not an object");
        this.assertFalse(Type.isObject(2), "number is not an object");
        this.assertFalse(Type.isObject([]), "array is not an object");
        this.assertFalse(Type.isObject(true), "boolean is not an object");
        this.assertFalse(Type.isObject(/juhu/), "regexp is not an object"); // test IE issue with a null returned from DOM

        this.assertFalse(Type.isObject(document.getElementById("ReturenedNull")));
      },
      testIsRegExp: function testIsRegExp() {
        var Type = qx.lang.Type;
        this.assertTrue(Type.isRegExp(/juhu/));
        this.assertTrue(Type.isRegExp(new RegExp()));
        this.assertFalse(Type.isRegExp());
        this.assertFalse(Type.isRegExp(function () {}));
        this.assertFalse(Type.isRegExp(""));
        this.assertFalse(Type.isRegExp(null));
        this.assertFalse(Type.isRegExp(2));
        this.assertFalse(Type.isRegExp([]));
        this.assertFalse(Type.isRegExp(true));
        this.assertFalse(Type.isRegExp({})); // test IE issue with a null returned from DOM

        this.assertFalse(Type.isRegExp(document.getElementById("ReturenedNull")));
      },
      testIsNumber: function testIsNumber() {
        var Type = qx.lang.Type;
        this.assertTrue(Type.isNumber(1));
        this.assertTrue(Type.isNumber(1.1));
        this.assertTrue(Type.isNumber(new Number(1)));
        this.assertTrue(Type.isNumber(0));
        this.assertFalse(Type.isNumber());
        this.assertFalse(Type.isNumber(function () {}));
        this.assertFalse(Type.isNumber(""));
        this.assertFalse(Type.isNumber(null));
        this.assertFalse(Type.isNumber(/g/));
        this.assertFalse(Type.isNumber([]));
        this.assertFalse(Type.isNumber(true));
        this.assertFalse(Type.isNumber({})); // test IE issue with a null returned from DOM

        this.assertFalse(Type.isNumber(document.getElementById("ReturenedNull")));
      },
      testIsBoolean: function testIsBoolean() {
        var Type = qx.lang.Type;
        this.assertTrue(Type.isBoolean(true));
        this.assertTrue(Type.isBoolean(false));
        this.assertTrue(Type.isBoolean(new Boolean()));
        this.assertFalse(Type.isBoolean());
        this.assertFalse(Type.isBoolean(function () {}));
        this.assertFalse(Type.isBoolean(""));
        this.assertFalse(Type.isBoolean(null));
        this.assertFalse(Type.isBoolean(/g/));
        this.assertFalse(Type.isBoolean([]));
        this.assertFalse(Type.isBoolean(2));
        this.assertFalse(Type.isBoolean({})); // test IE issue with a null returned from DOM

        this.assertFalse(Type.isBoolean(document.getElementById("ReturenedNull")));
      },
      testIsFunction: function testIsFunction() {
        var Type = qx.lang.Type;
        this.assertTrue(Type.isFunction(function () {}));
        this.assertTrue(Type.isFunction(Object));
        this.assertFalse(Type.isFunction());
        this.assertFalse(Type.isFunction(true));
        this.assertFalse(Type.isFunction(""));
        this.assertFalse(Type.isFunction(null));
        this.assertFalse(Type.isFunction(/g/));
        this.assertFalse(Type.isFunction([]));
        this.assertFalse(Type.isFunction(2));
        this.assertFalse(Type.isFunction({})); // test IE issue with a null returned from DOM

        this.assertFalse(Type.isFunction(document.getElementById("ReturenedNull")));
      },
      testIsDate: function testIsDate() {
        var Type = qx.lang.Type;
        this.assertTrue(Type.isDate(new Date()));
        this.assertTrue(Type.isDate(new Date(1981, 1, 10)));
        this.assertTrue(Type.isDate(new Date(1981, 1, 10, 6, 1, 2)));
        this.assertTrue(Type.isDate(new Date(516848615165861)));
        this.assertFalse(Type.isDate());
        this.assertFalse(Type.isDate(true));
        this.assertFalse(Type.isDate(""));
        this.assertFalse(Type.isDate(null));
        this.assertFalse(Type.isDate(undefined));
        this.assertFalse(Type.isDate(/g/));
        this.assertFalse(Type.isDate([]));
        this.assertFalse(Type.isDate(2));
        this.assertFalse(Type.isDate({}));
        this.assertFalse(Type.isDate(new Error())); // test IE issue with a null returned from DOM

        this.assertFalse(Type.isDate(document.getElementById("ReturenedNull")));
      },
      testIsError: function testIsError() {
        var Type = qx.lang.Type;
        this.assertTrue(Type.isError(new Error()));
        this.assertTrue(Type.isError(new Error("")));
        this.assertTrue(Type.isError(new Error("test")));
        this.assertTrue(Type.isError(new EvalError()));
        this.assertTrue(Type.isError(new RangeError()));
        this.assertFalse(Type.isError());
        this.assertFalse(Type.isError(true));
        this.assertFalse(Type.isError(""));
        this.assertFalse(Type.isError(null));
        this.assertFalse(Type.isError(undefined));
        this.assertFalse(Type.isError(/g/));
        this.assertFalse(Type.isError([]));
        this.assertFalse(Type.isError(2));
        this.assertFalse(Type.isError({}));
        this.assertFalse(Type.isError(new Date())); // test IE issue with a null returned from DOM

        this.assertFalse(Type.isError(document.getElementById("ReturenedNull")));
      },
      // @ignore(Promise)
      testIsPromise: function testIsPromise() {
        var Type = qx.lang.Type;
        this.assertTrue(Type.isPromise(new Promise(function () {})));
        this.assertTrue(Type.isPromise(new qx.Promise(function () {})));
        this.assertFalse(Type.isPromise());
        this.assertFalse(Type.isPromise(true));
        this.assertFalse(Type.isPromise(""));
        this.assertFalse(Type.isPromise({}));
        this.assertFalse(Type.isPromise(null));
        this.assertFalse(Type.isPromise(undefined));
        this.assertFalse(Type.isPromise(/g/));
        this.assertFalse(Type.isPromise([]));
        this.assertFalse(Type.isPromise(2));
        this.assertFalse(Type.isPromise({}));
        this.assertFalse(Type.isPromise(new Error()));
      }
    }
  });
  qx.test.lang.Type.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.lang.Webkit", {
    extend: qx.dev.unit.TestCase,
    members: {
      testSwitch: function testSwitch() {
        this.assertEquals(this, this._switchFunction(12));
        this.assertEquals(this, this._switchFunction(this));
      },
      _switchFunction: function _switchFunction(val) {
        switch (val) {
          case this:
            break;

          default:
            break;
        }

        return this;
      }
    }
  });
  qx.test.lang.Webkit.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.Array": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * @require(qx.lang.normalize.Array)
   */
  qx.Class.define("qx.test.lang.normalize.Array", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock],
    members: {
      testShims: function testShims() {
        var testArray = ["entry1", "entry2"];

        for (var index in testArray) {
          this.assertTrue(index == 0 || index == 1);
        }
      },
      testIndexOf: function testIndexOf() {
        var obj = {};
        var arr = [1, obj, "str", 1];
        this.assertEquals(0, arr.indexOf(1));
        this.assertEquals(1, arr.indexOf(obj));
        this.assertEquals(2, arr.indexOf("str"));
        this.assertEquals(-1, arr.indexOf(0));
      },
      testLastIndexOf: function testLastIndexOf() {
        var obj = {};
        var arr = [1, obj, "str", 1];
        this.assertEquals(3, arr.lastIndexOf(1));
        this.assertEquals(1, arr.lastIndexOf(obj));
        this.assertEquals(2, arr.lastIndexOf("str"));
        this.assertEquals(-1, arr.lastIndexOf(0));
      },
      testForEach: function testForEach() {
        var obj = {};
        var arr = [1, obj, "str", 1];
        arr[10] = 12;
        var values = [];
        var indexes = [];
        arr.forEach(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
        }, this);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3, 10], indexes);
      },
      testFilter: function testFilter() {
        var arr = [1, 2, 3, 4];
        arr[10] = 11;
        var values = [];
        var indexes = [];
        var odd = arr.filter(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
          return index % 2 == 1;
        }, this);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3, 10], indexes);
        this.assertArrayEquals([2, 4], odd);
      },
      testMap: function testMap() {
        var arr = [1, 2, 3, 4];
        arr[10] = 11;
        var values = [];
        var indexes = [];
        var result = arr.map(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
          return element + 1;
        }, this);
        var expected = [2, 3, 4, 5];
        expected[10] = 12;
        this.assertArrayEquals(expected, result);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3, 10], indexes);
      },
      testSome: function testSome() {
        var arr = [1, 2, 3, 4];
        arr[10] = 11;
        var values = [];
        var indexes = [];
        var result = arr.some(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
        }, this);
        this.assertFalse(result);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3, 10], indexes);
        this.assertTrue(arr.some(function (element) {
          return element == 3;
        }));
        this.assertFalse(arr.some(function (element, index) {
          return index == 6;
        }));
      },
      testFind: function testFind() {
        var arr = [1, 2, 3, 4];
        arr[10] = 11;
        var values = [];
        var indexes = [];
        var result = arr.find(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
        }, this);
        this.assertUndefined(result);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], indexes);
        this.assertEquals(arr.find(function (element) {
          return element == 3;
        }), 3);
        this.assertUndefined(arr.find(function (element, index) {
          return index == 6;
        }));
      },
      testFindIndex: function testFindIndex() {
        var arr = [1, 2, 3, 4];
        arr[10] = 11;
        var values = [];
        var indexes = [];
        var result = arr.findIndex(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
        }, this);
        this.assertEquals(result, -1);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], indexes);
        this.assertEquals(arr.findIndex(function (element) {
          return element == 3;
        }), 2);
        this.assertEquals(arr.findIndex(function (element, index) {
          return element == 6;
        }), -1);
      },
      testEvery: function testEvery() {
        var arr = [1, 2, 3, 4];
        arr[10] = 11;
        var values = [];
        var indexes = [];
        var result = arr.every(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
          return true;
        }, this);
        this.assertTrue(result);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3, 10], indexes);
        this.assertFalse(arr.every(function (element) {
          return element == 3;
        }));
        this.assertTrue(arr.every(function (element, index) {
          return element == index + 1;
        }));
      },
      testReduce: function testReduce() {
        this.assertEquals(10, [].reduce(function () {}, 10));
        var spy = this.spy();
        [1].reduce(spy, 10);
        this.assertCalledWith(spy, 10, 1, 0, [1]);
        this.assertEquals(6, [1, 2, 3].reduce(function (a, b) {
          return a + b;
        }, 0));
        this.assertArrayEquals([0, 1, 2, 3, 4], [[1, 2], [3, 4]].reduce(function (a, b) {
          return a.concat(b);
        }, [0]));
      },
      testReduceRight: function testReduceRight() {
        this.assertEquals(10, [].reduceRight(function () {}, 10));
        var spy = this.spy();
        [1].reduceRight(spy, 10);
        this.assertCalledWith(spy, 10, 1, 0, [1]);
        this.assertEquals(6, [1, 2, 3].reduceRight(function (a, b) {
          return a + b;
        }, 0));
        this.assertArrayEquals([0, 3, 4, 1, 2], [[1, 2], [3, 4]].reduceRight(function (a, b) {
          return a.concat(b);
        }, [0]));
      },
      testIncludes: function testIncludes() {
        var arr = ['one', 'two', 'three'];
        this.assertTrue(arr.includes("one"), "includes does not work!");
        this.assertTrue(arr.includes("two"), "includes does not work!");
        this.assertTrue(arr.includes("three"), "includes does not work!");
        this.assertFalse(arr.includes("four"), "includes does not work!");
        arr = [NaN];
        this.assertTrue(arr.includes(NaN), "includes does not work!");
        arr = [];
        this.assertFalse(arr.includes("one"), "includes does not work!");
      }
    }
  });
  qx.test.lang.normalize.Array.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.Date": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * George Nikolaidis (gnikolaidis)
       * Peter Schneider (ps)
  
  ************************************************************************ */

  /**
   * @require(qx.lang.normalize.Date)
   */
  qx.Class.define("qx.test.lang.normalize.Date", {
    extend: qx.dev.unit.TestCase,
    members: {
      "test parse()": function testParse() {
        var sixHours = 21600000;
        var sixHoursThirty = sixHours + 1800000;
        var february = new Date(new Date().getFullYear(), 1, 1);
        var localOffset = february.getTimezoneOffset() * 6e4; // [milliseconds]
        // qx.log.Logger.info("localOffset:" + localOffset);
        // Date part

        this.assertIdentical(Date.parse("1970-01-01"), Date.UTC(1970, 0, 1, 0, 0, 0, 0), "Unix epoch");
        this.assertIdentical(Date.parse("2001"), Date.UTC(2001, 0, 1, 0, 0, 0, 0), "2001");
        this.assertIdentical(Date.parse("2001-02"), Date.UTC(2001, 1, 1, 0, 0, 0, 0), "2001-02");
        this.assertIdentical(Date.parse("2001-02-03"), Date.UTC(2001, 1, 3, 0, 0, 0, 0), "2001-02-03");
        this.assertIdentical(Date.parse("-002001"), Date.UTC(-2001, 0, 1, 0, 0, 0, 0), "-002001");
        this.assertIdentical(Date.parse("-002001-02"), Date.UTC(-2001, 1, 1, 0, 0, 0, 0), "-002001-02");
        this.assertIdentical(Date.parse("-002001-02-03"), Date.UTC(-2001, 1, 3, 0, 0, 0, 0), "-002001-02-03");
        this.assertIdentical(Date.parse("+010000-02"), Date.UTC(10000, 1, 1, 0, 0, 0, 0), "+010000-02");
        this.assertIdentical(Date.parse("+010000-02-03"), Date.UTC(10000, 1, 3, 0, 0, 0, 0), "+010000-02-03");
        this.assertIdentical(Date.parse("-010000-02"), Date.UTC(-10000, 1, 1, 0, 0, 0, 0), "-010000-02");
        this.assertIdentical(Date.parse("-010000-02-03"), Date.UTC(-10000, 1, 3, 0, 0, 0, 0), "-010000-02-03");
        this.assertTrue(isNaN(Date.parse("asdf")), "invalid YYYY (non-digits)");
        this.assertTrue(isNaN(Date.parse("1970-as-df")), "invalid YYYY-MM-DD (non-digits)");
        this.assertTrue(isNaN(Date.parse("19700101")), "invalid YYYY-MM-DD (missing hyphens)"); // Time part

        this.assertIdentical(Date.parse("2001-02-03T04:05"), Date.UTC(2001, 1, 3, 4, 5, 0, 0) + localOffset, "2001-02-03T04:05");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06"), Date.UTC(2001, 1, 3, 4, 5, 6, 0) + localOffset, "2001-02-03T04:05:06");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06.007"), Date.UTC(2001, 1, 3, 4, 5, 6, 7) + localOffset, "2001-02-03T04:05:06.007");
        this.assertIdentical(Date.parse("2001-02-03T04:05Z"), Date.UTC(2001, 1, 3, 4, 5, 0, 0), "2001-02-03T04:05Z");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06Z"), Date.UTC(2001, 1, 3, 4, 5, 6, 0), "2001-02-03T04:05:06Z");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06.007Z"), Date.UTC(2001, 1, 3, 4, 5, 6, 7), "2001-02-03T04:05:06.007Z");
        this.assertIdentical(Date.parse("2001-02-03T04:05-00:00"), Date.UTC(2001, 1, 3, 4, 5, 0, 0), "2001-02-03T04:05-00:00");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06-00:00"), Date.UTC(2001, 1, 3, 4, 5, 6, 0), "2001-02-03T04:05:06-00:00");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06.007-00:00"), Date.UTC(2001, 1, 3, 4, 5, 6, 7), "2001-02-03T04:05:06.007-00:00");
        this.assertIdentical(Date.parse("2001-02-03T04:05+00:00"), Date.UTC(2001, 1, 3, 4, 5, 0, 0), "2001-02-03T04:05+00:00");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06+00:00"), Date.UTC(2001, 1, 3, 4, 5, 6, 0), "2001-02-03T04:05:06+00:00");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06.007+00:00"), Date.UTC(2001, 1, 3, 4, 5, 6, 7), "2001-02-03T04:05:06.007+00:00");
        this.assertIdentical(Date.parse("2001-02-03T04:05-06:30"), Date.UTC(2001, 1, 3, 4, 5, 0, 0) + sixHoursThirty, "2001-02-03T04:05-06:30");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06-06:30"), Date.UTC(2001, 1, 3, 4, 5, 6, 0) + sixHoursThirty, "2001-02-03T04:05:06-06:30");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06.007-06:30"), Date.UTC(2001, 1, 3, 4, 5, 6, 7) + sixHoursThirty, "2001-02-03T04:05:06.007-06:30");
        this.assertIdentical(Date.parse("2001-02-03T04:05+06:30"), Date.UTC(2001, 1, 3, 4, 5, 0, 0) - sixHoursThirty, "2001-02-03T04:05+06:30");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06+06:30"), Date.UTC(2001, 1, 3, 4, 5, 6, 0) - sixHoursThirty, "2001-02-03T04:05:06+06:30");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06.007+06:30"), Date.UTC(2001, 1, 3, 4, 5, 6, 7) - sixHoursThirty, "2001-02-03T04:05:06.007+06:30");
        this.assertIdentical(Date.parse("2001T04:05:06.007"), Date.UTC(2001, 0, 1, 4, 5, 6, 7) + localOffset, "2001T04:05:06.007");
        this.assertIdentical(Date.parse("2001-02T04:05:06.007"), Date.UTC(2001, 1, 1, 4, 5, 6, 7) + localOffset, "2001-02T04:05:06.007");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06.007"), Date.UTC(2001, 1, 3, 4, 5, 6, 7) + localOffset, "2001-02-03T04:05:06.007");
        this.assertIdentical(Date.parse("2001-02-03T04:05:06.007-06:30"), Date.UTC(2001, 1, 3, 4, 5, 6, 7) + sixHoursThirty, "2001-02-03T04:05:06.007-06:30");
        this.assertIdentical(Date.parse("-010000T04:05"), Date.UTC(-10000, 0, 1, 4, 5, 0, 0) + localOffset, "-010000T04:05");
        this.assertIdentical(Date.parse("-010000-02T04:05"), Date.UTC(-10000, 1, 1, 4, 5, 0, 0) + localOffset, "-010000-02T04:05");
        this.assertIdentical(Date.parse("-010000-02-03T04:05"), Date.UTC(-10000, 1, 3, 4, 5, 0, 0) + localOffset, "-010000-02-03T04:05");
        this.assertTrue(isNaN(Date.parse("1970-01-01T00:00:00,000")), "invalid date-time (comma instead of dot)");
        this.assertTrue(isNaN(Date.parse("1970-01-01T0000")), "invalid date-time (missing colon in time part)");
        this.assertTrue(isNaN(Date.parse("1970-01-01T00:00.000")), "invalid date-time (msec with missing seconds)");
      }
    }
  });
  qx.test.lang.normalize.Date.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.Error": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.lang.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @require(qx.lang.normalize.Error)
   */
  qx.Class.define("qx.test.lang.normalize.Error", {
    extend: qx.dev.unit.TestCase,
    members: {
      testToString: function testToString() {
        var msg = "Dummer Fehler";
        var error = new Error(msg);
        this.assertTrue(qx.lang.String.contains(error.toString(), msg));
      }
    }
  });
  qx.test.lang.normalize.Error.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.Function": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @require(qx.lang.normalize.Function)
   */
  qx.Class.define("qx.test.lang.normalize.Function", {
    extend: qx.dev.unit.TestCase,
    members: {
      testBind: function testBind() {
        var context = null;
        var result = 0;

        var add = function add(a, b) {
          context = this;
          return a + b;
        };

        context = null;
        result = add(1, 2);
        this.assertEquals(context, window);
        this.assertEquals(3, result);
        context = null;
        var boundAdd = add.bind(this);
        result = boundAdd(1, 3);
        this.assertEquals(context, this);
        this.assertEquals(4, result);
        context = null;
        var addOne = add.bind(this, 1);
        result = addOne(4);
        this.assertEquals(context, this);
        this.assertEquals(5, result);
      },
      testBindWithUndefinedArguments: function testBindWithUndefinedArguments() {
        var undef;

        var callback = function callback(undef, arg) {
          this.assertTrue(arg);
        };

        var bound = callback.bind(this, undef, true);
        bound();
      }
    }
  });
  qx.test.lang.normalize.Function.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.Object": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * @require(qx.lang.normalize.Object)
   */
  qx.Class.define("qx.test.lang.normalize.Object", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock],
    members: {
      testKeysWithExtendObject: function testKeysWithExtendObject() {
        function ObjectA() {
          this.A = 10;
        }

        ;

        function ObjectB() {
          this.B = 11;
        }

        ;
        ObjectB.prototype = new ObjectA();
        var objB = new ObjectB();
        this.assertEquals(10, objB.A, "Object extension fails!");
        this.assertEquals(11, objB.B, "Object extension fails!");
        var keys = Object.keys(objB);
        this.assertEquals(1, keys.length, "Expected length wrong!");
        this.assertFalse(keys.includes("A"), "Test property A!");
        this.assertTrue(keys.includes("B"), "Test property B!");
      },
      testKeys: function testKeys() {
        var obj = {};

        obj.isPrototypeOf = function () {};

        obj.hasOwnProperty = function () {};

        obj.toLocaleString = function () {};

        obj.toString = function () {};

        obj.valueOf = function () {};

        obj.constructor = function () {};

        obj.prototype = function () {};

        var keys = Object.keys(obj);
        this.assertTrue(keys.includes("isPrototypeOf"), "Test isPrototypeOf");
        this.assertTrue(keys.includes("hasOwnProperty"), "Test hasOwnProperty");
        this.assertTrue(keys.includes("toLocaleString"), "Test toLocaleString");
        this.assertTrue(keys.includes("toString"), "Test toString");
        this.assertTrue(keys.includes("valueOf"), "Test valueOf");
        this.assertTrue(keys.includes("constructor"), "Test constructor");
        this.assertTrue(keys.includes("prototype"), "Test prototype");
      },
      testGetValues: function testGetValues() {
        var object = {
          a: undefined,
          b: null,
          c: 1
        };
        this.assertArrayEquals([undefined, null, 1].sort(), Object.values(object).sort());
        var object = {};
        this.assertArrayEquals([], Object.values(object));
        var object = {
          "isPrototypeOf": 1,
          "hasOwnProperty": 2,
          "toLocaleString": 3,
          "toString": 4,
          "valueOf": 5
        };
        this.assertArrayEquals([1, 2, 3, 4, 5].sort(), Object.values(object).sort());
      }
    }
  });
  qx.test.lang.normalize.Object.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.String": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * @require(qx.lang.normalize.String)
   */
  qx.Class.define("qx.test.lang.normalize.String", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock],
    members: {
      "test trim()": function testTrim() {
        this.assertEquals("y", "   y".trim());
        this.assertEquals("y", "y   ".trim());
        this.assertEquals("y", " y  ".trim());
      },
      "test startsWith()": function testStartsWith() {
        var str = "To be, or not to be, that is the question.";
        this.assertTrue(str.startsWith("To be")); // true

        this.assertFalse(str.startsWith("not to be")); // false

        this.assertTrue(str.startsWith("not to be", 10)); // true
      },
      "test endsWith()": function testEndsWith() {
        var str = "To be, or not to be, that is the question.";
        this.assertTrue(str.endsWith("question.")); // true

        this.assertFalse(str.endsWith("to be")); // false

        this.assertTrue(str.endsWith("to be", 19)); // true
        //
        // Increase test covarage
        //
        // not finite

        this.assertTrue(str.endsWith("question.", Number.POSITIVE_INFINITY));
        this.assertFalse(str.endsWith("to be", Number.POSITIVE_INFINITY)); // float

        this.assertTrue(str.endsWith("question.", 42.2));
        this.assertFalse(str.endsWith("to be", 42.2)); // len > str.length

        this.assertTrue(str.endsWith("question.", 43));
        this.assertFalse(str.endsWith("to be", 43));
      }
    }
  });
  qx.test.lang.normalize.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.locale.Manager": {},
      "qx.locale.Date": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.locale.Date", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        qx.locale.Manager.getInstance().setLocale("C");
      },
      tearDown: function tearDown() {
        qx.locale.Manager.getInstance().resetLocale();
      },
      testDayNames: function testDayNames() {
        var Date = qx.locale.Date;
        var useLocale = "C";
        var abbrDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        this.assertJsonEquals(abbrDays, Date.getDayNames("abbreviated").map(function (v) {
          return v + "";
        }));

        for (var i = 0; i < 7; i++) {
          this.assertEquals(abbrDays[i], Date.getDayName("abbreviated", i));
        }

        var narrowDays = ["S", "M", "T", "W", "T", "F", "S"];
        this.assertJsonEquals(narrowDays, Date.getDayNames("narrow", useLocale, "stand-alone").map(function (v) {
          return v + "";
        }));

        for (var i = 0; i < 7; i++) {
          this.assertEquals(narrowDays[i], Date.getDayName("narrow", i, useLocale, "stand-alone"));
        }

        var wideDays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        this.assertJsonEquals(wideDays, Date.getDayNames("wide").map(function (v) {
          return v + "";
        }));

        for (var i = 0; i < 7; i++) {
          this.assertEquals(wideDays[i], Date.getDayName("wide", i));
        } // german


        useLocale = "de_DE";
        qx.locale.Manager.getInstance().setLocale(useLocale);
        var abbrDays = ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."];
        this.assertJsonEquals(abbrDays, Date.getDayNames("abbreviated").map(function (v) {
          return v + "";
        }));

        for (var i = 0; i < 7; i++) {
          this.assertEquals(abbrDays[i], Date.getDayName("abbreviated", i));
        }

        var narrowDays = ["S", "M", "D", "M", "D", "F", "S"];
        this.assertJsonEquals(narrowDays, Date.getDayNames("narrow", useLocale, "stand-alone").map(function (v) {
          return v + "";
        }));

        for (var i = 0; i < 7; i++) {
          this.assertEquals(narrowDays[i], Date.getDayName("narrow", i, useLocale, "stand-alone"));
        }

        var wideDays = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"];
        this.assertJsonEquals(wideDays, Date.getDayNames("wide").map(function (v) {
          return v + "";
        }));

        for (var i = 0; i < 7; i++) {
          this.assertEquals(wideDays[i], Date.getDayName("wide", i));
        }

        if (this.isDebugOn()) {
          this.assertException(function () {
            Date.getDayNames("verylong");
          }, Error);
          this.assertException(function () {
            Date.getDayName("wide", -1);
          }, Error);
          this.assertException(function () {
            Date.getDayName("wide", 8);
          }, Error);
        }
      },
      testDateFormat: function testDateFormat() {
        var Date = qx.locale.Date;
        this.assertEquals("AM", Date.getAmMarker("C"));
        this.assertEquals("PM", Date.getPmMarker("C"));
      }
    }
  });
  qx.test.locale.Date.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.locale.MTranslation": {
        "require": true
      },
      "qx.locale.Manager": {},
      "qx.ui.form.TextField": {},
      "qx.locale.Key": {},
      "qx.bom.client.OperatingSystem": {},
      "qx.bom.client.Locale": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "os.name": {
          "className": "qx.bom.client.OperatingSystem"
        },
        "locale": {
          "className": "qx.bom.client.Locale"
        },
        "locale.variant": {
          "className": "qx.bom.client.Locale"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.locale.Locale", {
    extend: qx.dev.unit.TestCase,
    include: qx.locale.MTranslation,
    members: {
      __defaultLocale: null,
      __listenerId: null,
      setUp: function setUp() {
        var manager = qx.locale.Manager.getInstance();
        this.__defaultLocale = manager.getLocale();
      },
      tearDown: function tearDown() {
        var manager = qx.locale.Manager.getInstance();
        manager.setLocale(this.__defaultLocale);

        if (this.__listenerId) {
          manager.removeListenerById(this.__listenerId);
        }
      },
      testTranslation: function testTranslation() {
        this.assertNotUndefined(qx.locale.Manager);
        var manager = qx.locale.Manager.getInstance(); // add dummy translations

        manager.addTranslation("en_QX", {
          "test one": "test one",
          "test two": "test two",
          "test Hello %1!": "test Hello %1!",
          "test Jonny": "test Jonny",
          "test one car": "test one car",
          "test %1 cars": "test %1 cars"
        });
        manager.addTranslation("de_QX", {
          "test one": "Eins",
          "test two": "Zwei",
          "test Hello %1!": "Servus %1!",
          "test Jonny": "Jonathan",
          "test one car": "Ein Auto",
          "test %1 cars": "%1 Autos"
        });
        manager.setLocale("en_QX");
        this.assertEquals("en", manager.getLanguage());
        this.assertEquals("QX", manager.getTerritory()); // tr(): simple case

        var one = this.tr("test one");
        this.assertEquals("test one", one); // tr(): format string

        var hello = this.tr("test Hello %1!", "Fabian");
        this.assertEquals("test Hello Fabian!", hello); // tr(): format string with namedArg

        var hello = this.tr("test Hello %{firstName} %{lastName}!", {
          firstName: "Fabian",
          lastName: "Jonny"
        });
        this.assertEquals("test Hello Fabian Jonny!", hello); // tr(): format string with translated arguments

        var hiJonny = this.tr("test Hello %1!", this.tr("test Jonny"));
        this.assertEquals("test Hello test Jonny!", hiJonny); // trn(): plural

        var car = this.trn("test one car", "test %1 cars", 0, 0);
        this.assertEquals("test 0 cars", car);
        car = this.trn("test one car", "test %1 cars", 1);
        this.assertEquals("test one car", car);
        var cars = this.trn("test one car", "test %1 cars", 5, 5);
        this.assertEquals("test 5 cars", cars); // trc(): comments

        one = this.trc("comment simple", "test one");
        this.assertEquals("test one", one);
        hello = this.trc("comment format", "test Hello %1!", "Fabian");
        this.assertEquals("test Hello Fabian!", hello);
        hiJonny = this.trc("comment format args", "test Hello %1!", this.tr("test Jonny"));
        this.assertEquals("test Hello test Jonny!", hiJonny); // trnc(): comments and plural

        car = this.trnc("comment count 0", "test one car", "test %1 cars", 0, 0);
        this.assertEquals("test 0 cars", car);
        car = this.trnc("comment count 1", "test one car", "test %1 cars", 1);
        this.assertEquals("test one car", car);
        cars = this.trnc("comment count 5", "test one car", "test %1 cars", 5, 5);
        this.assertEquals("test 5 cars", cars); // check listener

        var fired = false;
        var evtLocale = "";
        this.__listenerId = manager.addListener("changeLocale", function (e) {
          fired = true;
          evtLocale = e.getData();
        }); // change locale

        manager.setLocale("de_QX");
        this.assertTrue(fired);
        this.assertEquals("de_QX", evtLocale); // simple case

        one = one.translate();
        this.assertEquals("Eins", one); // format string

        hello = hello.translate();
        this.assertEquals("Servus Fabian!", hello); // format string with translated arguments

        hiJonny = hiJonny.translate();
        this.assertEquals("Servus Jonathan!", hiJonny); // plural

        car = car.translate();
        this.assertEquals("Ein Auto", car);
        cars = cars.translate();
        this.assertEquals("5 Autos", cars);
      },
      testInvalidMessage: function testInvalidMessage() {
        this.assertNotUndefined(qx.locale.Manager);
        var manager = qx.locale.Manager.getInstance(); // add dummy translations

        manager.addTranslation("en_QX", {
          "test one": "one!",
          "test two": "two!"
        });
        manager.addTranslation("de_QX", {
          "test one": "Eins!",
          "test two": "Zwei!"
        });
        manager.setLocale("en_QX");
        var textField = new qx.ui.form.TextField();
        textField.setInvalidMessage(this.tr("test one"));
        textField.setRequiredInvalidMessage(this.tr("test two"));
        this.assertEquals("one!", textField.getInvalidMessage());
        this.assertEquals("two!", textField.getRequiredInvalidMessage());
        manager.setLocale("de_QX");
        this.assertEquals("Eins!", textField.getInvalidMessage());
        this.assertEquals("Zwei!", textField.getRequiredInvalidMessage());
        textField.dispose();
      },
      testMacCtrl: function testMacCtrl() {
        // check if the translation is working
        this.assertEquals("Links", qx.locale.Key.getKeyName("short", "Left", "de_DE")); // is the localized version

        if (qx.core.Environment.get("os.name") == "osx") {
          // there is no strg on macs, only ctrl
          this.assertEquals("Ctrl", qx.locale.Key.getKeyName("short", "Control", "de_DE"));
          this.assertEquals("Control", qx.locale.Key.getKeyName("full", "Control", "de_DE"));
        } else {
          this.assertEquals("Strg", qx.locale.Key.getKeyName("short", "Control", "de_DE"));
          this.assertEquals("Steuerung", qx.locale.Key.getKeyName("full", "Control", "de_DE"));
        }
      },
      testResetLocale: function testResetLocale() {
        var locale = qx.core.Environment.get("locale");
        var variant = qx.core.Environment.get("locale.variant");

        if (variant !== "") {
          locale += "_" + variant;
        }

        var manager = qx.locale.Manager.getInstance();
        var oldLocale = manager.getLocale();
        manager.addTranslation("en_QX", {
          "test one": "one!",
          "test two": "two!"
        });
        manager.setLocale("en_QX"); // try the reset of the locale

        manager.resetLocale();
        this.assertEquals(locale, manager.getLocale()); // make sure we set the locale which was there before the test

        manager.setLocale(oldLocale);
      }
    }
  });
  qx.test.locale.Locale.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.locale.MTranslation": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.locale.LocalizedString": {},
      "qx.locale.Date": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Thomas Herchenroeder (thron7)
  
  ************************************************************************ */
  qx.Class.define("qx.test.locale.LocalizedString", {
    extend: qx.dev.unit.TestCase,
    include: [qx.locale.MTranslation, qx.dev.unit.MRequirements],
    members: {
      testTranslation: function testTranslation() {
        this.require(["qx.debug"]);

        this.assertException(function () {
          var ls = new qx.locale.LocalizedString("foo", "id", "xyz");
          ls.translate();
        });
      },
      testLocalizeVsTranslate: function testLocalizeVsTranslate() {
        this.assertEquals(qx.locale.Date.getMonthName("wide", new Date().getMonth()).toString(), qx.locale.Date.getMonthName("wide", new Date().getMonth()).translate().toString());
      }
    }
  });
  qx.test.locale.LocalizedString.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.log.Logger": {},
      "qx.test.log.fixture.ClassA": {},
      "qx.test.log.fixture.ClassB1": {},
      "qx.test.log.fixture.ClassC1": {},
      "qx.test.log.fixture.ClassB2": {},
      "qx.test.log.fixture.ClassC2": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.log.DeprecationMethodOverriding", {
    extend: qx.dev.unit.TestCase,
    members: {
      __lastWarnMsg: null,
      __orgWarnMesthod: null,
      __orgTraceMesthod: null,
      setUp: function setUp() {
        this.__orgWarnMesthod = qx.log.Logger.warn;
        this.__orgTraceMesthod = qx.log.Logger.trace;
        var that = this;

        qx.log.Logger.warn = function (msg) {
          that.__lastWarnMsg = msg;
        };

        qx.log.Logger.trace = function () {};
      },
      tearDown: function tearDown() {
        qx.log.Logger.warn = this.__orgWarnMesthod;
        qx.log.Logger.trace = this.__orgTraceMesthod;
        this.__orgWarnMesthod = null;
        this.__orgTraceMesthod = null;
        this.__lastWarnMsg = null;
      },
      "testClassA: baseclass": function testClassABaseclass() {
        var instance = new qx.test.log.fixture.ClassA();

        this.__test(instance, 1, 1, null);

        instance.dispose();
      },
      "testClassB1: overrides method": function testClassB1OverridesMethod() {
        var instance = new qx.test.log.fixture.ClassB1();

        this.__test(instance, 2, 2, /qx.test.log.fixture.ClassB1.prototype._applyOldProperty()/);

        instance.dispose();
      },
      "testClassC1: doesn't override method": function testClassC1DoesnTOverrideMethod() {
        var instance = new qx.test.log.fixture.ClassC1();

        this.__test(instance, 2, 3, /qx.test.log.fixture.ClassB1.prototype._applyOldProperty()/);

        instance.dispose();
      },
      "testClassB2: doesn't override method": function testClassB2DoesnTOverrideMethod() {
        var instance = new qx.test.log.fixture.ClassB2();

        this.__test(instance, 1, 2, null);

        instance.dispose();
      },
      "testClassC2: overrides method": function testClassC2OverridesMethod() {
        var instance = new qx.test.log.fixture.ClassC2();

        this.__test(instance, 2, 3, /qx.test.log.fixture.ClassC2.prototype._applyOldProperty()/);

        instance.dispose();
      },
      __test: function __test(instance, callCountOldProperty, callCountNewProperty, reqExpWarnMsg) {
        instance.setOldProperty("Jo");
        instance.setNewProperty("Do");
        this.assertEquals(callCountOldProperty, instance.getCallCountApplyOldProperty());
        this.assertEquals(callCountNewProperty, instance.getCallCountApplyNewProperty());
        {
          if (reqExpWarnMsg) {
            this.assertTrue(reqExpWarnMsg.test(this.__lastWarnMsg));
          } else {
            this.assertNull(this.__lastWarnMsg);
          }
        }
      }
    }
  });
  qx.test.log.DeprecationMethodOverriding.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.log.Logger": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.log.fixture.ClassA", {
    extend: qx.core.Object,
    construct: function construct() {
      this._callCountApplyOldProperty = 0;
      this._callCountApplyNewProperty = 0;
      qx.log.Logger.deprecateMethodOverriding(this, qx.test.log.fixture.ClassA, "_applyOldProperty");
    },
    properties: {
      oldProperty: {
        init: "oldProperty",
        apply: "_applyOldProperty"
      },
      newProperty: {
        init: "newProperty",
        apply: "_applyNewProperty"
      }
    },
    members: {
      _callCountApplyOldProperty: null,
      _callCountApplyNewProperty: null,
      _applyOldProperty: function _applyOldProperty() {
        this._callCountApplyOldProperty++;
      },
      _applyNewProperty: function _applyNewProperty() {
        this._callCountApplyNewProperty++;
      },
      getCallCountApplyOldProperty: function getCallCountApplyOldProperty() {
        return this._callCountApplyOldProperty;
      },
      getCallCountApplyNewProperty: function getCallCountApplyNewProperty() {
        return this._callCountApplyNewProperty;
      }
    }
  });
  qx.test.log.fixture.ClassA.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.log.fixture.ClassA": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.log.fixture.ClassB1", {
    extend: qx.test.log.fixture.ClassA,
    members: {
      _applyOldProperty: function _applyOldProperty() {
        qx.test.log.fixture.ClassB1.prototype._applyOldProperty.base.call(this);

        this._callCountApplyOldProperty++;
      },
      _applyNewProperty: function _applyNewProperty() {
        qx.test.log.fixture.ClassB1.prototype._applyNewProperty.base.call(this);

        this._callCountApplyNewProperty++;
      }
    }
  });
  qx.test.log.fixture.ClassB1.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.log.fixture.ClassB1": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.log.fixture.ClassC1", {
    extend: qx.test.log.fixture.ClassB1,
    members: {
      _applyNewProperty: function _applyNewProperty() {
        qx.test.log.fixture.ClassC1.prototype._applyNewProperty.base.call(this);

        this._callCountApplyNewProperty++;
      }
    }
  });
  qx.test.log.fixture.ClassC1.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.log.fixture.ClassA": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.log.fixture.ClassB2", {
    extend: qx.test.log.fixture.ClassA,
    members: {
      _applyNewProperty: function _applyNewProperty() {
        qx.test.log.fixture.ClassB2.prototype._applyNewProperty.base.call(this);

        this._callCountApplyNewProperty++;
      }
    }
  });
  qx.test.log.fixture.ClassB2.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.log.fixture.ClassB2": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.log.fixture.ClassC2", {
    extend: qx.test.log.fixture.ClassB2,
    members: {
      _applyOldProperty: function _applyOldProperty() {
        qx.test.log.fixture.ClassC2.prototype._applyOldProperty.base.call(this);

        this._callCountApplyOldProperty++;
      },
      _applyNewProperty: function _applyNewProperty() {
        qx.test.log.fixture.ClassC2.prototype._applyNewProperty.base.call(this);

        this._callCountApplyNewProperty++;
      }
    }
  });
  qx.test.log.fixture.ClassC2.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.log.appender.Native": {},
      "qx.log.Logger": {},
      "qx.log.appender.Util": {},
      "qx.core.Assert": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * John Spackman (john.spackman@zenesis.com)
  
   ************************************************************************ */

  /**
   * @ignore(my.TestLogger)
   */
  qx.Class.define("qx.test.log.Filters", {
    extend: qx.dev.unit.TestCase,
    members: {
      testFilters: function testFilters() {
        qx.log.appender.Native;
        var Logger = qx.log.Logger;
        qx.Class.define("my.TestLogger", {
          statics: {
            count: 0,
            process: function process(entry) {
              this.count++;
              var args = qx.log.appender.Util.toText(entry);
              (console[entry.level] || console.log).call(console, "TestLogger: " + args);
            }
          }
        });
        Logger.addFilter("afdemo", "qx.log.appender.Native");
        Logger.addFilter(/^test-level/, "my.TestLogger", "warn");
        var TestLogger = my.TestLogger;
        qx.log.Logger.register(TestLogger);
        TestLogger.count = 0;
        this.trace("Trace Test");
        this.debug("Debug Test");
        this.warn("Warn Test");
        this.error("Error Test");
        this.info("Info Test");
        Logger.trace("test-level", "Trace Test");
        Logger.debug("test-level", "Debug Test");
        Logger.info("test-level", "Info Test");
        Logger.warn("test-level", "Warn Test");
        Logger.error("test-level", "Error Test");
        qx.core.Assert.assertEquals(2, TestLogger.count);
        qx.log.Logger.unregister(TestLogger);
        qx.log.Logger.resetFilters();
      }
    }
  });
  qx.test.log.Filters.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.core.Object": {},
      "qx.core.ObjectRegistry": {},
      "qx.log.appender.Formatter": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
   * Fabian Jakobs (fjakobs)
  
   ************************************************************************ */
  qx.Class.define("qx.test.log.Formatter", {
    extend: qx.dev.unit.TestCase,
    members: {
      testToTextWithObject: function testToTextWithObject() {
        var time = new Date(1000);
        var obj = new qx.core.Object();
        qx.core.ObjectRegistry.register(obj);
        var entry = {
          time: time,
          offset: 900,
          level: "warn",
          items: [],
          win: window,
          object: obj.$$hash
        };
        var formatter = qx.log.appender.Formatter.getFormatter();
        var text = formatter.toText(entry);
        this.assertEquals("000900 qx.core.Object[" + obj.$$hash + "]:", text);
        obj.dispose();
      },
      testToTextAsDate: function testToTextAsDate() {
        var time = new Date(2019, 9, 10, 1, 2, 3);
        var obj = new qx.core.Object();
        qx.core.ObjectRegistry.register(obj);
        var entry = {
          time: time,
          offset: 900,
          level: "warn",
          items: [],
          win: window,
          object: obj.$$hash
        };
        var formatter = new qx.log.appender.Formatter().set({
          formatTimeAs: "datetime"
        });
        var text = formatter.toText(entry);
        this.assertEquals("2019-10-10 01:02:03 qx.core.Object[" + obj.$$hash + "]:", text);
        obj.dispose();
      },
      testToTextWithClass: function testToTextWithClass() {
        var time = new Date(1000);
        var entry = {
          time: time,
          offset: 900,
          level: "warn",
          items: [],
          win: window,
          clazz: qx.core.Object
        };
        var formatter = qx.log.appender.Formatter.getFormatter();
        var text = formatter.toText(entry);
        this.assertEquals("000900 qx.core.Object:", text);
      }
    }
  });
  qx.test.log.Formatter.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.log.Logger": {},
      "qx.log.appender.RingBuffer": {},
      "qx.bom.client.EcmaScript": {},
      "qx.bom.client.Engine": {},
      "qx.core.Object": {},
      "qx.core.IDisposable": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "ecmascript.error.stacktrace": {
          "className": "qx.bom.client.EcmaScript"
        },
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.log.Logger", {
    extend: qx.dev.unit.TestCase,
    statics: {
      TEST_CONSTANT: "abc"
    },
    members: {
      setUp: function setUp() {
        this.__initialLogLevel = qx.log.Logger.getLevel();
      },
      tearDown: function tearDown() {
        qx.log.Logger.setLevel(this.__initialLogLevel);
      },
      __testLogException: function __testLogException(exception) {
        var appender = new qx.log.appender.RingBuffer();
        qx.log.Logger.setLevel("debug");
        qx.log.Logger.clear();
        qx.log.Logger.register(appender);
        qx.log.Logger.debug(exception);
        var events = appender.getAllLogEvents();
        this.assertEquals(1, events.length);

        if (qx.core.Environment.get("ecmascript.error.stacktrace")) {
          if (exception instanceof Error || qx.core.Environment.get("engine.name") !== "gecko") {
            this.assert(events[0].items[0].trace.length > 0);
          }
        }

        qx.log.Logger.unregister(appender);
      },
      testLogException: function testLogException() {
        var exception = this.newException();

        this.__testLogException(exception);
      },
      testLogDOMException: function testLogDOMException() {
        var exception = this.newDOMException();

        this.__testLogException(exception);
      },
      testKonstantDeprecation: function testKonstantDeprecation() {
        // call the method to see if its not throwing an error
        qx.log.Logger.deprecatedConstantWarning(qx.test.log.Logger, "TEST_CONSTANT");
        this.assertEquals("abc", qx.test.log.Logger.TEST_CONSTANT);
      },

      /**
       * @ignore(test.DisposableObject)
       */
      testContextObject: function testContextObject() {
        var appender = new qx.log.appender.RingBuffer();
        qx.log.Logger.setLevel("debug");
        qx.log.Logger.clear();
        qx.log.Logger.register(appender);
        qx.Class.define("test.DisposableObject", {
          extend: qx.core.Object,
          implement: qx.core.IDisposable
        });
        var obj = new qx.core.Object();
        var dispObj = new test.DisposableObject();
        qx.log.Logger.debug(qx.core.Object, "m1");
        qx.log.Logger.debug(obj, "m2");
        qx.log.Logger.debug(qxWeb(), "m3");
        qx.log.Logger.debug(dispObj, "m4");
        var events = appender.getAllLogEvents();
        this.assertEquals(qx.core.Object, events[0].clazz);
        this.assertEquals(qx.core.Object, events[1].clazz);
        this.assertEquals(qxWeb, events[2].clazz);
        this.assertEquals(dispObj.toHashCode(), events[3].object);
        qx.log.Logger.unregister(appender);
        dispObj.dispose();
        qx.Class.undefine("test.DisposableObject");
      },
      newException: function newException() {
        var exc;

        try {
          throw new Error();
        } catch (e) {
          exc = e;
        }

        return exc;
      },
      newDOMException: function newDOMException() {
        var exc;

        try {
          document.body.appendChild(null);
        } catch (e) {
          exc = e;
        }

        return exc;
      }
    }
  });
  qx.test.log.Logger.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.log.Logger": {},
      "qx.log.appender.RingBuffer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.log.RingBuffer", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.__initialLogLevel = qx.log.Logger.getLevel();
      },
      tearDown: function tearDown() {
        qx.log.Logger.setLevel(this.__initialLogLevel);

        if (this.appender) {
          qx.log.Logger.unregister(this.appender);
        }

        this.appender = null;
      },
      testLog: function testLog() {
        this.appender = new qx.log.appender.RingBuffer();
        qx.log.Logger.setLevel("debug");
        qx.log.Logger.clear();
        qx.log.Logger.register(this.appender);
        qx.log.Logger.debug("test");
        var events = this.appender.getAllLogEvents();
        this.assertEquals(1, events.length);
        this.assertEquals("test", events[0].items[0].text);
        qx.log.Logger.unregister(this.appender);
        this.appender = null;
      },
      testExceedMaxMessages: function testExceedMaxMessages() {
        var appender = new qx.log.appender.RingBuffer(2);

        for (var i = 0; i < 10; i++) {
          appender.process({
            index: i
          });
        }

        var events = appender.getAllLogEvents();
        this.assertEquals(2, events.length);
        this.assertEquals(8, events[0].index);
        this.assertEquals(9, events[1].index);
      },
      testRetrieveLogEvents: function testRetrieveLogEvents() {
        var appender = new qx.log.appender.RingBuffer(6);

        for (var i = 0; i < 10; i++) {
          var event = {
            index: i
          };
          appender.process(event);
        }

        var events = appender.retrieveLogEvents(5);
        this.assertEquals(5, events.length);
        this.assertEquals(5, events[0].index);
        this.assertEquals(9, events[4].index);
      },
      testClearHistory: function testClearHistory() {
        var appender = new qx.log.appender.RingBuffer();
        appender.process({});
        this.assertEquals(1, appender.getAllLogEvents().length);
        appender.clearHistory();
        this.assertEquals(0, appender.getAllLogEvents().length);
      }
    }
  });
  qx.test.log.RingBuffer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.client.Browser": {},
      "qx.dev.unit.RequirementError": {},
      "qx.core.Init": {},
      "qx.ui.mobile.core.Root": {},
      "qx.ui.mobile.core.Widget": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.MobileTestCase", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements],
    statics: {
      _root: null,
      _oldApplicationFunction: null
    },
    members: {
      setUp: function setUp() {
        if (qx.core.Environment.get("browser.name") == "ie" && qx.core.Environment.get("browser.documentmode") < 10) {
          throw new qx.dev.unit.RequirementError("Mobile tests require Webkit, Gecko or IE10+");
        }

        qx.test.mobile.MobileTestCase._oldApplicationFunction = qx.core.Init.getApplication;
        var self = this;

        qx.core.Init.getApplication = function () {
          return {
            getRoot: function getRoot() {
              return self.getRoot();
            },
            addListener: function addListener() {
              return self.addListener.apply(self, arguments);
            },
            removeListener: function removeListener() {
              return self.removeListener.apply(self, arguments);
            },
            removeListenerById: function removeListenerById() {
              return self.removeListenerById.apply(self, arguments);
            },
            fireEvent: function fireEvent() {
              return self.fireEvent.apply(self, arguments);
            },
            fireDataEvent: function fireDataEvent() {
              return self.fireDataEvent.apply(self, arguments);
            },
            close: function close() {},
            terminate: function terminate() {}
          };
        };
      },
      tearDown: function tearDown() {
        this.getRoot().removeAll();
        qx.core.Init.getApplication = qx.test.mobile.MobileTestCase._oldApplicationFunction;
      },
      getRoot: function getRoot() {
        var clazz = qx.test.mobile.MobileTestCase;

        if (!clazz._root) {
          clazz._root = new qx.ui.mobile.core.Root();
        }

        return clazz._root;
      },
      assertQxMobileWidget: function assertQxMobileWidget(obj) {
        this.assertInstance(obj, qx.ui.mobile.core.Widget);
      }
    }
  });
  qx.test.mobile.MobileTestCase.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qxWeb": {
        "require": true
      },
      "qx.module.Attribute": {
        "require": true
      },
      "qx.module.Traversing": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "construct": true,
        "require": true
      },
      "qx.locale.MTranslation": {
        "require": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.ui.mobile.basic.Label": {},
      "qx.ui.mobile.list.List": {},
      "qx.data.Array": {},
      "qx.ui.mobile.form.Title": {},
      "qx.ui.mobile.form.Form": {},
      "qx.ui.mobile.form.TextField": {},
      "qx.ui.mobile.form.renderer.Single": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * @require(qxWeb)
   * @require(qx.module.Attribute)
   * @require(qx.module.Traversing)
   */
  qx.Class.define("qx.test.mobile.LocaleSwitch", {
    extend: qx.test.mobile.MobileTestCase,
    include: qx.locale.MTranslation,
    construct: function construct() {
      qx.test.mobile.MobileTestCase.constructor.call(this);
      this.manager = qx.locale.Manager.getInstance();
    },
    members: {
      manager: null,
      __translationAdded: null,
      setUp: function setUp() {
        qx.test.mobile.LocaleSwitch.prototype.setUp.base.call(this);

        if (!this.__translationAdded) {
          // add dummy translations
          this.manager.addTranslation("en_QX", {
            "test one": "test one",
            "test two": "test two",
            "test Hello %1!": "test Hello %1!",
            "test Jonny": "test Jonny"
          });
          this.manager.addTranslation("de_QX", {
            "test one": "Eins",
            "test two": "Zwei",
            "test Hello %1!": "Servus %1!",
            "test Jonny": "Jonathan"
          });
          this.__translationAdded = true;
        }

        this.manager.setLocale("en_QX");
      },
      tearDown: function tearDown() {
        qx.test.mobile.LocaleSwitch.prototype.tearDown.base.call(this);
        this.manager.resetLocale();
      },
      testLabel: function testLabel() {
        var label = new qx.ui.mobile.basic.Label(this.tr("test one"));
        this.addAutoDispose(label);
        this.getRoot().add(label);
        this.assertEquals("test one", label.getValue());
        this.manager.setLocale("de_QX");
        this.assertEquals("Eins", label.getValue());
        this.manager.setLocale("en_QX");
        label.setValue(this.tr("test Hello %1!", this.tr("test Jonny")));
        this.assertEquals("test Hello test Jonny!", label.getValue());
        this.manager.setLocale("de_QX");
        this.assertEquals("Servus Jonathan!", label.getValue()); // de -> en

        label.setValue(this.tr("test two"));
        this.assertEquals("Zwei", label.getValue());
        this.manager.setLocale("en_QX");
        this.assertEquals("test two", label.getValue());
        label.destroy();
      },
      testList: function testList() {
        var list = new qx.ui.mobile.list.List({
          configureItem: function configureItem(item, data, row) {
            item.setTitle(data.title);
            item.setSubtitle(data.subTitle);
          }
        });
        var data = [{
          title: this.tr("test one"),
          subTitle: this.tr("test two")
        }, {
          title: this.tr("test Hello %1!", this.tr("test Jonny")),
          subTitle: this.tr("test Jonny")
        }];
        list.setModel(new qx.data.Array(data));
        this.addAutoDispose(list);
        this.getRoot().add(list);

        this.__testListEn();

        this.manager.setLocale("de_QX");
        var title0 = q(".list * .list-item-title").eq(0).getHtml();
        this.assertEquals("Eins".title0);
        var subtitle0 = q(".list * .list-item-subtitle").eq(0).getHtml();
        this.assertEquals("Zwei", subtitle0);
        var title1 = q(".list * .list-item-title").eq(1).getHtml();
        this.assertEquals("Servus Jonathan!", title1);
        var subtitle1 = q(".list * .list-item-subtitle").eq(1).getHtml();
        this.assertEquals("Jonathan", subtitle1);
        this.manager.setLocale("en_QX");

        this.__testListEn();
      },
      __testListEn: function __testListEn() {
        //debugger
        var title0 = q(".list * .list-item-title").eq(0).getHtml();
        this.assertEquals("test one".title0);
        var subtitle0 = q(".list * .list-item-subtitle").eq(0).getHtml();
        this.assertEquals("test two", subtitle0);
        var title1 = q(".list * .list-item-title").eq(1).getHtml();
        this.assertEquals("test Hello test Jonny!", title1);
        var subtitle1 = q(".list * .list-item-subtitle").eq(1).getHtml();
        this.assertEquals("test Jonny", subtitle1);
      },
      testFormRendererSingle: function testFormRendererSingle() {
        var title = new qx.ui.mobile.form.Title(this.tr("test one"));
        this.addAutoDispose(title);
        var form = new qx.ui.mobile.form.Form();
        form.add(new qx.ui.mobile.form.TextField(), this.tr("test two"));
        this.getRoot().add(title);
        var renderer = new qx.ui.mobile.form.renderer.Single(form);
        this.addAutoDispose(renderer);
        this.getRoot().add(renderer);
        this.assertEquals("test one", title.getValue());
        this.assertEquals("test two", renderer._labels[0].getValue());
        this.manager.setLocale("de_QX");
        this.assertEquals("Eins", title.getValue());
        this.assertEquals("Zwei", renderer._labels[0].getValue());
        this.manager.setLocale("en_QX");
        title.destroy();
        renderer.destroy();
      }
    }
  });
  qx.test.mobile.LocaleSwitch.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.locale.Manager": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The label widget displays a text or HTML content.
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var label = new qx.ui.mobile.basic.Label("Hello World");
   *
   *   this.getRoot().add(label);
   * </pre>
   *
   * This example create a widget to display the label.
   *
   */
  qx.Class.define("qx.ui.mobile.basic.Label", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {String?null} Text or HTML content to display
     */
    construct: function construct(value) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (value) {
        this.setValue(value);
      }

      this.initWrap();
      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "label"
      },

      /**
       * Text or HTML content to display
       */
      value: {
        nullable: true,
        init: null,
        check: "String",
        apply: "_applyValue",
        event: "changeValue"
      },
      // overridden
      anonymous: {
        refine: true,
        init: true
      },

      /**
       * Controls whether text wrap is activated or not.
       */
      wrap: {
        check: "Boolean",
        init: true,
        apply: "_applyWrap"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // property apply
      _applyValue: function _applyValue(value, old) {
        this._setHtml(value);
      },
      // property apply
      _applyWrap: function _applyWrap(value, old) {
        if (value) {
          this.removeCssClass("no-wrap");
        } else {
          this.addCssClass("no-wrap");
        }
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale: function _onChangeLocale(e) {
        var content = this.getValue();

        if (content && content.translate) {
          this.setValue(content.translate());
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
    }
  });
  qx.ui.mobile.basic.Label.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.list.provider.Provider": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.bom.element.Class": {},
      "qx.bom.element.Attribute": {},
      "qx.dom.Element": {},
      "qx.bom.element.Dimension": {},
      "qx.bom.element.Style": {},
      "qx.bom.AnimationFrame": {},
      "qx.lang.Type": {},
      "qx.bom.Selector": {},
      "qx.lang.Object": {},
      "qx.util.Delegate": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The list widget displays the data of a model in a list.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *
   *    // Data for the list
   *    var data = [
   *       {title : "Row1", subtitle : "Sub1"},
   *       {title : "Row2", subtitle : "Sub2"},
   *       {title : "Row3", subtitle : "Sub3"}
   *   ];
   *
   *   // Create the list with a delegate that
   *   var list = new qx.ui.mobile.list.List({
   *     configureItem: function(item, data, row)
   *     {
   *       item.setImage("path/to/image.png");
   *       item.setTitle(data.title);
   *       item.setSubtitle(data.subtitle);
   *     },
   *
   *     configureGroupItem: function(item, data) {
   *       item.setTitle(data.title);
   *     },
   *
   *     group: function(data, row) {
   *      return {
   *       title: row < 2 ? "Selectable" : "Unselectable"
   *     };
   *    }
   *   });
   *
   *   // Set the model of the list
   *   list.setModel(new qx.data.Array(data));
   *
   *   // Add an changeSelection event
   *   list.addListener("changeSelection", function(evt) {
   *     alert("Index: " + evt.getData())
   *   }, this);
   *
   *   this.getRoot().add(list);
   * </pre>
   *
   * This example creates a list with a delegate that configures the list item with
   * the given data. A listener for the event {@link #changeSelection} is added.
   */
  qx.Class.define("qx.ui.mobile.list.List", {
    extend: qx.ui.mobile.core.Widget,

    /**
     * @param delegate {qx.ui.mobile.list.IListDelegate?null} The {@link #delegate} to use
     */
    construct: function construct(delegate) {
      qx.ui.mobile.core.Widget.constructor.call(this);
      this.__provider = new qx.ui.mobile.list.provider.Provider(this);
      this.addListener("tap", this._onTap, this);
      this.addListener("trackstart", this._onTrackStart, this);
      this.addListener("track", this._onTrack, this);
      this.addListener("trackend", this._onTrackEnd, this);

      if (delegate) {
        this.setDelegate(delegate);
      } else {
        this.setDelegate(this);
      }

      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      }
    },
    events: {
      /**
       * Fired when the selection is changed.
       */
      changeSelection: "qx.event.type.Data",

      /**
       * Fired when the group selection is changed.
       */
      changeGroupSelection: "qx.event.type.Data",

      /**
       * Fired when an item should be removed from list.
       */
      removeItem: "qx.event.type.Data"
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "list"
      },

      /**
       * Delegation object which can have one or more functions defined by the
       * {@link qx.ui.mobile.list.IListDelegate} interface.
       */
      delegate: {
        apply: "_applyDelegate",
        event: "changeDelegate",
        init: null,
        nullable: true
      },

      /**
       * The model to use to render the list.
       */
      model: {
        check: "qx.data.Array",
        apply: "_applyModel",
        event: "changeModel",
        nullable: true,
        init: null
      },

      /**
       * Number of items to display. Auto set by model.
       * Reset to limit the amount of data that should be displayed.
       */
      itemCount: {
        check: "Integer",
        init: 0
      },

      /**
      * The height of a list item.
      */
      itemHeight: {
        check: "Number",
        init: null,
        nullable: true
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      __provider: null,
      __minDeleteDistance: null,
      __isScrollingBlocked: null,
      __trackElement: null,
      // overridden
      _getTagName: function _getTagName() {
        return "ul";
      },

      /**
       * Default list delegate. Expects a map which contains an image, a subtitle, and a title:
       * <code>{title : "Row1", subtitle : "Sub1", image : "path/to/image.png"}</code>
       *
       * @param item {qx.ui.mobile.list.renderer.Abstract} Instance of list item renderer to modify
       * @param data {var} The data of the row. Can be used to configure the given item.
       * @param row {Integer} The row index.
       */
      configureItem: function configureItem(item, data, row) {
        if (typeof data.image != "undefined") {
          item.setImage(data.image);
        }

        if (typeof data.subtitle != "undefined") {
          item.setSubtitle(data.subtitle);
        }

        if (typeof data.title != "undefined") {
          item.setTitle(data.title);
        }

        if (typeof data.enabled != "undefined") {
          item.setEnabled(data.enabled);
        }

        if (typeof data.removable != "undefined") {
          item.setRemovable(data.removable);
        }

        if (typeof data.selectable != "undefined") {
          item.setSelectable(data.selectable);
        }

        if (typeof data.activatable != "undefined") {
          item.setActivatable(data.activatable);
        }

        if (typeof data.arrow != "undefined") {
          item.setShowArrow(data.arrow);
        }

        if (typeof data.selected != "undefined") {
          item.setSelected(data.selected);
        }
      },

      /**
       * Event handler for the "tap" event.
       *
       * @param evt {qx.event.type.Tap} The tap event
       */
      _onTap: function _onTap(evt) {
        var element = this._getElement(evt);

        if (!element) {
          return;
        }

        var row = -1;

        if (qx.bom.element.Class.has(element, "list-item")) {
          if (qx.bom.element.Attribute.get(element, "data-selectable") != "false" && qx.dom.Element.hasChild(this.getContainerElement(), element)) {
            row = parseInt(element.getAttribute("data-row"), 10);
          }

          if (row != -1) {
            this.fireDataEvent("changeSelection", row);
          }
        } else {
          var group = parseInt(element.getAttribute("data-group"), 10);

          if (qx.bom.element.Attribute.get(element, "data-selectable") != "false") {
            this.fireDataEvent("changeGroupSelection", group);
          }
        }
      },

      /**
      * Event handler for <code>trackstart</code> event.
      * @param evt {qx.event.type.Track} the <code>trackstart</code> event
      */
      _onTrackStart: function _onTrackStart(evt) {
        this.__isScrollingBlocked = null;
        this.__trackElement = null;

        var element = this._getElement(evt);

        if (element && qx.bom.element.Class.has(element, "list-item") && qx.bom.element.Class.has(element, "removable")) {
          this.__trackElement = element;
          this.__minDeleteDistance = qx.bom.element.Dimension.getWidth(element) / 2;
          qx.bom.element.Class.add(element, "track");
        }
      },

      /**
      * Event handler for <code>track</code> event.
      * @param evt {qx.event.type.Track} the <code>track</code> event
      */
      _onTrack: function _onTrack(evt) {
        if (!this.__trackElement) {
          return;
        }

        var element = this.__trackElement;
        var delta = evt.getDelta();
        var deltaX = Math.round(delta.x * 0.1) / 0.1;

        if (this.__isScrollingBlocked === null) {
          this.__isScrollingBlocked = delta.axis == "x";
        }

        if (!this.__isScrollingBlocked) {
          return;
        }

        var opacity = 1 - Math.abs(deltaX) / this.__minDeleteDistance;

        opacity = Math.round(opacity * 100) / 100;
        qx.bom.element.Style.set(element, "transform", "translate3d(" + deltaX + "px,0,0)");
        qx.bom.element.Style.set(element, "opacity", opacity);
        evt.preventDefault();
      },

      /**
      * Event handler for <code>trackend</code> event.
      * @param evt {qx.event.type.Track} the <code>trackend</code> event
      */
      _onTrackEnd: function _onTrackEnd(evt) {
        if (!this.__trackElement) {
          return;
        }

        var element = this.__trackElement;

        if (Math.abs(evt.getDelta().x) > this.__minDeleteDistance) {
          var row = parseInt(element.getAttribute("data-row"), 10);
          this.fireDataEvent("removeItem", row);
        } else {
          qx.bom.AnimationFrame.request(function () {
            qx.bom.element.Style.set(element, "transform", "translate3d(0,0,0)");
            qx.bom.element.Style.set(element, "opacity", "1");
            qx.bom.element.Class.remove(element, "track");
          }.bind(this));
        }
      },

      /**
      * Returns the target list item.
      * @param evt {Event} the input event
      * @return {Element} the target list item.
      */
      _getElement: function _getElement(evt) {
        var element = evt.getOriginalTarget(); // Click on border: do nothing.

        if (element.tagName == "UL") {
          return null;
        }

        while (element.tagName != "LI") {
          element = element.parentNode;
        }

        return element;
      },
      // property apply
      _applyModel: function _applyModel(value, old) {
        if (old != null) {
          old.removeListener("changeBubble", this.__onModelChangeBubble, this);
        }

        if (value != null) {
          value.addListener("changeBubble", this.__onModelChangeBubble, this);
        }

        if (old != null) {
          old.removeListener("change", this.__onModelChange, this);
        }

        if (value != null) {
          value.addListener("change", this.__onModelChange, this);
        }

        if (old != null) {
          old.removeListener("changeLength", this.__onModelChangeLength, this);
        }

        if (value != null) {
          value.addListener("changeLength", this.__onModelChangeLength, this);
        }

        this.__render();
      },
      // property apply
      _applyDelegate: function _applyDelegate(value, old) {
        this.__provider.setDelegate(value);
      },

      /**
       * Listen on model 'changeLength' event.
       * @param evt {qx.event.type.Data} data event which contains model change data.
       */
      __onModelChangeLength: function __onModelChangeLength(evt) {
        this.__render();
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale: function _onChangeLocale(e) {
        this.__render();
      },

      /**
       * Reacts on model 'change' event.
       * @param evt {qx.event.type.Data} data event which contains model change data.
       */
      __onModelChange: function __onModelChange(evt) {
        if (evt && evt.getData() && evt.getData().type == "order") {
          this.__render();
        }
      },

      /**
       * Reacts on model 'changeBubble' event.
       * @param evt {qx.event.type.Data} data event which contains model changeBubble data.
       */
      __onModelChangeBubble: function __onModelChangeBubble(evt) {
        if (evt) {
          var data = evt.getData();
          var isArray = qx.lang.Type.isArray(data.old) && qx.lang.Type.isArray(data.value);

          if (!isArray || isArray && data.old.length == data.value.length) {
            var rows = this._extractRowsToRender(data.name);

            for (var i = 0; i < rows.length; i++) {
              this.__renderRow(rows[i]);
            }
          }
        }
      },

      /**
       * Extracts all rows, which should be rendered from "changeBubble" event's
       * data.name.
       * @param name {String} The 'data.name' String of the "changeBubble" event,
       *    which contains the rows that should be rendered.
       * @return {Integer[]} An array with integer values, representing the rows which should
       *  be rendered.
       */
      _extractRowsToRender: function _extractRowsToRender(name) {
        var rows = [];

        if (!name) {
          return rows;
        } // "[0-2].propertyName" | "[0].propertyName" | "0"


        var containsPoint = name.indexOf(".") != -1;

        if (containsPoint) {
          // "[0-2].propertyName" | "[0].propertyName"
          var candidate = name.split(".")[0]; // Normalize

          candidate = candidate.replace("[", "");
          candidate = candidate.replace("]", ""); // "[0-2]" | "[0]"

          var isRange = candidate.indexOf("-") != -1;

          if (isRange) {
            var rangeMembers = candidate.split("-"); // 0

            var startRange = parseInt(rangeMembers[0], 10); // 2

            var endRange = parseInt(rangeMembers[1], 10);

            for (var i = startRange; i <= endRange; i++) {
              rows.push(i);
            }
          } else {
            // "[0]"
            rows.push(parseInt(candidate.match(/\d+/)[0], 10));
          }
        } else {
          // "0"
          var match = name.match(/\d+/);

          if (match.length == 1) {
            rows.push(parseInt(match[0], 10));
          }
        }

        return rows;
      },

      /**
       * Renders a specific row identified by its index.
       * @param index {Integer} index of the row which should be rendered.
       */
      __renderRow: function __renderRow(index) {
        var renderedItems = qx.bom.Selector.query(".list-item", this.getContentElement());
        var oldNode = renderedItems[index];

        var newNode = this.__provider.getItemElement(this.getModel().getItem(index), index);

        this.getContentElement().replaceChild(newNode, oldNode);

        this._domUpdated();
      },

      /**
      * @internal
      * Returns the height of one single list item.
      * @return {Integer} the height of a list item in px.
      */
      getListItemHeight: function getListItemHeight() {
        var listItemHeight = 0;

        if (this.getModel() != null && this.getModel().length > 0) {
          var listHeight = qx.bom.element.Style.get(this.getContentElement(), "height");
          listItemHeight = parseInt(listHeight) / this.getModel().length;
        }

        return listItemHeight;
      },

      /**
       * Renders the list.
       */
      __render: function __render() {
        this._setHtml("");

        var model = this.getModel();
        this.setItemCount(model ? model.getLength() : 0);
        var groupIndex = 0;

        for (var index = 0; index < this.getItemCount(); index++) {
          if (this.__hasGroup()) {
            var groupElement = this._renderGroup(index, groupIndex);

            if (groupElement) {
              groupIndex++;
              this.getContentElement().appendChild(groupElement);
            }
          }

          var item = model.getItem(index);

          var itemElement = this.__provider.getItemElement(item, index);

          var itemHeight = null;

          if (this.getItemHeight() !== null) {
            itemHeight = this.getItemHeight() + "px";
          } // Fixed height


          qx.bom.element.Style.set(itemElement, "minHeight", itemHeight);
          qx.bom.element.Style.set(itemElement, "maxHeight", itemHeight);
          this.getContentElement().appendChild(itemElement);
        }

        this._domUpdated();
      },

      /**
       * Triggers a re-rendering of this list.
       */
      render: function render() {
        this.__render();
      },

      /**
      * Renders a group header.
      *
      * @param itemIndex {Integer} the current list item index.
      * @param groupIndex {Integer} the group index.
      * @return {Element} the group element or <code>null</code> if no group was needed.
      */
      _renderGroup: function _renderGroup(itemIndex, groupIndex) {
        var group = this.__getGroup(itemIndex);

        if (itemIndex === 0) {
          return this.__provider.getGroupElement(group, groupIndex);
        } else {
          var previousGroup = this.__getGroup(itemIndex - 1);

          if (!qx.lang.Object.equals(group, previousGroup)) {
            return this.__provider.getGroupElement(group, groupIndex);
          }
        }
      },

      /**
      * Checks whether the delegate support group rendering.
      * @return {Boolean} true if the delegate object supports grouping function.
      */
      __hasGroup: function __hasGroup() {
        return qx.util.Delegate.getMethod(this.getDelegate(), "group") !== null;
      },

      /**
       * Returns the group for this item, identified by its index
       * @param index {Integer} the item index.
       * @return {Object} the group object, to which the item belongs to.
       */
      __getGroup: function __getGroup(index) {
        var item = this.getModel().getItem(index);
        var group = qx.util.Delegate.getMethod(this.getDelegate(), "group");
        return group(item, index);
      }
    },
    destruct: function destruct() {
      this.__trackElement = null;

      this._disposeObjects("__provider");

      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
    }
  });
  qx.ui.mobile.list.List.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.basic.Label": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Shows a title text for {@link Form} or {@link Group}.
   */
  qx.Class.define("qx.ui.mobile.form.Title", {
    extend: qx.ui.mobile.basic.Label,
    properties: {
      wrap: {
        refine: true,
        init: false
      },
      // overridden
      defaultCssClass: {
        refine: true,
        init: "form-title"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "h2";
      }
    }
  });
  qx.ui.mobile.form.Title.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Form": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Representation of a form. A form widget can contain one or more {@link Row} widgets.
   *
   * *Example*
   *
   * Here is an example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var title = new qx.ui.mobile.form.Title("Group");
   *   var form = new qx.ui.mobile.form.Form();
   *   form.add(new qx.ui.mobile.form.TextField(), "Username: ");
   *
   *   this.getRoot().add(title);
   *   this.getRoot().add(new qx.ui.mobile.form.renderer.Single(form));
   * </pre>
   *
   * This example creates a form and adds a row with a text field in it.
   */
  qx.Class.define("qx.ui.mobile.form.Form", {
    extend: qx.ui.form.Form,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.form.Form.constructor.call(this);
      this.__invalidItems = [];
    },
    members: {
      /**
       * the renderer this form uses to be displayed
       */
      __renderer: null,

      /**
       * Contains all invalid items.
       */
      __invalidItems: null,

      /**
       * Setter for the renderer private variable
       * @param renderer {qx.ui.mobile.form.renderer.AbstractRenderer} the renderer
       */
      setRenderer: function setRenderer(renderer) {
        this.__renderer = renderer;
      },

      /**
       * Validates the form using the
       * {@link qx.ui.form.validation.Manager#validate} method.
       * @lint ignoreDeprecated(alert)
       *
       * @return {Boolean | null} The validation result.
       */
      validate: function validate() {
        var validateResult = qx.ui.mobile.form.Form.prototype.validate.base.call(this);
        this.__invalidItems = [];

        if (this.__renderer != null) {
          this.__renderer.resetForm();
        }

        var groups = this.getGroups();

        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];

          for (var j = 0; j < group.items.length; j++) {
            var item = group.items[j];

            if (!item.isValid()) {
              this.__invalidItems.push(item);

              if (this.__renderer != null) {
                this.__renderer.showErrorForItem(item);
              } else {
                alert('error ' + item.getInvalidMessage());
              }
            }
          }
        }

        if (this.__renderer != null) {
          this.__renderer._domUpdated();
        }

        return validateResult;
      },

      /**
       * Makes a row visible, identified by its group and row index.
       * @param groupIndex {Integer} the index of the group to which the row belongs to
       * @param rowIndex {Integer} the index of the row inside the target group
       */
      showRow: function showRow(groupIndex, rowIndex) {
        var item = this._getItemByIndex(groupIndex, rowIndex);

        if (item) {
          this.__renderer.showItem(item);
        }
      },

      /**
       * Makes a row invisible, identified by its group and row index.
       * @param groupIndex {Integer} the index of the group to which the row belongs to
       * @param rowIndex {Integer} the index of the row inside the target group
       */
      hideRow: function hideRow(groupIndex, rowIndex) {
        var item = this._getItemByIndex(groupIndex, rowIndex);

        if (item) {
          this.__renderer.hideItem(item);
        }
      },

      /**
       * Gets the item with the given group and rowIndex.
       * @param groupIndex {Integer} the index of the group to which the row belongs to
       * @param rowIndex {Integer} the index of the row inside the target group
       * @return {qx.ui.form.IForm | null} The validation result.
       */
      _getItemByIndex: function _getItemByIndex(groupIndex, rowIndex) {
        var groups = this.getGroups();
        var group = groups[groupIndex];

        if (group) {
          var item = group.items[rowIndex];
          return item;
        }

        return null;
      },
      // overridden
      reset: function reset() {
        qx.ui.mobile.form.Form.prototype.reset.base.call(this);

        this.__renderer.resetForm();
      },

      /**
      * Returns the invalid items of the form, which were determined by {@link qx.ui.mobile.form.Form#validate} before.
      * It returns an empty array if no items are invalid.
      * @return {qx.ui.mobile.core.Widget[]} The invalid items of the form.
      */
      getInvalidItems: function getInvalidItems() {
        return this.__invalidItems;
      }
    }
  });
  qx.ui.mobile.form.Form.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Scroll": {},
      "qx.ui.mobile.core.Root": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The mixin contains all functionality to provide methods
   * for scroll container handling: determine the parent scroll container.
   *
   */
  qx.Mixin.define("qx.ui.mobile.container.MScrollHandling", {
    members: {
      /**
       * Returns the parent scroll container of this widget.
       * @return {qx.ui.mobile.container.Scroll} the parent scroll container or <code>null</code>
       */
      _getParentScrollContainer: function _getParentScrollContainer() {
        var scroll = this;

        while (!(scroll instanceof qx.ui.mobile.container.Scroll)) {
          if (scroll.getLayoutParent) {
            var layoutParent = scroll.getLayoutParent();

            if (layoutParent === null || layoutParent instanceof qx.ui.mobile.core.Root) {
              return null;
            }

            scroll = layoutParent;
          } else {
            return null;
          }
        }

        return scroll;
      }
    }
  });
  qx.ui.mobile.container.MScrollHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * The mixin contains all functionality to provide methods
   * for form elements to manipulate their state. [usually "valid" and "invalid"]
   *
   */
  qx.Mixin.define("qx.ui.mobile.form.MState", {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * The states of the element
       */
      __states: null,

      /**
       * Adds a state to the element
       * @param state {String} the state to be added
       *
       */
      addState: function addState(state) {
        if (this.__states === null) {
          this.__states = {};
        }

        this.__states[state] = true;
        this.addCssClass(state);
      },

      /**
       * Checks whether the element has the state passed as argument
       * @param state {String} the state to be checked
       * @return {Boolean} true if the element has the state, false if it doesn't.
       *
       */
      hasState: function hasState(state) {
        return this.__states !== null && this.__states[state];
      },

      /**
       * Removes a state from the element
       * @param state {String} the state to be removed
       *
       */
      removeState: function removeState(state) {
        if (this.hasState(state)) {
          delete this.__states[state];
          this.removeCssClass(state);
        }
      },

      /**
       * Replaces a state of the element with a new state.
       * If the element doesn't have the state to be removed, then th new state will
       * just be added.
       * @param oldState {String} the state to be replaced
       * @param newState {String} the state to get injected in the oldState's place
       *
       */
      replaceState: function replaceState(oldState, newState) {
        if (this.hasState(oldState)) {
          delete this.__states[oldState];
          this.__states[newState] = true;
          this.removeCssClass(oldState);
          this.addCssClass(newState);
        } else {
          this.addState(newState);
        }
      }
    }
  });
  qx.ui.mobile.form.MState.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.mobile.container.MScrollHandling": {
        "require": true
      },
      "qx.ui.mobile.form.MState": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.mobile.form.TextField": {},
      "qx.ui.mobile.form.NumberField": {},
      "qx.bom.AnimationFrame": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Abstract class for all input fields.
   */
  qx.Class.define("qx.ui.mobile.form.Input", {
    extend: qx.ui.mobile.core.Widget,
    include: [qx.ui.form.MForm, qx.ui.form.MModelProperty, qx.ui.mobile.container.MScrollHandling, qx.ui.mobile.form.MState],
    implement: [qx.ui.form.IForm, qx.ui.form.IModel],
    type: "abstract",
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);

      this._setAttribute("type", this._getType());

      this.addCssClass("gap");
      this.addListener("focus", this._onSelected, this);
    },
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "input";
      },

      /**
       * Returns the type of the input field. Override this method in the
       * specialized input class.
       */
      _getType: function _getType() {
        {
          throw new Error("Abstract method call");
        }
      },

      /**
       * Handles the <code>click</code> and <code>focus</code> event on this input widget.
       * @param evt {qx.event.type.Event} <code>click</code> or <code>focus</code> event
       */
      _onSelected: function _onSelected(evt) {
        if (!(evt.getTarget() instanceof qx.ui.mobile.form.TextField) && !(evt.getTarget() instanceof qx.ui.mobile.form.NumberField)) {
          return;
        }

        var scrollContainer = this._getParentScrollContainer();

        if (scrollContainer === null) {
          return;
        }

        setTimeout(function () {
          scrollContainer.scrollToWidget(this.getLayoutParent(), 0); // Refresh caret position after scrolling.

          this._setStyle("position", "relative");

          qx.bom.AnimationFrame.request(function () {
            this._setStyle("position", null);
          }, this);
        }.bind(this), 300);
      }
    },
    destruct: function destruct() {
      this.removeListener("focus", this._onSelected, this);
    }
  });
  qx.ui.mobile.form.Input.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.event.handler.Input": {
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.Registration": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The mixin contains all functionality to provide a value property for input
   * widgets.
   *
   * @require(qx.event.handler.Input)
   */
  qx.Mixin.define("qx.ui.mobile.form.MValue", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {var?null} The value of the widget.
     */
    construct: function construct(value) {
      if (value) {
        this.setValue(value);
      }

      if (this._getTagName() == "input" || this._getTagName() == "textarea") {
        qx.event.Registration.addListener(this.getContentElement(), "change", this._onChangeContent, this);
        qx.event.Registration.addListener(this.getContentElement(), "input", this._onInput, this);
      }

      this.addListener("focus", this._onFocus, this);
      this.addListener("blur", this._onBlur, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * The event is fired on every keystroke modifying the value of the field.
       *
       * The method {@link qx.event.type.Data#getData} returns the
       * current value of the text field.
       */
      "input": "qx.event.type.Data",

      /**
       * The event is fired each time the text field looses focus and the
       * text field values has changed.
       *
       * If you change {@link #liveUpdate} to true, the changeValue event will
       * be fired after every keystroke and not only after every focus loss. In
       * that mode, the changeValue event is equal to the {@link #input} event.
       *
       * The method {@link qx.event.type.Data#getData} returns the
       * current text value of the field.
       */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether the {@link #changeValue} event should be fired on every key
       * input. If set to true, the changeValue event is equal to the
       * {@link #input} event.
       */
      liveUpdate: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __oldValue: null,
      __inputTimeoutHandle: null,
      __hasFocus: null,

      /**
       * Converts the incoming value.
       *
       * @param value {var} The value to convert
       * @return {var} The converted value
       */
      _convertValue: function _convertValue(value) {
        if (typeof value === 'boolean') {
          return value;
        } else if (typeof value === 'number') {
          return value;
        } else {
          return value || "";
        }
      },

      /**
      * Handler for <code>focus</code> event.
      */
      _onFocus: function _onFocus() {
        this.__hasFocus = true;
      },

      /**
      * Handler for <code>blur</code> event.
      */
      _onBlur: function _onBlur() {
        this.__hasFocus = false;
      },

      /**
      * Returns whether this widget has focus or not.
      * @return {Boolean} <code>true</code> or <code>false</code>
      */
      hasFocus: function hasFocus() {
        return this.__hasFocus;
      },

      /**
       * Sets the value.
       *
       * @param value {var} The value to set
       */
      setValue: function setValue(value) {
        value = this._convertValue(value);

        if (this.__oldValue != value) {
          if (this._setValue) {
            this._setValue(value);
          } else {
            this._setAttribute("value", value);
          }

          this.__fireChangeValue(value);
        }
      },

      /**
       * Returns the set value.
       *
       * @return {var} The set value
       */
      getValue: function getValue() {
        return this._convertValue(this._getValue ? this._getValue() : this._getAttribute("value"));
      },

      /**
       * Resets the value.
       */
      resetValue: function resetValue() {
        this.setValue(null);
      },

      /**
       * Event handler. Called when the {@link #changeValue} event occurs.
       *
       * @param evt {qx.event.type.Data} The event, containing the changed content.
       */
      _onChangeContent: function _onChangeContent(evt) {
        this.__fireChangeValue(this._convertValue(evt.getData()));
      },

      /**
       * Event handler. Called when the {@link #input} event occurs.
       *
       * @param evt {qx.event.type.Data} The event, containing the changed content.
       */
      _onInput: function _onInput(evt) {
        var data = evt.getData();
        this.fireDataEvent("input", data, true);

        if (this.getLiveUpdate()) {
          if (this._setValue) {
            this._setValue(data);
          } else {
            this.__fireChangeValue(this._convertValue(data));
          }
        }
      },

      /**
      * Returns the caret position of this widget.
      * @return {Integer} the caret position.
      */
      _getCaretPosition: function _getCaretPosition() {
        var val = this.getContentElement().value;

        if (val && this._getAttribute("type") !== "number") {
          return val.slice(0, this.getContentElement().selectionStart).length;
        } else {
          return val.length;
        }
      },

      /**
       * Sets the caret position on this widget.
       * @param position {Integer} the caret position.
       */
      _setCaretPosition: function _setCaretPosition(position) {
        if (position != null && this.hasFocus()) {
          if (this._getAttribute("type") !== "number" && this.getContentElement().setSelectionRange) {
            this.getContentElement().setSelectionRange(position, position);
          }
        }
      },

      /**
       * Fires the {@link #changeValue} event.
       *
       * @param value {var} The current value to fire.
       */
      __fireChangeValue: function __fireChangeValue(value) {
        if (this.__oldValue != value) {
          this.__oldValue = value;
          this.fireDataEvent("changeValue", value);
        }
      }
    },
    destruct: function destruct() {
      this.removeListener("focus", this._onFocus, this);
      this.removeListener("blur", this._onBlur, this);
    }
  });
  qx.ui.mobile.form.MValue.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.event.handler.Input": {
        "require": true
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.OperatingSystem": {},
      "qx.bom.Element": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "os.name": {
          "className": "qx.bom.client.OperatingSystem"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The mixin contains all functionality to provide common properties for
   * text fields.
   *
   * @require(qx.event.handler.Input)
   */
  qx.Mixin.define("qx.ui.mobile.form.MText", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {var?null} The value of the widget.
     */
    construct: function construct(value) {
      this.initMaxLength();
      this.initPlaceholder();
      this.initReadOnly();
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
        * Maximal number of characters that can be entered in the input field.
        */
      maxLength: {
        check: "PositiveInteger",
        nullable: true,
        init: null,
        apply: "_applyMaxLength"
      },

      /**
       * String value which will be shown as a hint if the field is all of:
       * unset, unfocused and enabled. Set to <code>null</code> to not show a placeholder
       * text.
       */
      placeholder: {
        check: "String",
        nullable: true,
        init: null,
        apply: "_applyPlaceholder"
      },

      /** Whether the field is read only */
      readOnly: {
        check: "Boolean",
        nullable: true,
        init: null,
        apply: "_applyAttribute"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // property apply
      _applyMaxLength: function _applyMaxLength(value, old) {
        this._setAttribute("maxlength", value);
      },
      // property apply
      _applyPlaceholder: function _applyPlaceholder(value, old) {
        // Android is not able to indent placeholder.
        // Adding a space before the placeholder text, as a fix.
        if (qx.core.Environment.get("os.name") == "android" && value !== null) {
          value = " " + value;
        }

        this._setAttribute("placeholder", value);
      },

      /**
       * Points the focus of the form to this widget.
       */
      focus: function focus() {
        if (this.isReadOnly() || this.getEnabled() == false) {
          return;
        }

        var targetElement = this.getContainerElement();

        if (targetElement) {
          qx.bom.Element.focus(targetElement);
        }
      },

      /**
       * Removes the focus from this widget.
       */
      blur: function blur() {
        var targetElement = this.getContainerElement();

        if (targetElement) {
          qx.bom.Element.blur(targetElement);
        }
      }
    }
  });
  qx.ui.mobile.form.MText.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Input": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.mobile.form.MText": {
        "require": true
      },
      "qx.ui.form.IStringForm": {
        "require": true
      },
      "qx.bom.client.OperatingSystem": {
        "construct": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "os.name": {
          "construct": true,
          "className": "qx.bom.client.OperatingSystem"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The TextField is a single-line text input field.
   */
  qx.Class.define("qx.ui.mobile.form.TextField", {
    extend: qx.ui.mobile.form.Input,
    include: [qx.ui.mobile.form.MValue, qx.ui.mobile.form.MText],
    implement: [qx.ui.form.IStringForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {var?null} The value of the widget.
     */
    construct: function construct(value) {
      qx.ui.mobile.form.Input.constructor.call(this);
      this.addListener("keypress", this._onKeyPress, this);

      if (qx.core.Environment.get("os.name") == "ios") {
        // IOS does not blur input fields automatically if a parent DOM element
        // was set invisible, so blur manually on disappear
        this.addListener("disappear", this.blur, this);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "text-field"
      }
    },
    members: {
      // overridden
      _getType: function _getType() {
        return "text";
      },

      /**
      * Event handler for <code>keypress</code> event.
      * @param evt {qx.event.type.KeySequence} the keypress event.
      */
      _onKeyPress: function _onKeyPress(evt) {
        // On return
        if (evt.getKeyCode() == 13) {
          this.blur();
        }
      }
    },
    destruct: function destruct() {
      this.removeListener("keypress", this._onKeyPress, this);

      if (qx.core.Environment.get("os.name") == "ios") {
        this.removeListener("disappear", this.blur, this);
      }
    }
  });
  qx.ui.mobile.form.TextField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This interface defines the necessary features a form renderer should have.
   * Keep in mind that all renderes has to be widgets.
   */
  qx.Interface.define("qx.ui.form.renderer.IFormRenderer", {
    members: {
      /**
       * Add a group of form items with the corresponding names. The names should
       * be displayed as hint for the user what to do with the form item.
       * The title is optional and can be used as grouping for the given form
       * items.
       *
       * @param items {qx.ui.core.Widget[]} An array of form items to render.
       * @param names {String[]} An array of names for the form items.
       * @param title {String?} A title of the group you are adding.
       * @param itemsOptions {Array?null} The added additional data.
       * @param headerOptions {Map?null} The options map as defined by the form
       *   for the current group header.
       */
      addItems: function addItems(items, names, title, itemsOptions, headerOptions) {},

      /**
       * Adds a button the form renderer.
       *
       * @param button {qx.ui.form.Button} A button which should be added to
       *   the form.
       * @param options {Map?null} The added additional data.
       */
      addButton: function addButton(button, options) {}
    }
  });
  qx.ui.form.renderer.IFormRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.renderer.IFormRenderer": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * AbstractRenderer is an abstract class used to encapsulate
   * behaviours of how a form can be rendered into a mobile page.
   * Its subclasses can extend it and override {@link #addItems} and {@link #addButton}
   * methods in order to customize the way the form gets into the DOM.
   *
   *
   */
  qx.Class.define("qx.ui.mobile.form.renderer.AbstractRenderer", {
    type: "abstract",
    extend: qx.ui.mobile.core.Widget,
    implement: qx.ui.form.renderer.IFormRenderer,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param form {qx.ui.mobile.form.Form} The form to be rendered
     */
    construct: function construct(form) {
      qx.ui.mobile.core.Widget.constructor.call(this);
      this._form = form;

      this._render();

      form.addListener("change", this._onFormChange, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "form"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _form: null,

      /**
       * Handler responsible for updating the rendered widget as soon as the
       * form changes.
       */
      _onFormChange: function _onFormChange() {
        this._removeAll();

        this.resetForm();

        this._render();
      },

      /**
       * Renders the for: adds the items and buttons.
       */
      _render: function _render() {
        // add the groups
        var groups = this._form.getGroups();

        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          this.addItems(group.items, group.labels, group.title, group.options, group.headerOptions);
        } // add the buttons


        var buttons = this._form.getButtons();

        var buttonOptions = this._form.getButtonOptions();

        for (var i = 0; i < buttons.length; i++) {
          this.addButton(buttons[i], buttonOptions[i]);
        }

        this._form.setRenderer(this);
      },
      // interface implementation
      addItems: function addItems(items, names, title) {
        throw new Error("Abstract method call");
      },
      // interface implementation
      addButton: function addButton(button) {
        throw new Error("Abstract method call");
      },

      /**
       * Shows an error to the user when a form element is in invalid state
       * usually it prints an error message, so that user can rectify the filling of the form element.
       * @param item {qx.ui.mobile.core.Widget} the form item
       */
      showErrorForItem: function showErrorForItem(item) {
        throw new Error("Abstract method call");
      },

      /**
       *
       * Resets the errors for the form by removing any error messages
       * inserted into DOM in the case of invalid form elements
       *
       */
      resetForm: function resetForm() {
        throw new Error("Abstract method call");
      }
    }
  });
  qx.ui.mobile.form.renderer.AbstractRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.mobile.form.MState": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.mobile.container.Composite": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * A toggle Button widget
   *
   * If the user tap the button, the button toggles between the <code>ON</code>
   * and <code>OFF</code> state.
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.mobile.form.ToggleButton(false,"YES","NO");
   *
   *   button.addListener("changeValue", function(e) {
   *     alert(e.getData());
   *   }, this);
   *
   *   this.getRoot.add(button);
   * </pre>
   *
   * This example creates a toggle button and attaches an
   * event listener to the {@link #changeValue} event.
   */
  qx.Class.define("qx.ui.mobile.form.ToggleButton", {
    extend: qx.ui.mobile.core.Widget,
    include: [qx.ui.mobile.form.MValue, qx.ui.form.MForm, qx.ui.form.MModelProperty, qx.ui.mobile.form.MState],
    implement: [qx.ui.form.IField, qx.ui.form.IForm, qx.ui.form.IModel],

    /**
     * @param value {Boolean?null} The value of the button
     * @param labelChecked {Boolean?"ON"} The value of the text display when toggleButton is active
     * @param labelUnchecked {Boolean?"OFF"} The value of the text display when toggleButton is inactive
     */
    construct: function construct(value, labelChecked, labelUnchecked) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (labelChecked && labelUnchecked) {
        this.__labelUnchecked = labelUnchecked;
        this.__labelChecked = labelChecked;
      }

      this._setAttribute("data-label-checked", this.__labelChecked);

      this._setAttribute("data-label-unchecked", this.__labelUnchecked);

      this.__switch = this._createSwitch();

      this._add(this.__switch);

      if (value) {
        this.setValue(value);
      }

      this.addListener("tap", this._onTap, this);
      this.addListener("swipe", this._onSwipe, this);
      this.addCssClass("gap");
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "togglebutton"
      }
    },
    members: {
      __switch: null,
      __value: false,
      __labelUnchecked: "OFF",
      __labelChecked: "ON",
      __lastToggleTimestamp: 0,

      /**
       * Returns the child control of the toggle button.
       *
       * @return {qx.ui.mobile.container.Composite} the child control.
       */
      _getChild: function _getChild() {
        return this.__switch;
      },

      /**
       * Creates the switch control of the widget.
       * @return {qx.ui.mobile.container.Composite} The switch control.
       */
      _createSwitch: function _createSwitch() {
        var toggleButtonSwitch = new qx.ui.mobile.container.Composite();
        toggleButtonSwitch.addCssClass("togglebutton-switch");
        return toggleButtonSwitch;
      },

      /**
       * Sets the value [true/false] of this toggle button.
       * It is called by setValue method of qx.ui.mobile.form.MValue mixin
       * @param value {Boolean} the new value of the toggle button
       */
      _setValue: function _setValue(value) {
        if (typeof value !== 'boolean') {
          throw new Error("value for " + this + " should be boolean");
        }

        if (value) {
          this.addCssClass("checked");
        } else {
          this.removeCssClass("checked");
        }

        this.__value = value;
      },

      /**
       * Gets the value [true/false] of this toggle button.
       * It is called by getValue method of qx.ui.mobile.form.MValue mixin
       * @return {Boolean} the value of the toggle button
       */
      _getValue: function _getValue() {
        return this.__value;
      },

      /**
       * Toggles the value of the button.
       */
      toggle: function toggle() {
        this.setValue(!this.getValue());
      },

      /**
       * Event handler. Called when the tap event occurs.
       * Toggles the button.
       *
       * @param evt {qx.event.type.Tap} The tap event.
       */
      _onTap: function _onTap(evt) {
        if (this._checkLastPointerTime()) {
          this.toggle();
        }
      },

      /**
       * Event handler. Called when the swipe event occurs.
       * Toggles the button, when.
       *
       * @param evt {qx.event.type.Swipe} The swipe event.
       */
      _onSwipe: function _onSwipe(evt) {
        if (this._checkLastPointerTime()) {
          var direction = evt.getDirection();

          if (direction == "left") {
            if (this.__value == true) {
              this.toggle();
            }
          } else {
            if (this.__value == false) {
              this.toggle();
            }
          }
        }
      },

      /**
       * Checks if last touch event (swipe,tap) is more than 500ms ago.
       * Bugfix for several simulator/emulator, when tap is immediately followed by a swipe.
       * @return {Boolean} <code>true</code> if the last event was more than 500ms ago
       */
      _checkLastPointerTime: function _checkLastPointerTime() {
        var elapsedTime = new Date().getTime() - this.__lastToggleTimestamp;

        this.__lastToggleTimestamp = new Date().getTime();
        return elapsedTime > 500;
      }
    },
    destruct: function destruct() {
      this.removeListener("tap", this._onTap, this);
      this.removeListener("swipe", this._onSwipe, this);

      this._disposeObjects("__switch", "__labelUnchecked", "__labelChecked");
    }
  });
  qx.ui.mobile.form.ToggleButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Input": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.event.Registration": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The Radio button for mobile.
   *
   * *Example*
   *
   * <pre class='javascript'>
   *    var form = new qx.ui.mobile.form.Form();
   *
   *    var radio1 = new qx.ui.mobile.form.RadioButton();
   *    var radio2 = new qx.ui.mobile.form.RadioButton();
   *    var radio3 = new qx.ui.mobile.form.RadioButton();
   *
   *    var group = new qx.ui.mobile.form.RadioGroup(radio1, radio2, radio3);
  
   *    form.add(radio1, "Germany");
   *    form.add(radio2, "UK");
   *    form.add(radio3, "USA");
   *
   *    this.getRoot.add(new qx.ui.mobile.form.renderer.Single(form));
   * </pre>
   *
   *
   */
  qx.Class.define("qx.ui.mobile.form.RadioButton", {
    extend: qx.ui.mobile.form.Input,
    include: [qx.ui.mobile.form.MValue],
    implement: [qx.ui.form.IField],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {Boolean?null} The value of the checkbox.
     */
    construct: function construct(value) {
      qx.ui.mobile.form.Input.constructor.call(this);
      this.addListener("tap", this._onTap, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the selection value is changed.
       */
      changeValue: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "radio"
      },

      /** The assigned qx.ui.form.RadioGroup which handles the switching between registered buttons */
      group: {
        check: "qx.ui.mobile.form.RadioGroup",
        nullable: true,
        apply: "_applyGroup"
      }
    },
    members: {
      _state: null,
      // overridden
      _getTagName: function _getTagName() {
        return "span";
      },
      // overridden
      _getType: function _getType() {
        return null;
      },

      /**
       * Reacts on tap on radio button.
       */
      _onTap: function _onTap() {
        this.fireDataEvent("changeValue", {}); // Toggle State.

        this.setValue(true);
      },

      /**
       * The assigned {@link qx.ui.form.RadioGroup} which handles the switching between registered buttons
       * @param value {qx.ui.form.RadioGroup} the new radio group to which this radio button belongs.
       * @param old {qx.ui.form.RadioGroup} the old radio group of this radio button.
       */
      _applyGroup: function _applyGroup(value, old) {
        if (old) {
          old.remove(this);
        }

        if (value) {
          value.add(this);
        }
      },

      /**
       * Sets the value [true/false] of this radio button.
       * It is called by setValue method of qx.ui.mobile.form.MValue mixin
       * @param value {Boolean} the new value of the radio button
       */
      _setValue: function _setValue(value) {
        if (value == true) {
          this.addCssClass("checked");
        } else {
          this.removeCssClass("checked");
        }

        this._state = value;
      },

      /**
       * Gets the value [true/false] of this radio button.
       * It is called by getValue method of qx.ui.mobile.form.MValue mixin
       * @return {Boolean} the value of the radio button
       */
      _getValue: function _getValue() {
        return this._state;
      }
    },

    /*
    *****************************************************************************
        DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      qx.event.Registration.removeListener(this, "tap", this._onTap, this);
    }
  });
  qx.ui.mobile.form.RadioButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.TextField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The PasswordField is a single-line password input field.
   */
  qx.Class.define("qx.ui.mobile.form.PasswordField", {
    extend: qx.ui.mobile.form.TextField,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "password-field"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getType: function _getType() {
        return "password";
      }
    }
  });
  qx.ui.mobile.form.PasswordField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Input": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.mobile.form.MText": {
        "require": true
      },
      "qx.ui.form.IStringForm": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The NumberField is a single-line number input field. It uses HTML5 input field type
   * "number" and the attribute "min" ,"max" and "step". The attributes can be used
   * for form validation {@link qx.ui.form.validation.Manager}.
   */
  qx.Class.define("qx.ui.mobile.form.NumberField", {
    extend: qx.ui.mobile.form.Input,
    include: [qx.ui.mobile.form.MValue, qx.ui.mobile.form.MText],
    implement: [qx.ui.form.IStringForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {var?null} The value of the widget.
     */
    construct: function construct(value) {
      qx.ui.mobile.form.Input.constructor.call(this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "number-field"
      },

      /**
       * The minimum text field value (may be negative). This value must be smaller
       * than {@link #minimum}.
       */
      minimum: {
        check: "Number",
        init: '',
        apply: "_onChangeMinimum"
      },

      /**
       * The maximum text field value (may be negative). This value must be larger
       * than {@link #maximum}.
       */
      maximum: {
        check: "Number",
        init: '',
        apply: "_onChangeMaximum"
      },

      /**
       * The amount to increment on each event.
       */
      step: {
        check: "Number",
        init: '',
        apply: "_onChangeStep"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getType: function _getType() {
        return "number";
      },

      /**
       * Called when changed the property step.
       * Delegates value change on DOM element.
       */
      _onChangeStep: function _onChangeStep(value, old) {
        this._setAttribute("step", value);
      },

      /**
       * Called when changed the property maximum.
       * Delegates value change on DOM element.
       */
      _onChangeMaximum: function _onChangeMaximum(value, old) {
        this._setAttribute("max", value);
      },

      /**
       * Called when changed the property minimum.
       * Delegates value change on DOM element.
       */
      _onChangeMinimum: function _onChangeMinimum(value, old) {
        this._setAttribute("min", value);
      }
    }
  });
  qx.ui.mobile.form.NumberField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Input": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The Checkbox is the mobile correspondent of the html checkbox.
   *
   * *Example*
   *
   * <pre class='javascript'>
   *   var checkBox = new qx.ui.mobile.form.CheckBox();
   *   var title = new qx.ui.mobile.form.Title("Title");
   *
   *   checkBox.setModel("Title Activated");
   *   checkBox.bind("model", title, "value");
   *
   *   checkBox.addListener("changeValue", function(evt){
   *     this.setModel(evt.getdata() ? "Title Activated" : "Title Deactivated");
   *   });
   *
   *   this.getRoot.add(checkBox);
   *   this.getRoot.add(title);
   * </pre>
   *
   * This example adds 2 widgets , a checkBox and a Title and binds them together by their model and value properties.
   * When the user taps on the checkbox, its model changes and it is reflected in the Title's value.
   *
   */
  qx.Class.define("qx.ui.mobile.form.CheckBox", {
    extend: qx.ui.mobile.form.Input,
    include: [qx.ui.mobile.form.MValue],
    implement: [qx.ui.form.IField],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {Boolean?false} The value of the checkbox.
     */
    construct: function construct(value) {
      qx.ui.mobile.form.Input.constructor.call(this);

      if (typeof value != undefined) {
        this._state = value;
      }

      this.addListener("tap", this._onTap, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "checkbox"
      }
    },
    members: {
      _state: null,
      // overridden
      _getTagName: function _getTagName() {
        return "span";
      },
      // overridden
      _getType: function _getType() {
        return null;
      },

      /**
       * Handler for tap events.
       */
      _onTap: function _onTap() {
        // Toggle State.
        this.setValue(!this.getValue());
      },

      /**
       * Sets the value [true/false] of this checkbox.
       * It is called by setValue method of qx.ui.mobile.form.MValue mixin
       * @param value {Boolean} the new value of the checkbox
       */
      _setValue: function _setValue(value) {
        if (value == true) {
          this.addCssClass("checked");
        } else {
          this.removeCssClass("checked");
        }

        this._setAttribute("checked", value);

        this._state = value;
      },

      /**
       * Gets the value [true/false] of this checkbox.
       * It is called by getValue method of qx.ui.mobile.form.MValue mixin
       * @return {Boolean} the value of the checkbox
       */
      _getValue: function _getValue() {
        return this._state;
      }
    },

    /*
    *****************************************************************************
        DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.removeListener("tap", this._onTap, this);
    }
  });
  qx.ui.mobile.form.CheckBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.mobile.form.MText": {
        "require": true
      },
      "qx.ui.mobile.form.MState": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.mobile.dialog.Menu": {},
      "qx.lang.Type": {},
      "qx.core.ValidationError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The SelectBox
   *
   * an example, how to use the SelectBox:
   * *Example*
   *
   * <pre class='javascript'>
   *    var page1 = new qx.ui.mobile.page.Page();
   *    page1.addListener("initialize", function()
   *    {
   *      var sel = new qx.ui.mobile.form.SelectBox();
   *      page1.add(sel);
   *      var model = new qx.data.Array(["item1","item2"]);
   *      sel.setModel(model);
   *      model.push("item3");
   *
   *      var but = new qx.ui.mobile.form.Button("setSelection");
   *      page1.add(but);
   *      but.addListener("tap", function(){
   *        sel.setSelection("item3");
   *      }, this);
   *
   *      sel.addListener("changeSelection", function(evt) {
   *        console.log(evt.getData());
   *      }, this);
   *
   *      var title = new qx.ui.mobile.form.Title("item2");
   *      title.bind("value",sel,"value");
   *      sel.bind("value",title,"value");
   *      page1.add(title);
   *   },this);
   *
   *   page1.show();
   *  </pre>
   */
  qx.Class.define("qx.ui.mobile.form.SelectBox", {
    extend: qx.ui.mobile.core.Widget,
    include: [qx.ui.mobile.form.MValue, qx.ui.form.MForm, qx.ui.mobile.form.MText, qx.ui.mobile.form.MState],
    implement: [qx.ui.form.IForm, qx.ui.form.IField, qx.ui.form.IModel],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this); // This text node is for compatibility reasons, because Firefox can not
      // change appearance of SelectBoxes.

      this._setAttribute("type", "text");

      this.setReadOnly(true);
      this.addListener("focus", this.blur);
      this.addListener("tap", this._onTap, this); // Selection dialog creation.

      this.__selectionDialog = this._createSelectionDialog();
      this.addCssClass("gap"); // When selectionDialogs changes selection, get chosen selectedIndex from it.

      this.__selectionDialog.addListener("changeSelection", this._onChangeSelection, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when user selects an item.
       */
      changeSelection: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "selectbox"
      },
      // overridden
      activatable: {
        refine: true,
        init: true
      },

      /**
       * Defines if the SelectBox has a clearButton, which resets the selection.
       */
      nullable: {
        init: true,
        check: "Boolean",
        apply: "_applyNullable"
      },

      /**
       * The model to use to render the list.
       */
      model: {
        check: "qx.data.Array",
        apply: "_applyModel",
        event: "changeModel",
        nullable: true,
        init: null
      },

      /**
       * The selected index of this SelectBox.
       */
      selection: {
        init: null,
        validate: "_validateSelection",
        apply: "_applySelection",
        nullable: true
      }
    },
    members: {
      __selectionDialog: null,
      // overridden
      _getTagName: function _getTagName() {
        // No select here, see BUG #6054
        return "input";
      },

      /**
       * Creates the menu dialog. Override this to customize the widget.
       *
       * @return {qx.ui.mobile.dialog.Menu} A dialog, containing a selection list.
       */
      _createSelectionDialog: function _createSelectionDialog() {
        var menu = new qx.ui.mobile.dialog.Menu(); // Special appearance for SelectBox menu items.

        menu.setSelectedItemClass("selectbox-selected");
        menu.setUnselectedItemClass("selectbox-unselected"); // Hide selectionDialog on tap on blocker.

        menu.setHideOnBlockerTap(true);
        return menu;
      },

      /**
       * Returns the SelectionDialog.
       * @return {qx.ui.mobile.dialog.Menu} the SelectionDialog.
       */
      getSelectionDialog: function getSelectionDialog() {
        return this.__selectionDialog;
      },

      /**
       * Sets the dialog title on the selection dialog.
       * @param title {String} the title to set on selection dialog.
       */
      setDialogTitle: function setDialogTitle(title) {
        this.__selectionDialog.setTitle(title);
      },

      /**
       * Set the ClearButton label of the selection dialog.
       * @param value {String} the value to set on the ClearButton at selection dialog.
       */
      setClearButtonLabel: function setClearButtonLabel(value) {
        this.__selectionDialog.setClearButtonLabel(value);
      },

      /**
       * Sets the selected text value of this SelectBox.
       * @param value {String} the text value which should be selected.
       */
      _setValue: function _setValue(value) {
        if (this.getModel() == null) {
          return;
        }

        if (value == "") {
          if (this.isNullable()) {
            this.setSelection(null);
          } else {
            this.setSelection(0);
          }
        } else if (value != null) {
          this.setSelection(this.getModel().indexOf(value));
        } else {
          this.setSelection(null);
        }
      },

      /**
       * Get the text value of this
       * It is called by setValue method of qx.ui.mobile.form.MValue mixin.
       * @return {Number} the new selected index of the SelectBox.
       */
      _getValue: function _getValue() {
        return this._getAttribute("value");
      },

      /**
       * Renders this SelectBox. Override this if you would like to display the
       * values of the SelectBox in a different way than the default.
       */
      _render: function _render() {
        if (this.getModel() != null && this.getModel().length > 0) {
          var selectedItem = this.getModel().getItem(this.getSelection());

          this._setAttribute("value", selectedItem);
        }

        this._domUpdated();
      },

      /**
       * Sets the model property to the new value
       * @param value {qx.data.Array}, the new model
       * @param old {qx.data.Array?}, the old model
       */
      _applyModel: function _applyModel(value, old) {
        value.addListener("change", this._render, this);

        if (old != null) {
          old.removeListener("change", this._render, this);
        }

        this._render();
      },

      /**
       * Refreshs selection dialogs model, and shows it.
       */
      __showSelectionDialog: function __showSelectionDialog() {
        if (this.isEnabled() == true) {
          // Set index before items, because setItems() triggers rendering.
          this.__selectionDialog.setSelectedIndex(this.getSelection());

          this.__selectionDialog.setItems(this.getModel());

          this.__selectionDialog.show();
        }
      },

      /**
       * Gets the selectedIndex out of change selection event and renders view.
       * @param evt {qx.event.type.Data} data event.
       */
      _onChangeSelection: function _onChangeSelection(evt) {
        this.setSelection(evt.getData().index);

        this._render();
      },

      /**
      * Handler for <code>tap</code> event on this widget.
      * @param evt {qx.event.type.Tap} the handling tap event.
      */
      _onTap: function _onTap(evt) {
        this.__showSelectionDialog(); // request focus so that it leaves previous widget
        // such as text field and hide virtual keyboard.


        evt.getOriginalTarget().focus();
      },

      /**
       * Validates the selection value.
       * @param value {Integer} the selection value to validate.
       */
      _validateSelection: function _validateSelection(value) {
        if (value != null && qx.lang.Type.isNumber(value) == false) {
          throw new qx.core.ValidationError("Validation Error: Input value is not a number");
        }

        if (this.getModel() === null) {
          throw new qx.core.ValidationError("Validation Error: Please apply model before selection");
        }

        if (!this.isNullable() && value === null) {
          throw new qx.core.ValidationError("Validation Error: SelectBox is not nullable");
        }

        if (value != null && (value < 0 || value >= this.getModel().getLength())) {
          throw new qx.core.ValidationError("Validation Error: Input value is out of model range");
        }
      },
      // property apply
      _applySelection: function _applySelection(value, old) {
        var selectedItem = this.getModel().getItem(value);
        this.fireDataEvent("changeSelection", {
          index: value,
          item: selectedItem
        });

        this._render();
      },
      // property apply
      _applyNullable: function _applyNullable(value, old) {
        // Delegate nullable property.
        this.__selectionDialog.setNullable(value);
      }
    },
    destruct: function destruct() {
      this.__selectionDialog.removeListener("changeSelection", this._onChangeSelection, this);

      this._disposeObjects("__selectionDialog", "__selectionDialogTitle");

      this.removeListener("focus", this.blur);
      this.removeListener("tap", this._onTap, this);
    }
  });
  qx.ui.mobile.form.SelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.renderer.AbstractRenderer": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.ToggleButton": {
        "require": true
      },
      "qx.ui.mobile.form.RadioButton": {
        "require": true
      },
      "qx.ui.mobile.form.TextField": {
        "require": true
      },
      "qx.ui.mobile.form.PasswordField": {
        "require": true
      },
      "qx.ui.mobile.form.NumberField": {
        "require": true
      },
      "qx.ui.mobile.form.CheckBox": {
        "require": true
      },
      "qx.ui.mobile.form.SelectBox": {
        "require": true
      },
      "qx.ui.mobile.form.TextArea": {},
      "qx.bom.client.Scroll": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.container.Scroll": {},
      "qx.ui.mobile.form.Row": {},
      "qx.ui.mobile.form.Label": {},
      "qx.ui.mobile.basic.Label": {},
      "qx.dom.Element": {},
      "qx.bom.element.Class": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Single renderer is a class used to render forms into a mobile page.
   * It displays a label above or next to each form element.
   *
   */
  qx.Class.define("qx.ui.mobile.form.renderer.Single", {
    extend: qx.ui.mobile.form.renderer.AbstractRenderer,
    construct: function construct(form) {
      this.__errorMessageContainers = [];
      this._rows = [];
      this._labels = [];
      qx.ui.mobile.form.renderer.AbstractRenderer.constructor.call(this, form);
      this.addCssClass("single");
    },
    statics: {
      /** @type {Array} qx.Mobile form widgets which are rendered in one single line. */
      ONE_LINE_WIDGETS: [qx.ui.mobile.form.ToggleButton, qx.ui.mobile.form.RadioButton, qx.ui.mobile.form.TextField, qx.ui.mobile.form.PasswordField, qx.ui.mobile.form.NumberField, qx.ui.mobile.form.CheckBox, qx.ui.mobile.form.SelectBox]
    },
    members: {
      _rows: null,
      _labels: null,
      _onFormChange: function _onFormChange() {
        this._disposeArray("_labels");

        this._disposeArray("_rows");

        this._rows = [];
        this._labels = [];

        qx.ui.mobile.form.renderer.Single.prototype._onFormChange.base.call(this);
      },

      /**
       * A collection of error containers used to keep the error messages
       * resulted after form validation.
       * Also useful to clear them when the validation passes.
       */
      __errorMessageContainers: null,
      // override
      _getTagName: function _getTagName() {
        return "ul";
      },

      /**
      * Determines whether the given item can be display in one line
      * or whether a separate line for the text label is needed.
      * @param item {qx.ui.mobile.core.Widget} the widget which should be added.
      * @return {Boolean} it indicates whether the widget can be displayed
      *  in same line as the label.
      */
      _isOneLineWidget: function _isOneLineWidget(item) {
        var widgets = qx.ui.mobile.form.renderer.Single.ONE_LINE_WIDGETS;

        for (var i = 0; i < widgets.length; i++) {
          var widget = widgets[i];

          if (item instanceof widget) {
            return true;
          }
        }

        return false;
      },
      // override
      addItems: function addItems(items, names, title) {
        if (title !== null) {
          this._addGroupHeader(title);
        }

        this._addGroupHeaderRow();

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i];
          var name = names[i];
          var isLastItem = i == items.length - 1;

          if (item instanceof qx.ui.mobile.form.TextArea) {
            if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
              this._addToScrollContainer(item, name);
            } else {
              this._addRow(item, name, new qx.ui.mobile.layout.VBox());
            }
          } else {
            if (this._isOneLineWidget(item)) {
              this._addRow(item, name, new qx.ui.mobile.layout.HBox());
            } else {
              this._addRow(item, name, new qx.ui.mobile.layout.VBox());
            }
          }

          if (!item.isValid()) {
            this.showErrorForItem(item);
          }

          if (!isLastItem) {
            this._addSeparationRow();
          }
        }

        this._addGroupFooterRow();
      },

      /**
       * Wraps the given item with a {@link qx.ui.mobile.container.Scroll scroll} container.
       * @param item {qx.ui.mobile.core.Widget} A form item to render.
       * @param name {String} A name for the form item.
       */
      _addToScrollContainer: function _addToScrollContainer(item, name) {
        var scrollContainer = new qx.ui.mobile.container.Scroll();
        scrollContainer.addCssClass("form-row-scroll");
        scrollContainer.add(item, {
          flex: 1
        });

        this._addRow(scrollContainer, name, new qx.ui.mobile.layout.VBox());
      },

      /**
      * Adds a label and its according widget in a row and applies the given layout.
      * @param item {qx.ui.mobile.core.Widget} A form item to render.
      * @param name {String} A name for the form item.
      * @param layout {qx.ui.mobile.layout.Abstract} layout of the rendered row.
      */
      _addRow: function _addRow(item, name, layout) {
        var row = new qx.ui.mobile.form.Row(layout);
        row.addCssClass("form-row-content");

        if (name !== null) {
          var label = new qx.ui.mobile.form.Label(name);
          label.setLabelFor(item.getId());
          row.add(label, {
            flex: 1
          });

          this._labels.push(label);
        }

        row.add(item);

        this._add(row);

        this._rows.push(row);
      },

      /**
       * Adds a separation line into the form.
       */
      _addSeparationRow: function _addSeparationRow() {
        var row = new qx.ui.mobile.form.Row();
        row.addCssClass("form-separation-row");

        this._add(row);

        this._rows.push(row);
      },

      /**
       * Adds an row group header.
       */
      _addGroupHeaderRow: function _addGroupHeaderRow() {
        var row = new qx.ui.mobile.form.Row();
        row.addCssClass("form-row-group-first");

        this._add(row);

        this._rows.push(row);
      },

      /**
       * Adds an row group footer.
       */
      _addGroupFooterRow: function _addGroupFooterRow() {
        var row = new qx.ui.mobile.form.Row();
        row.addCssClass("form-row-group-last");

        this._add(row);

        this._rows.push(row);
      },

      /**
       * Adds a row with the name of a group of elements
       * When you want to group certain form elements, this methods implements
       * the way the header of that group is presented.
       * @param title {String} the title shown in the group header
       */
      _addGroupHeader: function _addGroupHeader(title) {
        var row = new qx.ui.mobile.form.Row();
        row.addCssClass("form-row-group-title");
        var titleLabel = new qx.ui.mobile.basic.Label(title);
        row.add(titleLabel);

        this._add(row);

        this._labels.push(titleLabel);

        this._rows.push(row);
      },
      // override
      addButton: function addButton(button) {
        var row = new qx.ui.mobile.form.Row(new qx.ui.mobile.layout.HBox());
        row.add(button, {
          flex: 1
        });

        this._add(row);

        this._rows.push(row);
      },
      // override
      showErrorForItem: function showErrorForItem(item) {
        var errorNode = qx.dom.Element.create('div');
        errorNode.innerHTML = item.getInvalidMessage();
        qx.bom.element.Class.add(errorNode, 'form-element-error');
        qx.dom.Element.insertAfter(errorNode, this._getParentRow(item).getContainerElement());

        this.__errorMessageContainers.push(errorNode);
      },

      /**
       * Shows a single item of this form
       * @param item {qx.ui.form.IForm} form item which should be hidden.
       */
      showItem: function showItem(item) {
        this._getParentRow(item).removeCssClass("exclude");
      },

      /**
       * Hides a single item of this form
       * @param item {qx.ui.form.IForm} form item which should be hidden.
       */
      hideItem: function hideItem(item) {
        this._getParentRow(item).addCssClass("exclude");
      },

      /**
      * Returns the parent row of the item.
      *
      * @param item {qx.ui.form.IForm} the form item.
      * @return {qx.ui.mobile.core.Widget} the parent row.
      */
      _getParentRow: function _getParentRow(item) {
        var parent = item.getLayoutParent();

        while (!parent.hasCssClass("form-row")) {
          parent = parent.getLayoutParent();
        }

        return parent;
      },
      // override
      resetForm: function resetForm() {
        for (var i = 0; i < this.__errorMessageContainers.length; i++) {
          qx.dom.Element.remove(this.__errorMessageContainers[i]);
        }
      }
    },

    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct: function destruct() {
      this.resetForm();

      this._disposeArray("_labels");

      this._disposeArray("_rows");
    }
  });
  qx.ui.mobile.form.renderer.Single.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.bom.Element": {},
      "qx.util.Delegate": {},
      "qx.ui.mobile.list.renderer.group.Default": {},
      "qx.ui.mobile.list.renderer.Default": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Provides a list item element for a certain row and its data.
   * Uses the {@link qx.ui.mobile.list.renderer.Default} list item renderer as a
   * default renderer when no other renderer is given by the {@link qx.ui.mobile.list.List#delegate}.
   */
  qx.Class.define("qx.ui.mobile.list.provider.Provider", {
    extend: qx.core.Object,
    properties: {
      /**
       * Delegation object which can have one or more functions defined by the
       * {@link qx.ui.mobile.list.IListDelegate} interface. Set by the list.
       *
       * @internal
       */
      delegate: {
        event: "changeDelegate",
        init: null,
        nullable: true,
        apply: "_applyDelegate"
      }
    },
    members: {
      __itemRenderer: null,
      __groupRenderer: null,

      /**
       * Sets the item renderer.
       *
       * @param renderer {qx.ui.mobile.list.renderer.Abstract} The used item renderer
       */
      _setItemRenderer: function _setItemRenderer(renderer) {
        this.__itemRenderer = renderer;
      },

      /**
       * Returns the set item renderer.
       *
       * @return {qx.ui.mobile.list.renderer.Abstract} The used item renderer
       */
      _getItemRenderer: function _getItemRenderer() {
        return this.__itemRenderer;
      },

      /**
      * Sets the group renderer.
      * @param renderer {qx.ui.mobile.list.renderer.group.Abstract} the group renderer.
      */
      _setGroupRenderer: function _setGroupRenderer(renderer) {
        this.__groupRenderer = renderer;
      },

      /**
      * Gets the group renderer.
      * @return {qx.ui.mobile.list.renderer.group.Abstract} the group renderer.
      */
      _getGroupRenderer: function _getGroupRenderer() {
        return this.__groupRenderer;
      },

      /**
       * Returns the list item element for a given row.
       *
       * @param data {var} The data of the row.
       * @param row {Integer} The row index.
       *
       * @return {Element} the list item element.
       */
      getItemElement: function getItemElement(data, row) {
        this.__itemRenderer.reset();

        this._configureItem(data, row); // Clone the element and all it's events


        var clone = qx.bom.Element.clone(this.__itemRenderer.getContainerElement(), true);
        clone.setAttribute("data-row", row);
        return clone;
      },

      /**
       * Returns the group item element for a given row.
       *
       * @param data {var} The data of the group.
       * @param group {Integer} The group index.
       *
       * @return {Element} the group item element.
       */
      getGroupElement: function getGroupElement(data, group) {
        this.__groupRenderer.reset();

        this._configureGroupItem(data, group); // Clone the element and all it's events


        var clone = qx.bom.Element.clone(this.__groupRenderer.getContainerElement(), true);
        clone.removeAttribute("id");
        clone.setAttribute("data-group", group);
        return clone;
      },

      /**
       * Configure the list item renderer with the passed data.
       *
       * @param data {var} The data of the row.
       * @param row {Integer} The row index.
       */
      _configureItem: function _configureItem(data, row) {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.configureItem != null) {
          delegate.configureItem(this.__itemRenderer, data, row);
        }
      },

      /**
      * Configures the group renderer with the passed group data.
      * @param data {var} The data of the group.
      * @param group {Integer} The group index.
      */
      _configureGroupItem: function _configureGroupItem(data, group) {
        var configureGroupItem = qx.util.Delegate.getMethod(this.getDelegate(), "configureGroupItem");

        if (configureGroupItem) {
          configureGroupItem(this.__groupRenderer, data, group);
        }
      },

      /**
       * Creates an instance of the group renderer to use. When no delegate method
       * is given the function will return an instance of {@link qx.ui.mobile.list.renderer.group.Default}.
       *
       * @return {qx.ui.mobile.list.renderer.group.Abstract} An instance of the group renderer.
      */
      _createGroupRenderer: function _createGroupRenderer() {
        var createGroupRenderer = qx.util.Delegate.getMethod(this.getDelegate(), "createGroupRenderer");
        var groupRenderer = null;

        if (createGroupRenderer == null) {
          groupRenderer = new qx.ui.mobile.list.renderer.group.Default();
        } else {
          groupRenderer = createGroupRenderer();
        }

        return groupRenderer;
      },

      /**
       * Creates an instance of the item renderer to use. When no delegate method
       * is given the function will return an instance of {@link qx.ui.mobile.list.renderer.Default}.
       *
       * @return {qx.ui.mobile.list.renderer.Abstract} An instance of the item renderer.
       *
       */
      _createItemRenderer: function _createItemRenderer() {
        var createItemRenderer = qx.util.Delegate.getMethod(this.getDelegate(), "createItemRenderer");
        var itemRenderer = null;

        if (createItemRenderer == null) {
          itemRenderer = new qx.ui.mobile.list.renderer.Default();
        } else {
          itemRenderer = createItemRenderer();
        }

        return itemRenderer;
      },
      // property apply
      _applyDelegate: function _applyDelegate(value, old) {
        this._setItemRenderer(this._createItemRenderer());

        this._setGroupRenderer(this._createGroupRenderer());
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__itemRenderer", "__groupRenderer");
    }
  });
  qx.ui.mobile.list.provider.Provider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Function": {},
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Methods to work with the delegate pattern.
   */
  qx.Class.define("qx.util.Delegate", {
    statics: {
      /**
       * Returns the delegate method given my its name.
       *
       * @param delegate {Object} The delegate object to check the method.
       * @param specificMethod {String} The name of the delegate method.
       * @return {Function|null} The requested method or null, if no method is set.
       */
      getMethod: function getMethod(delegate, specificMethod) {
        if (qx.util.Delegate.containsMethod(delegate, specificMethod)) {
          return qx.lang.Function.bind(delegate[specificMethod], delegate);
        }

        return null;
      },

      /**
       * Checks, if the given delegate is valid or if a specific method is given.
       *
       * @param delegate {Object} The delegate object.
       * @param specificMethod {String} The name of the method to search for.
       * @return {Boolean} True, if everything was ok.
       */
      containsMethod: function containsMethod(delegate, specificMethod) {
        var Type = qx.lang.Type;

        if (Type.isObject(delegate)) {
          return Type.isFunction(delegate[specificMethod]);
        }

        return false;
      }
    }
  });
  qx.util.Delegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "defer": "runtime",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.lang.Type": {},
      "qx.bom.Selector": {},
      "qx.bom.element.Location": {},
      "qx.bom.element.Dimension": {},
      "qx.bom.client.Scroll": {
        "defer": "runtime"
      },
      "qx.ui.mobile.container.MIScroll": {
        "defer": "runtime"
      },
      "qx.ui.mobile.container.MNativeScroll": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "defer": true,
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Container, which allows, depending on the set variant <code>qx.mobile.nativescroll</code>,
   * vertical and horizontal scrolling if the contents is larger than the container.
   *
   * Note that this class can only have one child widget. This container has a
   * fixed layout, which cannot be changed.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // create the scroll widget
   *   var scroll = new qx.ui.mobile.container.Scroll();
   *
   *   // add a children
   *   scroll.add(new qx.ui.mobile.basic.Label("Name: "));
   *
   *   this.getRoot().add(scroll);
   * </pre>
   *
   * This example creates a scroll container and adds a label to it.
   */
  qx.Class.define("qx.ui.mobile.container.Scroll", {
    extend: qx.ui.mobile.container.Composite,

    /**
    * @param scrollProperties {Object} A map with scroll properties which are passed to the scrolling container (may contain iScroll properties).
    */
    construct: function construct(scrollProperties) {
      qx.ui.mobile.container.Composite.constructor.call(this);

      if (scrollProperties) {
        this._scrollProperties = scrollProperties;
      }

      this.addListener("appear", this._updateWaypoints, this);
      this._waypointsX = [];
      this._waypointsY = [];
      this._currentX = 0;
      this._currentY = 0;
    },
    events: {
      /** Fired when the scroll container reaches its end position (including momentum/inertia). */
      scrollEnd: "qx.event.type.Event",

      /** Fired when the user scrolls to the end of scroll area. */
      pageEnd: "qx.event.type.Event",

      /** Fired when a vertical or horizontal waypoint is triggered. Data:
      * <code> {"offset": 0,
      *        "input": "10%",
      *        "index": 0,
      *        "element" : 0}</code>
      */
      waypoint: "qx.event.type.Data",

      /**
      * Fired when a momentum starts on an iOS device.
      */
      momentumStart: "qx.event.type.Event",

      /**
      * Fired when a momentum ends on an iOS device.
      */
      momentumEnd: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "scroll"
      },

      /**
       * Delegation object which can have one or more functions defined by the
       * {@link qx.ui.mobile.container.IScrollDelegate} interface.
       *
       * @internal
       */
      delegate: {
        init: null,
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _scrollProperties: null,
      _activeWaypointX: null,
      _activeWaypointY: null,
      _waypointsX: null,
      _waypointsY: null,
      _calculatedWaypointsX: null,
      _calculatedWaypointsY: null,
      _currentX: null,
      _currentY: null,

      /**
      * Sets the current x position.
      * @param value {Number} the current horizontal position.
      */
      _setCurrentX: function _setCurrentX(value) {
        var old = this._currentX;
        this._currentX = value;

        this._fireWaypoint(value, old, "x");
      },

      /**
      * Sets the current y position.
      * @param value {Number} the current vertical position.
      */
      _setCurrentY: function _setCurrentY(value) {
        var old = this._currentY;
        this._currentY = value;

        this._fireWaypoint(value, old, "y");
      },

      /**
       * Sets the horizontal trigger points, where a <code>waypoint</code> event will be fired.
       * @param waypoints {Array} description
       */
      setWaypointsX: function setWaypointsX(waypoints) {
        this._waypointsX = waypoints;
      },

      /**
       * Sets the vertical trigger points, where a <code>waypoint</code> event will be fired.
       * @param waypoints {Array} an array with waypoint descriptions. Allowed are percentage description as string, or pixel trigger points defined as numbers. <code>["20%",200]</code>
       */
      setWaypointsY: function setWaypointsY(waypoints) {
        this._waypointsY = waypoints;
      },

      /**
       * Returns the scroll height.
       * @return {Number} the scroll height.
       */
      getScrollHeight: function getScrollHeight() {
        return this._getScrollHeight();
      },

      /**
       * Returns the scroll width.
       * @return {Number} the scroll width.
       */
      getScrollWidth: function getScrollWidth() {
        return this._getScrollWidth();
      },

      /**
       * Re-calculates the internal waypoint offsets.
       */
      _updateWaypoints: function _updateWaypoints() {
        this._calculatedWaypointsX = [];
        this._calculatedWaypointsY = [];

        this._calcWaypoints(this._waypointsX, this._calculatedWaypointsX, this.getScrollWidth(), "x");

        this._calcWaypoints(this._waypointsY, this._calculatedWaypointsY, this.getScrollHeight());
      },

      /**
       * Validates and checks the waypoint offsets.
       * @param waypoints {Array} an array with waypoint descriptions.
       * @param results {Array} the array where calculated waypoints will be added.
       * @param scrollSize {Number} the vertical or horizontal scroll size.
       * @param axis {String?} "x" or "y".
       */
      _calcWaypoints: function _calcWaypoints(waypoints, results, scrollSize, axis) {
        axis = axis || "y";
        var offset = 0;

        for (var i = 0; i < waypoints.length; i++) {
          var waypoint = waypoints[i];

          if (qx.lang.Type.isString(waypoint)) {
            if (waypoint.endsWith("%")) {
              offset = parseInt(waypoint, 10) * (scrollSize / 100);
              results.push({
                "offset": offset,
                "input": waypoint,
                "index": i,
                "element": null,
                "axis": axis
              });
            } else {
              // Dynamically created waypoints, based upon a selector.
              var element = this.getContentElement();
              var waypointElements = qx.bom.Selector.query(waypoint, element);

              for (var j = 0; j < waypointElements.length; j++) {
                var position = qx.bom.element.Location.getRelative(waypointElements[j], element);

                if (axis === "y") {
                  offset = position.top + this.getContentElement().scrollTop;
                } else if (axis === "x") {
                  offset = position.left + this.getContentElement().scrollLeft;
                }

                results.push({
                  "offset": position.top + this._currentY,
                  "input": waypoint,
                  "index": i,
                  "element": j,
                  "axis": axis
                });
              }
            }
          } else if (qx.lang.Type.isNumber(waypoint)) {
            results.push({
              "offset": waypoint,
              "input": waypoint,
              "index": i,
              "element": null,
              "axis": axis
            });
          }
        }

        results.sort(function (a, b) {
          return a.offset - b.offset;
        });
      },

      /**
       * Fires a waypoints event when scroll position changes.
       * @param value {Number} old scroll position.
       * @param old {Number} old scroll position.
       * @param axis {String} "x" or "y".
       */
      _fireWaypoint: function _fireWaypoint(value, old, axis) {
        var waypoints = this._calculatedWaypointsY;

        if (axis === "x") {
          waypoints = this._calculatedWaypointsX;
        }

        if (waypoints === null) {
          return;
        }

        var nextWaypoint = null;

        for (var i = 0; i < waypoints.length; i++) {
          var waypoint = waypoints[i];

          if (waypoint.offset !== null) {
            if (value > -1 && value >= waypoint.offset || value < 0 && waypoint.offset < 0 && value <= waypoint.offset) {
              nextWaypoint = waypoint;
            } else {
              break;
            }
          }
        }

        if (nextWaypoint === null) {
          if (axis === "x") {
            this._activeWaypointX = null;
          } else {
            this._activeWaypointY = null;
          }

          return;
        }

        var direction = null;

        if (old <= value) {
          direction = "down";

          if (axis == "x") {
            direction = "left";
          }
        } else {
          direction = "up";

          if (axis == "x") {
            direction = "right";
          }
        }

        var activeWaypoint = this._activeWaypointY;

        if (axis === "x") {
          activeWaypoint = this._activeWaypointX;
        }

        if (activeWaypoint === null || activeWaypoint.index !== nextWaypoint.index || activeWaypoint.element !== nextWaypoint.element) {
          activeWaypoint = nextWaypoint;
          this._activeWaypointY = activeWaypoint;

          if (axis === "x") {
            this._activeWaypointX = activeWaypoint;
          }

          this.fireDataEvent("waypoint", {
            "axis": axis,
            "index": nextWaypoint.index,
            "element": nextWaypoint.element,
            "direction": direction
          });
        }
      },
      // overridden
      _createContainerElement: function _createContainerElement() {
        var element = qx.ui.mobile.container.Scroll.prototype._createContainerElement.base.call(this);

        var scrollElement = this._createScrollElement();

        if (scrollElement) {
          return scrollElement;
        }

        return element;
      },
      // overridden
      _getContentElement: function _getContentElement() {
        var contentElement = qx.ui.mobile.container.Scroll.prototype._getContentElement.base.call(this);

        var scrollContentElement = this._getScrollContentElement();

        return scrollContentElement || contentElement;
      },

      /**
       * Calls the refresh function the used scrolling method. Needed to recalculate the
       * scrolling container.
       */
      refresh: function refresh() {
        this._refresh();

        this._updateWaypoints();
      },

      /**
       * Scrolls the wrapper contents to the x/y coordinates in a given time.
       *
       * @param x {Integer} X coordinate to scroll to.
       * @param y {Integer} Y coordinate to scroll to.
       * @param time {Integer} Time slice in which scrolling should
       *              be done.
       */
      scrollTo: function scrollTo(x, y, time) {
        this._scrollTo(x, y, time);
      },

      /**
       * Returns the current scroll position
       * @return {Array} an array with <code>[scrollLeft,scrollTop]</code>.
       */
      getPosition: function getPosition() {
        return this._getPosition();
      },

      /**
       * Detects whether this scroll container is scrollable or not.
       * @return {Boolean} <code>true</code> or <code>false</code>
       */
      isScrollable: function isScrollable() {
        return this._isScrollable();
      },

      /**
       * Detects whether this scroll container is scrollable or not.
       * @return {Boolean} <code>true</code> or <code>false</code>
       */
      _isScrollable: function _isScrollable() {
        return this._isScrollableX() || this._isScrollableY();
      },

      /**
       * Detects whether this scroll container is scrollable on x axis or not.
       * @return {Boolean} <code>true</code> or <code>false</code>
       */
      _isScrollableX: function _isScrollableX() {
        if (this.getLayoutParent() === null) {
          return false;
        }

        var parentWidth = this.getContainerElement().clientWidth;
        var contentWidth = this.getContentElement().scrollWidth;

        var scrollContentElement = this._getScrollContentElement();

        if (scrollContentElement) {
          contentWidth = qx.bom.element.Dimension.getWidth(scrollContentElement);
        }

        return parentWidth < contentWidth;
      },

      /**
       * Detects whether this scroll container is scrollable on y axis or not.
       * @return {Boolean} <code>true</code> or <code>false</code>
       */
      _isScrollableY: function _isScrollableY() {
        if (this.getLayoutParent() === null) {
          return false;
        }

        var parentHeight = this.getContainerElement().clientHeight;
        var contentHeight = this.getContentElement().scrollHeight;

        var scrollContentElement = this._getScrollContentElement();

        if (scrollContentElement) {
          contentHeight = qx.bom.element.Dimension.getHeight(scrollContentElement);
        }

        return parentHeight < contentHeight;
      },

      /**
       * Scrolls the wrapper contents to the widgets coordinates in a given
       * period.
       *
       * @param target {Element} the element to which the scroll container should scroll to.
       * @param time {Integer?0} Time slice in which scrolling should
       *              be done (in seconds).
       *
       */
      scrollToElement: function scrollToElement(target, time) {
        this._scrollToElement(target, time);
      },

      /**
      * Scrolls the wrapper contents to the widgets coordinates in a given
      * period.
      *
      * @param element {String} the element to which the scroll container should scroll to.
      * @param time {Integer?0} Time slice in which scrolling should be done (in seconds).
      *
      */
      _scrollToElement: function _scrollToElement(element, time) {
        if (this._getContentElement() && this._isScrollable()) {
          if (typeof time === "undefined") {
            time = 0;
          }

          var location = qx.bom.element.Location.getRelative(this._getContentElement(), element, "scroll", "scroll");

          var offset = this._getScrollOffset();

          this._scrollTo(-location.left - offset[0], -location.top - offset[1], time);
        }
      },

      /**
       *
       * Determines the scroll offset for the <code>_scrollToElement</code> method.
       * If a delegate is available, the method calls
       * <code>qx.ui.mobile.container.IScrollDelegate.getScrollOffset()</code> for offset calculation.
       *
       * @return {Array} an array with x,y offset.
       */
      _getScrollOffset: function _getScrollOffset() {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.getScrollOffset) {
          return delegate.getScrollOffset.bind(this)();
        } else {
          return [0, 0];
        }
      },

      /**
       * Scrolls the wrapper contents to the widgets coordinates in a given
       * period.
       *
       * @param widget {qx.ui.mobile.core.Widget} the widget, the scroll container should scroll to.
       * @param time {Integer} Time slice in which scrolling should
       *              be done.
       */
      scrollToWidget: function scrollToWidget(widget, time) {
        if (widget) {
          this._scrollToElement(widget.getContentElement(), time);
        }
      }
    },
    defer: function defer(statics) {
      if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
        qx.Class.include(statics, qx.ui.mobile.container.MIScroll);
      } else {
        qx.Class.include(statics, qx.ui.mobile.container.MNativeScroll);
      }
    },
    destruct: function destruct() {
      this.removeListener("appear", this._updateWaypoints, this);
      this._waypointsX = this._waypointsY = null;
    }
  });
  qx.ui.mobile.container.Scroll.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.element.Class": {},
      "qx.bom.element.Dimension": {},
      "qx.util.ResourceManager": {},
      "qx.bom.request.Script": {},
      "qx.lang.Object": {},
      "qx.bom.client.Scroll": {},
      "qx.lang.Array": {},
      "qx.event.Registration": {},
      "qx.bom.Event": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   * Mixin for the {@link Scroll} container. Used when the variant
   * <code>qx.mobile.nativescroll</code> is set to "off". Uses the iScroll script to simulate
   * the CSS position:fixed style. Position fixed is not available in iOS and
   * Android < 2.2.
   *
   * @ignore(iScroll)
   * @asset(qx/mobile/js/iscroll*.js)
   */
  qx.Mixin.define("qx.ui.mobile.container.MIScroll", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      this.__initScroll();

      this.__registerEventListeners();
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __scroll: null,

      /**
       * Mixin method. Creates the scroll element.
       *
       * @return {Element} The scroll element
       */
      _createScrollElement: function _createScrollElement() {
        var scroll = qx.dom.Element.create("div");
        qx.bom.element.Class.add(scroll, "iscroll");
        return scroll;
      },

      /**
       * Mixin method. Returns the scroll content element..
       *
       * @return {Element} The scroll content element
       */
      _getScrollContentElement: function _getScrollContentElement() {
        return this.getContainerElement().childNodes[0];
      },

      /**
      * Returns the current scroll position
      * @return {Array} an array with the <code>[scrollLeft,scrollTop]</code>.
      */
      _getPosition: function _getPosition() {
        return [this._currentX, this._currentY];
      },

      /**
      * Returns the scrolling height of the inner container.
      * @return {Number} the scrolling height.
      */
      _getScrollHeight: function _getScrollHeight() {
        if (!this.getContainerElement()) {
          return 0;
        }

        return this._getScrollContentElement().scrollHeight - this.getContainerElement().offsetHeight;
      },

      /**
      * Returns the scrolling width of the inner container.
      * @return {Number} the scrolling width.
      */
      _getScrollWidth: function _getScrollWidth() {
        if (!this.getContainerElement()) {
          return 0;
        }

        return this._getScrollContentElement().scrollWidth - this.getContainerElement().offsetWidth;
      },

      /**
      * Scrolls the wrapper contents to the x/y coordinates in a given period.
      *
      * @param x {Integer} X coordinate to scroll to.
      * @param y {Integer} Y coordinate to scroll to.
      * @param time {Integer} Time slice in which scrolling should
      *              be done.
      */
      _scrollTo: function _scrollTo(x, y, time) {
        if (this._isScrollable()) {
          // Normalize scrollable values
          var lowerLimitY = qx.bom.element.Dimension.getHeight(this._getScrollContentElement()) - this.getContainerElement().offsetHeight;

          if (y > lowerLimitY) {
            y = lowerLimitY;
          }

          var lowerLimitX = qx.bom.element.Dimension.getWidth(this._getScrollContentElement()) - this.getContainerElement().offsetWidth;

          if (x > lowerLimitX) {
            x = lowerLimitX;
          }

          if (this.__scroll) {
            this.__scroll.scrollTo(-x, -y, time);
          } else {
            // Case when iScroll is not loaded yet, but user tries
            // to set a different scroll position. Position is applied on "__onScrollLoaded".
            this._setCurrentY(x);

            this._setCurrentY(y);
          }
        }
      },

      /**
       * Loads and inits the iScroll instance.
       *
       * @ignore(iScroll)
       */
      __initScroll: function __initScroll() {
        if (!window.iScroll) {
          {
            var resource = "qx/mobile/js/iscroll.js";
          }
          var path = qx.util.ResourceManager.getInstance().toUri(resource);
          {
            path += "?" + new Date().getTime();
          }
          var loader = new qx.bom.request.Script();
          loader.on("load", this.__onScrollLoaded, this);
          loader.open("GET", path);
          loader.send();
        } else {
          this.addListenerOnce("appear", function () {
            this._setScroll(this.__createScrollInstance());
          }, this);
        }
      },

      /**
       * Creates the iScroll instance.
       *
       * @return {Object} The iScroll instance
       * @ignore(iScroll)
       */
      __createScrollInstance: function __createScrollInstance() {
        var defaultScrollProperties = this._getDefaultScrollProperties();

        var customScrollProperties = {};

        if (this._scrollProperties != null) {
          customScrollProperties = this._scrollProperties;
        }

        var iScrollProperties = qx.lang.Object.mergeWith(defaultScrollProperties, customScrollProperties, true);
        return new iScroll(this.getContainerElement(), iScrollProperties);
      },

      /**
       * Returns a map with default iScroll properties for the iScroll instance.
       * @return {Object} Map with default iScroll properties
       */
      _getDefaultScrollProperties: function _getDefaultScrollProperties() {
        var container = this;
        return {
          hideScrollbar: true,
          fadeScrollbar: true,
          hScrollbar: false,
          scrollbarClass: "scrollbar",
          useTransform: true,
          useTransition: true,
          onScrollEnd: function onScrollEnd() {
            // Alert interested parties that we scrolled to end of page.
            if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
              container._setCurrentX(-this.x);

              container._setCurrentY(-this.y);

              container.fireEvent("scrollEnd");

              if (this.y == this.maxScrollY) {
                container.fireEvent("pageEnd");
              }
            }
          },
          onScrollMove: function onScrollMove() {
            // Alert interested parties that we scrolled to end of page.
            if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
              container._setCurrentX(-this.x);

              container._setCurrentY(-this.y);

              if (this.y == this.maxScrollY) {
                container.fireEvent("pageEnd");
              }
            }
          },
          onBeforeScrollStart: function onBeforeScrollStart(e) {
            // QOOXDOO ENHANCEMENT: Do not prevent default for form elements

            /* When updating iScroll, please check out that doubleTapTimer is not active (commented out)
             * in code. DoubleTapTimer creates a fake click event. Android 4.1. and newer
             * is able to fire native events, which  create side effect with the fake event of iScroll. */
            var target = e.target;

            while (target.nodeType != 1) {
              target = target.parentNode;
            }

            if (target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA' && target.tagName != 'LABEL') {
              // Remove focus from input elements, so that the keyboard and the mouse cursor is hidden
              var elements = [];
              var inputElements = qx.lang.Array.cast(document.getElementsByTagName("input"), Array);
              var textAreaElements = qx.lang.Array.cast(document.getElementsByTagName("textarea"), Array);
              elements = elements.concat(inputElements);
              elements = elements.concat(textAreaElements);

              for (var i = 0, length = elements.length; i < length; i++) {
                elements[i].blur();
              }

              e.preventDefault();
            }
          }
        };
      },

      /**
       * Registers all needed event listener.
       */
      __registerEventListeners: function __registerEventListeners() {
        qx.event.Registration.addListener(window, "orientationchange", this._refresh, this);
        qx.event.Registration.addListener(window, "resize", this._refresh, this);
        this.addListener("touchmove", qx.bom.Event.stopPropagation);
        this.addListener("domupdated", this._refresh, this);
      },

      /**
       * Unregisters all needed event listener.
       */
      __unregisterEventListeners: function __unregisterEventListeners() {
        qx.event.Registration.removeListener(window, "orientationchange", this._refresh, this);
        qx.event.Registration.removeListener(window, "resize", this._refresh, this);
        this.removeListener("touchmove", qx.bom.Event.stopPropagation);
        this.removeListener("domupdated", this._refresh, this);
      },

      /**
       * Load callback. Called when the iScroll script is loaded.
       *
       * @param request {qx.bom.request.Script} The Script request object
       */
      __onScrollLoaded: function __onScrollLoaded(request) {
        if (request.status < 400) {
          if (!this.isDisposed()) {
            this._setScroll(this.__createScrollInstance());

            this._scrollTo(this._currentX, this._currentY);
          }
        } else {
          {
            this.error("Could not load iScroll");
          }
        }
      },

      /**
       * Setter for the scroll instance.
       *
       * @param scroll {Object} iScroll instance.
       */
      _setScroll: function _setScroll(scroll) {
        this.__scroll = scroll;
      },

      /**
       * Delegation method for iScroll. Disabled the iScroll objects.
       * Prevents any further scrolling of this container.
       */
      disable: function disable() {
        if (this.__scroll) {
          this.__scroll.disable();
        }
      },

      /**
       * Delegation method for iScroll. Enables the iScroll object.
       */
      enable: function enable() {
        if (this.__scroll) {
          this.__scroll.enable();
        }
      },

      /**
       * Calls the refresh function of iScroll. Needed to recalculate the
       * scrolling container.
       */
      _refresh: function _refresh() {
        if (this.__scroll) {
          this.__scroll.refresh();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__unregisterEventListeners(); // Cleanup iScroll


      if (this.__scroll) {
        this.__scroll.destroy();
      }

      this.__scroll = null;
    }
  });
  qx.ui.mobile.container.MIScroll.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Animation": {
        "require": true
      },
      "qx.module.Manipulating": {
        "require": true
      },
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Event": {
        "construct": true
      },
      "qx.bom.client.OperatingSystem": {
        "construct": true
      },
      "qx.bom.element.Location": {},
      "qx.bom.element.Animation": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "os.name": {
          "construct": true,
          "className": "qx.bom.client.OperatingSystem"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * @require(qx.module.Animation)
   * @require(qx.module.Manipulating)
   *
   * Mixin for the {@link Scroll} container. Used when the variant
   * <code>qx.mobile.nativescroll</code> is set to "on".
   */
  qx.Mixin.define("qx.ui.mobile.container.MNativeScroll", {
    construct: function construct() {
      this.addCssClass("native");
      this._snapPoints = [];
      this.addListenerOnce("appear", this._onAppear, this);
      this.addListener("trackstart", this._onTrackStart, this);
      this.addListener("trackend", this._onTrackEnd, this);
      qx.bom.Event.addNativeListener(this._getContentElement(), "scroll", this._onScroll.bind(this));

      if (qx.core.Environment.get("os.name") == "ios") {
        this.addListener("touchmove", this._onTouchMove, this);
      }
    },
    members: {
      _snapPoints: null,
      _onTrack: null,
      _snapTimeoutId: null,

      /**
      * Event handler for <code>appear</code> event.
      */
      _onAppear: function _onAppear() {
        this._calcSnapPoints();
      },

      /**
      * Event handler for <code>touchmove</code> event.
      * Needed for preventing iOS page bounce.
      * @param evt {qx.event.type.Touch} touchmove event.
      */
      _onTouchMove: function _onTouchMove(evt) {
        // If scroll container is scrollable
        if (this._isScrollableY()) {
          evt.stopPropagation();
        } else {
          evt.preventDefault();
        }
      },

      /**
       * Event handler for <code>trackstart</code> events.
       * @param evt {qx.event.type.Track} touchmove event.
       */
      _onTrackStart: function _onTrackStart(evt) {
        this._onTrack = true;

        if (qx.core.Environment.get("os.name") == "ios") {
          this._preventPageBounce();
        }
      },

      /**
       * Prevents the iOS page bounce if scroll container reaches the upper or lower vertical scroll limit.
       */
      _preventPageBounce: function _preventPageBounce() {
        // If scroll container is scrollable
        if (this._isScrollableY()) {
          var element = this.getContentElement();
          var scrollTop = element.scrollTop;
          var maxScrollTop = element.scrollHeight - this.getLayoutParent().getContentElement().offsetHeight;

          if (scrollTop === 0) {
            element.scrollTop = 1;
          } else if (scrollTop == maxScrollTop) {
            element.scrollTop = maxScrollTop - 1;
          }
        }
      },

      /**
      * Event handler for <code>trackend</code> events.
      * @param evt {qx.event.type.Track} touchmove event.
      */
      _onTrackEnd: function _onTrackEnd(evt) {
        this._onTrack = false;

        if (this._snapTimeoutId) {
          clearTimeout(this._snapTimeoutId);
        }

        this._snapTimeoutId = setTimeout(function () {
          this._snap();
        }.bind(this), 100);
        evt.stopPropagation();
      },

      /**
      * Event handler for <code>scroll</code> events.
      */
      _onScroll: function _onScroll() {
        var scrollLeft = this.getContentElement().scrollLeft;
        var scrollTop = this.getContentElement().scrollTop;

        this._setCurrentX(scrollLeft);

        this._setCurrentY(scrollTop);

        if (this._snapTimeoutId) {
          clearTimeout(this._snapTimeoutId);
        }

        this._snapTimeoutId = setTimeout(function () {
          if (!this._onTrack) {
            this._snap();
          }
        }.bind(this), 100);
      },

      /**
      * Calculates the snapping points for the x/y axis.
      */
      _calcSnapPoints: function _calcSnapPoints() {
        if (this._scrollProperties) {
          var snap = this._scrollProperties.snap;

          if (snap) {
            this._snapPoints = [];
            var snapTargets = this.getContentElement().querySelectorAll(snap);

            for (var i = 0; i < snapTargets.length; i++) {
              var snapPoint = qx.bom.element.Location.getRelative(this._getContentElement(), snapTargets[i], "scroll", "scroll");

              this._snapPoints.push(snapPoint);
            }
          }
        }
      },

      /**
      * Determines the next snap points for the passed current position.
      * @param current {Integer} description
      * @param snapProperty {String} "top" or "left"
      * @return {Integer} the determined snap point.
      */
      _determineSnapPoint: function _determineSnapPoint(current, snapProperty) {
        for (var i = 0; i < this._snapPoints.length; i++) {
          var snapPoint = this._snapPoints[i];

          if (current <= -snapPoint[snapProperty]) {
            if (i > 0) {
              var previousSnapPoint = this._snapPoints[i - 1];
              var previousSnapDiff = Math.abs(current + previousSnapPoint[snapProperty]);
              var nextSnapDiff = Math.abs(current + snapPoint[snapProperty]);

              if (previousSnapDiff < nextSnapDiff) {
                return -previousSnapPoint[snapProperty];
              } else {
                return -snapPoint[snapProperty];
              }
            } else {
              return -snapPoint[snapProperty];
            }
          }
        }

        return current;
      },

      /**
      * Snaps the scrolling area to the nearest snap point.
      */
      _snap: function _snap() {
        this.fireEvent("scrollEnd");
        var element = this.getContentElement();

        if (element.scrollTop < 1 || element.scrollTop > this._getScrollHeight()) {
          return;
        }

        var current = this._getPosition();

        var nextX = this._determineSnapPoint(current[0], "left");

        var nextY = this._determineSnapPoint(current[1], "top");

        if (nextX != current[0] || nextY != current[1]) {
          this._scrollTo(nextX, nextY, 300);
        }
      },

      /**
       * Refreshes the scroll container. Recalculates the snap points.
       */
      _refresh: function _refresh() {
        this._calcSnapPoints();
      },

      /**
       * Mixin method. Creates the scroll element.
       *
       * @return {Element} The scroll element
       */
      _createScrollElement: function _createScrollElement() {
        return null;
      },

      /**
       * Returns the current scroll position
       * @return {Array} an array with <code>[scrollLeft,scrollTop]</code>.
       */
      _getPosition: function _getPosition() {
        return [this.getContentElement().scrollLeft, this.getContentElement().scrollTop];
      },

      /**
       * Mixin method. Returns the scroll content element.
       *
       * @return {Element} The scroll content element
       */
      _getScrollContentElement: function _getScrollContentElement() {
        return null;
      },

      /**
      * Returns the scrolling height of the inner container.
      * @return {Number} the scrolling height.
      */
      _getScrollHeight: function _getScrollHeight() {
        if (!this.getContentElement()) {
          return 0;
        }

        return this.getContentElement().scrollHeight - this.getContentElement().offsetHeight;
      },

      /**
      * Returns the scrolling width of the inner container.
      * @return {Number} the scrolling width.
      */
      _getScrollWidth: function _getScrollWidth() {
        if (!this.getContentElement()) {
          return 0;
        }

        return this.getContentElement().scrollWidth - this.getContentElement().offsetWidth;
      },

      /**
       * Scrolls the wrapper contents to the x/y coordinates in a given period.
       *
       * @param x {Integer} X coordinate to scroll to.
       * @param y {Integer} Y coordinate to scroll to.
       * @param time {Integer} is always <code>0</code> for this mixin.
       */
      _scrollTo: function _scrollTo(x, y, time) {
        var element = this.getContentElement();

        if (!time) {
          element.scrollLeft = x;
          element.scrollTop = y;
          return;
        }

        var startY = element.scrollTop;
        var startX = element.scrollLeft;

        if (element) {
          qx.bom.element.Animation.animate(element, {
            "duration": time,
            "keyFrames": {
              0: {
                "scrollTop": startY,
                "scrollLeft": startX
              },
              100: {
                "scrollTop": y,
                "scrollLeft": x
              }
            },
            "keep": 100,
            "timing": "ease-out"
          });
        }
      }
    },
    destruct: function destruct() {
      qx.bom.Event.removeNativeListener(this._getContentElement(), "scroll", this._onScroll.bind(this));
      this.removeListener("touchmove", this._onTouchMove, this);
      this.removeListener("appear", this._onAppear, this);
      this.removeListener("trackstart", this._onTrackStart, this);
      this.removeListener("trackend", this._onTrackEnd, this);
    }
  });
  qx.ui.mobile.container.MNativeScroll.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.bom.element.Location": {},
      "qx.bom.element.Dimension": {},
      "qx.util.placement.Placement": {},
      "qx.ui.mobile.core.Blocker": {},
      "qx.lang.Function": {},
      "qx.event.Registration": {},
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.basic.Atom": {},
      "qx.log.Logger": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The popup represents a widget that gets shown above other widgets,
   * usually to present more info/details regarding an item in the application.
   *
   * There are 3 usages for now:
   *
   * <pre class='javascript'>
   * var widget = new qx.ui.mobile.form.Button("Error!");
   * var popup = new qx.ui.mobile.dialog.Popup(widget);
   * popup.show();
   * </pre>
   * Here we show a popup consisting of a single buttons alerting the user
   * that an error has occurred.
   * It will be centered to the screen.
   * <pre class='javascript'>
   * var label = new qx.ui.mobile.basic.Label("Item1");
   * var widget = new qx.ui.mobile.form.Button("Error!");
   * var popup = new qx.ui.mobile.dialog.Popup(widget, label);
   * popup.show();
   * widget.addListener("tap", function(){
   *   popup.hide();
   * });
   *
   * </pre>
   *
   * In this case everything is as above, except that the popup will get shown next to "label"
   * so that the user can understand that the info presented is about the "Item1"
   * we also add a tap listener to the button that will hide out popup.
   *
   * Once created, the instance is reused between show/hide calls.
   *
   * <pre class='javascript'>
   * var widget = new qx.ui.mobile.form.Button("Error!");
   * var popup = new qx.ui.mobile.dialog.Popup(widget);
   * popup.placeTo(25,100);
   * popup.show();
   * </pre>
   *
   * Same as the first example, but this time the popup will be shown at the 25,100 coordinates.
   *
   *
   */
  qx.Class.define("qx.ui.mobile.dialog.Popup", {
    extend: qx.ui.mobile.core.Widget,
    statics: {
      ROOT: null
    },

    /**
     * @param widget {qx.ui.mobile.core.Widget} the widget that will be shown in the popup
     * @param anchor {qx.ui.mobile.core.Widget?} optional parameter, a widget to attach this popup to
     */
    construct: function construct(widget, anchor) {
      qx.ui.mobile.core.Widget.constructor.call(this);
      this.exclude();

      if (qx.ui.mobile.dialog.Popup.ROOT == null) {
        qx.ui.mobile.dialog.Popup.ROOT = qx.core.Init.getApplication().getRoot();
      }

      qx.ui.mobile.dialog.Popup.ROOT.add(this);
      this.__anchor = anchor;

      if (widget) {
        this._initializeChild(widget);
      }
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "popup"
      },

      /**
       * The label/caption/text of the qx.ui.mobile.basic.Atom instance
       */
      title: {
        apply: "_applyTitle",
        nullable: true,
        check: "String",
        event: "changeTitle"
      },

      /**
       * Any URI String supported by qx.ui.mobile.basic.Image to display an icon
       */
      icon: {
        check: "String",
        apply: "_applyIcon",
        nullable: true,
        event: "changeIcon"
      },

      /**
       * Whether the popup should be displayed modal.
       */
      modal: {
        init: false,
        check: "Boolean",
        nullable: false
      },

      /**
       * Indicates whether the a modal popup should disappear when user taps/clicks on Blocker.
       */
      hideOnBlockerTap: {
        check: "Boolean",
        init: false
      }
    },
    members: {
      __isShown: false,
      __childrenContainer: null,
      __percentageTop: null,
      __anchor: null,
      __widget: null,
      __titleWidget: null,
      __lastPopupDimension: null,

      /**
       * Event handler. Called whenever the position of the popup should be updated.
       */
      _updatePosition: function _updatePosition() {
        // Traverse single anchor classes for removal, for preventing 'domupdated' event if no CSS classes changed.
        var anchorClasses = ['top', 'bottom', 'left', 'right', 'anchor'];

        for (var i = 0; i < anchorClasses.length; i++) {
          this.removeCssClass(anchorClasses[i]);
        }

        if (this.__anchor) {
          this.addCssClass('anchor');
          var rootHeight = qx.ui.mobile.dialog.Popup.ROOT.getHeight();
          var rootWidth = qx.ui.mobile.dialog.Popup.ROOT.getWidth();
          var rootPosition = qx.bom.element.Location.get(qx.ui.mobile.dialog.Popup.ROOT.getContainerElement());
          var anchorPosition = qx.bom.element.Location.get(this.__anchor.getContainerElement());
          var popupDimension = qx.bom.element.Dimension.getSize(this.getContainerElement());
          this.__lastPopupDimension = popupDimension;
          var computedPopupPosition = qx.util.placement.Placement.compute(popupDimension, {
            width: rootPosition.left + rootWidth,
            height: rootPosition.top + rootHeight
          }, anchorPosition, {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, "bottom-left", "keep-align", "keep-align"); // Reset Anchor.

          this._resetPosition();

          var isTop = anchorPosition.top > computedPopupPosition.top;
          var isLeft = anchorPosition.left > computedPopupPosition.left;
          computedPopupPosition.top = computedPopupPosition.top - rootPosition.top;
          computedPopupPosition.left = computedPopupPosition.left - rootPosition.left;
          var isOutsideViewPort = computedPopupPosition.top < 0 || computedPopupPosition.left < 0 || computedPopupPosition.left + popupDimension.width > rootWidth || computedPopupPosition.top + popupDimension.height > rootHeight;

          if (isOutsideViewPort) {
            this._positionToCenter();
          } else {
            if (isTop) {
              this.addCssClass('bottom');
            } else {
              this.addCssClass('top');
            }

            if (isLeft) {
              this.addCssClass('right');
            } else {
              this.addCssClass('left');
            }

            this.placeTo(computedPopupPosition.left, computedPopupPosition.top);
          }
        } else if (this.__childrenContainer) {
          // No Anchor
          this._positionToCenter();
        }
      },

      /**
       * This method shows the popup.
       * First it updates the position, then registers the event handlers, and shows it.
       */
      show: function show() {
        if (!this.__isShown) {
          qx.core.Init.getApplication().fireEvent("popup");

          this.__registerEventListener(); // Move outside of viewport


          this.placeTo(-1000, -1000); // Needs to be added to screen, before rendering position, for calculating
          // objects height.

          qx.ui.mobile.dialog.Popup.prototype.show.base.call(this); // Now render position.

          this._updatePosition();
        }

        this.__isShown = true;

        if (this.getModal() === true) {
          qx.ui.mobile.core.Blocker.getInstance().show();

          if (this.getHideOnBlockerTap()) {
            qx.ui.mobile.core.Blocker.getInstance().addListener("tap", this.hide, this);
          }
        }
      },

      /**
       * Hides the popup.
       */
      hide: function hide() {
        if (this.__isShown) {
          this.__unregisterEventListener();

          this.exclude();
        }

        this.__isShown = false;

        if (this.getModal()) {
          qx.ui.mobile.core.Blocker.getInstance().hide();
        }

        qx.ui.mobile.core.Blocker.getInstance().removeListener("tap", this.hide, this);
      },

      /**
       * Hides the popup after a given time delay.
       * @param delay {Integer} time delay in ms.
       */
      hideWithDelay: function hideWithDelay(delay) {
        if (delay) {
          qx.lang.Function.delay(this.hide, delay, this);
        } else {
          this.hide();
        }
      },

      /**
       * Returns the shown state of this popup.
       * @return {Boolean} whether the popup is shown or not.
       */
      isShown: function isShown() {
        return this.__isShown;
      },

      /**
       * Toggles the visibility of this popup.
       */
      toggleVisibility: function toggleVisibility() {
        if (this.__isShown == true) {
          this.hide();
        } else {
          this.show();
        }
      },

      /**
       * This method positions the popup widget at the coordinates specified.
       * @param left {Integer} - the value the will be set to container's left style property
       * @param top {Integer} - the value the will be set to container's top style property
       */
      placeTo: function placeTo(left, top) {
        this._setStyle("left", left + "px");

        this._setStyle("top", top + "px");
      },

      /**
       * Tracks the user tap on root and hides the widget if <code>pointerdown</code> event
       * occurs outside of the widgets bounds.
       * @param evt {qx.event.type.Pointer} the pointer event.
       */
      _trackUserTap: function _trackUserTap(evt) {
        var clientX = evt.getViewportLeft();
        var clientY = evt.getViewportTop();
        var popupLocation = qx.bom.element.Location.get(this.getContainerElement());
        var isOutsideWidget = clientX < popupLocation.left || clientX > popupLocation.left + this.__lastPopupDimension.width || clientY > popupLocation.top + this.__lastPopupDimension.height || clientY < popupLocation.top;

        if (isOutsideWidget) {
          this.hide();
        }
      },

      /**
       * Centers this widget to window's center position.
       */
      _positionToCenter: function _positionToCenter() {
        var container = this.getContainerElement();
        container.style.position = "absolute";
        container.style.marginLeft = -parseInt(container.offsetWidth / 2) + "px";
        container.style.marginTop = -parseInt(container.offsetHeight / 2) + "px";
        container.style.left = "50%";
        container.style.top = "50%";
      },

      /**
       * Resets the position of this element (left, top, margins...)
       */
      _resetPosition: function _resetPosition() {
        var container = this.getContainerElement();
        container.style.left = "0px";
        container.style.top = "0px";
        container.style.marginLeft = null;
        container.style.marginTop = null;
      },

      /**
       * Registers all needed event listeners
       */
      __registerEventListener: function __registerEventListener() {
        qx.core.Init.getApplication().addListener("stop", this.hide, this);
        qx.core.Init.getApplication().addListener("popup", this.hide, this);
        qx.event.Registration.addListener(window, "resize", this._updatePosition, this);

        if (this.__anchor) {
          this.__anchor.addCssClass("anchor-target");

          qx.ui.mobile.dialog.Popup.ROOT.addListener("pointerdown", this._trackUserTap, this);
        }
      },

      /**
       * Unregisters all needed event listeners
       */
      __unregisterEventListener: function __unregisterEventListener() {
        qx.core.Init.getApplication().removeListener("stop", this.hide, this);
        qx.core.Init.getApplication().removeListener("popup", this.hide, this);
        qx.event.Registration.removeListener(window, "resize", this._updatePosition, this);

        if (this.__anchor) {
          this.__anchor.removeCssClass("anchor-target");

          qx.ui.mobile.dialog.Popup.ROOT.removeListener("pointerdown", this._trackUserTap, this);
        }
      },

      /**
       * This method creates the container where the popup's widget will be placed
       * and adds it to the popup.
       * @param widget {qx.ui.mobile.core.Widget} - what to show in the popup
       *
       */
      _initializeChild: function _initializeChild(widget) {
        if (this.__childrenContainer == null) {
          this.__childrenContainer = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());

          this.__childrenContainer.setDefaultCssClass("popup-content");

          this._add(this.__childrenContainer);
        }

        if (this._createTitleWidget()) {
          this.__childrenContainer.remove(this._createTitleWidget());

          this.__childrenContainer.add(this._createTitleWidget());
        }

        this.__childrenContainer.add(widget, {
          flex: 1
        });

        widget.addListener("domupdated", this._updatePosition, this);
        this.__widget = widget;
      },

      /**
       * Creates the title atom widget.
       *
       * @return {qx.ui.mobile.basic.Atom} The title atom widget.
       */
      _createTitleWidget: function _createTitleWidget() {
        if (this.__titleWidget) {
          return this.__titleWidget;
        }

        if (this.getTitle() || this.getIcon()) {
          this.__titleWidget = new qx.ui.mobile.basic.Atom(this.getTitle(), this.getIcon());

          this.__titleWidget.addCssClass('popup-title');

          return this.__titleWidget;
        } else {
          return null;
        }
      },
      // property apply
      _applyTitle: function _applyTitle(value, old) {
        if (value) {
          if (this.__titleWidget) {
            this.__titleWidget.setLabel(value);
          } else {
            this.__titleWidget = new qx.ui.mobile.basic.Atom(value, this.getIcon());

            this.__titleWidget.addCssClass('popup-title');

            if (this.__widget) {
              this.__childrenContainer.addBefore(this._createTitleWidget(), this.__widget);
            } else {
              if (this.__childrenContainer) {
                this.__childrenContainer.add(this._createTitleWidget());
              }
            }
          }
        }
      },
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        if (value) {
          if (this.__titleWidget) {
            this.__titleWidget.setIcon(value);
          } else {
            this.__titleWidget = new qx.ui.mobile.basic.Atom(this.getTitle(), value);

            this.__titleWidget.addCssClass('popup-title');

            if (this.__widget) {
              this.__childrenContainer.addBefore(this._createTitleWidget(), this.__widget);
            } else {
              if (this.__childrenContainer) {
                this.__childrenContainer.add(this._createTitleWidget());
              }
            }
          }
        }
      },

      /**
       * Adds the widget that will be shown in this popup. This method can be used in the case when you have removed the widget from the popup
       * or you haven't passed it in the constructor.
       * @param widget {qx.ui.mobile.core.Widget} - what to show in the popup
       */
      add: function add(widget) {
        this.removeWidget();

        this._initializeChild(widget);
      },

      /**
       * A widget to attach this popup to.
       *
       * @param widget {qx.ui.mobile.core.Widget} The anchor widget.
       */
      setAnchor: function setAnchor(widget) {
        this.__anchor = widget;

        this._updatePosition();
      },

      /**
       * Returns the title widget.
       *
       * @return {qx.ui.mobile.basic.Atom} The title widget.
       */
      getTitleWidget: function getTitleWidget() {
        return this.__titleWidget;
      },

      /**
       * This method removes the widget shown in the popup.
       * @return {qx.ui.mobile.core.Widget|null} The removed widget or <code>null</code>
       * if the popup doesn't have an attached widget
       */
      removeWidget: function removeWidget() {
        if (this.__widget) {
          this.__widget.removeListener("domupdated", this._updatePosition, this);

          this.__childrenContainer.remove(this.__widget);

          return this.__widget;
        } else {
          {
            qx.log.Logger.debug(this, "this popup has no widget attached yet");
          }
          return null;
        }
      }
    },
    destruct: function destruct() {
      this.__unregisterEventListener();

      this._disposeObjects("__childrenContainer");

      this.__isShown = this.__percentageTop = this._anchor = this.__widget = this.__lastPopupDimension = null;
    }
  });
  qx.ui.mobile.dialog.Popup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.dialog.Popup": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true
      },
      "qx.ui.mobile.form.Button": {},
      "qx.ui.mobile.container.Scroll": {},
      "qx.bom.element.Style": {},
      "qx.ui.mobile.list.List": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * This widget displays a menu. A dialog menu extends a popup and contains a
   * list, which provides the user the possibility to select one value.
   * The selected value is identified through selected index.
   *
   *
   * *Example*
   * <pre class='javascript'>
   *
   * var model = new qx.data.Array(["item1","item2","item3"]);
   *
   * var menu = new qx.ui.mobile.dialog.Menu(model);
   * menu.show();
   * menu.addListener("changeSelection", function(evt){
   *    var selectedIndex = evt.getData().index;
   *    var selectedItem = evt.getData().item;
   * }, this);
   * </pre>
   *
   * This example creates a menu with several choosable items.
   */
  qx.Class.define("qx.ui.mobile.dialog.Menu", {
    extend: qx.ui.mobile.dialog.Popup,

    /**
     * @param itemsModel {qx.data.Array ?}, the model which contains the choosable items of the menu.
     * @param anchor {qx.ui.mobile.core.Widget ?} The anchor widget for this item. If no anchor is available, the menu will be displayed modal and centered on screen.
     */
    construct: function construct(itemsModel, anchor) {
      // Create the list with a delegate that
      // configures the list item.
      this.__selectionList = this._createSelectionList();

      if (itemsModel) {
        this.__selectionList.setModel(itemsModel);
      }

      this.__menuContainer = new qx.ui.mobile.container.Composite();
      this.__clearButton = this._createClearButton();
      this.__listScroller = this._createListScroller(this.__selectionList);

      this.__menuContainer.add(this.__listScroller);

      this.__menuContainer.add(this.__clearButton);

      qx.ui.mobile.dialog.Popup.constructor.call(this, this.__menuContainer, anchor);

      if (anchor) {
        this.setModal(false);
      } else {
        this.setModal(true);
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the selection is changed.
       */
      changeSelection: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "menu"
      },

      /**
       *  Class which is assigned to selected items.
       *  Useful for re-styling your menu via LESS.
       */
      selectedItemClass: {
        init: "item-selected"
      },

      /**
       * Class which is assigned to unselected items.
       * Useful for re-styling your menu via LESS.
       */
      unselectedItemClass: {
        init: "item-unselected"
      },

      /**
       * Defines if the menu has a null value in the list, which can be chosen
       * by the user. The label
       */
      nullable: {
        init: false,
        check: "Boolean",
        apply: "_applyNullable"
      },

      /**
       * The label of the null value entry of the list. Only relevant
       * when nullable property is set to <code>true</code>.
       */
      clearButtonLabel: {
        init: "None",
        check: "String",
        apply: "_applyClearButtonLabel"
      },

      /**
       * The selected index of this menu.
       */
      selectedIndex: {
        check: "Integer",
        apply: "_applySelectedIndex",
        nullable: true
      },

      /**
      * This value defines how much list items are visible inside the menu.
      */
      visibleListItems: {
        check: "Integer",
        apply: "_updatePosition",
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __selectionList: null,
      __clearButton: null,
      __listScroller: null,
      __menuContainer: null,
      // overridden
      show: function show() {
        qx.ui.mobile.dialog.Menu.prototype.show.base.call(this);
        this.scrollToItem(this.getSelectedIndex());
      },

      /**
       * Creates the clearButton. Override this to customize the widget.
       *
       * @return {qx.ui.mobile.form.Button} the clearButton of this menu.
       */
      _createClearButton: function _createClearButton() {
        var clearButton = new qx.ui.mobile.form.Button(this.getClearButtonLabel());
        clearButton.addListener("tap", this.__onClearButtonTap, this);
        clearButton.exclude();
        return clearButton;
      },

      /**
       * Creates the scroll container for the selectionList. Override this to customize the widget.
       * @param selectionList {qx.ui.mobile.list.List} The selectionList of this menu.
       * @return {qx.ui.mobile.container.Scroll} the scroll container which contains the selectionList of this menu.
       */
      _createListScroller: function _createListScroller(selectionList) {
        var listScroller = new qx.ui.mobile.container.Scroll({
          "snap": ".list-item"
        });
        listScroller.add(selectionList, {
          flex: 1
        });
        listScroller.addCssClass("menu-scroller");
        return listScroller;
      },

      /**
      * Getter for the scroll container which contains a @see {qx.ui.mobile.list.List} with the choosable items.
      * @return {qx.ui.mobile.container.Scroll} the scroll container which contains the selectionList of this menu.
      */
      _getListScroller: function _getListScroller() {
        return this.__listScroller;
      },
      // overridden
      _updatePosition: function _updatePosition() {
        var parentHeight = qx.ui.mobile.dialog.Popup.ROOT.getHeight();
        var listScrollerHeight = parseInt(parentHeight, 10) * 0.75;
        listScrollerHeight = parseInt(listScrollerHeight, 10);

        if (this.getVisibleListItems() !== null) {
          var newListScrollerHeight = this.__selectionList.getListItemHeight() * this.getVisibleListItems();
          listScrollerHeight = Math.min(newListScrollerHeight, listScrollerHeight);
        }

        qx.bom.element.Style.set(this.__listScroller.getContainerElement(), "maxHeight", listScrollerHeight + "px");

        qx.ui.mobile.dialog.Menu.prototype._updatePosition.base.call(this);
      },

      /**
       * Creates the selection list. Override this to customize the widget.
       *
       * @return {qx.ui.mobile.list.List} The selectionList of this menu.
       */
      _createSelectionList: function _createSelectionList() {
        var self = this;
        var selectionList = new qx.ui.mobile.list.List({
          configureItem: function configureItem(item, data, row) {
            item.setTitle(data);
            item.setShowArrow(false);
            var isItemSelected = self.getSelectedIndex() == row;

            if (isItemSelected) {
              item.removeCssClass(self.getUnselectedItemClass());
              item.addCssClass(self.getSelectedItemClass());
            } else {
              item.removeCssClass(self.getSelectedItemClass());
              item.addCssClass(self.getUnselectedItemClass());
            }
          }
        }); // Add an changeSelection event

        selectionList.addListener("changeSelection", this.__onListChangeSelection, this);
        selectionList.addListener("tap", this._onSelectionListTap, this);
        return selectionList;
      },

      /**
      * Getter for the selectionList of the menu.
      * @return {qx.ui.mobile.list.List} The selectionList of this menu.
      */
      getSelectionList: function getSelectionList() {
        return this.__selectionList;
      },

      /** Handler for tap event on selection list. */
      _onSelectionListTap: function _onSelectionListTap() {
        this.hideWithDelay(500);
      },

      /**
       * Sets the choosable items of the menu.
       * @param itemsModel {qx.data.Array}, the model of choosable items in the menu.
       */
      setItems: function setItems(itemsModel) {
        if (this.__selectionList) {
          this.__selectionList.setModel(null);

          this.__selectionList.setModel(itemsModel);
        }
      },

      /**
       * Fires an event which contains index and data.
       * @param evt {qx.event.type.Data}, contains the selected index number.
       */
      __onListChangeSelection: function __onListChangeSelection(evt) {
        this.setSelectedIndex(evt.getData());
      },

      /**
       * Event handler for tap on clear button.
       */
      __onClearButtonTap: function __onClearButtonTap() {
        this.fireDataEvent("changeSelection", {
          index: null,
          item: null
        });
        this.hide();
      },
      // property apply
      _applySelectedIndex: function _applySelectedIndex(value, old) {
        var listModel = this.__selectionList.getModel();

        if (listModel !== null) {
          var selectedItem = listModel.getItem(value);
          this.fireDataEvent("changeSelection", {
            index: value,
            item: selectedItem
          });
        }

        this._render();
      },
      // property apply
      _applyNullable: function _applyNullable(value, old) {
        if (value) {
          this.__clearButton.setVisibility("visible");
        } else {
          this.__clearButton.setVisibility("excluded");
        }
      },
      // property apply
      _applyClearButtonLabel: function _applyClearButtonLabel(value, old) {
        this.__clearButton.setValue(value);
      },

      /**
       * Triggers (re-)rendering of menu items.
       */
      _render: function _render() {
        var tmpModel = this.__selectionList.getModel();

        this.__selectionList.setModel(null);

        this.__selectionList.setModel(tmpModel);
      },

      /**
       * Scrolls the scroll wrapper of the selectionList to the item with given index.
       * @param index {Integer}, the index of the listItem to which the listScroller should scroll to.
       */
      scrollToItem: function scrollToItem(index) {
        if (index !== null && this.__selectionList.getModel() != null) {
          var listItems = qxWeb("#" + this.__listScroller.getId() + " .list-item");
          var targetListItemElement = listItems[index];

          this.__listScroller.scrollToElement(targetListItemElement);
        }
      }
    },
    destruct: function destruct() {
      this.__selectionList.removeListener("tap", this._onSelectionListTap, this);

      this._disposeObjects("__selectionList", "__clearButton", "__listScroller", "__menuContainer");
    }
  });
  qx.ui.mobile.dialog.Menu.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.mobile.form.MText": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.mobile.form.MState": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.bom.client.Scroll": {
        "construct": true
      },
      "qx.ui.mobile.container.Scroll": {},
      "qx.ui.mobile.core.Root": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "construct": true,
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The TextArea is a multi-line text input field.
   */
  qx.Class.define("qx.ui.mobile.form.TextArea", {
    extend: qx.ui.mobile.core.Widget,
    include: [qx.ui.mobile.form.MValue, qx.ui.mobile.form.MText, qx.ui.form.MForm, qx.ui.form.MModelProperty, qx.ui.mobile.form.MState],
    implement: [qx.ui.form.IField, qx.ui.form.IForm, qx.ui.form.IModel],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {var?null} The value of the widget.
     */
    construct: function construct(value) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
        this.addListener("appear", this._fixChildElementsHeight, this);
        this.addListener("input", this._fixChildElementsHeight, this);
        this.addListener("changeValue", this._fixChildElementsHeight, this);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "text-area"
      }
    },
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "textarea";
      },

      /**
       * Synchronizes the elements.scrollHeight and its height.
       * Needed for making textArea scrollable.
       * @param evt {qx.event.type.Data} a custom event.
       */
      _fixChildElementsHeight: function _fixChildElementsHeight(evt) {
        this.getContentElement().style.height = 'auto';
        this.getContentElement().style.height = this.getContentElement().scrollHeight + 'px';

        var scroll = this.__getScrollContainer();

        if (scroll) {
          scroll.refresh();
        }
      },

      /**
      * Returns the parent scroll container of this widget.
      * @return {qx.ui.mobile.container.Scroll} the parent scroll container or <code>null</code>
      */
      __getScrollContainer: function __getScrollContainer() {
        var scroll = this;

        while (!(scroll instanceof qx.ui.mobile.container.Scroll)) {
          if (scroll.getLayoutParent) {
            var layoutParent = scroll.getLayoutParent();

            if (layoutParent == null || layoutParent instanceof qx.ui.mobile.core.Root) {
              return null;
            }

            scroll = layoutParent;
          } else {
            return null;
          }
        }

        return scroll;
      }
    },
    destruct: function destruct() {
      if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
        this.removeListener("appear", this._fixChildElementsHeight, this);
        this.removeListener("input", this._fixChildElementsHeight, this);
        this.removeListener("changeValue", this._fixChildElementsHeight, this);
      }
    }
  });
  qx.ui.mobile.form.TextArea.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.layout.AbstractBox": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A horizontal box layout.
   *
   * The horizontal box layout lays out widgets in a horizontal row, from left
   * to right.
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>flex</strong> <em>(Integer)</em>: The flex property determines how the container
   *   distributes remaining empty space among its children. If items are made
   *   flexible, they can grow or shrink accordingly. Their relative flex values
   *   determine how the items are being resized, i.e. the larger the flex ratio
   *   of two items, the larger the resizing of the first item compared to the
   *   second.
   * </li>
   * </ul>
   *
   * *Example*
   *
   * Here is a little example of how to use the HBox layout.
   *
   * <pre class="javascript">
   * var layout = new qx.ui.mobile.layout.HBox().set({alignX:"center"});
   *
   * var container = new qx.ui.mobile.container.Composite(layout);
   *
   * container.add(new qx.ui.mobile.basic.Label("1"));
   * container.add(new qx.ui.mobile.basic.Label("2"), {flex:1});
   * container.add(new qx.ui.mobile.basic.Label("3"));
   * </pre>
   */
  qx.Class.define("qx.ui.mobile.layout.HBox", {
    extend: qx.ui.mobile.layout.AbstractBox,

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      // overridden
      _getCssClasses: function _getCssClasses() {
        return ["qx-hbox"];
      }
    }
  });
  qx.ui.mobile.layout.HBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The Row widget represents a row in a {@link Form}.
   */
  qx.Class.define("qx.ui.mobile.form.Row", {
    extend: qx.ui.mobile.container.Composite,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param layout {qx.ui.mobile.layout.Abstract?null} The layout that should be used for this
     *     container
     */
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout);
      this.initSelectable();
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "form-row"
      },

      /**
       * Whether the widget is selectable or not.
       */
      selectable: {
        check: "Boolean",
        init: false,
        apply: "_applyAttribute"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "li";
      }
    }
  });
  qx.ui.mobile.form.Row.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.bom.client.Css": {},
      "qx.bom.client.Event": {},
      "qx.event.Registration": {},
      "qx.event.type.Tap": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.flexboxSyntax": {
          "className": "qx.bom.client.Css"
        },
        "event.dispatchevent": {
          "className": "qx.bom.client.Event"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The label widget displays a text or HTML content in form context.
   *
   * It uses the html tag <label>, for making it possible to set the
   * "for" attribute.
   *
   * The "for" attribute specifies which form element a label is bound to.
   * A tap on the label is forwarded to the bound element.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var checkBox = new qx.ui.mobile.form.CheckBox();
   *   var label = new qx.ui.mobile.form.Label("Label for CheckBox");
   *
   *   label.setLabelFor(checkBox.getId());
   *
   *   this.getRoot().add(label);
   *   this.getRoot().add(checkBox);
   * </pre>
   *
   * This example create a widget to display the label.
   *
   */
  qx.Class.define("qx.ui.mobile.form.Label", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {String?null} Text or HTML content to display
     */
    construct: function construct(value) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (value) {
        this.setValue(value);
      }

      this.addCssClass("gap");

      this._setLayout(new qx.ui.mobile.layout.HBox().set({
        "alignY": "middle",
        "alignX": "left"
      }));

      this.initWrap();
      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      }
      this.addListener("tap", this._onTap, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "label"
      },

      /**
       * Text or HTML content to display
       */
      value: {
        nullable: true,
        init: null,
        apply: "_applyValue",
        event: "changeValue"
      },
      // overridden
      anonymous: {
        refine: true,
        init: false
      },

      /**
       * Controls whether text wrap is activated or not.
       */
      wrap: {
        check: "Boolean",
        init: true,
        apply: "_applyWrap"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __forWidget: null,
      // overridden
      _getTagName: function _getTagName() {
        return "label";
      },
      // property apply
      _applyValue: function _applyValue(value, old) {
        var html = value; // [BUG #7871] Bugfix for IE 10 for enabling word-wrap within a flexbox layout.

        if (qx.core.Environment.get("css.flexboxSyntax") === "flexbox") {
          html = "<p>" + value + "</p>";
        }

        this._setHtml(html);
      },
      // property apply
      _applyWrap: function _applyWrap(value, old) {
        if (value) {
          this.removeCssClass("no-wrap");
        } else {
          this.addCssClass("no-wrap");
        }
      },

      /**
      * Event handler for the <code>changeEnabled</code> event on the target.
      * @param evt {qx.event.type.Data} the changeEnabled event.
      */
      _changeEnabled: function _changeEnabled(evt) {
        if (evt) {
          this.setEnabled(evt.getData());
        }
      },

      /**
       * Setter for the "for" attribute of this label.
       * The "for" attribute specifies which form element a label is bound to.
       *
       * @param elementId {String} The id of the element the label is bound to.
       *
       */
      setLabelFor: function setLabelFor(elementId) {
        if (this.__forWidget) {
          this.__forWidget.removeListener("changeEnabled", this._changeEnabled, this);
        }

        this.__forWidget = qx.ui.mobile.core.Widget.getWidgetById(elementId);

        if (this.__forWidget) {
          this.__forWidget.addListener("changeEnabled", this._changeEnabled, this);

          this.setEnabled(this.__forWidget.getEnabled());
        }

        this._setAttribute("for", elementId);
      },

      /**
       * Handler for <code>tap</code> event on the Label. This event will be delegated to target widget.
       * @param evt {qx.event.type.Pointer} The tap event.
       */
      _onTap: function _onTap(evt) {
        if (this.__forWidget && qx.core.Environment.get("event.dispatchevent")) {
          var target = this.__forWidget.getContentElement();

          qx.event.Registration.fireEvent(target, "tap", qx.event.type.Tap, [evt.getNativeEvent(), target, null, true, true]);
        }
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale: function _onChangeLocale(e) {
        var content = this.getValue();

        if (content && content.translate) {
          this.setValue(content.translate());
        }
      }
    },
    destruct: function destruct() {
      this.removeListener("tap", this._onTap, this);

      if (this.__forWidget) {
        this.__forWidget.removeListener("changeEnabled", this._changeEnabled, this);

        this.__forWidget = null;
      }

      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
    }
  });
  qx.ui.mobile.form.Label.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Base class for all group item renderer.
   */
  qx.Class.define("qx.ui.mobile.list.renderer.group.Abstract", {
    extend: qx.ui.mobile.container.Composite,
    type: "abstract",
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout);
      this.initSelectable();
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "group-item"
      },

      /**
       * Whether the row is selectable.
       */
      selectable: {
        check: "Boolean",
        init: false,
        apply: "_applyAttribute"
      },
      //overridden
      activatable: {
        refine: true,
        init: true
      }
    },
    members: {
      // abstract method

      /**
       * Resets all defined child widgets. Override this method in your custom
       * list item renderer and reset all widgets displaying data. Needed as the
       * renderer is used for every row and otherwise data of a different row
       * might be displayed, when not all data displaying widgets are used for the row.
       * Gets called automatically by the {@link qx.ui.mobile.list.provider.Provider}.
       *
       */
      reset: function reset() {
        {
          throw new Error("Abstract method call");
        }
      },
      // overridden
      _getTagName: function _getTagName() {
        return "li";
      }
    }
  });
  qx.ui.mobile.list.renderer.group.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.list.renderer.group.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.basic.Image": {},
      "qx.ui.mobile.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The default group renderer. Used as the default renderer by the
   * {@link qx.ui.mobile.list.provider.Provider}. Configure the renderer
   * by setting the {@link qx.ui.mobile.list.List#delegate} property.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // Create the list with a delegate that
   *   // configures the list item.
   *   var list = new qx.ui.mobile.list.List({
   *     configureItem: function(item, data, row)
   *     {
   *       item.setImage("path/to/image.png");
   *       item.setTitle(data.title);
   *       item.setSubtitle(data.subtitle);
   *     },
   *
   *     configureGroupItem: function(item, data, group) {
   *       item.setTitle(group + " " + data.title);
   *     },
   *
   *     group: function(data, row) {
   *      return {
   *       title: row < 4 ? "Selectable" : "Unselectable"
   *     };
   *    }
   *  });
   * </pre>
   *
   * This example creates a list with a delegate that configures the list items and groups with
   * the given data.
   */
  qx.Class.define("qx.ui.mobile.list.renderer.group.Default", {
    extend: qx.ui.mobile.list.renderer.group.Abstract,
    construct: function construct(layout) {
      qx.ui.mobile.list.renderer.group.Abstract.constructor.call(this, layout || new qx.ui.mobile.layout.HBox().set({
        alignY: "middle"
      }));

      this._init();
    },
    members: {
      __image: null,
      __title: null,
      __rightContainer: null,

      /**
       * Returns the image widget which is used for this renderer.
       *
       * @return {qx.ui.mobile.basic.Image} The image widget
       */
      getImageWidget: function getImageWidget() {
        return this.__image;
      },

      /**
       * Returns the title widget which is used for this renderer.
       *
       * @return {qx.ui.mobile.basic.Label} The title widget
       */
      getTitleWidget: function getTitleWidget() {
        return this.__title;
      },

      /**
       * Sets the source of the image widget.
       *
       * @param source {String} The source to set
       */
      setImage: function setImage(source) {
        this.__image.setSource(source);
      },

      /**
       * Sets the value of the title widget.
       *
       * @param title {String} The value to set
       */
      setTitle: function setTitle(title) {
        if (title && title.translate) {
          this.__title.setValue(title.translate());
        } else {
          this.__title.setValue(title);
        }
      },

      /**
       * Setter for the data attribute <code></code>
       * @param groupTitle {String} the title of the group
       */
      setGroup: function setGroup(groupTitle) {
        this._setAttribute("data-group", groupTitle);
      },

      /**
       * Inits the widgets for the renderer.
       *
       */
      _init: function _init() {
        this.__image = this._createImage();
        this.add(this.__image);
        this.__rightContainer = this._createRightContainer();
        this.add(this.__rightContainer, {
          flex: 1
        });
        this.__title = this._createTitle();

        this.__rightContainer.add(this.__title);
      },

      /**
       * Creates and returns the right container composite. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.container.Composite} the right container.
       */
      _createRightContainer: function _createRightContainer() {
        return new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
      },

      /**
       * Creates and returns the image widget. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.basic.Image} the image widget.
       */
      _createImage: function _createImage() {
        var image = new qx.ui.mobile.basic.Image();
        image.setAnonymous(true);
        image.addCssClass("group-item-image");
        return image;
      },

      /**
       * Creates and returns the title widget. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.basic.Label} the title widget.
       */
      _createTitle: function _createTitle() {
        var title = new qx.ui.mobile.basic.Label();
        title.setWrap(false);
        title.addCssClass("group-item-title");
        return title;
      },
      // overridden
      reset: function reset() {
        this.__image.setSource(null);

        this.__title.setValue("");
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__image", "__title", "__rightContainer");
    }
  });
  qx.ui.mobile.list.renderer.group.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Base class for all list item renderer.
   */
  qx.Class.define("qx.ui.mobile.list.renderer.Abstract", {
    extend: qx.ui.mobile.container.Composite,
    type: "abstract",

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout);
      this.initSelectable();
      this.initRemovable();
      this.initShowArrow();
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "list-item"
      },

      /**
       * Whether the row is selected.
       */
      selected: {
        check: "Boolean",
        init: false,
        apply: "_applySelected"
      },

      /**
       * Whether the row is selectable.
       */
      selectable: {
        check: "Boolean",
        init: true,
        apply: "_applyAttribute"
      },

      /**
       * Whether the row is removable.
       */
      removable: {
        check: "Boolean",
        init: false,
        apply: "_applyRemovable"
      },

      /**
       * Whether to show an arrow in the row.
       */
      showArrow: {
        check: "Boolean",
        init: false,
        apply: "_applyShowArrow"
      },
      //overridden
      activatable: {
        refine: true,
        init: true
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      // abstract method

      /**
       * Resets all defined child widgets. Override this method in your custom
       * list item renderer and reset all widgets displaying data. Needed as the
       * renderer is used for every row and otherwise data of a different row
       * might be displayed, when not all data displaying widgets are used for the row.
       * Gets called automatically by the {@link qx.ui.mobile.list.provider.Provider}.
       *
       */
      reset: function reset() {
        {
          throw new Error("Abstract method call");
        }
      },
      // overridden
      _getTagName: function _getTagName() {
        return "li";
      },

      /**
       * Returns the row index of a certain DOM element in the list from the given event.
       *
       * @param evt {qx.event.type.Event} The causing event.
       * @return {Integer} the index of the row.
       */
      getRowIndexFromEvent: function getRowIndexFromEvent(evt) {
        return this.getRowIndex(evt.getOriginalTarget());
      },

      /**
       * Returns the row index of a certain DOM element in the list.
       *
       * @param element {Element} DOM element to retrieve the index from.
       * @return {Integer} the index of the row.
       */
      getRowIndex: function getRowIndex(element) {
        while (element.tagName != "LI") {
          element = element.parentNode;
        }

        return element.getAttribute("data-row");
      },
      // property apply
      _applyShowArrow: function _applyShowArrow(value, old) {
        if (value) {
          this.addCssClass("arrow");
        } else {
          this.removeCssClass("arrow");
        }
      },
      // property apply
      _applyRemovable: function _applyRemovable(value, old) {
        if (value) {
          this.addCssClass("removable");
        } else {
          this.removeCssClass("removable");
        }
      },
      // property apply
      _applySelected: function _applySelected(value, old) {
        if (value) {
          this.addCssClass("selected");
        } else {
          this.removeCssClass("selected");
        }
      }
    }
  });
  qx.ui.mobile.list.renderer.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.list.renderer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.basic.Image": {},
      "qx.ui.mobile.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The default list item renderer. Used as the default renderer by the
   * {@link qx.ui.mobile.list.provider.Provider}. Configure the renderer
   * by setting the {@link qx.ui.mobile.list.List#delegate} property.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *
   *   // Create the list with a delegate that
   *   // configures the list item.
   *   var list = new qx.ui.mobile.list.List({
   *     configureItem : function(item, data, row)
   *     {
   *       item.setImage("path/to/image.png");
   *       item.setTitle(data.title);
   *       item.setSubtitle(data.subtitle);
   *     }
   *   });
   * </pre>
   *
   * This example creates a list with a delegate that configures the list item with
   * the given data.
   */
  qx.Class.define("qx.ui.mobile.list.renderer.Default", {
    extend: qx.ui.mobile.list.renderer.Abstract,
    construct: function construct(layout) {
      qx.ui.mobile.list.renderer.Abstract.constructor.call(this, layout || new qx.ui.mobile.layout.HBox().set({
        alignY: "middle"
      }));

      this._init();
    },
    members: {
      __image: null,
      __title: null,
      __subtitle: null,
      __rightContainer: null,

      /**
       * Returns the image widget which is used for this renderer.
       *
       * @return {qx.ui.mobile.basic.Image} The image widget
       */
      getImageWidget: function getImageWidget() {
        return this.__image;
      },

      /**
       * Returns the title widget which is used for this renderer.
       *
       * @return {qx.ui.mobile.basic.Label} The title widget
       */
      getTitleWidget: function getTitleWidget() {
        return this.__title;
      },

      /**
       * Returns the subtitle widget which is used for this renderer.
       *
       * @return {qx.ui.mobile.basic.Label} The subtitle widget
       */
      getSubtitleWidget: function getSubtitleWidget() {
        return this.__subtitle;
      },

      /**
       * Sets the source of the image widget.
       *
       * @param source {String} The source to set
       */
      setImage: function setImage(source) {
        this.__image.setSource(source);
      },

      /**
       * Sets the value of the title widget.
       *
       * @param title {String} The value to set
       */
      setTitle: function setTitle(title) {
        if (title && title.translate) {
          this.__title.setValue(title.translate());
        } else {
          this.__title.setValue(title);
        }
      },

      /**
       * Sets the value of the subtitle widget.
       *
       * @param subtitle {String} The value to set
       */
      setSubtitle: function setSubtitle(subtitle) {
        if (subtitle && subtitle.translate) {
          this.__subtitle.setValue(subtitle.translate());
        } else {
          this.__subtitle.setValue(subtitle);
        }
      },

      /**
       * Inits the widgets for the renderer.
       *
       */
      _init: function _init() {
        this.__image = this._createImage();
        this.add(this.__image);
        this.__rightContainer = this._createRightContainer();
        this.add(this.__rightContainer, {
          flex: 1
        });
        this.__title = this._createTitle();

        this.__rightContainer.add(this.__title);

        this.__subtitle = this._createSubtitle();

        this.__rightContainer.add(this.__subtitle);
      },

      /**
       * Creates and returns the right container composite. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.container.Composite} the right container.
       */
      _createRightContainer: function _createRightContainer() {
        return new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
      },

      /**
       * Creates and returns the image widget. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.basic.Image} the image widget.
       */
      _createImage: function _createImage() {
        var image = new qx.ui.mobile.basic.Image();
        image.setAnonymous(true);
        image.addCssClass("list-item-image");
        return image;
      },

      /**
       * Creates and returns the title widget. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.basic.Label} the title widget.
       */
      _createTitle: function _createTitle() {
        var title = new qx.ui.mobile.basic.Label();
        title.setWrap(false);
        title.addCssClass("list-item-title");
        return title;
      },

      /**
       * Creates and returns the subtitle widget. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.basic.Label} the subtitle widget.
       */
      _createSubtitle: function _createSubtitle() {
        var subtitle = new qx.ui.mobile.basic.Label();
        subtitle.setWrap(false);
        subtitle.addCssClass("list-item-subtitle");
        return subtitle;
      },
      // overridden
      reset: function reset() {
        this.__image.setSource(null);

        this.__title.setValue("");

        this.__subtitle.setValue("");
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__image", "__title", "__subtitle", "__rightContainer");
    }
  });
  qx.ui.mobile.list.renderer.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.bom.Viewport": {},
      "qx.bom.element.Dimension": {},
      "qx.event.Registration": {},
      "qx.bom.Event": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * This class blocks events and can be included into all widgets.
   *
   */
  qx.Class.define("qx.ui.mobile.core.Blocker", {
    extend: qx.ui.mobile.core.Widget,
    type: "singleton",
    statics: {
      ROOT: null
    },
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (qx.ui.mobile.core.Blocker.ROOT == null) {
        qx.ui.mobile.core.Blocker.ROOT = qx.core.Init.getApplication().getRoot();
      }

      this.forceHide();
      qx.ui.mobile.core.Blocker.ROOT.add(this);
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "blocker"
      }
    },
    members: {
      __count: 0,

      /**
       * Shows the blocker. When the show method is called a counter is incremented.
       * The {@link #hide} method needs to be called as many times as the {@link #show}
       * method. This behavior is useful, when you want to show a loading indicator.
       */
      show: function show() {
        if (this.__count == 0) {
          this._updateSize();

          this.__registerEventListener();

          qx.ui.mobile.core.Blocker.prototype.show.base.call(this);
        }

        this.__count++;
      },

      /**
       * Hides the blocker. The blocker is only hidden when the hide method
       * is called as many times as the {@link #show} method.
       */
      hide: function hide() {
        this.__count--;

        if (this.__count <= 0) {
          this.__count = 0;

          this.__unregisterEventListener();

          this.exclude();
        }
      },

      /**
       * Force the blocker to hide, even when the show counter is larger than
       * zero.
       */
      forceHide: function forceHide() {
        this.__count = 0;
        this.hide();
      },

      /**
       * Whether the blocker is shown or not.
       * @return {Boolean} <code>true</code> if the blocker is shown
       */
      isShown: function isShown() {
        return this.__count > 0;
      },

      /**
       * Event handler. Called whenever the size of the blocker should be updated.
       */
      _updateSize: function _updateSize() {
        if (qx.ui.mobile.core.Blocker.ROOT == this.getLayoutParent()) {
          this.getContainerElement().style.top = qx.bom.Viewport.getScrollTop() + "px";
          this.getContainerElement().style.left = qx.bom.Viewport.getScrollLeft() + "px";
          this.getContainerElement().style.width = qx.bom.Viewport.getWidth() + "px";
          this.getContainerElement().style.height = qx.bom.Viewport.getHeight() + "px";
        } else if (this.getLayoutParent() != null) {
          var dimension = qx.bom.element.Dimension.getSize(this.getLayoutParent().getContainerElement());
          this.getContainerElement().style.width = dimension.width + "px";
          this.getContainerElement().style.height = dimension.height + "px";
        }
      },

      /**
       * Event handler. Called when the scroll event occurs.
       *
       * @param evt {Event} The scroll event
       */
      _onScroll: function _onScroll(evt) {
        this._updateSize();
      },

      /**
       * Registers all needed event listener.
       */
      __registerEventListener: function __registerEventListener() {
        qx.event.Registration.addListener(window, "resize", this._updateSize, this);
        qx.event.Registration.addListener(window, "scroll", this._onScroll, this);
        this.addListener("pointerdown", qx.bom.Event.preventDefault, this);
        this.addListener("pointerup", qx.bom.Event.preventDefault, this);
      },

      /**
       * Unregisters all needed event listener.
       */
      __unregisterEventListener: function __unregisterEventListener() {
        qx.event.Registration.removeListener(window, "resize", this._updateSize, this);
        qx.event.Registration.removeListener(window, "scroll", this._onScroll, this);
        this.removeListener("pointerdown", qx.bom.Event.preventDefault, this);
        this.removeListener("pointerup", qx.bom.Event.preventDefault, this);
      }
    },
    destruct: function destruct() {
      qx.ui.mobile.core.Blocker.ROOT.remove(this);

      this.__unregisterEventListener();
    }
  });
  qx.ui.mobile.core.Blocker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.basic.Image": {},
      "qx.bom.element.Style": {},
      "qx.ui.mobile.basic.Label": {},
      "qx.ui.mobile.container.Composite": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * A multi-purpose widget, which combines a label with an icon.
   *
   * The intended purpose of qx.ui.mobile.basic.Atom is to easily align the common icon-text
   * combination in different ways.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var atom = new qx.ui.mobile.basic.Atom("Icon Right", "icon/32/actions/go-next.png");
   *   this.getRoot().add(atom);
   * </pre>
   *
   * This example creates an atom with the label "Icon Right" and an icon.
   */
  qx.Class.define("qx.ui.mobile.basic.Atom", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Label to use
     * @param icon {String?null} Icon to use
     */
    construct: function construct(label, icon) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      this.__createChildren(label, icon);

      this.addCssClass("gap");
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "atom"
      },

      /** The label/caption/text of the qx.ui.mobile.basic.Atom instance */
      label: {
        apply: "_applyLabel",
        nullable: true,
        check: "String",
        event: "changeLabel"
      },

      /** Any URI String supported by qx.ui.mobile.basic.Image to display an icon */
      icon: {
        check: "String",
        apply: "_applyIcon",
        nullable: true,
        event: "changeIcon"
      },

      /**
       * Configure the visibility of the sub elements/widgets.
       * Possible values: both, text, icon
       */
      show: {
        init: "both",
        check: ["both", "label", "icon"],
        inheritable: true,
        apply: "_applyShow"
      },

      /**
       * The position of the icon in relation to the text.
       * Only useful/needed if text and icon is configured and 'show' is configured as 'both' (default)
       */
      iconPosition: {
        init: "left",
        check: ["top", "right", "bottom", "left"],
        apply: "_applyIconPosition"
      }
    },
    members: {
      __layout: null,
      __label: null,
      __icon: null,
      __childrenContainer: null,
      // property apply
      _applyIconPosition: function _applyIconPosition(value, old) {
        var verticalLayout = ["top", "bottom"].indexOf(value) != -1;
        var hasNoLabel = !this.__label;

        this.__createLayout(verticalLayout, hasNoLabel);

        var isReverse = ["right", "bottom"].indexOf(value) != -1;

        this.__childrenContainer.setLayout(this.__layout);

        this.__layout.setReversed(isReverse);

        this._domUpdated();
      },
      // property apply
      _applyShow: function _applyShow(value, old) {
        if (this.__label) {
          if (value === 'both' || value === 'label') {
            this.__label.show();
          } else if (value === 'icon') {
            this.__label.exclude();
          }
        }

        if (this.__icon) {
          if (value === 'both' || value === 'icon') {
            this.__icon.show();
          } else if (value === 'label') {
            this.__icon.exclude();
          }
        }
      },
      // property apply
      _applyLabel: function _applyLabel(value, old) {
        if (this.__label) {
          this.__label.setValue(value);
        } else {
          this.__label = this._createLabelWidget(value);
        }
      },
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        if (this.__icon) {
          this.__icon.setSource(value);
        } else {
          this.__icon = this._createIconWidget(value);
        }
      },

      /**
       * Takes care of lazily creating the layout and disposing an already
       * present layout if necessary.
       *
       * @param verticalLayout {Boolean} Whether icon and label should be vertically aligned.
       * @param hasNoLabel {Boolean} Whether the atom currently contains a label.
       */
      __createLayout: function __createLayout(verticalLayout, hasNoLabel) {
        if (verticalLayout || hasNoLabel) {
          if (this.__layout) {
            if (this.__layout.classname !== "qx.ui.mobile.layout.VBox") {
              this.__layout.dispose();

              this.__layout = new qx.ui.mobile.layout.VBox();
            }
          } // layout == null
          else {
              this.__layout = new qx.ui.mobile.layout.VBox();
            }
        } // horizontal layout and has label
        else {
            if (this.__layout) {
              if (this.__layout.classname !== "qx.ui.mobile.layout.HBox") {
                this.__layout.dispose();

                this.__layout = new qx.ui.mobile.layout.HBox();
              }
            } // layout == null
            else {
                this.__layout = new qx.ui.mobile.layout.HBox();
              }
          }
      },

      /**
       * Returns the icon widget.
       *
       * @return {qx.ui.mobile.basic.Image} The icon widget.
       */
      getIconWidget: function getIconWidget() {
        return this.__icon;
      },

      /**
       * Returns the label widget.
       *
       * @return {qx.ui.mobile.basic.Label} The label widget.
       */
      getLabelWidget: function getLabelWidget() {
        return this.__label;
      },

      /**
       * Creates the icon widget.
       *
       * @param iconUrl {String} The icon url.
       * @return {qx.ui.mobile.basic.Image} The created icon widget.
       */
      _createIconWidget: function _createIconWidget(iconUrl) {
        var iconWidget = new qx.ui.mobile.basic.Image(iconUrl);
        qx.bom.element.Style.set(iconWidget.getContentElement(), "display", "block");
        iconWidget.setAnonymous(true);
        iconWidget.addCssClass("gap");
        return iconWidget;
      },

      /**
       * Creates the label widget.
       *
       * @param label {String} The text that should be displayed.
       * @return {qx.ui.mobile.basic.Label} The created label widget.
       */
      _createLabelWidget: function _createLabelWidget(label) {
        var labelWidget = new qx.ui.mobile.basic.Label(label);
        labelWidget.setAnonymous(true);
        labelWidget.setWrap(false);
        labelWidget.addCssClass("gap");
        return labelWidget;
      },

      /**
       * This function is responsible for creating and adding 2 children controls to the Button widget.
       * A label and an icon.
       * @param label {String} the text of the button
       * @param icon {String} A path to an image resource
       *
       */
      __createChildren: function __createChildren(label, icon) {
        this.__label = this._createLabelWidget(label);

        if (label) {
          this.setLabel(label);
        }

        this.__icon = this._createIconWidget(icon);

        if (icon) {
          this.setIcon(icon);
        } else {
          this.__icon.exclude();
        }

        var verticalLayout = ["top", "bottom"].indexOf(this.getIconPosition()) != -1; // If Atom has no Label, only Icon is shown, and should vertically centered.

        var hasNoLabel = !this.__label;

        this.__createLayout(verticalLayout, hasNoLabel);

        if (this.__childrenContainer) {
          this.__childrenContainer.dispose();
        }

        this.__childrenContainer = new qx.ui.mobile.container.Composite(this.__layout);

        this.__childrenContainer.addCssClass("qx-flex-center");

        this.__childrenContainer.setAnonymous(true);

        if (this.__icon) {
          this.__childrenContainer.add(this.__icon);
        }

        if (this.__label) {
          this.__label.addCssClass("qx-flex-center");

          this.__childrenContainer.add(this.__label);
        } // Show/Hide Label/Icon


        if (this.getShow() === 'icon' && this.__label) {
          this.__label.exclude();
        }

        if (this.getShow() === 'label' && this.__icon) {
          this.__icon.exclude();
        }

        this._add(this.__childrenContainer);
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__layout", "__label", "__icon", "__childrenContainer");
    }
  });
  qx.ui.mobile.basic.Atom.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.basic.Atom": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A Button widget.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.mobile.form.Button("Hello World");
   *
   *   button.addListener("tap", function(e) {
   *     alert("Button was clicked");
   *   }, this);
   *
   *   this.getRoot.add(button);
   * </pre>
   *
   * This example creates a button with the label "Hello World" and attaches an
   * event listener to the {@link qx.ui.mobile.core.Widget#tap} event.
   */
  qx.Class.define("qx.ui.mobile.form.Button", {
    extend: qx.ui.mobile.basic.Atom,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "button"
      },
      // overridden
      activatable: {
        refine: true,
        init: true
      }
    },
    members: {
      /**
       * Sets the value.
       *
       * @param value {String} The value to set
       */
      setValue: function setValue(value) {
        this.setLabel(value);
      },

      /**
       * Returns the set value.
       *
       * @return {String} The set value
       */
      getValue: function getValue() {
        return this.getLabel();
      }
    }
  });
  qx.ui.mobile.form.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.util.ResourceManager": {},
      "qx.io.ImageLoader": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The image widget displays an image file.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var image = new qx.ui.mobile.basic.Image("path/to/icon.png");
   *
   *   this.getRoot().add(image);
   * </pre>
   *
   * This example create a widget to display the image
   * <code>path/to/icon.png</code>.
   *
   */
  qx.Class.define("qx.ui.mobile.basic.Image", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param source {String?null} The URL of the image to display.
     */
    construct: function construct(source) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (qx.ui.mobile.basic.Image.ROOT === null) {
        qx.ui.mobile.basic.Image.ROOT = qx.core.Init.getApplication().getRoot();
      }

      if (source) {
        this.setSource(source);
      } else {
        this.initSource();
      }

      qx.ui.mobile.basic.Image.ROOT.addListener("changeAppScale", this._onChangeAppScale, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired if the image source can not be loaded.
       */
      loadingFailed: "qx.event.type.Event",

      /**
       * Fired if the image has been loaded.
       */
      loaded: "qx.event.type.Event"
    },
    statics: {
      /** @type {qx.ui.mobile.core.Root} the mobile application root */
      ROOT: null,

      /** @type {String} a 1px*1px sized transparent image. */
      PLACEHOLDER_IMAGE: null
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The URL of the image to display.
       */
      source: {
        check: "String",
        nullable: true,
        init: null,
        apply: "_applySource"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "img";
      },
      // property apply
      _applySource: function _applySource(value, old) {
        var resourceManager = qx.util.ResourceManager.getInstance();
        var source = value;

        if (source && source.indexOf('data:') != 0) {
          var uri = resourceManager.toUri(source);

          if (resourceManager.has(source)) {
            var highResSource = resourceManager.findHighResolutionSource(source, qx.ui.mobile.basic.Image.ROOT.getAppScale());

            if (highResSource) {
              this._createHighResolutionOverlay(highResSource, source);

              source = qx.ui.mobile.basic.Image.PLACEHOLDER_IMAGE;
              uri = resourceManager.toUri(highResSource);
            } else {
              source = uri;
            }
          }

          if (!qx.io.ImageLoader.isFailed(uri) && !qx.io.ImageLoader.isLoaded(uri)) {
            qx.io.ImageLoader.load(uri, this.__loaderCallback, this);
          }
        }

        this._setSource(source);
      },

      /**
      * Event handler for "changeAppScale" on application root.
      * Reloads the image source.
      */
      _onChangeAppScale: function _onChangeAppScale() {
        this._applySource(this.getSource());
      },

      /**
      * Creates an overlay for this image which shows the image defined by the parameter 'highResSource',
      * but has the same size and position as the source image.
      * The original image widget is hidden by this method.
      *
      * @param highResSource {String} Image source of the high-resolution image.
      * @param lowResSource {String} Image source of the low-resolution image.
      */
      _createHighResolutionOverlay: function _createHighResolutionOverlay(highResSource, lowResSource) {
        // Replace the source through transparent pixel for making the high-resolution background image visible.
        var resourceManager = qx.util.ResourceManager.getInstance();

        this._setStyle("backgroundImage", "url(" + resourceManager.toUri(highResSource) + ")");

        this._setStyle("backgroundSize", "100%");

        this._setStyle("backgroundRepeat", "no-repeat");

        this._setStyle("backgroundPosition", "50% 50%");

        this._setStyle("width", resourceManager.getImageWidth(lowResSource) / 16 + "rem");

        this._setStyle("height", resourceManager.getImageHeight(lowResSource) / 16 + "rem");
      },

      /**
       * Event handler fired after the preloader has finished loading the icon
       *
       * @param source {String} Image source which was loaded
       * @param imageInfo {Map} Dimensions of the loaded image
       */
      __loaderCallback: function __loaderCallback(source, imageInfo) {
        // Ignore the callback on already disposed images
        if (this.$$disposed === true) {
          return;
        } // Output a warning if the image could not loaded and quit


        if (imageInfo.failed) {
          this.warn("Image could not be loaded: " + source);
          this.fireEvent("loadingFailed");
        } else if (imageInfo.aborted) {
          // ignore the rest because it is aborted
          return;
        } else {
          this.fireEvent("loaded");
        }

        this._domUpdated();
      },

      /**
       * Sets the source attribute of the image tag.
       *
       * @param source {String} Image source which was loaded
       */
      _setSource: function _setSource(source) {
        this._setAttribute("src", source);
      },

      /**
       * Sets the attribute draggable to the given value "isDraggable".
       * @param isDraggable {Boolean} target value.
       */
      setDraggable: function setDraggable(isDraggable) {
        if (isDraggable) {
          this._setAttribute("draggable", "true");
        } else {
          this._setAttribute("draggable", "false");
        }
      }
    },
    defer: function defer(statics) {
      statics.PLACEHOLDER_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    },
    destruct: function destruct() {
      qx.ui.mobile.basic.Image.ROOT.removeListener("changeAppScale", this._onChangeAppScale, this);
    }
  });
  qx.ui.mobile.basic.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.basic.Atom": {},
      "qx.util.ResourceManager": {},
      "qx.bom.element.Location": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /* ************************************************************************
  ************************************************************************ */

  /**
   *
   * @asset(qx/icon/Tango/48/places/user-home.png)
   * @asset(qx/icon/Tango/32/places/folder-open.png)
   */
  qx.Class.define("qx.test.mobile.basic.Atom", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testLabel: function testLabel() {
        var atom = new qx.ui.mobile.basic.Atom("myText");
        this.getRoot().add(atom);
        this.assertString(atom.getLabel());
        this.assertEquals(atom.getLabel(), "myText");
        this.assertEquals(atom.getLabel(), atom.getLabelWidget().getContainerElement().innerHTML);
        atom.setLabel("mySecondText");
        this.assertEquals(atom.getLabel(), "mySecondText");
        this.assertEquals(atom.getLabel(), atom.getLabelWidget().getContainerElement().innerHTML);
        atom.destroy();
      },
      testIcon: function testIcon() {
        var imageURL = qx.util.ResourceManager.getInstance().toUri("qx/icon/Tango/48/places/user-home.png");
        var atom = new qx.ui.mobile.basic.Atom("myText", imageURL);
        this.getRoot().add(atom);
        this.assertString(atom.getIcon());
        this.assertEquals(atom.getIconWidget().getSource(), imageURL); // atom.getIconWidget().getContainerElement().src is usually in the form:
        // http://127.0.0.1/tablet/framework/test/html/qx/icon/Tango/48/places/folder-remote.png
        // but http://127.0.0.1/tablet/framework/test/html/ differs on where you test it

        this.assertTrue(atom.getIconWidget().getContainerElement().src.indexOf("qx/icon/Tango/48/places/user-home.png") != -1);
        var image2URL = qx.util.ResourceManager.getInstance().toUri("qx/icon/Tango/32/places/folder-open.png");
        atom.setIcon(image2URL);
        this.assertEquals(atom.getIcon(), image2URL);
        this.assertTrue(atom.getIconWidget().getContainerElement().src.indexOf("qx/icon/Tango/32/places/folder-open.png") != -1);
        atom.destroy();
      },
      testShow: function testShow() {
        var imageURL = qx.util.ResourceManager.getInstance().toUri("qx/icon/Tango/48/places/user-home.png");
        var atom = new qx.ui.mobile.basic.Atom("myText", imageURL);
        this.getRoot().add(atom);
        this.assertTrue(atom.getIconWidget().isVisible());
        this.assertTrue(atom.getLabelWidget().isVisible());
        atom.setShow('label');
        this.assertFalse(atom.getIconWidget().isVisible());
        this.assertTrue(atom.getLabelWidget().isVisible());
        atom.setShow('icon');
        this.assertTrue(atom.getIconWidget().isVisible());
        this.assertFalse(atom.getLabelWidget().isVisible());
        atom.setShow('both');
        this.assertTrue(atom.getIconWidget().isVisible());
        this.assertTrue(atom.getLabelWidget().isVisible());
      },
      testIconPosition: function testIconPosition() {
        var imageURL = qx.util.ResourceManager.getInstance().toUri("qx/icon/Tango/48/places/user-home.png");
        var atom = new qx.ui.mobile.basic.Atom("myTextmyTextmyTextmyTextmyText", imageURL);
        this.getRoot().add(atom);

        this.getRoot()._domUpdated();

        var iconElement = atom.getIconWidget().getContentElement();
        var labelElement = atom.getLabelWidget().getContentElement();
        atom.setIconPosition('top');
        this.assertTrue(qx.bom.element.Location.getTop(iconElement) <= qx.bom.element.Location.getTop(labelElement), "setIconPosition(top): iconElement.top is greater than labelElement.top");
        this.assertTrue(atom.getIconWidget().getLayoutParent().getLayout().basename === "VBox", "Layout of IconPosition Top should be VBox ");
        this.assertFalse(atom.getIconWidget().getLayoutParent().getLayout().isReversed(), "Layout should not be reversed.");
        atom.setIconPosition('bottom');
        this.assertTrue(atom.getIconWidget().getLayoutParent().getLayout().basename === "VBox", "Layout of IconPosition Bottom should be VBox ");
        this.assertTrue(atom.getIconWidget().getLayoutParent().getLayout().isReversed(), "Layout should be reversed.");
        atom.setIconPosition('left');
        this.assertTrue(atom.getIconWidget().getLayoutParent().getLayout().basename === "HBox", "Layout of IconPosition Left should be HBox ");
        var labelLeft = qx.bom.element.Location.getLeft(labelElement);
        var iconLeft = qx.bom.element.Location.getLeft(iconElement);
        this.assertTrue(iconLeft <= labelLeft, "setIconPosition(left): iconElement.left is greater than labelElement.left");
        this.assertFalse(atom.getIconWidget().getLayoutParent().getLayout().isReversed(), "Layout should not be reversed.");
        atom.setIconPosition('right');
        this.assertTrue(atom.getIconWidget().getLayoutParent().getLayout().basename === "HBox", "Layout of IconPosition Right should be HBox ");
        this.assertTrue(atom.getIconWidget().getLayoutParent().getLayout().isReversed(), "Layout should be reversed.");
        labelLeft = qx.bom.element.Location.getLeft(labelElement);
        iconLeft = qx.bom.element.Location.getLeft(iconElement);
        this.assertTrue(iconLeft >= labelLeft, "setIconPosition(right): iconElement.left is lower than labelElement.left");

        this.getRoot()._domUpdated();
      },
      testSetLabelAndIcon: function testSetLabelAndIcon() {
        var testText = "test234";
        var imageURL = qx.util.ResourceManager.getInstance().toUri("qx/icon/Tango/48/places/user-home.png");
        var atom = new qx.ui.mobile.basic.Atom();
        atom.setLabel(testText);
        atom.setIcon(imageURL);
        var atomElement = atom.getContentElement();
        var atomChildrenLength = atomElement.children[0].children.length;
        var atomIconTag = atomElement.children[0].children[0].tagName;
        var atomIconInnerHtml = atomElement.children[0].children[0].innerHTML;
        var atomLabelInnerHtml = atomElement.children[0].children[1].innerHTML;
        this.assertEquals("IMG", atomIconTag, 'Unexpected atom children tag');
        this.assertEquals(2, atomChildrenLength, 'Unexpected count of atom element children');
        this.assertEquals('', atomIconInnerHtml, 'Child element of icon has wrong content');
        this.assertEquals(testText, atomLabelInnerHtml, 'Child element of icon has wrong content');
      }
    }
  });
  qx.test.mobile.basic.Atom.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.util.ResourceManager": {},
      "qx.io.ImageLoader": {},
      "qx.ui.mobile.basic.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * @asset(qx/icon/Tango/48/places/folder.png)
   */
  qx.Class.define("qx.test.mobile.basic.Image", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testSrc: function testSrc() {
        var source = qx.util.ResourceManager.getInstance().toUri("qx/icon/Tango/48/places/folder.png");

        if (qx.io.ImageLoader.isLoaded(source)) {
          this.debug("testLoadedEvent skipped! Image already loaded.");
          return;
        }

        var image = new qx.ui.mobile.basic.Image("qx/icon/Tango/48/places/folder.png");
        image.addListener("loaded", function () {
          this.resume(function () {
            // use a timeout to dispose the image because it needs to
            // end its processing after the event has been fired.
            window.setTimeout(function () {
              image.destroy();
            });
          });
        }, this);
        this.getRoot().add(image);
        this.wait();
      },
      testLoadingFailed: function testLoadingFailed() {
        var image = new qx.ui.mobile.basic.Image("does not exist.png" + Math.random());
        this.getRoot().add(image);
        image.addListener("loadingFailed", function () {
          this.resume(function () {
            // use a timeout to dispose the image because it needs to
            // end its processing after the event has been fired.
            window.setTimeout(function () {
              image.destroy();
            });
          });
        }, this);
        this.wait();
      }
    }
  });
  qx.test.mobile.basic.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.basic.Label", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testValue: function testValue() {
        var label = new qx.ui.mobile.basic.Label("affe");
        this.getRoot().add(label);
        this.assertString(label.getValue());
        this.assertEquals(label.getValue(), "affe");
        this.assertEquals(label.getValue(), label.getContentElement().innerHTML);
        this.assertEventFired(label, "changeValue", function () {
          label.setValue("");
        });
        this.assertEquals(label.getValue(), "");
        this.assertEquals(label.getValue(), label.getContentElement().innerHTML);
        label.destroy();
      }
    }
  });
  qx.test.mobile.basic.Label.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.container.Carousel": {},
      "qx.ui.mobile.container.Composite": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.container.Carousel", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testInit: function testInit() {
        var carousel = new qx.ui.mobile.container.Carousel(0.4);
        this.getRoot().add(carousel);
        carousel.destroy();
      },
      testAddCarouselPage: function testAddCarouselPage() {
        var carousel = new qx.ui.mobile.container.Carousel();
        var carouselPage = new qx.ui.mobile.container.Composite();
        carousel.add(carouselPage);
        this.getRoot().add(carousel);
        carousel.destroy();
        carouselPage.destroy();
      },
      testRemoveCarouselPage: function testRemoveCarouselPage() {
        var carousel = new qx.ui.mobile.container.Carousel();
        var carouselPage = new qx.ui.mobile.container.Composite();
        carousel.add(carouselPage);
        carousel.removePageByIndex(0);
        this.getRoot().add(carousel);
        carousel.destroy();
        carouselPage.destroy();
      },
      testPageSwitch: function testPageSwitch() {
        var carousel = new qx.ui.mobile.container.Carousel();
        var carouselPage1 = new qx.ui.mobile.container.Composite();
        carousel.add(carouselPage1);
        var carouselPage2 = new qx.ui.mobile.container.Composite();
        carousel.add(carouselPage2);
        this.getRoot().add(carousel);
        this.assertEquals(0, carousel.getCurrentIndex());
        carousel.nextPage();
        this.assertEquals(1, carousel.getCurrentIndex()); // OVERFLOW

        carousel.nextPage();
        this.assertEquals(1, carousel.getCurrentIndex());
        carousel.previousPage();
        this.assertEquals(0, carousel.getCurrentIndex()); // OVERFLOW

        carousel.previousPage();
        this.assertEquals(0, carousel.getCurrentIndex());
        carousel.destroy();
        carouselPage1.destroy();
        carouselPage2.destroy();
      },
      testPageSwitchEvent: function testPageSwitchEvent() {
        var carousel = new qx.ui.mobile.container.Carousel();
        var carouselPage1 = new qx.ui.mobile.container.Composite();
        carousel.add(carouselPage1);
        var carouselPage2 = new qx.ui.mobile.container.Composite();
        carousel.add(carouselPage2);
        this.getRoot().add(carousel);
        this.assertEventFired(carousel, "changeCurrentIndex", function () {
          carousel.nextPage();
        }, function (e) {
          this.assertEquals(1, e.getData());
          this.assertEquals(0, e.getOldData());
        }.bind(this));
        this.assertEventFired(carousel, "changeCurrentIndex", function () {
          carousel.previousPage();
        }, function (e) {
          this.assertEquals(0, e.getData());
          this.assertEquals(1, e.getOldData());
        }.bind(this));
        carousel.destroy();
        carouselPage1.destroy();
        carouselPage2.destroy();
      },
      testScrollToPage: function testScrollToPage() {
        var carousel = new qx.ui.mobile.container.Carousel();
        var carouselPage1 = new qx.ui.mobile.container.Composite();
        carousel.add(carouselPage1);
        var carouselPage2 = new qx.ui.mobile.container.Composite();
        carousel.add(carouselPage2);
        this.getRoot().add(carousel);
        this.assertEquals(0, carousel.getCurrentIndex());
        carousel.setCurrentIndex(1);
        this.assertEquals(1, carousel.getCurrentIndex());
        window.setTimeout(function () {
          carousel.destroy();
          carouselPage1.destroy();
          carouselPage2.destroy();
        }, 600);
      }
    }
  });
  qx.test.mobile.container.Carousel.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.element.Style": {},
      "qx.bom.client.Scroll": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * This mixin resizes the container element to the height of the parent element.
   * Use this when the height can not be set by CSS.
   *
   */
  qx.Mixin.define("qx.ui.mobile.core.MResize", {
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Whether the resize should fire the "domupdated" event. Set this to "true"
       *  whenever other elements should react on this size change (e.g. when the size
       *  change does not infect the size of the application, but other widgets should
       *  react).
       */
      fireDomUpdatedOnResize: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __lastHeight: null,
      __lastWidth: null,

      /**
       * Removes fixed size from container.
       */
      releaseFixedSize: function releaseFixedSize() {
        var parent = this.getLayoutParent();

        if (parent && parent.getContainerElement()) {
          var element = this.getContainerElement();
          qx.bom.element.Style.set(element, "height", "auto");
          qx.bom.element.Style.set(element, "width", "auto");
        }
      },

      /**
       * Resizes the container element to the height of the parent element.
       */
      fixSize: function fixSize() {
        var parent = this.getLayoutParent();

        if (parent && parent.getContainerElement()) {
          var height = parent.getContainerElement().offsetHeight;
          var width = parent.getContainerElement().offsetWidth; // Only fix size, when value are above zero.

          if (height === 0 || width === 0) {
            return;
          }

          if (!this.getFireDomUpdatedOnResize()) {
            this._setHeight(height);

            this._setWidth(width);
          } else if (this.__lastHeight != height && this.__lastWidth != width) {
            this._setHeight(height);

            this._setWidth(width);

            this.__lastWidth = width;
            this.__lastHeight = height;

            this._domUpdated();
          }
        }
      },

      /**
       * Sets the height of the container element.
       *
       * @param height {Integer} The height to set
       */
      _setHeight: function _setHeight(height) {
        var element = this.getContainerElement();

        if (qx.core.Environment.get("qx.mobile.nativescroll")) {
          qx.bom.element.Style.set(element, "minHeight", height + "px");
        } else {
          qx.bom.element.Style.set(element, "height", height + "px");
        }
      },

      /**
       * Sets the width of the container element.
       *
       * @param width {Integer} The width to set
       */
      _setWidth: function _setWidth(width) {
        var element = this.getContainerElement();

        if (qx.core.Environment.get("qx.mobile.nativescroll")) {
          qx.bom.element.Style.set(element, "minWidth", width + "px");
        } else {
          qx.bom.element.Style.set(element, "width", width + "px");
        }
      }
    }
  });
  qx.ui.mobile.core.MResize.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.core.MResize": {
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.bom.Event": {
        "construct": true
      },
      "qx.event.Registration": {
        "construct": true
      },
      "qx.ui.mobile.layout.VBox": {
        "construct": true
      },
      "qx.util.DisposeUtil": {},
      "qx.bom.element.Style": {},
      "qx.ui.mobile.basic.Label": {},
      "qx.bom.element.Dimension": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Creates a Carousel widget.
   * A carousel is a widget which can switch between several sub pages {@link  qx.ui.mobile.container.Composite}.
   * A page switch is triggered by a swipe to left, for next page, or a swipe to right for
   * previous page.
   *
   * A carousel shows by default a pagination indicator at the bottom of the carousel.
   * This pagination indicator can be hidden by property <code>showPagination</code>.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *
   *  var carousel = new qx.ui.mobile.container.Carousel();
   *  var carouselPage1 = new qx.ui.mobile.container.Composite();
   *  var carouselPage2 = new qx.ui.mobile.container.Composite();
   *
   *  carouselPage1.add(new qx.ui.mobile.basic.Label("This is a carousel. Please swipe left."));
   *  carouselPage2.add(new qx.ui.mobile.basic.Label("Now swipe right."));
   *
   *  carousel.add(carouselPage1);
   *  carousel.add(carouselPage2);
   * </pre>
   *
   */
  qx.Class.define("qx.ui.mobile.container.Carousel", {
    extend: qx.ui.mobile.container.Composite,
    include: qx.ui.mobile.core.MResize,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
    * @param transitionDuration {Integer ? 0.4} transition duration on carouselPage change in seconds.
    */
    construct: function construct(transitionDuration) {
      qx.ui.mobile.container.Composite.constructor.call(this);

      if (transitionDuration) {
        this.setTransitionDuration(transitionDuration);
      }

      this.__snapPointsX = [];
      this.__onMoveOffset = [0, 0];
      this.__lastOffset = [0, 0];
      this.__boundsX = [0, 0];
      this.__pages = [];
      this.__paginationLabels = [];
      var carouselScroller = this.__carouselScroller = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox());
      carouselScroller.setTransformUnit("px");
      carouselScroller.addCssClass("carousel-scroller");
      carouselScroller.addListener("pointerdown", this._onPointerDown, this);
      carouselScroller.addListener("pointerup", this._onPointerUp, this);
      carouselScroller.addListener("track", this._onTrack, this);
      carouselScroller.addListener("swipe", this._onSwipe, this);
      this.addListener("touchmove", qx.bom.Event.preventDefault, this);
      this.addListener("appear", this._onContainerUpdate, this);
      qx.event.Registration.addListener(this.__carouselScroller.getContainerElement(), "transitionEnd", this._onScrollerTransitionEnd, this);
      qx.event.Registration.addListener(window, "orientationchange", this._onContainerUpdate, this);
      qx.event.Registration.addListener(window, "resize", this._onContainerUpdate, this);
      qx.event.Registration.addListener(this.getContentElement(), "scroll", this._onNativeScroll, this);
      var pagination = this.__pagination = new qx.ui.mobile.container.Composite();
      pagination.setLayout(new qx.ui.mobile.layout.HBox());
      pagination.setTransformUnit("px");
      pagination.addCssClass("carousel-pagination");
      this.setLayout(new qx.ui.mobile.layout.VBox());

      this._add(carouselScroller, {
        flex: 1
      });

      this._add(pagination, {
        flex: 1
      });
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "carousel"
      },

      /** Property for setting visibility of pagination indicator */
      showPagination: {
        check: "Boolean",
        init: true,
        apply: "_applyShowPagination"
      },

      /** Defines whether the carousel should scroll back to first or last page
       * when the start/end of carousel pages is reached  */
      scrollLoop: {
        check: "Boolean",
        init: true
      },

      /**
       * Defines the height of the carousel. If value is equal to <code>null</code>
       * the height is set to <code>100%</code>.
       */
      height: {
        check: "Number",
        init: 200,
        nullable: true,
        apply: "_updateCarouselLayout"
      },

      /**
       * The current visible page index.
       */
      currentIndex: {
        check: "Number",
        init: 0,
        apply: "_scrollToPage",
        event: "changeCurrentIndex"
      },

      /**
       * Duration of the carousel page transition.
       */
      transitionDuration: {
        check: "Number",
        init: 0.5
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __carouselScroller: null,
      __carouselScrollerWidth: null,
      __carouselWidth: null,
      __paginationLabels: null,
      __pagination: null,
      __snapPointsX: null,
      __onMoveOffset: null,
      __lastOffset: null,
      __boundsX: null,
      __pages: null,
      __showTransition: null,
      __isPageScrollTarget: null,
      __deltaX: null,
      __deltaY: null,
      // overridden

      /**
       * Adds a page to the end of the carousel.
       * @param page {qx.ui.mobile.container.Composite} The composite which should be added as a page to the end of carousel.
       */
      add: function add(page) {
        {
          if (!page instanceof qx.ui.mobile.container.Composite) {
            throw new Error("Page is expected to be an instance of qx.ui.mobile.container.Composite.");
          }
        }
        page.addCssClass("carousel-page");

        this.__pages.push(page);

        this.__carouselScroller.add(page, {
          flex: 1
        });

        var paginationLabel = this._createPaginationLabel();

        this.__paginationLabels.push(paginationLabel);

        this.__pagination.add(paginationLabel);

        this._setTransitionDuration(0);

        this._onContainerUpdate();
      },

      /**
       * Removes a carousel page from carousel identified by its index.
       * @param pageIndex {Integer} The page index which should be removed from carousel.
       * @return {qx.ui.mobile.container.Composite} the page which was removed from carousel.
       */
      removePageByIndex: function removePageByIndex(pageIndex) {
        if (this.__pages && this.__pages.length > pageIndex) {
          if (pageIndex <= this.getCurrentIndex() && this.getCurrentIndex() !== 0) {
            this.setCurrentIndex(this.getCurrentIndex() - 1);
          }

          var targetPage = this.__pages[pageIndex];
          var paginationLabel = this.__paginationLabels[pageIndex];

          this.__carouselScroller.remove(targetPage);

          this.__pagination.remove(paginationLabel);

          paginationLabel.removeListener("tap", this._onPaginationLabelTap, {
            self: this,
            targetIndex: pageIndex - 1
          });
          qx.util.DisposeUtil.destroyContainer(paginationLabel);

          this.__pages.splice(pageIndex, 1);

          this.__paginationLabels.splice(pageIndex, 1);

          this._onContainerUpdate();

          return targetPage;
        }
      },
      // overridden
      removeAll: function removeAll() {
        var removedPages = [];

        if (this.__pages) {
          for (var i = this.__pages.length - 1; i >= 0; i--) {
            removedPages.push(this.removePageByIndex(i));
          }
        }

        return removedPages;
      },

      /**
       * Scrolls the carousel to next page.
       */
      nextPage: function nextPage() {
        if (this.getCurrentIndex() == this.__pages.length - 1) {
          if (this.isScrollLoop() && this.__pages.length > 1) {
            this._doScrollLoop();
          }
        } else {
          this.setCurrentIndex(this.getCurrentIndex() + 1);
        }
      },

      /**
       * Scrolls the carousel to previous page.
       */
      previousPage: function previousPage() {
        if (this.getCurrentIndex() === 0) {
          if (this.isScrollLoop() && this.__pages.length > 1) {
            this._doScrollLoop();
          }
        } else {
          this.setCurrentIndex(this.getCurrentIndex() - 1);
        }
      },

      /**
      * Returns the current page count of this carousel.
      * @return {Integer} the current page count
      */
      getPageCount: function getPageCount() {
        if (this.__pages) {
          return this.__pages.length;
        }

        return 0;
      },

      /**
       * Scrolls the carousel to the page with the given pageIndex.
       * @param pageIndex {Integer} the target page index, which should be visible
       * @param showTransition {Boolean ? true} flag if a transition should be shown or not
       */
      _scrollToPage: function _scrollToPage(pageIndex, showTransition) {
        if (pageIndex >= this.__pages.length || pageIndex < 0) {
          return;
        }

        this._updatePagination(pageIndex);

        var snapPoint = -pageIndex * this.__carouselWidth;

        this._updateScrollerPosition(snapPoint); // Update lastOffset, because snapPoint has changed.


        this.__lastOffset[0] = snapPoint;
      },

      /**
       * Manages the the scroll loop. First fades out carousel scroller >>
       * waits till fading is done >> scrolls to pageIndex >> waits till scrolling is done
       * >> fades scroller in.
       */
      _doScrollLoop: function _doScrollLoop() {
        this._setTransitionDuration(this.getTransitionDuration());

        setTimeout(function () {
          this._setScrollersOpacity(0);
        }.bind(this), 0);
      },

      /**
      * Event handler for <code>transitionEnd</code> event on carouselScroller.
      */
      _onScrollerTransitionEnd: function _onScrollerTransitionEnd() {
        var opacity = qx.bom.element.Style.get(this.__carouselScroller.getContainerElement(), "opacity");

        if (opacity === 0) {
          var pageIndex = null;

          if (this.getCurrentIndex() == this.__pages.length - 1) {
            pageIndex = 0;
          }

          if (this.getCurrentIndex() === 0) {
            pageIndex = this.__pages.length - 1;
          }

          this._setTransitionDuration(0);

          this.setCurrentIndex(pageIndex);
          setTimeout(function () {
            this._setTransitionDuration(this.getTransitionDuration());

            this._setScrollersOpacity(1);
          }.bind(this), 0);
        }
      },

      /**
       * Factory method for a paginationLabel.
       * @return {qx.ui.mobile.container.Composite} the created pagination label.
       */
      _createPaginationLabel: function _createPaginationLabel() {
        var paginationIndex = this.__pages.length;
        var paginationLabel = new qx.ui.mobile.container.Composite();
        var paginationLabelText = new qx.ui.mobile.basic.Label("" + paginationIndex);
        paginationLabel.add(paginationLabelText);
        paginationLabel.addCssClass("carousel-pagination-label");
        paginationLabel.addListener("tap", this._onPaginationLabelTap, {
          self: this,
          targetIndex: paginationIndex - 1
        });
        return paginationLabel;
      },

      /**
       * Changes the opacity of the carouselScroller element.
       * @param opacity {Integer} the target value of the opacity.
       */
      _setScrollersOpacity: function _setScrollersOpacity(opacity) {
        if (this.__carouselScroller) {
          qx.bom.element.Style.set(this.__carouselScroller.getContainerElement(), "opacity", opacity);
        }
      },

      /**
       * Called when showPagination property is changed.
       * Manages <code>show()</code> and <code>hide()</code> of pagination container.
       */
      _applyShowPagination: function _applyShowPagination(value, old) {
        if (value) {
          if (this.__pages.length > 1) {
            this.__pagination.show();
          }
        } else {
          this.__pagination.hide();
        }
      },

      /**
       * Handles a tap on paginationLabel.
       */
      _onPaginationLabelTap: function _onPaginationLabelTap() {
        this.self.setCurrentIndex(this.targetIndex);
      },

      /**
       * Updates the layout of the carousel the carousel scroller and its pages.
       */
      _updateCarouselLayout: function _updateCarouselLayout() {
        if (!this.getContainerElement()) {
          return;
        }

        var carouselSize = qx.bom.element.Dimension.getSize(this.getContainerElement());
        this.__carouselWidth = carouselSize.width;

        if (this.getHeight() !== null) {
          this._setStyle("height", this.getHeight() / 16 + "rem");
        } else {
          this._setStyle("height", "100%");
        }

        qx.bom.element.Style.set(this.__carouselScroller.getContentElement(), "width", this.__pages.length * carouselSize.width + "px");

        for (var i = 0; i < this.__pages.length; i++) {
          var pageContentElement = this.__pages[i].getContentElement();

          qx.bom.element.Style.set(pageContentElement, "width", carouselSize.width + "px");
          qx.bom.element.Style.set(pageContentElement, "height", carouselSize.height + "px");
        }

        if (this.__pages.length == 1) {
          this.__pagination.exclude();
        } else {
          if (this.isShowPagination()) {
            this.__pagination.show();
          }
        }

        this._refreshScrollerPosition();
      },

      /**
       * Synchronizes the positions of the scroller to the current shown page index.
       */
      _refreshScrollerPosition: function _refreshScrollerPosition() {
        this.__carouselScrollerWidth = qx.bom.element.Dimension.getWidth(this.__carouselScroller.getContentElement());

        this._scrollToPage(this.getCurrentIndex());
      },

      /**
       * Handles window resize, device orientatonChange or page appear events.
       */
      _onContainerUpdate: function _onContainerUpdate() {
        this._setTransitionDuration(0);

        this._updateCarouselLayout();

        this._refreshScrollerPosition();
      },

      /**
       * Returns the current horizontal position of the carousel scrolling container.
       * @return {Number} the horizontal position
       */
      _getScrollerOffset: function _getScrollerOffset() {
        var transformMatrix = qx.bom.element.Style.get(this.__carouselScroller.getContentElement(), "transform");
        var transformValueArray = transformMatrix.substr(7, transformMatrix.length - 8).split(', ');
        var i = 4; // Check if MSCSSMatrix is used.

        if ('MSCSSMatrix' in window && !('WebKitCSSMatrix' in window)) {
          i = transformValueArray.length - 4;
        }

        return Math.floor(parseInt(transformValueArray[i], 10));
      },

      /**
       * Event handler for <code>pointerdown</code> events.
       * @param evt {qx.event.type.Pointer} The pointer event.
       */
      _onPointerDown: function _onPointerDown(evt) {
        if (!evt.isPrimary()) {
          return;
        }

        this.__lastOffset[0] = this._getScrollerOffset();
        this.__isPageScrollTarget = null;
        this.__boundsX[0] = -this.__carouselScrollerWidth + this.__carouselWidth;

        this._updateScrollerPosition(this.__lastOffset[0]);
      },

      /**
       * Event handler for <code>track</code> events.
       * @param evt {qx.event.type.Track} The track event.
       */
      _onTrack: function _onTrack(evt) {
        if (!evt.isPrimary()) {
          return;
        }

        this._setTransitionDuration(0);

        this.__deltaX = evt.getDelta().x;
        this.__deltaY = evt.getDelta().y;

        if (this.__isPageScrollTarget === null) {
          this.__isPageScrollTarget = evt.getDelta().axis == "y";
        }

        if (!this.__isPageScrollTarget) {
          this.__onMoveOffset[0] = Math.floor(this.__deltaX + this.__lastOffset[0]);

          if (this.__onMoveOffset[0] >= this.__boundsX[1]) {
            this.__onMoveOffset[0] = this.__boundsX[1];
          }

          if (this.__onMoveOffset[0] <= this.__boundsX[0]) {
            this.__onMoveOffset[0] = this.__boundsX[0];
          }

          this._updateScrollerPosition(this.__onMoveOffset[0]);

          evt.preventDefault();
        }
      },

      /**
      * Handler for <code>pointerup</code> event on carousel scroller.
      * @param evt {qx.event.type.Pointer} the pointerup event.
      */
      _onPointerUp: function _onPointerUp(evt) {
        if (!evt.isPrimary()) {
          return;
        }

        this._setTransitionDuration(this.getTransitionDuration());

        this._refreshScrollerPosition();
      },

      /**
       * Handler for swipe event on carousel scroller.
       * @param evt {qx.event.type.Swipe} The swipe event.
       */
      _onSwipe: function _onSwipe(evt) {
        if (!evt.isPrimary()) {
          return;
        }

        if (evt.getDuration() < 750 && Math.abs(evt.getDistance()) > 50) {
          var duration = this._calculateTransitionDuration(this.__deltaX, evt.getDuration());

          duration = Math.min(this.getTransitionDuration(), duration);

          this._setTransitionDuration(duration);

          if (evt.getDirection() == "left") {
            this.nextPage();
          } else if (evt.getDirection() == "right") {
            this.previousPage();
          }
        } else {
          this._snapCarouselPage();
        }
      },

      /**
      * Calculates the duration the transition will need till the next carousel
      * snap point is reached.
      * @param deltaX {Integer} the distance on axis between pointerdown and pointerup.
      * @param duration {Number} the swipe duration.
      * @return {Number} the transition duration.
      */
      _calculateTransitionDuration: function _calculateTransitionDuration(deltaX, duration) {
        var distanceX = this.__carouselWidth - Math.abs(deltaX);
        var transitionDuration = distanceX / Math.abs(deltaX) * duration;
        return transitionDuration / 1000;
      },

      /**
       * Handles the native scroll event on the carousel container.
       * This is needed for preventing "scrollIntoView" method.
       *
       * @param evt {qx.event.type.Native} the native scroll event.
       */
      _onNativeScroll: function _onNativeScroll(evt) {
        var nativeEvent = evt.getNativeEvent();
        nativeEvent.srcElement.scrollLeft = 0;
        nativeEvent.srcElement.scrollTop = 0;
      },

      /**
      * Applies the CSS property "transitionDuration" to the carouselScroller.
      * @param value {Number} the target value of the transitionDuration.
      */
      _setTransitionDuration: function _setTransitionDuration(value) {
        qx.bom.element.Style.set(this.__carouselScroller.getContentElement(), "transitionDuration", value + "s");
      },

      /**
       * Snaps carouselScroller offset to a carouselPage.
       * It determines which carouselPage is the nearest and moves
       * carouselScrollers offset till nearest carouselPage's left border is aligned to carousel's left border.
       */
      _snapCarouselPage: function _snapCarouselPage() {
        this._setTransitionDuration(this.getTransitionDuration());

        var leastDistance = 10000;
        var nearestPageIndex = 0; // Determine nearest snapPoint.

        for (var i = 0; i < this.__pages.length; i++) {
          var snapPoint = -i * this.__carouselWidth;
          var distance = this.__onMoveOffset[0] - snapPoint;

          if (Math.abs(distance) < leastDistance) {
            leastDistance = Math.abs(distance);
            nearestPageIndex = i;
          }
        }

        if (this.getCurrentIndex() == nearestPageIndex) {
          this._refreshScrollerPosition();
        } else {
          this.setCurrentIndex(nearestPageIndex);
        }
      },

      /**
       * Updates the pagination indicator of this carousel.
       * Removes the active state from from paginationLabel with oldActiveIndex,
       * Adds actives state to paginationLabel new ActiveIndex.
       * @param newActiveIndex {Integer} Index of paginationLabel which should have active state
       */
      _updatePagination: function _updatePagination(newActiveIndex) {
        for (var i = 0; i < this.__paginationLabels.length; i++) {
          this.__paginationLabels[i].removeCssClass("active");
        }

        var newActiveLabel = this.__paginationLabels[newActiveIndex];

        if (newActiveLabel && newActiveLabel.getContainerElement()) {
          newActiveLabel.addCssClass("active");
        }

        if (this.__paginationLabels.length) {
          var paginationStyle = window.getComputedStyle(this.__pagination.getContentElement());
          var paginationWidth = parseFloat(paginationStyle.width, 10);

          if (isNaN(paginationWidth)) {
            return;
          }

          var paginationLabelWidth = paginationWidth / this.__paginationLabels.length;
          var left = null;
          var translate = this.__carouselWidth / 2 - newActiveIndex * paginationLabelWidth - paginationLabelWidth / 2;

          if (paginationWidth < this.__carouselWidth) {
            left = this.__carouselWidth / 2 - paginationWidth / 2 + "px";
            translate = 0;
          }

          qx.bom.element.Style.set(this.__pagination.getContentElement(), "left", left);

          this.__pagination.setTranslateX(translate);
        }
      },

      /**
       * Assign new position of carousel scrolling container.
       * @param x {Integer} scroller's x position.
       */
      _updateScrollerPosition: function _updateScrollerPosition(x) {
        if (isNaN(x) || this.__carouselScroller.getContentElement() === null) {
          return;
        }

        this.__carouselScroller.setTranslateX(x);
      },

      /**
       * Remove all listeners.
       */
      _removeListeners: function _removeListeners() {
        this.__carouselScroller.removeListener("pointerdown", this._onPointerDown, this);

        this.__carouselScroller.removeListener("track", this._onTrack, this);

        this.__carouselScroller.removeListener("pointerup", this._onPointerUp, this);

        this.__carouselScroller.removeListener("swipe", this._onSwipe, this);

        this.__carouselScroller.removeListener("touchmove", qx.bom.Event.preventDefault, this);

        this.removeListener("appear", this._onContainerUpdate, this);
        qx.event.Registration.removeListener(window, "orientationchange", this._onContainerUpdate, this);
        qx.event.Registration.removeListener(window, "resize", this._onContainerUpdate, this);
        qx.event.Registration.removeListener(this.getContentElement(), "scroll", this._onNativeScroll, this);
      }
    },
    destruct: function destruct() {
      this._removeListeners();

      this._disposeObjects("__carouselScroller", " __pagination");

      qx.util.DisposeUtil.destroyContainer(this);
      qx.util.DisposeUtil.disposeArray(this, "__paginationLabels");
      this.__pages = this.__paginationLabels = this.__snapPointsX = this.__onMoveOffset = this.__lastOffset = this.__boundsX = this.__isPageScrollTarget = null;
    }
  });
  qx.ui.mobile.container.Carousel.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.container.Composite", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testAdd: function testAdd() {
        var composite = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);

        this._assertChildren(composite, 2);

        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      testAddSame: function testAddSame() {
        var composite = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        {
          this.assertException(function () {
            composite.add(widget1);
          });
        }

        this._assertChildren(composite, 1);

        widget1.destroy();
        composite.destroy();
      },
      testAddOther: function testAddOther() {
        var composite1 = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite1);
        var composite2 = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite2);
        var widget = new qx.ui.mobile.core.Widget();
        composite1.add(widget);

        this._assertChildren(composite1, 1);

        composite2.add(widget);

        this._assertChildren(composite1, 0);

        this.assertFalse(composite1.getContainerElement().hasChildNodes());

        this._assertChildren(composite2, 1);

        this.assertEquals(composite2.getContainerElement(), widget.getContainerElement().parentNode);
        widget.destroy();
        composite1.destroy();
        composite2.destroy();
      },
      testAddAt: function testAddAt() {
        var composite = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);
        var widget3 = new qx.ui.mobile.core.Widget();
        composite.addAt(widget3, 1);
        this.assertEquals(composite.indexOf(widget3), 1);
        this.assertEquals(composite.getContentElement().childNodes[1], widget3.getContainerElement());
        widget1.destroy();
        widget2.destroy();
        widget3.destroy();
        composite.destroy();
      },
      testAddBefore: function testAddBefore() {
        var composite = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);
        {
          this.assertException(function () {
            composite.addBefore(widget2, widget3);
          });
        }
        var widget3 = new qx.ui.mobile.core.Widget();
        composite.addBefore(widget3, widget2);
        this.assertEquals(composite.indexOf(widget3), 1);
        this.assertEquals(composite.getContentElement().childNodes[1], widget3.getContainerElement());
        widget1.destroy();
        widget2.destroy();
        widget3.destroy();
        composite.destroy();
      },
      testAddAfter: function testAddAfter() {
        var composite = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);
        {
          this.assertException(function () {
            composite.addAfter(widget2, widget3);
          });
        }
        var widget3 = new qx.ui.mobile.core.Widget();
        composite.addAfter(widget3, widget2);
        this.assertEquals(composite.indexOf(widget3), 2);
        this.assertEquals(composite.getContentElement().childNodes[2], widget3.getContainerElement());
        composite.remove(widget3);
        composite.addAfter(widget3, widget1);
        this.assertEquals(composite.getContentElement().childNodes[1], widget3.getContainerElement());
        widget1.destroy();
        widget2.destroy();
        widget3.destroy();
        composite.destroy();
      },
      testDestroy: function testDestroy() {
        var composite = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);

        this._assertChildren(composite, 2);

        widget1.destroy();
        widget2.destroy();

        this._assertChildren(composite, 0);

        composite.destroy();
      },
      testRemove: function testRemove() {
        var composite = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);

        this._assertChildren(composite, 2);

        composite.remove(widget1);

        this._assertChildren(composite, 1);

        composite.remove(widget2);

        this._assertChildren(composite, 0);

        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      testRemoveAt: function testRemoveAt() {
        var composite = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite);
        this.assertException(function () {
          composite.removeAt(1);
        });
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);
        var widget3 = new qx.ui.mobile.core.Widget();
        composite.add(widget3);

        this._assertChildren(composite, 3);

        composite.removeAt(1);

        this._assertChildren(composite, 2);

        this.assertEquals(widget1, composite.getChildren()[0]);
        this.assertEquals(widget3, composite.getChildren()[1]);
        widget1.destroy();
        widget2.destroy();
        widget3.destroy();
        composite.destroy();
      },
      testRemoveAll: function testRemoveAll() {
        var composite = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);

        this._assertChildren(composite, 2);

        composite.removeAll();

        this._assertChildren(composite, 0);

        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      testHasChildren: function testHasChildren() {
        var composite = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite);
        this.assertFalse(composite.hasChildren());
        var widget = new qx.ui.mobile.core.Widget();
        composite.add(widget);
        this.assertTrue(composite.hasChildren());
        widget.destroy();
        this.assertFalse(composite.hasChildren());
        composite.destroy();
      },
      testIndexOf: function testIndexOf() {
        var composite = new qx.ui.mobile.container.Composite();
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);
        this.assertNumber(composite.indexOf(widget1));
        this.assertEquals(composite.indexOf(widget1), 0);
        this.assertNumber(composite.indexOf(widget2));
        this.assertEquals(composite.indexOf(widget2), 1);
        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      _assertChildren: function _assertChildren(composite, number) {
        var children = composite.getChildren();
        this.assertNotNull(children);
        var length = children.length;
        this.assertEquals(length, number);
        length = composite.getContainerElement().childNodes.length;
        this.assertEquals(length, number);
      }
    }
  });
  qx.test.mobile.container.Composite.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.container.Drawer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.container.Drawer", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testInitComposite: function testInitComposite() {
        var parentContainer = new qx.ui.mobile.container.Composite();
        var drawer = new qx.ui.mobile.container.Drawer(parentContainer);
        var drawerCandidate = parentContainer.getChildren()[0];
        this.assertEquals(drawer, drawerCandidate, "Unexpected children of composite.");
        drawer.destroy();
      },
      testInitRoot: function testInitRoot() {
        var drawer = new qx.ui.mobile.container.Drawer();
        var drawerCandidate = this.getRoot().getChildren()[this.getRoot().getChildren().length - 1];
        this.assertEquals(drawer, drawerCandidate, "Unexpected children of root.");
        drawer.destroy();
      },
      testShowHide: function testShowHide() {
        var drawer = new qx.ui.mobile.container.Drawer();
        drawer.setTransitionDuration(0); // Initial hidden.

        this.assertTrue(drawer.isHidden(), "Drawer is asserted to be initially hidden."); // Show.

        drawer.show();
        this.assertFalse(drawer.isHidden(), "Drawer is asserted to be shown."); // Hide again.

        drawer.hide();
        this.assertTrue(drawer.isHidden(), "Drawer is asserted to be hidden.");
        drawer.destroy();
      },
      testToggleVisibility: function testToggleVisibility() {
        var drawer = new qx.ui.mobile.container.Drawer();
        drawer.setTransitionDuration(0); // Initial hidden.

        this.assertTrue(drawer.isHidden(), "Drawer is asserted to be initially hidden."); // Toggle visibility.

        var targetVisibility = drawer.toggleVisibility();
        this.assertTrue(targetVisibility, "Drawer's targetVisibility is asserted to be true.");
        this.assertFalse(drawer.isHidden(), "Drawer is asserted to be shown."); // Toggle visibility again.

        targetVisibility = drawer.toggleVisibility();
        this.assertFalse(targetVisibility, "Drawer's targetVisibility is asserted to be false.");
        this.assertTrue(drawer.isHidden(), "Drawer is asserted to be hidden.");
        drawer.destroy();
      }
    }
  });
  qx.test.mobile.container.Drawer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.bom.Element": {},
      "qx.bom.element.Style": {},
      "qx.bom.element.Location": {},
      "qx.util.DisposeUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Creates a drawer widget inside the given parent widget. The parent widget can
   * be assigned as a constructor argument. If no parent is set, the application's
   * root will be assumed as parent. A drawer widget can be assigned to left, right,
   * top or bottom edge of its parent by property <code>orientation</code>. The drawer floats
   * in on <code>show()</code> and floats out on <code>hide()</code>. Additionally the drawer is shown by
   * swiping in reverse direction on the parent edge to where the drawer is placed
   * to: Orientation: <code>left</code>, Swipe: <code>right</code> on parents edge: Drawer is shown etc.
   * The drawer is hidden when user taps the parent area outside of the drawer.
   * This behaviour can be deactivated by the property <code>hideOnParentTap</code>.
   *
   * <pre class='javascript'>
   *
   *  var drawer = new qx.ui.mobile.container.Drawer();
   *  drawer.setOrientation("right");
   *  drawer.setTapOffset(100);
   *
   *  var button = new qx.ui.mobile.form.Button("A Button");
   *  drawer.add(button);
   * </pre>
   *
   *
   */
  qx.Class.define("qx.ui.mobile.container.Drawer", {
    extend: qx.ui.mobile.container.Composite,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param parent {qx.ui.mobile.container.Composite?null} The widget to which
     * the drawer should be added, if null it is added to app root.
     * @param layout {qx.ui.mobile.layout.Abstract?null} The layout that should be
     * used for this container.
     */
    construct: function construct(parent, layout) {
      qx.ui.mobile.container.Composite.constructor.call(this);

      if (layout) {
        this.setLayout(layout);
      }

      this.initOrientation();
      this.initPositionZ();

      if (parent) {
        {
          this.assertInstance(parent, qx.ui.mobile.container.Composite);
        }
        parent.add(this);
      } else {
        qx.core.Init.getApplication().getRoot().add(this);
      }

      qx.core.Init.getApplication().addListener("back", this._onBack, this);
      this.__parent = this.getLayoutParent();

      this.__parent.addCssClass("drawer-parent");

      this.__parent.addListener("swipe", this._onParentSwipe, this);

      this.__parent.addListener("pointerdown", this._onParentPointerDown, this);

      this.__pointerStartPosition = [0, 0];
      this.forceHide();
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the drawer changes its size.
       */
      resize: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "drawer"
      },

      /** Property for setting the orientation of the drawer.
       * Allowed values are: <code>left</code>,<code>right</code>,<code>top</code>,<code>bottom</code> */
      orientation: {
        check: "String",
        init: "left",
        apply: "_applyOrientation"
      },

      /** The size of the drawer in <code>px</code>. This value is interpreted as width if
      * orientation is <code>left | right</code>, as height if orientation is
      * <code>top | bottom</code>. */
      size: {
        check: "Integer",
        init: 300,
        apply: "_applySize",
        event: "resize"
      },

      /** Indicates whether the drawer should hide when the parent area of it is tapped.  */
      hideOnParentTap: {
        check: "Boolean",
        init: true
      },

      /**
       * Indicates whether the drawer should hide when a back action appear form a key event.
       */
      hideOnBack: {
        check: "Boolean",
        init: true
      },

      /** Sets the size of the tapping area, where the drawer reacts on swipes for opening itself. */
      tapOffset: {
        check: "Integer",
        init: 20
      },

      /** The duration time of the transition between shown/hidden state in ms. */
      transitionDuration: {
        check: "Integer",
        init: 500,
        apply: "_applyTransitionDuration"
      },

      /** Sets the drawer zIndex position relative to its parent. */
      positionZ: {
        check: ["above", "below"],
        init: "above",
        apply: "_applyPositionZ"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __pointerStartPosition: null,
      __parent: null,
      __transitionEnabled: null,
      __inTransition: null,
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        this.removeCssClass(old);
        this.addCssClass(value); // Reapply width of height size depending on orientation.

        this._applySize(this.getSize());
      },
      // property apply
      _applyPositionZ: function _applyPositionZ(value, old) {
        this.removeCssClass(old);
        this.addCssClass(value);

        if (this.__parent) {
          this.__parent.setTranslateX(0);

          this.__parent.setTranslateY(0);
        }
      },
      // property apply
      _applySize: function _applySize(value) {
        var height = null;
        var width = null;
        var remSize = value / 16;

        if (this.getOrientation() == "left" || this.getOrientation() == "right") {
          width = remSize + "rem";
        } else {
          height = remSize + "rem";
        }

        this._setStyle("height", height);

        this._setStyle("width", width);
      },
      // property apply
      _applyTransitionDuration: function _applyTransitionDuration(value, old) {
        this.__transitionEnabled = value > 0;
      },

      /**
       * Shows the drawer.
       */
      show: function show() {
        if (!this.isHidden() || this.__inTransition === true) {
          return;
        }

        this.__inTransition = true; // Make drawer visible before "changeVisibility" event is fired, after transition.

        this._setStyle("visibility", "visible");

        this.__parent.addCssClass("blocked");

        if (this.getPositionZ() == "below") {
          if (this.getOrientation() == "left") {
            this.__parent.setTranslateX(this.getSize());
          } else if (this.getOrientation() == "right") {
            this.__parent.setTranslateX(-this.getSize());
          } else if (this.getOrientation() == "top") {
            this.__parent.setTranslateY(this.getSize());
          } else if (this.getOrientation() == "bottom") {
            this.__parent.setTranslateY(-this.getSize());
          }
        }

        if (this.getTransitionDuration() > 0) {
          this._enableTransition();

          var callArguments = arguments;

          var transitionTarget = this._getTransitionTarget().getContentElement();

          var listenerId = qx.bom.Element.addListener(transitionTarget, "transitionEnd", function (evt) {
            qx.ui.mobile.container.Drawer.prototype.show.base.call(this);

            this._disableTransition();

            this.__inTransition = false;
            qx.bom.Element.removeListenerById(transitionTarget, listenerId);
          }, this);
          setTimeout(function () {
            this.removeCssClass("hidden");
          }.bind(this), 0);
        } else {
          qx.ui.mobile.container.Drawer.prototype.show.base.call(this);
          this.__inTransition = false;
          this.removeCssClass("hidden");
        }
      },

      /**
       * Hides the drawer.
       */
      hide: function hide() {
        if (this.isHidden() || this.__inTransition === true) {
          return;
        }

        this.__inTransition = true;

        if (this.getPositionZ() == "below") {
          this.__parent.setTranslateX(0);

          this.__parent.setTranslateY(0);
        }

        if (this.getTransitionDuration() > 0) {
          this._enableTransition();

          var callArguments = arguments;

          var transitionTarget = this._getTransitionTarget().getContentElement();

          var listenerId = qx.bom.Element.addListener(transitionTarget, "transitionEnd", function (evt) {
            qx.ui.mobile.container.Drawer.prototype.hide.base.call(this);

            this._disableTransition();

            this.__parent.removeCssClass("blocked");

            this.__inTransition = false;
            qx.bom.Element.removeListenerById(transitionTarget, listenerId);
          }, this);
          setTimeout(function () {
            this.addCssClass("hidden");
          }.bind(this), 0);
        } else {
          qx.ui.mobile.container.Drawer.prototype.hide.base.call(this);
          this.addCssClass("hidden");
          this.__inTransition = false;

          this.__parent.removeCssClass("blocked");
        }
      },

      /**
       * Strict way to hide this drawer. Removes the blocker from the parent,
       * and hides the drawer without any animation. Should be called when drawer's
       * parent is animated and drawer should hide immediately.
       */
      forceHide: function forceHide() {
        this._disableTransition();

        if (this.getPositionZ() == "below") {
          this.__parent.setTranslateX(0);

          this.__parent.setTranslateY(0);
        }

        this.__parent.removeCssClass("blocked");

        this.addCssClass("hidden");
      },
      // overridden
      isHidden: function isHidden() {
        return this.hasCssClass("hidden");
      },

      /**
       * Enables the transition on this drawer.
       */
      _enableTransition: function _enableTransition() {
        qx.bom.element.Style.set(this._getTransitionTarget().getContentElement(), "transition", "all " + this.getTransitionDuration() + "ms ease-in-out");
      },

      /**
        * Disables the transition on this drawer.
        */
      _disableTransition: function _disableTransition() {
        qx.bom.element.Style.set(this._getTransitionTarget().getContentElement(), "transition", null);
      },

      /**
      * Returns the target widget which is responsible for the transition handling.
      * @return {qx.ui.mobile.core.Widget} the transition target widget.
      */
      _getTransitionTarget: function _getTransitionTarget() {
        if (this.getPositionZ() == "below") {
          return this.__parent;
        } else {
          return this;
        }
      },

      /**
       * Toggle the visibility of the drawer.
       * @return {Boolean} the new visibility state.
       */
      toggleVisibility: function toggleVisibility() {
        if (this.isHidden()) {
          this.show();
          return true;
        } else {
          this.hide();
          return false;
        }
      },

      /**
       * Handles a back event which appears on the application.
       *
       * @param evt {qx.event.type.Data} The back event.
       */
      _onBack: function _onBack(evt) {
        var triggeredByKeyEvent = !!evt.getData();

        if (triggeredByKeyEvent && !this.isHidden() && this.getHideOnBack()) {
          evt.preventDefault();
          this.hide();
        }
      },

      /**
       * Handles a tap on drawers' root.
       * @param evt {qx.module.event.Pointer} Handled pointer event.
       */
      _onParentPointerDown: function _onParentPointerDown(evt) {
        this.__pointerStartPosition = [evt.getViewportLeft(), evt.getViewportTop()];
        var isShown = !this.hasCssClass("hidden");

        if (isShown && this.isHideOnParentTap()) {
          var location = qx.bom.element.Location.get(this.getContainerElement());
          var orientation = this.getOrientation();

          if (orientation == "left" && this.__pointerStartPosition[0] > location.right || orientation == "top" && this.__pointerStartPosition[1] > location.bottom || orientation == "bottom" && this.__pointerStartPosition[1] < location.top || orientation == "right" && this.__pointerStartPosition[0] < location.left) {
            // First event on overlayed page should be ignored.
            evt.preventDefault();
            this.hide();
          }
        }
      },

      /**
       * Handles a swipe on layout parent.
       * @param evt {qx.module.event.Pointer} Handled pointer event.
       */
      _onParentSwipe: function _onParentSwipe(evt) {
        var direction = evt.getDirection();
        var isHidden = this.hasCssClass("hidden");

        if (isHidden) {
          var location = qx.bom.element.Location.get(this.getContainerElement());

          if (direction == "right" && this.getOrientation() == "left" && this.__pointerStartPosition[0] < location.right + this.getTapOffset() && this.__pointerStartPosition[0] > location.right || direction == "left" && this.getOrientation() == "right" && this.__pointerStartPosition[0] > location.left - this.getTapOffset() && this.__pointerStartPosition[0] < location.left || direction == "down" && this.getOrientation() == "top" && this.__pointerStartPosition[1] < this.getTapOffset() + location.bottom && this.__pointerStartPosition[1] > location.bottom || direction == "up" && this.getOrientation() == "bottom" && this.__pointerStartPosition[1] > location.top - this.getTapOffset() && this.__pointerStartPosition[1] < location.top) {
            this.show();
          }
        }
      }
    },
    destruct: function destruct() {
      qx.core.Init.getApplication().removeListener("back", this._onBack, this);

      this.__parent.removeListener("swipe", this._onParentSwipe, this);

      this.__parent.removeListener("pointerdown", this._onParentPointerDown, this);

      qx.util.DisposeUtil.destroyContainer(this);
      this.__pointerStartPosition = this.__parent = this.__transitionEnabled = null;
    }
  });
  qx.ui.mobile.container.Drawer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.container.Navigation": {},
      "qx.ui.mobile.page.NavigationPage": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.container.Navigation", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testCreate: function testCreate() {
        var container = new qx.ui.mobile.container.Navigation();
        this.getRoot().add(container);
        container.destroy();
      },
      testAdd: function testAdd() {
        var container = new qx.ui.mobile.container.Navigation();
        var page = new qx.ui.mobile.page.NavigationPage();
        this.getRoot().add(container);
        this.assertFalse(container.getContent().hasChildren());
        container.add(page);
        this.assertTrue(container.getContent().hasChildren());
        page.destroy();
        container.destroy();
      },
      testRemove: function testRemove() {
        var container = new qx.ui.mobile.container.Navigation();
        var page = new qx.ui.mobile.page.NavigationPage();
        this.getRoot().add(container);
        this.assertFalse(container.getContent().hasChildren());
        container.add(page);
        this.assertTrue(container.getContent().hasChildren());
        container.remove(page);
        this.assertFalse(container.getContent().hasChildren());
        page.destroy();
        container.destroy();
      },
      testUpdateEvent: function testUpdateEvent() {
        var container = new qx.ui.mobile.container.Navigation();
        var updateEventFired = false;
        container.addListener("update", function () {
          updateEventFired = true;
        }, this);
        var page1 = new qx.ui.mobile.page.NavigationPage();
        var page2 = new qx.ui.mobile.page.NavigationPage();
        this.getRoot().add(container);
        container.add(page1);
        container.add(page2);
        page2.show();
        this.assertTrue(updateEventFired);
        page1.destroy();
        page2.destroy();
        container.destroy();
      }
    }
  });
  qx.test.mobile.container.Navigation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.VBox": {
        "construct": true
      },
      "qx.ui.mobile.container.INavigation": {},
      "qx.ui.mobile.layout.Card": {},
      "qx.ui.mobile.navigationbar.NavigationBar": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The navigation controller includes already a {@link qx.ui.mobile.navigationbar.NavigationBar}
   * and a {@link qx.ui.mobile.container.Composite} container with a {@link qx.ui.mobile.layout.Card} layout.
   * All widgets that implement the {@link qx.ui.mobile.container.INavigation}
   * interface can be added to the container. The added widget provide the title
   * widget and the left/right container, which will be automatically merged into
   * navigation bar.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var container = new qx.ui.mobile.container.Navigation();
   *   this.getRoot(container);
   *   var page = new qx.ui.mobile.page.NavigationPage();
   *   container.add(page);
   *   page.show();
   * </pre>
   */
  qx.Class.define("qx.ui.mobile.container.Navigation", {
    extend: qx.ui.mobile.container.Composite,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.mobile.container.Composite.constructor.call(this, new qx.ui.mobile.layout.VBox());
      this.__navigationBar = this._createNavigationBar();

      if (this.__navigationBar) {
        this._add(this.__navigationBar);
      }

      this.__content = this._createContent();

      this._add(this.__content, {
        flex: 1
      });
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "navigation"
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the navigation bar gets updated */
      "update": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __navigationBar: null,
      __content: null,
      __layout: null,
      // overridden
      add: function add(widget) {
        {
          this.assertInterface(widget, qx.ui.mobile.container.INavigation);
        }
        this.getContent().add(widget);
      },
      // overridden
      remove: function remove(widget) {
        {
          this.assertInterface(widget, qx.ui.mobile.container.INavigation);
        }
        this.getContent().remove(widget);
      },

      /**
       * Returns the content container. Add all your widgets to this container.
       *
       * @return {qx.ui.mobile.container.Composite} The content container
       */
      getContent: function getContent() {
        return this.__content;
      },

      /**
       * Returns the assigned card layout.
       * @return {qx.ui.mobile.layout.Card} assigned Card Layout.
       */
      getLayout: function getLayout() {
        return this.__layout;
      },

      /**
       * Returns the navigation bar.
       *
       * @return {qx.ui.mobile.navigationbar.NavigationBar} The navigation bar.
       */
      getNavigationBar: function getNavigationBar() {
        return this.__navigationBar;
      },

      /**
       * Creates the content container.
       *
       * @return {qx.ui.mobile.container.Composite} The created content container
       */
      _createContent: function _createContent() {
        this.__layout = new qx.ui.mobile.layout.Card();

        this.__layout.addListener("updateLayout", this._onUpdateLayout, this);

        this.__layout.addListener("animationStart", this._onAnimationStart, this);

        this.__layout.addListener("animationEnd", this._onAnimationEnd, this);

        return new qx.ui.mobile.container.Composite(this.__layout);
      },

      /**
      * Handler for the "animationStart" event on the layout.
      */
      _onAnimationStart: function _onAnimationStart() {
        this.addCssClass("blocked");
      },

      /**
      * Handler for the "animationEnd" event on the layout.
      */
      _onAnimationEnd: function _onAnimationEnd() {
        this.removeCssClass("blocked");
      },

      /**
       * Event handler. Called when the "updateLayout" event occurs.
       *
       * @param evt {qx.event.type.Data} The causing event
       */
      _onUpdateLayout: function _onUpdateLayout(evt) {
        var data = evt.getData();
        var widget = data.widget;
        var action = data.action;

        if (action == "visible") {
          this._update(widget);
        }
      },

      /**
       * Updates the navigation bar depending on the set widget.
       *
       * @param widget {qx.ui.mobile.core.Widget} The widget that should be merged into the navigation bar.
       */
      _update: function _update(widget) {
        var navigationBar = this.getNavigationBar();

        this._setStyle("transitionDuration", widget.getNavigationBarToggleDuration() + "s");

        if (widget.isNavigationBarHidden()) {
          this.addCssClass("hidden");
        } else {
          navigationBar.show();
          this.removeCssClass("hidden");
        }

        navigationBar.removeAll();

        if (widget.basename) {
          this._setAttribute("data-target-page", widget.basename.toLowerCase());
        }

        var leftContainer = widget.getLeftContainer();

        if (leftContainer) {
          navigationBar.add(leftContainer);
        }

        var title = widget.getTitleWidget();

        if (title) {
          navigationBar.add(title, {
            flex: 1
          });
        }

        var rightContainer = widget.getRightContainer();

        if (rightContainer) {
          navigationBar.add(rightContainer);
        }

        this.fireDataEvent("update", widget);
      },

      /**
       * Creates the navigation bar.
       *
       * @return {qx.ui.mobile.navigationbar.NavigationBar} The created navigation bar
       */
      _createNavigationBar: function _createNavigationBar() {
        return new qx.ui.mobile.navigationbar.NavigationBar();
      }
    },
    destruct: function destruct() {
      this.getLayout().removeListener("animationStart", this._onAnimationStart, this);
      this.getLayout().removeListener("animationEnd", this._onAnimationEnd, this);

      this._disposeObjects("__navigationBar", "__content", "__layout");

      this.__navigationBar = this.__content = this.__layout = null;
    }
  });
  qx.ui.mobile.container.Navigation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.core.MResize": {
        "require": true
      },
      "qx.ui.mobile.layout.VBox": {
        "construct": true
      },
      "qx.bom.Event": {
        "defer": "runtime"
      },
      "qx.bom.client.PhoneGap": {
        "defer": "runtime"
      },
      "qx.bom.client.OperatingSystem": {
        "defer": "runtime"
      },
      "qx.core.Init": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "phonegap": {
          "className": "qx.bom.client.PhoneGap",
          "defer": true
        },
        "os.name": {
          "className": "qx.bom.client.OperatingSystem",
          "defer": true
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A page is a widget which provides a screen with which users
   * can interact in order to do something. Most times a page provides a single task
   * or a group of related tasks.
   *
   * A qooxdoo mobile application is usually composed of one or more loosely bound
   * pages. Typically there is one page that presents the "main" view.
   *
   * Pages can have one or more child widgets from the {@link qx.ui.mobile}
   * namespace. Normally a page provides a {@link qx.ui.mobile.navigationbar.NavigationBar}
   * for the navigation between pages.
   *
   * To navigate between two pages, just call the {@link #show} method of the page
   * that should be shown. Depending on the used page manager a page transition will be animated.
   * There are several animations available. Have
   * a look at the {@link qx.ui.mobile.page.Manager} manager or {@link qx.ui.mobile.layout.Card} card layout for more information.
   *
   * A page has predefined lifecycle methods that get called by the used page manager
   * when a page gets shown. Each time another page is requested to be shown the currently shown page
   * is stopped. The other page, will be, if shown for the first time, initialized and started
   * afterwards. For all called lifecycle methods an event is fired.
   *
   * Call of the {@link #show} method triggers the following lifecycle methods:
   *
   * * <strong>initialize</strong>: Initializes the page to show
   * * <strong>start</strong>: Gets called when the page to show is started
   * * <strong>stop</strong>:  Stops the current page
   *
   * IMPORTANT: Define all child widgets of a page when the {@link #initialize} lifecycle
   * method is called, either by listening to the {@link #initialize} event or overriding
   * the {@link #_initialize} method. This is because a page can be instanced during
   * application startup and would then decrease performance when the widgets would be
   * added during constructor call. The <code>initialize</code> event and the
   * {@link #_initialize} lifecycle method are only called when the page is shown
   * for the first time.
   *
   */
  qx.Class.define("qx.ui.mobile.page.Page", {
    extend: qx.ui.mobile.container.Composite,
    include: qx.ui.mobile.core.MResize,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout || new qx.ui.mobile.layout.VBox());
    },

    /*
     *****************************************************************************
        STATICS
     *****************************************************************************
     */
    statics: {
      _currentPage: null,

      /**
       * Event handler. Called when the device is ready.
       */
      _onDeviceReady: function _onDeviceReady() {
        qx.bom.Event.addNativeListener(document, "backbutton", qx.ui.mobile.page.Page._onBackButton);
        qx.bom.Event.addNativeListener(document, "menubutton", qx.ui.mobile.page.Page._onMenuButton);
      },

      /**
       * Event handler. Called when the back button of the device was pressed.
       */
      _onBackButton: function _onBackButton() {
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("os.name") == "android") {
          var exit = true;

          if (qx.ui.mobile.page.Page._currentPage) {
            exit = qx.ui.mobile.page.Page._currentPage.back(true);
          }

          if (exit) {
            navigator.app.exitApp();
          }
        }
      },

      /**
       * Event handler. Called when the menu button of the device was pressed.
       */
      _onMenuButton: function _onMenuButton() {
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("os.name") == "android") {
          if (qx.ui.mobile.page.Page._currentPage) {
            qx.ui.mobile.page.Page._currentPage.menu();
          }
        }
      }
    },
    events: {
      /** Fired when the lifecycle method {@link #initialize} is called */
      "initialize": "qx.event.type.Event",

      /** Fired when the lifecycle method {@link #start} is called */
      "start": "qx.event.type.Event",

      /** Fired when the lifecycle method {@link #stop} is called */
      "stop": "qx.event.type.Event",

      /** Fired when the lifecycle method {@link #pause} is called */
      "pause": "qx.event.type.Event",

      /** Fired when the lifecycle method {@link #resume} is called */
      "resume": "qx.event.type.Event",

      /**
       * Fired when the method {@link #back} is called and not prevented by
       * {@link qx.application.Mobile#back}. Data indicating whether
       * the action was triggered by a key event or not.
       */
      "back": "qx.event.type.Data",

      /** Fired when the method {@link #menu} is called */
      "menu": "qx.event.type.Event",

      /** Fired when the method {@link #wait} is called */
      "wait": "qx.event.type.Event"
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "page"
      },

      /**
       * The current active life cycle state of this page.
       */
      lifeCycleState: {
        init: null,
        check: ["initialize", "start", "stop", "resume", "wait", "pause"],
        apply: "_applyLifeCycleState"
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      __initialized: false,
      // overridden
      show: function show(properties) {
        if (qx.ui.mobile.page.Page._currentPage) {
          qx.ui.mobile.page.Page._currentPage.stop();
        }

        qx.ui.mobile.page.Page._currentPage = this;
        this.initialize();
        this.start();
        qx.ui.mobile.page.Page.prototype.show.base.call(this, properties);
      },
      // overridden
      exclude: function exclude(properties) {
        this.stop();
        qx.ui.mobile.page.Page.prototype.exclude.base.call(this, properties);
      },

      /**
       * Fires the <code>back</code> event. Call this method if you want to request
       * a back action. For Android PhoneGap applications this method gets called
       * by the used page manager when the back button was pressed. Return <code>true</code>
       * to exit the application.
       *
       * The back request can prevented by calling the {@link qx.event.type.Event#preventDefault} on
       * the {@link qx.application.Mobile#back} event.
       *
       * @param triggeredByKeyEvent {Boolean} Whether the back action was triggered by a key event.
       * @return {Boolean} Whether the exit should be exit or not. Return <code>true</code
       *     to exit the application. Only needed for Android PhoneGap applications.
       */
      back: function back(triggeredByKeyEvent) {
        if (qx.core.Init.getApplication().fireDataEvent("back", triggeredByKeyEvent, null, true)) {
          this.fireDataEvent("back", triggeredByKeyEvent);

          var value = this._back(triggeredByKeyEvent);

          return value || false;
        } else {
          return false;
        }
      },

      /**
       * Override this method if you want to perform a certain action when back
       * is called.
       *
       * @param triggeredByKeyEvent {Boolean} Whether the back action was triggered by a key event.
       * @return {Boolean} Whether the exit should be exit or not. Return <code>true</code
       *     to exit the application. Only needed for Android PhoneGap applications.
       * @see #back
       * @abstract
       */
      _back: function _back(triggeredByKeyEvent) {},

      /**
       * Only used by Android PhoneGap applications. Called by the used page manager
       * when the menu button was pressed. Fires the <code>menu</code> event.
       */
      menu: function menu() {
        this.fireEvent("menu");
      },

      /*
      ---------------------------------------------------------------------------
        Lifecycle Methods
      ---------------------------------------------------------------------------
      */

      /**
       * Lifecycle method. Called by the page manager when the page is shown.
       * Fires the <code>initialize</code> event. You should create and add all your
       * child widgets of the view,  either by listening to the {@link #initialize} event or overriding
       * the {@link #_initialize} method. This is because a page can be instanced during
       * application startup and would then decrease performance when the widgets would be
       * added during constructor call. The {@link #_initialize} lifecycle method and the
       * <code>initialize</code> are only called once when the page is shown for the first time.
       */
      initialize: function initialize() {
        if (!this.isInitialized()) {
          this._initialize();

          this.__initialized = true;
          this.setLifeCycleState("initialize");
        }
      },

      /**
       * Override this method if you would like to perform a certain action when initialize
       * is called.
       *
       * @see #initialize
       */
      _initialize: function _initialize() {},

      /**
       * Returns the status of the initialization of the page.
       *
       * @return {Boolean} Whether the page is already initialized or not
       */
      isInitialized: function isInitialized() {
        return this.__initialized;
      },

      /**
       * Lifecycle method. Called by the page manager after the {@link #initialize}
       * method when the page is shown. Fires the <code>start</code> event. You should
       * register all your event listener when this event occurs, so that no page
       * updates are done when page is not shown.
       */
      start: function start() {
        this._start();

        this.setLifeCycleState("start");
      },

      /**
       * Override this method if you would like to perform a certain action when start
       * is called.
       *
       * @see #start
       */
      _start: function _start() {},

      /**
       * Lifecycle method. Called by the page manager when another page is shown.
       * Fires the <code>stop</code> event. You should unregister all your event
       * listener when this event occurs, so that no page updates are down when page is not shown.
       */
      stop: function stop() {
        if (!this.isInitialized()) {
          return;
        }

        this._stop();

        this.setLifeCycleState("stop");
      },

      /**
       * Override this method if you would like to perform a certain action when stop
       * is called.
       *
       * @see #stop
       */
      _stop: function _stop() {},

      /**
       * Lifecycle method. Not used right now. Should be called when the current page
       * is interrupted, e.g. by a dialog, so that page view updates can be interrupted.
       * Fires the <code>pause</code> event.
       */
      pause: function pause() {
        this._pause();

        this.setLifeCycleState("pause");
      },

      /**
       * Override this method if you would like to perform a certain action when pause
       * is called.
       *
       * @see #pause
       */
      _pause: function _pause() {},

      /**
       * Lifecycle method. Not used right now. Should be called when the current page
       * is resuming from a interruption, e.g. when a dialog is closed, so that page
       * can resume updating the view.
       * Fires the <code>resume</code> event.
       */
      resume: function resume() {
        this._resume();

        this.setLifeCycleState("resume");
      },

      /**
       * Override this method if you would like to perform a certain action when resume
       * is called.
       *
       * @see #resume
       */
      _resume: function _resume() {},

      /**
       * Lifecycle method. Not used right now. Should be called when the current page
       * waits for data request etc.
       * Fires the <code>wait</code> event.
       */
      wait: function wait() {
        this._wait();

        this.setLifeCycleState("wait");
      },

      /**
       * Override this method if you would like to perform a certain action when wait
       * is called.
       *
       * @see #wait
       */
      _wait: function _wait() {},
      // property apply
      _applyLifeCycleState: function _applyLifeCycleState(value, old) {
        if (value == "start" || value == "stop") {
          qx.core.Init.getApplication().fireEvent(value);
        }

        this.fireEvent(value);
      }
    },

    /*
     *****************************************************************************
         DEFER
     *****************************************************************************
     */
    defer: function defer(statics) {
      if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("os.name") == "android") {
        qx.bom.Event.addNativeListener(document, "deviceready", statics._onDeviceReady);
      }
    }
  });
  qx.ui.mobile.page.Page.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * All widgets that are added to the navigation container should implement this interface.
   */
  qx.Interface.define("qx.ui.mobile.container.INavigation", {
    members: {
      /**
       * Returns the title widget that is merged into the navigation bar.
       *
       * @return {qx.ui.mobile.navigationbar.Title} The title of the navigation bar
       */
      getTitleWidget: function getTitleWidget() {},

      /**
       * Returns the left container that is merged into the navigation bar.
       *
       * @return {qx.ui.mobile.container.Composite} The left container of the navigation bar
       */
      getLeftContainer: function getLeftContainer() {},

      /**
       * Returns the right container that is merged into the navigation bar.
       *
       * @return {qx.ui.mobile.container.Composite} The right container of the navigation bar
       */
      getRightContainer: function getRightContainer() {}
    }
  });
  qx.ui.mobile.container.INavigation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.page.Page": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.container.INavigation": {
        "require": true
      },
      "qx.ui.mobile.navigationbar.Title": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.navigationbar.BackButton": {},
      "qx.ui.mobile.navigationbar.Button": {},
      "qx.ui.mobile.container.Scroll": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Specialized page. This page includes already a {@link qx.ui.mobile.navigationbar.NavigationBar}
   * and and a {@link qx.ui.mobile.container.Scroll} container.
   * The NavigationPage can only be used with a page manager {@link qx.ui.mobile.page.Manager}.
  
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *
   *  var manager = new qx.ui.mobile.page.Manager();
   *  var page = new qx.ui.mobile.page.NavigationPage();
   *  page.setTitle("Page Title");
   *  page.setShowBackButton(true);
   *  page.setBackButtonText("Back")
   *  page.addListener("initialize", function()
   *  {
   *    var button = new qx.ui.mobile.form.Button("Next Page");
   *    page.getContent().add(button);
   *  },this);
   *
   *  page.addListener("back", function()
   *  {
   *    otherPage.show({animation:"cube", reverse:true});
   *  },this);
   *
   *  manager.addDetail(page);
   *  page.show();
   * </pre>
   *
   * This example creates a NavigationPage with a title and a back button. In the
   * <code>initialize</code> lifecycle method a button is added.
   */
  qx.Class.define("qx.ui.mobile.page.NavigationPage", {
    extend: qx.ui.mobile.page.Page,
    implement: qx.ui.mobile.container.INavigation,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param wrapContentByGroup {Boolean} Defines whether a group box should wrap the content. This can be used for defining a page margin.
     * @param layout {qx.ui.mobile.layout.Abstract} The layout of this page.
     */
    construct: function construct(wrapContentByGroup, layout) {
      qx.ui.mobile.page.Page.constructor.call(this);

      if (wrapContentByGroup != null) {
        this._wrapContentByGroup = wrapContentByGroup;
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the user tapped on the navigation button */
      action: "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The title of the page */
      title: {
        check: "String",
        init: "",
        event: "changeTitle",
        apply: "_applyTitle"
      },

      /** The back button text */
      backButtonText: {
        check: "String",
        init: "",
        apply: "_applyBackButtonText"
      },

      /** The action button text */
      buttonText: {
        check: "String",
        init: "",
        apply: "_applyActionButtonText"
      },

      /** The action button icon */
      buttonIcon: {
        check: "String",
        init: null,
        nullable: true,
        apply: "_applyActionButtonIcon"
      },

      /**
       * Whether to show the back button.
       */
      showBackButton: {
        check: "Boolean",
        init: false,
        apply: "_applyShowBackButton"
      },

      /**
       * Indicates whether the back button should be shown on tablet.
       */
      showBackButtonOnTablet: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether to show the action button.
       */
      showButton: {
        check: "Boolean",
        init: false,
        apply: "_applyShowButton"
      },

      /**
       * Toggles visibility of NavigationBar in
       * wrapping container {@link qx.ui.mobile.container.Navigation}
       */
      navigationBarHidden: {
        check: "Boolean",
        init: false
      },

      /**
       * Sets the transition duration (in seconds) for the effect when hiding/showing
       * the NavigationBar through boolean property navigationBarHidden.
       */
      navigationBarToggleDuration: {
        check: "Number",
        init: 0.8
      },

      /**
       * The CSS class to add to the content per default.
       */
      contentCssClass: {
        check: "String",
        init: "content",
        nullable: true,
        apply: "_applyContentCssClass"
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      _isTablet: false,
      _wrapContentByGroup: true,
      __backButton: null,
      __actionButton: null,
      __content: null,
      __scrollContainer: null,
      __title: null,
      __leftContainer: null,
      __rightContainer: null,
      // interface implementation
      getTitleWidget: function getTitleWidget() {
        if (!this.__title) {
          this.__title = this._createTitleWidget();
        }

        return this.__title;
      },

      /**
       * Creates the navigation bar title.
       *
       * @return {qx.ui.mobile.navigationbar.Title} The created title widget
       */
      _createTitleWidget: function _createTitleWidget() {
        return new qx.ui.mobile.navigationbar.Title(this.getTitle());
      },
      // property apply
      _applyTitle: function _applyTitle(value, old) {
        if (this.__title) {
          this.__title.setValue(value);
        }
      },
      // interface implementation
      getLeftContainer: function getLeftContainer() {
        if (!this.__leftContainer) {
          this.__leftContainer = this._createLeftContainer();
        }

        return this.__leftContainer;
      },
      // interface implementation
      getRightContainer: function getRightContainer() {
        if (!this.__rightContainer) {
          this.__rightContainer = this._createRightContainer();
        }

        return this.__rightContainer;
      },

      /**
       * Creates the left container for the navigation bar.
       *
       * @return {qx.ui.mobile.container.Composite} Creates the left container for the navigation bar.
       */
      _createLeftContainer: function _createLeftContainer() {
        var layout = new qx.ui.mobile.layout.HBox();
        var container = new qx.ui.mobile.container.Composite(layout);
        container.addCssClass("left-container");
        this.__backButton = this._createBackButton();

        this.__backButton.addListener("tap", this._onBackButtonTap, this);

        this._showBackButton();

        container.add(this.__backButton);
        return container;
      },

      /**
       * Creates the right container for the navigation bar.
       *
       * @return {qx.ui.mobile.container.Composite} Creates the right container for the navigation bar.
       */
      _createRightContainer: function _createRightContainer() {
        var layout = new qx.ui.mobile.layout.HBox();
        var container = new qx.ui.mobile.container.Composite(layout);
        container.addCssClass("right-container");
        this.__actionButton = this._createButton();

        this.__actionButton.addListener("tap", this._onButtonTap, this);

        this._showButton();

        container.add(this.__actionButton);
        return container;
      },

      /**
        * Creates the navigation bar back button.
        * Creates the scroll container.
        *
        * @return {qx.ui.mobile.navigationbar.BackButton} The created back button widget
        */
      _createBackButton: function _createBackButton() {
        return new qx.ui.mobile.navigationbar.BackButton(this.getBackButtonText());
      },

      /**
        * Creates the navigation bar button.
        * Creates the content container.
        *
        * @return {qx.ui.mobile.navigationbar.Button} The created button widget
        */
      _createButton: function _createButton() {
        return new qx.ui.mobile.navigationbar.Button(this.getButtonText(), this.getButtonIcon());
      },

      /**
       * Returns the content container. Add all your widgets to this container.
       *
       * @return {qx.ui.mobile.container.Composite} The content container
       */
      getContent: function getContent() {
        return this.__content;
      },

      /**
       * Returns the back button widget.
       *
       * @return {qx.ui.mobile.navigationbar.BackButton} The back button widget
       */
      _getBackButton: function _getBackButton() {
        return this.__backButton;
      },

      /**
       * Returns the action button widget.
       *
       * @return {qx.ui.mobile.navigationbar.Button} The action button widget
       */
      _getButton: function _getButton() {
        return this.__actionButton;
      },

      /**
       * Sets the isTablet flag.
       * @param isTablet {Boolean} value of the isTablet flag.
       */
      setIsTablet: function setIsTablet(isTablet) {
        this._isTablet = isTablet;
      },

      /**
       * Returns the isTablet flag.
       * @return {Boolean} the isTablet flag of this page.
       */
      isTablet: function isTablet() {
        return this._isTablet;
      },

      /**
       * Returns the scroll container.
       *
       * @return {qx.ui.mobile.container.Scroll} The scroll container
       */
      _getScrollContainer: function _getScrollContainer() {
        return this.__scrollContainer;
      },

      /**
       * Adds a widget, below the NavigationBar.
       *
       * @param widget {qx.ui.mobile.core.Widget} The widget to add, after NavigationBar.
       */
      addAfterNavigationBar: function addAfterNavigationBar(widget) {
        if (widget && this.__scrollContainer) {
          this.addBefore(widget, this.__scrollContainer);
        }
      },
      // property apply
      _applyBackButtonText: function _applyBackButtonText(value, old) {
        if (this.__backButton) {
          this.__backButton.setValue(value);
        }
      },
      // property apply
      _applyActionButtonText: function _applyActionButtonText(value, old) {
        if (this.__actionButton) {
          this.__actionButton.setValue(value);
        }
      },
      // property apply
      _applyActionButtonIcon: function _applyActionButtonIcon(value, old) {
        if (this.__actionButton) {
          this.__actionButton.setIcon(value);
        }
      },
      // property apply
      _applyShowBackButton: function _applyShowBackButton(value, old) {
        this._showBackButton();
      },
      // property apply
      _applyShowButton: function _applyShowButton(value, old) {
        this._showButton();
      },
      // property apply
      _applyContentCssClass: function _applyContentCssClass(value, old) {
        if (this.__content) {
          this.__content.setDefaultCssClass(value);
        }
      },

      /**
       * Helper method to show the back button.
       */
      _showBackButton: function _showBackButton() {
        if (this.__backButton) {
          if (this.getShowBackButton()) {
            this.__backButton.show();
          } else {
            this.__backButton.exclude();
          }
        }
      },

      /**
       * Helper method to show the button.
       */
      _showButton: function _showButton() {
        if (this.__actionButton) {
          if (this.getShowButton()) {
            this.__actionButton.show();
          } else {
            this.__actionButton.exclude();
          }
        }
      },
      // overridden
      _initialize: function _initialize() {
        qx.ui.mobile.page.NavigationPage.prototype._initialize.base.call(this);

        this.__scrollContainer = this._createScrollContainer();
        this.__content = this._createContent();

        if (this.__content) {
          this.__scrollContainer.add(this.__content, {
            flex: 1
          });
        }

        if (this.__scrollContainer) {
          this.add(this.__scrollContainer, {
            flex: 1
          });
        }
      },

      /**
       * Creates the scroll container.
       *
       * @return {qx.ui.mobile.container.Scroll} The created scroll container
       */
      _createScrollContainer: function _createScrollContainer() {
        return new qx.ui.mobile.container.Scroll();
      },

      /**
       * Creates the content container.
       *
       * @return {qx.ui.mobile.container.Composite} The created content container
       */
      _createContent: function _createContent() {
        var content = new qx.ui.mobile.container.Composite();
        content.setDefaultCssClass(this.getContentCssClass());

        if (this._wrapContentByGroup == true) {
          content.addCssClass("group");
        }

        return content;
      },

      /**
       * Event handler. Called when the tap event occurs on the back button.
       *
       * @param evt {qx.event.type.Tap} The tap event
       */
      _onBackButtonTap: function _onBackButtonTap(evt) {
        this.back();
      },

      /**
       * Event handler. Called when the tap event occurs on the button.
       *
       * @param evt {qx.event.type.Tap} The tap event
       */
      _onButtonTap: function _onButtonTap(evt) {
        this.fireEvent("action");
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__leftContainer", "__rightContainer", "__backButton", "__actionButton", "__title");

      this.__leftContainer = this.__rightContainer = this.__backButton = this.__actionButton = null;
      this.__title = this.__content = this.__scrollContainer = null;
      this._isTablet = null;
    }
  });
  qx.ui.mobile.page.NavigationPage.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.event.handler.Transition": {},
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.layout.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.CardAnimation": {
        "construct": true
      },
      "qx.bom.client.CssTransform": {},
      "qx.bom.AnimationFrame": {},
      "qx.ui.mobile.core.MResize": {},
      "qx.event.Registration": {},
      "qx.bom.element.Class": {},
      "qx.bom.element.Animation": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.transform.3d": {
          "className": "qx.bom.client.CssTransform"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * A card layout.
   *
   * The card layout lays out widgets in a stack. Call show to display a widget.
   * Only the widget which show method is called is displayed. All other widgets are excluded.
   *
   *
   * *Example*
   *
   * Here is a little example of how to use the Card layout.
   *
   * <pre class="javascript">
   * var layout = new qx.ui.mobile.layout.Card());
   * var container = new qx.ui.mobile.container.Composite(layout);
   *
   * var label1 = new qx.ui.mobile.basic.Label("1");
   * container.add(label1);
   * var label2 = new qx.ui.mobile.basic.Label("2");
   * container.add(label2);
   *
   * label2.show();
   * </pre>
   *
   * @use(qx.event.handler.Transition)
   */
  qx.Class.define("qx.ui.mobile.layout.Card", {
    extend: qx.ui.mobile.layout.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.mobile.layout.Abstract.constructor.call(this);
      this.__cardAnimation = new qx.ui.mobile.layout.CardAnimation();
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the animation of a page transition starts */
      animationStart: "qx.event.type.Data",

      /** Fired when the animation of a page transition ends */
      animationEnd: "qx.event.type.Data"
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      /** The default animation to use for page transition */
      defaultAnimation: {
        check: "String",
        init: "slide"
      },

      /** Flag which indicates, whether animation is needed, or widgets should only swap. */
      showAnimation: {
        check: "Boolean",
        init: true
      },

      /** Transition duration of each animation. */
      animationDuration: {
        check: "Integer",
        init: 350
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      __nextWidget: null,
      __currentWidget: null,
      __inAnimation: null,
      __animation: null,
      __reverse: null,
      __cardAnimation: null,
      // overridden
      _getCssClasses: function _getCssClasses() {
        return ["layout-card", "qx-vbox"];
      },
      // overridden
      connectToChildWidget: function connectToChildWidget(widget) {
        qx.ui.mobile.layout.Card.prototype.connectToChildWidget.base.call(this);

        if (widget) {
          widget.addCssClass("layout-card-item");
          widget.addCssClass("qx-flex1");
          widget.exclude();
        }
      },
      // overridden
      disconnectFromChildWidget: function disconnectFromChildWidget(widget) {
        qx.ui.mobile.layout.Card.prototype.disconnectFromChildWidget.base.call(this);
        widget.removeCssClass("layout-card-item");
      },
      // overridden
      updateLayout: function updateLayout(widget, action, properties) {
        if (action == "visible") {
          this._showWidget(widget, properties);
        }

        qx.ui.mobile.layout.Card.prototype.updateLayout.base.call(this, widget, action, properties);
      },

      /**
       * Setter for this.__cardAnimation.
       * @param value {qx.ui.mobile.layout.CardAnimation} the new CardAnimation object.
       */
      setCardAnimation: function setCardAnimation(value) {
        this.__cardAnimation = value;
      },

      /**
       * Getter for this.__cardAnimation.
       * @return {qx.ui.mobile.layout.CardAnimation} the current CardAnimation object.
       */
      getCardAnimation: function getCardAnimation() {
        return this.__cardAnimation;
      },

      /**
       * Shows the widget with the given properties.
       *
       * @param widget {qx.ui.mobile.core.Widget} The target widget
       * @param properties {Map} The layout properties to set. Key / value pairs.
       */
      _showWidget: function _showWidget(widget, properties) {
        if (this.__nextWidget == widget) {
          return;
        }

        if (this.__inAnimation) {
          this.__stopAnimation();
        }

        this.__nextWidget = widget;

        if (this.__currentWidget && this.getShowAnimation() && qx.core.Environment.get("css.transform.3d")) {
          properties = properties || {}; // both are explicit identity checks for null

          if (properties.animation === null || this.getCardAnimation().getMap()[properties.animation] === null) {
            this._swapWidget();

            return;
          }

          this.__animation = properties.animation || this.getDefaultAnimation();

          if (properties.action && properties.action === "back") {
            this.__reverse = true;
          } else {
            properties.reverse = properties.reverse === null ? false : properties.reverse;
            this.__reverse = properties.reverse;
          }

          qx.bom.AnimationFrame.request(function () {
            this.__startAnimation(widget);
          }, this);
        } else {
          this._swapWidget();
        }
      },

      /**
       * Excludes the current widget and sets the next widget to the current widget.
       */
      _swapWidget: function _swapWidget() {
        if (this.__currentWidget) {
          this.__currentWidget.removeCssClass("active");

          this.__currentWidget.exclude();
        }

        this.__currentWidget = this.__nextWidget;

        this.__currentWidget.addCssClass("active");
      },

      /**
       * Fix size, only if widget has mixin MResize set,
       * and nextWidget is set.
       *
       * @param widget {qx.ui.mobile.core.Widget} The target widget which should have a fixed size.
       */
      _fixWidgetSize: function _fixWidgetSize(widget) {
        if (widget) {
          var hasResizeMixin = qx.Class.hasMixin(widget.constructor, qx.ui.mobile.core.MResize);

          if (hasResizeMixin) {
            // Size has to be fixed for animation.
            widget.fixSize();
          }
        }
      },

      /**
       * Releases recently fixed widget size (width/height). This is needed for allowing further
       * flexbox layouting.
       *
       * @param widget {qx.ui.mobile.core.Widget} The target widget which should have a flexible size.
       */
      _releaseWidgetSize: function _releaseWidgetSize(widget) {
        if (widget) {
          var hasResizeMixin = qx.Class.hasMixin(widget.constructor, qx.ui.mobile.core.MResize);

          if (hasResizeMixin) {
            // Size has to be released after animation.
            widget.releaseFixedSize();
          }
        }
      },

      /**
       * Starts the animation for the page transition.
       *
       * @param widget {qx.ui.mobile.core.Widget} The target widget
       */
      __startAnimation: function __startAnimation(widget) {
        if (widget.isDisposed()) {
          return;
        } // Fix size of current and next widget, then start animation.


        this.__inAnimation = true;
        this.fireDataEvent("animationStart", [this.__currentWidget, widget]);

        var fromElement = this.__currentWidget.getContainerElement();

        var toElement = widget.getContainerElement();
        qx.event.Registration.addListener(fromElement, "animationEnd", this._onAnimationEnd, this);
        qx.event.Registration.addListener(toElement, "animationEnd", this._onAnimationEnd, this);

        var fromCssClasses = this.__getAnimationClasses("out");

        var toCssClasses = this.__getAnimationClasses("in");

        this._widget.addCssClass("animationParent");

        var toElementAnimation = this.__cardAnimation.getAnimation(this.__animation, "in", this.__reverse);

        var fromElementAnimation = this.__cardAnimation.getAnimation(this.__animation, "out", this.__reverse);

        qx.bom.element.Class.addClasses(toElement, toCssClasses);
        qx.bom.element.Class.addClasses(fromElement, fromCssClasses);
        qx.bom.element.Animation.animate(toElement, toElementAnimation);
        qx.bom.element.Animation.animate(fromElement, fromElementAnimation);
      },

      /**
       * Event handler. Called when the animation of the page transition ends.
       *
       * @param evt {qx.event.type.Event} The causing event
       */
      _onAnimationEnd: function _onAnimationEnd(evt) {
        this.__stopAnimation();

        this.fireDataEvent("animationEnd", [this.__currentWidget, this.__nextWidget]);
      },

      /**
       * Stops the animation for the page transition.
       */
      __stopAnimation: function __stopAnimation() {
        if (this.__inAnimation) {
          var fromElement = this.__currentWidget.getContainerElement();

          var toElement = this.__nextWidget.getContainerElement();

          qx.event.Registration.removeListener(fromElement, "animationEnd", this._onAnimationEnd, this);
          qx.event.Registration.removeListener(toElement, "animationEnd", this._onAnimationEnd, this);
          qx.bom.element.Class.removeClasses(fromElement, this.__getAnimationClasses("out"));
          qx.bom.element.Class.removeClasses(toElement, this.__getAnimationClasses("in"));

          this._swapWidget();

          this._widget.removeCssClass("animationParent");

          this.__inAnimation = false;
        }
      },

      /**
       * Returns the animation CSS classes for a given direction. The direction
       * can be <code>in</code> or <code>out</code>.
       *
       * @param direction {String} The direction of the animation. <code>in</code> or <code>out</code>.
       * @return {String[]} The CSS classes for the set animation.
       */
      __getAnimationClasses: function __getAnimationClasses(direction) {
        var classes = ["animationChild", this.__animation, direction];

        if (this.__reverse) {
          classes.push("reverse");
        }

        return classes;
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__cardAnimation");
    }
  });
  qx.ui.mobile.layout.Card.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A navigation bar widget.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var bar = new qx.ui.mobile.navigationbar.NavigationBar();
   *   var backButton = new qx.ui.mobile.navigationbar.BackButton();
   *   bar.add(backButton);
   *   var title = new qx.ui.mobile.navigationbar.Title();
   *   var.add(title, {flex:1});
   *
   *   this.getRoot.add(bar);
   * </pre>
   *
   * This example creates a navigation bar and adds a back button and a title to it.
   */
  qx.Class.define("qx.ui.mobile.navigationbar.NavigationBar", {
    extend: qx.ui.mobile.container.Composite,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout);

      if (!layout) {
        this.setLayout(new qx.ui.mobile.layout.HBox().set({
          alignY: "middle"
        }));
      }
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "navigationbar"
      }
    }
  });
  qx.ui.mobile.navigationbar.NavigationBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.basic.Label": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A navigation bar title widget.
   */
  qx.Class.define("qx.ui.mobile.navigationbar.Title", {
    extend: qx.ui.mobile.basic.Label,
    properties: {
      wrap: {
        refine: true,
        init: false
      },
      // overridden
      defaultCssClass: {
        refine: true,
        init: "title"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "h1";
      }
    }
  });
  qx.ui.mobile.navigationbar.Title.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Button": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A navigation bar button widget.
   */
  qx.Class.define("qx.ui.mobile.navigationbar.Button", {
    extend: qx.ui.mobile.form.Button,

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "navigationbar-button"
      }
    }
  });
  qx.ui.mobile.navigationbar.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.navigationbar.Button": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A navigation bar back button widget.
   */
  qx.Class.define("qx.ui.mobile.navigationbar.BackButton", {
    extend: qx.ui.mobile.navigationbar.Button,

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "navigationbar-backbutton"
      }
    }
  });
  qx.ui.mobile.navigationbar.BackButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.util.Animation": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
   * Christopher Zuendorf (czuendorf)
  
   ************************************************************************ */

  /**
   * Contains all animations which are needed for page transitions on {@link qx.ui.mobile.layout.Card}.
   * Provides a convenience method {@link qx.ui.mobile.layout.CardAnimation#getAnimation} which
   * makes it possibility to resolve the right animation for a pageTransition out of the cardAnimationMap.
   */
  qx.Class.define("qx.ui.mobile.layout.CardAnimation", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this._cardAnimationsMap = {
        "none": null,
        "slide": {
          "in": qx.util.Animation.SLIDE_LEFT_IN,
          "out": qx.util.Animation.SLIDE_LEFT_OUT,
          "reverse": {
            "in": qx.util.Animation.SLIDE_RIGHT_IN,
            "out": qx.util.Animation.SLIDE_RIGHT_OUT
          }
        },
        "fade": {
          "in": qx.util.Animation.FADE_IN,
          "out": qx.util.Animation.FADE_OUT,
          "reverse": {
            "in": qx.util.Animation.FADE_IN,
            "out": qx.util.Animation.FADE_OUT
          }
        },
        "pop": {
          "in": qx.util.Animation.POP_IN,
          "out": qx.util.Animation.POP_OUT,
          "reverse": {
            "in": qx.util.Animation.POP_IN,
            "out": qx.util.Animation.POP_OUT
          }
        },
        "slideup": {
          "in": qx.util.Animation.SLIDE_UP_IN,
          "out": qx.util.Animation.SLIDE_UP_OUT,
          "reverse": {
            "in": qx.util.Animation.SLIDE_DOWN_IN,
            "out": qx.util.Animation.SLIDE_DOWN_OUT
          }
        },
        "flip": {
          "in": qx.util.Animation.FLIP_LEFT_IN,
          "out": qx.util.Animation.FLIP_LEFT_OUT,
          "reverse": {
            "in": qx.util.Animation.FLIP_RIGHT_IN,
            "out": qx.util.Animation.FLIP_RIGHT_OUT
          }
        },
        "swap": {
          "in": qx.util.Animation.SWAP_LEFT_IN,
          "out": qx.util.Animation.SWAP_LEFT_OUT,
          "reverse": {
            "in": qx.util.Animation.SWAP_RIGHT_IN,
            "out": qx.util.Animation.SWAP_RIGHT_OUT
          }
        },
        "cube": {
          "in": qx.util.Animation.CUBE_LEFT_IN,
          "out": qx.util.Animation.CUBE_LEFT_OUT,
          "reverse": {
            "in": qx.util.Animation.CUBE_RIGHT_IN,
            "out": qx.util.Animation.CUBE_RIGHT_OUT
          }
        }
      };
    },
    members: {
      _cardAnimationsMap: null,

      /**
      * Returns a map with properties for {@link qx.bom.element.Animation} according to the given input parameters.
      * @param animationName {String} the animation key
      * @param direction {String} the animation direction ("in" | "out")
      * @param reverse {Boolean} flag which indicates whether it is a reverse animation.
      * @return {Map} animation property map, intended for the usage with {@link qx.bom.element.Animation}
      */
      getAnimation: function getAnimation(animationName, direction, reverse) {
        {
          if (!reverse) {
            this.assertNotUndefined(this._cardAnimationsMap[animationName], "Animation '" + animationName + "' is not defined.");
            this.assertNotUndefined(this._cardAnimationsMap[animationName][direction], "Animation '" + animationName + " " + direction + "' is not defined.");
          } else {
            this.assertNotUndefined(this._cardAnimationsMap[animationName], "Animation Reverse'" + animationName + "' is not defined.");
            this.assertNotUndefined(this._cardAnimationsMap[animationName]["reverse"], "Animation Reverse'" + animationName + "' is not defined.");
            this.assertNotUndefined(this._cardAnimationsMap[animationName]["reverse"][direction], "Animation Reverse'" + animationName + " " + direction + "' is not defined.");
          }
        }
        var animation = this._cardAnimationsMap[animationName];
        var animationObject = {};

        if (!reverse) {
          animationObject = animation[direction];
        } else {
          animationObject = animation["reverse"][direction];
        }

        return animationObject;
      },

      /**
       * Getter for the cardAnimationsMap.
       * @return {Map} the cardAnimationsMap.
       */
      getMap: function getMap() {
        return this._cardAnimationsMap;
      }
    },
    destruct: function destruct() {
      this._cardAnimationsMap = null;
    }
  });
  qx.ui.mobile.layout.CardAnimation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
   * Christopher Zuendorf (czuendorf)
  
   ************************************************************************ */

  /**
   * Contains property maps for the usage with qx.bom.element.Animation {@link qx.bom.element.Animation}.
   * These animations can be used for page transitions for example.
   */
  qx.Bootstrap.define("qx.util.Animation", {
    statics: {
      /** Target slides in from right. */
      SLIDE_LEFT_IN: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            translate: ["100%"]
          },
          100: {
            translate: ["0%"]
          }
        }
      },

      /** Target slides out from right.*/
      SLIDE_LEFT_OUT: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            translate: ["0px"]
          },
          100: {
            translate: ["-100%"]
          }
        }
      },

      /** Target slides in from left.*/
      SLIDE_RIGHT_IN: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            translate: ["-100%"]
          },
          100: {
            translate: ["0%"]
          }
        }
      },

      /** Target slides out from left.*/
      SLIDE_RIGHT_OUT: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            translate: ["0px"]
          },
          100: {
            translate: ["100%"]
          }
        }
      },

      /** Target fades in. */
      FADE_IN: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            opacity: ["0"]
          },
          100: {
            opacity: ["1"]
          }
        }
      },

      /** Target fades out. */
      FADE_OUT: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            opacity: ["1"]
          },
          100: {
            opacity: ["0"]
          }
        }
      },

      /** Target pops in from center. */
      POP_IN: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            scale: [".2", ".2"]
          },
          100: {
            scale: ["1", "1"]
          }
        }
      },

      /** Target pops out from center. */
      POP_OUT: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            scale: ["1", "1"]
          },
          100: {
            scale: [".2", ".2"]
          }
        }
      },

      /** Target shrinks its height. */
      SHRINK_HEIGHT: {
        duration: 400,
        timing: "linear",
        origin: "top center",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["1", "1"],
            opacity: 1
          },
          100: {
            scale: ["1", "0"],
            opacity: 0
          }
        }
      },

      /** Target grows its height. */
      GROW_HEIGHT: {
        duration: 400,
        timing: "linear",
        origin: "top center",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["1", "0"],
            opacity: 0
          },
          100: {
            scale: ["1", "1"],
            opacity: 1
          }
        }
      },

      /** Target shrinks its width. */
      SHRINK_WIDTH: {
        duration: 400,
        timing: "linear",
        origin: "left center",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["1", "1"],
            opacity: 1
          },
          100: {
            scale: ["0", "1"],
            opacity: 0
          }
        }
      },

      /** Target grows its width. */
      GROW_WIDTH: {
        duration: 400,
        timing: "linear",
        origin: "left center",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["0", "1"],
            opacity: 0
          },
          100: {
            scale: ["1", "1"],
            opacity: 1
          }
        }
      },

      /** Target shrinks in both width and height. */
      SHRINK: {
        duration: 400,
        timing: "linear",
        origin: "left top",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["1", "1"],
            opacity: 1
          },
          100: {
            scale: ["0", "0"],
            opacity: 0
          }
        }
      },

      /** Target grows in both width and height. */
      GROW: {
        duration: 400,
        timing: "linear",
        origin: "left top",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["0", "0"],
            opacity: 0
          },
          100: {
            scale: ["1", "1"],
            opacity: 1
          }
        }
      },

      /** Target slides in to top. */
      SLIDE_UP_IN: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            translate: ["0px", "100%"]
          },
          100: {
            translate: ["0px", "0px"]
          }
        }
      },

      /** Target slides out to top.*/
      SLIDE_UP_OUT: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            translate: ["0px", "0px"]
          },
          100: {
            translate: ["0px", "0px"]
          }
        }
      },

      /** Target slides out to bottom.*/
      SLIDE_DOWN_IN: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            translate: ["0px", "0px"]
          },
          100: {
            translate: ["0px", "0px"]
          }
        }
      },

      /** Target slides down to bottom.*/
      SLIDE_DOWN_OUT: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            translate: ["0px", "0px"]
          },
          100: {
            translate: ["0px", "100%"]
          }
        }
      },

      /** Target flips (turns) left from back side to front side. */
      FLIP_LEFT_IN: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            opacity: 0
          },
          49: {
            opacity: 0
          },
          50: {
            rotate: ["0deg", "90deg"],
            scale: [".8", "1"],
            opacity: 1
          },
          100: {
            rotate: ["0deg", "0deg"],
            scale: ["1", "1"],
            opacity: 1
          }
        }
      },

      /** Target flips (turns) left from front side to back side. */
      FLIP_LEFT_OUT: {
        duration: 350,
        timing: "linear",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            scale: ["1", "1"]
          },
          100: {
            rotate: ["0deg", "-180deg"],
            scale: [".8", "1"]
          }
        }
      },

      /** Target flips (turns) right from back side to front side. */
      FLIP_RIGHT_IN: {
        duration: 350,
        timing: "linear",
        origin: "center center",
        keyFrames: {
          0: {
            opacity: 0
          },
          49: {
            opacity: 0
          },
          50: {
            rotate: ["0deg", "-90deg"],
            scale: [".8", "1"],
            opacity: 1
          },
          100: {
            rotate: ["0deg", "0deg"],
            scale: ["1", "1"],
            opacity: 1
          }
        }
      },

      /** Target flips (turns) right from front side to back side. */
      FLIP_RIGHT_OUT: {
        duration: 350,
        timing: "linear",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            scale: ["1", "1"]
          },
          100: {
            rotate: ["0deg", "180deg"],
            scale: [".8", "1"]
          }
        }
      },

      /** Target moves in to left. */
      SWAP_LEFT_IN: {
        duration: 700,
        timing: "ease-out",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "-70deg"],
            translate: ["0px", "0px", "-800px"],
            opacity: "0"
          },
          35: {
            rotate: ["0deg", "-20deg"],
            translate: ["-180px", "0px", "-400px"],
            opacity: "1"
          },
          100: {
            rotate: ["0deg", "0deg"],
            translate: ["0px", "0px", "0px"],
            opacity: "1"
          }
        }
      },

      /** Target moves out to left.  */
      SWAP_LEFT_OUT: {
        duration: 700,
        timing: "ease-out",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            translate: ["0px", "0px", "0px"],
            opacity: "1"
          },
          35: {
            rotate: ["0deg", "20deg"],
            translate: ["-180px", "0px", "-400px"],
            opacity: ".5"
          },
          100: {
            rotate: ["0deg", "70deg"],
            translate: ["0px", "0px", "-800px"],
            opacity: "0"
          }
        }
      },

      /** Target moves in to right. */
      SWAP_RIGHT_IN: {
        duration: 700,
        timing: "ease-out",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "70deg"],
            translate: ["0px", "0px", "-800px"],
            opacity: "0"
          },
          35: {
            rotate: ["0deg", "20deg"],
            translate: ["-180px", "0px", "-400px"],
            opacity: "1"
          },
          100: {
            rotate: ["0deg", "0deg"],
            translate: ["0px", "0px", "0px"],
            opacity: "1"
          }
        }
      },

      /** Target moves out to right. */
      SWAP_RIGHT_OUT: {
        duration: 700,
        timing: "ease-out",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            translate: ["0px", "0px", "0px"],
            opacity: "1"
          },
          35: {
            rotate: ["0deg", "-20deg"],
            translate: ["180px", "0px", "-400px"],
            opacity: ".5"
          },
          100: {
            rotate: ["0deg", "-70deg"],
            translate: ["0px", "0px", "-800px"],
            opacity: "0"
          }
        }
      },

      /** Target moves in with cube animation from right to left.  */
      CUBE_LEFT_IN: {
        duration: 550,
        timing: "linear",
        origin: "100% 50%",
        keyFrames: {
          0: {
            rotate: ["0deg", "90deg"],
            scale: ".5",
            translate: ["0", "0", "0px"],
            opacity: [".5"]
          },
          100: {
            rotate: ["0deg", "0deg"],
            scale: "1",
            translate: ["0", "0", "0"],
            opacity: ["1"]
          }
        }
      },

      /** Target moves out with cube animation from right to left.  */
      CUBE_LEFT_OUT: {
        duration: 550,
        timing: "linear",
        origin: "0% 50%",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            scale: "1",
            translate: ["0", "0", "0px"],
            opacity: ["1"]
          },
          100: {
            rotate: ["0deg", "-90deg"],
            scale: ".5",
            translate: ["0", "0", "0"],
            opacity: [".5"]
          }
        }
      },

      /** Target moves in with cube animation from left to right.  */
      CUBE_RIGHT_IN: {
        duration: 550,
        timing: "linear",
        origin: "0% 50%",
        keyFrames: {
          0: {
            rotate: ["0deg", "-90deg"],
            scale: ".5",
            translate: ["0", "0", "0px"],
            opacity: [".5"]
          },
          100: {
            rotate: ["0deg", "0deg"],
            scale: "1",
            translate: ["0", "0", "0"],
            opacity: ["1"]
          }
        }
      },

      /** Target moves out with cube animation from left to right.  */
      CUBE_RIGHT_OUT: {
        duration: 550,
        timing: "linear",
        origin: "100% 50%",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            scale: "1",
            translate: ["0", "0", "0px"],
            opacity: ["1"]
          },
          100: {
            rotate: ["0deg", "90deg"],
            scale: ".5",
            translate: ["0", "0", "0"],
            opacity: [".5"]
          }
        }
      }
    }
  });
  qx.util.Animation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.container.Scroll": {},
      "qx.ui.mobile.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.container.Scroll", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testCreate: function testCreate() {
        var container = new qx.ui.mobile.container.Scroll();
        this.getRoot().add(container);
        container.destroy();
      },
      testHorizontalWayPoint: function testHorizontalWayPoint() {
        var scrollContainer = new qx.ui.mobile.container.Scroll();
        scrollContainer.setWaypointsX([200]);
        qxWeb(scrollContainer.getContainerElement()).setStyle("overflow", "hidden");
        scrollContainer.addListener("waypoint", function (wayPoint) {
          var wayPointData = wayPoint.getData();
          this.resume(function () {
            this.assertEquals("x", wayPointData.axis);
            this.assertEquals(0, wayPointData.index);
            this.assertEquals("left", wayPointData.direction);
          }, this);
        }, this);
        var content = new qx.ui.mobile.core.Widget();
        qxWeb(content.getContainerElement()).setStyles({
          width: "5000px",
          height: "5000px"
        });
        scrollContainer.add(content);
        this.getRoot().add(scrollContainer);

        scrollContainer._updateWaypoints();

        setTimeout(function () {
          scrollContainer._setCurrentX(250);
        }, 100);
        this.wait();
      }
    }
  });
  qx.test.mobile.container.Scroll.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.core.Widget": {},
      "qx.bom.element.Class": {},
      "qx.locale.MTranslation": {},
      "qx.bom.element.Style": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.core.Widget", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testCreate: function testCreate() {
        var widget = new qx.ui.mobile.core.Widget().set({
          id: "affe"
        });
        this.getRoot().add(widget);
        var element = document.getElementById("affe");
        this.assertElement(element);
        widget.destroy();
      },
      testNameProperty: function testNameProperty() {
        var widget = new qx.ui.mobile.core.Widget().set({
          name: "affe"
        });
        this.getRoot().add(widget);
        var element = document.getElementsByName("affe")[0];
        this.assertElement(element);
        var name = widget.getName();
        this.assertEquals(name, "affe");
        widget.destroy();
      },
      testSetCssClass: function testSetCssClass() {
        var widget = new qx.ui.mobile.core.Widget();
        this.getRoot().add(widget);
        var element = widget.getContainerElement();
        var className = qx.bom.element.Class.get(element);
        this.assertEquals(className, "");
        widget.setDefaultCssClass("affe");
        var className = qx.bom.element.Class.get(element);
        this.assertEquals(className, "affe");
        /*
        widget.setDefaultCssClass("foo bar");
        var className = qx.bom.element.Class.get(element);
        this.assertEquals(className, "foo bar");
        */

        widget.setDefaultCssClass("bar");
        var className = qx.bom.element.Class.get(element);
        this.assertEquals(className, "bar");
        widget.destroy();
      },
      testAddRemoveCssClass: function testAddRemoveCssClass() {
        var widget = new qx.ui.mobile.core.Widget();
        this.getRoot().add(widget);
        var element = widget.getContainerElement();
        var className = qx.bom.element.Class.get(element);
        this.assertEquals(className, "");
        widget.addCssClass("affe");
        this.assertTrue(widget.hasCssClass("affe"));
        widget.removeCssClass("affe");
        this.assertFalse(widget.hasCssClass("affe"));
        widget.destroy();
      },
      testAutoId: function testAutoId() {
        var widget = new qx.ui.mobile.core.Widget();
        this.getRoot().add(widget);
        var clazz = qx.ui.mobile.core.Widget; // decrement is 2 when qx.core.Environment.get("qx.debug.dispose") because the _root is recreated on every test,
        // and it is a widget too

        var decrement = false ? 2 : 1;
        var id = clazz.ID_PREFIX + (clazz.getCurrentId() - decrement);
        var element = document.getElementById(id);
        this.assertElement(element);
        var widgetId = widget.getId();
        this.assertEquals(widgetId, id);
        widget.destroy();
      },
      testWidgetRegistration: function testWidgetRegistration() {
        var widget = new qx.ui.mobile.core.Widget();
        var id = widget.getId();
        widget = qx.ui.mobile.core.Widget.getWidgetById(id);
        this.assertQxMobileWidget(widget);
        widget.destroy();
      },
      testWidgetRegistrationSameId: function testWidgetRegistrationSameId() {
        var widget = new qx.ui.mobile.core.Widget().set({
          id: "affe"
        });
        {
          this.assertException(function () {
            var widget2 = new qx.ui.mobile.core.Widget().set({
              id: "affe"
            });
          });
        }
        widget.destroy();
      },
      testTranslationAvailable: function testTranslationAvailable() {
        var widget = new qx.ui.mobile.core.Widget();
        this.assertTrue(qx.Class.hasMixin(qx.ui.mobile.core.Widget, qx.locale.MTranslation), "No translation mixin found");
        this.assertFunction(widget.tr);
        widget.destroy();
      },
      testDestroy: function testDestroy() {
        var widget = new qx.ui.mobile.core.Widget();
        var id = widget.getId();
        widget.destroy();
        widget = qx.ui.mobile.core.Widget.getWidgetById(id);
        this.assertUndefined(widget);
        var element = document.getElementById(id);
        this.assertNull(element);
      },
      testDomUpdatedFired: function testDomUpdatedFired() {
        var widget = new qx.ui.mobile.core.Widget();
        this.assertEventNotFired(widget, "domupdated", qx.ui.mobile.core.Widget.domUpdated);
        this.getRoot().add(widget);
        this.assertEventFired(widget, "domupdated", qx.ui.mobile.core.Widget.domUpdated);
        widget.destroy();
      },
      testVisibility: function testVisibility() {
        var widget = new qx.ui.mobile.core.Widget();
        this.getRoot().add(widget);

        this.__assertShow(widget);

        widget.exclude();
        this.assertFalse(widget.isVisible(), "Exclude: Widget should not be visible");
        this.assertTrue(widget.isExcluded(), "Exclude: Widget should be excluded");
        this.assertTrue(widget.isHidden(), "Exclude: Widget should be hidden");
        this.assertTrue(widget.hasCssClass("exclude"), "Exclude: No exclude class set");
        this.assertEquals("visible", widget._getStyle("visibility"), "Exclude: Visibility style should be null");
        widget.show();

        this.__assertShow(widget);

        widget.hide();
        this.assertFalse(widget.isVisible(), "Hide: Widget should not be visible");
        this.assertFalse(widget.isExcluded(), "Hide: Widget should not be excluded");
        this.assertTrue(widget.isHidden(), "Hide: Widget should be hidden");
        this.assertTrue(widget.isSeeable(), "Hide: Widget should be seeable");
        this.assertEquals("block", widget._getStyle("display"), "Hide: Display style should be block");
        this.assertFalse(widget.hasCssClass("exclude"), "Hide: Exclude class set");
        this.assertEquals("hidden", widget._getStyle("visibility"), "Hide: Visibility style should be hidden");
        widget.show();

        this.__assertShow(widget);

        widget.destroy();
      },
      __assertShow: function __assertShow(widget) {
        this.assertTrue(widget.isVisible(), "Show: Widget should be visible");
        this.assertFalse(widget.isExcluded(), "Show: Widget should not be excluded");
        this.assertFalse(widget.isHidden(), "Show: Widget should not be hidden");
        this.assertTrue(widget.isSeeable(), "Show: Widget should be seeable");
        this.assertEquals("block", widget._getStyle("display"), "Show: Display style should be block");
        this.assertFalse(widget.hasCssClass("exclude"), "Hide: Exclude class set");
        this.assertEquals("visible", widget._getStyle("visibility"), "Show: Visibility style should be visible");
      },
      testEnabled: function testEnabled() {
        var widget = new qx.ui.mobile.core.Widget();
        this.getRoot().add(widget);
        this.assertEquals(true, widget.getEnabled());
        this.assertFalse(qx.bom.element.Class.has(widget.getContainerElement(), 'disabled'));
        widget.setEnabled(false);
        this.assertEquals(false, widget.getEnabled());
        this.assertEquals(true, qx.bom.element.Class.has(widget.getContainerElement(), 'disabled'));
        this.assertEquals('none', qx.bom.element.Style.get(widget.getContainerElement(), 'pointerEvents'));
        widget.destroy();
        widget = new qx.ui.mobile.core.Widget();
        this.getRoot().add(widget);
        widget.setEnabled(true);
        widget.setAnonymous(true);
        this.assertFalse(qx.bom.element.Class.has(widget.getContainerElement(), 'disabled'));
        this.assertEquals('none', qx.bom.element.Style.get(widget.getContainerElement(), 'pointerEvents'));
        widget.setEnabled(false);
        this.assertEquals(true, qx.bom.element.Class.has(widget.getContainerElement(), 'disabled'));
        this.assertEquals('none', qx.bom.element.Style.get(widget.getContainerElement(), 'pointerEvents'));
        widget.setEnabled(true);
        this.assertEquals('none', qx.bom.element.Style.get(widget.getContainerElement(), 'pointerEvents'));
        widget.destroy();
      },
      testToggleCss: function testToggleCss() {
        var widget = new qx.ui.mobile.core.Widget();
        this.getRoot().add(widget);
        widget.toggleCssClass("test");
        this.assertTrue(widget.hasCssClass("test"));
        widget.toggleCssClass("test");
        this.assertFalse(widget.hasCssClass("test"));
        widget.destroy();
      }
    }
  });
  qx.test.mobile.core.Widget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.data.Array": {},
      "qx.ui.mobile.dialog.Menu": {},
      "qx.bom.element.Style": {},
      "qx.bom.element.Dimension": {},
      "qx.ui.mobile.dialog.Popup": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.dialog.Menu", {
    extend: qx.test.mobile.MobileTestCase,
    include: [qx.dev.unit.MMock],
    members: {
      testInit: function testInit() {
        // SMOKE TEST for menu.
        var model = new qx.data.Array(["item1", "item2", "item3"]);
        var model2 = new qx.data.Array(["item4", "item5", "item6"]);
        var menu = new qx.ui.mobile.dialog.Menu(model);
        menu.setSelectedIndex(2);
        menu.setItems(model2);
        menu.setSelectedIndex(1);
        menu.destroy();
      },
      testSetListHeight: function testSetListHeight() {
        var model = new qx.data.Array(["item1", "item2", "item3"]);
        var menu = new qx.ui.mobile.dialog.Menu(model);
        var visibleItems = 2;
        menu.setVisibleListItems(visibleItems);
        menu.show();
        var expected = menu.getSelectionList().getListItemHeight() * visibleItems;
        var listHeight = qx.bom.element.Style.get(menu._getListScroller().getContentElement(), "height");
        listHeight = Math.floor(parseFloat(listHeight, 10) * 100);
        expected = Math.floor(expected * 100);
        this.assertEquals(listHeight, expected);
        menu.destroy();
      },
      testMaxListHeight: function testMaxListHeight() {
        var stub = this.stub(qx.bom.element.Dimension, "getHeight", function () {
          return 500;
        });
        var model = new qx.data.Array(["item1", "item2", "item3", "item1", "item2", "item3", "item1", "item2", "item3", "item1", "item2", "item3", "item2", "item3", "item2", "item3", "item1", "item2", "item3", "item1", "item2", "item3"]);
        var menu = new qx.ui.mobile.dialog.Menu(model);
        menu.setVisibleListItems(1000);
        menu.show();
        var parentHeight = qx.ui.mobile.dialog.Popup.ROOT.getHeight();
        parentHeight = parseInt(parentHeight, 10);
        parentHeight = parentHeight * 0.75;
        var expectedListHeight = parseInt(parentHeight, 10);
        var listHeight = qx.bom.element.Style.get(menu._getListScroller().getContentElement(), "height");
        listHeight = parseInt(listHeight, 10);
        this.assertEquals(expectedListHeight, listHeight);
        menu.destroy();
        stub.restore();
      }
    }
  });
  qx.test.mobile.dialog.Menu.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.basic.Label": {},
      "qx.ui.mobile.dialog.Popup": {},
      "qx.ui.mobile.core.Blocker": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.dialog.Popup", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testShow: function testShow() {
        var label = new qx.ui.mobile.basic.Label("test");
        var popup = new qx.ui.mobile.dialog.Popup(label);
        this.assertFalse(popup.isVisible());
        popup.show();
        this.assertTrue(popup.isVisible());
        label.destroy();
        popup.destroy();
      },
      testShowHide: function testShowHide() {
        this.require(["debug"]);

        var popup = new qx.ui.mobile.dialog.Popup();
        var blocker = qx.ui.mobile.core.Blocker.getInstance();
        blocker.forceHide(); // Modal mode false test cases, no changes expected.

        popup.setModal(false);
        popup.show();
        this.assertTrue(popup.isVisible(), 'popup should be visible.');
        this.assertFalse(blocker.isShown(), 'Modal mode is false, blocker should be still hidden.');
        popup.hide();
        this.assertFalse(popup.isVisible(), 'popup should not be visible.');
        this.assertFalse(blocker.isShown(), 'Modal mode is false, called popup.hide(), blocker should be still hidden.');
        popup.show();
        this.assertFalse(blocker.isShown(), 'Modal mode is false, called popup.show(), blocker should be still hidden.');
        this.assertTrue(popup.isVisible(), 'popup should be visible.'); // Modal mode true test cases

        popup.setModal(true);
        popup.show();
        this.assertTrue(blocker.isShown(), 'Modal mode is true, called popup.show(), Blocker should be shown.');
        popup.hide();
        this.assertFalse(blocker.isShown(), 'Modal mode is true, called dialog.hide(), Blocker should not be shown.');
        popup.destroy();
      },
      hasDebug: function hasDebug() {
        return true;
      }
    }
  });
  qx.test.mobile.dialog.Popup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.embed.Html": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.embed.Html", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testHtml: function testHtml() {
        var html = new qx.ui.mobile.embed.Html("<strong>affe</strong>");
        this.getRoot().add(html);
        this.assertString(html.getHtml());
        this.assertEquals(html.getHtml(), "<strong>affe</strong>");
        this.assertEquals(html.getHtml(), html.getContentElement().innerHTML);
        this.assertEventFired(html, "changeHtml", function () {
          html.setHtml("");
        });
        this.assertEquals(html.getHtml(), "");
        this.assertEquals(html.getHtml(), html.getContentElement().innerHTML);
        html.destroy();
      }
    }
  });
  qx.test.mobile.embed.Html.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The Html widget embeds plain HTML code into the application
   *
   * *Example*
   *
   * Here is a little example of how to use the html widget.
   *
   * <pre class='javascript'>
   * var html = new qx.ui.mobile.embed.Html();
   * html.setHtml("<h1>Hello World</h1>");
   * </pre>
   *
   */
  qx.Class.define("qx.ui.mobile.embed.Html", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param html {String?null} Initial HTML content
     */
    construct: function construct(html) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (html) {
        this.setHtml(html);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Any text string which can contain HTML, too */
      html: {
        check: "String",
        init: null,
        nullable: true,
        event: "changeHtml",
        apply: "_applyHtml"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // property apply
      _applyHtml: function _applyHtml(value, old) {
        this._setHtml(value);
      }
    }
  });
  qx.ui.mobile.embed.Html.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.Button": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.Button", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testLabel: function testLabel() {
        var button = new qx.ui.mobile.form.Button("affe");
        this.getRoot().add(button);
        this.assertString(button.getLabel());
        this.assertEquals("affe", button.getLabel());
        this.assertEquals(button.getLabel(), button.getLabelWidget().getContentElement().innerHTML);
        this.assertEventFired(button, "changeLabel", function () {
          button.setLabel("");
        });
        this.assertEquals("", button.getLabel());
        this.assertEquals(button.getLabel(), button.getLabelWidget().getContentElement().innerHTML);
        button.destroy();
      }
    }
  });
  qx.test.mobile.form.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.CheckBox": {},
      "qx.bom.element.Class": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.CheckBox", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testValue: function testValue() {
        var checkBox = new qx.ui.mobile.form.CheckBox(false);
        this.getRoot().add(checkBox);
        this.assertEquals(false, checkBox.getValue());
        this.assertEquals(false, qxWeb(checkBox.getContainerElement()).hasClass("checked"));
        checkBox.setValue(true);
        this.assertEquals(true, checkBox.getValue());
        this.assertEquals(true, qxWeb(checkBox.getContainerElement()).hasClass("checked"));
        checkBox.destroy();
      },
      testEnabled: function testEnabled() {
        var checkBox = new qx.ui.mobile.form.CheckBox();
        this.getRoot().add(checkBox);
        checkBox.setEnabled(false);
        this.assertEquals(false, checkBox.getEnabled());
        this.assertEquals(true, qx.bom.element.Class.has(checkBox.getContainerElement(), 'disabled'));
        checkBox.destroy();
      }
    }
  });
  qx.test.mobile.form.CheckBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.renderer.Single": {},
      "qx.bom.element.Class": {},
      "qx.ui.mobile.form.Form": {},
      "qx.ui.mobile.form.TextField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.Form", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      __username: null,
      testValidation: function testValidation() {
        var form = this.__createForm();

        var renderer = new qx.ui.mobile.form.renderer.Single(form);
        this.getRoot().add(renderer);
        this.assertFalse(form.validate());
        this.assertEquals(2, renderer._getChildren()[1].getChildren().length);
        this.assertTrue(qx.bom.element.Class.has(renderer._getChildren()[1].getChildren()[1].getContainerElement(), 'invalid'));

        this.__username.setValue('myusername');

        this.assertTrue(form.validate());
        this.assertEquals(2, renderer._getChildren()[1].getChildren().length);
        this.assertFalse(qx.bom.element.Class.has(renderer._getChildren()[1]._getChildren()[1].getContainerElement(), 'invalid'));

        this.__username.dispose();

        renderer.dispose();
        form.dispose();
      },
      __createForm: function __createForm() {
        var form = new qx.ui.mobile.form.Form();
        var validationManager = form.getValidationManager();
        var username = this.__username = new qx.ui.mobile.form.TextField().set({
          placeholder: "Username"
        });
        username.setRequired(true);
        form.add(username, "Username: ");
        validationManager.add(username, function (value, item) {
          var valid = value != null && value.length > 3;

          if (!valid) {
            item.setInvalidMessage("username should have more than 3 characters!");
          }

          return valid;
        }, this);
        return form;
      }
    }
  });
  qx.test.mobile.form.Form.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.Button": {},
      "qx.ui.mobile.form.Group": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.Group", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testGroup: function testGroup() {
        var button = new qx.ui.mobile.form.Button("affe");
        var group = new qx.ui.mobile.form.Group();
        group.add(button);
        this.getRoot().add(button);
        group.destroy();
        button.destroy();
      }
    }
  });
  qx.test.mobile.form.Group.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * A group widget arranges several widgets visual.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var title = new qx.ui.mobile.form.Title("Group");
   *   var list = new qx.ui.mobile.list.List();
   *   var group = new qx.ui.mobile.form.Group([list]);
   *
   *   this.getRoot.add(title);
   *   this.getRoot.add(group);
   * </pre>
   *
   * This example creates a group and adds a list to it.
   */
  qx.Class.define("qx.ui.mobile.form.Group", {
    extend: qx.ui.mobile.container.Composite,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param widgets {qx.ui.mobile.core.Widget[]}
     * @param showBorder {Boolean?} initial value of the property showBorder.
     */
    construct: function construct(widgets, showBorder) {
      qx.ui.mobile.container.Composite.constructor.call(this);
      this.addCssClass("bordered");

      if (showBorder != null) {
        this.setShowBorder(showBorder);
      } // Convenience: Add all widgets of array to group.


      if (widgets) {
        for (var i = 0; i < widgets.length; i++) {
          this.add(widgets[i]);
        }
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "group"
      },

      /**
       * Defines whether a border should drawn around the group.
       */
      showBorder: {
        check: "Boolean",
        init: true,
        apply: "_onChangeShowBorder"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Reacts on change of showBorder property.
       */
      _onChangeShowBorder: function _onChangeShowBorder() {
        if (this.isShowBorder() == true) {
          this.addCssClass("bordered");
        } else {
          this.removeCssClass("bordered");
        }
      }
    }
  });
  qx.ui.mobile.form.Group.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.Label": {},
      "qx.ui.mobile.form.TextField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.Label", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testLabelForTarget: function testLabelForTarget() {
        var label = new qx.ui.mobile.form.Label("foo-label");
        var target = new qx.ui.mobile.form.TextField("foo");
        label.setLabelFor(target.getId());
        var foundValue = label.getContentElement().getAttribute("for");
        this.assertEquals(target.getId(), foundValue, "'For' attribute has an unexpected value.");
        label.destroy();
        target.destroy();
      },
      testDisableTarget: function testDisableTarget() {
        var label = new qx.ui.mobile.form.Label("foo-label");
        var target = new qx.ui.mobile.form.TextField("foo");
        target.setEnabled(false);
        label.setLabelFor(target.getId()); // check if state is considered before label.for is set.

        this.assertFalse(label.isEnabled());
        target.setEnabled(true);
        this.assertTrue(label.isEnabled());
        target.setEnabled(false);
        this.assertFalse(label.isEnabled());
        label.destroy();
        target.destroy();
      }
    }
  });
  qx.test.mobile.form.Label.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.NumberField": {},
      "qx.bom.element.Attribute": {},
      "qx.bom.element.Class": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.NumberField", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testValue: function testValue() {
        var numberField = new qx.ui.mobile.form.NumberField();
        this.getRoot().add(numberField);
        this.assertEquals('', numberField.getValue());
        this.assertEquals(null, qx.bom.element.Attribute.get(numberField.getContainerElement(), 'value'));
        this.assertEventFired(numberField, "changeValue", function () {
          numberField.setValue(15);
        });
        this.assertEquals(15, numberField.getValue());
        this.assertEquals(15, qx.bom.element.Attribute.get(numberField.getContainerElement(), 'value'));
        numberField.destroy();
      },
      testMinimum: function testMinimum() {
        var numberField = new qx.ui.mobile.form.NumberField();
        this.getRoot().add(numberField);
        this.assertEquals('', numberField.getMinimum());
        numberField.setMinimum(42.23);
        this.assertEquals(42.23, numberField.getMinimum());
        numberField.destroy();
      },
      testMaximum: function testMaximum() {
        var numberField = new qx.ui.mobile.form.NumberField();
        this.getRoot().add(numberField);
        this.assertEquals('', numberField.getMaximum());
        numberField.setMaximum(42.23);
        this.assertEquals(42.23, numberField.getMaximum());
        numberField.destroy();
      },
      testStep: function testStep() {
        var numberField = new qx.ui.mobile.form.NumberField();
        this.getRoot().add(numberField);
        this.assertEquals('', numberField.getStep());
        numberField.setStep(42.23);
        this.assertEquals(42.23, numberField.getStep());
        numberField.destroy();
      },
      testResetValue: function testResetValue() {
        var numberField = new qx.ui.mobile.form.NumberField();
        this.getRoot().add(numberField);
        this.assertEquals('', numberField.getValue());
        this.assertEquals(null, qx.bom.element.Attribute.get(numberField.getContainerElement(), 'value'));
        numberField.setValue(15);
        this.assertEquals(15, numberField.getValue());
        numberField.resetValue();
        this.assertEquals(null, qx.bom.element.Attribute.get(numberField.getContainerElement(), 'value'));
        this.assertEquals('', numberField.getValue());
        numberField.destroy();
      },
      testEnabled: function testEnabled() {
        var numberField = new qx.ui.mobile.form.NumberField();
        this.getRoot().add(numberField);
        this.assertEquals(true, numberField.getEnabled());
        this.assertFalse(qx.bom.element.Class.has(numberField.getContainerElement(), 'disabled'));
        numberField.setEnabled(false);
        this.assertEquals(false, numberField.getEnabled());
        this.assertEquals(true, qx.bom.element.Class.has(numberField.getContainerElement(), 'disabled'));
        numberField.destroy();
      }
    }
  });
  qx.test.mobile.form.NumberField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.RadioButton": {},
      "qx.ui.mobile.form.RadioGroup": {},
      "qx.bom.element.Class": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.RadioButton", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testConstruct: function testConstruct() {
        var radio1 = new qx.ui.mobile.form.RadioButton();
        var radio2 = new qx.ui.mobile.form.RadioButton();
        var radio3 = new qx.ui.mobile.form.RadioButton();
        var group = new qx.ui.mobile.form.RadioGroup(radio1, radio2, radio3);
        this.getRoot().add(radio1);
        this.getRoot().add(radio2);
        this.getRoot().add(radio3); // Verify: allow empty selection can only be false in this case,
        // so radio1 has to be true.

        this.assertEquals(true, radio1.getValue(), "Radio1 is expected to be true.");
        this.assertEquals(false, radio2.getValue(), "Radio2 is expected to be false.");
        this.assertEquals(false, radio3.getValue(), "Radio3 is expected to be false.");
        this.assertEquals(3, group.getItems().length); // Clean up tests

        radio1.destroy();
        radio2.destroy();
        radio3.destroy();
        group.dispose();
      },
      testValue: function testValue() {
        var radio1 = new qx.ui.mobile.form.RadioButton();
        var radio2 = new qx.ui.mobile.form.RadioButton();
        var radio3 = new qx.ui.mobile.form.RadioButton();
        var group = new qx.ui.mobile.form.RadioGroup();
        group.setAllowEmptySelection(true);
        group.add(radio1, radio2, radio3);
        this.getRoot().add(radio1);
        this.getRoot().add(radio2);
        this.getRoot().add(radio3); // Verify: initial all radios buttons should be disabled.

        this.assertEquals(false, radio1.getValue());
        this.assertEquals(false, radio2.getValue());
        this.assertEquals(false, radio3.getValue());
        this.assertEquals(false, radio1.hasCssClass("checked"));
        this.assertEquals(false, radio2.hasCssClass("checked"));
        this.assertEquals(false, radio3.hasCssClass("checked")); // Radio 1 enabled

        radio1.setValue(true); // Verify

        this.assertEquals(true, radio1.getValue());
        this.assertEquals(true, radio1.hasCssClass("checked"));
        this.assertEquals(false, radio2.getValue());
        this.assertEquals(false, radio3.getValue()); // Radio 3 enabled

        radio3.setValue(true); // Verify

        this.assertEquals(true, radio3.getValue());
        this.assertEquals(false, radio2.getValue());
        this.assertEquals(false, radio1.getValue()); // Clean up tests

        radio1.destroy();
        radio2.destroy();
        radio3.destroy();
        group.dispose();
      },
      testEnabled: function testEnabled() {
        var radio1 = new qx.ui.mobile.form.RadioButton();
        this.getRoot().add(radio1);
        radio1.setEnabled(false);
        this.assertEquals(false, radio1.getEnabled());
        this.assertEquals(true, qx.bom.element.Class.has(radio1.getContainerElement(), 'disabled'));
        radio1.destroy();
      }
    }
  });
  qx.test.mobile.form.RadioButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.RadioGroup": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The Radio button group for mobile usage.
   *
   * *Example*
   *
   * <pre class='javascript'>
   *    var form = new qx.ui.mobile.form.Form();
   *
   *    var radio1 = new qx.ui.mobile.form.RadioButton();
   *    var radio2 = new qx.ui.mobile.form.RadioButton();
   *    var radio3 = new qx.ui.mobile.form.RadioButton();
   *
   *    var radiogroup = new qx.ui.mobile.form.RadioGroup(radio1, radio2, radio3);
  
   *    form.add(radio1, "Germany");
   *    form.add(radio2, "UK");
   *    form.add(radio3, "USA");
   *
   *    this.getRoot.add(new qx.ui.mobile.form.renderer.Single(form));
   * </pre>
   *
   *
   */
  qx.Class.define("qx.ui.mobile.form.RadioGroup", {
    extend: qx.ui.form.RadioGroup
  });
  qx.ui.mobile.form.RadioGroup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.data.Array": {},
      "qx.ui.mobile.form.SelectBox": {},
      "qx.lang.Function": {},
      "qx.core.ValidationError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.SelectBox", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testValue: function testValue() {
        var dd = new qx.data.Array(["Item 1", "Item 2", "Item 3"]);
        var selectBox = new qx.ui.mobile.form.SelectBox();
        selectBox.setModel(dd); // Initial value '''

        this.assertEquals('', selectBox.getValue()); // Attempt to set value to "Item 3"

        selectBox.setValue("Item 3");
        this.assertEquals(2, selectBox.getSelection());
        this.assertEquals("Item 3", selectBox.getValue()); // Attempt to set invalid value occurs validation error.

        this.assertException(qx.lang.Function.bind(selectBox.setValue, selectBox, "Item 4"), qx.core.ValidationError, "Validation Error: Input value is out of model range", "An validation error is expected, because this value does not exists in model.");
        this.assertEquals("Item 3", selectBox.getValue(), "Nothing should be changed by input setValue('Item 4') because input value is not in model.");
        selectBox.destroy();
        dd.dispose();
        dd = null;
      },
      testNullable: function testNullable() {
        var model = new qx.data.Array(["Item 1", "Item 2", "Item 3"]);
        var selectBox = new qx.ui.mobile.form.SelectBox();
        selectBox.setModel(model); // Default case: nullable is true, selection is null.

        this.assertEquals(null, selectBox.getSelection(), "Default selection of SelectBox should be null."); // Switch to nullable true...

        selectBox.setNullable(false); // Attempt to set null value occurs validation error.

        this.assertException(qx.lang.Function.bind(selectBox.setSelection, selectBox, null), qx.core.ValidationError, "Validation Error: SelectBox is not nullable", "Value should not be accepted when SelectBox is not nullable."); // Switch to nullable true... try to set selection to null..

        selectBox.setNullable(true);
        selectBox.setSelection(null);
        this.assertEquals(null, selectBox.getSelection(), "Value should be null."); // After

        selectBox.destroy();
        model.dispose();
        model = null;
      },
      testSelectionNoModel: function testSelectionNoModel() {
        var selectBox = new qx.ui.mobile.form.SelectBox();
        this.assertException(qx.lang.Function.bind(selectBox.setSelection, selectBox, 4), qx.core.ValidationError, "Validation Error: Please apply model before selection", "A selection needs a model.");
        selectBox.destroy();
      },
      testResetValue: function testResetValue() {
        var model = new qx.data.Array(["Item 1", "Item 2", "Item 3"]);
        var selectBox = new qx.ui.mobile.form.SelectBox();
        selectBox.setModel(model);
        selectBox.setNullable(true);
        selectBox.setValue("Item 3");
        this.assertEquals(2, selectBox.getSelection());
        selectBox.resetValue();
        this.assertEquals(null, selectBox.getSelection()); // After

        selectBox.destroy();
        model.dispose();
        model = null;
      },
      testResetValueNotNullable: function testResetValueNotNullable() {
        var model = new qx.data.Array(["Item 1", "Item 2", "Item 3"]);
        var selectBox = new qx.ui.mobile.form.SelectBox();
        selectBox.setModel(model);
        selectBox.setNullable(false);
        selectBox.setValue("Item 3");
        this.assertEquals(2, selectBox.getSelection());
        selectBox.resetValue();
        this.assertEquals(0, selectBox.getSelection()); // After

        selectBox.destroy();
        model.dispose();
        model = null;
      },
      testSelection: function testSelection() {
        var model = new qx.data.Array(["Item 1", "Item 2", "Item 3"]);
        var selectBox = new qx.ui.mobile.form.SelectBox();
        selectBox.setModel(model); // Default value of selectedIndex after setting model is 0.

        this.assertEquals(null, selectBox.getSelection()); // Set selection success

        selectBox.setSelection(2);
        this.assertEquals(2, selectBox.getSelection());
        this.assertEquals("Item 3", selectBox.getValue()); // Set selection failure
        // Nothing is changed because invalid selectedIndex value.

        this.assertException(qx.lang.Function.bind(selectBox.setSelection, selectBox, 4), qx.core.ValidationError, "Validation Error: Input value is out of model range", "Exception assertion failed.");
        this.assertEquals(2, selectBox.getSelection());
        this.assertEquals("Item 3", selectBox.getValue()); // Negative values are not allowed. Nothing is changed.

        this.assertException(qx.lang.Function.bind(selectBox.setSelection, selectBox, -1), qx.core.ValidationError, "Validation Error: Input value is out of model range", "Exception assertion failed.");
        this.assertEquals(2, selectBox.getSelection());
        this.assertEquals("Item 3", selectBox.getValue()); // Only type Number is allowed. Nothing is changed.

        this.assertException(qx.lang.Function.bind(selectBox.setSelection, selectBox, "foo"), qx.core.ValidationError, "Validation Error: Input value is not a number", "Exception assertion failed.");
        this.assertEquals(2, selectBox.getSelection());
        this.assertEquals("Item 3", selectBox.getValue()); // After

        selectBox.destroy();
        model.dispose();
        model = null;
      }
    }
  });
  qx.test.mobile.form.SelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.Form": {},
      "qx.ui.mobile.form.Button": {},
      "qx.ui.mobile.form.TextField": {},
      "qx.data.Array": {},
      "qx.ui.mobile.form.SelectBox": {},
      "qx.ui.mobile.form.renderer.Single": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.SingleRenderer", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      __form: null,
      __b: null,
      __t: null,
      __s: null,
      setUp: function setUp() {
        qx.test.mobile.form.SingleRenderer.prototype.setUp.base.call(this);
        this.__form = new qx.ui.mobile.form.Form();
        this.__b = new qx.ui.mobile.form.Button("a");

        this.__form.addButton(this.__b);

        this.__t = new qx.ui.mobile.form.TextField("test");

        this.__form.add(this.__t, "label");

        var dd = new qx.data.Array(["1"]);
        this.__s = new qx.ui.mobile.form.SelectBox();

        this.__s.setModel(dd);

        this.__form.add(this.__s, "select");

        this.__renderer = new qx.ui.mobile.form.renderer.Single(this.__form);
        this.getRoot().add(this.__renderer);
      },
      tearDown: function tearDown() {
        this.__b.dispose();

        this.__t.dispose();

        this.__s.dispose();

        this.__form.dispose();

        this.__renderer.dispose();

        qx.test.mobile.form.SingleRenderer.prototype.tearDown.base.call(this);
      },
      testShowHideRow: function testShowHideRow() {
        this.__renderer.hideItem(this.__b);

        var isHidden = this.__b.getLayoutParent().hasCssClass("exclude");

        this.assertTrue(isHidden, "Buttons parent is expected to contain 'exclude' class");

        this.__renderer.showItem(this.__b);

        isHidden = this.__b.getLayoutParent().hasCssClass("exclude");
        this.assertFalse(isHidden, "Button parent is expected to not contain 'exclude' class anymore");
      },
      testItemRow: function testItemRow() {
        this.assertNotNull(this.__renderer._getChildren()[0]);
        this.assertTrue(2 === this.__renderer._getChildren()[1]._getChildren().length); // we have a label and a form element in the row
      },
      testButtonRow: function testButtonRow() {
        this.assertNotNull(this.__renderer._getChildren()[5]);

        var buttonRowLength = this.__renderer._getChildren()[5]._getChildren().length;

        this.assertTrue(1 === buttonRowLength); // we have only the button in the row
      },
      testTwoLinesRow: function testTwoLinesRow() {
        this.assertNotNull(this.__renderer._getChildren()[3]);

        var rowLength = this.__renderer._getChildren()[3]._getChildren().length;

        this.assertTrue(2 === rowLength);
      }
    }
  });
  qx.test.mobile.form.SingleRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.Slider": {},
      "qx.bom.element.Dataset": {},
      "qx.bom.element.Class": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.Slider", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testValue: function testValue() {
        var slider = new qx.ui.mobile.form.Slider().set({
          "step": 4.5
        });
        this.getRoot().add(slider);
        this.assertEquals(0, slider.getValue());
        this.assertEquals(0, qx.bom.element.Dataset.get(slider._getKnobElement(), "value"));
        this.assertEquals(0, qx.bom.element.Dataset.get(slider._getKnobElement(), "percent"));
        this.assertEventFired(slider, "changeValue", function () {
          slider.nextValue();
        }, function (evt) {
          this.assertEquals(4.5, evt.getData());
        }.bind(this));
        this.assertEventFired(slider, "changeValue", function () {
          slider.setValue(11);
        }, function (evt) {
          this.assertEquals(11, evt.getData());
        }.bind(this));
        this.assertEventFired(slider, "changeValue", function () {
          slider.previousValue();
        }, function (evt) {
          this.assertEquals(6.5, evt.getData());
        }.bind(this));
        slider.destroy();
      },
      testEnabled: function testEnabled() {
        var slider = new qx.ui.mobile.form.Slider();
        this.getRoot().add(slider);
        slider.setEnabled(false);
        this.assertEquals(false, slider.getEnabled());
        this.assertEquals(true, qx.bom.element.Class.has(slider.getContainerElement(), 'disabled'));
        slider.destroy();
      }
    }
  });
  qx.test.mobile.form.Slider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.mobile.form.MState": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.form.INumberForm": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.event.Registration": {},
      "qx.bom.element.Dimension": {},
      "qx.bom.element.Location": {},
      "qx.bom.AnimationFrame": {},
      "qx.bom.element.Style": {},
      "qx.bom.element.Attribute": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The Slider widget provides horizontal slider.
   *
   * The Slider is the classic widget for controlling a bounded value.
   * It lets the user move a slider handle along a horizontal
   * groove and translates the handle's position into an integer value
   * within the defined range.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *    var slider= new qx.ui.mobile.form.Slider().set({
   *       minimum : 0,
   *       maximum : 10,
   *       step : 2
   *     });
   *     slider.addListener("changeValue", handler, this);
   *
   *   this.getRoot.add(slider);
   * </pre>
   *
   * This example creates a slider and attaches an
   * event listener to the {@link #changeValue} event.
   */
  qx.Class.define("qx.ui.mobile.form.Slider", {
    extend: qx.ui.mobile.core.Widget,
    include: [qx.ui.mobile.form.MValue, qx.ui.form.MForm, qx.ui.form.MModelProperty, qx.ui.mobile.form.MState],
    implement: [qx.ui.form.IForm, qx.ui.form.IModel, qx.ui.form.INumberForm],
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);

      this._registerEventListener();

      this._refresh();

      this.addCssClass("gap");
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "slider"
      },

      /**
       * The minimum slider value (may be negative). This value must be smaller
       * than {@link #maximum}.
       */
      minimum: {
        check: "Number",
        init: 0,
        apply: "_refresh",
        event: "changeMinimum"
      },

      /**
       * The maximum slider value (may be negative). This value must be larger
       * than {@link #minimum}.
       */
      maximum: {
        check: "Number",
        init: 100,
        apply: "_refresh",
        event: "changeMaximum"
      },

      /**
       * The amount to increment on each event. Typically corresponds
       * to the user moving the knob.
       */
      step: {
        check: "Number",
        init: 1,
        event: "changeStep"
      },

      /**
       * Reverses the display direction of the slider knob. If true, the maxmium of
       * the slider is on the left side and minimum on the right side.
       */
      reverseDirection: {
        check: "Boolean",
        init: false,
        apply: "_refresh"
      },

      /**
       * Adjusts which slider value should be displayed inside the knob.
       * If <code>null</code> no value will be displayed.
       */
      displayValue: {
        init: "percent",
        check: ["value", "percent"],
        nullable: true,
        apply: "_applyDisplayValue"
      }
    },
    members: {
      _knobElement: null,
      _containerElementWidth: null,
      _containerElementLeft: null,
      _pixelPerStep: null,
      __value: 0,

      /**
       * Increments the current value.
       */
      nextValue: function nextValue() {
        this.setValue(this.getValue() + this.getStep());
      },

      /**
       * Decrements the current value.
       */
      previousValue: function previousValue() {
        this.setValue(this.getValue() - this.getStep());
      },
      // overridden
      _createContainerElement: function _createContainerElement() {
        var container = qx.ui.mobile.form.Slider.prototype._createContainerElement.base.call(this);

        container.appendChild(this._createKnobElement());
        return container;
      },

      /**
       * Creates the knob element.
       *
       * @return {Element} The created knob element
       */
      _createKnobElement: function _createKnobElement() {
        return qx.dom.Element.create("div");
      },

      /**
       * Registers all needed event listener.
       */
      _registerEventListener: function _registerEventListener() {
        this.addListener("pointerdown", this._onPointerDown, this);
        this.addListener("track", this._onTrack, this);
        this.addListener("appear", this._refresh, this);
        qx.event.Registration.addListener(window, "resize", this._refresh, this);
        qx.event.Registration.addListener(window, "orientationchange", this._refresh, this);
        this.addListenerOnce("domupdated", this._refresh, this);
      },

      /**
       * Unregisters all needed event listener.
       */
      _unregisterEventListener: function _unregisterEventListener() {
        this.removeListener("pointerdown", this._onPointerDown, this);
        this.removeListener("track", this._onTrack, this);
        this.removeListener("appear", this._refresh, this);
        qx.event.Registration.removeListener(window, "resize", this._refresh, this);
        qx.event.Registration.removeListener(window, "orientationchange", this._refresh, this);
        this.removeListener("domupdated", this._refresh, this);
      },

      /**
       * Refreshes the slider and the knob position.
       */
      _refresh: function _refresh() {
        this._updateSizes();

        this._updateKnobPosition();
      },

      /**
       * Updates all internal sizes of the slider.
       */
      _updateSizes: function _updateSizes() {
        var containerElement = this.getContainerElement();

        if (containerElement) {
          this._containerElementWidth = qx.bom.element.Dimension.getWidth(containerElement);
          this._containerElementLeft = qx.bom.element.Location.getLeft(containerElement);
          this._pixelPerStep = this._getPixelPerStep(this._containerElementWidth);
        }
      },

      /**
       * Event handler. Called when the <code>pointerdown</code> event occurs.
       *
       * @param evt {qx.event.type.Pointer} The pointer event.
       */
      _onPointerDown: function _onPointerDown(evt) {
        if (evt.isPrimary()) {
          this._updateSizes();

          var position = this._getPosition(evt.getDocumentLeft());

          this.setValue(this._positionToValue(position));
          evt.stopPropagation();
        }
      },

      /**
       * Event handler. Called when the <code>track</code> event occurs.
       *
       * @param evt {qx.event.type.Track} The track event.
       */
      _onTrack: function _onTrack(evt) {
        var position = this._getPosition(evt.getDocumentLeft());

        this.setValue(this._positionToValue(position));
        evt.stopPropagation();
        evt.preventDefault();
      },

      /**
       * Returns the current position of the knob.
       *
       * @param documentLeft {Integer} The left position of the knob
       * @return {Integer} The current position of the container element.
       */
      _getPosition: function _getPosition(documentLeft) {
        return documentLeft - this._containerElementLeft;
      },

      /**
       * Returns the knob DOM element.
       *
       * @return {Element} The knob DOM element.
       */
      _getKnobElement: function _getKnobElement() {
        if (!this._knobElement) {
          var element = this.getContainerElement();

          if (element) {
            this._knobElement = element.childNodes[0];
          }
        }

        return this._knobElement;
      },

      /**
       * Sets the value of this slider.
       * It is called by setValue method of qx.ui.mobile.form.MValue mixin
       * @param value {Integer} the new value of the slider
       */
      _setValue: function _setValue(value) {
        this.__value = value;
        qx.bom.AnimationFrame.request(this._refresh, this);
      },

      /**
       * Gets the value [true/false] of this slider.
       * It is called by getValue method of qx.ui.mobile.form.MValue mixin
       * @return {Integer} the value of the slider
       */
      _getValue: function _getValue() {
        return this.__value;
      },

      /**
       * Updates the knob position based on the current value.
       */
      _updateKnobPosition: function _updateKnobPosition() {
        var percent = this._valueToPercent(this.getValue());

        var width = this._containerElementWidth;
        var position = Math.floor(this._percentToPosition(width, percent));

        var knobElement = this._getKnobElement();

        if (knobElement) {
          qx.bom.element.Style.set(this._getKnobElement(), "width", width - (width - position) + "px");
          qx.bom.element.Attribute.set(this._getKnobElement(), "data-value", this.getValue());
          qx.bom.element.Attribute.set(this._getKnobElement(), "data-percent", Math.floor(percent));
        }
      },
      // Property apply
      _applyDisplayValue: function _applyDisplayValue(value, old) {
        if (old != null) {
          this.removeCssClass(old);
        }

        if (value != null) {
          this.addCssClass(value);
        }
      },

      /**
       * Converts the given value to percent.
       *
       * @param value {Integer} The value to convert
       * @return {Integer} The value in percent
       */
      _valueToPercent: function _valueToPercent(value) {
        var min = this.getMinimum();

        var value = this._limitValue(value);

        var percent = (value - min) * 100 / this._getRange();

        if (this.isReverseDirection()) {
          return 100 - percent;
        } else {
          return percent;
        }
      },

      /**
       * Converts the given position to the corresponding value.
       *
       * @param position {Integer} The position to convert
       * @return {Integer} The converted value
       */
      _positionToValue: function _positionToValue(position) {
        var value = this.getMinimum() + Math.round(position / this._pixelPerStep) * this.getStep();
        value = this._limitValue(value);

        if (this.isReverseDirection()) {
          var center = this.getMinimum() + this._getRange() / 2;
          var dist = center - value;
          value = center + dist;
        }

        return value;
      },

      /**
       * Converts the given percent to the position of the knob.
       *
       * @param width {Integer} The width of the slider container element
       * @param percent {Integer} The percent to convert
       * @return {Integer} The position of the knob
       */
      _percentToPosition: function _percentToPosition(width, percent) {
        return width * (percent / 100);
      },

      /**
       * Limits a value to the set {@link #minimum} and {@link #maximum} properties.
       *
       * @param value {Integer} The value to limit
       * @return {Integer} The limited value
       */
      _limitValue: function _limitValue(value) {
        value = Math.min(value, this.getMaximum());
        value = Math.max(value, this.getMinimum());
        return value;
      },

      /**
       * Return the number of pixels per step.
       *
       * @param width {Integer} The width of the slider container element
       * @return {Integer} The pixels per step
       */
      _getPixelPerStep: function _getPixelPerStep(width) {
        return width / this._getOverallSteps();
      },

      /**
       * Return the overall number of steps.
       *
       * @return {Integer} The number of steps
       */
      _getOverallSteps: function _getOverallSteps() {
        return this._getRange() / this.getStep();
      },

      /**
       * Return the range between {@link #maximum} and {@link #minimum}.
       *
       * @return {Integer} The range between {@link #maximum} and {@link #minimum}
       */
      _getRange: function _getRange() {
        return this.getMaximum() - this.getMinimum();
      }
    },
    destruct: function destruct() {
      this._knobElement = null;

      this._unregisterEventListener();
    }
  });
  qx.ui.mobile.form.Slider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.TextArea": {},
      "qx.bom.element.Attribute": {},
      "qx.bom.element.Class": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.TextArea", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testValue: function testValue() {
        var textArea = new qx.ui.mobile.form.TextArea();
        this.getRoot().add(textArea);
        this.assertEquals('', textArea.getValue());
        this.assertEquals(null, qx.bom.element.Attribute.get(textArea.getContainerElement(), 'value'));
        this.assertEventFired(textArea, "changeValue", function () {
          textArea.setValue("mytext");
        });
        this.assertEquals('mytext', textArea.getValue());
        this.assertEquals('mytext', qx.bom.element.Attribute.get(textArea.getContainerElement(), 'value'));
        textArea.destroy();
        textArea = new qx.ui.mobile.form.TextArea('affe');
        this.getRoot().add(textArea);
        this.assertEquals('affe', textArea.getValue());
        this.assertEquals('affe', qx.bom.element.Attribute.get(textArea.getContainerElement(), 'value'));
        textArea.destroy();
      },
      testEnabled: function testEnabled() {
        var textArea = new qx.ui.mobile.form.TextArea();
        this.getRoot().add(textArea);
        this.assertEquals(true, textArea.getEnabled());
        this.assertFalse(qx.bom.element.Class.has(textArea.getContainerElement(), 'disabled'));
        textArea.setEnabled(false);
        this.assertEquals(false, textArea.getEnabled());
        this.assertEquals(true, qx.bom.element.Class.has(textArea.getContainerElement(), 'disabled'));
        textArea.destroy();
      }
    }
  });
  qx.test.mobile.form.TextArea.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.TextField": {},
      "qx.bom.element.Attribute": {},
      "qx.bom.element.Class": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.TextField", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testValue: function testValue() {
        var textField = new qx.ui.mobile.form.TextField();
        this.getRoot().add(textField);
        this.assertEquals('', textField.getValue());
        this.assertEquals(null, qx.bom.element.Attribute.get(textField.getContainerElement(), 'value'));
        this.assertEventFired(textField, "changeValue", function () {
          textField.setValue("mytext");
        });
        this.assertEquals('mytext', textField.getValue());
        this.assertEquals('mytext', qx.bom.element.Attribute.get(textField.getContainerElement(), 'value'));
        textField.destroy();
        textField = new qx.ui.mobile.form.TextField('affe');
        this.getRoot().add(textField);
        this.assertEquals('affe', textField.getValue());
        this.assertEquals('affe', qx.bom.element.Attribute.get(textField.getContainerElement(), 'value'));
        textField.destroy();
      },
      testEnabled: function testEnabled() {
        var textField = new qx.ui.mobile.form.TextField();
        this.getRoot().add(textField);
        this.assertEquals(true, textField.getEnabled());
        this.assertFalse(qx.bom.element.Class.has(textField.getContainerElement(), 'disabled'));
        textField.setEnabled(false);
        this.assertEquals(false, textField.getEnabled());
        this.assertEquals(true, qx.bom.element.Class.has(textField.getContainerElement(), 'disabled'));
        textField.destroy();
      }
    }
  });
  qx.test.mobile.form.TextField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.form.ToggleButton": {},
      "qx.bom.element.Class": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.form.ToggleButton", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testValue: function testValue() {
        var button = new qx.ui.mobile.form.ToggleButton(true);
        this.getRoot().add(button);
        this.assertBoolean(button.getValue());
        this.assertTrue(button.getValue());
        this.assertTrue(qx.bom.element.Class.has(button.getContentElement(), "checked"));
        this.assertEventFired(button, "changeValue", function () {
          button.setValue(false);
        });
        this.assertFalse(button.getValue());
        button.destroy();
      },
      testToggle: function testToggle() {
        var button = new qx.ui.mobile.form.ToggleButton(true);
        this.getRoot().add(button);
        this.assertBoolean(button.getValue());
        this.assertTrue(button.getValue());
        button.toggle();
        this.assertFalse(button.getValue());
        button.toggle();
        this.assertTrue(button.getValue());
        button.destroy();
      }
    }
  });
  qx.test.mobile.form.ToggleButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.Card": {},
      "qx.ui.mobile.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.layout.Card", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testAdd: function testAdd() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.Card());
        this.getRoot().add(composite);
        this.assertTrue(composite.hasCssClass("layout-card"));
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        this.assertTrue(widget1.hasCssClass("layout-card-item"));
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);
        this.assertTrue(widget2.hasCssClass("layout-card-item"));
        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      testRemove: function testRemove() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.Card());
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        composite.remove(widget1);
        this.assertFalse(widget1.hasCssClass("layout-card-item"));
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);
        composite.remove(widget2);
        this.assertFalse(widget2.hasCssClass("layout-card-item"));
        this.getRoot().remove(composite);
        this.assertTrue(composite.hasCssClass("layout-card"));
        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      testReset: function testReset() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.Card());
        this.getRoot().add(composite);
        composite.setLayout(null);
        this.assertFalse(composite.hasCssClass("layout-card"));
        composite.destroy();
      },
      testShow: function testShow() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.Card());
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);
        widget1.show();
        widget2.show();
        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      }
    }
  });
  qx.test.mobile.layout.Card.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.layout.HBox", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testAdd: function testAdd() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox());
        this.getRoot().add(composite);
        this.assertTrue(composite.hasCssClass("qx-hbox"));
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);
        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      testFlex: function testFlex() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox());
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1, {
          flex: 1
        });
        this.assertTrue(widget1.hasCssClass("qx-flex1"));
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2, {
          flex: 2
        });
        this.assertTrue(widget2.hasCssClass("qx-flex2"));
        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      testRemove: function testRemove() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox());
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1, {
          flex: 1
        });
        composite.remove(widget1);
        this.assertFalse(widget1.hasCssClass("qx-flex1"));
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2, {
          flex: 2
        });
        composite.remove(widget2);
        this.assertFalse(widget2.hasCssClass("qx-flex2"));
        this.getRoot().remove(composite);
        this.assertTrue(composite.hasCssClass("qx-hbox"));
        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      testReset: function testReset() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox());
        this.getRoot().add(composite);
        composite.setLayout(null);
        this.assertFalse(composite.hasCssClass("qx-hbox"));
        composite.destroy();
      }
    }
  });
  qx.test.mobile.layout.HBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.layout.VBox", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testAdd: function testAdd() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
        this.getRoot().add(composite);
        this.assertTrue(composite.hasCssClass("qx-vbox"));
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1);
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2);
        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      testFlex: function testFlex() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1, {
          flex: 1
        });
        this.assertTrue(widget1.hasCssClass("qx-flex1"));
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2, {
          flex: 2
        });
        this.assertTrue(widget2.hasCssClass("qx-flex2"));
        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      testRemove: function testRemove() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
        this.getRoot().add(composite);
        var widget1 = new qx.ui.mobile.core.Widget();
        composite.add(widget1, {
          flex: 1
        });
        composite.remove(widget1);
        this.assertFalse(widget1.hasCssClass("qx-flex1"));
        var widget2 = new qx.ui.mobile.core.Widget();
        composite.add(widget2, {
          flex: 2
        });
        composite.remove(widget2);
        this.assertFalse(widget2.hasCssClass("qx-flex2"));
        this.getRoot().remove(composite);
        this.assertTrue(composite.hasCssClass("qx-vbox"));
        widget1.destroy();
        widget2.destroy();
        composite.destroy();
      },
      testReset: function testReset() {
        var composite = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
        this.getRoot().add(composite);
        composite.setLayout(null);
        this.assertFalse(composite.hasCssClass("qx-vbox"));
        composite.destroy();
      }
    }
  });
  qx.test.mobile.layout.VBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.data.Array": {},
      "qx.ui.mobile.list.List": {},
      "qx.ui.mobile.list.renderer.Default": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /* ************************************************************************
  ************************************************************************ */

  /**
   *
   * @asset(qx/icon/Tango/48/places/folder.png)
   */
  qx.Class.define("qx.test.mobile.list.List", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      /**
      * Returns the img element on the given list, of the element item identified by elementIndex.
      */
      getImageElement: function getImageElement(list, elementIndex) {
        return list.getContentElement().childNodes[elementIndex].childNodes[0];
      },

      /**
      * Returns the title text on the given list, of the element item identified by elementIndex.
      */
      getTitleElement: function getTitleElement(list, elementIndex) {
        return list.getContentElement().childNodes[elementIndex].childNodes[1].childNodes[0];
      },

      /**
       * Returns the subtitle text on the given list, of the element item identified by elementIndex.
       */
      getSubtitleElement: function getSubtitleElement(list, elementIndex) {
        return list.getContentElement().childNodes[elementIndex].childNodes[1].childNodes[1];
      },
      __createModel: function __createModel() {
        var data = [];
        data.push({
          title: "1",
          subtitle: "s1",
          image: "qx/icon/Tango/48/places/folder.png"
        });
        data.push({
          title: "2",
          subtitle: "s2",
          image: "qx/icon/Tango/48/places/folder.png"
        });
        data.push({
          title: "3",
          subtitle: "s3",
          image: "qx/icon/Tango/48/places/folder.png"
        });
        data.push({
          title: "4",
          subtitle: "s4",
          image: "qx/icon/Tango/48/places/folder.png"
        });
        data.push({
          title: "5",
          subtitle: "s5",
          image: "qx/icon/Tango/48/places/folder.png"
        });
        return new qx.data.Array(data);
      },
      __createList: function __createList(createItemRenderer, configureItemFunction) {
        var list = new qx.ui.mobile.list.List();
        this.getRoot().add(list);
        list.setDelegate({
          configureItem: configureItemFunction ? configureItemFunction : this.__configureItemFunction,
          createItemRenderer: createItemRenderer ? createItemRenderer : null
        });
        list.setModel(this.__createModel());
        return list;
      },
      __configureItemFunction: function __configureItemFunction(item, data, row) {
        item.setImage(data.image);
        item.setTitle(data.title);
        item.setSubtitle(data.subtitle);
      },
      __assertItemsAndModelLength: function __assertItemsAndModelLength(list, dataLength) {
        var childrenLength = list.getContentElement().childNodes.length;
        this.assertEquals(dataLength, childrenLength);
      },
      __cleanUp: function __cleanUp(list) {
        list.destroy();
        var modelData = list.getModel();

        if (modelData) {
          modelData.dispose();
          modelData = null;
        }
      },
      testCreate: function testCreate() {
        var list = this.__createList();

        this.__assertItemsAndModelLength(list, 5);

        this.__cleanUp(list);
      },
      testCustomRenderer: function testCustomRenderer() {
        var list = this.__createList(function () {
          return new qx.ui.mobile.list.renderer.Default();
        });

        this.__assertItemsAndModelLength(list, 5);

        this.__cleanUp(list);
      },
      testSetModelNull: function testSetModelNull() {
        var list = this.__createList(function () {
          return new qx.ui.mobile.list.renderer.Default();
        });

        this.__assertItemsAndModelLength(list, 5);

        list.getModel().dispose();
        list.setModel(null);

        this.__assertItemsAndModelLength(list, 0);

        this.__cleanUp(list);
      },
      testModelChangeRemove: function testModelChangeRemove() {
        var list = this.__createList(function () {
          return new qx.ui.mobile.list.renderer.Default();
        });

        this.__assertItemsAndModelLength(list, 5);

        list.getModel().removeAt(0);

        this.__assertItemsAndModelLength(list, 4);

        this.__cleanUp(list);
      },
      testModelChangeEdit: function testModelChangeEdit() {
        var list = this.__createList(function () {
          return new qx.ui.mobile.list.renderer.Default();
        });

        this.__assertItemsAndModelLength(list, 5);

        list.getModel().setItem(0, {
          title: "affe",
          subtitle: "1",
          image: "qx/icon/Tango/48/places/folder.png"
        });

        this.__assertItemsAndModelLength(list, 5);

        var titleText = this.getTitleElement(list, 0).innerHTML;
        this.assertEquals("affe", titleText);

        this.__cleanUp(list);
      },

      /** Test Case for [BUG #7267] for different length of edited string value. */
      testModelChangeStringLength: function testModelChangeStringLength() {
        var list = this.__createList(function () {
          return new qx.ui.mobile.list.renderer.Default();
        });

        this.__assertItemsAndModelLength(list, 5);

        var newImageSrc = "qx/icon/Tango/52/places/folder.png";
        var newTitleText = "Giraffe";
        var newSubtitleText = "subtitle1";
        list.getModel().setItem(0, {
          title: newTitleText,
          subtitle: newSubtitleText,
          image: newImageSrc
        });

        this.__assertItemsAndModelLength(list, 5);

        var titleText = this.getTitleElement(list, 0).innerHTML;
        ;
        var subtitleText = this.getSubtitleElement(list, 0).innerHTML;
        var imageSrc = this.getImageElement(list, 0).src; // VERIFY

        this.assertEquals(newTitleText, titleText);
        this.assertEquals(newSubtitleText, subtitleText);
        this.assertNotEquals("-1", imageSrc.indexOf(newImageSrc));

        this.__cleanUp(list);
      },
      testModelChangeAdd: function testModelChangeAdd() {
        var list = this.__createList(function () {
          return new qx.ui.mobile.list.renderer.Default();
        });

        this.__assertItemsAndModelLength(list, 5);

        list.getModel().push({
          title: "6",
          subtitle: "6",
          image: "qx/icon/Tango/48/places/folder.png"
        });

        this.__assertItemsAndModelLength(list, 6);

        this.__cleanUp(list);
      },
      testExtractRowsToRender: function testExtractRowsToRender() {
        var list = new qx.ui.mobile.list.List();
        this.assertArrayEquals([0], list._extractRowsToRender("0"));
        this.assertArrayEquals([0], list._extractRowsToRender("[0].propertyName"));
        this.assertArrayEquals([0, 1, 2], list._extractRowsToRender("[0-2].propertyName"));
        this.assertArrayEquals([12, 13, 14], list._extractRowsToRender("[12-14].propertyName"));
        list.destroy();
      }
    }
  });
  qx.test.mobile.list.List.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.navigationbar.NavigationBar": {},
      "qx.ui.mobile.navigationbar.BackButton": {},
      "qx.ui.mobile.navigationbar.Title": {},
      "qx.ui.mobile.navigationbar.Button": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.navigationbar.NavigationBar", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testCreate: function testCreate() {
        var bar = new qx.ui.mobile.navigationbar.NavigationBar();
        this.getRoot().add(bar);
        var back = new qx.ui.mobile.navigationbar.BackButton("Back");
        bar.add(back);
        var title = new qx.ui.mobile.navigationbar.Title("Title");
        bar.add(title);
        var button = new qx.ui.mobile.navigationbar.Button("Action");
        bar.add(button);
        this.assertEquals(3, bar.getChildren().length);
        back.destroy();
        title.destroy();
        button.destroy();
        bar.destroy();
      }
    }
  });
  qx.test.mobile.navigationbar.NavigationBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.page.Manager": {},
      "qx.ui.mobile.page.NavigationPage": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.page.Manager", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testCreate: function testCreate() {
        var manager = new qx.ui.mobile.page.Manager();
        manager.dispose();
      },
      testAddTablet: function testAddTablet() {
        var manager = new qx.ui.mobile.page.Manager(true);
        var page = new qx.ui.mobile.page.NavigationPage();
        manager.addMaster([page]);
        manager.addDetail([page]);
        manager.dispose();
      },
      testAddMobile: function testAddMobile() {
        var manager = new qx.ui.mobile.page.Manager(false);
        var page1 = new qx.ui.mobile.page.NavigationPage();
        var page2 = new qx.ui.mobile.page.NavigationPage();
        manager.addMaster([page1]);
        manager.addMaster([page2]);
        manager.dispose();
      }
    }
  });
  qx.test.mobile.page.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.bom.client.Device": {
        "construct": true
      },
      "qx.event.Registration": {
        "construct": true
      },
      "qx.bom.Viewport": {
        "construct": true
      },
      "qx.ui.mobile.container.Drawer": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.navigationbar.Button": {},
      "qx.ui.mobile.container.Navigation": {},
      "qx.lang.Type": {},
      "qx.ui.mobile.page.NavigationPage": {},
      "qx.lang.String": {},
      "qx.bom.element.Style": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "device.type": {
          "construct": true,
          "className": "qx.bom.client.Device"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The page manager decides automatically whether the added pages should be
   * displayed in a master/detail view (for tablet) or as a plain card layout (for
   * smartphones).
   *
   * *Example*
   *
   * Here is a little example of how to use the manager.
   *
   * <pre class='javascript'>
   *  var manager = new qx.ui.mobile.page.Manager();
   *  var page1 = new qx.ui.mobile.page.NavigationPage();
   *  var page2 = new qx.ui.mobile.page.NavigationPage();
   *  var page3 = new qx.ui.mobile.page.NavigationPage();
   *  manager.addMaster(page1);
   *  manager.addDetail([page2,page3]);
   *
   *  page1.show();
   * </pre>
   *
   *
   */
  qx.Class.define("qx.ui.mobile.page.Manager", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param isTablet {Boolean?} flag which triggers the manager to layout for tablet (or big screens/displays) or mobile devices. If parameter is null,
     * qx.core.Environment.get("device.type") is called for decision.
     * @param root {qx.ui.mobile.core.Widget?} widget which should be used as root for this manager.
     */
    construct: function construct(isTablet, root) {
      qx.core.Object.constructor.call(this);
      root = root || qx.core.Init.getApplication().getRoot();

      if (typeof isTablet !== "undefined" && isTablet !== null) {
        this.__isTablet = isTablet;
      } else {
        // If isTablet is undefined, call environment variable "device.type".
        // When "tablet" or "desktop" type >> do tablet layouting.
        this.__isTablet = qx.core.Environment.get("device.type") == "desktop" || qx.core.Environment.get("device.type") == "tablet";
      }

      this.__detailNavigation = this._createDetailNavigation();

      this.__detailNavigation.getNavigationBar().hide();

      if (this.__isTablet) {
        this.__masterNavigation = this._createMasterNavigation();

        this.__masterNavigation.getNavigationBar().hide();

        this.__masterContainer = this._createMasterContainer();
        this.__detailContainer = this._createDetailContainer();
        this.__masterButton = this._createMasterButton();

        this.__masterButton.addListener("tap", this._onMasterButtonTap, this);

        this.__hideMasterButton = this._createHideMasterButton();

        this.__hideMasterButton.addListener("tap", this._onHideMasterButtonTap, this);

        this.__masterNavigation.addListener("update", this._onMasterContainerUpdate, this);

        this.__detailNavigation.addListener("update", this._onDetailContainerUpdate, this);

        root.add(this.__detailContainer, {
          flex: 1
        });

        this.__masterContainer.add(this.__masterNavigation, {
          flex: 1
        });

        this.__detailContainer.add(this.__detailNavigation, {
          flex: 1
        });

        qx.event.Registration.addListener(window, "orientationchange", this._onLayoutChange, this);

        this.__masterContainer.addListener("resize", this._onLayoutChange, this); // On Tablet Mode, no Animation should be shown by default.


        this.__masterNavigation.getLayout().setShowAnimation(false);

        this.__detailNavigation.getLayout().setShowAnimation(false);

        this.__masterContainer.forceHide();

        setTimeout(function () {
          if (qx.bom.Viewport.isLandscape()) {
            this.__masterContainer.show();
          }
        }.bind(this), 300);
      } else {
        root.add(this.__detailNavigation, {
          flex: 1
        });
      }
    },
    properties: {
      /**
       * The caption/label of the Master Button and Popup Title.
       */
      masterTitle: {
        init: "Master",
        check: "String",
        apply: "_applyMasterTitle"
      },

      /**
       * The caption/label of the Hide Master Button.
       */
      hideMasterButtonCaption: {
        init: "Hide",
        check: "String",
        apply: "_applyHideMasterButtonCaption"
      },

      /**
       * This flag controls whether the MasterContainer can be hidden on Landscape.
       */
      allowMasterHideOnLandscape: {
        init: true,
        check: "Boolean"
      },

      /**
       *  This flag controls whether the MasterContainer hides on portrait view,
       *  when a Detail Page fires the lifecycle event "start".
       */
      hideMasterOnDetailStart: {
        init: true,
        check: "Boolean"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __isTablet: null,
      __detailNavigation: null,
      __masterNavigation: null,
      __masterButton: null,
      __hideMasterButton: null,
      __masterPages: null,
      __detailPages: null,
      __masterContainer: null,
      __detailContainer: null,

      /**
       * Creates the master container.
       *
       * @return {qx.ui.mobile.container.Composite} The created container
       */
      _createMasterContainer: function _createMasterContainer() {
        var masterContainer = new qx.ui.mobile.container.Drawer(null, new qx.ui.mobile.layout.HBox()).set({
          hideOnParentTap: false,
          hideOnBack: false
        });
        masterContainer.addCssClass("master-detail-master");
        masterContainer.addListener("changeVisibility", this._onMasterChangeVisibility, this);
        return masterContainer;
      },

      /**
       * Creates the detail container.
       *
       * @return {qx.ui.mobile.container.Composite} The created container
       */
      _createDetailContainer: function _createDetailContainer() {
        var detailContainer = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
        detailContainer.setDefaultCssClass("master-detail-detail");
        return detailContainer;
      },

      /**
       * Getter for the Master Container
       * @return {qx.ui.mobile.container.Drawer} The Master Container.
       */
      getMasterContainer: function getMasterContainer() {
        return this.__masterContainer;
      },

      /**
       * Getter for the Detail Container
       * @return {qx.ui.mobile.container.Composite} The Detail Container.
       */
      getDetailContainer: function getDetailContainer() {
        return this.__detailContainer;
      },

      /**
       * Returns the button for showing/hiding the masterContainer.
       * @return {qx.ui.mobile.navigationbar.Button}
       */
      getMasterButton: function getMasterButton() {
        return this.__masterButton;
      },

      /**
       * Returns the masterNavigation.
       * @return {qx.ui.mobile.container.Navigation}
       */
      getMasterNavigation: function getMasterNavigation() {
        return this.__masterNavigation;
      },

      /**
       * Returns the detailNavigation.
       * @return {qx.ui.mobile.container.Navigation}
       */
      getDetailNavigation: function getDetailNavigation() {
        return this.__detailNavigation;
      },

      /**
      * Factory method for the master button, which is responsible for showing/hiding masterContainer.
      * @return {qx.ui.mobile.navigationbar.Button}
      */
      _createMasterButton: function _createMasterButton() {
        return new qx.ui.mobile.navigationbar.Button(this.getMasterTitle());
      },

      /**
       * Factory method for the hide master button, which is responsible for hiding masterContainer on Landscape view.
       * @return {qx.ui.mobile.navigationbar.Button}
       */
      _createHideMasterButton: function _createHideMasterButton() {
        return new qx.ui.mobile.navigationbar.Button("Hide");
      },

      /**
      * Factory method for masterNavigation.
      * @return {qx.ui.mobile.container.Navigation}
      */
      _createMasterNavigation: function _createMasterNavigation() {
        return new qx.ui.mobile.container.Navigation();
      },

      /**
       * Factory method for detailNavigation.
       * @return {qx.ui.mobile.container.Navigation}
       */
      _createDetailNavigation: function _createDetailNavigation() {
        return new qx.ui.mobile.container.Navigation();
      },

      /**
       * Adds an array of NavigationPages to masterContainer, if __isTablet is true. Otherwise it will be added to detailContainer.
       * @param pages {qx.ui.mobile.page.NavigationPage[]|qx.ui.mobile.page.NavigationPage} Array of NavigationPages or single NavigationPage.
       */
      addMaster: function addMaster(pages) {
        if (this.__isTablet) {
          if (pages) {
            if (!qx.lang.Type.isArray(pages)) {
              pages = [pages];
            }

            for (var i = 0; i < pages.length; i++) {
              var masterPage = pages[i];
              masterPage.addListener("start", this._onMasterPageStart, this);
            }

            if (this.__masterPages) {
              this.__masterPages.concat(pages);
            } else {
              this.__masterPages = pages;
            }

            this._add(pages, this.__masterNavigation);
          }
        } else {
          this.addDetail(pages);
        }
      },

      /**
       * Adds an array of NavigationPage to the detailContainer.
       * @param pages {qx.ui.mobile.page.NavigationPage[]|qx.ui.mobile.page.NavigationPage} Array of NavigationPages or single NavigationPage.
       */
      addDetail: function addDetail(pages) {
        this._add(pages, this.__detailNavigation);

        if (pages && this.__isTablet) {
          if (!qx.lang.Type.isArray(pages)) {
            pages = [pages];
          }

          for (var i = 0; i < pages.length; i++) {
            var detailPage = pages[i];
            detailPage.addListener("start", this._onDetailPageStart, this);
          }

          if (this.__detailPages) {
            this.__detailPages.concat(pages);
          } else {
            this.__detailPages = pages;
          }
        }
      },

      /**
       * Called when a detailPage reaches lifecycle state "start".
       * @param evt {qx.event.type.Event} source event.
       */
      _onDetailPageStart: function _onDetailPageStart(evt) {
        if (qx.bom.Viewport.isPortrait() && this.isHideMasterOnDetailStart()) {
          this.__masterContainer.hide();
        }
      },

      /**
       * Called when a masterPage reaches lifecycle state "start". Then property masterTitle will be update with masterPage's title.
       * @param evt {qx.event.type.Event} source event.
       */
      _onMasterPageStart: function _onMasterPageStart(evt) {
        var masterPage = evt.getTarget();
        var masterPageTitle = masterPage.getTitle();
        this.setMasterTitle(masterPageTitle);
      },

      /**
       * Adds an array of NavigationPage to the target container.
       * @param pages {qx.ui.mobile.page.NavigationPage[]|qx.ui.mobile.page.NavigationPage} Array of NavigationPages, or NavigationPage.
       * @param target {qx.ui.mobile.container.Navigation} target navigation container.
       */
      _add: function _add(pages, target) {
        if (!qx.lang.Type.isArray(pages)) {
          pages = [pages];
        }

        for (var i = 0; i < pages.length; i++) {
          var page = pages[i];
          {
            this.assertInstance(page, qx.ui.mobile.page.NavigationPage);
          }

          if (this.__isTablet && !page.getShowBackButtonOnTablet()) {
            page.setShowBackButton(false);
          }

          page.setIsTablet(this.__isTablet);
          target.add(page);
        }
      },

      /**
       * Called when masterContainer is updated.
       * @param evt {qx.event.type.Data} source event.
       */
      _onMasterContainerUpdate: function _onMasterContainerUpdate(evt) {
        var widget = evt.getData();
        widget.getRightContainer().remove(this.__hideMasterButton);
        widget.getRightContainer().add(this.__hideMasterButton);
      },

      /**
       * Called when detailContainer is updated.
       * @param evt {qx.event.type.Data} source event.
       */
      _onDetailContainerUpdate: function _onDetailContainerUpdate(evt) {
        var widget = evt.getData();
        widget.getLeftContainer().remove(this.__masterButton);
        widget.getLeftContainer().add(this.__masterButton);
      },

      /**
      * Called when user taps on masterButton.
      */
      _onMasterButtonTap: function _onMasterButtonTap() {
        this.__masterContainer.show();
      },

      /**
      * Called when user taps on hideMasterButton.
      */
      _onHideMasterButtonTap: function _onHideMasterButtonTap() {
        this._removeDetailContainerGap();

        this.__masterContainer.hide();
      },

      /**
      * Event handler for <code>changeVisibility</code> event on master container.
      * @param evt {qx.event.type.Data} the change event.
      */
      _onMasterChangeVisibility: function _onMasterChangeVisibility(evt) {
        var isMasterVisible = "visible" === evt.getData();

        if (qx.bom.Viewport.isLandscape()) {
          if (this.isAllowMasterHideOnLandscape()) {
            if (isMasterVisible) {
              this._createDetailContainerGap();

              this.__masterButton.exclude();

              this.__hideMasterButton.show();
            } else {
              this.__masterButton.show();

              this.__hideMasterButton.show();
            }
          } else {
            this.__masterButton.exclude();

            this.__hideMasterButton.exclude();
          }
        } else {
          this._removeDetailContainerGap();

          this.__masterButton.show();

          this.__hideMasterButton.show();
        }
      },

      /**
      * Called when layout of masterDetailContainer changes.
      */
      _onLayoutChange: function _onLayoutChange() {
        if (this.__isTablet) {
          if (qx.bom.Viewport.isLandscape()) {
            this.__masterContainer.setHideOnParentTap(false);

            if (this.__masterContainer.isHidden()) {
              this.__masterContainer.show();
            } else {
              this._removeDetailContainerGap();

              this.__masterContainer.hide();
            }
          } else {
            this._removeDetailContainerGap();

            this.__masterContainer.setHideOnParentTap(true);

            this.__masterContainer.hide();
          }
        }
      },

      /**
      * Returns the corresponding CSS property key which fits to the drawer's orientation.
      * @return {String} the CSS property key.
      */
      _getGapPropertyKey: function _getGapPropertyKey() {
        return "padding" + qx.lang.String.capitalize(this.__masterContainer.getOrientation());
      },

      /**
       * Moves detailContainer to the right edge of MasterContainer.
       * Creates spaces for aligning master and detail container aside each other.
       */
      _createDetailContainerGap: function _createDetailContainerGap() {
        qx.bom.element.Style.set(this.__detailContainer.getContainerElement(), this._getGapPropertyKey(), this.__masterContainer.getSize() / 16 + "rem");
        qx.event.Registration.fireEvent(window, "resize");
      },

      /**
       * Moves detailContainer to the left edge of viewport.
       */
      _removeDetailContainerGap: function _removeDetailContainerGap() {
        qx.bom.element.Style.set(this.__detailContainer.getContainerElement(), this._getGapPropertyKey(), null);
        qx.event.Registration.fireEvent(window, "resize");
      },

      /**
      * Called on property changes of hideMasterButtonCaption.
      * @param value {String} new caption
      * @param old {String} previous caption
      */
      _applyHideMasterButtonCaption: function _applyHideMasterButtonCaption(value, old) {
        if (this.__isTablet) {
          this.__hideMasterButton.setLabel(value);
        }
      },

      /**
      * Called on property changes of masterTitle.
      * @param value {String} new title
      * @param old {String} previous title
      */
      _applyMasterTitle: function _applyMasterTitle(value, old) {
        if (this.__isTablet) {
          this.__masterButton.setLabel(value);
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this.__masterPages) {
        for (var i = 0; i < this.__masterPages.length; i++) {
          var masterPage = this.__masterPages[i];
          masterPage.removeListener("start", this._onMasterPageStart, this);
        }
      }

      if (this.___detailPages) {
        for (var j = 0; j < this.___detailPages.length; j++) {
          var detailPage = this.___detailPages[j];
          detailPage.removeListener("start", this._onDetailPageStart, this);
        }
      }

      if (this.__isTablet) {
        this.__masterContainer.removeListener("changeVisibility", this._onMasterChangeVisibility, this);

        this.__masterContainer.removeListener("resize", this._onLayoutChange, this);

        qx.event.Registration.removeListener(window, "orientationchange", this._onLayoutChange, this);
      }

      this.__masterPages = this.__detailPages = null;

      this._disposeObjects("__detailNavigation", "__masterNavigation", "__masterButton");
    }
  });
  qx.ui.mobile.page.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.page.NavigationPage": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.page.NavigationPage", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testNavigationInterface: function testNavigationInterface() {
        var page = new qx.ui.mobile.page.NavigationPage();
        this.assertNotNull(page.getTitleWidget());
        this.assertNotNull(page.getLeftContainer());
        this.assertNotNull(page.getRightContainer());
        page.destroy();
      },
      testTitle: function testTitle() {
        var page = new qx.ui.mobile.page.NavigationPage();
        page.setTitle("Affe");
        this.assertEquals("Affe", page.getTitleWidget().getValue());
        page.destroy();
      },
      testBackButton: function testBackButton() {
        var page = new qx.ui.mobile.page.NavigationPage();
        page.getLeftContainer();
        page.setShowBackButton(true);
        page.setBackButtonText("Affe");
        this.assertEquals("Affe", page._getBackButton().getValue());
        this.assertTrue(page._getBackButton().isVisible());
        page.setShowBackButton(false);
        this.assertFalse(page._getBackButton().isVisible());
        page.destroy();
      },
      testButton: function testButton() {
        var page = new qx.ui.mobile.page.NavigationPage();
        page.getRightContainer();
        page.setShowButton(true);
        page.setButtonText("Affe");
        this.assertEquals("Affe", page._getButton().getValue());
        this.assertTrue(page._getButton().isVisible());
        page.setShowButton(false);
        this.assertFalse(page._getButton().isVisible());
        page.destroy();
      }
    }
  });
  qx.test.mobile.page.NavigationPage.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.page.Page": {},
      "qx.core.Init": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.page.Page", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      testShow: function testShow() {
        var initializedEvent = false;
        var startEvent = false;
        var stopEvent = false;
        var page = new qx.ui.mobile.page.Page();
        this.getRoot().add(page);
        page.addListener("initialize", function () {
          this.assertFalse(startEvent, "Start event is fired before initialize event was fired!");
          initializedEvent = true;
        }, this);
        page.addListener("start", function () {
          this.assertTrue(initializedEvent, "Start event is fired before initialize event was fired!");
          startEvent = true;
        }, this);
        page.addListener("stop", function () {
          stopEvent = true;
        }, this);
        page.show();
        this.assertTrue(initializedEvent, "Initialize event is not fired!");
        this.assertTrue(startEvent, "Start event is not fired!");
        this.assertFalse(stopEvent, "Stop event is fired!");
        page.destroy();
      },
      testInitialize: function testInitialize() {
        this.__testEventOnPage("initialize");
      },
      testStart: function testStart() {
        this.__testEventOnPageAndApplication("start");
      },
      testStop: function testStop() {
        this.__testEventOnPageAndApplication("stop", function (page) {
          page.initialize();
        });
      },
      testPause: function testPause() {
        this.__testEventOnPage("pause");
      },
      testResume: function testResume() {
        this.__testEventOnPage("resume");
      },
      testWait: function testWait() {
        this.__testEventOnPage("wait");
      },
      testBack: function testBack() {
        this.__testEventOnPageAndApplication("back");
      },
      testPreventBack: function testPreventBack() {
        var page = new qx.ui.mobile.page.Page();
        this.getRoot().add(page);
        var eventFiredOnApplication = false;
        var eventFiredOnPage = false;
        var application = qx.core.Init.getApplication();
        var id = application.addListener("back", function (evt) {
          eventFiredOnApplication = true;
          evt.preventDefault();
        }, this);
        page.addListener("back", function () {
          eventFiredOnPage = true;
        }, this);
        page.back();
        this.assertTrue(eventFiredOnApplication, "The 'back' event on application is not fired!");
        this.assertFalse(eventFiredOnPage, "The 'back' event on page is fired!");
        application.removeListenerById(id);
        page.destroy();
      },
      testMenu: function testMenu() {
        this.__testEventOnPage("menu");
      },
      __testEventOnPage: function __testEventOnPage(name) {
        var page = new qx.ui.mobile.page.Page();
        this.getRoot().add(page);
        var isEventFired = false;
        page.addListener(name, function () {
          isEventFired = true;
        }, this);
        page[name]();
        this.assertTrue(isEventFired, "The '" + name + "' event is not fired!");
        page.destroy();
      },
      __testEventOnPageAndApplication: function __testEventOnPageAndApplication(name, beforeCallback) {
        var page = new qx.ui.mobile.page.Page();
        this.getRoot().add(page);
        var eventFiredOnApplication = false;
        var eventFiredOnPage = false;
        var application = qx.core.Init.getApplication();
        var id = application.addListener(name, function () {
          eventFiredOnApplication = true;
        }, this);
        page.addListener(name, function () {
          eventFiredOnPage = true;
        }, this);

        if (beforeCallback) {
          beforeCallback(page);
        }

        page[name]();
        this.assertTrue(eventFiredOnApplication, "The '" + name + "' event on application is not fired!");
        this.assertTrue(eventFiredOnPage, "The '" + name + "' event on page is not fired!");
        application.removeListenerById(id);
        page.destroy();
      }
    }
  });
  qx.test.mobile.page.Page.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.tabbar.TabBar": {},
      "qx.ui.mobile.tabbar.TabButton": {},
      "qx.ui.mobile.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.tabbar.TabBar", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      __createTabBar: function __createTabBar() {
        var tabBar = new qx.ui.mobile.tabbar.TabBar();
        this.getRoot().add(tabBar);
        return tabBar;
      },
      __assertChildNodesLength: function __assertChildNodesLength(tabBar, tabNumber) {
        var childrenLength = tabBar.getContentElement().childNodes.length;
        this.assertEquals(tabNumber, childrenLength);
      },
      testAdd: function testAdd() {
        var tabBar = this.__createTabBar();

        var button1 = new qx.ui.mobile.tabbar.TabButton("Button 1");
        tabBar.add(button1);

        this.__assertChildNodesLength(tabBar, 1);

        var button2 = new qx.ui.mobile.tabbar.TabButton("Button 2");
        tabBar.add(button2);

        this.__assertChildNodesLength(tabBar, 2);

        var button3 = new qx.ui.mobile.tabbar.TabButton("Button 3");
        tabBar.add(button3);

        this.__assertChildNodesLength(tabBar, 3);

        button1.destroy();
        button2.destroy();
        button3.destroy();
        tabBar.destroy();
      },
      testRemove: function testRemove() {
        var tabBar = this.__createTabBar();

        var button1 = new qx.ui.mobile.tabbar.TabButton("Button 1");
        tabBar.add(button1);
        var button2 = new qx.ui.mobile.tabbar.TabButton("Button 2");
        tabBar.add(button2);
        var button3 = new qx.ui.mobile.tabbar.TabButton("Button 3");
        tabBar.add(button3);

        this.__assertChildNodesLength(tabBar, 3);

        tabBar.remove(button2);

        this.__assertChildNodesLength(tabBar, 2);

        tabBar.remove(button1);

        this.__assertChildNodesLength(tabBar, 1);

        tabBar.remove(button3);

        this.__assertChildNodesLength(tabBar, 0);

        button1.destroy();
        button2.destroy();
        button3.destroy();
        tabBar.destroy();
      },
      testSelection: function testSelection() {
        var tabBar = this.__createTabBar();

        var button1 = new qx.ui.mobile.tabbar.TabButton();
        tabBar.add(button1);
        this.assertEquals(tabBar.getSelection(), button1);
        var button2 = new qx.ui.mobile.tabbar.TabButton();
        tabBar.add(button2);
        this.assertEquals(tabBar.getSelection(), button1);
        var button3 = new qx.ui.mobile.tabbar.TabButton();
        tabBar.add(button3);
        this.assertEquals(tabBar.getSelection(), button1);
        tabBar.setSelection(button2);
        this.assertEquals(tabBar.getSelection(), button2);
        tabBar.remove(button2);
        this.assertEquals(tabBar.getSelection(), null);
        this.assertEventFired(tabBar, "changeSelection", function () {
          tabBar.setSelection(button1);
        });
        button1.destroy();
        button2.destroy();
        button3.destroy();
        tabBar.destroy();
      },
      testView: function testView() {
        var tabBar = this.__createTabBar();

        var button1 = new qx.ui.mobile.tabbar.TabButton("Button 1");
        var view1 = new qx.ui.mobile.basic.Label("1");
        view1.exclude();
        button1.setView(view1);
        tabBar.add(button1);
        this.assertTrue(view1.isVisible());
        var button2 = new qx.ui.mobile.tabbar.TabButton("Button 2");
        tabBar.add(button2);
        var view2 = new qx.ui.mobile.basic.Label("2");
        button2.setView(view2);
        this.assertFalse(view2.isVisible());
        var button3 = new qx.ui.mobile.tabbar.TabButton("Button 3");
        tabBar.add(button3);
        tabBar.setSelection(button3);
        var view3 = new qx.ui.mobile.basic.Label("3");
        this.assertEventFired(button3, "changeView", function () {
          button3.setView(view3);
        });
        this.assertFalse(view1.isVisible());
        this.assertTrue(view3.isVisible());
        tabBar.remove(button3);
        this.assertFalse(view1.isVisible());
        this.assertFalse(view2.isVisible());
        this.assertFalse(view3.isVisible());
        button1.destroy();
        button2.destroy();
        button3.destroy();
        view1.destroy();
        view2.destroy();
        view3.destroy();
        tabBar.destroy();
      }
    }
  });
  qx.test.mobile.tabbar.TabBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.ui.mobile.tabbar.TabButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * This widget displays a tab bar.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var tabBar = new qx.ui.mobile.tabbar.TabBar();
   *   var tabButton1 = new qx.ui.mobile.tabbar.TabButton("Tab 1");
   *   tabButton1.setView(view1);
   *   tabBar.add(tabButton1);
   *   var tabButton2 = new qx.ui.mobile.tabbar.TabButton("Tab 2");
   *   tabButton2.setView(view2);
   *   tabBar.add(tabButton2);
   *
   *   this.getRoot.add(tabBar);
   * </pre>
   *
   * This example creates a tab bar and adds two tab buttons to it.
   */
  qx.Class.define("qx.ui.mobile.tabbar.TabBar", {
    extend: qx.ui.mobile.core.Widget,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);

      this._setLayout(new qx.ui.mobile.layout.HBox());

      this.addListener("tap", this._onTap, this);
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "tabBar"
      },

      /**
       * Sets the selected tab.
       */
      selection: {
        check: "qx.ui.mobile.tabbar.TabButton",
        nullable: true,
        init: null,
        apply: "_applySelection",
        event: "changeSelection"
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      /**
       * Event handler. Called when a tab event occurs.
       *
       * @param evt {qx.event.type.Tap} The event object
       */
      _onTap: function _onTap(evt) {
        var target = evt.getTarget();

        while (!(target instanceof qx.ui.mobile.tabbar.TabButton)) {
          if (target.getLayoutParent) {
            var layoutParent = target.getLayoutParent();

            if (layoutParent == null || layoutParent instanceof qx.ui.mobile.tabbar.TabBar) {
              target = null;
              break;
            }

            target = layoutParent;
          } else {
            target = null;
            break;
          }
        }

        if (target !== null) {
          this.setSelection(target);
        }
      },
      // property apply
      _applySelection: function _applySelection(value, old) {
        if (old) {
          old.removeCssClass("selected");

          if (old.getView()) {
            old.getView().exclude();
          }
        }

        if (value) {
          value.addCssClass("selected");

          if (value.getView()) {
            value.getView().show();
          }
        }
      },

      /**
       * Adds a tab button to the tab bar.
       *
       * @param button {qx.ui.mobile.tabbar.TabButton} The button to add
       */
      add: function add(button) {
        this._add(button, {
          flex: 1
        });

        if (!this.getSelection()) {
          this.setSelection(button);
        }

        button.addListener("changeView", this._onChangeView, this);
      },

      /**
       * Event handler. Called when the view was changed.
       *
       * @param evt {qx.event.type.Data} The event
       */
      _onChangeView: function _onChangeView(evt) {
        if (this.getSelection() == evt.getTarget()) {
          evt.getData().show();
        }
      },

      /**
       * Removes a tab button from the tab bar.
       *
       * @param button {qx.ui.mobile.tabbar.TabButton} The button to remove
       */
      remove: function remove(button) {
        this._remove(button);

        if (this.getSelection() == button) {
          this.setSelection(null);
        }

        button.removeListener("changeView", this._onChangeView, this);
      }
    },
    destruct: function destruct() {
      this.removeListener("tap", this._onTap, this);
    }
  });
  qx.ui.mobile.tabbar.TabBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Button": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A tab button widget.
   *
   * A tab button can be added to the tab bar and is associated with a
   * {@link #view}.
   */
  qx.Class.define("qx.ui.mobile.tabbar.TabButton", {
    extend: qx.ui.mobile.form.Button,

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "tabButton"
      },

      /**
       * The associated view.
       */
      view: {
        check: "qx.ui.mobile.core.Widget",
        nullable: false,
        init: null,
        apply: "_applyView",
        event: "changeView"
      }
    },
    members: {
      // property apply
      _applyView: function _applyView(value, old) {
        value.exclude();
      }
    }
  });
  qx.ui.mobile.tabbar.TabButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.mobile.MobileTestCase": {
        "require": true
      },
      "qx.ui.mobile.toolbar.ToolBar": {},
      "qx.ui.mobile.toolbar.Button": {},
      "qx.bom.element.Dimension": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  qx.Class.define("qx.test.mobile.toolbar.Toolbar", {
    extend: qx.test.mobile.MobileTestCase,
    members: {
      __createToolbar: function __createToolbar() {
        var toolBar = new qx.ui.mobile.toolbar.ToolBar();
        this.getRoot().add(toolBar);
        return toolBar;
      },
      __assertChildNodesLength: function __assertChildNodesLength(toolBar, toolbarKidsNumber) {
        var childrenLength = toolBar.getContentElement().childNodes.length;
        this.assertEquals(toolbarKidsNumber, childrenLength);
      },
      testAdd: function testAdd() {
        var toolBar = this.__createToolbar();

        var button1 = new qx.ui.mobile.toolbar.Button("Button 1");
        toolBar.add(button1);

        this.__assertChildNodesLength(toolBar, 1);

        var button2 = new qx.ui.mobile.toolbar.Button("Button with long name 2");
        toolBar.add(button2);

        this.__assertChildNodesLength(toolBar, 2);

        var button3 = new qx.ui.mobile.toolbar.Button("Button 3");
        toolBar.add(button3);

        this.__assertChildNodesLength(toolBar, 3);

        this.assertEquals(qx.bom.element.Dimension.getWidth(button1.getContainerElement()), qx.bom.element.Dimension.getWidth(button2.getContainerElement()));
        this.assertEquals(qx.bom.element.Dimension.getWidth(button3.getContainerElement()), qx.bom.element.Dimension.getWidth(button2.getContainerElement()));
        button1.destroy();
        button2.destroy();
        button3.destroy();
        toolBar.destroy();
      },
      testRemove: function testRemove() {
        var toolBar = this.__createToolbar();

        var button1 = new qx.ui.mobile.toolbar.Button("Button 1");
        toolBar.add(button1);
        var button2 = new qx.ui.mobile.toolbar.Button("Button 2");
        toolBar.add(button2);
        var button3 = new qx.ui.mobile.toolbar.Button("Button 3");
        toolBar.add(button3);

        this.__assertChildNodesLength(toolBar, 3);

        toolBar.remove(button2);

        this.__assertChildNodesLength(toolBar, 2);

        toolBar.remove(button1);

        this.__assertChildNodesLength(toolBar, 1);

        toolBar.remove(button3);

        this.__assertChildNodesLength(toolBar, 0);

        button1.destroy();
        button2.destroy();
        button3.destroy();
        toolBar.destroy();
      }
    }
  });
  qx.test.mobile.toolbar.Toolbar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.ui.mobile.toolbar.Separator": {},
      "qx.lang.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * A toolbar widget.
   *
   */
  qx.Class.define("qx.ui.mobile.toolbar.ToolBar", {
    extend: qx.ui.mobile.container.Composite,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout);

      if (!layout) {
        this.setLayout(new qx.ui.mobile.layout.HBox().set({
          alignY: "middle"
        }));
      }
    },

    /*
    *****************************************************************************
        PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "toolbar"
      }
    },
    members: {
      /**
        * Flag to keep the show/hidden state of the toolbar
        */
      __hidden: false,

      /**
        * Adds a new child widget.
        *
        * @param child {qx.ui.mobile.core.Widget} the widget to add.
        * @param layoutProperties {Map?null} Optional layout data for widget.
        */
      add: function add(child, layoutProperties) {
        if (!(child instanceof qx.ui.mobile.toolbar.Separator)) {
          layoutProperties = layoutProperties ? layoutProperties : {};
          qx.lang.Object.mergeWith(layoutProperties, {
            flex: 1
          }, false);
        }

        qx.ui.mobile.toolbar.ToolBar.prototype.add.base.call(this, child, layoutProperties);
      }
    }
  });
  qx.ui.mobile.toolbar.ToolBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Button": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * A button used in toolbars.
   *
   */
  qx.Class.define("qx.ui.mobile.toolbar.Button", {
    extend: qx.ui.mobile.form.Button,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "toolbar-button"
      }
    }
  });
  qx.ui.mobile.toolbar.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * A separator widget used to separate widgets in a toolbar.
   *
   */
  qx.Class.define("qx.ui.mobile.toolbar.Separator", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "toolbar-separator"
      }
    }
  });
  qx.ui.mobile.toolbar.Separator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMeasure": {
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * @ignore(qx.test.performance.Base.*)
   * @ignore(qx.test.performance.Extend)
   */
  qx.Class.define("qx.test.performance.BaseCall", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMeasure,
    members: {
      ITERATIONS: 100000,
      testBaseCall: function testBaseCall() {
        var obj = new qx.test.performance.Extend();
        var self = this;
        this.measure("this.base()", function () {
          for (var i = 0; i < self.ITERATIONS; i++) {
            obj.foo_base();
          }
        }, function () {}, this.ITERATIONS);
      },
      testPlainCall: function testPlainCall() {
        var obj = new qx.test.performance.Extend();
        var self = this;
        this.measure("Base.prototype.foo_base.call", function () {
          for (var i = 0; i < self.ITERATIONS; i++) {
            obj.foo_call();
          }
        }, function () {}, this.ITERATIONS);
      },
      testPlainApply: function testPlainApply() {
        var obj = new qx.test.performance.Extend();
        var self = this;
        this.measure("Base.prototype.foo_base.apply", function () {
          for (var i = 0; i < self.ITERATIONS; i++) {
            obj.foo_apply();
          }
        }, function () {}, this.ITERATIONS);
      }
    }
  });
  qx.Class.define("qx.test.performance.Base", {
    extend: qx.core.Object,
    members: {
      foo_base: function foo_base(a, b, c) {}
    }
  });
  /**
   * @ignore(qx.test.performance.Base.*)
   */

  qx.Class.define("qx.test.performance.Extend", {
    extend: qx.test.performance.Base,
    members: {
      foo_base: function foo_base(a, b, c) {
        qx.test.performance.Extend.prototype.foo_base.base.call(this, a, b, c);
      },
      foo_call: function foo_call(a, b, c) {
        qx.test.performance.Base.prototype.foo_base.call(this, a, b, c);
      },
      foo_apply: function foo_apply(a, b, c) {
        qx.test.performance.Base.prototype.foo_base.apply(this, arguments);
      }
    }
  });
  qx.test.performance.BaseCall.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMeasure": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.performance.Event", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMeasure,
    events: {
      "plain": "qx.event.type.Event",
      "data": "qx.event.type.Data"
    },
    members: {
      FIRE_ITERATIONS: 10000,
      ADD_ITERATIONS: 5000,
      testFireEvent: function testFireEvent() {
        var that = this;
        this.measureRepeated("fire plain events", function () {
          that.fireEvent("plain");
        }, function () {}, this.FIRE_ITERATIONS);
      },
      testFireDataEvent: function testFireDataEvent() {
        var that = this;
        this.measureRepeated("fire data events", function () {
          that.fireDataEvent("data", true, false);
        }, function () {}, this.FIRE_ITERATIONS);
      },
      testFireDataEventCancelable: function testFireDataEventCancelable() {
        var that = this;
        this.measureRepeated("fire cancelable data events", function () {
          that.fireDataEvent("data", true, false, true);
        }, function () {}, this.FIRE_ITERATIONS);
      },
      testAddListener: function testAddListener() {
        var that = this;
        var handler = [];

        for (var i = 0; i < this.ADD_ITERATIONS; i++) {
          handler.push(function () {});
        }

        this.measureRepeated("addListener", function (i) {
          that.addListener("plain", handler[i]);
        }, function () {
          for (var i = 0; i < handler.length; i++) {
            that.removeListener("plain", handler[i]);
          }
        }, this.ADD_ITERATIONS);
      },
      testRemoveListener: function testRemoveListener() {
        var handler = [];

        for (var i = 0; i < this.ADD_ITERATIONS; i++) {
          handler.push(function () {});
          this.addListener("plain", handler[i]);
        }

        var that = this;
        this.measureRepeated("remove listeners", function (i) {
          that.removeListener("plain", handler[i]);
        }, function () {}, this.ADD_ITERATIONS);
      },
      testRemoveListenerById: function testRemoveListenerById() {
        var listeners = [];

        for (var i = 0; i < this.ADD_ITERATIONS; i++) {
          listeners.push(this.addListener("plain", function () {}));
        }

        var that = this;
        this.measureRepeated("remove listeners by id", function (i) {
          that.removeListenerById(listeners[i]);
        }, function () {}, this.ADD_ITERATIONS);
      },
      testExecutePlainListener: function testExecutePlainListener() {
        var listeners = [];

        for (var i = 0; i < this.FIRE_ITERATIONS; i++) {
          listeners.push(this.addListener("plain", function () {}));
        }

        var that = this;
        this.measureRepeated("execute plain listeners", function () {
          that.fireEvent("plain");
        }, function () {
          for (var i = 0; i < listeners.length; i++) {
            that.removeListenerById(listeners[i]);
          }
        }, 1, this.FIRE_ITERATIONS);
      },
      testExecuteDataListener: function testExecuteDataListener() {
        var listeners = [];

        for (var i = 0; i < this.FIRE_ITERATIONS; i++) {
          listeners.push(this.addListener("data", function () {}));
        }

        var that = this;
        this.measureRepeated("execute data listeners", function () {
          that.fireDataEvent("data", true, false);
        }, function () {
          for (var i = 0; i < listeners.length; i++) {
            that.removeListenerById(listeners[i]);
          }
        }, 1, this.FIRE_ITERATIONS);
      }
    }
  });
  qx.test.performance.Event.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMeasure": {
        "require": true
      },
      "qx.core.Object": {},
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.performance.Object", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMeasure,
    members: {
      CREATE_ITERATIONS: 100000,
      testObjectCreate: function testObjectCreate() {
        var objects = this.__objects = [];
        var self = this;
        this.measure("create qx.core.Object", function () {
          for (var i = 0; i < self.CREATE_ITERATIONS; i++) {
            objects.push(new qx.core.Object());
          }
        }, function () {
          self._disposeArray("__objects");
        }, this.CREATE_ITERATIONS);
      },
      testToHashCode: function testToHashCode() {
        var objects = [];
        var self = this;
        this.measure("toHashCode qx.core.Object", function () {
          for (var i = 0; i < self.CREATE_ITERATIONS; i++) {
            var object = {};
            qx.core.ObjectRegistry.toHashCode(object);
            objects.push(object);
          }
        }, function () {
          for (var i = 0; i < objects.length; i++) {
            qx.core.ObjectRegistry.clearHashCode(objects[i]);
          }
        }, this.CREATE_ITERATIONS);
      }
    }
  });
  qx.test.performance.Object.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMeasure": {
        "require": true
      },
      "qx.core.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.performance.Property", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMeasure,
    members: {
      SET_ITERATIONS: 10000,
      testPropertySet: function testPropertySet() {
        var Clazz = qx.Class.define("demo.MyClass", {
          extend: qx.core.Object,
          properties: {
            alpha: {
              init: null,
              nullable: true,
              check: "String",
              event: "changeAlpha"
            }
          }
        });
        var obj = new Clazz();
        obj.addListener("changeAlpha", function () {}, this);
        var self = this;
        this.measure("property set", function () {
          for (var i = 0; i < self.SET_ITERATIONS; i++) {
            obj.setAlpha("value #" + i);
          }
        }, function () {
          obj.dispose();
          qx.Class.undefine("demo.MyClass");
        }, this.SET_ITERATIONS);
      },
      testAsyncPropertySet: function testAsyncPropertySet() {
        {
          (console.log || this.warn)("Long Stack Traces are enabled - this will significantly slow down the test");
        }
        var Clazz = qx.Class.define("demo.MyClass", {
          extend: qx.core.Object,
          properties: {
            alpha: {
              init: null,
              nullable: true,
              check: "String",
              event: "changeAlpha",
              async: true
            }
          }
        });
        var obj = new Clazz();
        obj.addListener("changeAlpha", function () {}, this);
        var self = this;
        this.measure("property set", function () {
          for (var i = 0; i < self.SET_ITERATIONS; i++) {
            obj.setAlpha("value #" + i);
          }
        }, function () {
          obj.dispose();
          qx.Class.undefine("demo.MyClass");
        }, this.SET_ITERATIONS);
      }
    }
  });
  qx.test.performance.Property.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMeasure": {
        "require": true
      },
      "qx.data.marshal.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.performance.data.Marshaling", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMeasure,
    members: {
      CREATE_ITERATIONS: 100000,
      __objects: null,
      __marshaler: null,
      setUp: function setUp() {
        this.__marshaler = new qx.data.marshal.Json();
      },
      tearDown: function tearDown() {
        this.__marshaler.dispose();

        this.__marshaler = null;
      },
      testJsonSimpleToClass: function testJsonSimpleToClass() {
        var data = {
          a: 10
        };
        var self = this;
        this.measure("simple json class creation", function () {
          for (var i = 0; i < self.CREATE_ITERATIONS; i++) {
            self.__marshaler.toClass(data);
          }
        }, function () {
          qx.Class.undefine("qx.data.model.a");
        }, this.CREATE_ITERATIONS);
      },
      testJsonSimpleToClassWithBubble: function testJsonSimpleToClassWithBubble() {
        var data = {
          a: 10
        };
        var self = this;
        this.measure("simple json class creation with bubble events", function () {
          for (var i = 0; i < self.CREATE_ITERATIONS; i++) {
            self.__marshaler.toClass(data, true);
          }
        }, function () {
          qx.Class.undefine("qx.data.model.a");
        }, this.CREATE_ITERATIONS);
      },
      testJsonSimpleToModel: function testJsonSimpleToModel() {
        var data = {
          a: 10
        };

        this.__marshaler.toClass(data);

        var self = this;
        this.__objects = [];
        this.measure("simple json object creation", function () {
          for (var i = 0; i < self.CREATE_ITERATIONS; i++) {
            self.__objects.push(self.__marshaler.toModel(data));
          }
        }, function () {
          for (var i = 0; i < self.__objects.length; i++) {
            self.__objects[i].dispose();
          }

          qx.Class.undefine("qx.data.model.a");
        }, this.CREATE_ITERATIONS);
      }
    }
  });
  qx.test.performance.data.Marshaling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMeasure": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.element.Style": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.performance.decorator.AbstractDecorator", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMeasure,
    type: "abstract",
    members: {
      CREATE_ITTERATIONS: 5000,
      RENDER_ITTERATIONS: 5000,
      RESIZE_ITTERATIONS: 10000,
      __el: null,
      setUp: function setUp() {
        this.__el = qx.dom.Element.create("div", {
          "id": "testRoot"
        });
        document.body.appendChild(this.__el);
      },
      tearDown: function tearDown() {
        document.body.removeChild(this.__el);
        this.__el = null;
      },
      createDivs: function createDivs(count) {
        var divs = [];
        var container = document.createElement("div");

        for (var i = 0; i < count; i++) {
          var div = document.createElement("div");
          div.style.position = "absolute";
          div.style.width = "100px";
          div.style.height = "50px";
          container.appendChild(div);
          divs.push(div);
        }

        this.__el.appendChild(container);

        return divs;
      },
      createDecorator: function createDecorator() {// abstract method call
      },
      testCreate: function testCreate() {
        var self = this;
        this.measureRepeated("create and initial getStyles", function () {
          var decorator = self.createDecorator();
          decorator.getStyles();
        }, function () {}, this.CREATE_ITTERATIONS);
      },
      testRender: function testRender() {
        // warmup the decorator
        var decorator = this.createDecorator();
        var divs = this.createDivs(this.RENDER_ITTERATIONS);
        this.measureRepeated("apply styles", function (i) {
          qx.bom.element.Style.setStyles(divs[i], decorator.getStyles());
        }, function () {}, this.RENDER_ITTERATIONS);
      },
      testResize: function testResize() {
        var divs = this.createDivs(this.RESIZE_ITTERATIONS);
        var decorator = this.createDecorator();

        for (var i = 0; i < divs.length; i++) {
          qx.bom.element.Style.setStyles(divs[i], decorator.getStyles());
        }

        var size = [100, 200];
        this.measureRepeated("resize decorator", function (i) {
          var currentSize = size[i % 2];
          qx.bom.element.Style.set(divs[i], "width", currentSize);
        }, function () {}, this.RESIZE_ITTERATIONS);
      }
    }
  });
  qx.test.performance.decorator.AbstractDecorator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.performance.decorator.AbstractDecorator": {
        "require": true
      },
      "qx.ui.decoration.Decorator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.performance.decorator.Background", {
    extend: qx.test.performance.decorator.AbstractDecorator,
    members: {
      createDecorator: function createDecorator() {
        return new qx.ui.decoration.Decorator().set({
          backgroundImage: "decoration/form/tooltip-error-arrow.png",
          backgroundPositionY: "center",
          backgroundRepeat: "no-repeat",
          slice: [0, 0, 0, 10]
        });
      }
    }
  });
  qx.test.performance.decorator.Background.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.performance.decorator.AbstractDecorator": {
        "require": true
      },
      "qx.ui.decoration.Decorator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.performance.decorator.BackgroundScale", {
    extend: qx.test.performance.decorator.AbstractDecorator,
    members: {
      createDecorator: function createDecorator() {
        return new qx.ui.decoration.Decorator().set({
          backgroundImage: "decoration/selection.png",
          backgroundRepeat: "scale"
        });
      }
    }
  });
  qx.test.performance.decorator.BackgroundScale.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.performance.decorator.AbstractDecorator": {
        "require": true
      },
      "qx.ui.decoration.Decorator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.performance.decorator.Beveled", {
    extend: qx.test.performance.decorator.AbstractDecorator,
    members: {
      createDecorator: function createDecorator() {
        return new qx.ui.decoration.Decorator().set({
          outerColor: "invalid",
          innerColor: "border-focused-invalid",
          width: 1
        });
      }
    }
  });
  qx.test.performance.decorator.Beveled.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.performance.decorator.AbstractDecorator": {
        "require": true
      },
      "qx.ui.decoration.Decorator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.performance.decorator.Grid", {
    extend: qx.test.performance.decorator.AbstractDecorator,
    members: {
      createDecorator: function createDecorator() {
        return new qx.ui.decoration.Decorator().set({
          baseImage: "decoration/tabview/tabview-pane.png"
        });
      }
    }
  });
  qx.test.performance.decorator.Grid.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.performance.decorator.AbstractDecorator": {
        "require": true
      },
      "qx.ui.decoration.Decorator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.performance.decorator.Single", {
    extend: qx.test.performance.decorator.AbstractDecorator,
    members: {
      createDecorator: function createDecorator() {
        return new qx.ui.decoration.Decorator(5, "solid", "red");
      }
    }
  });
  qx.test.performance.decorator.Single.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMeasure": {
        "require": true
      },
      "qx.html.Root": {},
      "qx.html.Element": {},
      "qx.util.DisposeUtil": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.performance.element.Element", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMeasure,
    members: {
      setUp: function setUp() {
        var helper = document.createElement("div");
        document.body.appendChild(helper);
        this._doc = new qx.html.Root(helper);

        this._doc.setAttribute("id", "doc");
      },
      tearDown: function tearDown() {
        qx.html.Element.flush();
        var div = document.getElementById("doc");
        document.body.removeChild(div);
        this.children = this._doc.getChildren();
        qx.util.DisposeUtil.disposeArray(this, "children");

        this._doc.dispose();
      },
      CREATE_ITERATIONS: 1000,
      RESIZE_ITERATIONS: 500,
      DISPOSE_ITERATIONS: 1000,
      _createElement: function _createElement() {
        return new qx.html.Element("div");
      },
      testCreate: function testCreate() {
        var elements = [];
        var that = this;
        this.measureRepeated("create element instance", function () {
          elements.push(that._createElement());
        }, function () {
          for (var i = 0; i < elements.length; i++) {
            elements[i].dispose();
          }

          this.flush();
        }, this.CREATE_ITERATIONS);
      },
      flush: function flush() {
        qx.html.Element.flush();
      },
      testRender: function testRender() {
        for (var i = 0; i < this.CREATE_ITERATIONS; i++) {
          this._doc.add(this._createElement());
        }

        var that = this;
        this.measureRepeated("render/flush elements", function () {
          that.flush();
        }, function () {}, 1, this.CREATE_ITERATIONS);
      },
      testResizeAndFlush: function testResizeAndFlush() {
        var elements = [];

        for (var i = 0; i < this.DISPOSE_ITERATIONS; i++) {
          var element = this._createElement();

          this._doc.add(element);

          elements.push(element);
        }

        this.flush();
        var l = elements.length;
        var that = this;
        this.measureRepeated("resize/flush elements", function () {
          for (i = 0; i < l; i++) {
            elements[i].setStyles({
              width: "300px",
              height: "100px"
            });
          }

          that.flush();

          for (i = 0; i < l; i++) {
            elements[i].setStyles({
              width: "100px",
              height: "30px"
            });
          }

          that.flush();
        }, function () {}, 1, this.RESIZE_ITERATIONS);
      },
      testRemove: function testRemove() {
        for (var i = 0; i < this.CREATE_ITERATIONS; i++) {
          this._doc.add(this._createElement());
        }

        this.elements = qx.lang.Array.clone(this._doc.getChildren());
        var that = this;
        this.measureRepeated("remove/flush elements", function () {
          that._doc.removeAll();

          that.flush();
        }, function () {
          qx.util.DisposeUtil.disposeArray(this, "elements");
        }, 1, this.CREATE_ITERATIONS);
      },
      testDisposeNonRendered: function testDisposeNonRendered() {
        var elements = [];

        for (var i = 0; i < this.DISPOSE_ITERATIONS; i++) {
          elements.push(this._createElement());
        }

        this.measureRepeated("dispose not rendered elements", function () {
          for (var i = 0; i < elements.length; i++) {
            elements[i].dispose();
          }
        }, function () {
          this.flush();
        }, 1, this.DISPOSE_ITERATIONS);
      },
      testDisposeRendered: function testDisposeRendered() {
        var elements = [];

        for (var i = 0; i < this.DISPOSE_ITERATIONS; i++) {
          elements.push(this._createElement());

          this._doc.add(elements[i]);
        }

        this.flush();
        var that = this;
        this.measureRepeated("dispose rendered elements", function () {
          for (var i = 0; i < elements.length; i++) {
            elements[i].dispose();
          }

          that.flush();
        }, function () {
          this.flush();
        }, 1, this.DISPOSE_ITERATIONS);
      }
    }
  });
  qx.test.performance.element.Element.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MMeasure": {
        "require": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.Basic": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.performance.widget.AbstractWidget", {
    extend: qx.test.ui.LayoutTestCase,
    include: qx.dev.unit.MMeasure,
    type: "abstract",
    members: {
      DURATION: 1000,
      setUp: function setUp() {
        qx.test.performance.widget.AbstractWidget.prototype.setUp.base.call(this);
        this.flush();
      },
      _createWidget: function _createWidget() {
        throw new Error("abstract method call");
      },
      testCreate: function testCreate() {
        var widgets = [];
        var that = this;
        this.measureIterations("create widget instance", null, function () {
          widgets.push(that._createWidget());
        }, function () {
          for (var i = 0; i < widgets.length; i++) {
            widgets[i].dispose();
          }

          this.flush();
        }, this.DURATION);
      },
      testRender: function testRender() {
        var container = new qx.ui.container.Composite(new qx.ui.layout.Basic());
        this.getRoot().add(container);
        var that = this;
        var widget;
        this.measureIterations("render and flush widgets", function () {
          widget = that._createWidget();
        }, function () {
          that.getRoot().add(widget);
          that.flush();
        }, function () {
          container.destroy();
          that.flush();
        }, this.DURATION);
      },
      testResizeAndFlush: function testResizeAndFlush() {
        var that = this;
        var widgets = [];
        this.measureIterations("resize and flush widgets", function () {
          var widget = that._createWidget();

          widgets.push(widget);
          that.getRoot().add(widget);
          that.flush();
        }, function () {
          widgets[widgets.length - 1].setWidth(300);
          widgets[widgets.length - 1].setHeight(100);
          that.flush();
        }, function () {
          for (var i = 0; i < widgets.length; i++) {
            widgets[i].destroy();
          }

          this.flush();
        }, this.DURATION);
      },
      testRemove: function testRemove() {
        var container = new qx.ui.container.Composite(new qx.ui.layout.Basic());
        this.getRoot().add(container);
        var that = this;
        var widget;
        this.measureIterations("remove and flush widgets", function () {
          widget = that._createWidget();
          container.add(widget);
        }, function () {
          container.remove(widget);
          that.flush();
        }, function () {
          container.destroy();
          that.flush();
        }, this.DURATION);
      },
      testDisposeRendered: function testDisposeRendered() {
        this.flush();
        var widgets = [];
        var that = this;
        this.measureIterations("dispose rendered widgets", function () {
          widgets.push(that._createWidget());
          that.getRoot().add(widgets[widgets.length - 1]);
        }, function () {
          widgets[widgets.length - 1].destroy();
          that.flush();
        }, function () {
          that.flush();
        }, this.DURATION);
      }
    }
  });
  qx.test.performance.widget.AbstractWidget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.performance.widget.AbstractWidget": {
        "require": true
      },
      "qx.ui.form.Button": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.performance.widget.Button", {
    extend: qx.test.performance.widget.AbstractWidget,
    members: {
      _createWidget: function _createWidget() {
        return new qx.ui.form.Button();
      }
    }
  });
  qx.test.performance.widget.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.performance.widget.AbstractWidget": {
        "require": true
      },
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.performance.widget.Label", {
    extend: qx.test.performance.widget.AbstractWidget,
    members: {
      _createWidget: function _createWidget() {
        return new qx.ui.basic.Label("juhu");
      }
    }
  });
  qx.test.performance.widget.Label.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.performance.widget.AbstractWidget": {
        "require": true
      },
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.performance.widget.RichLabel", {
    extend: qx.test.performance.widget.AbstractWidget,
    members: {
      _createWidget: function _createWidget() {
        return new qx.ui.basic.Label("<b>juhu</b>").set({
          rich: true
        });
      }
    }
  });
  qx.test.performance.widget.RichLabel.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.performance.widget.AbstractWidget": {
        "require": true
      },
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.performance.widget.Widget", {
    extend: qx.test.performance.widget.AbstractWidget,
    members: {
      _createWidget: function _createWidget() {
        return new qx.ui.core.Widget();
      }
    }
  });
  qx.test.performance.widget.Widget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.performance.widget.AbstractWidget": {
        "construct": true,
        "require": true
      },
      "qx.ui.decoration.Decorator": {
        "construct": true
      },
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.performance.widget.WidgetWithDecorator", {
    extend: qx.test.performance.widget.AbstractWidget,
    construct: function construct() {
      qx.test.performance.widget.AbstractWidget.constructor.call(this);
      this.__decorator = new qx.ui.decoration.Decorator().set({
        width: 1,
        style: "solid",
        color: "red"
      });
    },
    members: {
      _createWidget: function _createWidget() {
        return new qx.ui.core.Widget().set({
          decorator: this.__decorator
        });
      }
    }
  });
  qx.test.performance.widget.WidgetWithDecorator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.performance.widget.AbstractWidget": {
        "require": true
      },
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.performance.widget.WidgetWithSingle", {
    extend: qx.test.performance.widget.AbstractWidget,
    members: {
      CREATE_ITERATIONS: 100,
      RESIZE_ITERATIONS: 50,
      DISPOSE_ITERATIONS: 100,
      _createWidget: function _createWidget() {
        return new qx.ui.core.Widget().set({
          decorator: "window"
        });
      }
    }
  });
  qx.test.performance.widget.WidgetWithSingle.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.ColorUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.renderer.Color", {
    extend: qx.dev.unit.TestCase,
    members: {
      testValidColors: function testValidColors() {
        var validColors = {
          "red": [255, 0, 0],
          //named
          "black": [0, 0, 0],
          //named
          "#FFF": [255, 255, 255],
          //hex3
          "#Ff1": [255, 255, 17],
          //hex3
          "#0101FF": [1, 1, 255],
          //hex6
          "rgb(123,11,1)": [123, 11, 1] //rgb

        };

        for (var color in validColors) {
          this.assertJsonEquals(validColors[color], qx.util.ColorUtil.stringToRgb(color));
        }
      },
      testInvalidColors: function testInvalidColors() {
        var invalidColors = ["blau", "1234", "#ff", "#ffff", "rgb(12,13)"];

        for (var i = 0; i < invalidColors.length; i++) {
          this.assertException(function () {
            qx.util.ColorUtil.stringToRgb(invalidColors[i]);
          }, Error, "Could not parse color");
        }

        this.assertException(function () {
          qx.util.ColorUtil.stringToRgb("inactivecaptiontext");
        }, Error, "Could not convert system colors to RGB");
      }
      /*
          testThemedColors : function()
          {
            var colorMgr = qx.theme.manager.Color.getInstance();
            var oldTheme = colorMgr.getColorTheme();
      
            colorMgr.setColorTheme(qx.theme.ext.Color);
            this.assertJsonEquals([ 101, 147, 207 ], qx.util.ColorUtil.stringToRgb("border-dark-shadow"));
      
            colorMgr.setColorTheme(qx.theme.classic.color.LunaBlue);
            this.assertJsonEquals([ 172, 168, 153 ], qx.util.ColorUtil.stringToRgb("border-dark-shadow"));
      
            colorMgr.setColorTheme(oldTheme);
          }
      */

    }
  });
  qx.test.renderer.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.theme.manager.Color": {},
      "qx.test.Theme": {},
      "qx.Theme": {},
      "qx.theme.indigo.Color": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.theme.manager.Color", {
    extend: qx.dev.unit.TestCase,
    members: {
      __formerTheme: null,
      setUp: function setUp() {
        this.manager = qx.theme.manager.Color.getInstance();
        this.__formerTheme = this.manager.getTheme();
      },
      tearDown: function tearDown() {
        qx.test.Theme.themes = null;
        this.manager.setTheme(this.__formerTheme);
        this.__formerTheme = null;
      },
      testInclude: function testInclude() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          extend: qx.theme.indigo.Color,
          colors: {
            "a": "#111111",
            "b": "#222222",
            "c": "#333333"
          }
        });
        this.manager.setTheme(qx.test.Theme.themes.A);
        var theme = this.manager.getTheme();
        this.assertEquals("#111111", theme.colors["a"]);
        this.assertEquals("#222222", theme.colors["b"]);
        this.assertEquals("#333333", theme.colors["c"]);
      },
      testResolve: function testResolve() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          extend: qx.theme.indigo.Color,
          colors: {
            "a": "#111111",
            "b": "#222222",
            "c": "#333333"
          }
        });
        this.manager.setTheme(qx.test.Theme.themes.A);
        this.assertEquals("#111111", this.manager.resolve("a"));
        this.assertEquals("#222222", this.manager.resolve("b"));
        this.assertEquals("#333333", this.manager.resolve("c"));
        this.assertEquals("d", this.manager.resolve("d"));
      },
      testResolveSelfReference: function testResolveSelfReference() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          extend: qx.theme.indigo.Color,
          colors: {
            "a": "#111111",
            "b": "a",
            "c": "b"
          }
        });
        this.manager.setTheme(qx.test.Theme.themes.A);
        this.assertEquals("#111111", this.manager.resolve("a"));
        this.assertEquals("#111111", this.manager.resolve("b"));
        this.assertEquals("#111111", this.manager.resolve("c"));
      },
      testResolveException: function testResolveException() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          extend: qx.theme.indigo.Color,
          colors: {
            "d": "xyz"
          }
        });
        var self = this;
        this.assertException(function () {
          self.manager.setTheme(qx.test.Theme.themes.A);
        });
        qx.Theme.define("qx.test.Theme.themes.A", {
          extend: qx.theme.indigo.Color,
          colors: {
            "b": "a",
            "c": "b"
          }
        });
        var self = this;
        this.assertException(function () {
          self.manager.setTheme(qx.test.Theme.themes.A);
        });
      }
    }
  });
  qx.test.theme.manager.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Css": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "css.rgba": {
          "load": true,
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Tristan Koch (trkoch)
  
  ************************************************************************ */

  /**
   * Indigo color theme
   */
  qx.Theme.define("qx.theme.indigo.Color", {
    colors: {
      // main
      "background": "white",
      "dark-blue": "#323335",
      "light-background": "#F4F4F4",
      "font": "#262626",
      "highlight": "#3D72C9",
      // bright blue
      "highlight-shade": "#5583D0",
      // bright blue
      // backgrounds
      "background-selected": "#3D72C9",
      "background-selected-disabled": "#CDCDCD",
      "background-selected-dark": "#323335",
      "background-disabled": "#F7F7F7",
      "background-disabled-checked": "#BBBBBB",
      "background-pane": "white",
      // tabview
      "tabview-unselected": "#1866B5",
      "tabview-button-border": "#134983",
      "tabview-label-active-disabled": "#D9D9D9",
      // text colors
      "link": "#24B",
      // scrollbar
      "scrollbar-bright": "#F1F1F1",
      "scrollbar-dark": "#EBEBEB",
      // form
      "button": "#E8F0E3",
      "button-border": "#BBB",
      "button-border-hovered": "#939393",
      "invalid": "#C00F00",
      "button-box-bright": "#F9F9F9",
      "button-box-dark": "#E3E3E3",
      "button-box-bright-pressed": "#BABABA",
      "button-box-dark-pressed": "#EBEBEB",
      "border-lead": "#888888",
      // window
      "window-border": "#dddddd",
      "window-border-inner": "#F4F4F4",
      // group box
      "white-box-border": "#dddddd",
      // shadows
      "shadow": qx.core.Environment.get("css.rgba") ? "rgba(0, 0, 0, 0.4)" : "#666666",
      // borders
      "border-main": "#dddddd",
      "border-light": "#B7B7B7",
      "border-light-shadow": "#686868",
      // separator
      "border-separator": "#808080",
      // text
      "text": "#262626",
      "text-disabled": "#A7A6AA",
      "text-selected": "white",
      "text-placeholder": "#CBC8CD",
      // tooltip
      "tooltip": "#FE0",
      "tooltip-text": "black",
      // table
      "table-header": [242, 242, 242],
      "table-focus-indicator": "#3D72C9",
      // used in table code
      "table-header-cell": [235, 234, 219],
      "table-row-background-focused-selected": "#3D72C9",
      "table-row-background-focused": "#F4F4F4",
      "table-row-background-selected": [51, 94, 168],
      "table-row-background-even": "white",
      "table-row-background-odd": "white",
      "table-row-selected": [255, 255, 255],
      "table-row": [0, 0, 0],
      "table-row-line": "#EEE",
      "table-column-line": "#EEE",
      // used in progressive code
      "progressive-table-header": "#AAAAAA",
      "progressive-table-row-background-even": [250, 248, 243],
      "progressive-table-row-background-odd": [255, 255, 255],
      "progressive-progressbar-background": "gray",
      "progressive-progressbar-indicator-done": "#CCCCCC",
      "progressive-progressbar-indicator-undone": "white",
      "progressive-progressbar-percent-background": "gray",
      "progressive-progressbar-percent-text": "white"
    }
  });
  qx.theme.indigo.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.theme.manager.Decoration": {},
      "qx.test.Theme": {},
      "qx.Theme": {},
      "qx.util.AliasManager": {},
      "qx.ui.style.Stylesheet": {},
      "qx.util.ColorUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.theme.manager.Decoration", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.manager = qx.theme.manager.Decoration.getInstance();
        this.__formerTheme = this.manager.getTheme();
      },
      tearDown: function tearDown() {
        qx.test.Theme.themes = null;
        this.manager.setTheme(this.__formerTheme);
        this.__formerTheme = null;
      },
      testAlias: function testAlias() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          aliases: {
            decoration: "test/decoration",
            custom: "test/custom"
          },
          decorations: {}
        });
        this.manager.setTheme(qx.test.Theme.themes.A); // make sure the decoration alias is set

        var alias = qx.util.AliasManager.getInstance();
        this.assertEquals("test/decoration", alias.resolve("decoration"));
        this.assertEquals("test/custom", alias.resolve("custom"));
      },
      testAliasExtend: function testAliasExtend() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          aliases: {
            decoration: "test/decoration",
            custom: "test/custom"
          },
          decorations: {}
        });
        qx.Theme.define("qx.test.Theme.themes.B", {
          extend: qx.test.Theme.themes.A,
          decorations: {}
        });
        this.manager.setTheme(qx.test.Theme.themes.B); // make sure the decoration alias is set

        var alias = qx.util.AliasManager.getInstance();
        this.assertEquals("test/decoration", alias.resolve("decoration"));
        this.assertEquals("test/custom", alias.resolve("custom"));
      },
      testAliasOverride: function testAliasOverride() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          aliases: {
            decoration: "test/decoration",
            custom: "test/custom"
          },
          decorations: {}
        });
        qx.Theme.define("qx.test.Theme.themes.B", {
          extend: qx.test.Theme.themes.A,
          aliases: {
            decoration: "juhu/decoration"
          },
          decorations: {}
        });
        this.manager.setTheme(qx.test.Theme.themes.B); // make sure the decoration alias is set

        var alias = qx.util.AliasManager.getInstance();
        this.assertEquals("juhu/decoration", alias.resolve("decoration"));
        this.assertEquals("test/custom", alias.resolve("custom"));
      },
      testChangeThemeEventFired: function testChangeThemeEventFired() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          aliases: {
            decoration: "test/decoration",
            custom: "test/custom"
          },
          decorations: {}
        });
        var that = this;
        this.assertEventFired(this.manager, "changeTheme", function () {
          that.manager.setTheme(qx.test.Theme.themes.A);
        }, function (e) {
          that.assertIdentical(e.getData(), qx.test.Theme.themes.A, "Setting theme failed!");
        });
      },
      testAddCssClass: function testAddCssClass() {
        qx.Theme.define("qx.test.Theme.themes.B", {
          aliases: {
            decoration: "test/decoration",
            custom: "test/custom"
          },
          decorations: {
            "test-add-css": {
              style: {
                backgroundColor: "red",
                backgroundImage: "icon/16/places/folder-open.png"
              }
            }
          }
        });
        this.manager.setTheme(qx.test.Theme.themes.B);
        var selector = this.manager.addCssClass("test-add-css");
        var sheet = qx.ui.style.Stylesheet.getInstance();
        var elem = document.createElement("div");
        elem.setAttribute("class", selector);
        document.body.appendChild(elem);
        var compStyle = window.getComputedStyle(elem);
        this.assertEquals("255,0,0", qx.util.ColorUtil.cssStringToRgb(compStyle.getPropertyValue("background-color")));
      }
    }
  });
  qx.test.theme.manager.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.theme.manager.Font": {},
      "qx.test.Theme": {},
      "qx.Theme": {},
      "qx.theme.modern.Font": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.theme.manager.Font", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.manager = qx.theme.manager.Font.getInstance();
        this.__formerTheme = this.manager.getTheme();
      },
      tearDown: function tearDown() {
        qx.test.Theme.themes = null;
        this.manager.setTheme(this.__formerTheme);
        this.__formerTheme = null;
      },
      testInclude: function testInclude() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          extend: qx.theme.modern.Font,
          fonts: {
            "myfont": {
              include: "default",
              bold: true
            },
            "mysecondfont": {
              include: "myfont",
              italic: true
            }
          }
        });
        this.manager.setTheme(qx.test.Theme.themes.A);
        var fontTheme = this.manager.getTheme();
        this.assertKeyInMap("size", fontTheme.fonts.myfont, "Including font theme failed");
        this.assertKeyInMap("lineHeight", fontTheme.fonts.myfont, "Including font theme failed");
        this.assertKeyInMap("family", fontTheme.fonts.myfont, "Including font theme failed");
        this.assertKeyInMap("bold", fontTheme.fonts.myfont, "Including font theme failed");
        this.assertKeyInMap("size", fontTheme.fonts.mysecondfont, "Including font theme failed");
        this.assertKeyInMap("lineHeight", fontTheme.fonts.mysecondfont, "Including font theme failed");
        this.assertKeyInMap("family", fontTheme.fonts.mysecondfont, "Including font theme failed");
        this.assertKeyInMap("bold", fontTheme.fonts.mysecondfont, "Including font theme failed");
        this.assertKeyInMap("italic", fontTheme.fonts.mysecondfont, "Including font theme failed");
      }
    }
  });
  qx.test.theme.manager.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.OperatingSystem": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "os.name": {
          "load": true,
          "className": "qx.bom.client.OperatingSystem"
        },
        "os.version": {
          "load": true,
          "className": "qx.bom.client.OperatingSystem"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
  
  ************************************************************************* */

  /**
   * The modern font theme.
   */
  qx.Theme.define("qx.theme.modern.Font", {
    fonts: {
      "default": {
        size: qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? 12 : 11,
        lineHeight: 1.4,
        family: qx.core.Environment.get("os.name") == "osx" ? ["Lucida Grande"] : qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? ["Segoe UI", "Candara"] : ["Tahoma", "Liberation Sans", "Arial", "sans-serif"]
      },
      "bold": {
        size: qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? 12 : 11,
        lineHeight: 1.4,
        family: qx.core.Environment.get("os.name") == "osx" ? ["Lucida Grande"] : qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? ["Segoe UI", "Candara"] : ["Tahoma", "Liberation Sans", "Arial", "sans-serif"],
        bold: true
      },
      "small": {
        size: qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? 11 : 10,
        lineHeight: 1.4,
        family: qx.core.Environment.get("os.name") == "osx" ? ["Lucida Grande"] : qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? ["Segoe UI", "Candara"] : ["Tahoma", "Liberation Sans", "Arial", "sans-serif"]
      },
      "monospace": {
        size: 11,
        lineHeight: 1.4,
        family: qx.core.Environment.get("os.name") == "osx" ? ["Lucida Console", "Monaco"] : qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? ["Consolas"] : ["Consolas", "DejaVu Sans Mono", "Courier New", "monospace"]
      }
    }
  });
  qx.theme.modern.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.theme.manager.Icon": {},
      "qx.test.Theme": {},
      "qx.Theme": {},
      "qx.util.AliasManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.theme.manager.Icon", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.manager = qx.theme.manager.Icon.getInstance();
        this.__formerTheme = this.manager.getTheme();
      },
      tearDown: function tearDown() {
        qx.test.Theme.themes = null;
        this.manager.setTheme(this.__formerTheme);
        this.__formerTheme = null;
      },
      testAlias: function testAlias() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          aliases: {
            icon: "test/icon",
            custom: "test/custom"
          }
        });
        this.manager.setTheme(qx.test.Theme.themes.A); // make sure the icon alias is set

        var alias = qx.util.AliasManager.getInstance();
        this.assertEquals("test/icon", alias.resolve("icon"));
        this.assertEquals("test/custom", alias.resolve("custom"));
      },
      testAliasExtend: function testAliasExtend() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          aliases: {
            icon: "test/icon",
            custom: "test/custom"
          }
        });
        qx.Theme.define("qx.test.Theme.themes.B", {
          extend: qx.test.Theme.themes.A
        });
        this.manager.setTheme(qx.test.Theme.themes.B); // make sure the icon alias is set

        var alias = qx.util.AliasManager.getInstance();
        this.assertEquals("test/icon", alias.resolve("icon"));
        this.assertEquals("test/custom", alias.resolve("custom"));
      },
      testAliasOverride: function testAliasOverride() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          aliases: {
            icon: "test/icon",
            custom: "test/custom"
          }
        });
        qx.Theme.define("qx.test.Theme.themes.B", {
          extend: qx.test.Theme.themes.A,
          aliases: {
            icon: "juhu/icon"
          }
        });
        this.manager.setTheme(qx.test.Theme.themes.B); // make sure the icon alias is set

        var alias = qx.util.AliasManager.getInstance();
        this.assertEquals("juhu/icon", alias.resolve("icon"));
        this.assertEquals("test/custom", alias.resolve("custom"));
      },
      testChangeThemeEventFired: function testChangeThemeEventFired() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          aliases: {
            "icon": "my/icon/Theme"
          }
        });
        var that = this;
        this.assertEventFired(this.manager, "changeTheme", function () {
          that.manager.setTheme(qx.test.Theme.themes.A);
        }, function (e) {
          that.assertIdentical(e.getData(), qx.test.Theme.themes.A, "Setting theme failed!");
        });
      }
    }
  });
  qx.test.theme.manager.Icon.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "construct": true,
        "require": true
      },
      "qx.Theme": {},
      "qx.test.theme.manager.mock.Color": {},
      "qx.test.theme.manager.mock.Decoration": {},
      "qx.test.theme.manager.mock.Font": {},
      "qx.test.theme.manager.mock.Appearance": {},
      "qx.theme.icon.Tango": {},
      "qx.theme.manager.Decoration": {},
      "qx.theme.manager.Color": {},
      "qx.theme.manager.Font": {},
      "qx.theme.manager.Appearance": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.theme.manager.Meta": {},
      "qx.ui.form.Button": {},
      "qx.ui.core.queue.Manager": {},
      "qx.bom.element.Style": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Mustafa Sak (msak)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.theme.manager.MockAll)
   * @ignore(qx.test.theme.manager.MockAppearance)
   * @ignore(qx.test.theme.manager.MockDecoration)
   * @ignore(qx.test.theme.manager.MockColor)
   */
  qx.Class.define("qx.test.theme.manager.Meta", {
    extend: qx.test.ui.LayoutTestCase,
    construct: function construct() {
      qx.test.ui.LayoutTestCase.constructor.call(this);
      qx.Theme.define("qx.test.theme.manager.MockAll", {
        title: "Mock all theme manager",
        meta: {
          color: qx.test.theme.manager.mock.Color,
          decoration: qx.test.theme.manager.mock.Decoration,
          font: qx.test.theme.manager.mock.Font,
          appearance: qx.test.theme.manager.mock.Appearance,
          icon: qx.theme.icon.Tango
        }
      });
      qx.Theme.define("qx.test.theme.manager.MockAppearance", {
        title: "Mock only appearance manager",
        meta: {
          appearance: qx.test.theme.manager.mock.Appearance,
          decoration: qx.theme.manager.Decoration.getInstance().getTheme(),
          color: qx.theme.manager.Color.getInstance().getTheme(),
          font: qx.theme.manager.Font.getInstance().getTheme(),
          icon: qx.theme.icon.Tango
        }
      });
      qx.Theme.define("qx.test.theme.manager.MockDecoration", {
        title: "Mock only decorator manager",
        meta: {
          decoration: qx.test.theme.manager.mock.Decoration,
          color: qx.theme.manager.Color.getInstance().getTheme(),
          font: qx.theme.manager.Font.getInstance().getTheme(),
          appearance: qx.theme.manager.Appearance.getInstance().getTheme(),
          icon: qx.theme.icon.Tango
        }
      });
      qx.Theme.define("qx.test.theme.manager.MockColor", {
        title: "Mock only color manager",
        meta: {
          color: qx.test.theme.manager.mock.Color,
          decoration: qx.theme.manager.Decoration.getInstance().getTheme(),
          font: qx.theme.manager.Font.getInstance().getTheme(),
          appearance: qx.theme.manager.Appearance.getInstance().getTheme(),
          icon: qx.theme.icon.Tango
        }
      });
    },
    members: {
      __formerTheme: null,
      __linerGradientRegExp: /(orange.*yellow|rgb\(255, 165, 0\).*rgb\(255, 255, 0\)|data:image\/png;base64,iVBORw0K)/,
      setUp: function setUp() {
        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9) {
          this.skip("Skipped in IE 8.");
        }

        this.manager = qx.theme.manager.Meta.getInstance();
        this.__formerTheme = this.manager.getTheme(); // add a theme able widget

        this.__button = new qx.ui.form.Button("Foo");
        this.getRoot().add(this.__button);
        qx.ui.core.queue.Manager.flush();
      },
      tearDown: function tearDown() {
        this.__button.destroy();

        this.manager.setTheme(this.__formerTheme);
        this.__formerTheme = null;
      },
      testAllThemeManagerChanged: function testAllThemeManagerChanged() {
        qx.theme.manager.Meta.getInstance().setTheme(qx.test.theme.manager.MockAll);
        qx.ui.core.queue.Manager.flush(); // button element

        var elem = this.__button.getContentElement().getDomElement(); // mocked appearance theme defines a padding with 30px 80px


        this.assertEquals(qx.bom.element.Style.get(elem, "padding"), "30px 80px"); // mocked color theme defines a gradient with 'orange' and 'yellow';
        // also check for corresponding rgb values (need for FireFox)

        this.assertNotNull(qx.bom.element.Style.get(elem, "backgroundImage").match(this.__linerGradientRegExp)); // mocked decoration theme defines a border radius of 10 pixel

        this.assertEquals(qx.bom.element.Style.get(elem, "borderTopLeftRadius"), "10px"); // button label element

        elem = this.__button.getChildControl("label").getContentElement().getDomElement(); // mocked color theme defines red text color for button labels

        this.assertEquals(qx.bom.element.Style.get(elem, "color"), "rgb(255, 0, 0)");
      },
      testColorThemeManagerChanged: function testColorThemeManagerChanged() {
        qx.theme.manager.Meta.getInstance().setTheme(qx.test.theme.manager.MockColor);
        qx.ui.core.queue.Manager.flush();

        var elem = this.__button.getContentElement().getDomElement(); // mocked color theme defines a gradient with 'orange' and 'yellow';
        // also check for corresponding rgb values (need for FireFox)


        this.assertNotNull(qx.bom.element.Style.get(elem, "backgroundImage").match(this.__linerGradientRegExp));
      },
      testDecoratorThemeManagerChanged: function testDecoratorThemeManagerChanged() {
        qx.theme.manager.Meta.getInstance().setTheme(qx.test.theme.manager.MockDecoration);
        qx.ui.core.queue.Manager.flush(); // mocked decoration theme defines a border radius of 10 pixel

        var elem = this.__button.getContentElement().getDomElement();

        this.assertEquals(qx.bom.element.Style.get(elem, "borderTopLeftRadius"), "10px");
      },
      testAppearanceThemeManagerChanged: function testAppearanceThemeManagerChanged() {
        qx.theme.manager.Meta.getInstance().setTheme(qx.test.theme.manager.MockAppearance);
        qx.ui.core.queue.Manager.flush(); // mocked appearance theme defines a padding with 30px 80px

        var elem = this.__button.getContentElement().getDomElement();

        this.assertEquals(qx.bom.element.Style.get(elem, "padding"), "30px 80px");
      },
      testColorThemeChanged: function testColorThemeChanged() {
        qx.theme.manager.Color.getInstance().setTheme(qx.test.theme.manager.mock.Color);
        qx.ui.core.queue.Manager.flush();

        var elem = this.__button.getContentElement().getDomElement(); // mocked color theme defines a gradient with 'orange' and 'yellow';
        // also check for corresponding rgb values (need for FireFox)


        this.assertNotNull(qx.bom.element.Style.get(elem, "backgroundImage").match(this.__linerGradientRegExp));
      }
    },
    destruct: function destruct() {}
  });
  qx.test.theme.manager.Meta.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Css": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "css.rgba": {
          "load": true,
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Alexander Steitz (aback)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Modern color theme
   */
  qx.Theme.define("qx.theme.modern.Color", {
    colors: {
      /*
      ---------------------------------------------------------------------------
        BACKGROUND COLORS
      ---------------------------------------------------------------------------
      */
      // application, desktop, ...
      "background-application": "#DFDFDF",
      // pane color for windows, splitpanes, ...
      "background-pane": "#F3F3F3",
      // textfields, ...
      "background-light": "#FCFCFC",
      // headers, ...
      "background-medium": "#EEEEEE",
      // splitpane
      "background-splitpane": "#AFAFAF",
      // tooltip, ...
      "background-tip": "#ffffdd",
      // error tooltip
      "background-tip-error": "#C72B2B",
      // tables, ...
      "background-odd": "#E4E4E4",
      // progress bar
      "progressbar-background": "white",

      /*
      ---------------------------------------------------------------------------
        TEXT COLORS
      ---------------------------------------------------------------------------
      */
      // other types
      "text-light": "#909090",
      "text-gray": "#4a4a4a",
      // labels
      "text-label": "#1a1a1a",
      // group boxes
      "text-title": "#314a6e",
      // text fields
      "text-input": "#000000",
      // states
      "text-hovered": "#001533",
      "text-disabled": "#7B7A7E",
      "text-selected": "#fffefe",
      "text-active": "#26364D",
      "text-inactive": "#404955",
      "text-placeholder": "#CBC8CD",

      /*
      ---------------------------------------------------------------------------
        BORDER COLORS
      ---------------------------------------------------------------------------
      */
      "border-inner-scrollbar": "white",
      // menus, tables, scrollbars, list, etc.
      "border-main": "#4d4d4d",
      "menu-separator-top": "#C5C5C5",
      "menu-separator-bottom": "#FAFAFA",
      // between toolbars
      "border-separator": "#808080",
      "border-toolbar-button-outer": "#b6b6b6",
      "border-toolbar-border-inner": "#f8f8f8",
      "border-toolbar-separator-right": "#f4f4f4",
      "border-toolbar-separator-left": "#b8b8b8",
      // text fields
      "border-input": "#334866",
      "border-inner-input": "white",
      // disabled text fields
      "border-disabled": "#B6B6B6",
      // tab view, window
      "border-pane": "#00204D",
      // buttons
      "border-button": "#666666",
      // tables (vertical line)
      "border-column": "#CCCCCC",
      // focus state of text fields
      "border-focused": "#99C3FE",
      // invalid form widgets
      "invalid": "#990000",
      "border-focused-invalid": "#FF9999",
      // drag & drop
      "border-dragover": "#33508D",
      "keyboard-focus": "black",

      /*
      ---------------------------------------------------------------------------
        TABLE COLORS
      ---------------------------------------------------------------------------
      */
      // equal to "background-pane"
      "table-pane": "#F3F3F3",
      // own table colors
      // "table-row-background-selected" and "table-row-background-focused-selected"
      // are inspired by the colors of the selection decorator
      "table-focus-indicator": "#0880EF",
      "table-row-background-focused-selected": "#084FAB",
      "table-row-background-focused": "#80B4EF",
      "table-row-background-selected": "#084FAB",
      // equal to "background-pane" and "background-odd"
      "table-row-background-even": "#F3F3F3",
      "table-row-background-odd": "#E4E4E4",
      // equal to "text-selected" and "text-label"
      "table-row-selected": "#fffefe",
      "table-row": "#1a1a1a",
      // equal to "border-column"
      "table-row-line": "#CCC",
      "table-column-line": "#CCC",
      "table-header-hovered": "white",

      /*
      ---------------------------------------------------------------------------
        PROGRESSIVE TABLE COLORS
      ---------------------------------------------------------------------------
      */
      "progressive-table-header": "#AAAAAA",
      "progressive-table-header-border-right": "#F2F2F2",
      "progressive-table-row-background-even": "#F4F4F4",
      "progressive-table-row-background-odd": "#E4E4E4",
      "progressive-progressbar-background": "gray",
      "progressive-progressbar-indicator-done": "#CCCCCC",
      "progressive-progressbar-indicator-undone": "white",
      "progressive-progressbar-percent-background": "gray",
      "progressive-progressbar-percent-text": "white",

      /*
      ---------------------------------------------------------------------------
        CSS ONLY COLORS
      ---------------------------------------------------------------------------
      */
      "selected-start": "#004DAD",
      "selected-end": "#00368A",
      "background-selected": "#00368A",
      "tabview-background": "#07125A",
      "shadow": qx.core.Environment.get("css.rgba") ? "rgba(0, 0, 0, 0.4)" : "#999999",
      "pane-start": "#FBFBFB",
      "pane-end": "#F0F0F0",
      "group-background": "#E8E8E8",
      "group-border": "#B4B4B4",
      "radiobutton-background": "#EFEFEF",
      "checkbox-border": "#314A6E",
      "checkbox-focus": "#87AFE7",
      "checkbox-hovered": "#B2D2FF",
      "checkbox-hovered-inner": "#D1E4FF",
      "checkbox-inner": "#EEEEEE",
      "checkbox-start": "#E4E4E4",
      "checkbox-end": "#F3F3F3",
      "checkbox-disabled-border": "#787878",
      "checkbox-disabled-inner": "#CACACA",
      "checkbox-disabled-start": "#D0D0D0",
      "checkbox-disabled-end": "#D8D8D8",
      "checkbox-hovered-inner-invalid": "#FAF2F2",
      "checkbox-hovered-invalid": "#F7E9E9",
      "radiobutton-checked": "#005BC3",
      "radiobutton-disabled": "#D5D5D5",
      "radiobutton-checked-disabled": "#7B7B7B",
      "radiobutton-hovered-invalid": "#F7EAEA",
      "tooltip-error": "#C82C2C",
      "scrollbar-start": "#CCCCCC",
      "scrollbar-end": "#F1F1F1",
      "scrollbar-slider-start": "#EEEEEE",
      "scrollbar-slider-end": "#C3C3C3",
      "button-border-disabled": "#959595",
      "button-start": "#F0F0F0",
      "button-end": "#AFAFAF",
      "button-disabled-start": "#F4F4F4",
      "button-disabled-end": "#BABABA",
      "button-hovered-start": "#F0F9FE",
      "button-hovered-end": "#8EB8D6",
      "button-focused": "#83BAEA",
      "border-invalid": "#930000",
      "input-start": "#F0F0F0",
      "input-end": "#FBFCFB",
      "input-focused-start": "#D7E7F4",
      "input-focused-end": "#5CB0FD",
      "input-focused-inner-invalid": "#FF6B78",
      "input-border-disabled": "#9B9B9B",
      "input-border-inner": "white",
      "toolbar-start": "#EFEFEF",
      "toolbar-end": "#DDDDDD",
      "window-border": "#00204D",
      "window-border-caption": "#727272",
      "window-caption-active-text": "white",
      "window-caption-active-start": "#084FAA",
      "window-caption-active-end": "#003B91",
      "window-caption-inactive-start": "#F2F2F2",
      "window-caption-inactive-end": "#DBDBDB",
      "window-statusbar-background": "#EFEFEF",
      "tabview-start": "#FCFCFC",
      "tabview-end": "#EEEEEE",
      "tabview-inactive": "#777D8D",
      "tabview-inactive-start": "#EAEAEA",
      "tabview-inactive-end": "#CECECE",
      "table-header-start": "#E8E8E8",
      "table-header-end": "#B3B3B3",
      "menu-start": "#E8E8E9",
      "menu-end": "#D9D9D9",
      "menubar-start": "#E8E8E8",
      "groupitem-start": "#A7A7A7",
      "groupitem-end": "#949494",
      "groupitem-text": "white",
      "virtual-row-layer-background-even": "white",
      "virtual-row-layer-background-odd": "white"
    }
  });
  qx.theme.modern.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.modern.Color": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Theme.define("qx.test.theme.manager.mock.Color", {
    extend: qx.theme.modern.Color,
    colors: {
      "text-label": "red",
      "border-button": "green",
      "button-start": "orange",
      "button-end": "yellow"
    }
  });
  qx.test.theme.manager.mock.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fabian Jakobs (fjakobs)
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Alexander Steitz (aback)
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   * The modern decoration theme.
   *
   * @asset(qx/decoration/Modern/toolbar/toolbar-part.gif)
   */
  qx.Theme.define("qx.theme.modern.Decoration", {
    aliases: {
      decoration: "qx/decoration/Modern"
    },
    decorations: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "main": {
        style: {
          width: 1,
          color: "border-main"
        }
      },
      "selected": {
        style: {
          startColorPosition: 0,
          endColorPosition: 100,
          startColor: "selected-start",
          endColor: "selected-end"
        }
      },
      "dragover": {
        style: {
          bottom: [2, "solid", "border-dragover"]
        }
      },
      "pane": {
        style: {
          width: 1,
          color: "tabview-background",
          radius: 3,
          shadowColor: "shadow",
          shadowBlurRadius: 2,
          shadowLength: 0,
          gradientStart: ["pane-start", 0],
          gradientEnd: ["pane-end", 100]
        }
      },
      "group": {
        style: {
          backgroundColor: "group-background",
          radius: 4,
          color: "group-border",
          width: 1
        }
      },
      "keyboard-focus": {
        style: {
          width: 1,
          color: "keyboard-focus",
          style: "dotted"
        }
      },

      /*
      ---------------------------------------------------------------------------
        RADIO BUTTON
      ---------------------------------------------------------------------------
      */
      "radiobutton": {
        style: {
          backgroundColor: "radiobutton-background",
          radius: 5,
          width: 1,
          innerWidth: 2,
          color: "checkbox-border",
          innerColor: "radiobutton-background",
          shadowLength: 0,
          shadowBlurRadius: 0,
          shadowColor: "checkbox-focus"
        }
      },
      "radiobutton-checked": {
        include: "radiobutton",
        style: {
          backgroundColor: "radiobutton-checked"
        }
      },
      "radiobutton-checked-focused": {
        include: "radiobutton-checked",
        style: {
          shadowBlurRadius: 4
        }
      },
      "radiobutton-checked-hovered": {
        include: "radiobutton-checked",
        style: {
          innerColor: "checkbox-hovered"
        }
      },
      "radiobutton-focused": {
        include: "radiobutton",
        style: {
          shadowBlurRadius: 4
        }
      },
      "radiobutton-hovered": {
        include: "radiobutton",
        style: {
          backgroundColor: "checkbox-hovered",
          innerColor: "checkbox-hovered"
        }
      },
      "radiobutton-disabled": {
        include: "radiobutton",
        style: {
          innerColor: "radiobutton-disabled",
          backgroundColor: "radiobutton-disabled",
          color: "checkbox-disabled-border"
        }
      },
      "radiobutton-checked-disabled": {
        include: "radiobutton-disabled",
        style: {
          backgroundColor: "radiobutton-checked-disabled"
        }
      },
      "radiobutton-invalid": {
        include: "radiobutton",
        style: {
          color: "invalid"
        }
      },
      "radiobutton-checked-invalid": {
        include: "radiobutton-checked",
        style: {
          color: "invalid"
        }
      },
      "radiobutton-checked-focused-invalid": {
        include: "radiobutton-checked-focused",
        style: {
          color: "invalid",
          shadowColor: "invalid"
        }
      },
      "radiobutton-checked-hovered-invalid": {
        include: "radiobutton-checked-hovered",
        style: {
          color: "invalid",
          innerColor: "radiobutton-hovered-invalid"
        }
      },
      "radiobutton-focused-invalid": {
        include: "radiobutton-focused",
        style: {
          color: "invalid",
          shadowColor: "invalid"
        }
      },
      "radiobutton-hovered-invalid": {
        include: "radiobutton-hovered",
        style: {
          color: "invalid",
          innerColor: "radiobutton-hovered-invalid",
          backgroundColor: "radiobutton-hovered-invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        SEPARATOR
      ---------------------------------------------------------------------------
      */
      "separator-horizontal": {
        style: {
          widthLeft: 1,
          colorLeft: "border-separator"
        }
      },
      "separator-vertical": {
        style: {
          widthTop: 1,
          colorTop: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLTIP
      ---------------------------------------------------------------------------
      */
      "tooltip-error": {
        style: {
          backgroundColor: "tooltip-error",
          radius: 4,
          shadowColor: "shadow",
          shadowBlurRadius: 2,
          shadowLength: 1
        }
      },

      /*
      ---------------------------------------------------------------------------
        POPUP
      ---------------------------------------------------------------------------
      */
      "popup": {
        style: {
          width: 1,
          color: "border-main",
          shadowColor: "shadow",
          shadowBlurRadius: 3,
          shadowLength: 1
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar-horizontal": {
        style: {
          gradientStart: ["scrollbar-start", 0],
          gradientEnd: ["scrollbar-end", 100]
        }
      },
      "scrollbar-vertical": {
        include: "scrollbar-horizontal",
        style: {
          orientation: "horizontal"
        }
      },
      "scrollbar-slider-horizontal": {
        style: {
          gradientStart: ["scrollbar-slider-start", 0],
          gradientEnd: ["scrollbar-slider-end", 100],
          color: "border-main",
          width: 1,
          radius: 3
        }
      },
      "scrollbar-slider-vertical": {
        include: "scrollbar-slider-horizontal",
        style: {
          orientation: "horizontal"
        }
      },
      "scrollbar-slider-horizontal-disabled": {
        include: "scrollbar-slider-horizontal",
        style: {
          color: "button-border-disabled"
        }
      },
      "scrollbar-slider-vertical-disabled": {
        include: "scrollbar-slider-vertical",
        style: {
          color: "button-border-disabled"
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button": {
        style: {
          radius: 3,
          color: "border-button",
          width: 1,
          startColor: "button-start",
          endColor: "button-end",
          startColorPosition: 35,
          endColorPosition: 100
        }
      },
      "button-disabled": {
        include: "button",
        style: {
          color: "button-border-disabled",
          startColor: "button-disabled-start",
          endColor: "button-disabled-end"
        }
      },
      "button-hovered": {
        include: "button",
        style: {
          startColor: "button-hovered-start",
          endColor: "button-hovered-end"
        }
      },
      "button-checked": {
        include: "button",
        style: {
          endColor: "button-start",
          startColor: "button-end"
        }
      },
      "button-pressed": {
        include: "button",
        style: {
          endColor: "button-hovered-start",
          startColor: "button-hovered-end"
        }
      },
      "button-focused": {
        style: {
          radius: 3,
          color: "border-button",
          width: 1,
          innerColor: "button-focused",
          innerWidth: 2,
          startColor: "button-start",
          endColor: "button-end",
          startColorPosition: 30,
          endColorPosition: 100
        }
      },
      "button-checked-focused": {
        include: "button-focused",
        style: {
          endColor: "button-start",
          startColor: "button-end"
        }
      },
      // invalid
      "button-invalid": {
        include: "button",
        style: {
          color: "border-invalid"
        }
      },
      "button-disabled-invalid": {
        include: "button-disabled",
        style: {
          color: "border-invalid"
        }
      },
      "button-hovered-invalid": {
        include: "button-hovered",
        style: {
          color: "border-invalid"
        }
      },
      "button-checked-invalid": {
        include: "button-checked",
        style: {
          color: "border-invalid"
        }
      },
      "button-pressed-invalid": {
        include: "button-pressed",
        style: {
          color: "border-invalid"
        }
      },
      "button-focused-invalid": {
        include: "button-focused",
        style: {
          color: "border-invalid"
        }
      },
      "button-checked-focused-invalid": {
        include: "button-checked-focused",
        style: {
          color: "border-invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        CHECK BOX
      ---------------------------------------------------------------------------
      */
      "checkbox": {
        style: {
          width: 1,
          color: "checkbox-border",
          innerWidth: 1,
          innerColor: "checkbox-inner",
          backgroundColor: "checkbox-end",
          shadowLength: 0,
          shadowBlurRadius: 0,
          shadowColor: "checkbox-focus"
        }
      },
      "checkbox-hovered": {
        include: "checkbox",
        style: {
          innerColor: "checkbox-hovered-inner",
          backgroundColor: "checkbox-hovered"
        }
      },
      "checkbox-focused": {
        include: "checkbox",
        style: {
          shadowBlurRadius: 4
        }
      },
      "checkbox-disabled": {
        include: "checkbox",
        style: {
          color: "checkbox-disabled-border",
          innerColor: "checkbox-disabled-inner",
          backgroundColor: "checkbox-disabled-end"
        }
      },
      "checkbox-invalid": {
        include: "checkbox",
        style: {
          color: "invalid"
        }
      },
      "checkbox-hovered-invalid": {
        include: "checkbox-hovered",
        style: {
          color: "invalid",
          innerColor: "checkbox-hovered-inner-invalid",
          backgroundColor: "checkbox-hovered-invalid"
        }
      },
      "checkbox-focused-invalid": {
        include: "checkbox-focused",
        style: {
          color: "invalid",
          shadowColor: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TEXT FIELD
      ---------------------------------------------------------------------------
      */
      "input": {
        style: {
          color: "border-input",
          innerColor: "border-inner-input",
          innerWidth: 1,
          width: 1,
          backgroundColor: "background-light",
          startColor: "input-start",
          endColor: "input-end",
          startColorPosition: 0,
          endColorPosition: 12,
          colorPositionUnit: "px"
        }
      },
      "border-invalid": {
        include: "input",
        style: {
          color: "border-invalid"
        }
      },
      "input-focused": {
        include: "input",
        style: {
          startColor: "input-focused-start",
          innerColor: "input-focused-end",
          endColorPosition: 4
        }
      },
      "input-focused-invalid": {
        include: "input-focused",
        style: {
          innerColor: "input-focused-inner-invalid",
          color: "border-invalid"
        }
      },
      "input-disabled": {
        include: "input",
        style: {
          color: "input-border-disabled"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar": {
        style: {
          startColorPosition: 40,
          endColorPosition: 60,
          startColor: "toolbar-start",
          endColor: "toolbar-end"
        }
      },
      "toolbar-button-hovered": {
        style: {
          color: "border-toolbar-button-outer",
          width: 1,
          innerWidth: 1,
          innerColor: "border-toolbar-border-inner",
          radius: 2,
          gradientStart: ["button-start", 30],
          gradientEnd: ["button-end", 100]
        }
      },
      "toolbar-button-checked": {
        include: "toolbar-button-hovered",
        style: {
          gradientStart: ["button-end", 30],
          gradientEnd: ["button-start", 100]
        }
      },
      "toolbar-separator": {
        style: {
          widthLeft: 1,
          widthRight: 1,
          colorLeft: "border-toolbar-separator-left",
          colorRight: "border-toolbar-separator-right",
          styleLeft: "solid",
          styleRight: "solid"
        }
      },
      "toolbar-part": {
        style: {
          backgroundImage: "decoration/toolbar/toolbar-part.gif",
          backgroundRepeat: "repeat-y"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview-pane": {
        style: {
          width: 1,
          color: "window-border",
          radius: 3,
          gradientStart: ["tabview-start", 90],
          gradientEnd: ["tabview-end", 100]
        }
      },
      "tabview-page-button-top-active": {
        style: {
          radius: [3, 3, 0, 0],
          width: [1, 1, 0, 1],
          color: "tabview-background",
          backgroundColor: "tabview-start",
          shadowLength: 1,
          shadowColor: "shadow",
          shadowBlurRadius: 2
        }
      },
      "tabview-page-button-top-inactive": {
        style: {
          radius: [3, 3, 0, 0],
          color: "tabview-inactive",
          colorBottom: "tabview-background",
          width: 1,
          gradientStart: ["tabview-inactive-start", 0],
          gradientEnd: ["tabview-inactive-end", 100]
        }
      },
      "tabview-page-button-bottom-active": {
        include: "tabview-page-button-top-active",
        style: {
          radius: [0, 0, 3, 3],
          width: [0, 1, 1, 1],
          backgroundColor: "tabview-inactive-start",
          shadowLength: 0,
          shadowBlurRadius: 0
        }
      },
      "tabview-page-button-bottom-inactive": {
        include: "tabview-page-button-top-inactive",
        style: {
          radius: [0, 0, 3, 3],
          width: [0, 1, 1, 1],
          colorBottom: "tabview-inactive",
          colorTop: "tabview-background"
        }
      },
      "tabview-page-button-left-active": {
        include: "tabview-page-button-top-active",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1],
          shadowLength: 0,
          shadowBlurRadius: 0
        }
      },
      "tabview-page-button-left-inactive": {
        include: "tabview-page-button-top-inactive",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1],
          colorBottom: "tabview-inactive",
          colorRight: "tabview-background"
        }
      },
      "tabview-page-button-right-active": {
        include: "tabview-page-button-top-active",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0],
          shadowLength: 0,
          shadowBlurRadius: 0
        }
      },
      "tabview-page-button-right-inactive": {
        include: "tabview-page-button-top-inactive",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0],
          colorBottom: "tabview-inactive",
          colorLeft: "tabview-background"
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane": {
        style: {
          backgroundColor: "background-pane",
          width: 3,
          color: "background-splitpane",
          style: "solid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: {
          radius: [5, 5, 0, 0],
          shadowBlurRadius: 4,
          shadowLength: 2,
          shadowColor: "shadow"
        }
      },
      "window-incl-statusbar": {
        include: "window",
        style: {
          radius: [5, 5, 5, 5]
        }
      },
      "window-resize-frame": {
        style: {
          radius: [5, 5, 0, 0],
          width: 1,
          color: "border-main"
        }
      },
      "window-resize-frame-incl-statusbar": {
        include: "window-resize-frame",
        style: {
          radius: [5, 5, 5, 5]
        }
      },
      "window-captionbar-active": {
        style: {
          width: 1,
          color: "window-border",
          colorBottom: "window-border-caption",
          radius: [5, 5, 0, 0],
          gradientStart: ["window-caption-active-start", 30],
          gradientEnd: ["window-caption-active-end", 70]
        }
      },
      "window-captionbar-inactive": {
        include: "window-captionbar-active",
        style: {
          gradientStart: ["window-caption-inactive-start", 30],
          gradientEnd: ["window-caption-inactive-end", 70]
        }
      },
      "window-statusbar": {
        style: {
          backgroundColor: "window-statusbar-background",
          width: [0, 1, 1, 1],
          color: "window-border",
          radius: [0, 0, 5, 5]
        }
      },
      "window-pane": {
        style: {
          backgroundColor: "background-pane",
          width: 1,
          color: "window-border",
          widthTop: 0
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table": {
        style: {
          width: 1,
          color: "border-main",
          style: "solid"
        }
      },
      "table-statusbar": {
        style: {
          widthTop: 1,
          colorTop: "border-main",
          style: "solid"
        }
      },
      "table-scroller-header": {
        style: {
          gradientStart: ["table-header-start", 10],
          gradientEnd: ["table-header-end", 90],
          widthBottom: 1,
          colorBottom: "border-main"
        }
      },
      "table-header-cell": {
        style: {
          widthRight: 1,
          colorRight: "border-separator",
          styleRight: "solid"
        }
      },
      "table-header-cell-hovered": {
        style: {
          widthRight: 1,
          colorRight: "border-separator",
          styleRight: "solid",
          widthBottom: 1,
          colorBottom: "table-header-hovered",
          styleBottom: "solid"
        }
      },
      "table-scroller-focus-indicator": {
        style: {
          width: 2,
          color: "table-focus-indicator",
          style: "solid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSIVE
      ---------------------------------------------------------------------------
      */
      "progressive-table-header": {
        style: {
          width: 1,
          color: "border-main",
          style: "solid"
        }
      },
      "progressive-table-header-cell": {
        style: {
          gradientStart: ["table-header-start", 10],
          gradientEnd: ["table-header-end", 90],
          widthRight: 1,
          colorRight: "progressive-table-header-border-right"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        style: {
          gradientStart: ["menu-start", 0],
          gradientEnd: ["menu-end", 100],
          shadowColor: "shadow",
          shadowBlurRadius: 2,
          shadowLength: 1,
          width: 1,
          color: "border-main"
        }
      },
      "menu-separator": {
        style: {
          widthTop: 1,
          colorTop: "menu-separator-top",
          widthBottom: 1,
          colorBottom: "menu-separator-bottom"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar": {
        style: {
          gradientStart: ["menubar-start", 0],
          gradientEnd: ["menu-end", 100],
          width: 1,
          color: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header": {
        style: {
          gradientStart: ["#243B58", 0],
          gradientEnd: ["#1D2D45", 100]
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: {
          width: 1,
          color: "border-input"
        }
      },

      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "group-item": {
        style: {
          startColorPosition: 0,
          endColorPosition: 100,
          startColor: "groupitem-start",
          endColor: "groupitem-end"
        }
      }
    }
  });
  qx.theme.modern.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.modern.Decoration": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Theme.define("qx.test.theme.manager.mock.Decoration", {
    extend: qx.theme.modern.Decoration,
    decorations: {
      "button": {
        style: {
          radius: 10,
          color: "border-button",
          width: 2,
          startColor: "button-start",
          endColor: "button-end",
          startColorPosition: 35,
          endColorPosition: 100
        }
      }
    }
  });
  qx.test.theme.manager.mock.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.modern.Font": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Theme.define("qx.test.theme.manager.mock.Font", {
    extend: qx.theme.modern.Font,
    fonts: {
      "default": {
        size: 99,
        family: ["arial", "sans-serif"]
      }
    }
  });
  qx.test.theme.manager.mock.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Fabian Jakobs (fjakobs)
     * Alexander Steitz (aback)
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The modern appearance theme.
   *
   * @asset(qx/icon/${qx.icontheme}/16/places/folder-open.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder.png)
   * @asset(qx/icon/${qx.icontheme}/16/mimetypes/office-document.png)
  
   * @asset(qx/icon/${qx.icontheme}/16/actions/window-close.png)
  
   * @asset(qx/icon/${qx.icontheme}/22/places/folder-open.png)
   * @asset(qx/icon/${qx.icontheme}/22/places/folder.png)
   * @asset(qx/icon/${qx.icontheme}/22/mimetypes/office-document.png)
  
   * @asset(qx/icon/${qx.icontheme}/32/places/folder-open.png)
   * @asset(qx/icon/${qx.icontheme}/32/places/folder.png)
   * @asset(qx/icon/${qx.icontheme}/32/mimetypes/office-document.png)
  
   * @asset(qx/icon/${qx.icontheme}/16/apps/office-calendar.png)
   * @asset(qx/icon/${qx.icontheme}/16/apps/utilities-color-chooser.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/view-refresh.png)
  
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-cancel.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-ok.png)
  
   * @asset(qx/decoration/Modern/cursors/*)
   *
   * @asset(qx/decoration/Modern/scrollbar/scrollbar-left.png)
   * @asset(qx/decoration/Modern/scrollbar/scrollbar-right.png)
   * @asset(qx/decoration/Modern/scrollbar/scrollbar-up.png)
   * @asset(qx/decoration/Modern/scrollbar/scrollbar-down.png)
   *
   * @asset(qx/decoration/Modern/toolbar/toolbar-handle-knob.gif)
   *
   * @asset(qx/decoration/Modern/tree/open-selected.png)
   * @asset(qx/decoration/Modern/tree/closed-selected.png)
   * @asset(qx/decoration/Modern/tree/open.png)
   * @asset(qx/decoration/Modern/tree/closed.png)
   *
   * @asset(qx/decoration/Modern/form/checked.png)
   * @asset(qx/decoration/Modern/form/undetermined.png)
   * @asset(qx/decoration/Modern/form/tooltip-error-arrow-right.png)
   * @asset(qx/decoration/Modern/form/tooltip-error-arrow.png)
   *
   * @asset(qx/decoration/Modern/window/minimize-active-hovered.png)
   * @asset(qx/decoration/Modern/window/minimize-active.png)
   * @asset(qx/decoration/Modern/window/minimize-inactive.png)
   * @asset(qx/decoration/Modern/window/restore-active-hovered.png)
   * @asset(qx/decoration/Modern/window/restore-active.png)
   * @asset(qx/decoration/Modern/window/restore-inactive.png)
   * @asset(qx/decoration/Modern/window/maximize-active-hovered.png)
   * @asset(qx/decoration/Modern/window/maximize-active.png)
   * @asset(qx/decoration/Modern/window/maximize-inactive.png)
   * @asset(qx/decoration/Modern/window/close-active-hovered.png)
   * @asset(qx/decoration/Modern/window/close-active.png)
   * @asset(qx/decoration/Modern/window/close-inactive.png)
   *
   * @asset(qx/decoration/Modern/splitpane/knob-horizontal.png)
   * @asset(qx/decoration/Modern/splitpane/knob-vertical.png)
   *
   * @asset(qx/decoration/Modern/arrows/down.png)
   * @asset(qx/decoration/Modern/arrows/up.png)
   * @asset(qx/decoration/Modern/arrows/right.png)
   * @asset(qx/decoration/Modern/arrows/left.png)
   * @asset(qx/decoration/Modern/arrows/rewind.png)
   * @asset(qx/decoration/Modern/arrows/forward.png)
   * @asset(qx/decoration/Modern/arrows/up-invert.png)
   * @asset(qx/decoration/Modern/arrows/down-invert.png)
   * @asset(qx/decoration/Modern/arrows/right-invert.png)
   * @asset(qx/decoration/Modern/arrows/up-small.png)
   * @asset(qx/decoration/Modern/arrows/down-small.png)
   *
   * @asset(qx/decoration/Modern/menu/checkbox-invert.gif)
   * @asset(qx/decoration/Modern/menu/checkbox.gif)
   * @asset(qx/decoration/Modern/menu/radiobutton-invert.gif)
   * @asset(qx/decoration/Modern/menu/radiobutton.gif)
   *
   * @asset(qx/decoration/Modern/table/select-column-order.png)
   * @asset(qx/decoration/Modern/table/ascending.png)
   * @asset(qx/decoration/Modern/table/descending.png)
   * @asset(qx/decoration/Modern/table/boolean-true.png)
   * @asset(qx/decoration/Modern/table/boolean-false.png)
   *
   * @asset(qx/static/blank.gif)
   * @asset(qx/static/blank.png)
   *
   * @asset(qx/decoration/Modern/colorselector/*)
   */
  qx.Theme.define("qx.theme.modern.Appearance", {
    appearances: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "widget": {},
      "root": {
        style: function style(states) {
          return {
            backgroundColor: "background-application",
            textColor: "text-label",
            font: "default"
          };
        }
      },
      "label": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "move-frame": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },
      "resize-frame": "move-frame",
      "dragdrop-cursor": {
        style: function style(states) {
          var icon = "nodrop";

          if (states.copy) {
            icon = "copy";
          } else if (states.move) {
            icon = "move";
          } else if (states.alias) {
            icon = "alias";
          }

          return {
            source: "decoration/cursors/" + icon + ".gif",
            position: "right-top",
            offset: [2, 16, 2, 6]
          };
        }
      },
      "image": {
        style: function style(states) {
          return {
            opacity: !states.replacement && states.disabled ? 0.3 : 1
          };
        }
      },
      "atom": {},
      "atom/label": "label",
      "atom/icon": "image",
      "popup": {
        style: function style(states) {
          return {
            decorator: "popup",
            backgroundColor: "background-light"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button-frame": {
        alias: "atom",
        style: function style(states) {
          var decorator, textColor;
          var padding = [3, 9]; // default padding

          if (states.checked && states.focused && !states.inner) {
            decorator = "button-checked-focused";
            textColor = undefined;
            padding = [1, 7];
          } else if (states.disabled) {
            decorator = "button-disabled";
            textColor = undefined;
          } else if (states.pressed) {
            decorator = "button-pressed";
            textColor = "text-hovered";
          } else if (states.checked) {
            decorator = "button-checked";
            textColor = undefined;
          } else if (states.hovered) {
            decorator = "button-hovered";
            textColor = "text-hovered";
          } else if (states.focused && !states.inner) {
            decorator = "button-focused";
            textColor = undefined;
            padding = [1, 7];
          } else {
            decorator = "button";
            textColor = undefined;
          }

          if (states.invalid && !states.disabled) {
            decorator += "-invalid";
          }

          return {
            decorator: decorator,
            textColor: textColor,
            padding: padding,
            margin: [1, 0]
          };
        }
      },
      "button-frame/image": {
        style: function style(states) {
          return {
            opacity: !states.replacement && states.disabled ? 0.5 : 1
          };
        }
      },
      "button": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          return {
            center: true
          };
        }
      },
      "hover-button": {
        alias: "atom",
        include: "atom",
        style: function style(states) {
          var decorator = states.hovered ? "selected" : undefined;
          return {
            decorator: decorator,
            textColor: states.hovered ? "text-selected" : undefined
          };
        }
      },
      "menubutton": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.png",
            iconPosition: "right"
          };
        }
      },
      "splitbutton": {},
      "splitbutton/button": "button",
      "splitbutton/arrow": {
        alias: "button",
        include: "button",
        style: function style(states, superStyles) {
          return {
            icon: "decoration/arrows/down.png",
            padding: [superStyles.padding[0], superStyles.padding[1] - 6],
            marginLeft: 1
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        FORM FIELDS
      ---------------------------------------------------------------------------
      */
      "form-renderer-label": {
        include: "label",
        style: function style() {
          return {
            paddingTop: 4
          };
        }
      },
      "checkbox": {
        alias: "atom",
        style: function style(states) {
          var icon;

          if (states.checked) {
            icon = "decoration/form/checked.png";
          } else if (states.undetermined) {
            icon = "decoration/form/undetermined.png";
          } else {
            icon = "qx/static/blank.gif";
          }

          return {
            icon: icon,
            minWidth: 14,
            gap: 8,
            paddingLeft: 2
          };
        }
      },
      "checkbox/icon": {
        style: function style(states) {
          var decorator;

          if (states.disabled) {
            decorator = "checkbox-disabled";
          } else if (states.focused) {
            decorator = "checkbox-focused";
          } else if (states.hovered) {
            decorator = "checkbox-hovered";
          } else {
            decorator = "checkbox";
          }

          decorator += states.invalid && !states.disabled ? "-invalid" : "";
          var padding = states.undetermined ? [3, 1] : 1;
          return {
            decorator: decorator,
            padding: padding,
            width: 10,
            height: 10
          };
        }
      },
      "radiobutton": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: "qx/static/blank.png",
            gap: 8,
            paddingLeft: 2
          };
        }
      },
      "radiobutton/icon": {
        style: function style(states) {
          var decorator;

          if (states.disabled && !states.checked) {
            decorator = "radiobutton-disabled";
          } else if (states.checked && states.focused) {
            decorator = "radiobutton-checked-focused";
          } else if (states.checked && states.disabled) {
            decorator = "radiobutton-checked-disabled";
          } else if (states.checked && states.hovered) {
            decorator = "radiobutton-checked-hovered";
          } else if (states.checked) {
            decorator = "radiobutton-checked";
          } else if (states.focused) {
            decorator = "radiobutton-focused";
          } else if (states.hovered) {
            decorator = "radiobutton-hovered";
          } else {
            decorator = "radiobutton";
          }

          decorator += states.invalid && !states.disabled ? "-invalid" : "";
          return {
            decorator: decorator,
            width: 10,
            height: 10
          };
        }
      },
      "textfield": {
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          var textColor;

          if (states.disabled) {
            textColor = "text-disabled";
          } else if (states.showingPlaceholder) {
            textColor = "text-placeholder";
          } else {
            textColor = "text-input";
          }

          return {
            decorator: decorator,
            padding: [2, 4, 1],
            textColor: textColor
          };
        }
      },
      "textarea": {
        include: "textfield",
        style: function style(states) {
          return {
            padding: 4
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPINNER
      ---------------------------------------------------------------------------
      */
      "spinner": {
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          return {
            decorator: decorator
          };
        }
      },
      "spinner/textfield": {
        style: function style(states) {
          return {
            marginRight: 2,
            padding: [2, 4, 1],
            textColor: states.disabled ? "text-disabled" : "text-input"
          };
        }
      },
      "spinner/upbutton": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states, superStyles) {
          return {
            icon: "decoration/arrows/up-small.png",
            padding: [superStyles.padding[0] - 1, superStyles.padding[1] - 5],
            margin: 0
          };
        }
      },
      "spinner/downbutton": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states, superStyles) {
          return {
            icon: "decoration/arrows/down-small.png",
            padding: [superStyles.padding[0] - 1, superStyles.padding[1] - 5],
            margin: 0
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATEFIELD
      ---------------------------------------------------------------------------
      */
      "datefield": "combobox",
      "datefield/button": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          return {
            icon: "icon/16/apps/office-calendar.png",
            padding: [0, 3],
            decorator: undefined
          };
        }
      },
      "datefield/textfield": "combobox/textfield",
      "datefield/list": {
        alias: "datechooser",
        include: "datechooser",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "groupbox": {
        style: function style(states) {
          return {
            legendPosition: "top"
          };
        }
      },
      "groupbox/legend": {
        alias: "atom",
        style: function style(states) {
          return {
            padding: [1, 0, 1, 4],
            textColor: states.invalid ? "invalid" : "text-title",
            font: "bold"
          };
        }
      },
      "groupbox/frame": {
        style: function style(states) {
          return {
            padding: 10,
            margin: 1,
            decorator: "group"
          };
        }
      },
      "check-groupbox": "groupbox",
      "check-groupbox/legend": {
        alias: "checkbox",
        include: "checkbox",
        style: function style(states) {
          return {
            padding: [1, 0, 1, 4],
            textColor: states.invalid ? "invalid" : "text-title",
            font: "bold"
          };
        }
      },
      "radio-groupbox": "groupbox",
      "radio-groupbox/legend": {
        alias: "radiobutton",
        include: "radiobutton",
        style: function style(states) {
          return {
            padding: [1, 0, 1, 4],
            textColor: states.invalid ? "invalid" : "text-title",
            font: "bold"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLLAREA
      ---------------------------------------------------------------------------
      */
      "scrollarea": "widget",
      "scrollarea/corner": {
        style: function style(states) {
          return {
            backgroundColor: "background-application"
          };
        }
      },
      "scrollarea/pane": "widget",
      "scrollarea/scrollbar-x": "scrollbar",
      "scrollarea/scrollbar-y": "scrollbar",

      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar": {
        style: function style(states) {
          if (states["native"]) {
            return {};
          }

          return {
            width: states.horizontal ? undefined : 16,
            height: states.horizontal ? 16 : undefined,
            decorator: states.horizontal ? "scrollbar-horizontal" : "scrollbar-vertical",
            padding: 1
          };
        }
      },
      "scrollbar/slider": {
        alias: "slider",
        style: function style(states) {
          return {
            padding: states.horizontal ? [0, 1, 0, 1] : [1, 0, 1, 0]
          };
        }
      },
      "scrollbar/slider/knob": {
        include: "button-frame",
        style: function style(states) {
          var decorator = states.horizontal ? "scrollbar-slider-horizontal" : "scrollbar-slider-vertical";

          if (states.disabled) {
            decorator += "-disabled";
          }

          return {
            decorator: decorator,
            minHeight: states.horizontal ? undefined : 9,
            minWidth: states.horizontal ? 9 : undefined,
            padding: undefined,
            margin: 0
          };
        }
      },
      "scrollbar/button": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          var icon = "decoration/scrollbar/scrollbar-";

          if (states.left) {
            icon += "left.png";
          } else if (states.right) {
            icon += "right.png";
          } else if (states.up) {
            icon += "up.png";
          } else {
            icon += "down.png";
          }

          if (states.left || states.right) {
            var paddingLeft = states.left ? 3 : 4;
            return {
              padding: [3, 0, 3, paddingLeft],
              icon: icon,
              width: 15,
              height: 14,
              margin: 0
            };
          } else {
            return {
              padding: 3,
              icon: icon,
              width: 14,
              height: 15,
              margin: 0
            };
          }
        }
      },
      "scrollbar/button-begin": "scrollbar/button",
      "scrollbar/button-end": "scrollbar/button",

      /*
      ---------------------------------------------------------------------------
        SLIDER
      ---------------------------------------------------------------------------
      */
      "slider": {
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          return {
            decorator: decorator
          };
        }
      },
      "slider/knob": {
        include: "button-frame",
        style: function style(states) {
          return {
            decorator: states.disabled ? "scrollbar-slider-horizontal-disabled" : "scrollbar-slider-horizontal",
            height: 14,
            width: 14,
            padding: 0,
            margin: 0
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        LIST
      ---------------------------------------------------------------------------
      */
      "list": {
        alias: "scrollarea",
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          return {
            backgroundColor: "background-light",
            decorator: decorator
          };
        }
      },
      "list/pane": "widget",
      "listitem": {
        alias: "atom",
        style: function style(states) {
          return {
            padding: states.dragover ? [4, 4, 2, 4] : 4,
            textColor: states.selected ? "text-selected" : undefined,
            decorator: states.selected ? "selected" : undefined,
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDEBAR
      ---------------------------------------------------------------------------
      */
      "slidebar": {},
      "slidebar/scrollpane": {},
      "slidebar/content": {},
      "slidebar/button-forward": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          return {
            padding: 5,
            center: true,
            icon: states.vertical ? "decoration/arrows/down.png" : "decoration/arrows/right.png"
          };
        }
      },
      "slidebar/button-backward": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          return {
            padding: 5,
            center: true,
            icon: states.vertical ? "decoration/arrows/up.png" : "decoration/arrows/left.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview": {
        style: function style(states) {
          return {
            contentPadding: 16
          };
        }
      },
      "tabview/bar": {
        alias: "slidebar",
        style: function style(states) {
          var result = {
            marginBottom: states.barTop ? -1 : 0,
            marginTop: states.barBottom ? -4 : 0,
            marginLeft: states.barRight ? -3 : 0,
            marginRight: states.barLeft ? -1 : 0,
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingLeft: 0
          };

          if (states.barTop || states.barBottom) {
            result.paddingLeft = 5;
            result.paddingRight = 7;
          } else {
            result.paddingTop = 5;
            result.paddingBottom = 7;
          }

          return result;
        }
      },
      "tabview/bar/button-forward": {
        include: "slidebar/button-forward",
        alias: "slidebar/button-forward",
        style: function style(states) {
          if (states.barTop || states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 2
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 2
            };
          }
        }
      },
      "tabview/bar/button-backward": {
        include: "slidebar/button-backward",
        alias: "slidebar/button-backward",
        style: function style(states) {
          if (states.barTop || states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 2
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 2
            };
          }
        }
      },
      "tabview/bar/scrollpane": {},
      "tabview/pane": {
        style: function style(states) {
          return {
            decorator: "tabview-pane",
            marginBottom: states.barBottom ? -1 : 0,
            marginTop: states.barTop ? -1 : 0,
            marginLeft: states.barLeft ? -1 : 0,
            marginRight: states.barRight ? -1 : 0
          };
        }
      },
      "tabview-page": {
        alias: "widget",
        include: "widget",
        style: function style(states) {
          // is used for the padding of the pane
          return {
            padding: [4, 3]
          };
        }
      },
      "tabview-page/button": {
        alias: "atom",
        style: function style(states) {
          var decorator,
              padding = 0;
          var marginTop = 0,
              marginBottom = 0,
              marginLeft = 0,
              marginRight = 0;

          if (states.checked) {
            if (states.barTop) {
              decorator = "tabview-page-button-top-active";
              padding = [5, 11];
              marginLeft = states.firstTab ? 0 : -5;
              marginRight = states.lastTab ? 0 : -5;
            } else if (states.barBottom) {
              decorator = "tabview-page-button-bottom-active";
              padding = [5, 11];
              marginLeft = states.firstTab ? 0 : -5;
              marginRight = states.lastTab ? 0 : -5;
              marginTop = 3;
            } else if (states.barRight) {
              decorator = "tabview-page-button-right-active";
              padding = [5, 10];
              marginTop = states.firstTab ? 0 : -5;
              marginBottom = states.lastTab ? 0 : -5;
              marginLeft = 2;
            } else {
              decorator = "tabview-page-button-left-active";
              padding = [5, 10];
              marginTop = states.firstTab ? 0 : -5;
              marginBottom = states.lastTab ? 0 : -5;
            }
          } else {
            if (states.barTop) {
              decorator = "tabview-page-button-top-inactive";
              padding = [3, 9];
              marginTop = 4;
              marginLeft = states.firstTab ? 5 : 1;
              marginRight = 1;
            } else if (states.barBottom) {
              decorator = "tabview-page-button-bottom-inactive";
              padding = [3, 9];
              marginBottom = 4;
              marginLeft = states.firstTab ? 5 : 1;
              marginRight = 1;
              marginTop = 3;
            } else if (states.barRight) {
              decorator = "tabview-page-button-right-inactive";
              padding = [3, 9];
              marginRight = 5;
              marginTop = states.firstTab ? 5 : 1;
              marginBottom = 1;
              marginLeft = 3;
            } else {
              decorator = "tabview-page-button-left-inactive";
              padding = [3, 9];
              marginLeft = 5;
              marginTop = states.firstTab ? 5 : 1;
              marginBottom = 1;
              marginRight = 1;
            }
          }

          return {
            zIndex: states.checked ? 10 : 5,
            decorator: decorator,
            padding: padding,
            marginTop: marginTop,
            marginBottom: marginBottom,
            marginLeft: marginLeft,
            marginRight: marginRight,
            textColor: states.disabled ? "text-disabled" : states.checked ? "text-active" : "text-inactive"
          };
        }
      },
      "tabview-page/button/label": {
        alias: "label",
        style: function style(states) {
          return {
            padding: states.focused ? [0, 1, 0, 1] : [1, 2, 1, 2],
            //margin : states.focused ? 0 : 1,
            decorator: states.focused ? "keyboard-focus" : undefined
          };
        }
      },
      "tabview-page/button/close-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: "icon/16/actions/window-close.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar": {
        style: function style(states) {
          return {
            decorator: "toolbar",
            spacing: 2
          };
        }
      },
      "toolbar/part": {
        style: function style(states) {
          return {
            decorator: "toolbar-part",
            spacing: 2
          };
        }
      },
      "toolbar/part/container": {
        style: function style(states) {
          return {
            paddingLeft: 2,
            paddingRight: 2
          };
        }
      },
      "toolbar/part/handle": {
        style: function style(states) {
          return {
            source: "decoration/toolbar/toolbar-handle-knob.gif",
            marginLeft: 3,
            marginRight: 3
          };
        }
      },
      "toolbar-button": {
        alias: "atom",
        style: function style(states) {
          var decorator;

          if (states.pressed || states.checked && !states.hovered || states.checked && states.disabled) {
            decorator = "toolbar-button-checked";
          } else if (states.hovered && !states.disabled) {
            decorator = "toolbar-button-hovered";
          }

          return {
            marginTop: 2,
            marginBottom: 2,
            padding: (states.pressed || states.checked || states.hovered) && !states.disabled || states.disabled && states.checked ? 3 : 5,
            decorator: decorator
          };
        }
      },
      "toolbar-menubutton": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          return {
            showArrow: true
          };
        }
      },
      "toolbar-menubutton/arrow": {
        alias: "image",
        include: "image",
        style: function style(states) {
          return {
            source: "decoration/arrows/down-small.png"
          };
        }
      },
      "toolbar-splitbutton": {
        style: function style(states) {
          return {
            marginTop: 2,
            marginBottom: 2
          };
        }
      },
      "toolbar-splitbutton/button": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.png",
            marginTop: undefined,
            marginBottom: undefined
          };
        }
      },
      "toolbar-splitbutton/arrow": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          if (states.pressed || states.checked || states.hovered && !states.disabled) {
            var padding = 1;
          } else {
            var padding = 3;
          }

          return {
            padding: padding,
            icon: "decoration/arrows/down.png",
            marginTop: undefined,
            marginBottom: undefined
          };
        }
      },
      "toolbar-separator": {
        style: function style(states) {
          return {
            decorator: "toolbar-separator",
            margin: 7
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREE
      ---------------------------------------------------------------------------
      */
      "tree": "list",
      "tree-item": {
        style: function style(states) {
          var decorator = states.selected ? "selected" : undefined;
          return {
            padding: [2, 6],
            textColor: states.selected ? "text-selected" : undefined,
            decorator: decorator,
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree-item/icon": {
        include: "image",
        style: function style(states) {
          return {
            paddingRight: 5
          };
        }
      },
      "tree-item/label": "label",
      "tree-item/open": {
        include: "image",
        style: function style(states) {
          var icon;

          if (states.selected && states.opened) {
            icon = "decoration/tree/open-selected.png";
          } else if (states.selected && !states.opened) {
            icon = "decoration/tree/closed-selected.png";
          } else if (states.opened) {
            icon = "decoration/tree/open.png";
          } else {
            icon = "decoration/tree/closed.png";
          }

          return {
            padding: [0, 5, 0, 2],
            source: icon
          };
        }
      },
      "tree-folder": {
        include: "tree-item",
        alias: "tree-item",
        style: function style(states) {
          var icon, iconOpened;

          if (states.small) {
            icon = states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png";
            iconOpened = "icon/16/places/folder-open.png";
          } else if (states.large) {
            icon = states.opened ? "icon/32/places/folder-open.png" : "icon/32/places/folder.png";
            iconOpened = "icon/32/places/folder-open.png";
          } else {
            icon = states.opened ? "icon/22/places/folder-open.png" : "icon/22/places/folder.png";
            iconOpened = "icon/22/places/folder-open.png";
          }

          return {
            icon: icon,
            iconOpened: iconOpened
          };
        }
      },
      "tree-file": {
        include: "tree-item",
        alias: "tree-item",
        style: function style(states) {
          return {
            icon: states.small ? "icon/16/mimetypes/office-document.png" : states.large ? "icon/32/mimetypes/office-document.png" : "icon/22/mimetypes/office-document.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREEVIRTUAL
      ---------------------------------------------------------------------------
      */
      "treevirtual": "table",
      "treevirtual-folder": {
        style: function style(states) {
          return {
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png"
          };
        }
      },
      "treevirtual-file": {
        include: "treevirtual-folder",
        alias: "treevirtual-folder",
        style: function style(states) {
          return {
            icon: "icon/16/mimetypes/office-document.png"
          };
        }
      },
      "treevirtual-line": {
        style: function style(states) {
          return {
            icon: "qx/static/blank.gif"
          };
        }
      },
      "treevirtual-contract": {
        style: function style(states) {
          return {
            icon: "decoration/tree/open.png",
            paddingLeft: 5,
            paddingTop: 2
          };
        }
      },
      "treevirtual-expand": {
        style: function style(states) {
          return {
            icon: "decoration/tree/closed.png",
            paddingLeft: 5,
            paddingTop: 2
          };
        }
      },
      "treevirtual-only-contract": "treevirtual-contract",
      "treevirtual-only-expand": "treevirtual-expand",
      "treevirtual-start-contract": "treevirtual-contract",
      "treevirtual-start-expand": "treevirtual-expand",
      "treevirtual-end-contract": "treevirtual-contract",
      "treevirtual-end-expand": "treevirtual-expand",
      "treevirtual-cross-contract": "treevirtual-contract",
      "treevirtual-cross-expand": "treevirtual-expand",
      "treevirtual-end": {
        style: function style(states) {
          return {
            icon: "qx/static/blank.gif"
          };
        }
      },
      "treevirtual-cross": {
        style: function style(states) {
          return {
            icon: "qx/static/blank.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOL TIP
      ---------------------------------------------------------------------------
      */
      "tooltip": {
        include: "popup",
        style: function style(states) {
          return {
            backgroundColor: "background-tip",
            padding: [1, 3, 2, 3],
            offset: [15, 5, 5, 5]
          };
        }
      },
      "tooltip/atom": "atom",
      "tooltip-error": {
        style: function style(states) {
          return {
            placeMethod: "widget",
            offset: [-3, 1, 0, 0],
            arrowPosition: states.placementLeft ? "left" : "right",
            position: "right-top",
            showTimeout: 100,
            hideTimeout: 10000,
            padding: [0, 4, 4, 0]
          };
        }
      },
      "tooltip-error/arrow": {
        include: "image",
        style: function style(states) {
          var source = states.placementLeft ? "decoration/form/tooltip-error-arrow-right.png" : "decoration/form/tooltip-error-arrow.png";
          return {
            source: source,
            padding: [6, 0, 0, 0],
            zIndex: 10000001
          };
        }
      },
      "tooltip-error/atom": {
        include: "popup",
        style: function style(states) {
          return {
            textColor: "text-selected",
            backgroundColor: undefined,
            decorator: "tooltip-error",
            font: "bold",
            padding: [3, 4, 4, 4],
            margin: [1, 0, 0, 0],
            maxWidth: 333
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: function style(states) {
          return {
            decorator: states.showStatusbar ? "window-incl-statusbar" : "window",
            contentPadding: [10, 10, 10, 10],
            margin: states.maximized ? 0 : [0, 5, 5, 0]
          };
        }
      },
      "window-resize-frame": {
        style: function style(states) {
          return {
            decorator: states.showStatusbar ? "window-resize-frame-incl-statusbar" : "window-resize-frame"
          };
        }
      },
      "window/pane": {
        style: function style(states) {
          return {
            decorator: "window-pane"
          };
        }
      },
      "window/captionbar": {
        style: function style(states) {
          return {
            decorator: states.active ? "window-captionbar-active" : "window-captionbar-inactive",
            textColor: states.active ? "window-caption-active-text" : "text-gray",
            minHeight: 26,
            paddingRight: 2
          };
        }
      },
      "window/icon": {
        style: function style(states) {
          return {
            margin: [5, 0, 3, 6]
          };
        }
      },
      "window/title": {
        style: function style(states) {
          return {
            alignY: "middle",
            font: "bold",
            marginLeft: 6,
            marginRight: 12
          };
        }
      },
      "window/minimize-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: states.active ? states.hovered ? "decoration/window/minimize-active-hovered.png" : "decoration/window/minimize-active.png" : "decoration/window/minimize-inactive.png",
            margin: [4, 8, 2, 0]
          };
        }
      },
      "window/restore-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: states.active ? states.hovered ? "decoration/window/restore-active-hovered.png" : "decoration/window/restore-active.png" : "decoration/window/restore-inactive.png",
            margin: [5, 8, 2, 0]
          };
        }
      },
      "window/maximize-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: states.active ? states.hovered ? "decoration/window/maximize-active-hovered.png" : "decoration/window/maximize-active.png" : "decoration/window/maximize-inactive.png",
            margin: [4, 8, 2, 0]
          };
        }
      },
      "window/close-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: states.active ? states.hovered ? "decoration/window/close-active-hovered.png" : "decoration/window/close-active.png" : "decoration/window/close-inactive.png",
            margin: [4, 8, 2, 0]
          };
        }
      },
      "window/statusbar": {
        style: function style(states) {
          return {
            padding: [2, 6],
            decorator: "window-statusbar",
            minHeight: 18
          };
        }
      },
      "window/statusbar-text": {
        style: function style(states) {
          return {
            font: "small"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        IFRAME
      ---------------------------------------------------------------------------
      */
      "iframe": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        RESIZER
      ---------------------------------------------------------------------------
      */
      "resizer": {
        style: function style(states) {
          return {
            decorator: "pane"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane": {
        style: function style(states) {
          return {
            decorator: "splitpane"
          };
        }
      },
      "splitpane/splitter": {
        style: function style(states) {
          return {
            width: states.horizontal ? 3 : undefined,
            height: states.vertical ? 3 : undefined,
            backgroundColor: "background-splitpane"
          };
        }
      },
      "splitpane/splitter/knob": {
        style: function style(states) {
          return {
            source: states.horizontal ? "decoration/splitpane/knob-horizontal.png" : "decoration/splitpane/knob-vertical.png"
          };
        }
      },
      "splitpane/slider": {
        style: function style(states) {
          return {
            width: states.horizontal ? 3 : undefined,
            height: states.vertical ? 3 : undefined,
            backgroundColor: "background-splitpane"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTBOX
      ---------------------------------------------------------------------------
      */
      "selectbox": "button-frame",
      "selectbox/atom": "atom",
      "selectbox/popup": "popup",
      "selectbox/list": {
        alias: "list"
      },
      "selectbox/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: "decoration/arrows/down.png",
            paddingLeft: 5
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser": {
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          return {
            padding: 2,
            decorator: decorator,
            backgroundColor: "background-light"
          };
        }
      },
      "datechooser/navigation-bar": {},
      "datechooser/nav-button": {
        include: "button-frame",
        alias: "button-frame",
        style: function style(states) {
          var result = {
            padding: [2, 4]
          };

          if (states.lastYear) {
            result.icon = "decoration/arrows/rewind.png";
            result.marginRight = 1;
          } else if (states.lastMonth) {
            result.icon = "decoration/arrows/left.png";
          } else if (states.nextYear) {
            result.icon = "decoration/arrows/forward.png";
            result.marginLeft = 1;
          } else if (states.nextMonth) {
            result.icon = "decoration/arrows/right.png";
          }

          return result;
        }
      },
      "datechooser/last-year-button-tooltip": "tooltip",
      "datechooser/last-month-button-tooltip": "tooltip",
      "datechooser/next-year-button-tooltip": "tooltip",
      "datechooser/next-month-button-tooltip": "tooltip",
      "datechooser/last-year-button": "datechooser/nav-button",
      "datechooser/last-month-button": "datechooser/nav-button",
      "datechooser/next-month-button": "datechooser/nav-button",
      "datechooser/next-year-button": "datechooser/nav-button",
      "datechooser/month-year-label": {
        style: function style(states) {
          return {
            font: "bold",
            textAlign: "center",
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "datechooser/date-pane": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined,
            marginTop: 2
          };
        }
      },
      "datechooser/weekday": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : states.weekend ? "text-light" : undefined,
            textAlign: "center",
            paddingTop: 2,
            backgroundColor: "background-medium"
          };
        }
      },
      "datechooser/week": {
        style: function style(states) {
          return {
            textAlign: "center",
            padding: [2, 4],
            backgroundColor: "background-medium"
          };
        }
      },
      "datechooser/day": {
        style: function style(states) {
          var decorator = states.disabled ? undefined : states.selected ? "selected" : undefined;
          return {
            textAlign: "center",
            decorator: decorator,
            textColor: states.disabled ? "text-disabled" : states.selected ? "text-selected" : states.otherMonth ? "text-light" : undefined,
            font: states.today ? "bold" : undefined,
            padding: [2, 4]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COMBOBOX
      ---------------------------------------------------------------------------
      */
      "combobox": {
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          return {
            decorator: decorator
          };
        }
      },
      "combobox/popup": "popup",
      "combobox/list": {
        alias: "list"
      },
      "combobox/button": {
        include: "button-frame",
        alias: "button-frame",
        style: function style(states, superStyles) {
          var ret = {
            icon: "decoration/arrows/down.png",
            padding: [superStyles.padding[0], superStyles.padding[1] - 6],
            margin: undefined
          };

          if (states.selected) {
            ret.decorator = "button-focused";
          }

          return ret;
        }
      },
      "combobox/textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        style: function style(states) {
          var result = {
            decorator: "menu",
            spacingX: 6,
            spacingY: 1,
            iconColumnWidth: 16,
            arrowColumnWidth: 4,
            placementModeY: states.submenu || states.contextmenu ? "best-fit" : "keep-align"
          };

          if (states.submenu) {
            result.position = "right-top";
            result.offset = [-2, -3];
          }

          return result;
        }
      },
      "menu/slidebar": "menu-slidebar",
      "menu-slidebar": "widget",
      "menu-slidebar-button": {
        style: function style(states) {
          var decorator = states.hovered ? "selected" : undefined;
          return {
            decorator: decorator,
            padding: 7,
            center: true
          };
        }
      },
      "menu-slidebar/button-backward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: states.hovered ? "decoration/arrows/up-invert.png" : "decoration/arrows/up.png"
          };
        }
      },
      "menu-slidebar/button-forward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: states.hovered ? "decoration/arrows/down-invert.png" : "decoration/arrows/down.png"
          };
        }
      },
      "menu-separator": {
        style: function style(states) {
          return {
            height: 0,
            decorator: "menu-separator",
            margin: [4, 2]
          };
        }
      },
      "menu-button": {
        alias: "atom",
        style: function style(states) {
          var decorator = states.selected ? "selected" : undefined;
          return {
            decorator: decorator,
            textColor: states.selected ? "text-selected" : undefined,
            padding: [4, 6]
          };
        }
      },
      "menu-button/icon": {
        include: "image",
        style: function style(states) {
          return {
            alignY: "middle"
          };
        }
      },
      "menu-button/label": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            padding: 1
          };
        }
      },
      "menu-button/shortcut": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            marginLeft: 14,
            padding: 1
          };
        }
      },
      "menu-button/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: states.selected ? "decoration/arrows/right-invert.png" : "decoration/arrows/right.png",
            alignY: "middle"
          };
        }
      },
      "menu-checkbox": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : states.selected ? "decoration/menu/checkbox-invert.gif" : "decoration/menu/checkbox.gif"
          };
        }
      },
      "menu-radiobutton": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : states.selected ? "decoration/menu/radiobutton-invert.gif" : "decoration/menu/radiobutton.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar": {
        style: function style(states) {
          return {
            decorator: "menubar"
          };
        }
      },
      "menubar-button": {
        alias: "atom",
        style: function style(states) {
          var decorator = (states.pressed || states.hovered) && !states.disabled ? "selected" : undefined;
          return {
            decorator: decorator,
            textColor: states.pressed || states.hovered ? "text-selected" : undefined,
            padding: [3, 8]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR SELECTOR
      ---------------------------------------------------------------------------
      */
      "colorselector": "widget",
      "colorselector/control-bar": "widget",
      "colorselector/control-pane": "widget",
      "colorselector/visual-pane": "groupbox",
      "colorselector/preset-grid": "widget",
      "colorselector/colorbucket": {
        style: function style(states) {
          return {
            decorator: "main",
            width: 16,
            height: 16
          };
        }
      },
      "colorselector/preset-field-set": "groupbox",
      "colorselector/input-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 20
          };
        }
      },
      "colorselector/preview-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 20
          };
        }
      },
      "colorselector/hex-field-composite": "widget",
      "colorselector/hex-field": "textfield",
      "colorselector/rgb-spinner-composite": "widget",
      "colorselector/rgb-spinner-red": "spinner",
      "colorselector/rgb-spinner-green": "spinner",
      "colorselector/rgb-spinner-blue": "spinner",
      "colorselector/hsb-spinner-composite": "widget",
      "colorselector/hsb-spinner-hue": "spinner",
      "colorselector/hsb-spinner-saturation": "spinner",
      "colorselector/hsb-spinner-brightness": "spinner",
      "colorselector/preview-content-old": {
        style: function style(states) {
          return {
            decorator: "main",
            width: 50,
            height: 10
          };
        }
      },
      "colorselector/preview-content-new": {
        style: function style(states) {
          return {
            decorator: "main",
            backgroundColor: "background-light",
            width: 50,
            height: 10
          };
        }
      },
      "colorselector/hue-saturation-field": {
        style: function style(states) {
          return {
            decorator: "main",
            margin: 5
          };
        }
      },
      "colorselector/brightness-field": {
        style: function style(states) {
          return {
            decorator: "main",
            margin: [5, 7]
          };
        }
      },
      "colorselector/hue-saturation-pane": "widget",
      "colorselector/hue-saturation-handle": "widget",
      "colorselector/brightness-pane": "widget",
      "colorselector/brightness-handle": "widget",

      /*
      ---------------------------------------------------------------------------
        COLOR POPUP
      ---------------------------------------------------------------------------
      */
      "colorpopup": {
        alias: "popup",
        include: "popup",
        style: function style(states) {
          return {
            padding: 5,
            backgroundColor: "background-application"
          };
        }
      },
      "colorpopup/field": {
        style: function style(states) {
          return {
            decorator: "main",
            margin: 2,
            width: 14,
            height: 14,
            backgroundColor: "background-light"
          };
        }
      },
      "colorpopup/selector-button": "button",
      "colorpopup/auto-button": "button",
      "colorpopup/preview-pane": "groupbox",
      "colorpopup/current-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginLeft: 4,
            decorator: "main",
            allowGrowX: true
          };
        }
      },
      "colorpopup/selected-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginRight: 4,
            decorator: "main",
            allowGrowX: true
          };
        }
      },
      "colorpopup/colorselector-okbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-ok.png"
          };
        }
      },
      "colorpopup/colorselector-cancelbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-cancel.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table": {
        alias: "widget",
        style: function style(states) {
          return {
            decorator: "table"
          };
        }
      },
      "table/statusbar": {
        style: function style(states) {
          return {
            decorator: "table-statusbar",
            padding: [0, 2]
          };
        }
      },
      "table/column-button": {
        alias: "button-frame",
        style: function style(states) {
          return {
            decorator: "table-scroller-header",
            padding: 3,
            icon: "decoration/table/select-column-order.png"
          };
        }
      },
      "table-column-reset-button": {
        include: "menu-button",
        alias: "menu-button",
        style: function style() {
          return {
            icon: "icon/16/actions/view-refresh.png"
          };
        }
      },
      "table-scroller": "widget",
      "table-scroller/scrollbar-x": "scrollbar",
      "table-scroller/scrollbar-y": "scrollbar",
      "table-scroller/header": {
        style: function style(states) {
          return {
            decorator: "table-scroller-header",
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "table-scroller/pane": {
        style: function style(states) {
          return {
            backgroundColor: "table-pane"
          };
        }
      },
      "table-scroller/focus-indicator": {
        style: function style(states) {
          return {
            decorator: "table-scroller-focus-indicator"
          };
        }
      },
      "table-scroller/resize-line": {
        style: function style(states) {
          return {
            backgroundColor: "border-separator",
            width: 2
          };
        }
      },
      "table-header-cell": {
        alias: "atom",
        style: function style(states) {
          return {
            minWidth: 13,
            minHeight: 20,
            padding: states.hovered ? [3, 4, 2, 4] : [3, 4],
            decorator: states.hovered ? "table-header-cell-hovered" : "table-header-cell",
            sortIcon: states.sorted ? states.sortedAscending ? "decoration/table/ascending.png" : "decoration/table/descending.png" : undefined
          };
        }
      },
      "table-header-cell/label": {
        style: function style(states) {
          return {
            minWidth: 0,
            alignY: "middle",
            paddingRight: 5
          };
        }
      },
      "table-header-cell/sort-icon": {
        style: function style(states) {
          return {
            alignY: "middle",
            alignX: "right",
            opacity: states.disabled ? 0.3 : 1
          };
        }
      },
      "table-header-cell/icon": {
        style: function style(states) {
          return {
            minWidth: 0,
            alignY: "middle",
            paddingRight: 5,
            opacity: states.disabled ? 0.3 : 1
          };
        }
      },
      "table-editor-textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 2],
            backgroundColor: "background-light"
          };
        }
      },
      "table-editor-selectbox": {
        include: "selectbox",
        alias: "selectbox",
        style: function style(states) {
          return {
            padding: [0, 2],
            backgroundColor: "background-light"
          };
        }
      },
      "table-editor-combobox": {
        include: "combobox",
        alias: "combobox",
        style: function style(states) {
          return {
            decorator: undefined,
            backgroundColor: "background-light"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSIVE
      ---------------------------------------------------------------------------
      */
      "progressive-table-header": {
        alias: "widget",
        style: function style(states) {
          return {
            decorator: "progressive-table-header"
          };
        }
      },
      "progressive-table-header-cell": {
        alias: "atom",
        style: function style(states) {
          return {
            minWidth: 40,
            minHeight: 25,
            paddingLeft: 6,
            decorator: "progressive-table-header-cell"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header": {
        style: function style(states) {
          return {
            font: "bold",
            textColor: "text-selected",
            padding: [8, 12],
            decorator: "app-header"
          };
        }
      },
      "app-header-label": "label",
      "app-splitpane": {
        alias: "splitpane",
        style: function style(states) {
          return {
            padding: 0
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "virtual-list": "list",
      "virtual-list/row-layer": "row-layer",
      "row-layer": "widget",
      "group-item": {
        include: "label",
        alias: "label",
        style: function style(states) {
          return {
            padding: 4,
            decorator: "group-item",
            textColor: "groupitem-text",
            font: "bold"
          };
        }
      },
      "virtual-selectbox": "selectbox",
      "virtual-selectbox/dropdown": "popup",
      "virtual-selectbox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-combobox": "combobox",
      "virtual-combobox/dropdown": "popup",
      "virtual-combobox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-tree": {
        include: "tree",
        alias: "tree",
        style: function style(states) {
          return {
            itemHeight: 26
          };
        }
      },
      "virtual-tree-folder": "tree-folder",
      "virtual-tree-file": "tree-file",
      "column-layer": "widget",
      "cell": {
        style: function style(states) {
          return {
            textColor: states.selected ? "text-selected" : "text-label",
            padding: [3, 6],
            font: "default"
          };
        }
      },
      "cell-string": "cell",
      "cell-number": {
        include: "cell",
        style: function style(states) {
          return {
            textAlign: "right"
          };
        }
      },
      "cell-image": "cell",
      "cell-boolean": {
        include: "cell",
        style: function style(states) {
          return {
            iconTrue: "decoration/table/boolean-true.png",
            iconFalse: "decoration/table/boolean-false.png"
          };
        }
      },
      "cell-atom": "cell",
      "cell-date": "cell",
      "cell-html": "cell",

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: function style(states) {
          return {
            decorator: "progressbar",
            padding: [1],
            backgroundColor: "progressbar-background",
            width: 200,
            height: 20
          };
        }
      },
      "progressbar/progress": {
        style: function style(states) {
          return {
            decorator: states.disabled ? "group-item" : "selected"
          };
        }
      }
    }
  });
  qx.theme.modern.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.modern.Appearance": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Theme.define("qx.test.theme.manager.mock.Appearance", {
    extend: qx.theme.modern.Appearance,
    appearances: {
      "button-frame": {
        alias: "atom",
        style: function style(states) {
          return {
            decorator: "button",
            padding: [30, 80]
          };
        }
      },
      "button-frame/label": {
        alias: "atom/label",
        style: function style(states) {
          return {
            textColor: "text-label"
          };
        }
      }
    }
  });
  qx.test.theme.manager.mock.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * Tango icons
   */
  qx.Theme.define("qx.theme.icon.Tango", {
    title: "Tango",
    aliases: {
      "icon": "qx/icon/Tango"
    }
  });
  qx.theme.icon.Tango.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.simple.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The simple qooxdoo appearance theme.
   *
   * @asset(qx/icon/${qx.icontheme}/16/apps/office-calendar.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder-open.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder.png)
   * @asset(qx/icon/${qx.icontheme}/16/mimetypes/text-plain.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/view-refresh.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/window-close.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-cancel.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-ok.png)
   */
  qx.Theme.define("qx.theme.simple.Appearance", {
    appearances: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "widget": {},
      "label": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "image": {
        style: function style(states) {
          return {
            opacity: !states.replacement && states.disabled ? 0.3 : undefined
          };
        }
      },
      "atom": {},
      "atom/label": "label",
      "atom/icon": "image",
      "root": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: "text",
            font: "default"
          };
        }
      },
      "popup": {
        style: function style(states) {
          return {
            decorator: "popup",
            backgroundColor: "background-pane"
          };
        }
      },
      "tooltip": {
        include: "popup",
        style: function style(states) {
          return {
            backgroundColor: "tooltip",
            textColor: "tooltip-text",
            decorator: "tooltip",
            padding: [1, 3, 2, 3],
            offset: [10, 5, 5, 5]
          };
        }
      },
      "tooltip/atom": "atom",
      "tooltip-error": {
        include: "tooltip",
        style: function style(states) {
          return {
            textColor: "text-selected",
            showTimeout: 100,
            hideTimeout: 10000,
            decorator: "tooltip-error",
            font: "bold",
            backgroundColor: undefined
          };
        }
      },
      "tooltip-error/atom": "atom",
      "iframe": {
        style: function style(states) {
          return {
            backgroundColor: "white",
            decorator: "main-dark"
          };
        }
      },
      "move-frame": {
        style: function style(states) {
          return {
            decorator: "main-dark"
          };
        }
      },
      "resize-frame": "move-frame",
      "dragdrop-cursor": {
        style: function style(states) {
          var icon = "nodrop";

          if (states.copy) {
            icon = "copy";
          } else if (states.move) {
            icon = "move";
          } else if (states.alias) {
            icon = "alias";
          }

          return {
            source: qx.theme.simple.Image.URLS["cursor-" + icon],
            position: "right-top",
            offset: [2, 16, 2, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDEBAR
      ---------------------------------------------------------------------------
      */
      "slidebar": {},
      "slidebar/scrollpane": {},
      "slidebar/content": {},
      "slidebar/button-forward": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-" + (states.vertical ? "down" : "right")]
          };
        }
      },
      "slidebar/button-backward": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-" + (states.vertical ? "up" : "left")]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table": "widget",
      "table/statusbar": {
        style: function style(states) {
          return {
            decorator: "statusbar",
            padding: [2, 5]
          };
        }
      },
      "table/column-button": {
        alias: "button",
        style: function style(states) {
          return {
            decorator: "table-header-column-button",
            padding: 3,
            icon: qx.theme.simple.Image.URLS["select-column-order"]
          };
        }
      },
      "table-column-reset-button": {
        include: "menu-button",
        alias: "menu-button",
        style: function style() {
          return {
            icon: "icon/16/actions/view-refresh.png"
          };
        }
      },
      "table-scroller/scrollbar-x": "scrollbar",
      "table-scroller/scrollbar-y": "scrollbar",
      "table-scroller": "widget",
      "table-scroller/header": {
        style: function style() {
          return {
            decorator: "table-header"
          };
        }
      },
      "table-scroller/pane": {},
      "table-scroller/focus-indicator": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },
      "table-scroller/resize-line": {
        style: function style(states) {
          return {
            backgroundColor: "button-border",
            width: 3
          };
        }
      },
      "table-header-cell": {
        alias: "atom",
        style: function style(states) {
          return {
            decorator: states.first ? "table-header-cell-first" : "table-header-cell",
            minWidth: 13,
            font: "bold",
            paddingTop: 3,
            paddingLeft: 5,
            cursor: states.disabled ? undefined : "pointer",
            sortIcon: states.sorted ? qx.theme.simple.Image.URLS["table-" + (states.sortedAscending ? "ascending" : "descending")] : undefined
          };
        }
      },
      "table-header-cell/icon": {
        include: "atom/icon",
        style: function style(states) {
          return {
            paddingRight: 5
          };
        }
      },
      "table-header-cell/sort-icon": {
        style: function style(states) {
          return {
            alignY: "middle",
            alignX: "right",
            paddingRight: 5
          };
        }
      },
      "table-editor-textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 2]
          };
        }
      },
      "table-editor-selectbox": {
        include: "selectbox",
        alias: "selectbox",
        style: function style(states) {
          return {
            padding: [0, 2]
          };
        }
      },
      "table-editor-combobox": {
        include: "combobox",
        alias: "combobox",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },
      "progressive-table-header": {
        style: function style(states) {
          return {
            decorator: "progressive-table-header"
          };
        }
      },
      "progressive-table-header-cell": {
        style: function style(states) {
          return {
            decorator: "progressive-table-header-cell",
            padding: [5, 6, 5, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREEVIRTUAL
      ---------------------------------------------------------------------------
      */
      "treevirtual": {
        include: "textfield",
        alias: "table",
        style: function style(states, superStyles) {
          return {
            padding: [superStyles.padding[0] + 2, superStyles.padding[1] + 1]
          };
        }
      },
      "treevirtual-folder": {
        style: function style(states) {
          return {
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-file": {
        include: "treevirtual-folder",
        alias: "treevirtual-folder",
        style: function style(states) {
          return {
            icon: "icon/16/mimetypes/text-plain.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-line": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-line"]
          };
        }
      },
      "treevirtual-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["tree-minus"]
          };
        }
      },
      "treevirtual-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["tree-plus"]
          };
        }
      },
      "treevirtual-only-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-only"]
          };
        }
      },
      "treevirtual-only-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-only"]
          };
        }
      },
      "treevirtual-start-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-start"]
          };
        }
      },
      "treevirtual-start-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-start"]
          };
        }
      },
      "treevirtual-end-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-end"]
          };
        }
      },
      "treevirtual-end-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-end"]
          };
        }
      },
      "treevirtual-cross-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-cross"]
          };
        }
      },
      "treevirtual-cross-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-cross"]
          };
        }
      },
      "treevirtual-end": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-end"]
          };
        }
      },
      "treevirtual-cross": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-cross"]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        RESIZER
      ---------------------------------------------------------------------------
      */
      "resizer": {
        style: function style(states) {
          return {
            decorator: "main-dark"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane": {},
      "splitpane/splitter": {
        style: function style(states) {
          return {
            backgroundColor: "light-background"
          };
        }
      },
      "splitpane/splitter/knob": {
        style: function style(states) {
          return {
            source: qx.theme.simple.Image.URLS["knob-" + (states.horizontal ? "horizontal" : "vertical")],
            padding: 2
          };
        }
      },
      "splitpane/slider": {
        style: function style(states) {
          return {
            backgroundColor: "border-light-shadow",
            opacity: 0.3
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        style: function style(states) {
          var result = {
            backgroundColor: "background",
            decorator: "main",
            spacingX: 6,
            spacingY: 1,
            iconColumnWidth: 16,
            arrowColumnWidth: 4,
            padding: 1,
            placementModeY: states.submenu || states.contextmenu ? "best-fit" : "keep-align"
          };

          if (states.submenu) {
            result.position = "right-top";
            result.offset = [-2, -3];
          }

          if (states.contextmenu) {
            result.offset = 4;
          }

          return result;
        }
      },
      "menu/slidebar": "menu-slidebar",
      "menu-slidebar": "widget",
      "menu-slidebar-button": {
        style: function style(states) {
          return {
            backgroundColor: states.hovered ? "background-selected" : undefined,
            padding: 6,
            center: true
          };
        }
      },
      "menu-slidebar/button-backward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-up" + (states.hovered ? "-invert" : "")]
          };
        }
      },
      "menu-slidebar/button-forward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-down" + (states.hovered ? "-invert" : "")]
          };
        }
      },
      "menu-separator": {
        style: function style(states) {
          return {
            height: 0,
            decorator: "menu-separator",
            marginTop: 4,
            marginBottom: 4,
            marginLeft: 2,
            marginRight: 2
          };
        }
      },
      "menu-button": {
        alias: "atom",
        style: function style(states) {
          return {
            backgroundColor: states.selected ? "background-selected" : undefined,
            textColor: states.selected ? "text-selected" : undefined,
            padding: [2, 6]
          };
        }
      },
      "menu-button/icon": {
        include: "image",
        style: function style(states) {
          return {
            alignY: "middle"
          };
        }
      },
      "menu-button/label": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            padding: 1
          };
        }
      },
      "menu-button/shortcut": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            marginLeft: 14,
            padding: 1
          };
        }
      },
      "menu-button/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: qx.theme.simple.Image.URLS["arrow-right" + (states.selected ? "-invert" : "")],
            alignY: "middle"
          };
        }
      },
      "menu-checkbox": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : qx.theme.simple.Image.URLS["menu-checkbox" + (states.selected ? "-invert" : "")]
          };
        }
      },
      "menu-radiobutton": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : qx.theme.simple.Image.URLS["menu-radiobutton" + (states.selected ? "-invert" : "")]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar": {
        style: function style(states) {
          return {
            backgroundColor: "light-background",
            padding: [4, 2]
          };
        }
      },
      "menubar-button": {
        style: function style(states) {
          var decorator;
          var padding = [2, 6];

          if (!states.disabled) {
            if (states.pressed) {
              decorator = "menubar-button-pressed";
              padding = [1, 5, 2, 5];
            } else if (states.hovered) {
              decorator = "menubar-button-hovered";
              padding = [1, 5];
            }
          }

          return {
            padding: padding,
            cursor: states.disabled ? undefined : "pointer",
            textColor: "link",
            decorator: decorator
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "virtual-list": "list",
      "virtual-list/row-layer": "row-layer",
      "row-layer": "widget",
      "column-layer": "widget",
      "group-item": {
        include: "label",
        alias: "label",
        style: function style(states) {
          return {
            padding: 4,
            backgroundColor: "#BABABA",
            textColor: "white",
            font: "bold"
          };
        }
      },
      "virtual-selectbox": "selectbox",
      "virtual-selectbox/dropdown": "popup",
      "virtual-selectbox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-combobox": "combobox",
      "virtual-combobox/dropdown": "popup",
      "virtual-combobox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-tree": {
        include: "tree",
        alias: "tree",
        style: function style(states) {
          return {
            itemHeight: 21
          };
        }
      },
      "virtual-tree-folder": "tree-folder",
      "virtual-tree-file": "tree-file",
      "cell": {
        style: function style(states) {
          return {
            backgroundColor: states.selected ? "table-row-background-selected" : "table-row-background-even",
            textColor: states.selected ? "text-selected" : "text",
            padding: [3, 6]
          };
        }
      },
      "cell-string": "cell",
      "cell-number": {
        include: "cell",
        style: function style(states) {
          return {
            textAlign: "right"
          };
        }
      },
      "cell-image": "cell",
      "cell-boolean": "cell",
      "cell-atom": "cell",
      "cell-date": "cell",
      "cell-html": "cell",

      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar": {},
      "scrollbar/slider": {},
      "scrollbar/slider/knob": {
        style: function style(states) {
          var decorator = "scroll-knob";

          if (!states.disabled) {
            if (states.hovered && !states.pressed && !states.checked) {
              decorator = "scroll-knob-hovered";
            } else if (states.hovered && (states.pressed || states.checked)) {
              decorator = "scroll-knob-pressed-hovered";
            } else if (states.pressed || states.checked) {
              decorator = "scroll-knob-pressed";
            }
          }

          return {
            height: 14,
            width: 14,
            cursor: states.disabled ? undefined : "pointer",
            decorator: decorator,
            minHeight: states.horizontal ? undefined : 20,
            minWidth: states.horizontal ? 20 : undefined
          };
        }
      },
      "scrollbar/button": {
        style: function style(states) {
          var styles = {};
          styles.padding = 4;
          var icon = "";

          if (states.left) {
            icon = "left";
            styles.marginRight = 2;
          } else if (states.right) {
            icon += "right";
            styles.marginLeft = 2;
          } else if (states.up) {
            icon += "up";
            styles.marginBottom = 2;
          } else {
            icon += "down";
            styles.marginTop = 2;
          }

          styles.icon = qx.theme.simple.Image.URLS["arrow-" + icon];
          styles.cursor = "pointer";
          styles.decorator = "button-box";
          return styles;
        }
      },
      "scrollbar/button-begin": "scrollbar/button",
      "scrollbar/button-end": "scrollbar/button",

      /*
      ---------------------------------------------------------------------------
        SCROLLAREA
      ---------------------------------------------------------------------------
      */
      "scrollarea/corner": {
        style: function style(states) {
          return {
            backgroundColor: "background"
          };
        }
      },
      "scrollarea": "widget",
      "scrollarea/pane": "widget",
      "scrollarea/scrollbar-x": "scrollbar",
      "scrollarea/scrollbar-y": "scrollbar",

      /*
      ---------------------------------------------------------------------------
        TEXT FIELD
      ---------------------------------------------------------------------------
      */
      "textfield": {
        style: function style(states) {
          var textColor;

          if (states.disabled) {
            textColor = "text-disabled";
          } else if (states.showingPlaceholder) {
            textColor = "text-placeholder";
          } else {
            textColor = undefined;
          }

          var decorator;
          var padding;

          if (states.disabled) {
            decorator = "inset";
            padding = [2, 3];
          } else if (states.invalid) {
            decorator = "border-invalid";
            padding = [1, 2];
          } else if (states.focused) {
            decorator = "focused-inset";
            padding = [1, 2];
          } else {
            padding = [2, 3];
            decorator = "inset";
          }

          return {
            decorator: decorator,
            padding: padding,
            textColor: textColor,
            backgroundColor: states.disabled ? "background-disabled" : "white"
          };
        }
      },
      "textarea": "textfield",

      /*
      ---------------------------------------------------------------------------
        RADIO BUTTON
      ---------------------------------------------------------------------------
      */
      "radiobutton/icon": {
        style: function style(states) {
          var decorator = "radiobutton";

          if (states.focused && !states.invalid) {
            decorator = "radiobutton-focused";
          }

          decorator += states.invalid && !states.disabled ? "-invalid" : "";
          var backgroundColor;

          if (states.disabled && states.checked) {
            backgroundColor = "background-disabled-checked";
          } else if (states.disabled) {
            backgroundColor = "background-disabled";
          } else if (states.checked) {
            backgroundColor = "background-selected";
          }

          return {
            decorator: decorator,
            width: 12,
            height: 12,
            backgroundColor: backgroundColor
          };
        }
      },
      "radiobutton": {
        style: function style(states) {
          // set an empty icon to be sure that the icon image is rendered
          return {
            icon: qx.theme.simple.Image.URLS["blank"]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        FORM
      ---------------------------------------------------------------------------
      */
      "form-renderer-label": {
        include: "label",
        style: function style() {
          return {
            paddingTop: 3
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        CHECK BOX
      ---------------------------------------------------------------------------
      */
      "checkbox": {
        alias: "atom",
        style: function style(states) {
          // The "disabled" icon is set to an icon **without** the -disabled
          // suffix on purpose. This is because the Image widget handles this
          // already by replacing the current image with a disabled version
          // (if available). If no disabled image is found, the opacity style
          // is used.
          var icon; // Checked

          if (states.checked) {
            icon = qx.theme.simple.Image.URLS["checkbox-checked"]; // Undetermined
          } else if (states.undetermined) {
            icon = qx.theme.simple.Image.URLS["checkbox-undetermined"]; // Unchecked
          } else {
            // empty icon
            icon = qx.theme.simple.Image.URLS["blank"];
          }

          return {
            icon: icon,
            gap: 6
          };
        }
      },
      "checkbox/icon": {
        style: function style(states) {
          var decorator = "checkbox";

          if (states.focused && !states.invalid) {
            decorator = "checkbox-focused";
          }

          decorator += states.invalid && !states.disabled ? "-invalid" : "";
          var padding; // Checked

          if (states.checked) {
            padding = 2; // Undetermined
          } else if (states.undetermined) {
            padding = [4, 2];
          }

          return {
            decorator: decorator,
            width: 12,
            height: 12,
            padding: padding,
            backgroundColor: "white"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPINNER
      ---------------------------------------------------------------------------
      */
      "spinner": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "spinner/textfield": "textfield",
      "spinner/upbutton": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          var decorator = "button-box-top-right";

          if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered-top-right";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered-top-right";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed-top-right";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-up-small"],
            decorator: decorator,
            width: 17
          };
        }
      },
      "spinner/downbutton": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          var decorator = "button-box-bottom-right";

          if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered-bottom-right";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered-bottom-right";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed-bottom-right";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down-small"],
            decorator: decorator,
            width: 17
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTBOX
      ---------------------------------------------------------------------------
      */
      "selectbox": "button-frame",
      "selectbox/atom": "atom",
      "selectbox/popup": "popup",
      "selectbox/list": {
        alias: "list",
        include: "list",
        style: function style() {
          return {
            decorator: undefined
          };
        }
      },
      "selectbox/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: qx.theme.simple.Image.URLS["arrow-down"],
            paddingRight: 4,
            paddingLeft: 5
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COMBO BOX
      ---------------------------------------------------------------------------
      */
      "combobox": {},
      "combobox/button": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          var decorator = "button-box-right-borderless";

          if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered-right-borderless";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered-right-borderless";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed-right-borderless";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            padding: [0, 5],
            width: 19
          };
        }
      },
      "combobox/popup": "popup",
      "combobox/list": {
        alias: "list"
      },
      "combobox/textfield": "textfield",

      /*
      ---------------------------------------------------------------------------
        DATEFIELD
      ---------------------------------------------------------------------------
      */
      "datefield": "textfield",
      "datefield/button": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          return {
            icon: "icon/16/apps/office-calendar.png",
            padding: [0, 0, 0, 3],
            backgroundColor: undefined,
            decorator: undefined,
            width: 19
          };
        }
      },
      "datefield/textfield": {
        alias: "textfield",
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: 0
          };
        }
      },
      "datefield/list": {
        alias: "datechooser",
        include: "datechooser",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        LIST
      ---------------------------------------------------------------------------
      */
      "list": {
        alias: "scrollarea",
        include: "textfield"
      },
      "listitem": {
        alias: "atom",
        style: function style(states) {
          var padding = [3, 5, 3, 5];

          if (states.lead) {
            padding = [2, 4, 2, 4];
          }

          if (states.dragover) {
            padding[2] -= 2;
          }

          var backgroundColor;

          if (states.selected) {
            backgroundColor = "background-selected";

            if (states.disabled) {
              backgroundColor += "-disabled";
            }
          }

          return {
            gap: 4,
            padding: padding,
            backgroundColor: backgroundColor,
            textColor: states.selected ? "text-selected" : undefined,
            decorator: states.lead ? "lead-item" : states.dragover ? "dragover" : undefined,
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDER
      ---------------------------------------------------------------------------
      */
      "slider": {
        style: function style(states) {
          var decorator;
          var padding;

          if (states.disabled) {
            decorator = "inset";
            padding = [2, 3];
          } else if (states.invalid) {
            decorator = "border-invalid";
            padding = [1, 2];
          } else if (states.focused) {
            decorator = "focused-inset";
            padding = [1, 2];
          } else {
            padding = [2, 3];
            decorator = "inset";
          }

          return {
            decorator: decorator,
            padding: padding
          };
        }
      },
      "slider/knob": "scrollbar/slider/knob",

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button-frame": {
        alias: "atom",
        style: function style(states) {
          var decorator = "button-box";

          if (!states.disabled) {
            if (states.hovered && !states.pressed && !states.checked) {
              decorator = "button-box-hovered";
            } else if (states.hovered && (states.pressed || states.checked)) {
              decorator = "button-box-pressed-hovered";
            } else if (states.pressed || states.checked) {
              decorator = "button-box-pressed";
            }
          }

          if (states.invalid && !states.disabled) {
            decorator += "-invalid";
          } else if (states.focused) {
            decorator += "-focused";
          }

          return {
            decorator: decorator,
            padding: [3, 8],
            cursor: states.disabled ? undefined : "pointer",
            minWidth: 5,
            minHeight: 5
          };
        }
      },
      "button-frame/label": {
        alias: "atom/label",
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "button": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          return {
            center: true
          };
        }
      },
      "hover-button": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            decorator: states.hovered ? "button-hover" : undefined
          };
        }
      },
      "menubutton": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            iconPosition: "right"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLIT BUTTON
      ---------------------------------------------------------------------------
      */
      "splitbutton": {},
      "splitbutton/button": {
        alias: "atom",
        style: function style(states) {
          var decorator = "button-box";

          if (!states.disabled) {
            if (states.pressed || states.checked) {
              decorator += "-pressed";
            }

            if (states.hovered) {
              decorator += "-hovered";
            }
          }

          if (states.focused) {
            decorator += "-focused";
          }

          decorator += "-left";
          return {
            decorator: decorator,
            padding: [3, 8],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "splitbutton/arrow": {
        style: function style(states) {
          var decorator = "button-box";

          if (!states.disabled) {
            if (states.pressed || states.checked) {
              decorator += "-pressed";
            }

            if (states.hovered) {
              decorator += "-hovered";
            }
          }

          if (states.focused) {
            decorator += "-focused";
          }

          decorator += "-right";
          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            cursor: states.disabled ? undefined : "pointer",
            padding: [3, 4]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "groupbox": {},
      "groupbox/legend": {
        alias: "atom",
        style: function style(states) {
          return {
            textColor: states.invalid ? "invalid" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },
      "groupbox/frame": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            padding: [6, 9],
            margin: [18, 2, 2, 2],
            decorator: "white-box"
          };
        }
      },
      "check-groupbox": "groupbox",
      "check-groupbox/legend": {
        alias: "checkbox",
        include: "checkbox",
        style: function style(states) {
          return {
            textColor: states.invalid ? "invalid" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },
      "radio-groupbox": "groupbox",
      "radio-groupbox/legend": {
        alias: "radiobutton",
        include: "radiobutton",
        style: function style(states) {
          return {
            textColor: states.invalid ? "invalid" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREE
      ---------------------------------------------------------------------------
      */
      "tree-folder/open": {
        include: "image",
        style: function style(states) {
          return {
            source: states.opened ? qx.theme.simple.Image.URLS["tree-minus"] : qx.theme.simple.Image.URLS["tree-plus"]
          };
        }
      },
      "tree-folder": {
        style: function style(states) {
          var backgroundColor;

          if (states.selected) {
            backgroundColor = "background-selected";

            if (states.disabled) {
              backgroundColor += "-disabled";
            }
          }

          return {
            padding: [2, 8, 2, 5],
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png",
            backgroundColor: backgroundColor,
            iconOpened: "icon/16/places/folder-open.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree-folder/icon": {
        include: "image",
        style: function style(states) {
          return {
            padding: [0, 4, 0, 0]
          };
        }
      },
      "tree-folder/label": {
        style: function style(states) {
          return {
            padding: [1, 2],
            textColor: states.selected && !states.disabled ? "text-selected" : undefined
          };
        }
      },
      "tree-file": {
        include: "tree-folder",
        alias: "tree-folder",
        style: function style(states) {
          return {
            icon: "icon/16/mimetypes/text-plain.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree": {
        include: "list",
        alias: "list",
        style: function style(states) {
          return {
            contentPadding: states.invalid && !states.disabled ? [3, 0] : [4, 1],
            padding: states.focused ? 0 : 1
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: function style(states) {
          return {
            contentPadding: [10, 10, 10, 10],
            backgroundColor: "background",
            decorator: states.maximized ? undefined : states.active ? "window-active" : "window"
          };
        }
      },
      "window-resize-frame": "resize-frame",
      "window/pane": {},
      "window/captionbar": {
        style: function style(states) {
          return {
            backgroundColor: states.active ? "light-background" : "background-disabled",
            padding: 8,
            font: "bold",
            decorator: "window-caption"
          };
        }
      },
      "window/icon": {
        style: function style(states) {
          return {
            marginRight: 4
          };
        }
      },
      "window/title": {
        style: function style(states) {
          return {
            cursor: "default",
            font: "bold",
            marginRight: 20,
            alignY: "middle"
          };
        }
      },
      "window/minimize-button": {
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["window-minimize"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/restore-button": {
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["window-restore"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/maximize-button": {
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["window-maximize"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/close-button": {
        alias: "button",
        style: function style(states) {
          return {
            marginLeft: 2,
            icon: qx.theme.simple.Image.URLS["window-close"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/statusbar": {
        style: function style(states) {
          return {
            decorator: "statusbar",
            padding: [2, 6]
          };
        }
      },
      "window/statusbar-text": "label",

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser": {
        style: function style(states) {
          return {
            decorator: "main",
            minWidth: 220
          };
        }
      },
      "datechooser/navigation-bar": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: states.disabled ? "text-disabled" : states.invalid ? "invalid" : undefined,
            padding: [2, 10]
          };
        }
      },
      "datechooser/last-year-button-tooltip": "tooltip",
      "datechooser/last-month-button-tooltip": "tooltip",
      "datechooser/next-year-button-tooltip": "tooltip",
      "datechooser/next-month-button-tooltip": "tooltip",
      "datechooser/last-year-button": "datechooser/button",
      "datechooser/last-month-button": "datechooser/button",
      "datechooser/next-year-button": "datechooser/button",
      "datechooser/next-month-button": "datechooser/button",
      "datechooser/button/icon": {},
      "datechooser/button": {
        style: function style(states) {
          var result = {
            width: 17,
            show: "icon",
            cursor: states.disabled ? undefined : "pointer"
          };

          if (states.lastYear) {
            result.icon = qx.theme.simple.Image.URLS["arrow-rewind"];
          } else if (states.lastMonth) {
            result.icon = qx.theme.simple.Image.URLS["arrow-left"];
          } else if (states.nextYear) {
            result.icon = qx.theme.simple.Image.URLS["arrow-forward"];
          } else if (states.nextMonth) {
            result.icon = qx.theme.simple.Image.URLS["arrow-right"];
          }

          return result;
        }
      },
      "datechooser/month-year-label": {
        style: function style(states) {
          return {
            font: "bold",
            textAlign: "center"
          };
        }
      },
      "datechooser/date-pane": {
        style: function style(states) {
          return {
            decorator: "datechooser-date-pane",
            backgroundColor: "background"
          };
        }
      },
      "datechooser/weekday": {
        style: function style(states) {
          return {
            decorator: "datechooser-weekday",
            font: "bold",
            textAlign: "center",
            textColor: states.disabled ? "text-disabled" : states.weekend ? "background-selected-dark" : "background",
            backgroundColor: states.weekend ? "background" : "background-selected-dark",
            paddingTop: 2
          };
        }
      },
      "datechooser/day": {
        style: function style(states) {
          return {
            textAlign: "center",
            decorator: states.today ? "main" : undefined,
            textColor: states.disabled ? "text-disabled" : states.selected ? "text-selected" : states.otherMonth ? "text-disabled" : undefined,
            backgroundColor: states.disabled ? undefined : states.selected ? "background-selected" : undefined,
            padding: states.today ? [1, 3] : [2, 4]
          };
        }
      },
      "datechooser/week": {
        style: function style(states) {
          return {
            textAlign: "center",
            textColor: "background-selected-dark",
            padding: [2, 4],
            decorator: states.header ? "datechooser-week-header" : "datechooser-week"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: function style(states) {
          return {
            decorator: "progressbar",
            padding: 1,
            backgroundColor: "white",
            width: 200,
            height: 20
          };
        }
      },
      "progressbar/progress": {
        style: function style(states) {
          return {
            backgroundColor: states.disabled ? "background-disabled-checked" : "background-selected"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar": {
        style: function style(states) {
          return {
            backgroundColor: "light-background",
            padding: 0
          };
        }
      },
      "toolbar/part": {
        style: function style(states) {
          return {
            margin: [0, 15]
          };
        }
      },
      "toolbar/part/container": {},
      "toolbar/part/handle": {},
      "toolbar-separator": {
        style: function style(states) {
          return {
            decorator: "toolbar-separator",
            margin: [7, 0],
            width: 4
          };
        }
      },
      "toolbar-button": {
        alias: "atom",
        style: function style(states) {
          var decorator = "button-box";

          if (states.disabled) {
            decorator = "button-box";
          } else if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed";
          } // set the right left and right decorator


          if (states.left) {
            decorator += "-left";
          } else if (states.right) {
            decorator += "-right";
          } else if (states.middle) {
            decorator += "-middle";
          } // set the margin


          var margin = [7, 10];

          if (states.left || states.middle || states.right) {
            margin = [7, 0];
          }

          return {
            cursor: states.disabled ? undefined : "pointer",
            decorator: decorator,
            margin: margin,
            padding: [3, 5]
          };
        }
      },
      "toolbar-menubutton": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          return {
            showArrow: true
          };
        }
      },
      "toolbar-menubutton/arrow": {
        alias: "image",
        include: "image",
        style: function style(states) {
          return {
            source: qx.theme.simple.Image.URLS["arrow-down"],
            cursor: states.disabled ? undefined : "pointer",
            padding: [0, 5],
            marginLeft: 2
          };
        }
      },
      "toolbar-splitbutton": {},
      "toolbar-splitbutton/button": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          var decorator = "button-box";

          if (states.disabled) {
            decorator = "button-box";
          } else if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed";
          } // default margin, when the button is alone


          var margin = [7, 0, 7, 10];

          if (states.left || states.middle || states.right) {
            margin = [7, 0, 7, 0];
          } // set the right left and right decorator


          if (states.left) {
            decorator += "-left";
          } else if (states.right) {
            decorator += "-middle";
          } else if (states.middle) {
            decorator += "-middle";
          } else {
            decorator += "-left";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            margin: margin
          };
        }
      },
      "toolbar-splitbutton/arrow": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          var decorator = "button-box";

          if (states.disabled) {
            decorator = "button-box";
          } else if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed";
          } // default margin, when the button is alone


          var margin = [7, 10, 7, 0];

          if (states.left || states.middle || states.right) {
            margin = [7, 0, 7, 0];
          } // set the right left and right decorator


          if (states.left) {
            decorator += "-middle";
          } else if (states.right) {
            decorator += "-right";
          } else if (states.middle) {
            decorator += "-middle";
          } else {
            decorator += "-right";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            margin: margin
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview": {},
      "tabview/bar": {
        alias: "slidebar",
        style: function style(states) {
          var marginTop = 0,
              marginRight = 0,
              marginBottom = 0,
              marginLeft = 0;

          if (states.barTop) {
            marginBottom -= 1;
          } else if (states.barBottom) {
            marginTop -= 1;
          } else if (states.barRight) {
            marginLeft -= 1;
          } else {
            marginRight -= 1;
          }

          return {
            marginBottom: marginBottom,
            marginTop: marginTop,
            marginLeft: marginLeft,
            marginRight: marginRight
          };
        }
      },
      "tabview/bar/button-forward": {
        include: "slidebar/button-forward",
        alias: "slidebar/button-forward",
        style: function style(states) {
          if (states.barTop) {
            return {
              marginTop: 4,
              marginBottom: 2,
              decorator: null
            };
          } else if (states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 4,
              decorator: null
            };
          } else if (states.barLeft) {
            return {
              marginLeft: 4,
              marginRight: 2,
              decorator: null
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 4,
              decorator: null
            };
          }
        }
      },
      "tabview/bar/button-backward": {
        include: "slidebar/button-backward",
        alias: "slidebar/button-backward",
        style: function style(states) {
          if (states.barTop) {
            return {
              marginTop: 4,
              marginBottom: 2,
              decorator: null
            };
          } else if (states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 4,
              decorator: null
            };
          } else if (states.barLeft) {
            return {
              marginLeft: 4,
              marginRight: 2,
              decorator: null
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 4,
              decorator: null
            };
          }
        }
      },
      "tabview/pane": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            decorator: "main",
            padding: 10
          };
        }
      },
      "tabview-page": "widget",
      "tabview-page/button": {
        style: function style(states) {
          var decorator; // default padding

          if (states.barTop || states.barBottom) {
            var padding = [8, 16, 8, 13];
          } else {
            var padding = [8, 4, 8, 4];
          } // decorator


          if (states.checked) {
            if (states.barTop) {
              decorator = "tabview-page-button-top";
            } else if (states.barBottom) {
              decorator = "tabview-page-button-bottom";
            } else if (states.barRight) {
              decorator = "tabview-page-button-right";
            } else if (states.barLeft) {
              decorator = "tabview-page-button-left";
            }
          } else {
            for (var i = 0; i < padding.length; i++) {
              padding[i] += 1;
            } // reduce the size by 1 because we have different decorator border width


            if (states.barTop) {
              padding[2] -= 1;
            } else if (states.barBottom) {
              padding[0] -= 1;
            } else if (states.barRight) {
              padding[3] -= 1;
            } else if (states.barLeft) {
              padding[1] -= 1;
            }
          }

          return {
            zIndex: states.checked ? 10 : 5,
            decorator: decorator,
            textColor: states.disabled ? "text-disabled" : states.checked ? null : "link",
            padding: padding,
            cursor: "pointer"
          };
        }
      },
      "tabview-page/button/label": {
        alias: "label",
        style: function style(states) {
          return {
            padding: [0, 1, 0, 1]
          };
        }
      },
      "tabview-page/button/icon": "image",
      "tabview-page/button/close-button": {
        alias: "atom",
        style: function style(states) {
          return {
            cursor: states.disabled ? undefined : "pointer",
            icon: qx.theme.simple.Image.URLS["tabview-close"]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR POPUP
      ---------------------------------------------------------------------------
      */
      "colorpopup": {
        alias: "popup",
        include: "popup",
        style: function style(states) {
          return {
            padding: 5
          };
        }
      },
      "colorpopup/field": {
        style: function style(states) {
          return {
            margin: 2,
            width: 14,
            height: 14,
            backgroundColor: "background",
            decorator: "main-dark"
          };
        }
      },
      "colorpopup/selector-button": "button",
      "colorpopup/auto-button": "button",
      "colorpopup/preview-pane": "groupbox",
      "colorpopup/current-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginLeft: 4,
            decorator: "main-dark",
            allowGrowX: true
          };
        }
      },
      "colorpopup/selected-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginRight: 4,
            decorator: "main-dark",
            allowGrowX: true
          };
        }
      },
      "colorpopup/colorselector-okbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-ok.png"
          };
        }
      },
      "colorpopup/colorselector-cancelbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-cancel.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR SELECTOR
      ---------------------------------------------------------------------------
      */
      "colorselector": "widget",
      "colorselector/control-bar": "widget",
      "colorselector/visual-pane": "groupbox",
      "colorselector/control-pane": "widget",
      "colorselector/preset-grid": "widget",
      "colorselector/colorbucket": {
        style: function style(states) {
          return {
            decorator: "main-dark",
            width: 16,
            height: 16
          };
        }
      },
      "colorselector/preset-field-set": "groupbox",
      "colorselector/input-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/preview-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/hex-field-composite": "widget",
      "colorselector/hex-field": "textfield",
      "colorselector/rgb-spinner-composite": "widget",
      "colorselector/rgb-spinner-red": "spinner",
      "colorselector/rgb-spinner-green": "spinner",
      "colorselector/rgb-spinner-blue": "spinner",
      "colorselector/hsb-spinner-composite": "widget",
      "colorselector/hsb-spinner-hue": "spinner",
      "colorselector/hsb-spinner-saturation": "spinner",
      "colorselector/hsb-spinner-brightness": "spinner",
      "colorselector/preview-content-old": {
        style: function style(states) {
          return {
            decorator: "main-dark",
            width: 50,
            height: 25
          };
        }
      },
      "colorselector/preview-content-new": {
        style: function style(states) {
          return {
            decorator: "main-dark",
            backgroundColor: "white",
            width: 50,
            height: 25
          };
        }
      },
      "colorselector/hue-saturation-field": {
        style: function style(states) {
          return {
            decorator: "main-dark",
            margin: 5
          };
        }
      },
      "colorselector/brightness-field": {
        style: function style(states) {
          return {
            decorator: "main-dark",
            margin: [5, 7]
          };
        }
      },
      "colorselector/hue-saturation-pane": "widget",
      "colorselector/hue-saturation-handle": "widget",
      "colorselector/brightness-pane": "widget",
      "colorselector/brightness-handle": "widget",

      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header": {
        style: function style(states) {
          return {
            font: "headline",
            textColor: "text-selected",
            backgroundColor: "background-selected-dark",
            padding: [8, 12]
          };
        }
      },
      "app-header-label": {
        style: function style(states) {
          return {
            paddingTop: 5
          };
        }
      },
      "app-splitpane": {
        alias: "splitpane",
        style: function style(states) {
          return {
            padding: [0, 10, 10, 10],
            backgroundColor: "light-background"
          };
        }
      }
    }
  });
  qx.theme.simple.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.theme.simple.Appearance": {
        "require": true
      },
      "qx.theme.simple.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2016 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * William Opandi (woprandi)
  
  ************************************************************************ */
  qx.Class.define("qx.test.theme.simple.Appearance", {
    extend: qx.dev.unit.TestCase,
    members: {
      __obj: qx.theme.simple.Appearance.appearances,
      testLabel: function testLabel() {
        var obj = this.__obj.label;
        this.assertIdentical("text-disabled", obj.style({
          disabled: true
        }).textColor);
        this.assertUndefined(obj.style({
          disabled: false
        }).textColor);
      },
      testImage: function testImage() {
        var obj = this.__obj.image;
        var states = {
          replacement: false,
          disabled: true
        };
        this.assertIdentical(0.3, obj.style(states).opacity);
        states.replacement = true;
        this.assertUndefined(obj.style(states).opacity);
      },
      testRoot: function testRoot() {
        var obj = this.__obj.root;
        var style = obj.style();
        this.assertIdentical("background", style.backgroundColor);
        this.assertIdentical("text", style.textColor);
        this.assertIdentical("default", style.font);
      },
      testPopup: function testPopup() {
        var obj = this.__obj.popup;
        var style = obj.style();
        this.assertIdentical("popup", style.decorator);
        this.assertIdentical("background-pane", style.backgroundColor);
      },
      testTooltip: function testTooltip() {
        var obj = this.__obj.tooltip;
        var style = obj.style();
        this.assertIdentical("tooltip", style.backgroundColor);
        this.assertIdentical("tooltip-text", style.textColor);
        this.assertIdentical("tooltip", style.decorator);
        this.assertArrayEquals([1, 3, 2, 3], style.padding);
        this.assertArrayEquals([10, 5, 5, 5], style.offset);
      },
      testTooltipError: function testTooltipError() {
        var obj = this.__obj["tooltip-error"];
        var style = obj.style();
        this.assertIdentical("text-selected", style.textColor);
        this.assertIdentical(100, style.showTimeout);
        this.assertIdentical(10000, style.hideTimeout);
        this.assertIdentical("tooltip-error", style.decorator);
        this.assertIdentical("bold", style.font);
        this.assertUndefined(style.backgroundColor);
      },
      testIframe: function testIframe() {
        var obj = this.__obj.iframe;
        var style = obj.style();
        this.assertIdentical("white", style.backgroundColor);
        this.assertIdentical("main-dark", style.decorator);
      },
      testMoveFrame: function testMoveFrame() {
        var obj = this.__obj["move-frame"];
        var style = obj.style();
        this.assertIdentical("main-dark", style.decorator);
      },
      testDragDropCursor: function testDragDropCursor() {
        var obj = this.__obj["dragdrop-cursor"];
        var states = {
          copy: true,
          move: true,
          alias: true
        };
        var style = obj.style(states);
        this.assertIdentical(qx.theme.simple.Image.URLS["cursor-copy"], style.source);
        states.copy = false;
        style = obj.style(states);
        this.assertIdentical(qx.theme.simple.Image.URLS["cursor-move"], style.source);
        states.move = false;
        style = obj.style(states);
        this.assertIdentical(qx.theme.simple.Image.URLS["cursor-alias"], style.source);
        states.alias = false;
        style = obj.style(states);
        this.assertIdentical(qx.theme.simple.Image.URLS["cursor-nodrop"], style.source);
        this.assertIdentical("right-top", style.position);
        this.assertArrayEquals([2, 16, 2, 6], style.offset);
      },
      testSlideBarButtonForward: function testSlideBarButtonForward() {
        var style = this.__obj["slidebar/button-forward"].style;
        this.assertIdentical(qx.theme.simple.Image.URLS["arrow-down"], style({
          vertical: true
        }).icon);
        this.assertIdentical(qx.theme.simple.Image.URLS["arrow-right"], style({
          vertical: false
        }).icon);
      },
      testSlideBarButtonBackward: function testSlideBarButtonBackward() {
        var style = this.__obj["slidebar/button-backward"].style;
        this.assertIdentical(qx.theme.simple.Image.URLS["arrow-up"], style({
          vertical: true
        }).icon);
        this.assertIdentical(qx.theme.simple.Image.URLS["arrow-left"], style({
          vertical: false
        }).icon);
      },
      testTableStatusBar: function testTableStatusBar() {
        var style = this.__obj["table/statusbar"].style();

        this.assertIdentical("statusbar", style.decorator);
        this.assertArrayEquals([2, 5], style.padding);
      },
      testTableColumnButton: function testTableColumnButton() {
        var style = this.__obj["table/column-button"].style();

        this.assertIdentical("table-header-column-button", style.decorator);
        this.assertIdentical(3, style.padding);
        this.assertIdentical(qx.theme.simple.Image.URLS["select-column-order"], style.icon);
      },
      testTableColumnResetButton: function testTableColumnResetButton() {
        var style = this.__obj["table-column-reset-button"].style();

        this.assertIdentical("icon/16/actions/view-refresh.png", style.icon);
      },
      testTableScrollerHeader: function testTableScrollerHeader() {
        var style = this.__obj["table-scroller/header"].style();

        this.assertIdentical("table-header", style.decorator);
      },
      testTableScrollerFocusIndicator: function testTableScrollerFocusIndicator() {
        var style = this.__obj["table-scroller/focus-indicator"].style();

        this.assertIdentical("main", style.decorator);
      },
      testTableScrollerResizeLine: function testTableScrollerResizeLine() {
        var style = this.__obj["table-scroller/resize-line"].style();

        this.assertIdentical("button-border", style.backgroundColor);
        this.assertIdentical(3, style.width);
      },
      testTableHeaderCell: function testTableHeaderCell() {
        var styleFunc = this.__obj["table-header-cell"].style;
        var states = {
          first: true,
          disabled: true,
          sorted: true,
          sortedAscending: true
        };
        var style = styleFunc(states);
        this.assertIdentical(13, style.minWidth);
        this.assertIdentical("bold", style.font);
        this.assertIdentical(3, style.paddingTop);
        this.assertIdentical(5, style.paddingLeft);
        this.assertIdentical("table-header-cell-first", style.decorator);
        this.assertUndefined(style.pointer);
        this.assertIdentical(qx.theme.simple.Image.URLS["table-ascending"], style.sortIcon);
        states.sortedAscending = false;
        style = styleFunc(states);
        this.assertIdentical(qx.theme.simple.Image.URLS["table-descending"], style.sortIcon);
        states.sorted = false;
        style = styleFunc(states);
        this.assertUndefined(style.sortIcon);
        states.disabled = false;
        style = styleFunc(states);
        this.assertIdentical("pointer", style.cursor);
        states.first = false, style = styleFunc(states);
        this.assertIdentical("table-header-cell", style.decorator);
      },
      testTableHeaderCellIcon: function testTableHeaderCellIcon() {
        var style = this.__obj["table-header-cell/icon"].style();

        this.assertIdentical(5, style.paddingRight);
      },
      testTableHeaderCellSortIcon: function testTableHeaderCellSortIcon() {
        var style = this.__obj["table-header-cell/sort-icon"].style();

        this.assertIdentical("middle", style.alignY);
        this.assertIdentical("right", style.alignX);
        this.assertIdentical(5, style.paddingRight);
      },
      testTableEditorTextField: function testTableEditorTextField() {
        var style = this.__obj["table-editor-textfield"].style();

        this.assertUndefined(style.decorator);
        this.assertArrayEquals([2, 2], style.padding);
      },
      testTableEditorSelectBox: function testTableEditorSelectBox() {
        var style = this.__obj["table-editor-selectbox"].style();

        this.assertArrayEquals([0, 2], style.padding);
      },
      testTableEditorComboBox: function testTableEditorComboBox() {
        var style = this.__obj["table-editor-combobox"].style();

        this.assertUndefined(style.decorator);
      },
      testProgressiveTableHeader: function testProgressiveTableHeader() {
        var style = this.__obj["progressive-table-header"].style();

        this.assertIdentical("progressive-table-header", style.decorator);
      },
      testProgressiveTableHeaderCell: function testProgressiveTableHeaderCell() {
        var style = this.__obj["progressive-table-header-cell"].style();

        this.assertIdentical("progressive-table-header-cell", style.decorator);
        this.assertArrayEquals([5, 6, 5, 6], style.padding);
      },
      testTreeVirtual: function testTreeVirtual() {
        var styleFunc = this.__obj["treevirtual"].style;
        var superStyles = {
          padding: [3, 4]
        };
        var style = styleFunc(null, superStyles);
        this.assertArrayEquals([5, 5], style.padding);
      },
      testTreeVirtualFolder: function testTreeVirtualFolder() {
        var styleFunc = this.__obj["treevirtual-folder"].style;
        var states = {
          opened: true,
          drag: true
        };
        var style = styleFunc(states);
        this.assertIdentical("icon/16/places/folder-open.png", style.icon);
        this.assertIdentical(0.5, style.opacity);
        states.opened = false;
        states.drag = false;
        style = styleFunc(states);
        this.assertIdentical("icon/16/places/folder.png", style.icon);
        this.assertUndefined(style.opacity);
      },
      testTreeVirtualFile: function testTreeVirtualFile() {
        var styleFunc = this.__obj["treevirtual-file"].style;
        this.assertIdentical("icon/16/mimetypes/text-plain.png", styleFunc({
          drag: false
        }).icon);
        this.assertIdentical(0.5, styleFunc({
          drag: true
        }).opacity);
        this.assertUndefined(styleFunc({
          drag: false
        }).opacity);
      },
      testTreeVirtualLine: function testTreeVirtualLine() {
        var style = this.__obj["treevirtual-line"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-line"], style.icon);
      },
      testTreeVirtualContract: function testTreeVirtualContract() {
        var style = this.__obj["treevirtual-contract"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["tree-minus"], style.icon);
      },
      testTreeVirtualExpand: function testTreeVirtualExpand() {
        var style = this.__obj["treevirtual-expand"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["tree-plus"], style.icon);
      },
      testTreeVirtualOnlyContract: function testTreeVirtualOnlyContract() {
        var style = this.__obj["treevirtual-only-contract"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-minus-only"], style.icon);
      },
      testTreeVirtualOnlyExpand: function testTreeVirtualOnlyExpand() {
        var style = this.__obj["treevirtual-only-expand"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-plus-only"], style.icon);
      },
      testTreeVirtualStartContract: function testTreeVirtualStartContract() {
        var style = this.__obj["treevirtual-start-contract"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-minus-start"], style.icon);
      },
      testTreeVirtualStartExpand: function testTreeVirtualStartExpand() {
        var style = this.__obj["treevirtual-start-expand"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-plus-start"], style.icon);
      },
      testTreeVirtualEndContract: function testTreeVirtualEndContract() {
        var style = this.__obj["treevirtual-end-contract"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-minus-end"], style.icon);
      },
      testTreeVirtualEndExpand: function testTreeVirtualEndExpand() {
        var style = this.__obj["treevirtual-end-expand"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-plus-end"], style.icon);
      },
      testTreeVirtualCrossContract: function testTreeVirtualCrossContract() {
        var style = this.__obj["treevirtual-cross-contract"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-minus-cross"], style.icon);
      },
      testTreeVirtualCrossExpand: function testTreeVirtualCrossExpand() {
        var style = this.__obj["treevirtual-cross-expand"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-plus-cross"], style.icon);
      },
      testTreeVirtualEnd: function testTreeVirtualEnd() {
        var style = this.__obj["treevirtual-end"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-end"], style.icon);
      },
      testTreeVirtualCross: function testTreeVirtualCross() {
        var style = this.__obj["treevirtual-cross"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-cross"], style.icon);
      },
      testTreeVirtualCross: function testTreeVirtualCross() {
        var style = this.__obj["treevirtual-cross"].style();

        this.assertIdentical(qx.theme.simple.Image.URLS["treevirtual-cross"], style.icon);
      },
      testResizer: function testResizer() {
        var style = this.__obj["resizer"].style();

        this.assertIdentical("main-dark", style.decorator);
      },
      testSplitpaneSplitter: function testSplitpaneSplitter() {
        var style = this.__obj["splitpane/splitter"].style();

        this.assertIdentical("light-background", style.backgroundColor);
      },
      testSplitpaneSplitterKnob: function testSplitpaneSplitterKnob() {
        var styleFunc = this.__obj["splitpane/splitter/knob"].style;
        var states = {
          horizontal: true
        };
        var style = styleFunc(states);
        this.assertIdentical(2, style.padding);
        this.assertIdentical(qx.theme.simple.Image.URLS["knob-horizontal"], style.source);
        style = styleFunc({
          horizontal: false
        });
        this.assertIdentical(qx.theme.simple.Image.URLS["knob-vertical"], style.source);
      },
      testSplitpaneSlider: function testSplitpaneSlider() {
        var style = this.__obj["splitpane/slider"].style();

        this.assertIdentical("border-light-shadow", style.backgroundColor);
        this.assertIdentical(0.3, style.opacity);
      },
      testMenu: function testMenu() {
        var styleFunc = this.__obj["menu"].style;
        var states = {
          submenu: true,
          contextmenu: true
        };
        var style = styleFunc(states);
        this.assertIdentical("background", style.backgroundColor);
        this.assertIdentical("main", style.decorator);
        this.assertIdentical(6, style.spacingX);
        this.assertIdentical(1, style.spacingY);
        this.assertIdentical(16, style.iconColumnWidth);
        this.assertIdentical(4, style.arrowColumnWidth);
        this.assertIdentical(1, style.padding);
        this.assertIdentical("best-fit", style.placementModeY);
        this.assertNotUndefined(style.position);
        this.assertIdentical("right-top", style.position);
        this.assertNotUndefined(style.offset);
        this.assertIdentical(4, style.offset);
        states.submenu = false;
        style = styleFunc(states);
        this.assertIdentical("best-fit", style.placementModeY);
        this.assertUndefined(style.position);
        this.assertIdentical(4, style.offset);
        states.contextmenu = false;
        style = styleFunc(states);
        this.assertIdentical("keep-align", style.placementModeY);
        this.assertUndefined(style.position);
        this.assertUndefined(style.offset);
      },
      testMenuSlideBarButton: function testMenuSlideBarButton() {
        var styleFunc = this.__obj["menu-slidebar-button"].style;
        var style = styleFunc({
          hovered: true
        });
        this.assertIdentical(6, style.padding);
        this.assertIdentical(true, style.center);
        this.assertIdentical("background-selected", style.backgroundColor);
        style = styleFunc({
          hovered: false
        });
        this.assertUndefined(style.backgroundColor);
      },
      testMenuSlideBarButtonBackward: function testMenuSlideBarButtonBackward() {
        var styleFunc = this.__obj["menu-slidebar/button-backward"].style;
        var style = styleFunc({
          hovered: true
        });
        this.assertIdentical(qx.theme.simple.Image.URLS["arrow-up-invert"], style.icon);
        style = styleFunc({
          hovered: false
        });
        this.assertIdentical(qx.theme.simple.Image.URLS["arrow-up"], style.icon);
      },
      testMenuSlideBarButtonForward: function testMenuSlideBarButtonForward() {
        var styleFunc = this.__obj["menu-slidebar/button-forward"].style;
        var style = styleFunc({
          hovered: true
        });
        this.assertIdentical(qx.theme.simple.Image.URLS["arrow-down-invert"], style.icon);
        style = styleFunc({
          hovered: false
        });
        this.assertIdentical(qx.theme.simple.Image.URLS["arrow-down"], style.icon);
      },
      testMenuSeparator: function testMenuSeparator() {
        var style = this.__obj["menu-separator"].style();

        this.assertIdentical(0, style.height);
        this.assertIdentical("menu-separator", style.decorator);
        this.assertIdentical(4, style.marginTop);
        this.assertIdentical(4, style.marginBottom);
        this.assertIdentical(2, style.marginLeft);
        this.assertIdentical(2, style.marginRight);
      },
      testMenuButton: function testMenuButton() {
        var styleFunc = this.__obj["menu-button"].style;
        this.assertIdentical("background-selected", styleFunc({
          selected: true
        }).backgroundColor);
        this.assertIdentical("text-selected", styleFunc({
          selected: true
        }).textColor);
        this.assertArrayEquals([2, 6], styleFunc({
          selected: true
        }).padding);
        this.assertUndefined(styleFunc({
          selected: false
        }).backgroundColor);
        this.assertUndefined(styleFunc({
          selected: false
        }).textColor);
      },
      testMenuButtonIcon: function testMenuButtonIcon() {
        var style = this.__obj["menu-button/icon"].style();

        this.assertIdentical("middle", style.alignY);
      },
      testMenuButtonLabel: function testMenuButtonLabel() {
        var style = this.__obj["menu-button/label"].style();

        this.assertIdentical("middle", style.alignY);
        this.assertIdentical(1, style.padding);
      },
      testMenuButtonShortcut: function testMenuButtonShortcut() {
        var style = this.__obj["menu-button/shortcut"].style();

        this.assertIdentical("middle", style.alignY);
        this.assertIdentical(1, style.padding);
        this.assertIdentical(14, style.marginLeft);
      },
      testMenuButtonArrow: function testMenuButtonArrow() {
        var styleFunc = this.__obj["menu-button/arrow"].style;
        var states = {
          selected: true
        };
        var style = styleFunc(states);
        this.assertIdentical(qx.theme.simple.Image.URLS["arrow-right-invert"], style.source);
        this.assertIdentical("middle", style.alignY);
        states.selected = false;
        style = styleFunc(states);
        this.assertIdentical(qx.theme.simple.Image.URLS["arrow-right"], style.source);
      },
      testMenuCheckbox: function testMenuCheckbox() {
        var styleFunc = this.__obj["menu-checkbox"].style;
        var states = {
          checked: true,
          selected: true
        };
        var style = styleFunc(states);
        this.assertIdentical(qx.theme.simple.Image.URLS["menu-checkbox-invert"], style.icon);
        states.selected = false;
        style = styleFunc(states);
        this.assertIdentical(qx.theme.simple.Image.URLS["menu-checkbox"], style.icon);
        states.checked = false;
        style = styleFunc(states);
        this.assertUndefined(style.icon);
      },
      testMenuRadioButton: function testMenuRadioButton() {
        var styleFunc = this.__obj["menu-radiobutton"].style;
        var states = {
          checked: true,
          selected: true
        };
        var style = styleFunc(states);
        this.assertIdentical(qx.theme.simple.Image.URLS["menu-radiobutton-invert"], style.icon);
        states.selected = false;
        style = styleFunc(states);
        this.assertIdentical(qx.theme.simple.Image.URLS["menu-radiobutton"], style.icon);
        states.checked = false;
        style = styleFunc(states);
        this.assertUndefined(style.icon);
      },
      testMenuBar: function testMenuBar() {
        var style = this.__obj["menubar"].style();

        this.assertIdentical("light-background", style.backgroundColor);
        this.assertArrayEquals([4, 2], style.padding);
      },
      testMenuBarButton: function testMenuBarButton() {
        var styleFunc = this.__obj["menubar-button"].style;
        var states = {
          disabled: false,
          pressed: true,
          hovered: false
        };
        var style = styleFunc(states);
        this.assertIdentical("menubar-button-pressed", style.decorator);
        this.assertArrayEquals([1, 5, 2, 5], style.padding);
        this.assertIdentical("pointer", style.cursor);
        states.pressed = false;
        states.hovered = true;
        style = styleFunc(states);
        this.assertIdentical("menubar-button-hovered", style.decorator);
        this.assertArrayEquals([1, 5], style.padding);
        states.hovered = false;
        style = styleFunc(states);
        this.assertIdentical("link", style.textColor);
        this.assertUndefined(style.decorator);
        this.assertArrayEquals([2, 6], style.padding);
        states.disabled = true;
        style = styleFunc(states);
        this.assertUndefined(style.cursor);
      },
      testGroupItem: function testGroupItem() {
        var style = this.__obj["group-item"].style();

        this.assertIdentical(4, style.padding);
        this.assertIdentical("#BABABA", style.backgroundColor);
        this.assertIdentical("white", style.textColor);
        this.assertIdentical("bold", style.font);
      },
      testVirtualTree: function testVirtualTree() {
        var style = this.__obj["virtual-tree"].style();

        this.assertIdentical(21, style.itemHeight);
      },
      testCell: function testCell() {
        var styleFunc = this.__obj["cell"].style;
        var style = styleFunc({
          selected: true
        });
        this.assertIdentical("table-row-background-selected", style.backgroundColor);
        this.assertIdentical("text-selected", style.textColor);
        this.assertArrayEquals([3, 6], style.padding);
        style = styleFunc({
          selected: false
        });
        this.assertIdentical("table-row-background-even", style.backgroundColor);
        this.assertIdentical("text", style.textColor);
      },
      testCellNumber: function testCellNumber() {
        var style = this.__obj["cell-number"].style();

        this.assertIdentical("right", style.textAlign);
      }
    }
  });
  qx.test.theme.simple.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * Mapping class for all images used in the simple theme.
   *
   * @asset(qx/decoration/Simple/*)
   * @asset(qx/static/blank.png)
   */
  qx.Class.define("qx.theme.simple.Image", {
    extend: qx.core.Object,
    statics: {
      /**
       * Holds a map containing all the URL to the images.
       * @internal
       */
      URLS: {
        "blank": "qx/static/blank.png",
        // checkbox
        "checkbox-checked": "decoration/checkbox/checked.png",
        "checkbox-undetermined": "decoration/checkbox/undetermined.png",
        // window
        "window-minimize": "decoration/window/minimize.gif",
        "window-maximize": "decoration/window/maximize.gif",
        "window-restore": "decoration/window/restore.gif",
        "window-close": "decoration/window/close.gif",
        // cursor
        "cursor-copy": "decoration/cursors/copy.gif",
        "cursor-move": "decoration/cursors/move.gif",
        "cursor-alias": "decoration/cursors/alias.gif",
        "cursor-nodrop": "decoration/cursors/nodrop.gif",
        // arrows
        "arrow-right": "decoration/arrows/right.gif",
        "arrow-left": "decoration/arrows/left.gif",
        "arrow-up": "decoration/arrows/up.gif",
        "arrow-down": "decoration/arrows/down.gif",
        "arrow-forward": "decoration/arrows/forward.gif",
        "arrow-rewind": "decoration/arrows/rewind.gif",
        "arrow-down-small": "decoration/arrows/down-small.gif",
        "arrow-up-small": "decoration/arrows/up-small.gif",
        "arrow-up-invert": "decoration/arrows/up-invert.gif",
        "arrow-down-invert": "decoration/arrows/down-invert.gif",
        "arrow-right-invert": "decoration/arrows/right-invert.gif",
        // split pane
        "knob-horizontal": "decoration/splitpane/knob-horizontal.png",
        "knob-vertical": "decoration/splitpane/knob-vertical.png",
        // tree
        "tree-minus": "decoration/tree/minus.gif",
        "tree-plus": "decoration/tree/plus.gif",
        // table
        "select-column-order": "decoration/table/select-column-order.png",
        "table-ascending": "decoration/table/ascending.png",
        "table-descending": "decoration/table/descending.png",
        // tree virtual
        "treevirtual-line": "decoration/treevirtual/line.gif",
        "treevirtual-minus-only": "decoration/treevirtual/only_minus.gif",
        "treevirtual-plus-only": "decoration/treevirtual/only_plus.gif",
        "treevirtual-minus-start": "decoration/treevirtual/start_minus.gif",
        "treevirtual-plus-start": "decoration/treevirtual/start_plus.gif",
        "treevirtual-minus-end": "decoration/treevirtual/end_minus.gif",
        "treevirtual-plus-end": "decoration/treevirtual/end_plus.gif",
        "treevirtual-minus-cross": "decoration/treevirtual/cross_minus.gif",
        "treevirtual-plus-cross": "decoration/treevirtual/cross_plus.gif",
        "treevirtual-end": "decoration/treevirtual/end.gif",
        "treevirtual-cross": "decoration/treevirtual/cross.gif",
        // menu
        "menu-checkbox": "decoration/menu/checkbox.gif",
        "menu-checkbox-invert": "decoration/menu/checkbox-invert.gif",
        "menu-radiobutton-invert": "decoration/menu/radiobutton-invert.gif",
        "menu-radiobutton": "decoration/menu/radiobutton.gif",
        // tabview
        "tabview-close": "decoration/tabview/close.gif"
      }
    }
  });
  qx.theme.simple.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-20011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.toolchain.PrivateOptimization", {
    extend: qx.dev.unit.TestCase,
    members: {
      /*
       * The next test tests whether privates are renamed at all.
       */
      testPrivatesRenaming: function testPrivatesRenaming() {
        // Can only fail in build version with all optimizations
        this.assertEquals("__test a", this.__test(), "Variable in a string renamed!");
        this.assertEquals("__test a test", this.__test() + " test", "Variable in a string renamed!");
      },
      // needed for testPrivatesRenaming
      __test: function __test() {
        return "__test a";
      }
    }
  });
  qx.test.toolchain.PrivateOptimization.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.event.Timer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.toolchain.TestRunner", {
    extend: qx.dev.unit.TestCase,
    members: {
      testAsynchronous: function testAsynchronous() {
        qx.event.Timer.once(function () {
          this.resume(function () {// do nothing
          }, this);
        }, this, 1000);
        this.wait();
      }
    }
  });
  qx.test.toolchain.TestRunner.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.test.bool_true": {}
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-20011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Thomas Herchenroeder (thron7)
  
  ************************************************************************ */
  qx.Class.define("qx.test.toolchain.VariantOptimization", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MRequirements,
    members: {
      setUp: function setUp() {
        this.require(["variantsOptimized"]); // run the tests only when this code is variant-optimized

      },
      hasVariantsOptimized: function hasVariantsOptimized() {
        return false;
      },

      /*
       * 1.
       *
       * The next tests whether the generator optimized an 'if' statement, so that
       * only the 'then' branch made it into the optimized code.
       */
      "test If 'if' statement is pruned by the generator": function testIfIfStatementIsPrunedByTheGenerator() {
        var a = 0;
        /*
         * "qx.test.bool_true" and "qx.test.bool_false" are custom environment
         * keys that are set in config.json for the framework's AUT.
         *
         * Faking "qx.test.bool_true" to temporarily evaluate to false here.
         * (Undone in the "tearDown" method).
         */

        qx.core.Environment.getChecks()["qx.test.bool_true"] = function () {
          return false;
        };
        /*
         * The 'if' statement should be optimized by the generator, as the value
         * of "qx.test.bool_true" is known at compile time, so that only "a = 1"
         * makes it into the generated code.
         *
         * If the 'if' is not optimized, the .get call will actually be performed
         * returning 'false' (see above), and the else branch will be executed.
         */


        if (qx.core.Environment.get("qx.test.bool_true")) {
          a = 1;
        } else {
          a = 2;
        } // The next will fail if the 'else' branch has been chosen, due to missing
        // or wrong optimization.


        this.assertEquals(1, a);
      },
      "tearDown If 'if' statement is pruned by the generator": function tearDownIfIfStatementIsPrunedByTheGenerator() {
        qx.core.Environment.getChecks()["qx.test.bool_true"] = function () {
          return true;
        };
      },

      /*
       * 2.
       *
       * In the next test, we apply the same trick as above, to check that a .select
       * expression has been optimized.
       */
      "test If 'select' call is pruned by the generator": function testIfSelectCallIsPrunedByTheGenerator() {
        // Fake "qx.test.bool_true" to be false at run time.
        qx.core.Environment.getChecks()["qx.test.bool_true"] = function () {
          return false;
        }; // Under optimization, the .select call will have been gone at run time.


        var a = qx.core.Environment.select("qx.test.bool_true", {
          "true": 1,
          "false": 2
        });
        this.assertEquals(1, a);
      },
      "tearDown If 'select' call is pruned by the generator": function tearDownIfSelectCallIsPrunedByTheGenerator() {
        qx.core.Environment.getChecks()["qx.test.bool_true"] = function () {
          return true;
        };
      },

      /*
       * 3.
       *
       * Check if a simple .get call is optimized.
       */
      "test If simple 'get' call is pruned by the generator": function testIfSimpleGetCallIsPrunedByTheGenerator() {
        // Fake "qx.test.bool_true" to be false at run time.
        qx.core.Environment.getChecks()["qx.test.bool_true"] = function () {
          return false;
        }; // Under optimization, the .get call will have been gone at run time.


        var a = qx.core.Environment.get("qx.test.bool_true");
        this.assertEquals(true, a);
      },
      "tearDown If simple 'get' call is pruned by the generator": function tearDownIfSimpleGetCallIsPrunedByTheGenerator() {
        qx.core.Environment.getChecks()["qx.test.bool_true"] = function () {
          return true;
        };
      }
    }
  });
  qx.test.toolchain.VariantOptimization.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.type.Array": {},
      "qx.type.BaseArray": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.type.Array", {
    extend: qx.dev.unit.TestCase,
    members: {
      __arr: null,
      setUp: function setUp() {
        this.__arr = new qx.type.Array("x");
      },
      testConstruct: function testConstruct() {
        this.assertEquals(this.__arr[0], "x");
      },
      testAppend: function testAppend() {
        // native array
        this.__arr.append([1, 2]);

        this.assertEquals(this.__arr[1], 1);
        this.assertEquals(this.__arr[2], 2); // type array

        var a = new qx.type.Array(3, 4);

        this.__arr.append(a);

        this.assertEquals(this.__arr[3], 3);
        this.assertEquals(this.__arr[4], 4); // type base array

        var b = new qx.type.BaseArray(5, 6);

        this.__arr.append(b);

        this.assertEquals(this.__arr[5], 5);
        this.assertEquals(this.__arr[6], 6);
      },
      testPrepend: function testPrepend() {
        // native array
        this.__arr.prepend([1, 2]);

        this.assertEquals(this.__arr[0], 1);
        this.assertEquals(this.__arr[1], 2); // type array

        var a = new qx.type.Array(3, 4);

        this.__arr.prepend(a);

        this.assertEquals(this.__arr[0], 3);
        this.assertEquals(this.__arr[1], 4); // type base array

        var b = new qx.type.BaseArray(5, 6);

        this.__arr.prepend(b);

        this.assertEquals(this.__arr[0], 5);
        this.assertEquals(this.__arr[1], 6);
      }
    }
  });
  qx.test.type.Array.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.type.BaseArray": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * An extended array class which adds a lot of often used
   * convenience methods to the regular array like <code>remove</code> or
   * <code>contains</code>.
   */
  qx.Class.define("qx.type.Array", {
    extend: qx.type.BaseArray,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Creates a new Array with the given length or the listed items.
     *
     * <pre class="javascript">
     * var arr1 = new qx.type.Array(length);
     * var arr2 = new qx.type.Array(elem0, elem1, ..., elemN);
     * </pre>
     *
     * * <code>length</code>: The initial length of the array.
     * * <code>item1, item2. .. itemN</code>:  the items that will make up the newly created array
     *
     * @param length_or_items {Integer|var?null} The initial size of the collection
     *        OR an argument list of elements.
     */
    construct: function construct(length_or_items) {
      qx.type.BaseArray.apply(this, arguments);
    },
    members: {
      /**
       * Returns a clone of the array. Primitive values are copied.
       * Others are referenced.
       *
       * @return {Array} Cloned array instance
       * @signature function()
       */
      clone: qx.type.BaseArray.prototype.concat,

      /**
       * Insert an element at a given position
       *
       * @param obj {var} the element to insert
       * @param i {Integer} position where to insert the element into the arr
       * @return {Array} the array
       */
      insertAt: function insertAt(obj, i) {
        this.splice(i, 0, obj);
        return this;
      },

      /**
       * Insert an element before a given second element
       *
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 before this object
       * @return {Array} the array
       */
      insertBefore: function insertBefore(obj, obj2) {
        var i = this.indexOf(obj2);

        if (i == -1) {
          this.push(obj);
        } else {
          this.splice(i, 0, obj);
        }

        return this;
      },

      /**
       * Insert an element after a given second element
       *
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 after this object
       * @return {Array} the array
       */
      insertAfter: function insertAfter(obj, obj2) {
        var i = this.indexOf(obj2);

        if (i == -1 || i == this.length - 1) {
          this.push(obj);
        } else {
          this.splice(i + 1, 0, obj);
        }

        return this;
      },

      /**
       * Remove an element at the given index
       *
       * @param i {Integer} index of the element to be removed
       * @return {var} The removed element.
       */
      removeAt: function removeAt(i) {
        return this.splice(i, 1)[0];
      },

      /**
       * Remove all elements
       *
       * @return {Array} empty array
       */
      removeAll: function removeAll() {
        this.length = 0;
        return this;
      },

      /**
       * Append the elements of the given array
       *
       * @param arr {Array} the elements of this array will be appended to other one
       * @return {Array} The modified array.
       * @throws {Error} if one of the arguments is not an array
       */
      append: function append(arr) {
        var arg = this.__toPlainArray(arr);

        Array.prototype.push.apply(this, arg);
        return this;
      },

      /**
       * Prepend the elements of the given array.
       *
       * @param arr {Array} The elements of this array will be prepended to other one
       * @return {Array} The modified array.
       * @throws {Error} if one of the arguments is not an array
       */
      prepend: function prepend(arr) {
        var arg = this.__toPlainArray(arr);

        Array.prototype.splice.apply(this, [0, 0].concat(arg));
        return this;
      },

      /**
       * Helper which checks for the given element and converts that to a
       * native array if necessary.
       *
       * @param arr {Array} Native or qx.type.BaseArray to convert.
       * @return {Array} A native array.
       */
      __toPlainArray: function __toPlainArray(arr) {
        // this check is important because Opera throws an uncatchable error if
        // apply is called without an arr as second argument.
        {
          qx.core.Assert.assertArray(arr, "The parameter must be an array.");
        }
        var arg = arr; // concat needs a plain array as argument [BUG #4488]

        if (arr instanceof qx.type.BaseArray) {
          arg = [];

          for (var i = 0; i < arr.length; i++) {
            arg[i] = arr[i];
          }

          ;
        }

        return arg;
      },

      /**
       * Remove an element
       *
       * @param obj {var} element to be removed from the array
       * @return {var} the removed element
       */
      remove: function remove(obj) {
        var i = this.indexOf(obj);

        if (i != -1) {
          this.splice(i, 1);
          return obj;
        }
      },

      /**
       * Whether the array contains the given element
       *
       * @param obj {var} object to look for
       * @return {Boolean} whether the array contains the element
       */
      contains: function contains(obj) {
        return this.indexOf(obj) !== -1;
      }
    }
  });
  qx.type.Array.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "construct": true,
        "require": true
      },
      "qx.type.BaseArray": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.type.TestArray)
   */
  qx.Class.define("qx.test.type.BaseArray", {
    extend: qx.dev.unit.TestCase,
    construct: function construct() {
      qx.dev.unit.TestCase.constructor.call(this);
      qx.Class.define("qx.test.type.TestArray", {
        extend: qx.type.BaseArray
      });
    },
    members: {
      testListConstruct: function testListConstruct() {
        var list = new qx.test.type.TestArray(10);
        this.assertEquals(10, list.length);
        list = new qx.test.type.TestArray(1, 2, 3);
        this.assertArrayEquals([1, 2, 3], list);
      },
      testSingleItemConstruct: function testSingleItemConstruct() {
        // ECMAScript version 3 compatible,
        // but NOT ECMAScript version 1
        var list = new qx.test.type.TestArray("42");
        this.assertArray(list);
        this.assertEquals(list.length, 1);
        this.assertIdentical("42", list[0], "The answer was not 42!");
      },
      testArrayLength: function testArrayLength() {
        var list = new qx.test.type.TestArray(1, 2, 3);
        this.assertEquals(3, list.length);
      },
      testClear: function testClear() {
        var list = new qx.test.type.TestArray(1, 2, 3);
        list.length = 0;
        this.assertArrayEquals([], list);
      },
      testArrayJoin: function testArrayJoin() {
        var list = new qx.test.type.TestArray(1, 2, 3);
        this.assertEquals("1, 2, 3", list.join(", "));
      },
      testArrayConcat: function testArrayConcat() {
        var list = new qx.test.type.TestArray(1, 2, 3);
        this.assertArrayEquals([1, 2, 3, 4, 5], list.concat(4, 5));
        this.assertInstance(list.concat(4, 5), qx.test.type.TestArray);
      },
      testArrayPop: function testArrayPop() {
        var list = new qx.test.type.TestArray(1, 2, 3);
        var popped = list.pop();
        this.assertEquals(3, popped);
        this.assertArrayEquals([1, 2], list);
      },
      testArrayPush: function testArrayPush() {
        var list = new qx.test.type.TestArray(1, 2);
        var length = list.push(3);
        this.assertEquals(3, length);
        this.assertArrayEquals([1, 2, 3], list);
        var length = list.push(4, 5);
        this.assertEquals(5, length);
        this.assertArrayEquals([1, 2, 3, 4, 5], list);
      },
      testArrayReverse: function testArrayReverse() {
        var list = new qx.test.type.TestArray(1, 2, 3, 4, 5);
        list.reverse();
        this.assertArrayEquals([5, 4, 3, 2, 1], list);
        list.reverse();
        this.assertArrayEquals([1, 2, 3, 4, 5], list);
      },
      testArrayShift: function testArrayShift() {
        var list = new qx.test.type.TestArray(1, 2, 3, 4, 5);
        var shifted = list.shift();
        this.assertEquals(1, shifted);
        this.assertArrayEquals([2, 3, 4, 5], list);
      },
      testArrayUnshift: function testArrayUnshift() {
        var list = new qx.test.type.TestArray(2, 3, 4, 5);
        var length = list.unshift(1);
        this.assertArrayEquals([1, 2, 3, 4, 5], list);
      },
      testArraySlice: function testArraySlice() {
        var list = new qx.test.type.TestArray(1, 2, 3, 4, 5);
        this.assertArrayEquals([3, 4], list.slice(2, 4));
        this.assertArrayEquals([2, 3, 4, 5], list.slice(1));
        this.assertArrayEquals([3, 4], list.slice(2, -1));
        this.assertInstance(list.slice(2, 4), qx.test.type.TestArray);
      },
      testArraySort: function testArraySort() {
        var list = new qx.test.type.TestArray(3, 5, 1, -1);
        var sorted = list.sort();
        this.assertArrayEquals([-1, 1, 3, 5], list);
        var list = new qx.test.type.TestArray(3, 5, 1, -1);
        var sorted = list.sort(function (a, b) {
          return a > b ? -1 : 1;
        });
        this.assertArrayEquals([5, 3, 1, -1], list);
      },
      testArraySplice: function testArraySplice() {
        var list = new qx.test.type.TestArray(1, 2, 3, 4, 5);
        var removed = list.splice(1, 2, 22, 33);
        this.assertArrayEquals([2, 3], removed);
        this.assertInstance(removed, qx.test.type.TestArray);
        this.assertArrayEquals([1, 22, 33, 4, 5], list);
      },
      testArrayToString: function testArrayToString() {
        var list = new qx.test.type.TestArray(1, 2, 3);
        this.assertEquals(list.join(), list.toString());
      },
      testArrayToLocaleString: function testArrayToLocaleString() {
        var list = new qx.test.type.TestArray(1, 2, 3);
        this.assertEquals([1, 2, 3].toLocaleString(), list.toLocaleString());
      },
      testArrayAccess: function testArrayAccess() {
        var list = new qx.test.type.TestArray(1, 2, 3);
        this.assertEquals(1, list[0]);
        this.assertEquals(2, list[1]);
        this.assertEquals(3, list[2]);
      },
      testIndexOf: function testIndexOf() {
        var obj = {};
        var arr = new qx.test.type.TestArray(1, obj, "str", 1);
        this.assertEquals(0, arr.indexOf(1));
        this.assertEquals(1, arr.indexOf(obj));
        this.assertEquals(2, arr.indexOf("str"));
        this.assertEquals(-1, arr.indexOf(0));
      },
      testLastIndexOf: function testLastIndexOf() {
        var obj = {};
        var arr = new qx.test.type.TestArray(1, obj, "str", 1);
        this.assertEquals(3, arr.lastIndexOf(1));
        this.assertEquals(1, arr.lastIndexOf(obj));
        this.assertEquals(2, arr.lastIndexOf("str"));
        this.assertEquals(-1, arr.lastIndexOf(0));
      },
      testForEach: function testForEach() {
        var obj = {};
        var arr = new qx.test.type.TestArray(1, obj, "str", 1);
        var values = [];
        var indexes = [];
        arr.forEach(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
        }, this);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3], indexes);
      },
      testFilter: function testFilter() {
        var arr = new qx.test.type.TestArray(1, 2, 3, 4);
        var values = [];
        var indexes = [];
        var odd = arr.filter(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
          return index % 2 == 1;
        }, this);
        this.assertInstance(odd, qx.test.type.TestArray);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3], indexes);
        this.assertArrayEquals([2, 4], odd);
      },
      testMap: function testMap() {
        var arr = new qx.test.type.TestArray(1, 2, 3, 4);
        var values = [];
        var indexes = [];
        var result = arr.map(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
          return element + 1;
        }, this);
        this.assertInstance(result, qx.test.type.TestArray);
        this.assertArrayEquals([2, 3, 4, 5], result);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3], indexes);
      },
      testSome: function testSome() {
        var arr = new qx.test.type.TestArray(1, 2, 3, 4);
        var values = [];
        var indexes = [];
        var result = arr.some(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
        }, this);
        this.assertFalse(result);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3], indexes);
        this.assertTrue(arr.some(function (element) {
          return element == 3;
        }));
        this.assertFalse(arr.some(function (element, index) {
          return index == 6;
        }));
      },
      testEvery: function testEvery() {
        var arr = new qx.test.type.TestArray(1, 2, 3, 4);
        var values = [];
        var indexes = [];
        var result = arr.every(function (element, index, array) {
          values[index] = element;
          indexes.push(index);
          this.assertEquals(arr, array);
          return true;
        }, this);
        this.assertTrue(result);
        this.assertArrayEquals(arr, values);
        this.assertArrayEquals([0, 1, 2, 3], indexes);
        this.assertFalse(arr.every(function (element) {
          return element == 3;
        }));
        this.assertTrue(arr.every(function (element, index) {
          return element == index + 1;
        }));
      }
    }
  });
  qx.test.type.BaseArray.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.type.BaseString": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * @ignore(qx.String)
   */
  qx.Class.define("qx.test.type.BaseString", {
    extend: qx.dev.unit.TestCase,
    members: {
      testToString: function testToString() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals("Juhu", s);
      },
      testValueOf: function testValueOf() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals("Juhu".valueOf(), s.valueOf());
      },
      testUpperCase: function testUpperCase() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals("JUHU", s.toUpperCase());
      },
      testIndexOf: function testIndexOf() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals(1, s.indexOf("u"));
      },
      testPlusOperator: function testPlusOperator() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals("__Juhu__", ["__", s + "__"].join(""));
      },
      testCharAt: function testCharAt() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals("h", s.charAt(2));
      },
      testcharCodeAt: function testcharCodeAt() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals(104, s.charCodeAt(2));
      },
      testlastIndexOf: function testlastIndexOf() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals(3, s.lastIndexOf("u"));
      },
      testLength: function testLength() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals(4, s.length);
      },
      testLowerCase: function testLowerCase() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals("juhu", s.toLowerCase());
      },
      testSubstringOneArgument: function testSubstringOneArgument() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals("hu", s.substring(2));
      },
      testSubstringTwoArguments: function testSubstringTwoArguments() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals("u", s.substring(2, 1));
      },
      testSearchString: function testSearchString() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals(2, s.search("h"));
      },
      testSearchRegExp: function testSearchRegExp() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals(0, s.search(/J/));
      },
      testReplace: function testReplace() {
        var s = new qx.type.BaseString("Juhu");
        this.assertEquals("Johu", s.replace("u", "o"));
      },
      testEmptyString: function testEmptyString() {
        var s = new qx.type.BaseString();
        this.assertEquals("", s.toString());
        var s = new qx.type.BaseString("");
        this.assertEquals("", s.toString());
      },
      testExtend: function testExtend() {
        qx.Class.define("qx.String", {
          extend: qx.type.BaseString,
          members: {
            bold: function bold() {
              return "<b>" + this.toString() + "</b>";
            }
          }
        });
        var s = new qx.String("Juhu");
        this.assertEquals("<b>Juhu</b>", s.bold());
      }
    }
  });
  qx.test.type.BaseString.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.decoration.Decorator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.BackgroundColor", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      testChangeColorInContainer: function testChangeColorInContainer() {
        var widget = new qx.ui.container.Composite();
        this.getRoot().add(widget);
        this.assertStyle(widget, "backgroundColor", "transparent");
        widget.setBackgroundColor("red");
        this.assertStyle(widget, "backgroundColor", "red");
        widget.setBackgroundColor("green");
        this.assertStyle(widget, "backgroundColor", "green");
        widget.setBackgroundColor(null);
        this.assertStyle(widget, "backgroundColor", "transparent");
        this.getRoot().remove(widget);
        widget.destroy();
      },
      testChangeColorInDecorator: function testChangeColorInDecorator() {
        var widget = new qx.ui.container.Composite();
        this.getRoot().add(widget);
        var deco = new qx.ui.decoration.Decorator().set({
          width: 1
        });
        widget.setDecorator(deco);
        this.assertStyle(widget, "backgroundColor", "transparent", "no bg color");
        widget.setBackgroundColor("red");
        this.assertStyle(widget, "backgroundColor", "red", "red bg color");
        widget.setBackgroundColor("green");
        this.assertStyle(widget, "backgroundColor", "green", "green bg color");
        widget.setBackgroundColor(null);
        this.assertStyle(widget, "backgroundColor", "transparent", "null bg color");
        this.getRoot().remove(widget);
        widget.dispose();
        deco.dispose();
      },
      testChangeDecorator: function testChangeDecorator() {
        var widget = new qx.ui.container.Composite();
        this.getRoot().add(widget);
        this.assertStyle(widget, "backgroundColor", "transparent"); // set decoration

        var deco = new qx.ui.decoration.Decorator().set({
          width: 1
        });
        widget.setDecorator(deco); // set background color

        widget.setBackgroundColor("red");
        this.assertStyle(widget, "backgroundColor", "red"); // change decorator
        //var repl = new qx.ui.decoration.Double(1, "solid", "green", 1, "black");

        var repl = new qx.ui.decoration.Decorator().set({
          width: 1,
          style: "solid",
          color: "green",
          innerWidth: 1,
          innerColor: "black"
        });
        widget.setDecorator(repl);
        this.assertStyle(widget, "backgroundColor", "red");
        widget.destroy();
        deco.dispose();
        repl.dispose();
      },
      testDecorationColor: function testDecorationColor() {
        var widget = new qx.ui.container.Composite();
        this.getRoot().add(widget);
        this.assertStyle(widget, "backgroundColor", "transparent");
        widget.setBackgroundColor("green");
        this.assertStyle(widget, "backgroundColor", "green"); // set decoration

        var deco = new qx.ui.decoration.Decorator().set({
          width: 1,
          backgroundColor: "red"
        });
        widget.setDecorator(deco); // widget color takes precedence over decorator color

        this.assertStyle(widget, "backgroundColor", "green"); // reset widget bg color

        widget.setBackgroundColor(null);
        this.assertStyle(widget, "backgroundColor", "red");
        this.getRoot().remove(widget);
        widget.dispose();
        deco.dispose();
      }
    }
  });
  qx.test.ui.BackgroundColor.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.Basic": {},
      "qx.ui.core.Widget": {},
      "qx.core.AssertionError": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Test widget children handling
   */
  qx.Class.define("qx.test.ui.ChildrenHandling", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      assertArrayEquals: function assertArrayEquals(expected, found, msg) {
        this.assertArray(expected, msg);
        this.assertArray(found, msg);
        this.assertEquals(expected.length, found.length, msg);

        for (var i = 0; i < expected.length; i++) {
          this.assertIdentical(expected[i], found[i], msg);
        }
      },
      _setChildren: function _setChildren(parent, children) {
        parent.removeAll();

        for (var i = 0; i < children.length; i++) {
          parent.add(children[i]);
        }

        this.flush();
        this.assertArrayEquals(children, parent.getChildren());
      },
      testRemove: function testRemove() {
        var parent = new qx.ui.container.Composite(new qx.ui.layout.Basic());
        var c1 = new qx.ui.core.Widget();
        var c2 = new qx.ui.core.Widget();
        var c3 = new qx.ui.core.Widget();
        var children = [c1, c2, c3];

        this._setChildren(parent, children);

        parent.remove(c1);
        this.assertArrayEquals([c2, c3], parent.getChildren(), "remove first");

        this._setChildren(parent, children);

        parent.remove(c2);
        this.assertArrayEquals([c1, c3], parent.getChildren(), "remove middle");

        this._setChildren(parent, children);

        parent.remove(c3);
        this.assertArrayEquals([c1, c2], parent.getChildren(), "remove last");

        this._setChildren(parent, children);

        c1.destroy();
        c2.destroy();
        c3.destroy();
        parent.destroy();
      },
      testRemoveAll: function testRemoveAll() {
        var parent = new qx.ui.container.Composite(new qx.ui.layout.Basic());
        var c1 = new qx.ui.core.Widget();
        var c2 = new qx.ui.core.Widget();
        var c3 = new qx.ui.core.Widget();
        var children = [c1, c2, c3];

        this._setChildren(parent, children);

        var removed = parent.removeAll();
        this.assertArrayEquals([], parent.getChildren(), "remove last");
        this.assertEquals(3, removed.length);
        this.assertEquals(c1, removed[0]);
        this.assertEquals(c2, removed[1]);
        this.assertEquals(c3, removed[2]);
        c1.destroy();
        c2.destroy();
        c3.destroy();
        parent.destroy();
      },
      testRemoveNonChild: function testRemoveNonChild() {
        var parent = new qx.ui.container.Composite(new qx.ui.layout.Basic());
        var w1 = new qx.ui.core.Widget();
        this.assertException(function () {
          parent.remove(w1);
        });
        w1.destroy();
        parent.destroy();
      },
      testRemoveAt: function testRemoveAt() {
        var parent = new qx.ui.container.Composite(new qx.ui.layout.Basic());
        var c1 = new qx.ui.core.Widget();
        var c2 = new qx.ui.core.Widget();
        var c3 = new qx.ui.core.Widget();
        var w1 = new qx.ui.core.Widget();
        var children = [c1, c2, c3];

        this._setChildren(parent, children);

        parent.removeAt(0);
        this.assertArrayEquals([c2, c3], parent.getChildren(), "remove first");

        this._setChildren(parent, children);

        parent.removeAt(1);
        this.assertArrayEquals([c1, c3], parent.getChildren(), "remove middle");

        this._setChildren(parent, children);

        parent.removeAt(2);
        this.assertArrayEquals([c1, c2], parent.getChildren(), "remove last");

        if (this.isDebugOn()) {
          this._setChildren(parent, children);

          this.assertException(function () {
            parent.removeAt(-1);
          }, qx.core.AssertionError, "", "remove at negative index");
        }

        if (this.isDebugOn()) {
          this._setChildren(parent, children);

          this.assertException(function () {
            parent.removeAt(-1);
          }, qx.core.AssertionError, "", "remove at negative index");
        }

        c1.destroy();
        c2.destroy();
        c3.destroy();
        w1.destroy();
        parent.destroy();
      },
      testAddBefore: function testAddBefore() {
        var parent = new qx.ui.container.Composite(new qx.ui.layout.Basic());
        var c1 = new qx.ui.core.Widget();
        var c2 = new qx.ui.core.Widget();
        var c3 = new qx.ui.core.Widget();
        var w1 = new qx.ui.core.Widget();
        var w2 = new qx.ui.core.Widget();
        var children = [c1, c2, c3];

        this._setChildren(parent, children);

        parent.addBefore(w1, c1);
        this.assertArrayEquals([w1, c1, c2, c3], parent.getChildren(), "add new widget at begin");

        this._setChildren(parent, children);

        parent.addBefore(w1, c3);
        this.assertArrayEquals([c1, c2, w1, c3], parent.getChildren(), "add new widget in the middle");

        this._setChildren(parent, children);

        if (this.isDebugOn()) {
          var self = this;
          this.assertException(function () {
            parent.addBefore(w1, w2);
          }, qx.core.AssertionError, "", "add new widget before non child");

          this._setChildren(parent, children);
        }

        parent.addBefore(c1, c1);
        this.assertArrayEquals([c1, c2, c3], parent.getChildren(), "add existing before itself");

        this._setChildren(parent, children);

        parent.addBefore(c3, c1);
        this.assertArrayEquals([c3, c1, c2], parent.getChildren(), "add existing before first");

        this._setChildren(parent, children);

        parent.addBefore(c3, c2);
        this.assertArrayEquals([c1, c3, c2], parent.getChildren(), "add existing in the middle");

        this._setChildren(parent, children);

        if (this.isDebugOn()) {
          var self = this;
          this.assertException(function () {
            parent.addBefore(c3, w2);
          }, qx.core.AssertionError, "", "add existing before non child");

          this._setChildren(parent, children);
        }

        c1.destroy();
        c2.destroy();
        c3.destroy();
        w1.destroy();
        w2.destroy();
        parent.destroy();
      },
      testAddAfter: function testAddAfter() {
        var parent = new qx.ui.container.Composite(new qx.ui.layout.Basic());
        var c1 = new qx.ui.core.Widget();
        var c2 = new qx.ui.core.Widget();
        var c3 = new qx.ui.core.Widget();
        var w1 = new qx.ui.core.Widget();
        var w2 = new qx.ui.core.Widget();
        var children = [c1, c2, c3];

        this._setChildren(parent, children);

        parent.addAfter(w1, c3);
        this.assertArrayEquals([c1, c2, c3, w1], parent.getChildren(), "add new widget ar end");

        this._setChildren(parent, children);

        parent.addAfter(w1, c1);
        this.assertArrayEquals([c1, w1, c2, c3], parent.getChildren(), "add new widget in the middle");

        this._setChildren(parent, children);

        if (this.isDebugOn()) {
          var self = this;
          this.assertException(function () {
            parent.addAfter(w1, w2);
          }, qx.core.AssertionError, "", "add new widget after non child");

          this._setChildren(parent, children);
        }

        parent.addAfter(c1, c1);
        this.assertArrayEquals([c1, c2, c3], parent.getChildren(), "add existing before itself");

        this._setChildren(parent, children);

        parent.addAfter(c1, c3);
        this.assertArrayEquals([c2, c3, c1], parent.getChildren(), "add existing before last");

        this._setChildren(parent, children);

        parent.addAfter(c1, c2);
        this.assertArrayEquals([c2, c1, c3], parent.getChildren(), "add existing in the middle");

        this._setChildren(parent, children);

        if (this.isDebugOn()) {
          var self = this;
          this.assertException(function () {
            parent.addAfter(c1, w2);
          }, qx.core.AssertionError, "", "add existing after non child");

          this._setChildren(parent, children);
        }

        c1.destroy();
        c2.destroy();
        c3.destroy();
        w1.destroy();
        w2.destroy();
        parent.destroy();
      },
      testDoubleAdd: function testDoubleAdd() {
        var parent = new qx.ui.container.Composite(new qx.ui.layout.Basic());
        var children = [];

        for (var i = 0; i < 4; i++) {
          children[i] = new qx.ui.core.Widget();
          parent.add(children[i]);
        }

        this.assertArrayEquals(children, parent.getChildren()); // double add must move the child to the end!

        var child = children[1];
        parent.add(child);
        qx.lang.Array.remove(children, child);
        children.push(child);
        this.assertArrayEquals(children, parent.getChildren());
        parent.destroy();
      }
    }
  });
  qx.test.ui.ChildrenHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.core.Widget": {},
      "qx.ui.layout.Basic": {},
      "qx.ui.layout.Canvas": {},
      "qx.ui.layout.Dock": {},
      "qx.ui.layout.Grow": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.layout.VBox": {},
      "qx.ui.layout.Grid": {},
      "qx.ui.form.Button": {},
      "qx.ui.form.ComboBox": {},
      "qx.ui.form.CheckBox": {},
      "qx.ui.form.PasswordField": {},
      "qx.ui.form.RadioButton": {},
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.Slider": {},
      "qx.ui.form.Spinner": {},
      "qx.ui.form.SplitButton": {},
      "qx.ui.form.TextArea": {},
      "qx.ui.form.TextField": {},
      "qx.ui.form.ToggleButton": {},
      "qx.ui.form.MenuButton": {},
      "qx.ui.basic.Atom": {},
      "qx.ui.basic.Label": {},
      "qx.ui.basic.Image": {},
      "qx.ui.container.Resizer": {},
      "qx.ui.container.Scroll": {},
      "qx.ui.container.SlideBar": {},
      "qx.ui.container.Stack": {},
      "qx.ui.control.ColorSelector": {},
      "qx.ui.control.DateChooser": {},
      "qx.ui.control.ColorPopup": {},
      "qx.ui.core.queue.Dispose": {},
      "qx.ui.core.scroll.ScrollBar": {},
      "qx.ui.core.scroll.NativeScrollBar": {},
      "qx.ui.core.scroll.ScrollPane": {},
      "qx.ui.core.scroll.ScrollSlider": {},
      "qx.ui.embed.Html": {},
      "qx.ui.embed.Canvas": {},
      "qx.ui.embed.Iframe": {},
      "qx.ui.groupbox.CheckGroupBox": {},
      "qx.ui.groupbox.GroupBox": {},
      "qx.ui.groupbox.RadioGroupBox": {},
      "qx.ui.menu.Menu": {},
      "qx.ui.menu.Button": {},
      "qx.ui.menu.CheckBox": {},
      "qx.ui.menu.RadioButton": {},
      "qx.ui.menu.Separator": {},
      "qx.ui.popup.Popup": {},
      "qx.ui.splitpane.Pane": {},
      "qx.ui.tabview.TabView": {},
      "qx.ui.tabview.Page": {},
      "qx.ui.toolbar.Button": {},
      "qx.ui.toolbar.CheckBox": {},
      "qx.ui.toolbar.Part": {},
      "qx.ui.toolbar.PartContainer": {},
      "qx.ui.toolbar.RadioButton": {},
      "qx.ui.toolbar.Separator": {},
      "qx.ui.toolbar.ToolBar": {},
      "qx.ui.toolbar.MenuButton": {},
      "qx.ui.toolbar.SplitButton": {},
      "qx.ui.tooltip.ToolTip": {},
      "qx.ui.tree.Tree": {},
      "qx.ui.tree.TreeFolder": {},
      "qx.ui.tree.TreeFile": {},
      "qx.ui.form.RadioGroup": {},
      "qx.ui.form.RadioButtonGroup": {},
      "qx.ui.window.Window": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.Destroy", {
    extend: qx.test.ui.LayoutTestCase,
    statics: {
      $$clazz: null,
      $$args: null
    },
    members: {
      /**
       * @lint ignoreDeprecated(eval)
       */
      assertLayoutDispose: function assertLayoutDispose(clazz, args, layoutArgsArr) {
        this.assertDestroy(function () {
          var argStr = [];

          for (var i = 0; i < args.length; i++) {
            argStr.push("qx.test.ui.Destroy.$$args[" + i + "]");
          }

          qx.test.ui.Destroy.$$clazz = clazz;
          qx.test.ui.Destroy.$$args = args;
          var str = "new qx.test.ui.Destroy.$$clazz(" + argStr.join(", ") + ");";
          var layout = eval(str);
          var widget = new qx.ui.container.Composite();
          widget.setLayout(layout);

          for (var i = 0; i < layoutArgsArr.length; i++) {
            widget.add(new qx.ui.core.Widget(), layoutArgsArr[i]);
          }

          this.getRoot().add(widget);
          this.flush();
          widget.destroy();
        }, this);
      },
      testLayouts: function testLayouts() {
        var layouts = [[qx.ui.layout.Basic, [], [{
          left: 10
        }, {
          top: 10
        }, {
          left: 10,
          top: 10
        }]], [qx.ui.layout.Canvas, [], [{
          left: 10
        }, {
          top: 10
        }, {
          right: 10,
          top: "10%"
        }]], [qx.ui.layout.Dock, [], [{
          edge: "north"
        }, {
          edge: "south"
        }, {
          edge: "west"
        }, {
          edge: "east"
        }]], [qx.ui.layout.Grow, [], [{}]], [qx.ui.layout.HBox, [], [{
          flex: 1
        }, {}, {}]], [qx.ui.layout.VBox, [], [{
          flex: 1
        }, {}, {}]], [qx.ui.layout.Grid, [], [{
          row: 0,
          column: 0
        }, {
          row: 4,
          column: 3
        }, {
          row: 2,
          column: 0,
          colSpan: 3
        }]]];

        for (var i = 0; i < layouts.length; i++) {
          this.assertLayoutDispose(layouts[i][0], layouts[i][1], layouts[i][2]);
        }
      },
      testForms: function testForms() {
        var forms = [[qx.ui.form.Button, ["Juhu"]], [qx.ui.form.ComboBox, []], [qx.ui.form.CheckBox, ["Juhu"]], [qx.ui.form.PasswordField, []], [qx.ui.form.RadioButton, []], [qx.ui.form.SelectBox, []], [qx.ui.form.Slider, []], [qx.ui.form.Spinner, []], [qx.ui.form.SplitButton, []], [qx.ui.form.TextArea, []], [qx.ui.form.TextField, []], [qx.ui.form.ToggleButton, []]];

        for (var i = 0; i < forms.length; i++) {
          this.assertWidgetDispose(forms[i][0], forms[i][1], "Disposing " + forms[i][0].classname);
        }

        this.assertDestroy(function () {
          var widget = new qx.ui.form.MenuButton();

          var menu = this.__createMenu();

          widget.setMenu(menu);
          this.getRoot().add(widget);
          this.flush();
          widget.destroy();
          menu.destroy();
        }, this, "Dispose menu button");
      },
      testBasic: function testBasic() {
        var forms = [[qx.ui.basic.Atom, ["Juhu"]], [qx.ui.basic.Label, ["Juhu"]], [qx.ui.basic.Image, []]];

        for (var i = 0; i < forms.length; i++) {
          this.assertWidgetDispose(forms[i][0], forms[i][1], "Disposing " + forms[i][0].classname);
        }
      },
      testContainer: function testContainer() {
        var forms = [[qx.ui.container.Composite, []], [qx.ui.container.Resizer, []], [qx.ui.container.Scroll, []], [qx.ui.container.SlideBar, []], [qx.ui.container.Stack, []]];

        for (var i = 0; i < forms.length; i++) {
          this.assertWidgetDispose(forms[i][0], forms[i][1], "Disposing " + forms[i][0].classname);
        }
      },
      testControls: function testControls() {
        var forms = [[qx.ui.control.ColorSelector, []], [qx.ui.control.DateChooser, []]];

        for (var i = 0; i < forms.length; i++) {
          this.assertWidgetDispose(forms[i][0], forms[i][1], "Disposing " + forms[i][0].classname);
        }

        this.assertDestroy(function () {
          var widget = new qx.ui.control.ColorPopup();
          widget.show();
          this.flush();
          widget.destroy();
        }, this, "Dispose color popup");
        this.assertDestroy(function () {
          var widget = new qx.ui.control.ColorPopup();
          widget.show();
          widget.getChildControl("selector-button").execute();
          this.flush();
          widget.destroy();
          qx.ui.core.queue.Dispose.flush();
        }, this, "Dispose color popup with selector open");
      },
      testCore: function testCore() {
        var forms = [[qx.ui.core.scroll.ScrollBar, []], [qx.ui.core.scroll.NativeScrollBar, []], [qx.ui.core.scroll.ScrollPane, []], [qx.ui.core.scroll.ScrollSlider, []], [qx.ui.core.Widget, []]];

        for (var i = 0; i < forms.length; i++) {
          this.assertWidgetDispose(forms[i][0], forms[i][1], "Disposing " + forms[i][0].classname);
        }
      },
      testEmbeds: function testEmbeds() {
        var forms = [[qx.ui.embed.Html, ["Juhu <b>Kinners</b>"]], [qx.ui.embed.Canvas, []], [qx.ui.embed.Iframe, []]];

        for (var i = 0; i < forms.length; i++) {
          this.assertWidgetDispose(forms[i][0], forms[i][1], "Disposing " + forms[i][0].classname);
        }
      },
      testGroupBox: function testGroupBox() {
        var forms = [[qx.ui.groupbox.CheckGroupBox, []], [qx.ui.groupbox.GroupBox, []], [qx.ui.groupbox.RadioGroupBox, []]];

        for (var i = 0; i < forms.length; i++) {
          this.assertWidgetDispose(forms[i][0], forms[i][1], "Disposing " + forms[i][0].classname);
        }
      },
      testMenu: function testMenu() {
        this.assertDestroy(function () {
          var menu = new qx.ui.menu.Menu();
          var btn = new qx.ui.menu.Button("Juhu");
          menu.add(btn);
          menu.add(new qx.ui.menu.CheckBox("Juhu"));
          menu.add(new qx.ui.menu.RadioButton("Juhu"));
          menu.add(new qx.ui.menu.Separator("Juhu"));
          var subMenu = new qx.ui.menu.Menu();
          subMenu.add(new qx.ui.menu.Button("Juhu"));
          btn.setMenu(subMenu);
          menu.setOpener(this.getRoot());
          menu.open();
          this.flush();
          subMenu.destroy();
          menu.destroy();
        }, this, "Dispose configured menu");
      },
      testPopup: function testPopup() {
        this.assertDestroy(function () {
          var widget = new qx.ui.popup.Popup();
          widget.show();
          this.flush();
          widget.destroy();
        }, this, "Dispose configured menu");
      },
      testSplitPane: function testSplitPane() {
        this.assertDestroy(function () {
          var widget = new qx.ui.splitpane.Pane();
          widget.add(new qx.ui.core.Widget(), 1);
          widget.add(new qx.ui.core.Widget());
          this.getRoot().add(widget);
          this.flush();
          widget.destroy();
        }, this, "Dispose split pane");
      },
      testTabView: function testTabView() {
        this.assertDestroy(function () {
          var widget = new qx.ui.tabview.TabView();
          widget.add(new qx.ui.tabview.Page("Juhu"));
          widget.add(new qx.ui.tabview.Page("Kinners"));
          this.getRoot().add(widget);
          this.flush();
          widget.destroy();
        }, this, "Dispose tabview");
      },
      testToolbar: function testToolbar() {
        var forms = [[qx.ui.toolbar.Button, ["Juhu"]], [qx.ui.toolbar.CheckBox, ["Juhu"]], [qx.ui.toolbar.Part, []], [qx.ui.toolbar.PartContainer, []], [qx.ui.toolbar.RadioButton, ["Juhu"]], [qx.ui.toolbar.Separator, []], [qx.ui.toolbar.ToolBar, []]];

        for (var i = 0; i < forms.length; i++) {
          this.assertWidgetDispose(forms[i][0], forms[i][1], "Disposing " + forms[i][0].classname);
        }

        this.assertDestroy(function () {
          var widget = new qx.ui.toolbar.MenuButton("juhu");

          var menu = this.__createMenu();

          widget.setMenu(menu);
          this.getRoot().add(widget);
          this.flush();
          widget.destroy();
          menu.destroy();
        }, this, "Dispose toolbar menu button");
        this.assertDestroy(function () {
          var widget = new qx.ui.toolbar.SplitButton("Juhu");

          var menu = this.__createMenu();

          widget.setMenu(menu);
          this.getRoot().add(widget);
          this.flush();
          widget.destroy();
          menu.destroy();
        }, this, "Dispose toolbar split button");
        this.assertDestroy(function () {
          var widget = new qx.ui.toolbar.ToolBar();
          widget.add(new qx.ui.toolbar.Button("juhu"));
          var part = new qx.ui.toolbar.Part();
          part.add(new qx.ui.toolbar.RadioButton());
          widget.add(part);
          this.getRoot().add(widget);
          this.flush();
          widget.destroy();
        }, this, "Dispose configured toolbar");
      },
      testTooltip: function testTooltip() {
        this.assertDestroy(function () {
          var widget = new qx.ui.tooltip.ToolTip();
          widget.show();
          this.flush();
          widget.destroy();
        }, this, "Dispose tool tip");
      },
      testTree: function testTree() {
        this.assertDestroy(function () {
          var widget = new qx.ui.tree.Tree();
          var root = new qx.ui.tree.TreeFolder("folder");
          root.setOpen(true);
          root.add(new qx.ui.tree.TreeFile("file"));
          widget.setRoot(root);
          widget.show();
          this.flush();
          widget.destroy();
        }, this, "Dispose tree");
      },
      testRadioGroup: function testRadioGroup() {
        this.assertDestroy(function () {
          var group = new qx.ui.form.RadioGroup(new qx.ui.form.RadioButton("one"), new qx.ui.form.RadioButton("two"));
          group.dispose();
        });
      },
      testRadioButtonGroup: function testRadioButtonGroup() {
        this.assertDestroy(function () {
          var group = new qx.ui.form.RadioButtonGroup(new qx.ui.layout.HBox());
          group.add(new qx.ui.form.RadioButton("one"));
          group.add(new qx.ui.form.RadioButton("two"));
          group.destroy();
        });
      },
      testWindow: function testWindow() {
        this.assertDestroy(function () {
          var widget = new qx.ui.window.Window();
          widget.show();
          this.flush();
          widget.destroy();
        }, this, "Dispose window");
      },
      __createMenu: function __createMenu() {
        var menu = new qx.ui.menu.Menu();
        menu.add(new qx.ui.menu.Button("Juhu"));
        menu.add(new qx.ui.menu.CheckBox("Juhu"));
        menu.add(new qx.ui.menu.RadioButton("Juhu"));
        menu.add(new qx.ui.menu.Separator("Juhu"));
        return menu;
      }
    }
  });
  qx.test.ui.Destroy.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Util": {},
      "qx.theme.manager.Decoration": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Docks children to one of the edges.
   *
   * *Features*
   *
   * * Percent width for left/right/center attached children
   * * Percent height for top/bottom/center attached children
   * * Minimum and maximum dimensions
   * * Prioritized growing/shrinking (flex)
   * * Auto sizing
   * * Margins and Spacings
   * * Alignment in orthogonal axis (e.g. alignX of north attached)
   * * Different sort options for children
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>edge</strong> <em>(String)</em>: The edge where the layout item
   *   should be docked. This may be one of <code>north</code>, <code>east</code>,
   *   <code>south</code>, <code>west</code> or <code>center</code>. (Required)</li>
   * <li><strong>width</strong> <em>(String)</em>: Defines a percent
   *   width for the item. The percent width,
   *   when specified, is used instead of the width defined by the size hint.
   *   This is only supported for children added to the north or south edge or
   *   are centered in the middle of the layout.
   *   The minimum and maximum width still takes care of the elements limitations.
   *   It has no influence on the layout's size hint. Percents are mainly useful for
   *   widgets which are sized by the outer hierarchy.
   * </li>
   * <li><strong>height</strong> <em>(String)</em>: Defines a percent
   *   height for the item. The percent height,
   *   when specified, is used instead of the height defined by the size hint.
   *   This is only supported for children added to the west or east edge or
   *   are centered in the middle of the layout.
   *   The minimum and maximum height still takes care of the elements limitations.
   *   It has no influence on the layout's size hint. Percents are mainly useful for
   *   widgets which are sized by the outer hierarchy.
   * </li>
   * </ul>
   *
   * *Example*
   *
   * <pre class="javascript">
   * var layout = new qx.ui.layout.Dock();
   *
   * var w1 = new qx.ui.core.Widget();
   * var w2 = new qx.ui.core.Widget();
   * var w3 = new qx.ui.core.Widget();
   *
   * w1.setHeight(200);
   * w2.setWidth(150);
   *
   * var container = new qx.ui.container.Composite(layout);
   * container.add(w1, {edge:"north"});
   * container.add(w2, {edge:"west"});
   * container.add(w3, {edge:"center"});
   * </pre>
   *
   * *Detailed Description*
   *
   * Using this layout, items may be "docked" to a specific side
   * of the available space. Each displayed item reduces the available space
   * for the following children. Priorities depend on the position of
   * the child in the internal children list.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/dock.html'>
   * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.
   */
  qx.Class.define("qx.ui.layout.Dock", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param spacingX {Integer?0} The horizontal spacing. Sets {@link #spacingX}.
     * @param spacingY {Integer?0} The vertical spacing. Sets {@link #spacingY}.
     * @param separatorX {String|qx.ui.decoration.IDecorator} Separator to render between columns
     * @param separatorY {String|qx.ui.decoration.IDecorator} Separator to render between rows
     */
    construct: function construct(spacingX, spacingY, separatorX, separatorY) {
      qx.ui.layout.Abstract.constructor.call(this);

      if (spacingX) {
        this.setSpacingX(spacingX);
      }

      if (spacingY) {
        this.setSpacingY(spacingY);
      }

      if (separatorX) {
        this.setSeparatorX(separatorX);
      }

      if (separatorY) {
        this.setSeparatorY(separatorY);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The way the widgets should be displayed (in conjunction with their
       * position in the childrens array).
       */
      sort: {
        check: ["auto", "y", "x"],
        init: "auto",
        apply: "_applySort"
      },

      /** Separator lines to use between the horizontal objects */
      separatorX: {
        check: "Decorator",
        nullable: true,
        apply: "_applyLayoutChange"
      },

      /** Separator lines to use between the vertical objects */
      separatorY: {
        check: "Decorator",
        nullable: true,
        apply: "_applyLayoutChange"
      },

      /**
       * Whether separators should be collapsed so when a spacing is
       * configured the line go over into each other
       */
      connectSeparators: {
        check: "Boolean",
        init: false,
        apply: "_applyLayoutChange"
      },

      /** Horizontal spacing between two children */
      spacingX: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /** Vertical spacing between two children */
      spacingY: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __children: null,
      __edges: null,
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        this.assertInArray(name, ["flex", "edge", "height", "width"], "The property '" + name + "' is not supported by the Dock layout!");

        if (name === "edge") {
          this.assertInArray(value, ["north", "south", "west", "east", "center"]);
        } else if (name === "flex") {
          this.assertNumber(value);
          this.assert(value >= 0);
        } else {
          this.assertMatch(value, qx.ui.layout.Util.PERCENT_VALUE);
        }
      },
      // property apply
      _applySort: function _applySort() {
        // easiest way is to invalidate the cache
        this._invalidChildrenCache = true; // call normal layout change

        this._applyLayoutChange();
      },

      /**
       * @type {Map} Maps edge IDs to numeric values
       *
       * @lint ignoreReferenceField(__edgeMap)
       */
      __edgeMap: {
        north: 1,
        south: 2,
        west: 3,
        east: 4,
        center: 5
      },

      /**
       * @type {Map} Maps edges to align values
       *
       * @lint ignoreReferenceField(__alignMap)
       */
      __alignMap: {
        1: "top",
        2: "bottom",
        3: "left",
        4: "right"
      },

      /**
       * Rebuilds cache for sorted children list.
       *
       */
      __rebuildCache: function __rebuildCache() {
        var all = this._getLayoutChildren();

        var child, center;
        var length = all.length;
        var high = [];
        var low = [];
        var edge = [];
        var yfirst = this.getSort() === "y";
        var xfirst = this.getSort() === "x";

        for (var i = 0; i < length; i++) {
          child = all[i];
          edge = child.getLayoutProperties().edge;

          if (edge === "center") {
            if (center) {
              throw new Error("It is not allowed to have more than one child aligned to 'center'!");
            }

            center = child;
          } else if (xfirst || yfirst) {
            if (edge === "north" || edge === "south") {
              yfirst ? high.push(child) : low.push(child);
            } else if (edge === "west" || edge === "east") {
              yfirst ? low.push(child) : high.push(child);
            }
          } else {
            high.push(child);
          }
        } // Combine sorted children list


        var result = high.concat(low);

        if (center) {
          result.push(center);
        }

        this.__children = result; // Cache edges for faster access

        var edges = [];

        for (var i = 0; i < length; i++) {
          edge = result[i].getLayoutProperties().edge;
          edges[i] = this.__edgeMap[edge] || 5;
        }

        this.__edges = edges; // Clear invalidation marker

        delete this._invalidChildrenCache;
      },

      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        // Rebuild flex/width caches
        if (this._invalidChildrenCache) {
          this.__rebuildCache();
        }

        var util = qx.ui.layout.Util;
        var children = this.__children;
        var edges = this.__edges;
        var length = children.length;
        var flexibles, child, hint, props, flex, grow, width, height, offset;
        var widths = [];
        var heights = [];

        var separatorWidths = this._getSeparatorWidths();

        var spacingX = this.getSpacingX();
        var spacingY = this.getSpacingY(); // **************************************
        //   Caching children data
        // **************************************

        var allocatedWidth = -spacingX;
        var allocatedHeight = -spacingY;

        if (separatorWidths.x) {
          allocatedWidth -= separatorWidths.x + spacingX;
        }

        if (separatorWidths.y) {
          allocatedHeight -= separatorWidths.y + spacingY;
        }

        for (var i = 0; i < length; i++) {
          child = children[i];
          props = child.getLayoutProperties();
          hint = child.getSizeHint();
          width = hint.width;
          height = hint.height;

          if (props.width != null) {
            width = Math.floor(availWidth * parseFloat(props.width) / 100);

            if (width < hint.minWidth) {
              width = hint.minWidth;
            } else if (width > hint.maxWidth) {
              width = hint.maxWidth;
            }
          }

          if (props.height != null) {
            height = Math.floor(availHeight * parseFloat(props.height) / 100);

            if (height < hint.minHeight) {
              height = hint.minHeight;
            } else if (height > hint.maxHeight) {
              height = hint.maxHeight;
            }
          }

          widths[i] = width;
          heights[i] = height; // Update allocated width

          switch (edges[i]) {
            // north+south
            case 1:
            case 2:
              allocatedHeight += height + child.getMarginTop() + child.getMarginBottom() + spacingY;

              if (separatorWidths.y) {
                allocatedHeight += separatorWidths.y + spacingY;
              }

              break;
            // west+east

            case 3:
            case 4:
              allocatedWidth += width + child.getMarginLeft() + child.getMarginRight() + spacingX;

              if (separatorWidths.x) {
                allocatedWidth += separatorWidths.x + spacingX;
              }

              break;
            // center

            default:
              allocatedWidth += width + child.getMarginLeft() + child.getMarginRight() + spacingX;
              allocatedHeight += height + child.getMarginTop() + child.getMarginBottom() + spacingY;

              if (separatorWidths.x) {
                allocatedWidth += separatorWidths.x + spacingX;
              }

              if (separatorWidths.y) {
                allocatedHeight += separatorWidths.y + spacingY;
              }

          }
        } // **************************************
        //   Horizontal flex support
        // **************************************


        if (allocatedWidth != availWidth) {
          flexibles = {};
          grow = allocatedWidth < availWidth;

          for (var i = 0; i < length; i++) {
            child = children[i];

            switch (edges[i]) {
              case 3:
              case 4:
              case 5:
                flex = child.getLayoutProperties().flex; // Default flex for centered children is '1'

                if (flex == null && edges[i] == 5) {
                  flex = 1;
                }

                if (flex > 0) {
                  hint = child.getSizeHint();
                  flexibles[i] = {
                    min: hint.minWidth,
                    value: widths[i],
                    max: hint.maxWidth,
                    flex: flex
                  };
                }

            }
          }

          var result = util.computeFlexOffsets(flexibles, availWidth, allocatedWidth);

          for (var i in result) {
            offset = result[i].offset;
            widths[i] += offset;
            allocatedWidth += offset;
          }
        } // **************************************
        //   Vertical flex support
        // **************************************
        // Process height for flex stretching/shrinking


        if (allocatedHeight != availHeight) {
          flexibles = {};
          grow = allocatedHeight < availHeight;

          for (var i = 0; i < length; i++) {
            child = children[i];

            switch (edges[i]) {
              case 1:
              case 2:
              case 5:
                flex = child.getLayoutProperties().flex; // Default flex for centered children is '1'

                if (flex == null && edges[i] == 5) {
                  flex = 1;
                }

                if (flex > 0) {
                  hint = child.getSizeHint();
                  flexibles[i] = {
                    min: hint.minHeight,
                    value: heights[i],
                    max: hint.maxHeight,
                    flex: flex
                  };
                }

            }
          }

          var result = util.computeFlexOffsets(flexibles, availHeight, allocatedHeight);

          for (var i in result) {
            offset = result[i].offset;
            heights[i] += offset;
            allocatedHeight += offset;
          }
        } // **************************************
        //   Layout children
        // **************************************
        // Pre configure separators


        this._clearSeparators(); // Prepare loop


        var separatorX = this.getSeparatorX(),
            separatorY = this.getSeparatorY();
        var connectSeparators = this.getConnectSeparators();
        var nextTop = 0,
            nextLeft = 0;
        var left, top, width, height, used, edge;
        var separatorLeft, separatorTop, separatorWidth, separatorHeight;
        var marginTop, marginBottom, marginLeft, marginRight;
        var alignMap = this.__alignMap;

        for (var i = 0; i < length; i++) {
          // Cache child data
          child = children[i];
          edge = edges[i];
          hint = child.getSizeHint(); // Cache child margins

          marginTop = child.getMarginTop();
          marginBottom = child.getMarginBottom();
          marginLeft = child.getMarginLeft();
          marginRight = child.getMarginRight(); // Calculate child layout

          switch (edge) {
            // north + south
            case 1:
            case 2:
              // Full available width
              width = availWidth - marginLeft - marginRight; // Limit width to min/max

              if (width < hint.minWidth) {
                width = hint.minWidth;
              } else if (width > hint.maxWidth) {
                width = hint.maxWidth;
              } // Child preferred height


              height = heights[i]; // Compute position

              top = nextTop + util.computeVerticalAlignOffset(alignMap[edge], height, availHeight, marginTop, marginBottom);
              left = nextLeft + util.computeHorizontalAlignOffset(child.getAlignX() || "left", width, availWidth, marginLeft, marginRight); // Render the separator

              if (separatorWidths.y) {
                if (edge == 1) {
                  separatorTop = nextTop + height + marginTop + spacingY + marginBottom;
                } else {
                  separatorTop = nextTop + availHeight - height - marginTop - spacingY - marginBottom - separatorWidths.y;
                }

                separatorLeft = left;
                separatorWidth = availWidth;

                if (connectSeparators && separatorLeft > 0) {
                  separatorLeft -= spacingX + marginLeft;
                  separatorWidth += spacingX * 2;
                } else {
                  separatorLeft -= marginLeft;
                }

                this._renderSeparator(separatorY, {
                  left: separatorLeft + padding.left,
                  top: separatorTop + padding.top,
                  width: separatorWidth,
                  height: separatorWidths.y
                });
              } // Update available height


              used = height + marginTop + marginBottom + spacingY;

              if (separatorWidths.y) {
                used += separatorWidths.y + spacingY;
              }

              availHeight -= used; // Update coordinates, for next child

              if (edge == 1) {
                nextTop += used;
              }

              break;
            // west + east

            case 3:
            case 4:
              // Full available height
              height = availHeight - marginTop - marginBottom; // Limit height to min/max

              if (height < hint.minHeight) {
                height = hint.minHeight;
              } else if (height > hint.maxHeight) {
                height = hint.maxHeight;
              } // Child preferred width


              width = widths[i]; // Compute position

              left = nextLeft + util.computeHorizontalAlignOffset(alignMap[edge], width, availWidth, marginLeft, marginRight);
              top = nextTop + util.computeVerticalAlignOffset(child.getAlignY() || "top", height, availHeight, marginTop, marginBottom); // Render the separator

              if (separatorWidths.x) {
                if (edge == 3) {
                  separatorLeft = nextLeft + width + marginLeft + spacingX + marginRight;
                } else {
                  separatorLeft = nextLeft + availWidth - width - marginLeft - spacingX - marginRight - separatorWidths.x;
                }

                separatorTop = top;
                separatorHeight = availHeight;

                if (connectSeparators && separatorTop > 0) {
                  separatorTop -= spacingY + marginTop;
                  separatorHeight += spacingY * 2;
                } else {
                  separatorTop -= marginTop;
                }

                this._renderSeparator(separatorX, {
                  left: separatorLeft + padding.left,
                  top: separatorTop + padding.top,
                  width: separatorWidths.x,
                  height: separatorHeight
                });
              } // Update available height


              used = width + marginLeft + marginRight + spacingX;

              if (separatorWidths.x) {
                used += separatorWidths.x + spacingX;
              }

              availWidth -= used; // Update coordinates, for next child

              if (edge == 3) {
                nextLeft += used;
              }

              break;
            // center

            default:
              // Calculated width/height
              width = availWidth - marginLeft - marginRight;
              height = availHeight - marginTop - marginBottom; // Limit width to min/max

              if (width < hint.minWidth) {
                width = hint.minWidth;
              } else if (width > hint.maxWidth) {
                width = hint.maxWidth;
              } // Limit height to min/max


              if (height < hint.minHeight) {
                height = hint.minHeight;
              } else if (height > hint.maxHeight) {
                height = hint.maxHeight;
              } // Compute coordinates (respect margins and alignments for both axis)


              left = nextLeft + util.computeHorizontalAlignOffset(child.getAlignX() || "left", width, availWidth, marginLeft, marginRight);
              top = nextTop + util.computeVerticalAlignOffset(child.getAlignY() || "top", height, availHeight, marginTop, marginBottom);
          } // Apply layout


          child.renderLayout(left + padding.left, top + padding.top, width, height);
        }
      },

      /**
       * Computes the dimensions each separator on both the <code>x</code> and
       * <code>y</code> axis needs.
       *
       * @return {Map} Map with the keys <code>x</code> and
       *   <code>y</code>
       */
      _getSeparatorWidths: function _getSeparatorWidths() {
        var separatorX = this.getSeparatorX(),
            separatorY = this.getSeparatorY();

        if (separatorX || separatorY) {
          var decorationManager = qx.theme.manager.Decoration.getInstance();
        }

        if (separatorX) {
          var separatorInstanceX = decorationManager.resolve(separatorX);
          var separatorInsetsX = separatorInstanceX.getInsets();
          var separatorWidthX = separatorInsetsX.left + separatorInsetsX.right;
        }

        if (separatorY) {
          var separatorInstanceY = decorationManager.resolve(separatorY);
          var separatorInsetsY = separatorInstanceY.getInsets();
          var separatorWidthY = separatorInsetsY.top + separatorInsetsY.bottom;
        }

        return {
          x: separatorWidthX || 0,
          y: separatorWidthY || 0
        };
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        // Rebuild flex/width caches
        if (this._invalidChildrenCache) {
          this.__rebuildCache();
        }

        var children = this.__children;
        var edges = this.__edges;
        var length = children.length;
        var hint, child;
        var marginX, marginY;
        var widthX = 0,
            minWidthX = 0;
        var heightX = 0,
            minHeightX = 0;
        var widthY = 0,
            minWidthY = 0;
        var heightY = 0,
            minHeightY = 0;

        var separatorWidths = this._getSeparatorWidths();

        var spacingX = this.getSpacingX(),
            spacingY = this.getSpacingY();
        var spacingSumX = -spacingX,
            spacingSumY = -spacingY;

        if (separatorWidths.x) {
          spacingSumX -= separatorWidths.x + spacingX;
        }

        if (separatorWidths.y) {
          spacingSumY -= separatorWidths.y + spacingY;
        } // Detect children sizes


        for (var i = 0; i < length; i++) {
          child = children[i];
          hint = child.getSizeHint(); // Pre-cache margin sums

          marginX = child.getMarginLeft() + child.getMarginRight();
          marginY = child.getMarginTop() + child.getMarginBottom(); // Ok, this part is a bit complicated :)

          switch (edges[i]) {
            case 1:
            case 2:
              // Find the maximum width used by these fully stretched items
              // The recommended width used by these must add the currently
              // occupied width by the orthogonal ordered children.
              widthY = Math.max(widthY, hint.width + widthX + marginX);
              minWidthY = Math.max(minWidthY, hint.minWidth + minWidthX + marginX); // Add the needed heights of this widget

              heightY += hint.height + marginY;
              minHeightY += hint.minHeight + marginY; // Add spacing

              spacingSumY += spacingY;

              if (separatorWidths.y) {
                spacingSumY += separatorWidths.y + spacingY;
              }

              break;

            case 3:
            case 4:
              // Find the maximum height used by these fully stretched items
              // The recommended height used by these must add the currently
              // occupied height by the orthogonal ordered children.
              heightX = Math.max(heightX, hint.height + heightY + marginY);
              minHeightX = Math.max(minHeightX, hint.minHeight + minHeightY + marginY); // Add the needed widths of this widget

              widthX += hint.width + marginX;
              minWidthX += hint.minWidth + marginX; // Add spacing

              spacingSumX += spacingX;

              if (separatorWidths.x) {
                spacingSumX += separatorWidths.x + spacingX;
              }

              break;

            default:
              // A centered widget must be added to both sums as
              // it stretches into the remaining available space.
              widthX += hint.width + marginX;
              minWidthX += hint.minWidth + marginX;
              heightY += hint.height + marginY;
              minHeightY += hint.minHeight + marginY; // Add spacing

              spacingSumX += spacingX;

              if (separatorWidths.x) {
                spacingSumX += separatorWidths.x + spacingX;
              }

              spacingSumY += spacingY;

              if (separatorWidths.y) {
                spacingSumY += separatorWidths.y + spacingY;
              }

          }
        }

        var minWidth = Math.max(minWidthX, minWidthY) + spacingSumX;
        var width = Math.max(widthX, widthY) + spacingSumX;
        var minHeight = Math.max(minHeightX, minHeightY) + spacingSumY;
        var height = Math.max(heightX, heightY) + spacingSumY; // Return hint

        return {
          minWidth: minWidth,
          width: width,
          minHeight: minHeight,
          height: height
        };
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__edges = this.__children = null;
    }
  });
  qx.ui.layout.Dock.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.TextField": {
        "require": true
      },
      "qx.html.Input": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A password input field, which hides the entered text.
   */
  qx.Class.define("qx.ui.form.PasswordField", {
    extend: qx.ui.form.TextField,
    members: {
      // overridden
      _createInputElement: function _createInputElement() {
        return new qx.html.Input("password");
      }
    }
  });
  qx.ui.form.PasswordField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Button": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * Radio buttons can be used in radio groups to allow to the user to select
   * exactly one item from a list. Radio groups are established by adding
   * radio buttons to a radio manager {@link qx.ui.form.RadioGroup}.
   *
   * Example:
   * <pre class="javascript">
   *   var container = new qx.ui.container.Composite(new qx.ui.layout.VBox);
   *
   *   var female = new qx.ui.form.RadioButton("female");
   *   var male = new qx.ui.form.RadioButton("male");
   *
   *   var mgr = new qx.ui.form.RadioGroup();
   *   mgr.add(female, male);
   *
   *   container.add(male);
   *   container.add(female);
   * </pre>
   */
  qx.Class.define("qx.ui.form.RadioButton", {
    extend: qx.ui.form.Button,
    include: [qx.ui.form.MForm, qx.ui.form.MModelProperty],
    implement: [qx.ui.form.IRadioItem, qx.ui.form.IForm, qx.ui.form.IBooleanForm, qx.ui.form.IModel],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String?null} An optional label for the radio button.
     */
    construct: function construct(label) {
      {
        this.assertArgumentsCount(arguments, 0, 1);
      }
      qx.ui.form.Button.constructor.call(this, label); // Add listeners

      this.addListener("execute", this._onExecute);
      this.addListener("keypress", this._onKeyPress);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The assigned qx.ui.form.RadioGroup which handles the switching between registered buttons */
      group: {
        check: "qx.ui.form.RadioGroup",
        nullable: true,
        apply: "_applyGroup"
      },

      /** The value of the widget. True, if the widget is checked. */
      value: {
        check: "Boolean",
        nullable: true,
        event: "changeValue",
        apply: "_applyValue",
        init: false
      },
      // overridden
      appearance: {
        refine: true,
        init: "radiobutton"
      },
      // overridden
      allowGrowX: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        checked: true,
        focused: true,
        invalid: true,
        hovered: true
      },
      // overridden (from MExecutable to keep the icon out of the binding)

      /**
       * @lint ignoreReferenceField(_bindableProperties)
       */
      _bindableProperties: ["enabled", "label", "toolTipText", "value", "menu"],

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyValue: function _applyValue(value, old) {
        value ? this.addState("checked") : this.removeState("checked");
      },

      /** The assigned {@link qx.ui.form.RadioGroup} which handles the switching between registered buttons */
      _applyGroup: function _applyGroup(value, old) {
        if (old) {
          old.remove(this);
        }

        if (value) {
          value.add(this);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT-HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for the "execute" event.
       *
       * Sets the property "checked" to true.
       *
       * @param e {qx.event.type.Event} execute event
       */
      _onExecute: function _onExecute(e) {
        var grp = this.getGroup();

        if (grp && grp.getAllowEmptySelection()) {
          this.toggleValue();
        } else {
          this.setValue(true);
        }
      },

      /**
       * Event listener for the "keyPress" event.
       *
       * Selects the previous RadioButton when pressing "Left" or "Up" and
       * Selects the next RadioButton when pressing "Right" and "Down"
       *
       * @param e {qx.event.type.KeySequence} KeyPress event
       */
      _onKeyPress: function _onKeyPress(e) {
        var grp = this.getGroup();

        if (!grp) {
          return;
        }

        switch (e.getKeyIdentifier()) {
          case "Left":
          case "Up":
            grp.selectPrevious();
            break;

          case "Right":
          case "Down":
            grp.selectNext();
            break;
        }
      }
    }
  });
  qx.ui.form.RadioButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.form.Button": {},
      "qx.ui.form.MenuButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A button which acts as a normal button and shows a menu on one
   * of the sides to open something like a history list.
   *
   * @childControl button {qx.ui.form.Button} button to execute action
   * @childControl arrow {qx.ui.form.MenuButton} arrow to open the popup
   */
  qx.Class.define("qx.ui.form.SplitButton", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MExecutable],
    implement: [qx.ui.form.IExecutable],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Label to use
     * @param icon {String?null} Icon to use
     * @param menu {qx.ui.menu.Menu} Connect to menu instance
     * @param command {qx.ui.command.Command} Command instance to connect with
     */
    construct: function construct(label, icon, menu, command) {
      qx.ui.core.Widget.constructor.call(this);

      this._setLayout(new qx.ui.layout.HBox()); // Force arrow creation


      this._createChildControl("arrow"); // Add pointer listeners


      this.addListener("pointerover", this._onPointerOver, this, true);
      this.addListener("pointerout", this._onPointerOut, this, true); // Add key listeners

      this.addListener("keydown", this._onKeyDown);
      this.addListener("keyup", this._onKeyUp); // Process incoming arguments

      if (label != null) {
        this.setLabel(label);
      }

      if (icon != null) {
        this.setIcon(icon);
      }

      if (menu != null) {
        this.setMenu(menu);
      }

      if (command != null) {
        this.setCommand(command);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "splitbutton"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /** The label/caption/text of the qx.ui.basic.Atom instance */
      label: {
        apply: "_applyLabel",
        nullable: true,
        check: "String"
      },

      /** Any URI String supported by qx.ui.basic.Image to display an icon */
      icon: {
        check: "String",
        apply: "_applyIcon",
        nullable: true,
        themeable: true
      },

      /**
       * Configure the visibility of the sub elements/widgets.
       * Possible values: both, text, icon
       */
      show: {
        init: "both",
        check: ["both", "label", "icon"],
        themeable: true,
        inheritable: true,
        apply: "_applyShow",
        event: "changeShow"
      },

      /** The menu instance to show when tapping on the button */
      menu: {
        check: "qx.ui.menu.Menu",
        nullable: true,
        apply: "_applyMenu",
        event: "changeMenu"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __cursorIsOut: null,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "button":
            control = new qx.ui.form.Button();
            control.addListener("execute", this._onButtonExecute, this);
            control.setFocusable(false);

            this._addAt(control, 0, {
              flex: 1
            });

            break;

          case "arrow":
            control = new qx.ui.form.MenuButton();
            control.setFocusable(false);
            control.setShow("both");

            this._addAt(control, 1);

            break;
        }

        return control || qx.ui.form.SplitButton.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        hovered: 1,
        focused: 1
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyLabel: function _applyLabel(value, old) {
        var button = this.getChildControl("button");
        value == null ? button.resetLabel() : button.setLabel(value);
      },
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        var button = this.getChildControl("button");
        value == null ? button.resetIcon() : button.setIcon(value);
      },
      // property apply
      _applyMenu: function _applyMenu(value, old) {
        var arrow = this.getChildControl("arrow");

        if (value) {
          arrow.resetEnabled();
          arrow.setMenu(value);
          value.setOpener(this);
          value.addListener("changeVisibility", this._onChangeMenuVisibility, this);
        } else {
          arrow.setEnabled(false);
          arrow.resetMenu();
        }

        if (old) {
          old.removeListener("changeVisibility", this._onChangeMenuVisibility, this);
          old.resetOpener();
        }
      },
      // property apply
      _applyShow: function _applyShow(value, old) {// pass: is already inherited to the button
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Listener for <code>pointerover</code> event
       *
       * @param e {qx.event.type.Pointer} pointerover event
       */
      _onPointerOver: function _onPointerOver(e) {
        // Captured listener
        // Whole stop for event, do not let the
        // inner buttons know about this event.
        e.stopPropagation(); // Add hover state, is forwarded to the buttons

        this.addState("hovered"); // Delete cursor out flag

        delete this.__cursorIsOut;
      },

      /**
       * Listener for <code>pointerout</code> event
       *
       * @param e {qx.event.type.Pointer} pointerout event
       */
      _onPointerOut: function _onPointerOut(e) {
        // Captured listener
        // Whole stop for event, do not let the
        // inner buttons know about this event.
        e.stopPropagation(); // First simple state check

        if (!this.hasState("hovered")) {
          return;
        } // Only when the related target is not part of the button


        var related = e.getRelatedTarget();

        if (qx.ui.core.Widget.contains(this, related)) {
          return;
        } // When the menu is visible (cursor moved to the menu)
        // keep the hover state on the whole button


        var menu = this.getMenu();

        if (menu && menu.isVisible()) {
          this.__cursorIsOut = true;
          return;
        } // Finally remove state


        this.removeState("hovered");
      },

      /**
       * Event listener for all keyboard events
       *
       * @param e {qx.event.type.KeySequence} Event object
       */
      _onKeyDown: function _onKeyDown(e) {
        var button = this.getChildControl("button");

        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            button.removeState("abandoned");
            button.addState("pressed");
        }
      },

      /**
       * Event listener for all keyboard events
       *
       * @param e {qx.event.type.KeySequence} Event object
       */
      _onKeyUp: function _onKeyUp(e) {
        var button = this.getChildControl("button");

        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            if (button.hasState("pressed")) {
              button.removeState("abandoned");
              button.removeState("pressed");
              button.execute();
            }

        }
      },

      /**
       * Event listener for button's execute event.
       *
       * @param e {qx.event.type.Event} execute event of the button
       */
      _onButtonExecute: function _onButtonExecute(e) {
        // forward execute event
        this.execute();
      },

      /**
       * Event listener for visibility changes of the menu
       *
       * @param e {qx.event.type.Data} property change event
       */
      _onChangeMenuVisibility: function _onChangeMenuVisibility(e) {
        if (!this.getMenu().isVisible() && this.__cursorIsOut) {
          this.removeState("hovered");
        }
      }
    }
  });
  qx.ui.form.SplitButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.AbstractField": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.queue.Layout": {},
      "qx.ui.core.queue.Manager": {},
      "qx.html.Element": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.bom.Element": {},
      "qx.html.Input": {},
      "qx.bom.element.Dimension": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /**
   * The TextField is a multi-line text input field.
   */
  qx.Class.define("qx.ui.form.TextArea", {
    extend: qx.ui.form.AbstractField,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {String?""} The text area's initial value
     */
    construct: function construct(value) {
      qx.ui.form.AbstractField.constructor.call(this, value);
      this.initWrap();
      this.addListener("roll", this._onRoll, this);
      this.addListener("resize", this._onResize, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Controls whether text wrap is activated or not. */
      wrap: {
        check: "Boolean",
        init: true,
        apply: "_applyWrap"
      },
      // overridden
      appearance: {
        refine: true,
        init: "textarea"
      },

      /** Factor for scrolling the <code>TextArea</code> with the mouse wheel. */
      singleStep: {
        check: "Integer",
        init: 20
      },

      /** Minimal line height. On default this is set to four lines. */
      minimalLineHeight: {
        check: "Integer",
        apply: "_applyMinimalLineHeight",
        init: 4
      },

      /**
      * Whether the <code>TextArea</code> should automatically adjust to
      * the height of the content.
      *
      * To set the initial height, modify {@link #minHeight}. If you wish
      * to set a minHeight below four lines of text, also set
      * {@link #minimalLineHeight}. In order to limit growing to a certain
      * height, set {@link #maxHeight} respectively. Please note that
      * autoSize is ignored when the {@link #height} property is in use.
      */
      autoSize: {
        check: "Boolean",
        apply: "_applyAutoSize",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __areaClone: null,
      __areaHeight: null,
      __originalAreaHeight: null,
      // overridden
      setValue: function setValue(value) {
        value = qx.ui.form.TextArea.prototype.setValue.base.call(this, value);

        this.__autoSize();

        return value;
      },

      /**
       * Handles the roll for scrolling the <code>TextArea</code>.
       *
       * @param e {qx.event.type.Roll} roll event.
       */
      _onRoll: function _onRoll(e) {
        // only wheel
        if (e.getPointerType() != "wheel") {
          return;
        }

        var contentElement = this.getContentElement();
        var scrollY = contentElement.getScrollY();
        contentElement.scrollToY(scrollY + e.getDelta().y / 30 * this.getSingleStep());
        var newScrollY = contentElement.getScrollY();

        if (newScrollY != scrollY) {
          e.stop();
        }
      },

      /**
       * When the element resizes we throw away the clone and trigger autosize again, otherwise the clone would have
       * another width and the autosize calculation would be faulty.
       * 
       * @param e {qx.event.type.Data} resize event.
       */
      _onResize: function _onResize(e) {
        if (this.__areaClone) {
          this.__areaClone.dispose();

          this.__areaClone = null;

          this.__autoSize();
        }
      },

      /*
      ---------------------------------------------------------------------------
        AUTO SIZE
      ---------------------------------------------------------------------------
      */

      /**
      * Adjust height of <code>TextArea</code> so that content fits without scroll bar.
      *
      */
      __autoSize: function __autoSize() {
        if (this.isAutoSize()) {
          var clone = this.__getAreaClone();

          if (clone && this.getBounds()) {
            // Remember original area height
            this.__originalAreaHeight = this.__originalAreaHeight || this._getAreaHeight();

            var scrolledHeight = this._getScrolledAreaHeight(); // Show scroll-bar when above maxHeight, if defined


            if (this.getMaxHeight()) {
              var insets = this.getInsets();
              var innerMaxHeight = -insets.top + this.getMaxHeight() - insets.bottom;

              if (scrolledHeight > innerMaxHeight) {
                this.getContentElement().setStyle("overflowY", "auto");
              } else {
                this.getContentElement().setStyle("overflowY", "hidden");
              }
            } // Never shrink below original area height


            var desiredHeight = Math.max(scrolledHeight, this.__originalAreaHeight); // Set new height

            this._setAreaHeight(desiredHeight); // On init, the clone is not yet present. Try again on appear.

          } else {
            this.getContentElement().addListenerOnce("appear", function () {
              this.__autoSize();
            }, this);
          }
        }
      },

      /**
      * Get actual height of <code>TextArea</code>
      *
      * @return {Integer} Height of <code>TextArea</code>
      */
      _getAreaHeight: function _getAreaHeight() {
        return this.getInnerSize().height;
      },

      /**
      * Set actual height of <code>TextArea</code>
      *
      * @param height {Integer} Desired height of <code>TextArea</code>
      */
      _setAreaHeight: function _setAreaHeight(height) {
        if (this._getAreaHeight() !== height) {
          this.__areaHeight = height;
          qx.ui.core.queue.Layout.add(this); // Apply height directly. This works-around a visual glitch in WebKit
          // browsers where a line-break causes the text to be moved upwards
          // for one line. Since this change appears instantly whereas the queue
          // is computed later, a flicker is visible.

          qx.ui.core.queue.Manager.flush();

          this.__forceRewrap();
        }
      },

      /**
      * Get scrolled area height. Equals the total height of the <code>TextArea</code>,
      * as if no scroll-bar was visible.
      *
      * @return {Integer} Height of scrolled area
      */
      _getScrolledAreaHeight: function _getScrolledAreaHeight() {
        var clone = this.__getAreaClone();

        var cloneDom = clone.getDomElement();

        if (cloneDom) {
          // Clone created but not yet in DOM. Try again.
          if (!cloneDom.parentNode) {
            qx.html.Element.flush();
            return this._getScrolledAreaHeight();
          } // In WebKit and IE8, "wrap" must have been "soft" on DOM level before setting
          // "off" can disable wrapping. To fix, make sure wrap is toggled.
          // Otherwise, the height of an auto-size text area with wrapping
          // disabled initially is incorrectly computed as if wrapping was enabled.


          if (qx.core.Environment.get("engine.name") === "webkit" || qx.core.Environment.get("engine.name") == "mshtml") {
            clone.setWrap(!this.getWrap(), true);
          }

          clone.setWrap(this.getWrap(), true); // Webkit needs overflow "hidden" in order to correctly compute height

          if (qx.core.Environment.get("engine.name") === "webkit" || qx.core.Environment.get("engine.name") == "mshtml") {
            cloneDom.style.overflow = "hidden";
          } // IE >= 8 needs overflow "visible" in order to correctly compute height


          if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") >= 8) {
            cloneDom.style.overflow = "visible";
            cloneDom.style.overflowX = "hidden";
          } // Update value


          clone.setValue(this.getValue() || ""); // Force IE > 8 to update size measurements

          if (qx.core.Environment.get("engine.name") == "mshtml") {
            cloneDom.style.height = "auto";
            qx.html.Element.flush();
            cloneDom.style.height = "0";
          } // Recompute


          this.__scrollCloneToBottom(clone);

          if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") == 8) {
            // Flush required for scrollTop to return correct value
            // when initial value should be taken into consideration
            if (!cloneDom.scrollTop) {
              qx.html.Element.flush();
            }
          }

          return cloneDom.scrollTop;
        }
      },

      /**
      * Returns the area clone.
      *
      * @return {Element|null} DOM Element or <code>null</code> if there is no
      * original element
      */
      __getAreaClone: function __getAreaClone() {
        this.__areaClone = this.__areaClone || this.__createAreaClone();
        return this.__areaClone;
      },

      /**
      * Creates and prepares the area clone.
      *
      * @return {Element} Element
      */
      __createAreaClone: function __createAreaClone() {
        var orig, clone, cloneDom, cloneHtml;
        orig = this.getContentElement(); // An existing DOM element is required

        if (!orig.getDomElement()) {
          return null;
        } // Create DOM clone


        cloneDom = qx.bom.Element.clone(orig.getDomElement()); // Convert to qx.html Element

        cloneHtml = new qx.html.Input("textarea");
        cloneHtml.useElement(cloneDom);
        clone = cloneHtml; // Push out of view
        // Zero height (i.e. scrolled area equals height)

        clone.setStyles({
          position: "absolute",
          top: 0,
          left: "-9999px",
          height: 0,
          overflow: "hidden"
        }, true); // Fix attributes

        clone.removeAttribute('id');
        clone.removeAttribute('name');
        clone.setAttribute("tabIndex", "-1"); // Copy value

        clone.setValue(orig.getValue() || ""); // Attach to DOM

        clone.insertBefore(orig); // Make sure scrollTop is actual height

        this.__scrollCloneToBottom(clone);

        return clone;
      },

      /**
      * Scroll <code>TextArea</code> to bottom. That way, scrollTop reflects the height
      * of the <code>TextArea</code>.
      *
      * @param clone {Element} The <code>TextArea</code> to scroll
      */
      __scrollCloneToBottom: function __scrollCloneToBottom(clone) {
        clone = clone.getDomElement();

        if (clone) {
          clone.scrollTop = 10000;
        }
      },

      /*
      ---------------------------------------------------------------------------
        FIELD API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createInputElement: function _createInputElement() {
        return new qx.html.Input("textarea", {
          overflowX: "auto",
          overflowY: "auto"
        });
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyWrap: function _applyWrap(value, old) {
        this.getContentElement().setWrap(value);

        if (this._placeholder) {
          var whiteSpace = value ? "normal" : "nowrap";

          this._placeholder.setStyle("whiteSpace", whiteSpace);
        }

        this.__autoSize();
      },
      // property apply
      _applyMinimalLineHeight: function _applyMinimalLineHeight() {
        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyAutoSize: function _applyAutoSize(value, old) {
        {
          this.__warnAutoSizeAndHeight();
        }

        if (value) {
          this.__autoSize();

          this.addListener("input", this.__autoSize, this); // This is done asynchronously on purpose. The style given would
          // otherwise be overridden by the DOM changes queued in the
          // property apply for wrap. See [BUG #4493] for more details.

          if (!this.getBounds()) {
            this.addListenerOnce("appear", function () {
              this.getContentElement().setStyle("overflowY", "hidden");
            });
          } else {
            this.getContentElement().setStyle("overflowY", "hidden");
          }
        } else {
          this.removeListener("input", this.__autoSize);
          this.getContentElement().setStyle("overflowY", "auto");
        }
      },
      // property apply
      _applyDimension: function _applyDimension(value) {
        qx.ui.form.TextArea.prototype._applyDimension.base.call(this);

        {
          this.__warnAutoSizeAndHeight();
        }

        if (value === this.getMaxHeight()) {
          this.__autoSize();
        }
      },

      /**
       * Force rewrapping of text.
       *
       * The distribution of characters depends on the space available.
       * Unfortunately, browsers do not reliably (or not at all) rewrap text when
       * the size of the text area changes.
       *
       * This method is called on change of the area's size.
       */
      __forceRewrap: function __forceRewrap() {
        var content = this.getContentElement();
        var element = content.getDomElement(); // Temporarily increase width

        var width = content.getStyle("width");
        content.setStyle("width", parseInt(width, 10) + 1000 + "px", true); // Force browser to render

        if (element) {
          qx.bom.element.Dimension.getWidth(element);
        } // Restore width


        content.setStyle("width", width, true);
      },

      /**
       * Warn when both autoSize and height property are set.
       *
       */
      __warnAutoSizeAndHeight: function __warnAutoSizeAndHeight() {
        if (this.isAutoSize() && this.getHeight()) {
          this.warn("autoSize is ignored when the height property is set. If you want to set an initial height, use the minHeight property instead.");
        }
      },

      /*
      ---------------------------------------------------------------------------
        LAYOUT
      ---------------------------------------------------------------------------
      */
      // overridden
      _getContentHint: function _getContentHint() {
        var hint = qx.ui.form.TextArea.prototype._getContentHint.base.call(this); // lines of text


        hint.height = hint.height * this.getMinimalLineHeight(); // 20 character wide

        hint.width = this._getTextSize().width * 20;

        if (this.isAutoSize()) {
          hint.height = this.__areaHeight || hint.height;
        }

        return hint;
      }
    },
    destruct: function destruct() {
      this.setAutoSize(false);

      if (this.__areaClone) {
        this.__areaClone.dispose();
      }
    }
  });
  qx.ui.form.TextArea.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Button": {
        "construct": true,
        "require": true
      },
      "qx.ui.menu.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A button which opens the connected menu when tapping on it.
   */
  qx.Class.define("qx.ui.form.MenuButton", {
    extend: qx.ui.form.Button,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Initial label
     * @param icon {String?null} Initial icon
     * @param menu {qx.ui.menu.Menu} Connect to menu instance
     */
    construct: function construct(label, icon, menu) {
      qx.ui.form.Button.constructor.call(this, label, icon); // Initialize properties

      if (menu != null) {
        this.setMenu(menu);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The menu instance to show when tapping on the button */
      menu: {
        check: "qx.ui.menu.Menu",
        nullable: true,
        apply: "_applyMenu",
        event: "changeMenu"
      },
      // overridden
      appearance: {
        refine: true,
        init: "menubutton"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyVisibility: function _applyVisibility(value, old) {
        qx.ui.form.MenuButton.prototype._applyVisibility.base.call(this, value, old); // hide the menu too


        var menu = this.getMenu();

        if (value != "visible" && menu) {
          menu.hide();
        }
      },
      // property apply
      _applyMenu: function _applyMenu(value, old) {
        if (old) {
          old.removeListener("changeVisibility", this._onMenuChange, this);
          old.resetOpener();
        }

        if (value) {
          value.addListener("changeVisibility", this._onMenuChange, this);
          value.setOpener(this);
          value.removeState("submenu");
          value.removeState("contextmenu");
        }
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Positions and shows the attached menu widget.
       *
       * @param selectFirst {Boolean?false} Whether the first menu button should be selected
       */
      open: function open(selectFirst) {
        var menu = this.getMenu();

        if (menu) {
          // Hide all menus first
          qx.ui.menu.Manager.getInstance().hideAll(); // Open the attached menu

          menu.setOpener(this);
          menu.open(); // Select first item

          if (selectFirst) {
            var first = menu.getSelectables()[0];

            if (first) {
              menu.setSelectedButton(first);
            }
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Listener for visibility property changes of the attached menu
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onMenuChange: function _onMenuChange(e) {
        var menu = this.getMenu();

        if (menu.isVisible()) {
          this.addState("pressed");
        } else {
          this.removeState("pressed");
        }
      },
      // overridden
      _onPointerDown: function _onPointerDown(e) {
        // call the base function to get into the capture phase [BUG #4340]
        qx.ui.form.MenuButton.prototype._onPointerDown.base.call(this, e); // only open on left clicks [BUG #5125]


        if (e.getButton() != "left") {
          return;
        }

        var menu = this.getMenu();

        if (menu) {
          // Toggle sub menu visibility
          if (!menu.isVisible()) {
            this.open();
          } else {
            menu.exclude();
          } // Event is processed, stop it for others


          e.stopPropagation();
        }
      },
      // overridden
      _onPointerUp: function _onPointerUp(e) {
        // call base for firing the execute event
        qx.ui.form.MenuButton.prototype._onPointerUp.base.call(this, e); // Just stop propagation to stop menu manager
        // from getting the event


        e.stopPropagation();
      },
      // overridden
      _onPointerOver: function _onPointerOver(e) {
        // Add hovered state
        this.addState("hovered");
      },
      // overridden
      _onPointerOut: function _onPointerOut(e) {
        // Just remove the hover state
        this.removeState("hovered");
      },
      // overridden
      _onKeyDown: function _onKeyDown(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
            this.removeState("abandoned");
            this.addState("pressed");
            var menu = this.getMenu();

            if (menu) {
              // Toggle sub menu visibility
              if (!menu.isVisible()) {
                this.open();
              } else {
                menu.exclude();
              }
            }

            e.stopPropagation();
        }
      },
      // overridden
      _onKeyUp: function _onKeyUp(e) {// no action required here
      }
    }
  });
  qx.ui.form.MenuButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.Registration": {
        "construct": true
      },
      "qx.event.handler.DragDrop": {
        "construct": true
      },
      "qx.ui.core.Widget": {},
      "qx.core.Init": {},
      "qx.lang.Object": {},
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 David Pérez Carmona
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * David Perez Carmona (david-perez)
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Provides resizing behavior to any widget.
   */
  qx.Mixin.define("qx.ui.core.MResizable", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      // Register listeners to the content
      var content = this.getContentElement();
      content.addListener("pointerdown", this.__onResizePointerDown, this, true);
      content.addListener("pointerup", this.__onResizePointerUp, this);
      content.addListener("pointermove", this.__onResizePointerMove, this);
      content.addListener("pointerout", this.__onResizePointerOut, this);
      content.addListener("losecapture", this.__onResizeLoseCapture, this); // Get a reference of the drag and drop handler

      var domElement = content.getDomElement();

      if (domElement == null) {
        domElement = window;
      }

      this.__dragDropHandler = qx.event.Registration.getManager(domElement).getHandler(qx.event.handler.DragDrop);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Whether the top edge is resizable */
      resizableTop: {
        check: "Boolean",
        init: true
      },

      /** Whether the right edge is resizable */
      resizableRight: {
        check: "Boolean",
        init: true
      },

      /** Whether the bottom edge is resizable */
      resizableBottom: {
        check: "Boolean",
        init: true
      },

      /** Whether the left edge is resizable */
      resizableLeft: {
        check: "Boolean",
        init: true
      },

      /**
       * Property group to configure the resize behaviour for all edges at once
       */
      resizable: {
        group: ["resizableTop", "resizableRight", "resizableBottom", "resizableLeft"],
        mode: "shorthand"
      },

      /** The tolerance to activate resizing */
      resizeSensitivity: {
        check: "Integer",
        init: 5
      },

      /** Whether a frame replacement should be used during the resize sequence */
      useResizeFrame: {
        check: "Boolean",
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __dragDropHandler: null,
      __resizeFrame: null,
      __resizeActive: null,
      __resizeLeft: null,
      __resizeTop: null,
      __resizeStart: null,
      __resizeRange: null,
      RESIZE_TOP: 1,
      RESIZE_BOTTOM: 2,
      RESIZE_LEFT: 4,
      RESIZE_RIGHT: 8,

      /*
      ---------------------------------------------------------------------------
        CORE FEATURES
      ---------------------------------------------------------------------------
      */

      /**
       * Get the widget, which draws the resize/move frame. The resize frame is
       * shared by all widgets and is added to the root widget.
       *
       * @return {qx.ui.core.Widget} The resize frame
       */
      _getResizeFrame: function _getResizeFrame() {
        var frame = this.__resizeFrame;

        if (!frame) {
          frame = this.__resizeFrame = new qx.ui.core.Widget();
          frame.setAppearance("resize-frame");
          frame.exclude();
          qx.core.Init.getApplication().getRoot().add(frame);
        }

        return frame;
      },

      /**
       * Creates, shows and syncs the frame with the widget.
       */
      __showResizeFrame: function __showResizeFrame() {
        var location = this.getContentLocation();

        var frame = this._getResizeFrame();

        frame.setUserBounds(location.left, location.top, location.right - location.left, location.bottom - location.top);
        frame.show();
        frame.setZIndex(this.getZIndex() + 1);
      },

      /*
      ---------------------------------------------------------------------------
        RESIZE SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Computes the new boundaries at each interval
       * of the resize sequence.
       *
       * @param e {qx.event.type.Pointer} Last pointer event
       * @return {Map} A map with the computed boundaries
       */
      __computeResizeResult: function __computeResizeResult(e) {
        // Detect mode
        var resizeActive = this.__resizeActive; // Read size hint

        var hint = this.getSizeHint();
        var range = this.__resizeRange; // Read original values

        var start = this.__resizeStart;
        var width = start.width;
        var height = start.height;
        var left = start.left;
        var top = start.top;
        var diff;

        if (resizeActive & this.RESIZE_TOP || resizeActive & this.RESIZE_BOTTOM) {
          diff = Math.max(range.top, Math.min(range.bottom, e.getDocumentTop())) - this.__resizeTop;

          if (resizeActive & this.RESIZE_TOP) {
            height -= diff;
          } else {
            height += diff;
          }

          if (height < hint.minHeight) {
            height = hint.minHeight;
          } else if (height > hint.maxHeight) {
            height = hint.maxHeight;
          }

          if (resizeActive & this.RESIZE_TOP) {
            top += start.height - height;
          }
        }

        if (resizeActive & this.RESIZE_LEFT || resizeActive & this.RESIZE_RIGHT) {
          diff = Math.max(range.left, Math.min(range.right, e.getDocumentLeft())) - this.__resizeLeft;

          if (resizeActive & this.RESIZE_LEFT) {
            width -= diff;
          } else {
            width += diff;
          }

          if (width < hint.minWidth) {
            width = hint.minWidth;
          } else if (width > hint.maxWidth) {
            width = hint.maxWidth;
          }

          if (resizeActive & this.RESIZE_LEFT) {
            left += start.width - width;
          }
        }

        return {
          // left and top of the visible widget
          viewportLeft: left,
          viewportTop: top,
          parentLeft: start.bounds.left + left - start.left,
          parentTop: start.bounds.top + top - start.top,
          // dimensions of the visible widget
          width: width,
          height: height
        };
      },

      /**
       * @type {Map} Maps internal states to cursor symbols to use
       *
       * @lint ignoreReferenceField(__resizeCursors)
       */
      __resizeCursors: {
        1: "n-resize",
        2: "s-resize",
        4: "w-resize",
        8: "e-resize",
        5: "nw-resize",
        6: "sw-resize",
        9: "ne-resize",
        10: "se-resize"
      },

      /**
       * Updates the internally stored resize mode
       *
       * @param e {qx.event.type.Pointer} Last pointer event
       */
      __computeResizeMode: function __computeResizeMode(e) {
        var location = this.getContentLocation();
        var pointerTolerance = this.getResizeSensitivity();
        var pointerLeft = e.getDocumentLeft();
        var pointerTop = e.getDocumentTop();

        var resizeActive = this.__computeResizeActive(location, pointerLeft, pointerTop, pointerTolerance); // check again in case we have a corner [BUG #1200]


        if (resizeActive > 0) {
          // this is really a | (or)!
          resizeActive = resizeActive | this.__computeResizeActive(location, pointerLeft, pointerTop, pointerTolerance * 2);
        }

        this.__resizeActive = resizeActive;
      },

      /**
       * Internal helper for computing the proper resize action based on the
       * given parameters.
       *
       * @param location {Map} The current location of the widget.
       * @param pointerLeft {Integer} The left position of the pointer.
       * @param pointerTop {Integer} The top position of the pointer.
       * @param pointerTolerance {Integer} The desired distance to the edge.
       * @return {Integer} The resize active number.
       */
      __computeResizeActive: function __computeResizeActive(location, pointerLeft, pointerTop, pointerTolerance) {
        var resizeActive = 0; // TOP

        if (this.getResizableTop() && Math.abs(location.top - pointerTop) < pointerTolerance && pointerLeft > location.left - pointerTolerance && pointerLeft < location.right + pointerTolerance) {
          resizeActive += this.RESIZE_TOP; // BOTTOM
        } else if (this.getResizableBottom() && Math.abs(location.bottom - pointerTop) < pointerTolerance && pointerLeft > location.left - pointerTolerance && pointerLeft < location.right + pointerTolerance) {
          resizeActive += this.RESIZE_BOTTOM;
        } // LEFT


        if (this.getResizableLeft() && Math.abs(location.left - pointerLeft) < pointerTolerance && pointerTop > location.top - pointerTolerance && pointerTop < location.bottom + pointerTolerance) {
          resizeActive += this.RESIZE_LEFT; // RIGHT
        } else if (this.getResizableRight() && Math.abs(location.right - pointerLeft) < pointerTolerance && pointerTop > location.top - pointerTolerance && pointerTop < location.bottom + pointerTolerance) {
          resizeActive += this.RESIZE_RIGHT;
        }

        return resizeActive;
      },

      /*
      ---------------------------------------------------------------------------
        RESIZE EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the pointer down event
       *
       * @param e {qx.event.type.Pointer} The pointer event instance
       */
      __onResizePointerDown: function __onResizePointerDown(e) {
        // Check for active resize
        if (!this.__resizeActive || !this.getEnabled() || e.getPointerType() == "touch") {
          return;
        } // Add resize state


        this.addState("resize"); // Store pointer coordinates

        this.__resizeLeft = e.getDocumentLeft();
        this.__resizeTop = e.getDocumentTop(); // Cache bounds

        var location = this.getContentLocation();
        var bounds = this.getBounds();
        this.__resizeStart = {
          top: location.top,
          left: location.left,
          width: location.right - location.left,
          height: location.bottom - location.top,
          bounds: qx.lang.Object.clone(bounds)
        }; // Compute range

        var parent = this.getLayoutParent();
        var parentLocation = parent.getContentLocation();
        var parentBounds = parent.getBounds();
        this.__resizeRange = {
          left: parentLocation.left,
          top: parentLocation.top,
          right: parentLocation.left + parentBounds.width,
          bottom: parentLocation.top + parentBounds.height
        }; // Show frame if configured this way

        if (this.getUseResizeFrame()) {
          this.__showResizeFrame();
        } // Enable capturing


        this.capture(); // Stop event

        e.stop();
      },

      /**
       * Event handler for the pointer up event
       *
       * @param e {qx.event.type.Pointer} The pointer event instance
       */
      __onResizePointerUp: function __onResizePointerUp(e) {
        // Check for active resize
        if (!this.hasState("resize") || !this.getEnabled() || e.getPointerType() == "touch") {
          return;
        } // Hide frame afterwards


        if (this.getUseResizeFrame()) {
          this._getResizeFrame().exclude();
        } // Compute bounds


        var bounds = this.__computeResizeResult(e); // Sync with widget


        this.setWidth(bounds.width);
        this.setHeight(bounds.height); // Update coordinate in canvas

        if (this.getResizableLeft() || this.getResizableTop()) {
          this.setLayoutProperties({
            left: bounds.parentLeft,
            top: bounds.parentTop
          });
        } // Clear mode


        this.__resizeActive = 0; // Remove resize state

        this.removeState("resize"); // Reset cursor

        this.resetCursor();
        this.getApplicationRoot().resetGlobalCursor(); // Disable capturing

        this.releaseCapture();
        e.stopPropagation();
      },

      /**
       * Event listener for <code>losecapture</code> event.
       *
       * @param e {qx.event.type.Event} Lose capture event
       */
      __onResizeLoseCapture: function __onResizeLoseCapture(e) {
        // Check for active resize
        if (!this.__resizeActive) {
          return;
        } // Reset cursor


        this.resetCursor();
        this.getApplicationRoot().resetGlobalCursor(); // Remove drag state

        this.removeState("move"); // Hide frame afterwards

        if (this.getUseResizeFrame()) {
          this._getResizeFrame().exclude();
        }
      },

      /**
       * Event handler for the pointer move event
       *
       * @param e {qx.event.type.Pointer} The pointer event instance
       */
      __onResizePointerMove: function __onResizePointerMove(e) {
        if (!this.getEnabled() || e.getPointerType() == "touch") {
          return;
        }

        if (this.hasState("resize")) {
          var bounds = this.__computeResizeResult(e); // Update widget


          if (this.getUseResizeFrame()) {
            // Sync new bounds to frame
            var frame = this._getResizeFrame();

            frame.setUserBounds(bounds.viewportLeft, bounds.viewportTop, bounds.width, bounds.height);
          } else {
            // Update size
            this.setWidth(bounds.width);
            this.setHeight(bounds.height); // Update coordinate in canvas

            if (this.getResizableLeft() || this.getResizableTop()) {
              this.setLayoutProperties({
                left: bounds.parentLeft,
                top: bounds.parentTop
              });
            }
          } // Full stop for event


          e.stopPropagation();
        } else if (!this.hasState("maximized") && !this.__dragDropHandler.isSessionActive()) {
          this.__computeResizeMode(e);

          var resizeActive = this.__resizeActive;
          var root = this.getApplicationRoot();

          if (resizeActive) {
            var cursor = this.__resizeCursors[resizeActive];
            this.setCursor(cursor);
            root.setGlobalCursor(cursor);
          } else if (this.getCursor()) {
            this.resetCursor();
            root.resetGlobalCursor();
          }
        }
      },

      /**
       * Event handler for the pointer out event
       *
       * @param e {qx.event.type.Pointer} The pointer event instance
       */
      __onResizePointerOut: function __onResizePointerOut(e) {
        if (e.getPointerType() == "touch") {
          return;
        } // When the pointer left the window and resizing is not yet
        // active we must be sure to (especially) reset the global
        // cursor.


        if (this.getCursor() && !this.hasState("resize")) {
          this.resetCursor();
          this.getApplicationRoot().resetGlobalCursor();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this.getCursor()) {
        this.getApplicationRoot().resetGlobalCursor();
      }

      if (this.__resizeFrame != null && !qx.core.ObjectRegistry.inShutDown) {
        this.__resizeFrame.destroy();

        this.__resizeFrame = null;
      }

      this.__dragDropHandler = null;
    }
  });
  qx.ui.core.MResizable.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "require": true
      },
      "qx.ui.core.MResizable": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * David Perez (david-perez)
  
  ************************************************************************ */

  /**
   * The Resizer is a resizable container widget.
   *
   * It allows to be resized (not moved), normally in
   * the right and/or bottom directions. It is an alternative to splitters.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var resizer = new qx.ui.container.Resizer().set({
   *     width: 200,
   *     height: 100
   *   });
   *
   *   resizer.setLayout(new qx.ui.layout.Canvas());
   *   var text = new qx.ui.form.TextArea("Resize me\nI'm resizable");
   *   resizer.add(text, {edge: 0});
   *
   *   this.getRoot().add(resizer);
   * </pre>
   *
   * This example creates a resizer, configures it with a canvas layout and
   * adds a text area to it.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/resizer.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.container.Resizer", {
    extend: qx.ui.container.Composite,
    include: qx.ui.core.MResizable,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "resizer"
      }
    }
  });
  qx.ui.container.Resizer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.scroll.AbstractScrollArea": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Container, which allows vertical and horizontal scrolling if the contents is
   * larger than the container.
   *
   * Note that this class can only have one child widget. This container has a
   * fixed layout, which cannot be changed.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // create scroll container
   *   var scroll = new qx.ui.container.Scroll().set({
   *     width: 300,
   *     height: 200
   *   });
   *
   *   // add a widget which is larger than the container
   *   scroll.add(new qx.ui.core.Widget().set({
   *     width: 600,
   *     minWidth: 600,
   *     height: 400,
   *     minHeight: 400
   *   }));
   *
   *   this.getRoot().add(scroll);
   * </pre>
   *
   * This example creates a scroll container and adds a widget, which is larger
   * than the container. This will cause the container to display vertical
   * and horizontal toolbars.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/scroll.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.container.Scroll", {
    extend: qx.ui.core.scroll.AbstractScrollArea,
    include: [qx.ui.core.MContentPadding],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param content {qx.ui.core.LayoutItem?null} The content widget of the scroll
     *    container.
     */
    construct: function construct(content) {
      qx.ui.core.scroll.AbstractScrollArea.constructor.call(this);

      if (content) {
        this.add(content);
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Sets the content of the scroll container. Scroll containers
       * may only have one child, so it always replaces the current
       * child with the given one.
       *
       * @param widget {qx.ui.core.Widget} Widget to insert
       */
      add: function add(widget) {
        this.getChildControl("pane").add(widget);
      },

      /**
       * Returns the content of the scroll area.
       *
       * @param widget {qx.ui.core.Widget} Widget to remove
       */
      remove: function remove(widget) {
        this.getChildControl("pane").remove(widget);
      },

      /**
       * Returns the content of the scroll container.
       *
       * Scroll containers may only have one child. This
       * method returns an array containing the child or an empty array.
       *
       * @return {Object[]} The child array
       */
      getChildren: function getChildren() {
        return this.getChildControl("pane").getChildren();
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getChildControl("pane");
      }
    }
  });
  qx.ui.container.Scroll.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This mixin redirects the layout manager to a child widget of the
   * including class. This is e.g. used in {@link qx.ui.window.Window} to configure
   * the layout manager of the window pane instead of the window directly.
   *
   * The including class must implement the method <code>getChildrenContainer</code>,
   * which has to return the widget, to which the layout should be set.
   */
  qx.Mixin.define("qx.ui.core.MRemoteLayoutHandling", {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Set a layout manager for the widget. A a layout manager can only be connected
       * with one widget. Reset the connection with a previous widget first, if you
       * like to use it in another widget instead.
       *
       * @param layout {qx.ui.layout.Abstract} The new layout or
       *     <code>null</code> to reset the layout.
       */
      setLayout: function setLayout(layout) {
        this.getChildrenContainer().setLayout(layout);
      },

      /**
       * Get the widget's layout manager.
       *
       * @return {qx.ui.layout.Abstract} The widget's layout manager
       */
      getLayout: function getLayout() {
        return this.getChildrenContainer().getLayout();
      }
    }
  });
  qx.ui.core.MRemoteLayoutHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.core.MRemoteLayoutHandling": {
        "require": true
      },
      "qx.ui.form.RepeatButton": {},
      "qx.ui.container.Composite": {},
      "qx.ui.core.scroll.ScrollPane": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.layout.VBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Container, which provides scrolling in one dimension (vertical or horizontal).
   *
   * @childControl button-forward {qx.ui.form.RepeatButton} button to step forward
   * @childControl button-backward {qx.ui.form.RepeatButton} button to step backward
   * @childControl content {qx.ui.container.Composite} container to hold the content
   * @childControl scrollpane {qx.ui.core.scroll.ScrollPane} the scroll pane holds the content to enable scrolling
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // create slide bar container
   *   slideBar = new qx.ui.container.SlideBar().set({
   *     width: 300
   *   });
   *
   *   // set layout
   *   slideBar.setLayout(new qx.ui.layout.HBox());
   *
   *   // add some widgets
   *   for (var i=0; i<10; i++)
   *   {
   *     slideBar.add((new qx.ui.core.Widget()).set({
   *       backgroundColor : (i % 2 == 0) ? "red" : "blue",
   *       width : 60
   *     }));
   *   }
   *
   *   this.getRoot().add(slideBar);
   * </pre>
   *
   * This example creates a SlideBar and add some widgets with alternating
   * background colors. Since the content is larger than the container, two
   * scroll buttons at the left and the right edge are shown.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/slidebar.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.container.SlideBar", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.core.MRemoteLayoutHandling],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param orientation {String?"horizontal"} The slide bar orientation
     */
    construct: function construct(orientation) {
      qx.ui.core.Widget.constructor.call(this);
      var scrollPane = this.getChildControl("scrollpane");

      this._add(scrollPane, {
        flex: 1
      });

      if (orientation != null) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      }

      this.addListener("roll", this._onRoll, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "slidebar"
      },

      /** Orientation of the bar */
      orientation: {
        check: ["horizontal", "vertical"],
        init: "horizontal",
        apply: "_applyOrientation"
      },

      /** The number of pixels to scroll if the buttons are pressed */
      scrollStep: {
        check: "Integer",
        init: 15,
        themeable: true
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired on scroll animation end invoked by 'scroll*' methods. */
      scrollAnimationEnd: "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("content");
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "button-forward":
            control = new qx.ui.form.RepeatButton();
            control.addListener("execute", this._onExecuteForward, this);
            control.setFocusable(false);

            this._addAt(control, 2);

            break;

          case "button-backward":
            control = new qx.ui.form.RepeatButton();
            control.addListener("execute", this._onExecuteBackward, this);
            control.setFocusable(false);

            this._addAt(control, 0);

            break;

          case "content":
            control = new qx.ui.container.Composite();
            this.getChildControl("scrollpane").add(control);
            break;

          case "scrollpane":
            control = new qx.ui.core.scroll.ScrollPane();
            control.addListener("update", this._onResize, this);
            control.addListener("scrollX", this._onScroll, this);
            control.addListener("scrollY", this._onScroll, this);
            control.addListener("scrollAnimationEnd", this._onScrollAnimationEnd, this);
            break;
        }

        return control || qx.ui.container.SlideBar.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        barLeft: true,
        barTop: true,
        barRight: true,
        barBottom: true
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC SCROLL API
      ---------------------------------------------------------------------------
      */

      /**
       * Scrolls the element's content by the given amount.
       *
       * @param offset {Integer?0} Amount to scroll
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollBy: function scrollBy(offset, duration) {
        var pane = this.getChildControl("scrollpane");

        if (this.getOrientation() === "horizontal") {
          pane.scrollByX(offset, duration);
        } else {
          pane.scrollByY(offset, duration);
        }
      },

      /**
       * Scrolls the element's content to the given coordinate
       *
       * @param value {Integer} The position to scroll to.
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollTo: function scrollTo(value, duration) {
        var pane = this.getChildControl("scrollpane");

        if (this.getOrientation() === "horizontal") {
          pane.scrollToX(value, duration);
        } else {
          pane.scrollToY(value, duration);
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyEnabled: function _applyEnabled(value, old, name) {
        qx.ui.container.SlideBar.prototype._applyEnabled.base.call(this, value, old, name);

        this._updateArrowsEnabled();
      },
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        var oldLayouts = [this.getLayout(), this._getLayout()];
        var buttonForward = this.getChildControl("button-forward");
        var buttonBackward = this.getChildControl("button-backward"); // old can also be null, so we have to check both explicitly to set
        // the states correctly.

        if (old == "vertical" && value == "horizontal") {
          buttonForward.removeState("vertical");
          buttonBackward.removeState("vertical");
          buttonForward.addState("horizontal");
          buttonBackward.addState("horizontal");
        } else if (old == "horizontal" && value == "vertical") {
          buttonForward.removeState("horizontal");
          buttonBackward.removeState("horizontal");
          buttonForward.addState("vertical");
          buttonBackward.addState("vertical");
        }

        if (value == "horizontal") {
          this._setLayout(new qx.ui.layout.HBox());

          this.setLayout(new qx.ui.layout.HBox());
        } else {
          this._setLayout(new qx.ui.layout.VBox());

          this.setLayout(new qx.ui.layout.VBox());
        }

        if (oldLayouts[0]) {
          oldLayouts[0].dispose();
        }

        if (oldLayouts[1]) {
          oldLayouts[1].dispose();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Scrolls pane on roll events
       *
       * @param e {qx.event.type.Roll} the roll event
       */
      _onRoll: function _onRoll(e) {
        // only wheel and touch
        if (e.getPointerType() == "mouse") {
          return;
        }

        var delta = 0;
        var pane = this.getChildControl("scrollpane");

        if (this.getOrientation() === "horizontal") {
          delta = e.getDelta().x;
          var position = pane.getScrollX();
          var max = pane.getScrollMaxX();
          var steps = parseInt(delta); // pass the event to the parent if both scrollbars are at the end

          if (!(steps < 0 && position <= 0 || steps > 0 && position >= max || delta == 0)) {
            e.stop();
          } else {
            e.stopMomentum();
          }
        } else {
          delta = e.getDelta().y;
          var position = pane.getScrollY();
          var max = pane.getScrollMaxY();
          var steps = parseInt(delta); // pass the event to the parent if both scrollbars are at the end

          if (!(steps < 0 && position <= 0 || steps > 0 && position >= max || delta == 0)) {
            e.stop();
          } else {
            e.stopMomentum();
          }
        }

        this.scrollBy(parseInt(delta, 10)); // block all momentum scrolling

        if (e.getMomentum()) {
          e.stop();
        }
      },

      /**
       * Update arrow enabled state after scrolling
       */
      _onScroll: function _onScroll() {
        this._updateArrowsEnabled();
      },

      /**
       * Handler to fire the 'scrollAnimationEnd' event.
       */
      _onScrollAnimationEnd: function _onScrollAnimationEnd() {
        this.fireEvent("scrollAnimationEnd");
      },

      /**
       * Listener for resize event. This event is fired after the
       * first flush of the element which leads to another queuing
       * when the changes modify the visibility of the scroll buttons.
       *
       * @param e {Event} Event object
       */
      _onResize: function _onResize(e) {
        var content = this.getChildControl("scrollpane").getChildren()[0];

        if (!content) {
          return;
        }

        var innerSize = this.getInnerSize();
        var contentSize = content.getBounds();
        var overflow = this.getOrientation() === "horizontal" ? contentSize.width > innerSize.width : contentSize.height > innerSize.height;

        if (overflow) {
          this._showArrows();

          this._updateArrowsEnabled();
        } else {
          this._hideArrows();
        }
      },

      /**
       * Scroll handler for left scrolling
       *
       */
      _onExecuteBackward: function _onExecuteBackward() {
        this.scrollBy(-this.getScrollStep());
      },

      /**
       * Scroll handler for right scrolling
       *
       */
      _onExecuteForward: function _onExecuteForward() {
        this.scrollBy(this.getScrollStep());
      },

      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */

      /**
       * Update arrow enabled state
       */
      _updateArrowsEnabled: function _updateArrowsEnabled() {
        // set the disables state directly because we are overriding the
        // inheritance
        if (!this.getEnabled()) {
          this.getChildControl("button-backward").setEnabled(false);
          this.getChildControl("button-forward").setEnabled(false);
          return;
        }

        var pane = this.getChildControl("scrollpane");

        if (this.getOrientation() === "horizontal") {
          var position = pane.getScrollX();
          var max = pane.getScrollMaxX();
        } else {
          var position = pane.getScrollY();
          var max = pane.getScrollMaxY();
        }

        this.getChildControl("button-backward").setEnabled(position > 0);
        this.getChildControl("button-forward").setEnabled(position < max);
      },

      /**
       * Show the arrows (Called from resize event)
       *
       */
      _showArrows: function _showArrows() {
        this._showChildControl("button-forward");

        this._showChildControl("button-backward");
      },

      /**
       * Hide the arrows (Called from resize event)
       *
       */
      _hideArrows: function _hideArrows() {
        this._excludeChildControl("button-forward");

        this._excludeChildControl("button-backward");

        this.scrollTo(0);
      }
    }
  });
  qx.ui.container.SlideBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.core.ISingleSelection": {
        "require": true
      },
      "qx.ui.core.MSingleSelectionHandling": {
        "require": true
      },
      "qx.ui.core.MChildrenHandling": {
        "require": true
      },
      "qx.ui.layout.Grow": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */

  /**
   * The stack container puts its child widgets on top of each other and only the
   * topmost widget is visible.
   *
   * This is used e.g. in the tab view widget. Which widget is visible can be
   * controlled by using the {@link #getSelection} method.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // create stack container
   *   var stack = new qx.ui.container.Stack();
   *
   *   // add some children
   *   stack.add(new qx.ui.core.Widget().set({
   *    backgroundColor: "red"
   *   }));
   *   stack.add(new qx.ui.core.Widget().set({
   *    backgroundColor: "green"
   *   }));
   *   stack.add(new qx.ui.core.Widget().set({
   *    backgroundColor: "blue"
   *   }));
   *
   *   // select green widget
   *   stack.setSelection([stack.getChildren()[1]]);
   *
   *   this.getRoot().add(stack);
   * </pre>
   *
   * This example creates an stack with three children. Only the selected "green"
   * widget is visible.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/stack.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.container.Stack", {
    extend: qx.ui.core.Widget,
    implement: [qx.ui.form.IField, qx.ui.core.ISingleSelection],
    include: [qx.ui.core.MSingleSelectionHandling, qx.ui.core.MChildrenHandling],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this);

      this._setLayout(new qx.ui.layout.Grow());

      this.addListener("changeSelection", this.__onChangeSelection, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether the size of the widget depends on the selected child. When
       * disabled (default) the size is configured to the largest child.
       */
      dynamic: {
        check: "Boolean",
        init: false,
        apply: "_applyDynamic"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // property apply
      _applyDynamic: function _applyDynamic(value) {
        var children = this._getChildren();

        var selected = this.getSelection()[0];
        var child;

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (child != selected) {
            if (value) {
              children[i].exclude();
            } else {
              children[i].hide();
            }
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS FOR SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the widget for the selection.
       * @return {qx.ui.core.Widget[]} Widgets to select.
       */
      _getItems: function _getItems() {
        return this.getChildren();
      },

      /**
       * Returns if the selection could be empty or not.
       *
       * @return {Boolean} <code>true</code> If selection could be empty,
       *    <code>false</code> otherwise.
       */
      _isAllowEmptySelection: function _isAllowEmptySelection() {
        return true;
      },

      /**
       * Returns whether the given item is selectable.
       *
       * @param item {qx.ui.core.Widget} The item to be checked
       * @return {Boolean} Whether the given item is selectable
       */
      _isItemSelectable: function _isItemSelectable(item) {
        return true;
      },

      /**
       * Event handler for <code>changeSelection</code>.
       *
       * Shows the new selected widget and hide the old one.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      __onChangeSelection: function __onChangeSelection(e) {
        var old = e.getOldData()[0];
        var value = e.getData()[0];

        if (old) {
          if (this.isDynamic()) {
            old.exclude();
          } else {
            old.hide();
          }
        }

        if (value) {
          value.show();
        }
      },
      //overridden
      _afterAddChild: function _afterAddChild(child) {
        var selected = this.getSelection()[0];

        if (!selected) {
          this.setSelection([child]);
        } else if (selected !== child) {
          if (this.isDynamic()) {
            child.exclude();
          } else {
            child.hide();
          }
        }
      },
      //overridden
      _afterRemoveChild: function _afterRemoveChild(child) {
        if (this.getSelection()[0] === child) {
          var first = this._getChildren()[0];

          if (first) {
            this.setSelection([first]);
          } else {
            this.resetSelection();
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Go to the previous child in the children list.
       */
      previous: function previous() {
        var selected = this.getSelection()[0];
        var go = this._indexOf(selected) - 1;

        var children = this._getChildren();

        if (go < 0) {
          go = children.length - 1;
        }

        var prev = children[go];
        this.setSelection([prev]);
      },

      /**
       * Go to the next child in the children list.
       */
      next: function next() {
        var selected = this.getSelection()[0];
        var go = this._indexOf(selected) + 1;

        var children = this._getChildren();

        var next = children[go] || children[0];
        this.setSelection([next]);
      }
    }
  });
  qx.ui.container.Stack.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which have boolean as their primary
   * data type like a colorchooser.
   */
  qx.Interface.define("qx.ui.form.IColorForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {Color|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {Color|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.IColorForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IColorForm": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.groupbox.GroupBox": {},
      "qx.ui.layout.Canvas": {},
      "qx.ui.basic.Image": {},
      "qx.ui.layout.Grow": {},
      "qx.ui.layout.Grid": {},
      "qx.ui.basic.Label": {},
      "qx.ui.form.TextField": {},
      "qx.ui.form.Spinner": {},
      "qx.util.ColorUtil": {},
      "qx.lang.Number": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
       * Matthew Gregory
  
  ************************************************************************ */

  /**
   * A typical color selector as known from native applications.
   *
   * Includes support for RGB and HSB color areas.
   *
   * @childControl control-bar {qx.ui.container.Composite} container which holds the control-pane and visual-pane
   * @childControl visual-pane {qx.ui.groupbox.GroupBox} pane shows the hue-saturation-pane and the brightness-pane
   * @childControl hue-saturation-pane {qx.ui.container.Composite} shows the hue saturation and the handle to select
   * @childControl hue-saturation-field {qx.ui.basic.Image} hue saturation image which shows all available colors
   * @childControl hue-saturation-handle {qx.ui.basic.Image} handle to select the color using the pointer
   * @childControl brightness-pane {qx.ui.container.Composite} shows the brightness field and the handle to select
   * @childControl brightness-field {qx.ui.basic.Image} brightness image which shows all brightness steps
   * @childControl brightness-handle {qx.ui.basic.Image} brightness handle to select the brightness using the pointer
   * @childControl preset-field-set {qx.ui.groupbox.GroupBox} groupbox holding all preset colors
   * @childControl colorbucket {qx.ui.core.Widget} color bucket
   * @childControl preset-grid {qx.ui.container.Composite} container for all color presets
   * @childControl input-field-set {qx.ui.groupbox.GroupBox} groupbox holding different input elements
   * @childControl preview-field-set {qx.ui.groupbox.GroupBox} groupbox holding the two preview fields
   * @childControl hex-field-composite {qx.ui.container.Composite} container for the hex field
   * @childControl hex-field {qx.ui.form.TextField} textfield to input a hex value
   * @childControl rgb-spinner-composite {qx.ui.container.Composite} container for the rgb spinner
   * @childControl rgb-spinner-red {qx.ui.form.Spinner} spinner control for the red hex value
   * @childControl rgb-spinner-green {qx.ui.form.Spinner} spinner control for the green hex value
   * @childControl rgb-spinner-blue {qx.ui.form.Spinner} spinner control for the blue hex value
   * @childControl hsb-spinner-composite {qx.ui.container.Composite} container for the hsb spinners
   * @childControl hsb-spinner-hue {qx.ui.form.Spinner} spinner control for the huevalue
   * @childControl hsb-spinner-saturation {qx.ui.form.Spinner} spinner control for the saturation value
   * @childControl hsb-spinner-brightness {qx.ui.form.Spinner} spinner control for the brightness value
   * @childControl preview-content-old {qx.ui.core.Widget} preview of the old color
   * @childControl preview-content-new {qx.ui.core.Widget} preview of the new color
   */
  qx.Class.define("qx.ui.control.ColorSelector", {
    extend: qx.ui.core.Widget,
    implement: [qx.ui.form.IColorForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Creates a ColorSelector.
     */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // add the basic layout

      this._setLayout(new qx.ui.layout.VBox());

      this._createChildControl("control-bar");

      this.addListener("appear", this._onAppear, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the "OK" button is tapped. */
      "dialogok": "qx.event.type.Event",

      /** Fired when the "Cancel" button is tapped. */
      "dialogcancel": "qx.event.type.Event",

      /** Fired when the value changes */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "colorselector"
      },

      /** The numeric red value of the selected color. */
      red: {
        check: "Integer",
        init: 255,
        apply: "_applyRed"
      },

      /** The numeric green value of the selected color. */
      green: {
        check: "Integer",
        init: 255,
        apply: "_applyGreen"
      },

      /** The numeric blue value of the selected color. */
      blue: {
        check: "Integer",
        init: 255,
        apply: "_applyBlue"
      },

      /** The numeric hue value. */
      hue: {
        check: "Number",
        init: 0,
        apply: "_applyHue"
      },

      /** The numeric saturation value. */
      saturation: {
        check: "Number",
        init: 0,
        apply: "_applySaturation"
      },

      /** The numeric brightness value. */
      brightness: {
        check: "Number",
        init: 100,
        apply: "_applyBrightness"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        CONTEXT HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * @type {String} The context in which an update has occurred.
       */
      __updateContext: null,

      /**
       * @type {Array} Map containing the preset colors.
       * @lint ignoreReferenceField(__presetTable)
       */
      __presetTable: ["maroon", "red", "orange", "yellow", "olive", "purple", "fuchsia", "lime", "green", "navy", "blue", "aqua", "teal", "black", "#333", "#666", "#999", "#BBB", "#EEE", "white"],

      /**
       * @type {String} Name of child control which is captured.
       */
      __capture: "",

      /**
       * @type {Number} Numeric brightness value
       */
      __brightnessSubtract: 0,

      /**
       * @type {Integer} HueSaturation's X coordinate
       */
      __hueSaturationSubtractTop: 0,

      /**
       * @type {Integer} HueSaturation's Y coordinate
       */
      __hueSaturationSubtractLeft: 0,
      // internal boolean flag to signal, that the value is set to null
      __nullValue: true,
      // internal mutex to prevent the changeValue event to be fired too often
      __preventChangeValueEvent: false,
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          /*
          ---------------------------------------------------------------------------
            CREATE #1: BASE STRUCTURE
          ---------------------------------------------------------------------------
          */
          case "control-bar":
            control = new qx.ui.container.Composite(new qx.ui.layout.HBox(10));
            control.add(this.getChildControl("control-pane"));
            control.add(this.getChildControl("visual-pane"));

            this._add(control);

            break;

          /*
          ---------------------------------------------------------------------------
            CREATE #2: PANES
          ---------------------------------------------------------------------------
          */

          case "visual-pane":
            control = new qx.ui.groupbox.GroupBox(this.tr("Visual"));
            control.setLayout(new qx.ui.layout.HBox(10));
            control.add(this.getChildControl("hue-saturation-pane"));
            control.add(this.getChildControl("brightness-pane"));
            break;

          case "control-pane":
            control = new qx.ui.container.Composite(new qx.ui.layout.VBox(0));
            control.add(this.getChildControl("preset-field-set"));
            control.add(this.getChildControl("input-field-set"));
            control.add(this.getChildControl("preview-field-set"), {
              flex: 1
            });
            break;

          case "hue-saturation-pane":
            control = new qx.ui.container.Composite(new qx.ui.layout.Canvas());
            control.setAllowGrowY(false);
            control.addListener("roll", this._onHueSaturationPaneRoll, this);
            control.add(this.getChildControl("hue-saturation-field"));
            control.add(this.getChildControl("hue-saturation-handle"), {
              left: 0,
              top: 256
            });
            break;

          case "hue-saturation-field":
            control = new qx.ui.basic.Image("decoration/colorselector/huesaturation-field.jpg");
            control.addListener("pointerdown", this._onHueSaturationFieldPointerDown, this);
            break;

          case "hue-saturation-handle":
            control = new qx.ui.basic.Image("decoration/colorselector/huesaturation-handle.gif");
            control.addListener("pointerdown", this._onHueSaturationFieldPointerDown, this);
            control.addListener("pointerup", this._onHueSaturationHandlePointerUp, this);
            control.addListener("pointermove", this._onHueSaturationHandlePointerMove, this);
            break;

          case "brightness-pane":
            control = new qx.ui.container.Composite(new qx.ui.layout.Canvas());
            control.setAllowGrowY(false);
            control.addListener("roll", this._onBrightnessPaneRoll, this);
            control.add(this.getChildControl("brightness-field"));
            control.add(this.getChildControl("brightness-handle"));
            break;

          case "brightness-field":
            control = new qx.ui.basic.Image("decoration/colorselector/brightness-field.png");
            control.addListener("pointerdown", this._onBrightnessFieldPointerDown, this);
            break;

          case "brightness-handle":
            control = new qx.ui.basic.Image("decoration/colorselector/brightness-handle.gif");
            control.addListener("pointerdown", this._onBrightnessHandlePointerDown, this);
            control.addListener("pointerup", this._onBrightnessHandlePointerUp, this);
            control.addListener("pointermove", this._onBrightnessHandlePointerMove, this);
            break;

          /*
          ---------------------------------------------------------------------------
            CREATE #3: CONTROL PANE CONTENT
          ---------------------------------------------------------------------------
          */

          case "preset-field-set":
            control = new qx.ui.groupbox.GroupBox(this.tr("Presets"));
            control.setLayout(new qx.ui.layout.Grow());
            control.add(this.getChildControl("preset-grid"));
            break;

          case "colorbucket":
            control = new qx.ui.core.Widget();
            control.addListener("pointerdown", this._onColorFieldTap, this);
            break;

          case "preset-grid":
            controlLayout = new qx.ui.layout.Grid(3, 3);
            control = new qx.ui.container.Composite(controlLayout);
            var colorField;
            var colorPos;

            for (var i = 0; i < 2; i++) {
              for (var j = 0; j < 10; j++) {
                colorPos = i * 10 + j;
                colorField = this.getChildControl("colorbucket#" + colorPos);
                colorField.setBackgroundColor(this.__presetTable[colorPos]);
                control.add(colorField, {
                  column: j,
                  row: i
                });
              }
            }

            break;

          case "input-field-set":
            control = new qx.ui.groupbox.GroupBox(this.tr("Details"));
            var controlLayout = new qx.ui.layout.VBox();
            controlLayout.setSpacing(10);
            control.setLayout(controlLayout);
            control.add(this.getChildControl("hex-field-composite"));
            control.add(this.getChildControl("rgb-spinner-composite"));
            control.add(this.getChildControl("hsb-spinner-composite"));
            break;

          case "preview-field-set":
            control = new qx.ui.groupbox.GroupBox(this.tr("Preview (Old/New)"));
            var controlLayout = new qx.ui.layout.HBox(10);
            control.setLayout(controlLayout);
            control.add(this.getChildControl("preview-content-old"), {
              flex: 1
            });
            control.add(this.getChildControl("preview-content-new"), {
              flex: 1
            });
            break;

          /*
          ---------------------------------------------------------------------------
            CREATE #4: INPUT FIELDSET CONTENT
          ---------------------------------------------------------------------------
          */

          case "hex-field-composite":
            var layout = new qx.ui.layout.HBox(4);
            layout.setAlignY("middle");
            control = new qx.ui.container.Composite(layout);
            var hexLabel = new qx.ui.basic.Label(this.tr("Hex"));
            hexLabel.setWidth(30);
            control.add(hexLabel);
            var hexHelper = new qx.ui.basic.Label("#");
            control.add(hexHelper);
            control.add(this.getChildControl("hex-field"));
            break;

          case "hex-field":
            control = new qx.ui.form.TextField("FFFFFF");
            control.setMaxLength(6);
            control.setFilter(/[0-9A-Fa-f]/);
            control.setWidth(55);
            control.addListener("changeValue", this._onHexFieldChange, this);
            break;

          case "rgb-spinner-composite":
            var layout = new qx.ui.layout.HBox(4);
            layout.setAlignY("middle");
            control = new qx.ui.container.Composite(layout);
            var rgbSpinLabel = new qx.ui.basic.Label(this.tr("RGB"));
            rgbSpinLabel.setWidth(30);
            control.add(rgbSpinLabel);
            control.add(this.getChildControl("rgb-spinner-red"));
            control.add(this.getChildControl("rgb-spinner-green"));
            control.add(this.getChildControl("rgb-spinner-blue"));
            break;

          case "rgb-spinner-red":
            control = new qx.ui.form.Spinner(0, 255, 255);
            control.setWidth(50);
            control.addListener("changeValue", this._setRedFromSpinner, this);
            break;

          case "rgb-spinner-green":
            control = new qx.ui.form.Spinner(0, 255, 255);
            control.setWidth(50);
            control.addListener("changeValue", this._setGreenFromSpinner, this);
            break;

          case "rgb-spinner-blue":
            control = new qx.ui.form.Spinner(0, 255, 255);
            control.setWidth(50);
            control.addListener("changeValue", this._setBlueFromSpinner, this);
            break;

          case "hsb-spinner-composite":
            var layout = new qx.ui.layout.HBox(4);
            layout.setAlignY("middle");
            control = new qx.ui.container.Composite(layout);
            var hsbSpinLabel = new qx.ui.basic.Label(this.tr("HSB"));
            hsbSpinLabel.setWidth(30);
            control.add(hsbSpinLabel);
            control.add(this.getChildControl("hsb-spinner-hue"));
            control.add(this.getChildControl("hsb-spinner-saturation"));
            control.add(this.getChildControl("hsb-spinner-brightness"));
            break;

          case "hsb-spinner-hue":
            control = new qx.ui.form.Spinner(0, 0, 360);
            control.setWidth(50);
            control.addListener("changeValue", this._setHueFromSpinner, this);
            break;

          case "hsb-spinner-saturation":
            control = new qx.ui.form.Spinner(0, 0, 100);
            control.setWidth(50);
            control.addListener("changeValue", this._setSaturationFromSpinner, this);
            break;

          case "hsb-spinner-brightness":
            control = new qx.ui.form.Spinner(0, 100, 100);
            control.setWidth(50);
            control.addListener("changeValue", this._setBrightnessFromSpinner, this);
            break;

          /*
          ---------------------------------------------------------------------------
            CREATE #5: PREVIEW CONTENT
          ---------------------------------------------------------------------------
          */

          case "preview-content-old":
            control = new qx.ui.core.Widget();
            break;

          case "preview-content-new":
            control = new qx.ui.core.Widget();
            break;
        }

        return control || qx.ui.control.ColorSelector.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * The value of the ColorSelector is a string containing the HEX value of
       * the currently selected color. Take a look at
       * {@link qx.util.ColorUtil#stringToRgb} to see what kind of input the
       * method can handle.
       *
       * @param value {String} The value of a color.
       */
      setValue: function setValue(value) {
        var rgb;

        if (value == null) {
          this.__nullValue = true;
          rgb = [255, 255, 255];
        } else {
          rgb = qx.util.ColorUtil.stringToRgb(value);
          this.__nullValue = false;
        } // block the first tow events


        this.__preventChangeValueEvent = true;
        this.setRed(rgb[0]);
        this.setGreen(rgb[1]); // only allow the final change event

        this.__preventChangeValueEvent = false;
        this.setBlue(rgb[2]);
      },

      /**
       * Returns the currently selected color.
       *
       * @return {String | null} The HEX value of the color of if not color
       *   is set, null.
       */
      getValue: function getValue() {
        return this.__nullValue ? null : qx.util.ColorUtil.rgbToHexString([this.getRed(), this.getGreen(), this.getBlue()]);
      },

      /**
       * Resets the color to null.
       */
      resetValue: function resetValue() {
        this.__nullValue = true;
        this.__preventChangeValueEvent = true;
        this.setRed(255);
        this.setGreen(255);
        this.__preventChangeValueEvent = false;
        this.setBlue(255);
      },

      /**
       * Helper for firing the changeValue event and checking for the mutex.
       */
      __fireChangeValueEvent: function __fireChangeValueEvent() {
        if (!this.__preventChangeValueEvent) {
          this.__nullValue = false;
          this.fireDataEvent("changeValue", this.getValue());
        }
      },

      /*
      ---------------------------------------------------------------------------
        RGB MODIFIER
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyRed: function _applyRed(value, old) {
        if (this.__updateContext === null) {
          this.__updateContext = "redModifier";
        }

        if (this.__updateContext !== "rgbSpinner") {
          this.getChildControl("rgb-spinner-red").setValue(value);
        }

        if (this.__updateContext !== "hexField") {
          this._setHexFromRgb();
        }

        switch (this.__updateContext) {
          case "rgbSpinner":
          case "hexField":
          case "redModifier":
            this._setHueFromRgb();

        }

        this._setPreviewFromRgb();

        this.__fireChangeValueEvent();

        if (this.__updateContext === "redModifier") {
          this.__updateContext = null;
        }
      },
      // property apply
      _applyGreen: function _applyGreen(value, old) {
        if (this.__updateContext === null) {
          this.__updateContext = "greenModifier";
        }

        if (this.__updateContext !== "rgbSpinner") {
          this.getChildControl("rgb-spinner-green").setValue(value);
        }

        if (this.__updateContext !== "hexField") {
          this._setHexFromRgb();
        }

        switch (this.__updateContext) {
          case "rgbSpinner":
          case "hexField":
          case "greenModifier":
            this._setHueFromRgb();

        }

        this._setPreviewFromRgb();

        this.__fireChangeValueEvent();

        if (this.__updateContext === "greenModifier") {
          this.__updateContext = null;
        }
      },
      // property apply
      _applyBlue: function _applyBlue(value, old) {
        if (this.__updateContext === null) {
          this.__updateContext = "blueModifier";
        }

        if (this.__updateContext !== "rgbSpinner") {
          this.getChildControl("rgb-spinner-blue").setValue(value);
        }

        if (this.__updateContext !== "hexField") {
          this._setHexFromRgb();
        }

        switch (this.__updateContext) {
          case "rgbSpinner":
          case "hexField":
          case "blueModifier":
            this._setHueFromRgb();

        }

        this._setPreviewFromRgb();

        this.__fireChangeValueEvent();

        if (this.__updateContext === "blueModifier") {
          this.__updateContext = null;
        }
      },

      /*
      ---------------------------------------------------------------------------
        HSB MODIFIER
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyHue: function _applyHue(value, old) {
        if (this.__updateContext === null) {
          this.__updateContext = "hueModifier";
        }

        if (this.__updateContext !== "hsbSpinner") {
          this.getChildControl("hsb-spinner-hue").setValue(value);
        }

        if (this.__updateContext !== "hueSaturationField") {
          if (this.getChildControl("hue-saturation-handle").getBounds()) {
            this.getChildControl("hue-saturation-handle").setDomLeft(Math.round(value / 1.40625) + this.getChildControl("hue-saturation-pane").getPaddingLeft());
          } else {
            this.getChildControl("hue-saturation-handle").setLayoutProperties({
              left: Math.round(value / 1.40625)
            });
          }
        }

        switch (this.__updateContext) {
          case "hsbSpinner":
          case "hueSaturationField":
          case "hueModifier":
            this._setRgbFromHue();

        }

        this._setBrightnessGradiant();

        if (this.__updateContext === "hueModifier") {
          this.__updateContext = null;
        }
      },
      // property apply
      _applySaturation: function _applySaturation(value, old) {
        if (this.__updateContext === null) {
          this.__updateContext = "saturationModifier";
        }

        if (this.__updateContext !== "hsbSpinner") {
          this.getChildControl("hsb-spinner-saturation").setValue(value);
        }

        if (this.__updateContext !== "hueSaturationField") {
          this._setBrightnessGradiant();

          if (this.getChildControl("hue-saturation-handle").getBounds()) {
            this.getChildControl("hue-saturation-handle").setDomTop(256 - Math.round(value * 2.56) + this.getChildControl("hue-saturation-pane").getPaddingTop());
          } else {
            this.getChildControl("hue-saturation-handle").setLayoutProperties({
              top: 256 - Math.round(value * 2.56)
            });
          }
        }

        switch (this.__updateContext) {
          case "hsbSpinner":
          case "hueSaturationField":
          case "saturationModifier":
            this._setRgbFromHue();

        }

        if (this.__updateContext === "saturationModifier") {
          this.__updateContext = null;
        }
      },
      // property apply
      _applyBrightness: function _applyBrightness(value, old) {
        if (this.__updateContext === null) {
          this.__updateContext = "brightnessModifier";
        }

        if (this.__updateContext !== "hsbSpinner") {
          this.getChildControl("hsb-spinner-brightness").setValue(value);
        }

        if (this.__updateContext !== "brightnessField") {
          var topValue = 256 - Math.round(value * 2.56);

          if (this.getChildControl("brightness-handle").getBounds()) {
            this.getChildControl("brightness-handle").setDomTop(topValue + this.getChildControl("brightness-pane").getPaddingTop());
          } else {
            this.getChildControl("brightness-handle").setLayoutProperties({
              top: topValue
            });
          }
        }

        switch (this.__updateContext) {
          case "hsbSpinner":
          case "brightnessField":
          case "brightnessModifier":
            this._setRgbFromHue();

        }

        if (this.__updateContext === "brightnessModifier") {
          this.__updateContext = null;
        }
      },

      /*
      ---------------------------------------------------------------------------
        BRIGHTNESS IMPLEMENTATION
      ---------------------------------------------------------------------------
      */

      /**
       * Listener of pointerdown event on the brightness handle.
       * Adjusts the color by changing the brightness.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onBrightnessHandlePointerDown: function _onBrightnessHandlePointerDown(e) {
        // Activate Capturing
        this.getChildControl("brightness-handle").capture();
        this.__capture = "brightness-handle"; // Calculate subtract: Position of Brightness Field - Current Pointer Offset

        var locationBrightnessField = this.getChildControl("brightness-field").getContentLocation();
        var locationBrightnessHandle = this.getChildControl("brightness-handle").getContentLocation();
        var fieldBounds = this.getChildControl("brightness-field").getBounds();
        this.__brightnessSubtract = locationBrightnessField.top + (e.getDocumentTop() - locationBrightnessHandle.top) - fieldBounds.top; // Block field event handling

        e.stopPropagation();
      },

      /**
       * Listener of pointerup event on the brightness handle.
       * Releases the capture.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onBrightnessHandlePointerUp: function _onBrightnessHandlePointerUp(e) {
        // Disabling capturing
        this.getChildControl("brightness-handle").releaseCapture();
        this.__capture = null;
      },

      /**
       * Listener of pointermove event on the brightness handle.
       * Forwards the event to _setBrightnessOnFieldEvent().
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onBrightnessHandlePointerMove: function _onBrightnessHandlePointerMove(e) {
        // Update if captured currently (through previous pointerdown)
        if (this.__capture === "brightness-handle") {
          this._setBrightnessOnFieldEvent(e);

          e.stopPropagation();
        }
      },

      /**
       * Listener of pointerdown event on the brightness field.
       * Adjusts the color by changing the brightness.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onBrightnessFieldPointerDown: function _onBrightnessFieldPointerDown(e) {
        // Calculate substract: Half height of handler
        var location = this.getChildControl("brightness-field").getContentLocation();
        var bounds = this.getChildControl("brightness-handle").getBounds();
        this.__brightnessSubtract = location.top + bounds.height / 2; // Update

        this._setBrightnessOnFieldEvent(e); // Afterwards: Activate Capturing for handle


        this.getChildControl("brightness-handle").capture();
        this.__capture = "brightness-handle";
      },

      /**
       * Listener of roll event on the brightness pane.
       * Adjusts the color by changing the brightness.
       *
       * @param e {qx.event.type.Roll} Incoming event object
       */
      _onBrightnessPaneRoll: function _onBrightnessPaneRoll(e) {
        e.stop(); // only wheel

        if (e.getPointerType() != "wheel") {
          return;
        }

        this.setBrightness(qx.lang.Number.limit(this.getBrightness() - e.getDelta().y / 10, 0, 100));
      },

      /**
       * Sets the brightness and moves the brightness handle.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _setBrightnessOnFieldEvent: function _setBrightnessOnFieldEvent(e) {
        var value = qx.lang.Number.limit(e.getDocumentTop() - this.__brightnessSubtract, 0, 256);
        this.__updateContext = "brightnessField";

        if (this.getChildControl("brightness-handle").getBounds()) {
          this.getChildControl("brightness-handle").setDomTop(value);
        } else {
          this.getChildControl("brightness-handle").setLayoutProperties({
            top: value
          });
        }

        this.setBrightness(100 - Math.round(value / 2.56));
        this.__updateContext = null;
      },

      /*
      ---------------------------------------------------------------------------
        HUE/SATURATION IMPLEMENTATION
      ---------------------------------------------------------------------------
      */

      /**
       * Listener of pointerup event on the saturation handle.
       * Releases pointer capture.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onHueSaturationHandlePointerUp: function _onHueSaturationHandlePointerUp(e) {
        // Disabling capturing
        if (this.__capture) {
          e.stopPropagation();
          this.getChildControl("hue-saturation-handle").releaseCapture();
          this.__capture = null;
        }
      },

      /**
       * Listener of pointermove event on the saturation handle.
       * Forwards the event to _onHueSaturationHandlePointerMove().
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onHueSaturationHandlePointerMove: function _onHueSaturationHandlePointerMove(e) {
        // Update if captured currently (through previous pointerdown)
        if (this.__capture === "hue-saturation-handle") {
          this._setHueSaturationOnFieldEvent(e);

          e.stopPropagation();
        }
      },

      /**
       * Listener of pointerdown event on the saturation field.
       * Adjusts the color by changing the saturation.
       * Sets pointer capture.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onHueSaturationFieldPointerDown: function _onHueSaturationFieldPointerDown(e) {
        // Calculate substract: Half width/height of handler
        var location = this.getChildControl("hue-saturation-field").getContentLocation();
        var handleBounds = this.getChildControl("hue-saturation-handle").getBounds();
        var fieldBounds = this.getChildControl("hue-saturation-field").getBounds();
        this.__hueSaturationSubtractTop = location.top + handleBounds.height / 2 - fieldBounds.top;
        this.__hueSaturationSubtractLeft = location.left + handleBounds.width / 2 - fieldBounds.left; // Update

        this._setHueSaturationOnFieldEvent(e); // Afterwards: Activate Capturing for handle


        this.getChildControl("hue-saturation-handle").capture();
        this.__capture = "hue-saturation-handle";
      },

      /**
       * Listener of roll event on the saturation pane.
       * Adjusts the color by changing the saturation.
       *
       * @param e {qx.event.type.Roll} Incoming event object
       */
      _onHueSaturationPaneRoll: function _onHueSaturationPaneRoll(e) {
        e.stop(); // only wheel

        if (e.getPointerType() != "wheel") {
          return;
        }

        var delta = e.getDelta();
        this.setSaturation(qx.lang.Number.limit(this.getSaturation() - delta.y / 10, 0, 100));
        this.setHue(qx.lang.Number.limit(this.getHue() + delta.x / 10, 0, 360));
      },

      /**
       * Sets the saturation and moves the saturation handle.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _setHueSaturationOnFieldEvent: function _setHueSaturationOnFieldEvent(e) {
        var vTop = qx.lang.Number.limit(e.getDocumentTop() - this.__hueSaturationSubtractTop, 0, 256);
        var vLeft = qx.lang.Number.limit(e.getDocumentLeft() - this.__hueSaturationSubtractLeft, 0, 256);
        this.getChildControl("hue-saturation-handle").setDomPosition(vLeft, vTop);
        this.__updateContext = "hueSaturationField";
        this.setSaturation(100 - Math.round(vTop / 2.56));
        this.setHue(Math.round(vLeft * 1.40625));
        this.__updateContext = null;
      },

      /*
      ---------------------------------------------------------------------------
        RGB SPINNER
      ---------------------------------------------------------------------------
      */

      /**
       * Sets widget's red value to spinner's value.
       */
      _setRedFromSpinner: function _setRedFromSpinner() {
        if (this.__updateContext !== null) {
          return;
        }

        this.__updateContext = "rgbSpinner";
        this.setRed(this.getChildControl("rgb-spinner-red").getValue());
        this.__updateContext = null;
      },

      /**
       * Sets widget's green value to spinner's value.
       */
      _setGreenFromSpinner: function _setGreenFromSpinner() {
        if (this.__updateContext !== null) {
          return;
        }

        this.__updateContext = "rgbSpinner";
        this.setGreen(this.getChildControl("rgb-spinner-green").getValue());
        this.__updateContext = null;
      },

      /**
       * Sets widget's blue value to spinner's value.
       */
      _setBlueFromSpinner: function _setBlueFromSpinner() {
        if (this.__updateContext !== null) {
          return;
        }

        this.__updateContext = "rgbSpinner";
        this.setBlue(this.getChildControl("rgb-spinner-blue").getValue());
        this.__updateContext = null;
      },

      /*
      ---------------------------------------------------------------------------
        HSB SPINNER
      ---------------------------------------------------------------------------
      */

      /**
       * Sets widget's hue value to spinner's value.
       */
      _setHueFromSpinner: function _setHueFromSpinner() {
        if (this.__updateContext !== null) {
          return;
        }

        this.__updateContext = "hsbSpinner";
        this.setHue(this.getChildControl("hsb-spinner-hue").getValue());
        this.__updateContext = null;
      },

      /**
       * Sets widget's saturation value to spinner's value.
       */
      _setSaturationFromSpinner: function _setSaturationFromSpinner() {
        if (this.__updateContext !== null) {
          return;
        }

        this.__updateContext = "hsbSpinner";
        this.setSaturation(this.getChildControl("hsb-spinner-saturation").getValue());
        this.__updateContext = null;
      },

      /**
       * Sets widget's brightness value to spinner's value.
       */
      _setBrightnessFromSpinner: function _setBrightnessFromSpinner() {
        if (this.__updateContext !== null) {
          return;
        }

        this.__updateContext = "hsbSpinner";
        this.setBrightness(this.getChildControl("hsb-spinner-brightness").getValue());
        this.__updateContext = null;
      },

      /*
      ---------------------------------------------------------------------------
        HEX FIELD
      ---------------------------------------------------------------------------
      */

      /**
       * Changes red, green and blue value to the corresponding hexfield value.
       * @param e {qx.event.type.Data} Incoming event object
       */
      _onHexFieldChange: function _onHexFieldChange(e) {
        if (this.__updateContext !== null) {
          return;
        }

        try {
          var hexField = this.getChildControl("hex-field");
          var rgb = qx.util.ColorUtil.hexStringToRgb("#" + hexField.getValue());
        } catch (ex) {
          return;
        }

        ;
        this.__updateContext = "hexField";
        this.setRed(rgb[0]);
        this.setGreen(rgb[1]);
        this.setBlue(rgb[2]);
        this.__updateContext = null;
      },

      /**
       * Sets hexfield value to it's corresponding red, green and blue value.
       */
      _setHexFromRgb: function _setHexFromRgb() {
        var value = qx.util.ColorUtil.rgbToHexString([this.getRed(), this.getGreen(), this.getBlue()]); // get rid of the starting '#'

        value = value.substring(1, value.length);
        this.getChildControl("hex-field").setValue(value);
      },

      /*
      ---------------------------------------------------------------------------
        COLOR FIELD
      ---------------------------------------------------------------------------
      */

      /**
       * Listener of tap event on the color field.
       * Sets red, green and blue values to tapped color field's background color.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onColorFieldTap: function _onColorFieldTap(e) {
        var vColor = e.getTarget().getBackgroundColor();

        if (!vColor) {
          this.error("Missing backgroundColor value for field: " + e.getTarget());
          return;
        }

        var rgb = qx.util.ColorUtil.stringToRgb(vColor);
        this.setRed(rgb[0]);
        this.setGreen(rgb[1]);
        this.setBlue(rgb[2]);
      },

      /*
      ---------------------------------------------------------------------------
        RGB/HSB SYNC
      ---------------------------------------------------------------------------
      */

      /**
       * Sets hue value to it's corresponding red, green and blue value.
       */
      _setHueFromRgb: function _setHueFromRgb() {
        switch (this.__updateContext) {
          case "hsbSpinner":
          case "hueSaturationField":
          case "brightnessField":
            break;

          default:
            var hsb = qx.util.ColorUtil.rgbToHsb([this.getRed(), this.getGreen(), this.getBlue()]);
            this.setHue(hsb[0]);
            this.setSaturation(hsb[1]);
            this.setBrightness(hsb[2]);
        }
      },

      /**
       * Sets red, green and blue value to corresponding hue value.
       */
      _setRgbFromHue: function _setRgbFromHue() {
        switch (this.__updateContext) {
          case "rgbSpinner":
          case "hexField":
            break;

          default:
            var vRgb = qx.util.ColorUtil.hsbToRgb([this.getHue(), this.getSaturation(), this.getBrightness()]);
            this.setRed(vRgb[0]);
            this.setGreen(vRgb[1]);
            this.setBlue(vRgb[2]);
        }
      },

      /*
      ---------------------------------------------------------------------------
        PREVIEW SYNC
      ---------------------------------------------------------------------------
      */

      /**
       * Sets preview pane's background color to corresponding red, green and blue color values.
       */
      _setPreviewFromRgb: function _setPreviewFromRgb() {
        var rgbString = qx.util.ColorUtil.rgbToRgbString([this.getRed(), this.getGreen(), this.getBlue()]);
        this.getChildControl("preview-content-new").setBackgroundColor(rgbString);
      },

      /**
       * Sets previous color's to given values.
       *
       * @param red {Number} Red color value.
       * @param green {Number} Green color value.
       * @param blue {Number} Blue color value.
       */
      setPreviousColor: function setPreviousColor(red, green, blue) {
        var color = qx.util.ColorUtil.rgbToRgbString([red, green, blue]);
        this.getChildControl("preview-content-old").setBackgroundColor(color);
        this.setRed(red);
        this.setGreen(green);
        this.setBlue(blue);
      },

      /**
       * Updates the background of the brightness field to give a nicer gradient
       */
      _setBrightnessGradiant: function _setBrightnessGradiant() {
        var ColorUtil = qx.util.ColorUtil;
        var helpRgb = ColorUtil.hsbToRgb([this.getHue(), this.getSaturation(), 255]);
        var helpRgbString = ColorUtil.rgbToRgbString(helpRgb);
        this.getChildControl("brightness-field").setBackgroundColor(helpRgbString);
      },

      /**
       * Listener for appear.
       * Sets preview pane's background color to the current color.
       *
       * @param e {qx.event.type.Data} Incoming event object
       */
      _onAppear: function _onAppear(e) {
        var color = qx.util.ColorUtil.rgbToRgbString([this.getRed(), this.getGreen(), this.getBlue()]);
        this.getChildControl("preview-content-old").setBackgroundColor(color);
        this.getChildControl("preview-content-new").setBackgroundColor(color);
      }
    }
  });
  qx.ui.control.ColorSelector.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which have date as their primary
   * data type like datechooser's.
   */
  qx.Interface.define("qx.ui.form.IDateForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {Date|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {Date|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.IDateForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IDateForm": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.locale.Date": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.tooltip.ToolTip": {},
      "qx.ui.toolbar.Button": {},
      "qx.ui.basic.Label": {},
      "qx.ui.layout.Grid": {},
      "qx.util.format.DateFormat": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * A *date chooser* is a small calendar including a navigation bar to switch the shown
   * month. It includes a column for the calendar week and shows one month. Selecting
   * a date is as easy as tapping on it.
   *
   * To be conform with all form widgets, the {@link qx.ui.form.IForm} interface
   * is implemented.
   *
   * The following example creates and adds a date chooser to the root element.
   * A listener alerts the user if a new date is selected.
   *
   * <pre class='javascript'>
   * var chooser = new qx.ui.control.DateChooser();
   * this.getRoot().add(chooser, { left : 20, top: 20});
   *
   * chooser.addListener("changeValue", function(e) {
   *   alert(e.getData());
   * });
   * </pre>
   *
   * Additionally to a selection event an execute event is available which is
   * fired by doubletap or tapping the space / enter key. With this event you
   * can for example save the selection and close the date chooser.
   *
   * @childControl navigation-bar {qx.ui.container.Composite} container for the navigation bar controls
   * @childControl last-year-button-tooltip {qx.ui.tooltip.ToolTip} tooltip for the last year button
   * @childControl last-year-button {qx.ui.form.Button} button to jump to the last year
   * @childControl last-month-button-tooltip {qx.ui.tooltip.ToolTip} tooltip for the last month button
   * @childControl last-month-button {qx.ui.form.Button} button to jump to the last month
   * @childControl next-month-button-tooltip {qx.ui.tooltip.ToolTip} tooltip for the next month button
   * @childControl next-month-button {qx.ui.form.Button} button to jump to the next month
   * @childControl next-year-button-tooltip {qx.ui.tooltip.ToolTip} tooltip for the next year button
   * @childControl next-year-button {qx.ui.form.Button} button to jump to the next year
   * @childControl month-year-label {qx.ui.basic.Label} shows the current month and year
   * @childControl week {qx.ui.basic.Label} week label (used multiple times)
   * @childControl weekday {qx.ui.basic.Label} weekday label (used multiple times)
   * @childControl day {qx.ui.basic.Label} day label (used multiple times)
   * @childControl date-pane {qx.ui.container.Composite} the pane used to position the week, weekday and day labels
   *
   */
  qx.Class.define("qx.ui.control.DateChooser", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MExecutable, qx.ui.form.MForm],
    implement: [qx.ui.form.IExecutable, qx.ui.form.IForm, qx.ui.form.IDateForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param date {Date ? null} The initial date to show. If <code>null</code>
     * the current day (today) is shown.
     */
    construct: function construct(date) {
      qx.ui.core.Widget.constructor.call(this); // set the layout

      var layout = new qx.ui.layout.VBox();

      this._setLayout(layout); // create the child controls


      this._createChildControl("navigation-bar");

      this._createChildControl("date-pane"); // Support for key events


      this.addListener("keypress", this._onKeyPress); // initialize format - moved from statics{} to constructor due to [BUG #7149]

      var DateChooser = qx.ui.control.DateChooser;

      if (!DateChooser.MONTH_YEAR_FORMAT) {
        DateChooser.MONTH_YEAR_FORMAT = qx.locale.Date.getDateTimeFormat("yyyyMMMM", "MMMM yyyy");
      } // Show the right date


      var shownDate = date != null ? date : new Date();
      this.showMonth(shownDate.getMonth(), shownDate.getFullYear()); // listen for locale changes

      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._updateDatePane, this);
      } // register pointer up and down handler

      this.addListener("pointerdown", this._onPointerUpDown, this);
      this.addListener("pointerup", this._onPointerUpDown, this);
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * @type {string} The format for the date year label at the top center.
       */
      MONTH_YEAR_FORMAT: null,

      /**
       * @type {string} The format for the weekday labels (the headers of the date table).
       */
      WEEKDAY_FORMAT: "EE",

      /**
       * @type {string} The format for the week numbers (the labels of the left column).
       */
      WEEK_FORMAT: "ww"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "datechooser"
      },
      // overridden
      width: {
        refine: true,
        init: 200
      },
      // overridden
      height: {
        refine: true,
        init: 150
      },

      /** The currently shown month. 0 = january, 1 = february, and so on. */
      shownMonth: {
        check: "Integer",
        init: null,
        nullable: true,
        event: "changeShownMonth"
      },

      /** The currently shown year. */
      shownYear: {
        check: "Integer",
        init: null,
        nullable: true,
        event: "changeShownYear"
      },

      /** The date value of the widget. */
      value: {
        check: "Date",
        init: null,
        nullable: true,
        event: "changeValue",
        apply: "_applyValue"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __weekdayLabelArr: null,
      __dayLabelArr: null,
      __weekLabelArr: null,
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        invalid: true
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET INTERNALS
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          // NAVIGATION BAR STUFF
          case "navigation-bar":
            control = new qx.ui.container.Composite(new qx.ui.layout.HBox()); // Add the navigation bar elements

            control.add(this.getChildControl("last-year-button"));
            control.add(this.getChildControl("last-month-button"));
            control.add(this.getChildControl("month-year-label"), {
              flex: 1
            });
            control.add(this.getChildControl("next-month-button"));
            control.add(this.getChildControl("next-year-button"));

            this._add(control);

            break;

          case "last-year-button-tooltip":
            control = new qx.ui.tooltip.ToolTip(this.tr("Last year"));
            break;

          case "last-year-button":
            control = new qx.ui.toolbar.Button();
            control.addState("lastYear");
            control.setFocusable(false);
            control.setToolTip(this.getChildControl("last-year-button-tooltip"));
            control.addListener("tap", this._onNavButtonTap, this);
            break;

          case "last-month-button-tooltip":
            control = new qx.ui.tooltip.ToolTip(this.tr("Last month"));
            break;

          case "last-month-button":
            control = new qx.ui.toolbar.Button();
            control.addState("lastMonth");
            control.setFocusable(false);
            control.setToolTip(this.getChildControl("last-month-button-tooltip"));
            control.addListener("tap", this._onNavButtonTap, this);
            break;

          case "next-month-button-tooltip":
            control = new qx.ui.tooltip.ToolTip(this.tr("Next month"));
            break;

          case "next-month-button":
            control = new qx.ui.toolbar.Button();
            control.addState("nextMonth");
            control.setFocusable(false);
            control.setToolTip(this.getChildControl("next-month-button-tooltip"));
            control.addListener("tap", this._onNavButtonTap, this);
            break;

          case "next-year-button-tooltip":
            control = new qx.ui.tooltip.ToolTip(this.tr("Next year"));
            break;

          case "next-year-button":
            control = new qx.ui.toolbar.Button();
            control.addState("nextYear");
            control.setFocusable(false);
            control.setToolTip(this.getChildControl("next-year-button-tooltip"));
            control.addListener("tap", this._onNavButtonTap, this);
            break;

          case "month-year-label":
            control = new qx.ui.basic.Label();
            control.setAllowGrowX(true);
            control.setAnonymous(true);
            break;

          case "week":
            control = new qx.ui.basic.Label();
            control.setAllowGrowX(true);
            control.setAllowGrowY(true);
            control.setSelectable(false);
            control.setAnonymous(true);
            control.setCursor("default");
            break;

          case "weekday":
            control = new qx.ui.basic.Label();
            control.setAllowGrowX(true);
            control.setAllowGrowY(true);
            control.setSelectable(false);
            control.setAnonymous(true);
            control.setCursor("default");
            break;

          case "day":
            control = new qx.ui.basic.Label();
            control.setAllowGrowX(true);
            control.setAllowGrowY(true);
            control.setCursor("default");
            control.addListener("pointerdown", this._onDayTap, this);
            control.addListener("dbltap", this._onDayDblTap, this);
            break;

          case "date-pane":
            var controlLayout = new qx.ui.layout.Grid();
            control = new qx.ui.container.Composite(controlLayout);

            for (var i = 0; i < 8; i++) {
              controlLayout.setColumnFlex(i, 1);
            }

            for (var i = 0; i < 7; i++) {
              controlLayout.setRowFlex(i, 1);
            } // Create the weekdays
            // Add an empty label as spacer for the week numbers


            var label = this.getChildControl("week#0");
            label.addState("header");
            control.add(label, {
              column: 0,
              row: 0
            });
            this.__weekdayLabelArr = [];

            for (var i = 0; i < 7; i++) {
              label = this.getChildControl("weekday#" + i);
              control.add(label, {
                column: i + 1,
                row: 0
              });

              this.__weekdayLabelArr.push(label);
            } // Add the days


            this.__dayLabelArr = [];
            this.__weekLabelArr = [];

            for (var y = 0; y < 6; y++) {
              // Add the week label
              var label = this.getChildControl("week#" + (y + 1));
              control.add(label, {
                column: 0,
                row: y + 1
              });

              this.__weekLabelArr.push(label); // Add the day labels


              for (var x = 0; x < 7; x++) {
                var label = this.getChildControl("day#" + (y * 7 + x));
                control.add(label, {
                  column: x + 1,
                  row: y + 1
                });

                this.__dayLabelArr.push(label);
              }
            }

            this._add(control);

            break;
        }

        return control || qx.ui.control.DateChooser.prototype._createChildControlImpl.base.call(this, id);
      },
      // apply methods
      _applyValue: function _applyValue(value, old) {
        if (value != null && (this.getShownMonth() != value.getMonth() || this.getShownYear() != value.getFullYear())) {
          // The new date is in another month -> Show that month
          this.showMonth(value.getMonth(), value.getFullYear());
        } else {
          // The new date is in the current month -> Just change the states
          var newDay = value == null ? -1 : value.getDate();

          for (var i = 0; i < 42; i++) {
            var dayLabel = this.__dayLabelArr[i];

            if (dayLabel.hasState("otherMonth")) {
              if (dayLabel.hasState("selected")) {
                dayLabel.removeState("selected");
              }
            } else {
              var day = parseInt(dayLabel.getValue(), 10);

              if (day == newDay) {
                dayLabel.addState("selected");
              } else if (dayLabel.hasState("selected")) {
                dayLabel.removeState("selected");
              }
            }
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Handler which stops the propagation of the tap event if
       * the navigation bar or calendar headers will be tapped.
       *
       * @param e {qx.event.type.Pointer} The pointer up / down event
       */
      _onPointerUpDown: function _onPointerUpDown(e) {
        var target = e.getTarget();

        if (target == this.getChildControl("navigation-bar") || target == this.getChildControl("date-pane")) {
          e.stopPropagation();
          return;
        }
      },

      /**
       * Event handler. Called when a navigation button has been tapped.
       *
       * @param evt {qx.event.type.Data} The data event.
       */
      _onNavButtonTap: function _onNavButtonTap(evt) {
        var year = this.getShownYear();
        var month = this.getShownMonth();

        switch (evt.getCurrentTarget()) {
          case this.getChildControl("last-year-button"):
            year--;
            break;

          case this.getChildControl("last-month-button"):
            month--;

            if (month < 0) {
              month = 11;
              year--;
            }

            break;

          case this.getChildControl("next-month-button"):
            month++;

            if (month >= 12) {
              month = 0;
              year++;
            }

            break;

          case this.getChildControl("next-year-button"):
            year++;
            break;
        }

        this.showMonth(month, year);
      },

      /**
       * Event handler. Called when a day has been tapped.
       *
       * @param evt {qx.event.type.Data} The event.
       */
      _onDayTap: function _onDayTap(evt) {
        var time = evt.getCurrentTarget().dateTime;
        this.setValue(new Date(time));
      },

      /**
       * Event handler. Called when a day has been double-tapped.
       */
      _onDayDblTap: function _onDayDblTap() {
        this.execute();
      },

      /**
       * Event handler. Called when a key was pressed.
       *
       * @param evt {qx.event.type.Data} The event.
       */
      _onKeyPress: function _onKeyPress(evt) {
        var dayIncrement = null;
        var monthIncrement = null;
        var yearIncrement = null;

        if (evt.getModifiers() == 0) {
          switch (evt.getKeyIdentifier()) {
            case "Left":
              dayIncrement = -1;
              break;

            case "Right":
              dayIncrement = 1;
              break;

            case "Up":
              dayIncrement = -7;
              break;

            case "Down":
              dayIncrement = 7;
              break;

            case "PageUp":
              monthIncrement = -1;
              break;

            case "PageDown":
              monthIncrement = 1;
              break;

            case "Escape":
              if (this.getValue() != null) {
                this.setValue(null);
                return;
              }

              break;

            case "Enter":
            case "Space":
              if (this.getValue() != null) {
                this.execute();
              }

              return;
          }
        } else if (evt.isShiftPressed()) {
          switch (evt.getKeyIdentifier()) {
            case "PageUp":
              yearIncrement = -1;
              break;

            case "PageDown":
              yearIncrement = 1;
              break;
          }
        }

        if (dayIncrement != null || monthIncrement != null || yearIncrement != null) {
          var date = this.getValue();

          if (date != null) {
            date = new Date(date.getTime());
          }

          if (date == null) {
            date = new Date();
          } else {
            if (dayIncrement != null) {
              date.setDate(date.getDate() + dayIncrement);
            }

            if (monthIncrement != null) {
              date.setMonth(date.getMonth() + monthIncrement);
            }

            if (yearIncrement != null) {
              date.setFullYear(date.getFullYear() + yearIncrement);
            }
          }

          this.setValue(date);
        }
      },

      /**
       * Shows a certain month.
       *
       * @param month {Integer ? null} the month to show (0 = january). If not set
       *      the month will remain the same.
       * @param year {Integer ? null} the year to show. If not set the year will
       *      remain the same.
       */
      showMonth: function showMonth(month, year) {
        if (month != null && month != this.getShownMonth() || year != null && year != this.getShownYear()) {
          if (month != null) {
            this.setShownMonth(month);
          }

          if (year != null) {
            this.setShownYear(year);
          }

          this._updateDatePane();
        }
      },

      /**
       * Event handler. Used to handle the key events.
       *
       * @param e {qx.event.type.Data} The event.
       */
      handleKeyPress: function handleKeyPress(e) {
        this._onKeyPress(e);
      },

      /**
       * Updates the date pane.
       */
      _updateDatePane: function _updateDatePane() {
        var DateChooser = qx.ui.control.DateChooser;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth();
        var todayDayOfMonth = today.getDate();
        var selDate = this.getValue();
        var selYear = selDate == null ? -1 : selDate.getFullYear();
        var selMonth = selDate == null ? -1 : selDate.getMonth();
        var selDayOfMonth = selDate == null ? -1 : selDate.getDate();
        var shownMonth = this.getShownMonth();
        var shownYear = this.getShownYear();
        var startOfWeek = qx.locale.Date.getWeekStart(); // Create a help date that points to the first of the current month

        var helpDate = new Date(this.getShownYear(), this.getShownMonth(), 1);
        var monthYearFormat = new qx.util.format.DateFormat(DateChooser.MONTH_YEAR_FORMAT);
        this.getChildControl("month-year-label").setValue(monthYearFormat.format(helpDate)); // Show the day names

        var firstDayOfWeek = helpDate.getDay();
        var firstSundayInMonth = 1 + (7 - firstDayOfWeek) % 7;
        var weekDayFormat = new qx.util.format.DateFormat(DateChooser.WEEKDAY_FORMAT);

        for (var i = 0; i < 7; i++) {
          var day = (i + startOfWeek) % 7;
          var dayLabel = this.__weekdayLabelArr[i];
          helpDate.setDate(firstSundayInMonth + day);
          dayLabel.setValue(weekDayFormat.format(helpDate));

          if (qx.locale.Date.isWeekend(day)) {
            dayLabel.addState("weekend");
          } else {
            dayLabel.removeState("weekend");
          }
        } // Show the days


        helpDate = new Date(shownYear, shownMonth, 1, 12, 0, 0);
        var nrDaysOfLastMonth = (7 + firstDayOfWeek - startOfWeek) % 7;
        helpDate.setDate(helpDate.getDate() - nrDaysOfLastMonth);
        var weekFormat = new qx.util.format.DateFormat(DateChooser.WEEK_FORMAT);

        for (var week = 0; week < 6; week++) {
          this.__weekLabelArr[week].setValue(weekFormat.format(helpDate));

          for (var i = 0; i < 7; i++) {
            var dayLabel = this.__dayLabelArr[week * 7 + i];
            var year = helpDate.getFullYear();
            var month = helpDate.getMonth();
            var dayOfMonth = helpDate.getDate();
            var isSelectedDate = selYear == year && selMonth == month && selDayOfMonth == dayOfMonth;

            if (isSelectedDate) {
              dayLabel.addState("selected");
            } else {
              dayLabel.removeState("selected");
            }

            if (month != shownMonth) {
              dayLabel.addState("otherMonth");
            } else {
              dayLabel.removeState("otherMonth");
            }

            var isToday = year == todayYear && month == todayMonth && dayOfMonth == todayDayOfMonth;

            if (isToday) {
              dayLabel.addState("today");
            } else {
              dayLabel.removeState("today");
            }

            dayLabel.setValue("" + dayOfMonth);
            dayLabel.dateTime = helpDate.getTime(); // Go to the next day

            helpDate.setDate(helpDate.getDate() + 1);
          }
        }

        monthYearFormat.dispose();
        weekDayFormat.dispose();
        weekFormat.dispose();
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._updateDatePane, this);
      }
      this.__weekdayLabelArr = this.__dayLabelArr = this.__weekLabelArr = null;
    }
  });
  qx.ui.control.DateChooser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.popup.Popup": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IColorForm": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.core.Widget": {},
      "qx.ui.form.Button": {},
      "qx.ui.groupbox.GroupBox": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.container.Composite": {},
      "qx.ui.layout.Basic": {},
      "qx.ui.window.Window": {},
      "qx.ui.control.ColorSelector": {},
      "qx.util.ColorUtil": {},
      "qx.lang.Array": {},
      "qx.locale.Manager": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
  
  
  ************************************************************************ */

  /**
   * A popup which contains palettes of colors and the possibility to open the
   * Colorselector to choose a color.
   *
   * @childControl field {qx.ui.core.Widget} shows preset colors
   * @childControl auto-button {qx.ui.form.Button} automatic button
   * @childControl selector-button {qx.ui.form.Button} button to open the color selector
   * @childControl preview-pane {qx.ui.groupbox.GroupBox} group box to show the old and the new color
   * @childControl selected-preview {qx.ui.container.Composite} show the selected color
   * @childControl current-preview {qx.ui.container.Composite} show the current color
   * @childControl colorselector-okbutton {qx.ui.form.Button} button of the colorselector
   * @childControl colorselector-cancelbutton {qx.ui.form.Button} button of the colorselector
   */
  qx.Class.define("qx.ui.control.ColorPopup", {
    extend: qx.ui.popup.Popup,
    implement: [qx.ui.form.IColorForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.popup.Popup.constructor.call(this);
      this.setLayout(new qx.ui.layout.VBox(5));

      this._createChildControl("auto-button");

      this._createBoxes();

      this._createChildControl("preview-pane");

      this._createChildControl("selector-button");

      this.addListener("changeVisibility", this._onChangeVisibility, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "colorpopup"
      },

      /** The hex value of the selected color. */
      value: {
        nullable: true,
        apply: "_applyValue",
        event: "changeValue"
      },

      /** The numeric red value of the selected color. */
      red: {
        check: "Number",
        init: null,
        nullable: true,
        event: "changeRed"
      },

      /** The numeric green value of the selected color. */
      green: {
        check: "Number",
        init: null,
        nullable: true,
        event: "changeGreen"
      },

      /** The numeric blue value of the selected color. */
      blue: {
        check: "Number",
        init: null,
        nullable: true,
        event: "changeBlue"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __minZIndex: 1e5,
      __boxes: null,
      __colorSelectorWindow: null,
      __colorSelector: null,
      __buttonBar: null,
      __recentTableId: "recent",
      __fieldNumber: 12,
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "field":
            control = new qx.ui.core.Widget();
            control.addListener("pointerdown", this._onFieldPointerDown, this);
            control.addListener("pointerover", this._onFieldPointerOver, this);
            control.addListener("pointerout", this._onFieldPointerOut, this);
            break;

          case "auto-button":
            control = new qx.ui.form.Button(this.tr("Automatic"));
            control.setAllowStretchX(true);
            control.addListener("execute", this._onAutomaticBtnExecute, this);
            this.add(control);
            break;

          case "selector-button":
            control = new qx.ui.form.Button(this.tr("Open ColorSelector"));
            control.addListener("execute", this._onSelectorButtonExecute, this);
            this.add(control);
            break;

          case "preview-pane":
            control = new qx.ui.groupbox.GroupBox(this.tr("Preview (Old/New)"));
            control.setLayout(new qx.ui.layout.HBox());
            control.add(this._createChildControl("selected-preview", true), {
              flex: 1
            });
            control.add(this._createChildControl("current-preview", true), {
              flex: 1
            });
            this.add(control);
            break;

          case "selected-preview":
            control = new qx.ui.container.Composite(new qx.ui.layout.Basic());
            break;

          case "current-preview":
            control = new qx.ui.container.Composite(new qx.ui.layout.Basic());
            break;

          case "colorselector-okbutton":
            control = new qx.ui.form.Button(this.tr("OK"));
            control.addListener("execute", this._onColorSelectorOk, this);
            break;

          case "colorselector-cancelbutton":
            control = new qx.ui.form.Button(this.tr("Cancel"));
            control.addListener("execute", this._onColorSelectorCancel, this);
            break;
        }

        return control || qx.ui.control.ColorPopup.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        CREATOR SUBS
      ---------------------------------------------------------------------------
      */

      /**
       * Creates the GroupBoxes containing the colored fields.
       */
      _createBoxes: function _createBoxes() {
        this.__boxes = {};
        var tables = this._tables;
        var table, box, field;
        var j = 0;

        for (var tableId in tables) {
          table = tables[tableId];
          box = new qx.ui.groupbox.GroupBox(table.label);
          box.setLayout(new qx.ui.layout.HBox());
          this.__boxes[tableId] = box;
          this.add(box);

          for (var i = 0; i < this.__fieldNumber; i++) {
            field = this.getChildControl("field#" + j++);
            field.setBackgroundColor(table.values[i] || null);
            box.add(field);
          }
        }
      },

      /**
       * Creates the ColorSelector and adds buttons.
       */
      _createColorSelector: function _createColorSelector() {
        if (this.__colorSelector) {
          return;
        }

        var win = new qx.ui.window.Window(this.tr("Color Selector"));
        this.__colorSelectorWindow = win;
        win.setLayout(new qx.ui.layout.VBox(16));
        win.setResizable(false);
        win.moveTo(20, 20);
        this.__colorSelector = new qx.ui.control.ColorSelector();
        win.add(this.__colorSelector);
        this.__buttonBar = new qx.ui.container.Composite(new qx.ui.layout.HBox(8, "right"));
        win.add(this.__buttonBar);

        var btnCancel = this._createChildControl("colorselector-cancelbutton");

        var btnOk = this._createChildControl("colorselector-okbutton");

        this.__buttonBar.add(btnCancel);

        this.__buttonBar.add(btnOk);
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // Property apply
      _applyValue: function _applyValue(value, old) {
        if (value === null) {
          this.setRed(null);
          this.setGreen(null);
          this.setBlue(null);
        } else {
          var rgb = qx.util.ColorUtil.stringToRgb(value);
          this.setRed(rgb[0]);
          this.setGreen(rgb[1]);
          this.setBlue(rgb[2]);
        }

        this.getChildControl("selected-preview").setBackgroundColor(value);

        this._rotatePreviousColors();
      },

      /**
       * Adds the most recent selected color to the "Recent colors" list.
       * If this list is full, the first color will be removed before inserting
       * the new one.
       */
      _rotatePreviousColors: function _rotatePreviousColors() {
        if (!this._tables) {
          return;
        }

        var vRecentTable = this._tables[this.__recentTableId].values;
        var vRecentBox = this.__boxes[this.__recentTableId];

        if (!vRecentTable) {
          return;
        }

        var newValue = this.getValue();

        if (!newValue) {
          return;
        } // Modifying incoming table


        var vIndex = vRecentTable.indexOf(newValue);

        if (vIndex != -1) {
          qx.lang.Array.removeAt(vRecentTable, vIndex);
        } else if (vRecentTable.length == this.__fieldNumber) {
          vRecentTable.shift();
        }

        vRecentTable.push(newValue); // Sync to visible fields

        var vFields = vRecentBox.getChildren();

        for (var i = 0; i < vFields.length; i++) {
          vFields[i].setBackgroundColor(vRecentTable[i] || null);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Listener of pointerdown event on a color field. Sets the ColorPoup's value
       * to field's color value and paint the preview pane.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onFieldPointerDown: function _onFieldPointerDown(e) {
        var vValue = this.getChildControl("current-preview").getBackgroundColor();
        this.setValue(vValue);

        if (vValue) {
          this.hide();
        }
      },

      /**
       * Listener of pointermove event on a color field. Sets preview pane's
       * background color to the field's color value.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onFieldPointerOver: function _onFieldPointerOver(e) {
        this.getChildControl("current-preview").setBackgroundColor(e.getTarget().getBackgroundColor());
      },

      /**
       * Listener of pointerout event on a color field. Reset the preview pane's
       * background color to the old color value.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onFieldPointerOut: function _onFieldPointerOut(e) {
        var red = this.getRed();
        var green = this.getGreen();
        var blue = this.getBlue();
        var color = null;

        if (red !== null || green !== null || blue !== null) {
          color = qx.util.ColorUtil.rgbToRgbString([red, green, blue]);
        }

        this.getChildControl("current-preview").setBackgroundColor(color);
      },

      /**
       * Listener of execute event on the "cancel" button.
       * Hides the ColorPopup and resets it's color value.
       */
      _onAutomaticBtnExecute: function _onAutomaticBtnExecute() {
        this.setValue(null);
        this.hide();
      },

      /**
       * Listener of execute event on the "Open ColorSelector" button.
       * Opens a ColorSelector widget and hides the ColorPopup.
       */
      _onSelectorButtonExecute: function _onSelectorButtonExecute() {
        this._createColorSelector();

        this.exclude();
        var red = this.getRed();
        var green = this.getGreen();
        var blue = this.getBlue();

        if (red === null || green === null || blue === null) {
          red = 255;
          green = 255;
          blue = 255;
        }

        this.__colorSelector.setRed(red);

        this.__colorSelector.setGreen(green);

        this.__colorSelector.setBlue(blue);

        this.__colorSelectorWindow.open();
      },

      /**
       * Listener of execute event on the "OK" button.
       * Hides the ColorPopup and sets it's color value to the selected color.
       */
      _onColorSelectorOk: function _onColorSelectorOk() {
        var sel = this.__colorSelector;
        this.setValue(qx.util.ColorUtil.rgbToRgbString([sel.getRed(), sel.getGreen(), sel.getBlue()]));

        this.__colorSelectorWindow.close();
      },

      /**
       * Listener of execute event on the "Cancel" button.
       * Hides the ColorPopup.
       */
      _onColorSelectorCancel: function _onColorSelectorCancel() {
        this.__colorSelectorWindow.close();
      },

      /**
       * Listener for visibility changes.
       * Sets preview pane's background color to the current color,
       * when the popup is visible.
       *
       * @param e {qx.event.type.Data} Incoming event object
       */
      _onChangeVisibility: function _onChangeVisibility(e) {
        if (this.getVisibility() == "visible") {
          var red = this.getRed();
          var green = this.getGreen();
          var blue = this.getBlue();
          var color = null;

          if (red !== null || green !== null || blue !== null) {
            color = qx.util.ColorUtil.rgbToRgbString([red, green, blue]);
          }

          this.getChildControl("selected-preview").setBackgroundColor(color);
          this.getChildControl("current-preview").setBackgroundColor(color);
        }
      },

      /**
       * @lint ignoreReferenceField(_tables)
       */
      _tables: {
        core: {
          label: qx.locale.Manager.tr("Basic Colors"),
          values: ["#000", "#333", "#666", "#999", "#CCC", "#FFF", "red", "green", "blue", "yellow", "teal", "maroon"]
        },
        recent: {
          label: qx.locale.Manager.tr("Recent Colors"),
          values: []
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this.__colorSelectorWindow) {
        this.__colorSelectorWindow.destroy();

        this.__colorSelector.destroy();

        this.__buttonBar.destroy();
      }

      this._tables = this.__boxes = null;
    }
  });
  qx.ui.control.ColorPopup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.scroll.IScrollBar": {
        "require": true
      },
      "qx.html.Element": {},
      "qx.bom.element.Scroll": {},
      "qx.ui.core.queue.Layout": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.bom.AnimationFrame": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.name": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The scroll bar widget wraps the native browser scroll bars as a qooxdoo widget.
   * It can be uses instead of the styled qooxdoo scroll bars.
   *
   * Scroll bars are used by the {@link qx.ui.container.Scroll} container. Usually
   * a scroll bar is not used directly.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var scrollBar = new qx.ui.core.scroll.NativeScrollBar("horizontal");
   *   scrollBar.set({
   *     maximum: 500
   *   })
   *   this.getRoot().add(scrollBar);
   * </pre>
   *
   * This example creates a horizontal scroll bar with a maximum value of 500.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/scrollbar.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.core.scroll.NativeScrollBar", {
    extend: qx.ui.core.Widget,
    implement: qx.ui.core.scroll.IScrollBar,

    /**
     * @param orientation {String?"horizontal"} The initial scroll bar orientation
     */
    construct: function construct(orientation) {
      qx.ui.core.Widget.constructor.call(this);
      this.addState("native");
      this.getContentElement().addListener("scroll", this._onScroll, this);
      this.addListener("pointerdown", this._stopPropagation, this);
      this.addListener("pointerup", this._stopPropagation, this);
      this.addListener("pointermove", this._stopPropagation, this);
      this.addListener("appear", this._onAppear, this);
      this.getContentElement().add(this._getScrollPaneElement());
      this.getContentElement().setStyle("box-sizing", "content-box"); // Configure orientation

      if (orientation != null) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      } // prevent drag & drop on scrolling


      this.addListener("track", function (e) {
        e.stopPropagation();
      }, this);
    },
    events: {
      /**
       * Fired as soon as the scroll animation ended.
       */
      scrollAnimationEnd: 'qx.event.type.Event'
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "scrollbar"
      },
      // interface implementation
      orientation: {
        check: ["horizontal", "vertical"],
        init: "horizontal",
        apply: "_applyOrientation"
      },
      // interface implementation
      maximum: {
        check: "PositiveInteger",
        apply: "_applyMaximum",
        init: 100
      },
      // interface implementation
      position: {
        check: "Number",
        init: 0,
        apply: "_applyPosition",
        event: "scroll"
      },

      /**
       * Step size for each tap on the up/down or left/right buttons.
       */
      singleStep: {
        check: "Integer",
        init: 20
      },
      // interface implementation
      knobFactor: {
        check: "PositiveNumber",
        nullable: true
      }
    },
    members: {
      __isHorizontal: null,
      __scrollPaneElement: null,
      __requestId: null,
      __scrollAnimationframe: null,

      /**
       * Get the scroll pane html element.
       *
       * @return {qx.html.Element} The element
       */
      _getScrollPaneElement: function _getScrollPaneElement() {
        if (!this.__scrollPaneElement) {
          this.__scrollPaneElement = new qx.html.Element();
        }

        return this.__scrollPaneElement;
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        var changes = qx.ui.core.scroll.NativeScrollBar.prototype.renderLayout.base.call(this, left, top, width, height);

        this._updateScrollBar();

        return changes;
      },
      // overridden
      _getContentHint: function _getContentHint() {
        var scrollbarWidth = qx.bom.element.Scroll.getScrollbarWidth();
        return {
          width: this.__isHorizontal ? 100 : scrollbarWidth,
          maxWidth: this.__isHorizontal ? null : scrollbarWidth,
          minWidth: this.__isHorizontal ? null : scrollbarWidth,
          height: this.__isHorizontal ? scrollbarWidth : 100,
          maxHeight: this.__isHorizontal ? scrollbarWidth : null,
          minHeight: this.__isHorizontal ? scrollbarWidth : null
        };
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.core.scroll.NativeScrollBar.prototype._applyEnabled.base.call(this, value, old);

        this._updateScrollBar();
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyMaximum: function _applyMaximum(value) {
        this._updateScrollBar();
      },
      // property apply
      _applyPosition: function _applyPosition(value) {
        var content = this.getContentElement();

        if (this.__isHorizontal) {
          content.scrollToX(value);
        } else {
          content.scrollToY(value);
        }
      },
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        var isHorizontal = this.__isHorizontal = value === "horizontal";
        this.set({
          allowGrowX: isHorizontal,
          allowShrinkX: isHorizontal,
          allowGrowY: !isHorizontal,
          allowShrinkY: !isHorizontal
        });

        if (isHorizontal) {
          this.replaceState("vertical", "horizontal");
        } else {
          this.replaceState("horizontal", "vertical");
        }

        this.getContentElement().setStyles({
          overflowX: isHorizontal ? "scroll" : "hidden",
          overflowY: isHorizontal ? "hidden" : "scroll"
        }); // Update layout

        qx.ui.core.queue.Layout.add(this);
      },

      /**
       * Update the scroll bar according to its current size, max value and
       * enabled state.
       */
      _updateScrollBar: function _updateScrollBar() {
        var isHorizontal = this.__isHorizontal;
        var bounds = this.getBounds();

        if (!bounds) {
          return;
        }

        if (this.isEnabled()) {
          var containerSize = isHorizontal ? bounds.width : bounds.height;
          var innerSize = this.getMaximum() + containerSize;
        } else {
          innerSize = 0;
        } // Scrollbars don't work properly in IE/Edge if the element with overflow has
        // exactly the size of the scrollbar. Thus we move the element one pixel
        // out of the view and increase the size by one.


        if (qx.core.Environment.get("engine.name") == "mshtml" || qx.core.Environment.get("browser.name") == "edge") {
          var bounds = this.getBounds();
          this.getContentElement().setStyles({
            left: (isHorizontal ? bounds.left : bounds.left - 1) + "px",
            top: (isHorizontal ? bounds.top - 1 : bounds.top) + "px",
            width: (isHorizontal ? bounds.width : bounds.width + 1) + "px",
            height: (isHorizontal ? bounds.height + 1 : bounds.height) + "px"
          });
        }

        this._getScrollPaneElement().setStyles({
          left: 0,
          top: 0,
          width: (isHorizontal ? innerSize : 1) + "px",
          height: (isHorizontal ? 1 : innerSize) + "px"
        });

        this.updatePosition(this.getPosition());
      },
      // interface implementation
      scrollTo: function scrollTo(position, duration) {
        // if a user sets a new position, stop any animation
        this.stopScrollAnimation();

        if (duration) {
          var from = this.getPosition();
          this.__scrollAnimationframe = new qx.bom.AnimationFrame();

          this.__scrollAnimationframe.on("frame", function (timePassed) {
            var newPos = parseInt(timePassed / duration * (position - from) + from);
            this.updatePosition(newPos);
          }, this);

          this.__scrollAnimationframe.on("end", function () {
            this.setPosition(Math.max(0, Math.min(this.getMaximum(), position)));
            this.__scrollAnimationframe = null;
            this.fireEvent("scrollAnimationEnd");
          }, this);

          this.__scrollAnimationframe.startSequence(duration);
        } else {
          this.updatePosition(position);
        }
      },

      /**
       * Helper to set the new position taking care of min and max values.
       * @param position {Number} The new position.
       */
      updatePosition: function updatePosition(position) {
        this.setPosition(Math.max(0, Math.min(this.getMaximum(), position)));
      },
      // interface implementation
      scrollBy: function scrollBy(offset, duration) {
        this.scrollTo(this.getPosition() + offset, duration);
      },
      // interface implementation
      scrollBySteps: function scrollBySteps(steps, duration) {
        var size = this.getSingleStep();
        this.scrollBy(steps * size, duration);
      },

      /**
       * If a scroll animation is running, it will be stopped.
       */
      stopScrollAnimation: function stopScrollAnimation() {
        if (this.__scrollAnimationframe) {
          this.__scrollAnimationframe.cancelSequence();

          this.__scrollAnimationframe = null;
        }
      },

      /**
       * Scroll event handler
       *
       * @param e {qx.event.type.Event} the scroll event
       */
      _onScroll: function _onScroll(e) {
        var container = this.getContentElement();
        var position = this.__isHorizontal ? container.getScrollX() : container.getScrollY();
        this.setPosition(position);
      },

      /**
       * Listener for appear which ensured the scroll bar is positioned right
       * on appear.
       *
       * @param e {qx.event.type.Data} Incoming event object
       */
      _onAppear: function _onAppear(e) {
        this._applyPosition(this.getPosition());
      },

      /**
       * Stops propagation on the given even
       *
       * @param e {qx.event.type.Event} the event
       */
      _stopPropagation: function _stopPropagation(e) {
        e.stopPropagation();
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__scrollPaneElement");
    }
  });
  qx.ui.core.scroll.NativeScrollBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This mixin is included by all widgets which supports native overflowing.
   */
  qx.Mixin.define("qx.ui.core.MNativeOverflow", {
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether the widget should have horizontal scrollbars.
       */
      overflowX: {
        check: ["hidden", "visible", "scroll", "auto"],
        nullable: true,
        apply: "_applyOverflowX"
      },

      /**
       * Whether the widget should have vertical scrollbars.
       */
      overflowY: {
        check: ["hidden", "visible", "scroll", "auto"],
        nullable: true,
        apply: "_applyOverflowY"
      },

      /**
       * Overflow group property
       */
      overflow: {
        group: ["overflowX", "overflowY"]
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // property apply
      _applyOverflowX: function _applyOverflowX(value) {
        this.getContentElement().setStyle("overflowX", value);
      },
      // property apply
      _applyOverflowY: function _applyOverflowY(value) {
        this.getContentElement().setStyle("overflowY", value);
      }
    }
  });
  qx.ui.core.MNativeOverflow.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MNativeOverflow": {
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.theme.manager.Font": {},
      "qx.bom.Font": {},
      "qx.theme.manager.Color": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The Html widget embeds plain HTML code into the application
   *
   * *Example*
   *
   * Here is a little example of how to use the canvas widget.
   *
   * <pre class='javascript'>
   * var html = new qx.ui.embed.Html();
   * html.setHtml("<h1>Hello World</h1>");
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/html.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.embed.Html", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MNativeOverflow],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param html {String} Initial HTML content
     */
    construct: function construct(html) {
      qx.ui.core.Widget.constructor.call(this);

      if (html != null) {
        this.setHtml(html);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Any text string which can contain HTML, too */
      html: {
        check: "String",
        apply: "_applyHtml",
        event: "changeHtml",
        nullable: true
      },

      /**
       * The css classname for the html embed.
       * <b>IMPORTANT</b> Paddings and borders does not work
       * in the css class. These styles cause conflicts with
       * the layout engine.
       */
      cssClass: {
        check: "String",
        init: "",
        apply: "_applyCssClass"
      },
      // overridden
      selectable: {
        refine: true,
        init: true
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      getFocusElement: function getFocusElement() {
        return this.getContentElement();
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyHtml: function _applyHtml(value, old) {
        var elem = this.getContentElement(); // Workaround for http://bugzilla.qooxdoo.org/show_bug.cgi?id=7679

        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") == 9) {
          elem.setStyle("position", "relative");
        } // Insert HTML content


        elem.setAttribute("html", value || "");
      },
      // property apply
      _applyCssClass: function _applyCssClass(value, old) {
        this.getContentElement().removeClass(old);
        this.getContentElement().addClass(value);
      },
      // overridden
      _applySelectable: function _applySelectable(value) {
        qx.ui.embed.Html.prototype._applySelectable.base.call(this, value);
        /*
         * We have to set the value to "text" in Webkit for the content element
         */


        if (qx.core.Environment.get("engine.name") == "webkit") {
          this.getContentElement().setStyle("userSelect", value ? "text" : "none");
        }
      },

      /*
      ---------------------------------------------------------------------------
        FONT SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyFont: function _applyFont(value, old) {
        var styles = value ? qx.theme.manager.Font.getInstance().resolve(value).getStyles() : qx.bom.Font.getDefaultStyles(); // check if text color already set - if so this local value has higher priority

        if (this.getTextColor() != null) {
          delete styles["color"];
        }

        this.getContentElement().setStyles(styles);
      },

      /*
      ---------------------------------------------------------------------------
        TEXT COLOR SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyTextColor: function _applyTextColor(value, old) {
        if (value) {
          this.getContentElement().setStyle("color", qx.theme.manager.Color.getInstance().resolve(value));
        } else {
          this.getContentElement().removeStyle("color");
        }
      }
    }
  });
  qx.ui.embed.Html.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.util.DeferredCall": {
        "construct": true
      },
      "qx.html.Canvas": {},
      "qx.event.type.Data": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The Canvas widget embeds the HMTL canvas element
   * [<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#the-canvas">W3C-HTML5</a>]
   *
   * Note: This widget does not work in Internet Explorer < 9!
   * Check for browser support with qx.core.Environment.get("html.canvas").
   *
   * To paint something on the canvas and keep the content updated on resizes you
   * either have to override the {@link #_draw} method or redraw the content on
   * the {@link #redraw} event. The drawing context can be obtained by {@link #getContext2d}.
   *
   * Note that this widget operates on two different coordinate systems. The canvas
   * has its own coordinate system for drawing operations. This canvas coordinate
   * system is scaled to fit actual size of the DOM element. Each time the size of
   * the canvas dimensions is changed a redraw is required. In this case the
   * protected method {@link #_draw} is called and the event {@link #redraw}
   * is fired. You can synchronize the internal canvas dimension with the
   * CSS dimension of the canvas element by setting {@link #syncDimension} to
   * <code>true</code>.
   *
   * *Example*
   *
   * Here is a little example of how to use the canvas widget.
   *
   * <pre class='javascript'>
   * var canvas = new qx.ui.embed.Canvas().set({
   *   canvasWidth: 200,
   *   canvasHeight: 200,
   *   syncDimension: true
   * });
   * canvas.addListener("redraw", function(e)
   * {
   *   var data = e.getData();
   *   var width = data.width;
   *   var height = data.height;
   *   var ctx = data.context;
   *
   *   ctx.fillStyle = "rgb(200,0,0)";
   *   ctx.fillRect (20, 20, width-5, height-5);
   *
   *   ctx.fillStyle = "rgba(0, 0, 200, 0.5)";
   *   ctx.fillRect (70, 70, 105, 100);
   * }, this);
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/canvas.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.embed.Canvas", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param canvasWidth {Integer} The internal with of the canvas coordinates.
     * @param canvasHeight {Integer} The internal height of the canvas coordinates.
     */
    construct: function construct(canvasWidth, canvasHeight) {
      qx.ui.core.Widget.constructor.call(this);
      this.__deferredDraw = new qx.util.DeferredCall(this.__redraw, this);
      this.addListener("resize", this._onResize, this);

      if (canvasWidth !== undefined) {
        this.setCanvasWidth(canvasWidth);
      }

      if (canvasHeight !== undefined) {
        this.setCanvasHeight(canvasHeight);
      }
    },

    /*
     *****************************************************************************
        EVENTS
     *****************************************************************************
     */
    events: {
      /**
       * The redraw event is fired each time the canvas dimension change and the
       * canvas needs to be updated. The data field contains a map containing the
       * <code>width</code> and <code>height</code> of the canvas and the
       * rendering <code>context</code>.
       */
      "redraw": "qx.event.type.Data"
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    properties: {
      /** Whether canvas and widget coordinates should be synchronized */
      syncDimension: {
        check: "Boolean",
        init: false
      },

      /** The internal with of the canvas coordinates */
      canvasWidth: {
        check: "Integer",
        init: 300,
        apply: "_applyCanvasWidth"
      },

      /** The internal height of the canvas coordinates */
      canvasHeight: {
        check: "Integer",
        init: 150,
        apply: "_applyCanvasHeight"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.util.DeferredCall} */
      __deferredDraw: null,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createContentElement: function _createContentElement() {
        return new qx.html.Canvas();
      },

      /**
       * This methods triggers the redraw of the canvas' content
       */
      __redraw: function __redraw() {
        var canvas = this.getContentElement();
        var height = canvas.getHeight();
        var width = canvas.getWidth();
        var context = canvas.getContext2d();

        this._draw(width, height, context);

        this.fireNonBubblingEvent("redraw", qx.event.type.Data, [{
          width: width,
          height: height,
          context: context
        }]);
      },
      // property apply
      _applyCanvasWidth: function _applyCanvasWidth(value, old) {
        this.getContentElement().setWidth(value);

        this.__deferredDraw.schedule();
      },
      // property apply
      _applyCanvasHeight: function _applyCanvasHeight(value, old) {
        this.getContentElement().setHeight(value);

        this.__deferredDraw.schedule();
      },

      /**
       * Redraw the canvas
       */
      update: function update() {
        this.__deferredDraw.schedule();
      },

      /**
       * Widget resize event handler. Updates the canvas dimension if needed.
       *
       * @param e {qx.event.type.Data} The resize event object
       */
      _onResize: function _onResize(e) {
        var data = e.getData();

        if (this.getSyncDimension()) {
          this.setCanvasHeight(data.height);
          this.setCanvasWidth(data.width);
        }
      },

      /**
       * Get the native canvas 2D rendering context
       * [<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasrenderingcontext2d">W3C-HTML5</a>].
       * All drawing operations are performed on this context.
       *
       * @return {CanvasRenderingContext2D} The 2D rendering context.
       */
      getContext2d: function getContext2d() {
        return this.getContentElement().getContext2d();
      },

      /**
       * Template method, which can be used by derived classes to redraw the
       * content. It is called each time the canvas dimension change and the
       * canvas needs to be updated.
       *
       * @param width {Integer} New canvas width
       * @param height {Integer} New canvas height
       * @param context {CanvasRenderingContext2D} The rendering context to draw to
       */
      _draw: function _draw(width, height, context) {}
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this._disposeObjects("__deferredDraw");
    }
  });
  qx.ui.embed.Canvas.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Til Schneider (til132)
       * Jonathan Weiß (jonathan_rass)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Abstract base class for iframe widgets.
   */
  qx.Class.define("qx.ui.embed.AbstractIframe", {
    extend: qx.ui.core.Widget,

    /**
     * @param source {String} URL which should initially set.
     */
    construct: function construct(source) {
      qx.ui.core.Widget.constructor.call(this);

      if (source) {
        this.setSource(source);
      }

      this._getIframeElement().addListener("navigate", this.__onNavigate, this);
    },
    events: {
      /**
       * The "load" event is fired after the iframe content has successfully been loaded.
       */
      "load": "qx.event.type.Event",

      /**
      * The "navigate" event is fired whenever the location of the iframe
      * changes.
      *
      * Useful to track user navigation and internally used to keep the source
      * property in sync. Only works when the destination source is of same
      * origin than the page embedding the iframe.
      */
      "navigate": "qx.event.type.Data"
    },
    properties: {
      /**
       * Source URL of the iframe.
       */
      source: {
        check: "String",
        apply: "_applySource",
        init: "about:blank"
      },

      /**
       * Name of the iframe.
       */
      frameName: {
        check: "String",
        init: "",
        apply: "_applyFrameName"
      }
    },
    members: {
      /**
       * Get the Element wrapper for the iframe
       *
       * @abstract
       * @return {qx.html.Iframe} the iframe element wrapper
       */
      _getIframeElement: function _getIframeElement() {
        throw new Error("Abstract method call");
      },
      // property apply
      _applySource: function _applySource(value, old) {
        this._getIframeElement().setSource(value);
      },
      // property apply
      _applyFrameName: function _applyFrameName(value, old) {
        this._getIframeElement().setAttribute("name", value);
      },

      /**
       * Get the DOM window object of an iframe.
       *
       * @return {Window} The DOM window object of the iframe.
       */
      getWindow: function getWindow() {
        return this._getIframeElement().getWindow();
      },

      /**
       * Get the DOM document object of an iframe.
       *
       * @return {Document} The DOM document object of the iframe.
       */
      getDocument: function getDocument() {
        return this._getIframeElement().getDocument();
      },

      /**
       * Get the HTML body element of the iframe.
       *
       * @return {Element} The DOM node of the <code>body</code> element of the iframe.
       */
      getBody: function getBody() {
        return this._getIframeElement().getBody();
      },

      /**
       * Get the current name.
       *
       * @return {String} The iframe's name.
       */
      getName: function getName() {
        return this._getIframeElement().getName();
      },

      /**
       * Reload the contents of the iframe.
       *
       */
      reload: function reload() {
        this._getIframeElement().reload();
      },

      /**
      * Handle user navigation. Sync actual URL of iframe with source property.
      *
      * @param e {qx.event.type.Data} navigate event
      */
      __onNavigate: function __onNavigate(e) {
        var actualUrl = e.getData();

        if (actualUrl) {
          this.setSource(actualUrl);
        }

        this.fireDataEvent("navigate", actualUrl);
      }
    }
  });
  qx.ui.embed.AbstractIframe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.embed.AbstractIframe": {
        "construct": true,
        "require": true
      },
      "qx.event.Registration": {
        "construct": true
      },
      "qx.bom.client.EcmaScript": {
        "construct": true
      },
      "qx.bom.Event": {
        "construct": true
      },
      "qx.lang.Function": {
        "construct": true
      },
      "qx.html.Iframe": {},
      "qx.html.Blocker": {},
      "qx.bom.client.Event": {},
      "qx.bom.client.Browser": {},
      "qx.bom.Iframe": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "ecmascript.mutationobserver": {
          "construct": true,
          "className": "qx.bom.client.EcmaScript"
        },
        "event.help": {
          "className": "qx.bom.client.Event"
        },
        "browser.name": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Til Schneider (til132)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Container widget for internal frames (iframes).
   * An iframe can display any HTML page inside the widget.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   * var document = this.getRoot();
   * var iframe = new qx.ui.embed.Iframe("http://www.qooxdoo.org");
   * document.add(iframe);
   * </pre>
   *
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/iframe.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   * 
   * 
   * *Notes*
   * When modifying this file, note that the test qx.test.ui.embed.Iframe.testSyncSourceAfterDOMMove
   * has been disabled under Chrome because of problems with Travis and Github.  Changes to this file
   * should be tested manually against that test.
   */
  qx.Class.define("qx.ui.embed.Iframe", {
    extend: qx.ui.embed.AbstractIframe,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @ignore(MutationObserver)
     * @param source {String} URL which should initially set.
     */
    construct: function construct(source) {
      if (source != null) {
        this.__source = source;
      }

      qx.ui.embed.AbstractIframe.constructor.call(this, source);
      qx.event.Registration.addListener(document.body, "pointerdown", this.block, this, true);
      qx.event.Registration.addListener(document.body, "pointerup", this.release, this, true);
      qx.event.Registration.addListener(document.body, "losecapture", this.release, this, true);
      this.__blockerElement = this._createBlockerElement();

      if (qx.core.Environment.get("ecmascript.mutationobserver")) {
        this.addListenerOnce("appear", function () {
          var element = this.getContentElement().getDomElement(); // Mutation record check callback

          var isDOMNodeInserted = function isDOMNodeInserted(mutationRecord) {
            var i; // 'our' iframe was either added...

            if (mutationRecord.addedNodes) {
              for (i = mutationRecord.addedNodes.length; i >= 0; --i) {
                if (mutationRecord.addedNodes[i] == element) {
                  return true;
                }
              }
            } // ...or removed


            if (mutationRecord.removedNodes) {
              for (i = mutationRecord.removedNodes.length; i >= 0; --i) {
                if (mutationRecord.removedNodes[i] == element) {
                  return true;
                }
              }
            }

            return false;
          };

          var observer = new MutationObserver(function (mutationRecords) {
            if (mutationRecords.some(isDOMNodeInserted)) {
              this._syncSourceAfterDOMMove();
            }
          }.bind(this)); // Observe parent element

          var parent = this.getLayoutParent().getContentElement().getDomElement();
          observer.observe(parent, {
            childList: true,
            subtree: true
          });
        }, this);
      } else // !qx.core.Environment.get("ecmascript.mutationobserver")
        {
          this.addListenerOnce("appear", function () {
            var element = this.getContentElement().getDomElement();
            qx.bom.Event.addNativeListener(element, "DOMNodeInserted", this._onDOMNodeInserted);
          }, this);
          this._onDOMNodeInserted = qx.lang.Function.listener(this._syncSourceAfterDOMMove, this);
        }
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "iframe"
      },

      /**
       * Whether to show the frame's native context menu.
       *
       * Note: This only works if the iframe source is served from the same domain
       * as the main application.
       */
      nativeContextMenu: {
        refine: true,
        init: false
      },

      /**
       * If the user presses F1 in IE by default the onhelp event is fired and
       * IE’s help window is opened. Setting this property to <code>false</code>
       * prevents this behavior.
       *
       * Note: This only works if the iframe source is served from the same domain
       * as the main application.
       */
      nativeHelp: {
        check: "Boolean",
        init: false,
        apply: "_applyNativeHelp"
      },

      /**
       * Whether the widget should have scrollbars.
       */
      scrollbar: {
        check: ["auto", "no", "yes"],
        nullable: true,
        themeable: true,
        apply: "_applyScrollbar"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __source: null,
      __blockerElement: null,
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        qx.ui.embed.Iframe.prototype.renderLayout.base.call(this, left, top, width, height);
        var pixel = "px";
        var insets = this.getInsets();

        this.__blockerElement.setStyles({
          "left": left + insets.left + pixel,
          "top": top + insets.top + pixel,
          "width": width - insets.left - insets.right + pixel,
          "height": height - insets.top - insets.bottom + pixel
        });
      },
      // overridden
      _createContentElement: function _createContentElement() {
        var iframe = new qx.html.Iframe(this.__source);
        iframe.addListener("load", this._onIframeLoad, this);
        return iframe;
      },
      // overridden
      _getIframeElement: function _getIframeElement() {
        return this.getContentElement();
      },

      /**
       * Creates <div> element which is aligned over iframe node to avoid losing pointer events.
       *
       * @return {Object} Blocker element node
       */
      _createBlockerElement: function _createBlockerElement() {
        var el = new qx.html.Blocker();
        el.setStyles({
          "zIndex": 20,
          "display": "none"
        });
        return el;
      },

      /**
       * Reacts on native load event and redirects it to the widget.
       *
       * @param e {qx.event.type.Event} Native load event
       */
      _onIframeLoad: function _onIframeLoad(e) {
        this._applyNativeContextMenu(this.getNativeContextMenu(), null);

        this._applyNativeHelp(this.getNativeHelp(), null);

        this.fireNonBubblingEvent("load");
      },

      /*
      ---------------------------------------------------------------------------
        METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Cover the iframe with a transparent blocker div element. This prevents
       * pointer or key events to be handled by the iframe. To release the blocker
       * use {@link #release}.
       *
       */
      block: function block() {
        this.__blockerElement.setStyle("display", "block");
      },

      /**
       * Release the blocker set by {@link #block}.
       *
       */
      release: function release() {
        this.__blockerElement.setStyle("display", "none");
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyNativeContextMenu: function _applyNativeContextMenu(value, old) {
        if (value !== false && old !== false) {
          return;
        }

        var doc = this.getDocument();

        if (!doc) {
          return;
        }

        try {
          var documentElement = doc.documentElement;
        } catch (e) {
          // this may fail due to security restrictions
          return;
        }

        if (old === false) {
          qx.event.Registration.removeListener(documentElement, "contextmenu", this._onNativeContextMenu, this, true);
        }

        if (value === false) {
          qx.event.Registration.addListener(documentElement, "contextmenu", this._onNativeContextMenu, this, true);
        }
      },

      /**
       * Stops the <code>contextmenu</code> event from showing the native context menu
       *
       * @param e {qx.event.type.Mouse} The event object
       */
      _onNativeContextMenu: function _onNativeContextMenu(e) {
        e.preventDefault();
      },
      // property apply
      _applyNativeHelp: function _applyNativeHelp(value, old) {
        if (qx.core.Environment.get("event.help")) {
          var document = this.getDocument();

          if (!document) {
            return;
          }

          try {
            if (old === false) {
              qx.bom.Event.removeNativeListener(document, "help", function () {
                return false;
              });
            }

            if (value === false) {
              qx.bom.Event.addNativeListener(document, "help", function () {
                return false;
              });
            }
          } catch (e) {
            {
              this.warn("Unable to set 'nativeHelp' property, possibly due to security restrictions");
            }
          }
        }
      },

      /**
       * Checks if the iframe element is out of sync. This can happen in Firefox
       * if the iframe is moved around and the source is changed right after.
       * The root cause is that Firefox is reloading the iframe when its position
       * in DOM has changed.
       */
      _syncSourceAfterDOMMove: function _syncSourceAfterDOMMove() {
        var iframeDomElement = this.getContentElement() && this.getContentElement().getDomElement();

        if (!iframeDomElement) {
          return;
        }

        var iframeSource = iframeDomElement.src; // remove trailing "/"

        if (iframeSource.charAt(iframeSource.length - 1) == "/") {
          iframeSource = iframeSource.substring(0, iframeSource.length - 1);
        }

        if (iframeSource != this.getSource()) {
          if (qx.core.Environment.get("browser.name") != "edge" && qx.core.Environment.get("browser.name") != "ie") {
            qx.bom.Iframe.getWindow(iframeDomElement).stop();
          }

          iframeDomElement.src = this.getSource();
        }
      },
      // property apply
      _applyScrollbar: function _applyScrollbar(value) {
        this.getContentElement().setAttribute("scrolling", value);
      },
      // overridden
      setLayoutParent: function setLayoutParent(parent) {
        qx.ui.embed.Iframe.prototype.setLayoutParent.base.call(this, parent);

        if (parent) {
          this.getLayoutParent().getContentElement().add(this.__blockerElement);
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this.getLayoutParent() && this.__blockerElement.getParent()) {
        this.getLayoutParent().getContentElement().remove(this.__blockerElement);
      }

      this._disposeObjects("__blockerElement");

      qx.event.Registration.removeListener(document.body, "pointerdown", this.block, this, true);
      qx.event.Registration.removeListener(document.body, "pointerup", this.release, this, true);
      qx.event.Registration.removeListener(document.body, "losecapture", this.release, this, true);
    }
  });
  qx.ui.embed.Iframe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.core.MRemoteLayoutHandling": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.layout.Canvas": {
        "construct": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.basic.Atom": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Group boxes are used to group a set of form elements.
   *
   * @childControl frame {qx.ui.container.Composite} frame for the content widgets
   * @childControl legend {qx.ui.basic.Atom} legend to show at top of the groupbox
   */
  qx.Class.define("qx.ui.groupbox.GroupBox", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.core.MRemoteLayoutHandling, qx.ui.core.MContentPadding, qx.ui.form.MForm],
    implement: [qx.ui.form.IForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param legend {String?""} The group boxes legend
     * @param icon {String?""} The icon of the legend
     */
    construct: function construct(legend, icon) {
      qx.ui.core.Widget.constructor.call(this);

      this._setLayout(new qx.ui.layout.Canvas()); // Sub widgets


      this._createChildControl("frame");

      this._createChildControl("legend"); // Processing parameters


      if (legend != null) {
        this.setLegend(legend);
      }

      if (icon != null) {
        this.setIcon(icon);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "groupbox"
      },

      /**
       * Label of the legend sub widget. Set if the given string is
       * valid. Otherwise the legend sub widget is not being displayed.
       */
      legend: {
        check: "String",
        apply: "_applyLegend",
        event: "changeLegend",
        nullable: true
      },

      /**
       * Property for setting the position of the legend.
       */
      legendPosition: {
        check: ["top", "middle"],
        init: "middle",
        apply: "_applyLegendPosition",
        themeable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        invalid: true
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "frame":
            control = new qx.ui.container.Composite();

            this._add(control, {
              left: 0,
              top: 6,
              right: 0,
              bottom: 0
            });

            break;

          case "legend":
            control = new qx.ui.basic.Atom();
            control.addListener("resize", this._repositionFrame, this);

            this._add(control, {
              left: 0,
              right: 0
            });

            break;
        }

        return control || qx.ui.groupbox.GroupBox.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getChildControl("frame");
      },

      /*
      ---------------------------------------------------------------------------
        LEGEND HANDLING
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyLegend: function _applyLegend(value, old) {
        var control = this.getChildControl("legend");

        if (value !== null) {
          control.setLabel(value);
          control.show();
        } else {
          control.exclude();
        }
      },

      /**
       * Apply method for applying the legend position. It calls the
       * {@link #_repositionFrame} method.
       */
      _applyLegendPosition: function _applyLegendPosition(e) {
        if (this.getChildControl("legend").getBounds()) {
          this._repositionFrame();
        }
      },

      /**
       * Repositions the frame of the group box dependent on the
       * {@link #legendPosition} property.
       */
      _repositionFrame: function _repositionFrame() {
        var legend = this.getChildControl("legend");
        var frame = this.getChildControl("frame"); // get the current height of the legend

        var height = legend.getBounds().height; // check for the property legend position

        if (this.getLegendPosition() == "middle") {
          frame.setLayoutProperties({
            "top": Math.round(height / 2)
          });
        } else if (this.getLegendPosition() == "top") {
          frame.setLayoutProperties({
            "top": height
          });
        }
      },

      /*
      ---------------------------------------------------------------------------
        GETTER FOR SUB WIDGETS
      ---------------------------------------------------------------------------
      */

      /**
       * The children container needed by the {@link qx.ui.core.MRemoteChildrenHandling}
       * mixin
       *
       * @return {qx.ui.container.Composite} pane sub widget
       */
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("frame");
      },

      /*
      ---------------------------------------------------------------------------
        SETTER/GETTER
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the icon of the legend sub widget.
       *
       * @param icon {String} source of the new icon of the legend sub widget
       */
      setIcon: function setIcon(icon) {
        this.getChildControl("legend").setIcon(icon);
      },

      /**
       * Accessor method for the icon of the legend sub widget
       *
       * @return {String} source of the new icon of the legend sub widget
       */
      getIcon: function getIcon() {
        return this.getChildControl("legend").getIcon();
      }
    }
  });
  qx.ui.groupbox.GroupBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.groupbox.GroupBox": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.CheckBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * A group box, which has a check box near the legend.
   *
   * @childControl legend {qx.ui.form.CheckBox} checkbox to en-/disable the
   *   groupbox content
   */
  qx.Class.define("qx.ui.groupbox.CheckGroupBox", {
    extend: qx.ui.groupbox.GroupBox,
    implement: [qx.ui.form.IExecutable, qx.ui.form.IBooleanForm, qx.ui.form.IModel],
    include: [qx.ui.form.MModelProperty],
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "check-groupbox"
      }
    },
    events: {
      /** Fired when the included checkbox changed its value */
      "changeValue": "qx.event.type.Data",

      /** Fired if the {@link #execute} method is invoked.*/
      "execute": "qx.event.type.Event"
    },
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "legend":
            control = new qx.ui.form.CheckBox();
            control.setValue(true);
            control.setAllowGrowX(true);
            control.addListener("changeValue", this._onRadioChangeValue, this);
            control.addListener("resize", this._repositionFrame, this);
            control.addListener("execute", this._onExecute, this);

            this._add(control, {
              left: 0,
              right: 0
            });

        }

        return control || qx.ui.groupbox.CheckGroupBox.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.groupbox.CheckGroupBox.prototype._applyEnabled.base.call(this, value, old);

        this.getChildrenContainer().setEnabled(value && this.getValue());
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for execute event of checkbox.
       *
       * @param e {qx.event.type.Event} Event which holds the current status
       */
      _onExecute: function _onExecute(e) {
        this.fireEvent("execute");
      },

      /**
       * Event listener for change event of checkbox
       *
       * @param e {qx.event.type.Data} Data event which holds the current status
       */
      _onRadioChangeValue: function _onRadioChangeValue(e) {
        var checked = e.getData() ? true : false; // Disable content

        this.getChildrenContainer().setEnabled(checked); // Fire event to the outside

        this.fireDataEvent("changeValue", checked, e.getOldData());
      },

      /*
      ---------------------------------------------------------------------------
        REDIRECTIONS TO LEGEND (CHECKBOX COMPATIBILITY MODE)
      ---------------------------------------------------------------------------
      */
      // interface implementation
      execute: function execute() {
        this.getChildControl("legend").execute();
      },
      // interface implementation
      setCommand: function setCommand(command) {
        this.getChildControl("legend").setCommand(command);
      },
      // interface implementation
      getCommand: function getCommand() {
        return this.getChildControl("legend").getCommand();
      },

      /**
       * The value of the groupbox.
       *
       * @return {Boolean} <code>true</code> when enabled.
       */
      getValue: function getValue() {
        return this.getChildControl("legend").getValue();
      },

      /**
       * Configures the value of the groupbox.
       *
       * @param value {Boolean} <code>true</code> when enabled.
       */
      setValue: function setValue(value) {
        this.getChildControl("legend").setValue(value);
      },

      /**
       * Resets the value.
       */
      resetValue: function resetValue() {
        this.getChildControl("legend").resetValue();
      }
    }
  });
  qx.ui.groupbox.CheckGroupBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.groupbox.GroupBox": {
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.RadioButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * A group box, which has a radio button near the legend.
   *
   * @childControl legend {qx.ui.form.RadioButton} radio button to en-/disable the groupbox content
   */
  qx.Class.define("qx.ui.groupbox.RadioGroupBox", {
    extend: qx.ui.groupbox.GroupBox,
    implement: [qx.ui.form.IRadioItem, qx.ui.form.IExecutable, qx.ui.form.IBooleanForm, qx.ui.form.IModel],
    include: [qx.ui.form.MModelProperty],

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "radio-groupbox"
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the included radiobutton changed its value */
      "changeValue": "qx.event.type.Data",

      /** Fired if the {@link #execute} method is invoked.*/
      "execute": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "legend":
            control = new qx.ui.form.RadioButton();
            control.setAllowGrowX(true);
            control.setValue(true);
            control.addListener("changeValue", this._onRadioChangeValue, this);
            control.addListener("resize", this._repositionFrame, this);
            control.addListener("execute", this._onExecute, this);

            this._add(control, {
              left: 0,
              right: 0
            });

        }

        return control || qx.ui.groupbox.RadioGroupBox.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.groupbox.RadioGroupBox.prototype._applyEnabled.base.call(this, value, old);

        this.getChildrenContainer().setEnabled(value && this.getValue());
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for execute event of checkbox.
       *
       * @param e {qx.event.type.Event} Event which holds the current status
       */
      _onExecute: function _onExecute(e) {
        this.fireEvent("execute");
      },

      /**
       * Event listener for changeValue event of radio button
       *
       * @param e {qx.event.type.Data} Data event which holds the current status
       */
      _onRadioChangeValue: function _onRadioChangeValue(e) {
        var checked = e.getData() ? true : false; // Disable content

        this.getChildrenContainer().setEnabled(checked); // Fire event to the outside

        this.fireDataEvent("changeValue", checked, e.getOldData());
      },

      /*
      ---------------------------------------------------------------------------
        REDIRECTIONS TO LEGEND (FOR RADIO GROUP SUPPORT)
      ---------------------------------------------------------------------------
      */
      // interface implementation
      execute: function execute() {
        this.getChildControl("legend").execute();
      },
      // interface implementation
      setCommand: function setCommand(command) {
        this.getChildControl("legend").setCommand(command);
      },
      // interface implementation
      getCommand: function getCommand() {
        return this.getChildControl("legend").getCommand();
      },

      /**
       * Returns the radio group
       *
       * @return {qx.ui.form.RadioGroup} The radio manager
       */
      getGroup: function getGroup() {
        return this.getChildControl("legend").getGroup();
      },

      /**
       * Sets the radio group to use
       *
       * @param value {qx.ui.form.RadioGroup} The radio group to use
       */
      setGroup: function setGroup(value) {
        if (value != null) {
          value.add(this);
        }

        return;
      },

      /**
       * The value of the groupbox
       *
       * @return {Boolean} <code>true</code> when enabled.
       */
      getValue: function getValue() {
        return this.getChildControl("legend").getValue();
      },

      /**
       * Configures the value of the groupbox.
       *
       * @param value {Boolean} <code>true</code> when enabled.
       */
      setValue: function setValue(value) {
        this.getChildControl("legend").setValue(value);
      },

      /**
       * Resets the value.
       */
      resetValue: function resetValue() {
        this.getChildControl("legend").resetValue();
      },

      /**
       * Returns the configured legend. Only used for RadioManager compatibility.
       *
       * @return {String} The configured legend.
       */
      getLabel: function getLabel() {
        return this.getChildControl("legend").getLabel();
      }
    }
  });
  qx.ui.groupbox.RadioGroupBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MPlacement": {
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.menu.Layout": {
        "construct": true
      },
      "qx.ui.core.Blocker": {
        "construct": true
      },
      "qx.ui.menu.Separator": {},
      "qx.ui.menu.Manager": {},
      "qx.ui.menu.AbstractButton": {},
      "qx.ui.menu.MenuSlideBar": {},
      "qx.ui.layout.Grow": {},
      "qx.lang.Array": {},
      "qx.ui.core.queue.Widget": {},
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The menu is a popup like control which supports buttons. It comes
   * with full keyboard navigation and an improved timeout based pointer
   * control behavior.
   *
   * This class is the container for all derived instances of
   * {@link qx.ui.menu.AbstractButton}.
   *
   * @childControl slidebar {qx.ui.menu.MenuSlideBar} shows a slidebar to easily navigate inside the menu (if too little space is left)
   */
  qx.Class.define("qx.ui.menu.Menu", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MPlacement, qx.ui.core.MRemoteChildrenHandling],
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // Use hard coded layout

      this._setLayout(new qx.ui.menu.Layout()); // Automatically add to application's root


      var root = this.getApplicationRoot();
      root.add(this); // Register pointer listeners

      this.addListener("pointerover", this._onPointerOver);
      this.addListener("pointerout", this._onPointerOut); // add resize listener

      this.addListener("resize", this._onResize, this);
      root.addListener("resize", this._onResize, this);
      this._blocker = new qx.ui.core.Blocker(root); // Initialize properties

      this.initVisibility();
      this.initKeepFocus();
      this.initKeepActive();
    },
    properties: {
      /*
      ---------------------------------------------------------------------------
        WIDGET PROPERTIES
      ---------------------------------------------------------------------------
      */
      // overridden
      appearance: {
        refine: true,
        init: "menu"
      },
      // overridden
      allowGrowX: {
        refine: true,
        init: false
      },
      // overridden
      allowGrowY: {
        refine: true,
        init: false
      },
      // overridden
      visibility: {
        refine: true,
        init: "excluded"
      },
      // overridden
      keepFocus: {
        refine: true,
        init: true
      },
      // overridden
      keepActive: {
        refine: true,
        init: true
      },

      /*
      ---------------------------------------------------------------------------
        STYLE OPTIONS
      ---------------------------------------------------------------------------
      */

      /** The spacing between each cell of the menu buttons */
      spacingX: {
        check: "Integer",
        apply: "_applySpacingX",
        init: 0,
        themeable: true
      },

      /** The spacing between each menu button */
      spacingY: {
        check: "Integer",
        apply: "_applySpacingY",
        init: 0,
        themeable: true
      },

      /**
      * Default icon column width if no icons are rendered.
      * This property is ignored as soon as an icon is present.
      */
      iconColumnWidth: {
        check: "Integer",
        init: 0,
        themeable: true,
        apply: "_applyIconColumnWidth"
      },

      /** Default arrow column width if no sub menus are rendered */
      arrowColumnWidth: {
        check: "Integer",
        init: 0,
        themeable: true,
        apply: "_applyArrowColumnWidth"
      },

      /**
       * Color of the blocker
       */
      blockerColor: {
        check: "Color",
        init: null,
        nullable: true,
        apply: "_applyBlockerColor",
        themeable: true
      },

      /**
       * Opacity of the blocker
       */
      blockerOpacity: {
        check: "Number",
        init: 1,
        apply: "_applyBlockerOpacity",
        themeable: true
      },

      /*
      ---------------------------------------------------------------------------
        FUNCTIONALITY PROPERTIES
      ---------------------------------------------------------------------------
      */

      /** The currently selected button */
      selectedButton: {
        check: "qx.ui.core.Widget",
        nullable: true,
        apply: "_applySelectedButton"
      },

      /** The currently opened button (sub menu is visible) */
      openedButton: {
        check: "qx.ui.core.Widget",
        nullable: true,
        apply: "_applyOpenedButton"
      },

      /** Widget that opened the menu */
      opener: {
        check: "qx.ui.core.Widget",
        nullable: true
      },

      /*
      ---------------------------------------------------------------------------
        BEHAVIOR PROPERTIES
      ---------------------------------------------------------------------------
      */

      /** Interval in ms after which sub menus should be opened */
      openInterval: {
        check: "Integer",
        themeable: true,
        init: 250,
        apply: "_applyOpenInterval"
      },

      /** Interval in ms after which sub menus should be closed  */
      closeInterval: {
        check: "Integer",
        themeable: true,
        init: 250,
        apply: "_applyCloseInterval"
      },

      /** Blocks the background if value is <code>true<code> */
      blockBackground: {
        check: "Boolean",
        themeable: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __scheduledOpen: null,
      __onAfterSlideBarAdd: null,

      /** @type {qx.ui.core.Blocker} blocker for background blocking */
      _blocker: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Opens the menu and configures the opener
       */
      open: function open() {
        if (this.getOpener() != null) {
          var isPlaced = this.placeToWidget(this.getOpener(), true);

          if (isPlaced) {
            this.__updateSlideBar();

            this.show();
            this._placementTarget = this.getOpener();
          } else {
            this.warn("Could not open menu instance because 'opener' widget is not visible");
          }
        } else {
          this.warn("The menu instance needs a configured 'opener' widget!");
        }
      },

      /**
       * Opens the menu at the pointer position
       *
       * @param e {qx.event.type.Pointer} Pointer event to align to
       */
      openAtPointer: function openAtPointer(e) {
        this.placeToPointer(e);

        this.__updateSlideBar();

        this.show();
        this._placementTarget = {
          left: e.getDocumentLeft(),
          top: e.getDocumentTop()
        };
      },

      /**
       * Opens the menu in relation to the given point
       *
       * @param point {Map} Coordinate of any point with the keys <code>left</code>
       *   and <code>top</code>.
       */
      openAtPoint: function openAtPoint(point) {
        this.placeToPoint(point);

        this.__updateSlideBar();

        this.show();
        this._placementTarget = point;
      },

      /**
       * Convenience method to add a separator to the menu
       */
      addSeparator: function addSeparator() {
        this.add(new qx.ui.menu.Separator());
      },

      /**
       * Returns the column sizes detected during the pre-layout phase
       *
       * @return {Array} List of all column widths
       */
      getColumnSizes: function getColumnSizes() {
        return this._getMenuLayout().getColumnSizes();
      },

      /**
       * Return all selectable menu items.
       *
       * @return {qx.ui.core.Widget[]} selectable widgets
       */
      getSelectables: function getSelectables() {
        var result = [];
        var children = this.getChildren();

        for (var i = 0; i < children.length; i++) {
          if (children[i].isEnabled()) {
            result.push(children[i]);
          }
        }

        return result;
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyIconColumnWidth: function _applyIconColumnWidth(value, old) {
        this._getMenuLayout().setIconColumnWidth(value);
      },
      // property apply
      _applyArrowColumnWidth: function _applyArrowColumnWidth(value, old) {
        this._getMenuLayout().setArrowColumnWidth(value);
      },
      // property apply
      _applySpacingX: function _applySpacingX(value, old) {
        this._getMenuLayout().setColumnSpacing(value);
      },
      // property apply
      _applySpacingY: function _applySpacingY(value, old) {
        this._getMenuLayout().setSpacing(value);
      },
      // overridden
      _applyVisibility: function _applyVisibility(value, old) {
        qx.ui.menu.Menu.prototype._applyVisibility.base.call(this, value, old);

        var mgr = qx.ui.menu.Manager.getInstance();

        if (value === "visible") {
          // Register to manager (zIndex handling etc.)
          mgr.add(this); // Mark opened in parent menu

          var parentMenu = this.getParentMenu();

          if (parentMenu) {
            parentMenu.setOpenedButton(this.getOpener());
          }
        } else if (old === "visible") {
          // Deregister from manager (zIndex handling etc.)
          mgr.remove(this); // Unmark opened in parent menu

          var parentMenu = this.getParentMenu();

          if (parentMenu && parentMenu.getOpenedButton() == this.getOpener()) {
            parentMenu.resetOpenedButton();
          } // Clear properties


          this.resetOpenedButton();
          this.resetSelectedButton();
        }

        this.__updateBlockerVisibility();
      },

      /**
       * Updates the blocker's visibility
       */
      __updateBlockerVisibility: function __updateBlockerVisibility() {
        if (this.isVisible()) {
          if (this.getBlockBackground()) {
            var zIndex = this.getZIndex();

            this._blocker.blockContent(zIndex - 1);
          }
        } else {
          if (this._blocker.isBlocked()) {
            this._blocker.unblock();
          }
        }
      },

      /**
       * Get the parent menu. Returns <code>null</code> if the menu doesn't have a
       * parent menu.
       *
       * @return {qx.ui.core.Widget|null} The parent menu.
       */
      getParentMenu: function getParentMenu() {
        var widget = this.getOpener();

        if (!widget || !(widget instanceof qx.ui.menu.AbstractButton)) {
          return null;
        }

        if (widget && widget.getContextMenu() === this) {
          return null;
        }

        while (widget && !(widget instanceof qx.ui.menu.Menu)) {
          widget = widget.getLayoutParent();
        }

        return widget;
      },
      // property apply
      _applySelectedButton: function _applySelectedButton(value, old) {
        if (old) {
          old.removeState("selected");
        }

        if (value) {
          value.addState("selected");
        }
      },
      // property apply
      _applyOpenedButton: function _applyOpenedButton(value, old) {
        if (old && old.getMenu()) {
          old.getMenu().exclude();
        }

        if (value) {
          value.getMenu().open();
        }
      },
      // property apply
      _applyBlockerColor: function _applyBlockerColor(value, old) {
        this._blocker.setColor(value);
      },
      // property apply
      _applyBlockerOpacity: function _applyBlockerOpacity(value, old) {
        this._blocker.setOpacity(value);
      },

      /*
      ---------------------------------------------------------------------------
      SCROLLING SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("slidebar", true) || this;
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "slidebar":
            var control = new qx.ui.menu.MenuSlideBar();

            var layout = this._getLayout();

            this._setLayout(new qx.ui.layout.Grow());

            var slidebarLayout = control.getLayout();
            control.setLayout(layout);
            slidebarLayout.dispose();
            var children = qx.lang.Array.clone(this.getChildren());

            for (var i = 0; i < children.length; i++) {
              control.add(children[i]);
            }

            this.removeListener("resize", this._onResize, this);
            control.getChildrenContainer().addListener("resize", this._onResize, this);

            this._add(control);

            break;
        }

        return control || qx.ui.menu.Menu.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Get the menu layout manager
       *
       * @return {qx.ui.layout.Abstract} The menu layout manager
       */
      _getMenuLayout: function _getMenuLayout() {
        if (this.hasChildControl("slidebar")) {
          return this.getChildControl("slidebar").getChildrenContainer().getLayout();
        } else {
          return this._getLayout();
        }
      },

      /**
       * Get the menu bounds
       *
       * @return {Map} The menu bounds
       */
      _getMenuBounds: function _getMenuBounds() {
        if (this.hasChildControl("slidebar")) {
          return this.getChildControl("slidebar").getChildrenContainer().getBounds();
        } else {
          return this.getBounds();
        }
      },

      /**
       * Computes the size of the menu. This method is used by the
       * {@link qx.ui.core.MPlacement} mixin.
       * @return {Map} The menu bounds
       */
      _computePlacementSize: function _computePlacementSize() {
        return this._getMenuBounds();
      },

      /**
       * Updates the visibility of the slidebar based on the menu's current size
       * and position.
       */
      __updateSlideBar: function __updateSlideBar() {
        var menuBounds = this._getMenuBounds();

        if (!menuBounds) {
          this.addListenerOnce("resize", this.__updateSlideBar, this);
          return;
        }

        var rootHeight = this.getLayoutParent().getBounds().height;
        var top = this.getLayoutProperties().top;
        var left = this.getLayoutProperties().left; // Adding the slidebar must be deferred because this call can happen
        // during the layout flush, which make it impossible to move existing
        // layout to the slidebar

        if (top < 0) {
          this._assertSlideBar(function () {
            this.setHeight(menuBounds.height + top);
            this.moveTo(left, 0);
          });
        } else if (top + menuBounds.height > rootHeight) {
          this._assertSlideBar(function () {
            this.setHeight(rootHeight - top);
          });
        } else {
          this.setHeight(null);
        }
      },

      /**
       * Schedules the addition of the slidebar and calls the given callback
       * after the slidebar has been added.
       *
       * @param callback {Function} the callback to call
       * @return {var|undefined} The return value of the callback if the slidebar
       * already exists, or <code>undefined</code> if it doesn't
       */
      _assertSlideBar: function _assertSlideBar(callback) {
        if (this.hasChildControl("slidebar")) {
          return callback.call(this);
        }

        this.__onAfterSlideBarAdd = callback;
        qx.ui.core.queue.Widget.add(this);
      },
      // overridden
      syncWidget: function syncWidget(jobs) {
        this.getChildControl("slidebar");

        if (this.__onAfterSlideBarAdd) {
          this.__onAfterSlideBarAdd.call(this);

          delete this.__onAfterSlideBarAdd;
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Update position if the menu or the root is resized
       */
      _onResize: function _onResize() {
        if (this.isVisible()) {
          var target = this._placementTarget;

          if (!target) {
            return;
          } else if (target instanceof qx.ui.core.Widget) {
            this.placeToWidget(target, true);
          } else if (target.top !== undefined) {
            this.placeToPoint(target);
          } else {
            throw new Error("Unknown target: " + target);
          }

          this.__updateSlideBar();
        }
      },

      /**
       * Event listener for pointerover event.
       *
       * @param e {qx.event.type.Pointer} pointerover event
       */
      _onPointerOver: function _onPointerOver(e) {
        // Cache manager
        var mgr = qx.ui.menu.Manager.getInstance(); // Be sure this menu is kept

        mgr.cancelClose(this); // Change selection

        var target = e.getTarget();

        if (target.isEnabled() && target instanceof qx.ui.menu.AbstractButton) {
          // Select button directly
          this.setSelectedButton(target);
          var subMenu = target.getMenu && target.getMenu();

          if (subMenu) {
            subMenu.setOpener(target); // Finally schedule for opening

            mgr.scheduleOpen(subMenu); // Remember scheduled menu for opening

            this.__scheduledOpen = subMenu;
          } else {
            var opened = this.getOpenedButton();

            if (opened) {
              mgr.scheduleClose(opened.getMenu());
            }

            if (this.__scheduledOpen) {
              mgr.cancelOpen(this.__scheduledOpen);
              this.__scheduledOpen = null;
            }
          }
        } else if (!this.getOpenedButton()) {
          // When no button is opened reset the selection
          // Otherwise keep it
          this.resetSelectedButton();
        }
      },

      /**
       * Event listener for pointerout event.
       *
       * @param e {qx.event.type.Pointer} pointerout event
       */
      _onPointerOut: function _onPointerOut(e) {
        // Cache manager
        var mgr = qx.ui.menu.Manager.getInstance(); // Detect whether the related target is out of the menu

        if (!qx.ui.core.Widget.contains(this, e.getRelatedTarget())) {
          // Update selected property
          // Force it to the open sub menu in cases where that is opened
          // Otherwise reset it. Menus which are left by the cursor should
          // not show any selection.
          var opened = this.getOpenedButton();
          opened ? this.setSelectedButton(opened) : this.resetSelectedButton(); // Cancel a pending close request for the currently
          // opened sub menu

          if (opened) {
            mgr.cancelClose(opened.getMenu());
          } // When leaving this menu to the outside, stop
          // all pending requests to open any other sub menu


          if (this.__scheduledOpen) {
            mgr.cancelOpen(this.__scheduledOpen);
          }
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (!qx.core.ObjectRegistry.inShutDown) {
        qx.ui.menu.Manager.getInstance().remove(this);
      }

      this.getApplicationRoot().removeListener("resize", this._onResize, this);
      this._placementTarget = null;

      this._disposeObjects("_blocker");
    }
  });
  qx.ui.menu.Menu.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.menu.ButtonLayout": {
        "construct": true
      },
      "qx.ui.basic.Image": {},
      "qx.ui.basic.Label": {},
      "qx.event.Timer": {},
      "qx.ui.menu.Manager": {},
      "qx.locale.Manager": {},
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The abstract menu button class is used for all type of menu content
   * for example normal buttons, checkboxes or radiobuttons.
   *
   * @childControl icon {qx.ui.basic.Image} icon of the button
   * @childControl label {qx.ui.basic.Label} label of the button
   * @childControl shortcut {qx.ui.basic.Label} shows if specified the shortcut
   * @childControl arrow {qx.ui.basic.Image} shows the arrow to show an additional widget (e.g. popup or submenu)
   */
  qx.Class.define("qx.ui.menu.AbstractButton", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MExecutable],
    implement: [qx.ui.form.IExecutable],
    type: "abstract",

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // Use hard coded layout

      this._setLayout(new qx.ui.menu.ButtonLayout()); // Add listeners


      this.addListener("tap", this._onTap);
      this.addListener("keypress", this._onKeyPress); // Add command listener

      this.addListener("changeCommand", this._onChangeCommand, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      blockToolTip: {
        refine: true,
        init: true
      },

      /** The label text of the button */
      label: {
        check: "String",
        apply: "_applyLabel",
        nullable: true,
        event: "changeLabel"
      },

      /** Whether a sub menu should be shown and which one */
      menu: {
        check: "qx.ui.menu.Menu",
        apply: "_applyMenu",
        nullable: true,
        dereference: true,
        event: "changeMenu"
      },

      /** The icon to use */
      icon: {
        check: "String",
        apply: "_applyIcon",
        themeable: true,
        nullable: true,
        event: "changeIcon"
      },

      /** Indicates whether the label for the command (shortcut) should be visible or not. */
      showCommandLabel: {
        check: "Boolean",
        apply: "_applyShowCommandLabel",
        themeable: true,
        init: true,
        event: "changeShowCommandLabel"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "icon":
            control = new qx.ui.basic.Image();
            control.setAnonymous(true);

            this._add(control, {
              column: 0
            });

            break;

          case "label":
            control = new qx.ui.basic.Label();
            control.setAnonymous(true);

            this._add(control, {
              column: 1
            });

            break;

          case "shortcut":
            control = new qx.ui.basic.Label();
            control.setAnonymous(true);

            if (!this.getShowCommandLabel()) {
              control.exclude();
            }

            this._add(control, {
              column: 2
            });

            break;

          case "arrow":
            control = new qx.ui.basic.Image();
            control.setAnonymous(true);

            this._add(control, {
              column: 3
            });

            break;
        }

        return control || qx.ui.menu.AbstractButton.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        selected: 1
      },

      /*
      ---------------------------------------------------------------------------
        LAYOUT UTILS
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the dimensions of all children
       *
       * @return {Array} Preferred width of each child
       */
      getChildrenSizes: function getChildrenSizes() {
        var iconWidth = 0,
            labelWidth = 0,
            shortcutWidth = 0,
            arrowWidth = 0;

        if (this._isChildControlVisible("icon")) {
          var icon = this.getChildControl("icon");
          iconWidth = icon.getMarginLeft() + icon.getSizeHint().width + icon.getMarginRight();
        }

        if (this._isChildControlVisible("label")) {
          var label = this.getChildControl("label");
          labelWidth = label.getMarginLeft() + label.getSizeHint().width + label.getMarginRight();
        }

        if (this._isChildControlVisible("shortcut")) {
          var shortcut = this.getChildControl("shortcut");
          shortcutWidth = shortcut.getMarginLeft() + shortcut.getSizeHint().width + shortcut.getMarginRight();
        }

        if (this._isChildControlVisible("arrow")) {
          var arrow = this.getChildControl("arrow");
          arrowWidth = arrow.getMarginLeft() + arrow.getSizeHint().width + arrow.getMarginRight();
        }

        return [iconWidth, labelWidth, shortcutWidth, arrowWidth];
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for tap
       *
       * @param e {qx.event.type.Pointer} pointer event
       */
      _onTap: function _onTap(e) {
        if (e.isLeftPressed()) {
          this.execute();
          qx.event.Timer.once(qx.ui.menu.Manager.getInstance().hideAll, qx.ui.menu.Manager.getInstance(), 0);
        } // right click
        else {
            // only prevent contextmenu event if button has no further context menu.
            if (!this.getContextMenu()) {
              qx.ui.menu.Manager.getInstance().preventContextMenuOnce();
            }
          }
      },

      /**
       * Event listener for keypress event
       *
       * @param e {qx.event.type.KeySequence} keypress event
       */
      _onKeyPress: function _onKeyPress(e) {
        this.execute();
      },

      /**
       * Event listener for command changes. Updates the text of the shortcut.
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onChangeCommand: function _onChangeCommand(e) {
        var command = e.getData(); // do nothing if no command is set

        if (command == null) {
          return;
        }

        {
          var oldCommand = e.getOldData();

          if (!oldCommand) {
            qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
          }

          if (!command) {
            qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
          }
        }
        var cmdString = command != null ? command.toString() : "";
        this.getChildControl("shortcut").setValue(cmdString);
      },

      /**
       * Update command string on locale changes
       */
      _onChangeLocale: function _onChangeLocale(e) {
        var command = this.getCommand();

        if (command != null) {
          this.getChildControl("shortcut").setValue(command.toString());
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        if (value) {
          this._showChildControl("icon").setSource(value);
        } else {
          this._excludeChildControl("icon");
        }
      },
      // property apply
      _applyLabel: function _applyLabel(value, old) {
        if (value) {
          this._showChildControl("label").setValue(value);
        } else {
          this._excludeChildControl("label");
        }
      },
      // property apply
      _applyMenu: function _applyMenu(value, old) {
        if (old) {
          old.resetOpener();
          old.removeState("submenu");
        }

        if (value) {
          this._showChildControl("arrow");

          value.setOpener(this);
          value.addState("submenu");
        } else {
          this._excludeChildControl("arrow");
        }
      },
      // property apply
      _applyShowCommandLabel: function _applyShowCommandLabel(value, old) {
        if (value) {
          this._showChildControl("shortcut");
        } else {
          this._excludeChildControl("shortcut");
        }
      }
    },

    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct: function destruct() {
      this.removeListener("changeCommand", this._onChangeCommand, this);

      if (this.getMenu()) {
        if (!qx.core.ObjectRegistry.inShutDown) {
          this.getMenu().destroy();
        }
      }

      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
    }
  });
  qx.ui.menu.AbstractButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "require": true
      },
      "qx.lang.Array": {},
      "qx.ui.layout.Util": {},
      "qx.ui.menu.Menu": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Layout used for the menu buttons which may contain four elements. A icon,
   * a label, a shortcut text and an arrow (for a sub menu)
   *
   * @internal
   */
  qx.Class.define("qx.ui.menu.ButtonLayout", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        this.assert(name == "column", "The property '" + name + "' is not supported by the MenuButton layout!");
      },
      // overridden
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        var children = this._getLayoutChildren();

        var child;
        var column;
        var columnChildren = [];

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];
          column = child.getLayoutProperties().column;
          columnChildren[column] = child;
        }

        var menu = this.__getMenu(children[0]);

        var columns = menu.getColumnSizes();
        var spacing = menu.getSpacingX(); // stretch label column

        var neededWidth = qx.lang.Array.sum(columns) + spacing * (columns.length - 1);

        if (neededWidth < availWidth) {
          columns[1] += availWidth - neededWidth;
        }

        var left = padding.left,
            top = padding.top;
        var Util = qx.ui.layout.Util;

        for (var i = 0, l = columns.length; i < l; i++) {
          child = columnChildren[i];

          if (child) {
            var hint = child.getSizeHint();
            var childTop = top + Util.computeVerticalAlignOffset(child.getAlignY() || "middle", hint.height, availHeight, 0, 0);
            var offsetLeft = Util.computeHorizontalAlignOffset(child.getAlignX() || "left", hint.width, columns[i], child.getMarginLeft(), child.getMarginRight());
            child.renderLayout(left + offsetLeft, childTop, hint.width, hint.height);
          }

          if (columns[i] > 0) {
            left += columns[i] + spacing;
          }
        }
      },

      /**
       * Get the widget's menu
       *
       * @param widget {qx.ui.core.Widget} the widget to get the menu for
       * @return {qx.ui.menu.Menu} the menu
       */
      __getMenu: function __getMenu(widget) {
        while (!(widget instanceof qx.ui.menu.Menu)) {
          widget = widget.getLayoutParent();
        }

        return widget;
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var children = this._getLayoutChildren();

        var neededHeight = 0;
        var neededWidth = 0;

        for (var i = 0, l = children.length; i < l; i++) {
          var hint = children[i].getSizeHint();
          neededWidth += hint.width;
          neededHeight = Math.max(neededHeight, hint.height);
        }

        return {
          width: neededWidth,
          height: neededHeight
        };
      }
    }
  });
  qx.ui.menu.ButtonLayout.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menu.AbstractButton": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The real menu button class which supports a command and an icon. All
   * other features are inherited from the {@link qx.ui.menu.AbstractButton}
   * class.
   */
  qx.Class.define("qx.ui.menu.Button", {
    extend: qx.ui.menu.AbstractButton,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Initial label
     * @param icon {String} Initial icon
     * @param command {qx.ui.command.Command} Initial command (shortcut)
     * @param menu {qx.ui.menu.Menu} Initial sub menu
     */
    construct: function construct(label, icon, command, menu) {
      qx.ui.menu.AbstractButton.constructor.call(this); // Initialize with incoming arguments

      if (label != null) {
        this.setLabel(label);
      }

      if (icon != null) {
        this.setIcon(icon);
      }

      if (command != null) {
        this.setCommand(command);
      }

      if (menu != null) {
        this.setMenu(menu);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "menu-button"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      // overridden
      _onTap: function _onTap(e) {
        if (e.isLeftPressed() && this.getMenu()) {
          this.execute(); // don't close menus if the button is a sub menu button

          this.getMenu().open();
          return;
        }

        qx.ui.menu.Button.prototype._onTap.base.call(this, e);
      }
    }
  });
  qx.ui.menu.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menu.AbstractButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Renders a special checkbox button inside a menu. The button behaves like
   * a normal {@link qx.ui.form.CheckBox} and shows a check icon when
   * checked; normally shows no icon when not checked (depends on the theme).
   */
  qx.Class.define("qx.ui.menu.CheckBox", {
    extend: qx.ui.menu.AbstractButton,
    implement: [qx.ui.form.IBooleanForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Initial label
     * @param menu {qx.ui.menu.Menu} Initial sub menu
     */
    construct: function construct(label, menu) {
      qx.ui.menu.AbstractButton.constructor.call(this); // Initialize with incoming arguments

      if (label != null) {
        // try to translate every time you create a checkbox [BUG #2699]
        if (label.translate) {
          this.setLabel(label.translate());
        } else {
          this.setLabel(label);
        }
      }

      if (menu != null) {
        this.setMenu(menu);
      }

      this.addListener("execute", this._onExecute, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "menu-checkbox"
      },

      /** Whether the button is checked */
      value: {
        check: "Boolean",
        init: false,
        apply: "_applyValue",
        event: "changeValue",
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden (from MExecutable to keep the icon out of the binding)

      /**
       * @lint ignoreReferenceField(_bindableProperties)
       */
      _bindableProperties: ["enabled", "label", "toolTipText", "value", "menu"],
      // property apply
      _applyValue: function _applyValue(value, old) {
        value ? this.addState("checked") : this.removeState("checked");
      },

      /**
       * Handler for the execute event.
       *
       * @param e {qx.event.type.Event} The execute event.
       */
      _onExecute: function _onExecute(e) {
        this.toggleValue();
      }
    }
  });
  qx.ui.menu.CheckBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menu.AbstractButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Renders a special radio button inside a menu. The button behaves like
   * a normal {@link qx.ui.form.RadioButton} and shows a radio icon when
   * checked; normally shows no icon when not checked (depends on the theme).
   */
  qx.Class.define("qx.ui.menu.RadioButton", {
    extend: qx.ui.menu.AbstractButton,
    include: [qx.ui.form.MModelProperty],
    implement: [qx.ui.form.IRadioItem, qx.ui.form.IBooleanForm, qx.ui.form.IModel],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Initial label
     * @param menu {qx.ui.menu.Menu} Initial sub menu
     */
    construct: function construct(label, menu) {
      qx.ui.menu.AbstractButton.constructor.call(this); // Initialize with incoming arguments

      if (label != null) {
        this.setLabel(label);
      }

      if (menu != null) {
        this.setMenu(menu);
      }

      this.addListener("execute", this._onExecute, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "menu-radiobutton"
      },

      /** The value of the widget. True, if the widget is checked. */
      value: {
        check: "Boolean",
        nullable: true,
        event: "changeValue",
        apply: "_applyValue",
        init: false
      },

      /** The assigned qx.ui.form.RadioGroup which handles the switching between registered buttons */
      group: {
        check: "qx.ui.form.RadioGroup",
        nullable: true,
        apply: "_applyGroup"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden (from MExecutable to keep the icon out of the binding)

      /**
       * @lint ignoreReferenceField(_bindableProperties)
       */
      _bindableProperties: ["enabled", "label", "toolTipText", "value", "menu"],
      // property apply
      _applyValue: function _applyValue(value, old) {
        value ? this.addState("checked") : this.removeState("checked");
      },
      // property apply
      _applyGroup: function _applyGroup(value, old) {
        if (old) {
          old.remove(this);
        }

        if (value) {
          value.add(this);
        }
      },

      /**
       * Handler for the execute event.
       *
       * @param e {qx.event.type.Event} The execute event.
       */
      _onExecute: function _onExecute(e) {
        var grp = this.getGroup();

        if (grp && grp.getAllowEmptySelection()) {
          this.toggleValue();
        } else {
          this.setValue(true);
        }
      }
    }
  });
  qx.ui.menu.RadioButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This widget draws a separator line between two instances of
   * {@link qx.ui.menu.AbstractButton} and is inserted into the
   * {@link qx.ui.menu.Menu}.
   *
   * For convenience reasons there is also
   * a method {@link qx.ui.menu.Menu#addSeparator} to append instances
   * of this class to the menu.
   */
  qx.Class.define("qx.ui.menu.Separator", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "menu-separator"
      },
      // overridden
      anonymous: {
        refine: true,
        init: true
      }
    }
  });
  qx.ui.menu.Separator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.splitpane.Slider": {},
      "qx.ui.splitpane.Splitter": {},
      "qx.ui.splitpane.Blocker": {},
      "qx.ui.splitpane.VLayout": {},
      "qx.ui.splitpane.HLayout": {},
      "qx.ui.core.queue.Manager": {},
      "qx.bom.element.Location": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A split panes divides an area into two panes. The ratio between the two
   * panes is configurable by the user using the splitter.
   *
   * @childControl slider {qx.ui.splitpane.Slider} shown during resizing the splitpane
   * @childControl splitter {qx.ui.splitpane.Splitter} splitter to resize the splitpane
   */
  qx.Class.define("qx.ui.splitpane.Pane", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Creates a new instance of a SplitPane. It allows the user to dynamically
     * resize the areas dropping the border between.
     *
     * @param orientation {String} The orientation of the split pane control.
     * Allowed values are "horizontal" (default) and "vertical".
     */
    construct: function construct(orientation) {
      qx.ui.core.Widget.constructor.call(this);
      this.__children = []; // Initialize orientation

      if (orientation) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      } // add all pointer listener to the blocker


      this.__blocker.addListener("pointerdown", this._onPointerDown, this);

      this.__blocker.addListener("pointerup", this._onPointerUp, this);

      this.__blocker.addListener("pointermove", this._onPointerMove, this);

      this.__blocker.addListener("pointerout", this._onPointerOut, this);

      this.__blocker.addListener("losecapture", this._onPointerUp, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "splitpane"
      },

      /**
       * Distance between pointer and splitter when the cursor should change
       * and enable resizing.
       */
      offset: {
        check: "Integer",
        init: 6,
        apply: "_applyOffset"
      },

      /**
       * The orientation of the splitpane control.
       */
      orientation: {
        init: "horizontal",
        check: ["horizontal", "vertical"],
        apply: "_applyOrientation"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __splitterOffset: null,
      __activeDragSession: false,
      __lastPointerX: null,
      __lastPointerY: null,
      __isHorizontal: null,
      __beginSize: null,
      __endSize: null,
      __children: null,
      __blocker: null,
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          // Create and add slider
          case "slider":
            control = new qx.ui.splitpane.Slider(this);
            control.exclude();

            this._add(control, {
              type: id
            });

            break;
          // Create splitter

          case "splitter":
            control = new qx.ui.splitpane.Splitter(this);

            this._add(control, {
              type: id
            });

            control.addListener("move", this.__onSplitterMove, this);
            break;
        }

        return control || qx.ui.splitpane.Pane.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Move handler for the splitter which takes care of the external
       * triggered resize of children.
       *
       * @param e {qx.event.type.Data} The data even of move.
       */
      __onSplitterMove: function __onSplitterMove(e) {
        this.__setBlockerPosition(e.getData());
      },

      /**
       * Creates a blocker for the splitter which takes all bouse events and
       * also handles the offset and cursor.
       *
       * @param orientation {String} The orientation of the pane.
       */
      __createBlocker: function __createBlocker(orientation) {
        this.__blocker = new qx.ui.splitpane.Blocker(orientation);
        this.getContentElement().add(this.__blocker);
        var splitter = this.getChildControl("splitter");
        var splitterWidth = splitter.getWidth();

        if (!splitterWidth) {
          splitter.addListenerOnce("appear", function () {
            this.__setBlockerPosition();
          }, this);
        } // resize listener to remove the blocker in case the splitter
        // is removed.


        splitter.addListener("resize", function (e) {
          var bounds = e.getData();

          if (this.getChildControl("splitter").getVisible() && (bounds.height == 0 || bounds.width == 0)) {
            this.__blocker.hide();
          } else {
            this.__blocker.show();
          }
        }, this);
      },

      /**
       * Returns the blocker used over the splitter. this could be used for
       * adding event listeners like tap or dbltap.
       *
       * @return {qx.ui.splitpane.Blocker} The used blocker element.
       *
       * @internal
       */
      getBlocker: function getBlocker() {
        return this.__blocker;
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Apply routine for the orientation property.
       *
       * Sets the pane's layout to vertical or horizontal split layout.
       *
       * @param value {String} The new value of the orientation property
       * @param old {String} The old value of the orientation property
       */
      _applyOrientation: function _applyOrientation(value, old) {
        var slider = this.getChildControl("slider");
        var splitter = this.getChildControl("splitter"); // Store boolean flag for faster access

        this.__isHorizontal = value === "horizontal";

        if (!this.__blocker) {
          this.__createBlocker(value);
        } // update the blocker


        this.__blocker.setOrientation(value); // Dispose old layout


        var oldLayout = this._getLayout();

        if (oldLayout) {
          oldLayout.dispose();
        } // Create new layout


        var newLayout = value === "vertical" ? new qx.ui.splitpane.VLayout() : new qx.ui.splitpane.HLayout();

        this._setLayout(newLayout); // Update states for splitter and slider


        splitter.removeState(old);
        splitter.addState(value);
        splitter.getChildControl("knob").removeState(old);
        splitter.getChildControl("knob").addState(value);
        slider.removeState(old);
        slider.addState(value); // flush (needs to be done for the blocker update) and update the blocker

        qx.ui.core.queue.Manager.flush();

        this.__setBlockerPosition();
      },
      // property apply
      _applyOffset: function _applyOffset(value, old) {
        this.__setBlockerPosition();
      },

      /**
       * Helper for setting the blocker to the right position, which depends on
       * the offset, orientation and the current position of the splitter.
       *
       * @param bounds {Map?null} If the bounds of the splitter are known,
       *   they can be added.
       */
      __setBlockerPosition: function __setBlockerPosition(bounds) {
        var splitter = this.getChildControl("splitter");
        var offset = this.getOffset();
        var splitterBounds = splitter.getBounds();
        var splitterElem = splitter.getContentElement().getDomElement(); // do nothing if the splitter is not ready

        if (!splitterElem) {
          return;
        } // recalculate the dimensions of the blocker


        if (this.__isHorizontal) {
          // get the width either of the given bounds or of the read bounds
          var width = null;

          if (bounds) {
            width = bounds.width;
          } else if (splitterBounds) {
            width = splitterBounds.width;
          }

          var left = bounds && bounds.left;

          if (width || !this.getChildControl("splitter").getVisible()) {
            if (isNaN(left)) {
              left = qx.bom.element.Location.getPosition(splitterElem).left;
            }

            this.__blocker.setWidth(offset, width || 6);

            this.__blocker.setLeft(offset, left);
          } // vertical case

        } else {
          // get the height either of the given bounds or of the read bounds
          var height = null;

          if (bounds) {
            height = bounds.height;
          } else if (splitterBounds) {
            height = splitterBounds.height;
          }

          var top = bounds && bounds.top;

          if (height || !this.getChildControl("splitter").getVisible()) {
            if (isNaN(top)) {
              top = qx.bom.element.Location.getPosition(splitterElem).top;
            }

            this.__blocker.setHeight(offset, height || 6);

            this.__blocker.setTop(offset, top);
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Adds a widget to the pane.
       *
       * Sets the pane's layout to vertical or horizontal split layout. Depending on the
       * pane's layout the first widget will be the left or top widget, the second one
       * the bottom or right widget. Adding more than two widgets will overwrite the
       * existing ones.
       *
       * @param widget {qx.ui.core.Widget} The widget to be inserted into pane.
       * @param flex {Number} The (optional) layout property for the widget's flex value.
       */
      add: function add(widget, flex) {
        if (flex == null) {
          this._add(widget);
        } else {
          this._add(widget, {
            flex: flex
          });
        }

        this.__children.push(widget);
      },

      /**
       * Removes the given widget from the pane.
       *
       * @param widget {qx.ui.core.Widget} The widget to be removed.
       */
      remove: function remove(widget) {
        this._remove(widget);

        qx.lang.Array.remove(this.__children, widget);
      },

      /**
       * Returns an array containing the pane's content.
       *
       * @return {qx.ui.core.Widget[]} The pane's child widgets
       */
      getChildren: function getChildren() {
        return this.__children;
      },

      /*
      ---------------------------------------------------------------------------
        POINTER LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Handler for pointerdown event.
       *
       * Shows slider widget and starts drag session if pointer is near/on splitter widget.
       *
       * @param e {qx.event.type.Pointer} pointerdown event
       */
      _onPointerDown: function _onPointerDown(e) {
        // Only proceed if left pointer button is pressed and the splitter is active
        if (!e.isLeftPressed()) {
          return;
        }

        var splitter = this.getChildControl("splitter"); // Store offset between pointer event coordinates and splitter

        var splitterLocation = splitter.getContentLocation();
        var paneLocation = this.getContentLocation();
        this.__splitterOffset = this.__isHorizontal ? e.getDocumentLeft() - splitterLocation.left + paneLocation.left : e.getDocumentTop() - splitterLocation.top + paneLocation.top; // Synchronize slider to splitter size and show it

        var slider = this.getChildControl("slider");
        var splitterBounds = splitter.getBounds();
        slider.setUserBounds(splitterBounds.left, splitterBounds.top, splitterBounds.width || 6, splitterBounds.height || 6);
        slider.setZIndex(splitter.getZIndex() + 1);
        slider.show(); // Enable session

        this.__activeDragSession = true;

        this.__blocker.capture();

        e.stop();
      },

      /**
       * Handler for pointermove event.
       *
       * @param e {qx.event.type.Pointer} pointermove event
       */
      _onPointerMove: function _onPointerMove(e) {
        this._setLastPointerPosition(e.getDocumentLeft(), e.getDocumentTop()); // Check if slider is already being dragged


        if (this.__activeDragSession) {
          // Compute new children sizes
          this.__computeSizes(); // Update slider position


          var slider = this.getChildControl("slider");
          var pos = this.__beginSize;

          if (this.__isHorizontal) {
            slider.setDomLeft(pos);

            this.__blocker.setStyle("left", pos - this.getOffset() + "px");
          } else {
            slider.setDomTop(pos);

            this.__blocker.setStyle("top", pos - this.getOffset() + "px");
          }

          e.stop();
        }
      },

      /**
       * Handler for pointerout event
       *
       * @param e {qx.event.type.Pointer} pointerout event
       */
      _onPointerOut: function _onPointerOut(e) {
        this._setLastPointerPosition(e.getDocumentLeft(), e.getDocumentTop());
      },

      /**
       * Handler for pointerup event
       *
       * Sets widget sizes if dragging session has been active.
       *
       * @param e {qx.event.type.Pointer} pointerup event
       */
      _onPointerUp: function _onPointerUp(e) {
        if (!this.__activeDragSession) {
          return;
        } // Set sizes to both widgets


        this._finalizeSizes(); // Hide the slider


        var slider = this.getChildControl("slider");
        slider.exclude(); // Cleanup

        this.__activeDragSession = false;
        this.releaseCapture();
        e.stop();
      },

      /*
      ---------------------------------------------------------------------------
        INTERVAL HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Updates widgets' sizes based on the slider position.
       */
      _finalizeSizes: function _finalizeSizes() {
        var beginSize = this.__beginSize;
        var endSize = this.__endSize;

        if (beginSize == null) {
          return;
        }

        var children = this._getChildren();

        var firstWidget = children[2];
        var secondWidget = children[3]; // Read widgets' flex values

        var firstFlexValue = firstWidget.getLayoutProperties().flex;
        var secondFlexValue = secondWidget.getLayoutProperties().flex; // Both widgets have flex values

        if (firstFlexValue != 0 && secondFlexValue != 0) {
          firstWidget.setLayoutProperties({
            flex: beginSize
          });
          secondWidget.setLayoutProperties({
            flex: endSize
          });
        } // Update both sizes
        else {
            // Set widths to static widgets
            if (this.__isHorizontal) {
              firstWidget.setWidth(beginSize);
              secondWidget.setWidth(endSize);
            } else {
              firstWidget.setHeight(beginSize);
              secondWidget.setHeight(endSize);
            }
          }
      },

      /**
       * Computes widgets' sizes based on the pointer coordinate.
       */
      __computeSizes: function __computeSizes() {
        if (this.__isHorizontal) {
          var min = "minWidth",
              size = "width",
              max = "maxWidth",
              pointer = this.__lastPointerX;
        } else {
          var min = "minHeight",
              size = "height",
              max = "maxHeight",
              pointer = this.__lastPointerY;
        }

        var children = this._getChildren();

        var beginHint = children[2].getSizeHint();
        var endHint = children[3].getSizeHint(); // Area given to both widgets

        var allocatedSize = children[2].getBounds()[size] + children[3].getBounds()[size]; // Calculate widget sizes

        var beginSize = pointer - this.__splitterOffset;
        var endSize = allocatedSize - beginSize; // Respect minimum limits

        if (beginSize < beginHint[min]) {
          endSize -= beginHint[min] - beginSize;
          beginSize = beginHint[min];
        } else if (endSize < endHint[min]) {
          beginSize -= endHint[min] - endSize;
          endSize = endHint[min];
        } // Respect maximum limits


        if (beginSize > beginHint[max]) {
          endSize += beginSize - beginHint[max];
          beginSize = beginHint[max];
        } else if (endSize > endHint[max]) {
          beginSize += endSize - endHint[max];
          endSize = endHint[max];
        } // Store sizes


        this.__beginSize = beginSize;
        this.__endSize = endSize;
      },

      /**
       * Determines whether this is an active drag session
       *
       * @return {Boolean} True if active drag session, otherwise false.
       */
      _isActiveDragSession: function _isActiveDragSession() {
        return this.__activeDragSession;
      },

      /**
       * Sets the last pointer position.
       *
       * @param x {Integer} the x position of the pointer.
       * @param y {Integer} the y position of the pointer.
       */
      _setLastPointerPosition: function _setLastPointerPosition(x, y) {
        this.__lastPointerX = x;
        this.__lastPointerY = y;
      }
    },
    destruct: function destruct() {
      this.__children = null;
    }
  });
  qx.ui.splitpane.Pane.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.ISingleSelection": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.ui.tabview.Page": {},
      "qx.ui.container.SlideBar": {},
      "qx.ui.container.Stack": {},
      "qx.ui.form.RadioGroup": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.layout.VBox": {},
      "qx.event.type.Event": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Jonathan Weiß (jonathan_rass)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A tab view is a multi page view where only one page is visible
   * at each moment. It is possible to switch the pages using the
   * buttons rendered by each page.
   * 
   * Note that prior to v6.0, when changing the currently selected tab via code
   * (ie changing the selection property) TabView would automatically set the 
   * focus to that tab; this is undesirable (and inconsistent with other parts
   * of the framework) and is no longer done automatically.
   *
   * @childControl bar {qx.ui.container.SlideBar} slidebar for all tab buttons
   * @childControl pane {qx.ui.container.Stack} stack container to show one tab page
   */
  qx.Class.define("qx.ui.tabview.TabView", {
    extend: qx.ui.core.Widget,
    implement: qx.ui.core.ISingleSelection,
    include: [qx.ui.core.MContentPadding],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param barPosition {String} Initial bar position ({@link #barPosition})
     */
    construct: function construct(barPosition) {
      qx.ui.core.Widget.constructor.call(this);
      this.__barPositionToState = {
        top: "barTop",
        right: "barRight",
        bottom: "barBottom",
        left: "barLeft"
      };

      this._createChildControl("bar");

      this._createChildControl("pane"); // Create manager


      var mgr = this.__radioGroup = this._createRadioGroupInstance();

      mgr.setWrap(false);
      mgr.addListener("changeSelection", this._onChangeSelection, this); // Initialize bar position

      if (barPosition != null) {
        this.setBarPosition(barPosition);
      } else {
        this.initBarPosition();
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fires after the selection was modified */
      "changeSelection": "qx.event.type.Data",

      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "tabview"
      },

      /**
       * This property defines on which side of the TabView the bar should be positioned.
       */
      barPosition: {
        check: ["left", "right", "top", "bottom"],
        init: "top",
        apply: "_applyBarPosition"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.form.RadioGroup} instance containing the radio group */
      __radioGroup: null,

      /**
       * setValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @param item {null|qx.ui.tabview.Page} Page to set as selected value.
       * @returns {null|TypeError} The status of this operation.
       */
      setValue: function setValue(item) {
        if (null === item) {
          this.resetSelection();
          return null;
        }

        if (item instanceof qx.ui.tabview.Page) {
          this.setSelection([item]);
          return null;
        } else {
          return new TypeError("Given argument is not null or a {qx.ui.tabview.Page}.");
        }
      },

      /**
       * getValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @returns {null|qx.ui.tabview.Page} The currently selected page or null if there is none.
       */
      getValue: function getValue() {
        var pages = this.getSelection();

        if (pages.length) {
          return pages[0];
        } else {
          return null;
        }
      },

      /**
       * resetValue implements part of the {@link qx.ui.form.IField} interface.
       */
      resetValue: function resetValue() {
        this.resetSelection();
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "bar":
            control = new qx.ui.container.SlideBar();
            control.setZIndex(10);

            this._add(control);

            break;

          case "pane":
            control = new qx.ui.container.Stack();
            control.setZIndex(5);

            this._add(control, {
              flex: 1
            });

            break;
        }

        return control || qx.ui.tabview.TabView.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Creates the radio group manager instance.
       * 
       * Allows override customizations of the instance 
       * 
       * @return {qx.ui.form.RadioGroup} 
       */
      _createRadioGroupInstance: function _createRadioGroupInstance() {
        return new qx.ui.form.RadioGroup();
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getChildControl("pane");
      },

      /*
      ---------------------------------------------------------------------------
        CHILDREN HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Adds a page to the tabview including its needed button
       * (contained in the page).
       *
       * @param page {qx.ui.tabview.Page} The page which should be added.
       */
      add: function add(page) {
        {
          if (!(page instanceof qx.ui.tabview.Page)) {
            throw new Error("Incompatible child for TabView: " + page);
          }
        }
        var button = page.getButton();
        var bar = this.getChildControl("bar");
        var pane = this.getChildControl("pane"); // Exclude page

        page.exclude(); // Add button and page

        bar.add(button);
        pane.add(page); // Register button

        this.__radioGroup.add(button); // Add state to page


        page.addState(this.__barPositionToState[this.getBarPosition()]); // Update states

        page.addState("lastTab");
        var children = this.getChildren();

        if (children[0] == page) {
          page.addState("firstTab");
        } else {
          children[children.length - 2].removeState("lastTab");
        }

        page.addListener("close", this._onPageClose, this);
      },

      /**
       * Adds a page to the tabview including its needed button
       * (contained in the page).
       *
       * @param page {qx.ui.tabview.Page} The page which should be added.
       * @param index {Integer?null} Optional position where to add the page.
       */
      addAt: function addAt(page, index) {
        {
          if (!(page instanceof qx.ui.tabview.Page)) {
            throw new Error("Incompatible child for TabView: " + page);
          }
        }
        var children = this.getChildren();

        if (!(index == null) && index > children.length) {
          throw new Error("Index should be less than : " + children.length);
        }

        if (index == null) {
          index = children.length;
        }

        var button = page.getButton();
        var bar = this.getChildControl("bar");
        var pane = this.getChildControl("pane"); // Exclude page

        page.exclude(); // Add button and page

        bar.addAt(button, index);
        pane.addAt(page, index); // Register button

        this.__radioGroup.add(button); // Add state to page


        page.addState(this.__barPositionToState[this.getBarPosition()]); // Update states

        children = this.getChildren();

        if (index == children.length - 1) {
          page.addState("lastTab");
        }

        if (children[0] == page) {
          page.addState("firstTab");
        } else {
          children[children.length - 2].removeState("lastTab");
        }

        page.addListener("close", this._onPageClose, this);
      },

      /**
       * Removes a page (and its corresponding button) from the TabView.
       *
       * @param page {qx.ui.tabview.Page} The page to be removed.
       */
      remove: function remove(page) {
        var pane = this.getChildControl("pane");
        var bar = this.getChildControl("bar");
        var button = page.getButton();
        var children = pane.getChildren(); // Try to select next page

        if (this.getSelection()[0] == page) {
          var index = children.indexOf(page);

          if (index == 0) {
            if (children[1]) {
              this.setSelection([children[1]]);
            } else {
              this.resetSelection();
            }
          } else {
            this.setSelection([children[index - 1]]);
          }
        } // Remove the button and page


        bar.remove(button);
        pane.remove(page); // Remove the button from the radio group

        this.__radioGroup.remove(button); // Remove state from page


        page.removeState(this.__barPositionToState[this.getBarPosition()]); // Update states

        if (page.hasState("firstTab")) {
          page.removeState("firstTab");

          if (children[0]) {
            children[0].addState("firstTab");
          }
        }

        if (page.hasState("lastTab")) {
          page.removeState("lastTab");

          if (children.length > 0) {
            children[children.length - 1].addState("lastTab");
          }
        }

        page.removeListener("close", this._onPageClose, this);
      },

      /**
       * Returns TabView's children widgets.
       *
       * @return {qx.ui.tabview.Page[]} List of children.
       */
      getChildren: function getChildren() {
        return this.getChildControl("pane").getChildren();
      },

      /**
       * Returns the position of the given page in the TabView.
       *
       * @param page {qx.ui.tabview.Page} The page to query for.
       * @return {Integer} Position of the page in the TabView.
       */
      indexOf: function indexOf(page) {
        return this.getChildControl("pane").indexOf(page);
      },

      /**
       * Returns the radio group manager.
       *
       * @return {qx.ui.form.RadioGroup} the radio group.
       */
      getRadioGroup: function getRadioGroup() {
        return this.__radioGroup;
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */

      /** @type {Map} Maps the bar position to an appearance state */
      __barPositionToState: null,

      /**
       * Apply method for the placeBarOnTop-Property.
       *
       * Passes the desired value to the layout of the tabview so
       * that the layout can handle it.
       * It also sets the states to all buttons so they know the
       * position of the bar.
       *
       * @param value {Boolean} The new value.
       * @param old {Boolean} The old value.
       */
      _applyBarPosition: function _applyBarPosition(value, old) {
        var bar = this.getChildControl("bar");
        var pane = this.getChildControl("pane");
        var horizontal = value == "left" || value == "right";
        var reversed = value == "right" || value == "bottom";
        var layoutClass = horizontal ? qx.ui.layout.HBox : qx.ui.layout.VBox;

        var layout = this._getLayout();

        if (layout && layout instanceof layoutClass) {// pass
        } else {
          this._setLayout(layout = new layoutClass());
        } // Update reversed


        layout.setReversed(reversed); // Sync orientation to bar

        bar.setOrientation(horizontal ? "vertical" : "horizontal"); // Read children

        var children = this.getChildren();
        var i, l; // Toggle state to bar

        if (old) {
          var oldState = this.__barPositionToState[old]; // Update bar

          bar.removeState(oldState); // Update pane

          pane.removeState(oldState); // Update pages

          for (i = 0, l = children.length; i < l; i++) {
            children[i].removeState(oldState);
          }
        }

        if (value) {
          var newState = this.__barPositionToState[value]; // Update bar

          bar.addState(newState); // Update pane

          pane.addState(newState); // Update pages

          for (i = 0, l = children.length; i < l; i++) {
            children[i].addState(newState);
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {qx.ui.tabview.Page[]} List of items.
       */
      getSelection: function getSelection() {
        var buttons = this.__radioGroup.getSelection();

        var result = [];

        for (var i = 0; i < buttons.length; i++) {
          result.push(buttons[i].getUserData("page"));
        }

        return result;
      },

      /**
       * Replaces current selection with the given items.
       *
       * @param items {qx.ui.tabview.Page[]} Items to select.
       * @throws {Error} if one of the items is not a child element and if
       *    items contains more than one elements.
       */
      setSelection: function setSelection(items) {
        var buttons = [];

        for (var i = 0; i < items.length; i++) {
          buttons.push(items[i].getChildControl("button"));
        }

        this.__radioGroup.setSelection(buttons);
      },

      /**
       * Clears the whole selection at once.
       */
      resetSelection: function resetSelection() {
        this.__radioGroup.resetSelection();
      },

      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {qx.ui.tabview.Page} Any valid selectable item.
       * @return {Boolean} Whether the item is selected.
       * @throws {Error} if one of the items is not a child element.
       */
      isSelected: function isSelected(item) {
        var button = item.getChildControl("button");
        return this.__radioGroup.isSelected(button);
      },

      /**
       * Whether the selection is empty.
       *
       * @return {Boolean} Whether the selection is empty.
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__radioGroup.isSelectionEmpty();
      },

      /**
       * Returns all elements which are selectable.
       *
       * @return {qx.ui.tabview.Page[]} The contained items.
       * @param all {Boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       */
      getSelectables: function getSelectables(all) {
        var buttons = this.__radioGroup.getSelectables(all);

        var result = [];

        for (var i = 0; i < buttons.length; i++) {
          result.push(buttons[i].getUserData("page"));
        }

        return result;
      },

      /**
       * Event handler for <code>changeSelection</code>.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      _onChangeSelection: function _onChangeSelection(e) {
        var pane = this.getChildControl("pane");
        var button = e.getData()[0];
        var oldButton = e.getOldData()[0];
        var value = [];
        var old = [];

        if (button) {
          value = [button.getUserData("page")];
          pane.setSelection(value);
          this.scrollChildIntoView(button, null, null, false);
        } else {
          pane.resetSelection();
        }

        if (oldButton) {
          old = [oldButton.getUserData("page")];
        }

        this.fireDataEvent("changeSelection", value, old);
      },

      /**
       * Event handler for <code>beforeChangeSelection</code>.
       *
       * @param e {qx.event.type.Event} Data event.
       */
      _onBeforeChangeSelection: function _onBeforeChangeSelection(e) {
        if (!this.fireNonBubblingEvent("beforeChangeSelection", qx.event.type.Event, [false, true])) {
          e.preventDefault();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the change of the selected item of the radio group.
       * @param e {qx.event.type.Data} The data event
       */
      _onRadioChangeSelection: function _onRadioChangeSelection(e) {
        var element = e.getData()[0];

        if (element) {
          this.setSelection([element.getUserData("page")]);
        } else {
          this.resetSelection();
        }
      },

      /**
       * Removes the Page widget on which the close button was tapped.
       *
       * @param e {qx.event.type.Pointer} pointer event
       */
      _onPageClose: function _onPageClose(e) {
        // reset the old close button states, before remove page
        // see http://bugzilla.qooxdoo.org/show_bug.cgi?id=3763 for details
        var page = e.getTarget();
        var closeButton = page.getButton().getChildControl("close-button");
        closeButton.reset();
        this.remove(page);
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__radioGroup");

      this.__barPositionToState = null;
    }
  });
  qx.ui.tabview.TabView.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.tabview.TabButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A page is the way to add content to a {@link TabView}. Each page gets a
   * button to switch to the page. Only one page is visible at a time.
   *
   * @childControl button {qx.ui.tabview.TabButton} tab button connected to the page
   */
  qx.Class.define("qx.ui.tabview.Page", {
    extend: qx.ui.container.Composite,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Initial label of the tab
     * @param icon {String} Initial icon of the tab
     */
    construct: function construct(label, icon) {
      qx.ui.container.Composite.constructor.call(this);

      this._createChildControl("button"); // init


      if (label != null) {
        this.setLabel(label);
      }

      if (icon != null) {
        this.setIcon(icon);
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired by {@link qx.ui.tabview.TabButton} if the close button is tapped.
       */
      "close": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "tabview-page"
      },

      /** The label/caption/text of the Page's button. */
      label: {
        check: "String",
        init: "",
        apply: "_applyLabel"
      },

      /** Any URI String supported by qx.ui.basic.Image to display an icon in Page's button. */
      icon: {
        check: "String",
        init: "",
        apply: "_applyIcon",
        nullable: true
      },

      /** Indicates if the close button of a TabButton should be shown. */
      showCloseButton: {
        check: "Boolean",
        init: false,
        apply: "_applyShowCloseButton"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        barTop: 1,
        barRight: 1,
        barBottom: 1,
        barLeft: 1,
        firstTab: 1,
        lastTab: 1
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        var btn = this.getChildControl("button");

        if (value) {
          btn.setIcon(value);

          btn._showChildControl("icon");
        } else {
          btn._excludeChildControl("icon");
        }
      },
      // property apply
      _applyLabel: function _applyLabel(value, old) {
        this.getChildControl("button").setLabel(value);
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.tabview.Page.prototype._applyEnabled.base.call(this, value, old); // delegate to non-child widget button
        // since enabled is inheritable value may be null


        var btn = this.getChildControl("button");
        value == null ? btn.resetEnabled() : btn.setEnabled(value);
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "button":
            control = new qx.ui.tabview.TabButton();
            control.setAllowGrowX(true);
            control.setAllowGrowY(true);
            control.setUserData("page", this);
            control.addListener("close", this._onButtonClose, this);
            break;
        }

        return control || qx.ui.tabview.Page.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyShowCloseButton: function _applyShowCloseButton(value, old) {
        this.getChildControl("button").setShowCloseButton(value);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Fires an "close" event when the close button of the TabButton of the page
       * is tapped.
       */
      _onButtonClose: function _onButtonClose() {
        this.fireEvent("close");
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the button used within this page. This method is used by
       * the TabView to access the button.
       *
       * @internal
       * @return {qx.ui.form.RadioButton} The button associated with this page.
       */
      getButton: function getButton() {
        return this.getChildControl("button");
      }
    }
  });
  qx.ui.tabview.Page.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Button": {
        "construct": true,
        "require": true
      },
      "qx.ui.toolbar.PartContainer": {},
      "qx.ui.core.queue.Appearance": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * The normal toolbar button. Like a normal {@link qx.ui.form.Button}
   * but with a style matching the toolbar and without keyboard support.
   */
  qx.Class.define("qx.ui.toolbar.Button", {
    extend: qx.ui.form.Button,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct(label, icon, command) {
      qx.ui.form.Button.constructor.call(this, label, icon, command); // Toolbar buttons should not support the keyboard events

      this.removeListener("keydown", this._onKeyDown);
      this.removeListener("keyup", this._onKeyUp);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "toolbar-button"
      },
      show: {
        refine: true,
        init: "inherit"
      },
      focusable: {
        refine: true,
        init: false
      }
    },
    members: {
      // overridden
      _applyVisibility: function _applyVisibility(value, old) {
        qx.ui.toolbar.Button.prototype._applyVisibility.base.call(this, value, old); // trigger a appearance recalculation of the parent


        var parent = this.getLayoutParent();

        if (parent && parent instanceof qx.ui.toolbar.PartContainer) {
          qx.ui.core.queue.Appearance.add(parent);
        }
      }
    }
  });
  qx.ui.toolbar.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.ToggleButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.toolbar.PartContainer": {},
      "qx.ui.core.queue.Appearance": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A button which is toggle-able for toolbars.
   */
  qx.Class.define("qx.ui.toolbar.CheckBox", {
    extend: qx.ui.form.ToggleButton,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct(label, icon) {
      qx.ui.form.ToggleButton.constructor.call(this, label, icon); // Toolbar buttons should not support the keyboard events

      this.removeListener("keydown", this._onKeyDown);
      this.removeListener("keyup", this._onKeyUp);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "toolbar-button"
      },
      show: {
        refine: true,
        init: "inherit"
      },
      focusable: {
        refine: true,
        init: false
      }
    },
    members: {
      // overridden
      _applyVisibility: function _applyVisibility(value, old) {
        qx.ui.toolbar.CheckBox.prototype._applyVisibility.base.call(this, value, old); // trigger a appearance recalculation of the parent


        var parent = this.getLayoutParent();

        if (parent && parent instanceof qx.ui.toolbar.PartContainer) {
          qx.ui.core.queue.Appearance.add(parent);
        }
      }
    }
  });
  qx.ui.toolbar.CheckBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.basic.Image": {},
      "qx.ui.toolbar.PartContainer": {},
      "qx.ui.toolbar.Separator": {},
      "qx.ui.menubar.Button": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A part is a container for multiple toolbar buttons. Each part comes
   * with a handle which may be used in later versions to drag the part
   * around and move it to another position. Currently mainly used
   * for structuring large toolbars beyond the capabilities of the
   * {@link Separator}.
   *
   * @childControl handle {qx.ui.basic.Image} prat handle to visualize the separation
   * @childControl container {qx.ui.toolbar.PartContainer} holds the content of the toolbar part
   */
  qx.Class.define("qx.ui.toolbar.Part", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // Hard coded HBox layout

      this._setLayout(new qx.ui.layout.HBox()); // Force creation of the handle


      this._createChildControl("handle");
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "toolbar/part"
      },

      /** Whether icons, labels, both or none should be shown. */
      show: {
        init: "both",
        check: ["both", "label", "icon"],
        inheritable: true,
        event: "changeShow"
      },

      /** The spacing between every child of the toolbar */
      spacing: {
        nullable: true,
        check: "Integer",
        themeable: true,
        apply: "_applySpacing"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "handle":
            control = new qx.ui.basic.Image();
            control.setAlignY("middle");

            this._add(control);

            break;

          case "container":
            control = new qx.ui.toolbar.PartContainer();
            control.addListener("syncAppearance", this.__onSyncAppearance, this);

            this._add(control);

            control.addListener("changeChildren", function () {
              this.__onSyncAppearance();
            }, this);
            break;
        }

        return control || qx.ui.toolbar.Part.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("container");
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      _applySpacing: function _applySpacing(value, old) {
        var layout = this.getChildControl("container").getLayout();
        value == null ? layout.resetSpacing() : layout.setSpacing(value);
      },

      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */

      /**
       * Helper which applies the left, right and middle states.
       */
      __onSyncAppearance: function __onSyncAppearance() {
        // check every child
        var children = this.getChildrenContainer().getChildren();
        children = children.filter(function (child) {
          return child.getVisibility() == "visible";
        });

        for (var i = 0; i < children.length; i++) {
          // if its the first child
          if (i == 0 && i != children.length - 1) {
            children[i].addState("left");
            children[i].removeState("right");
            children[i].removeState("middle"); // if its the last child
          } else if (i == children.length - 1 && i != 0) {
            children[i].addState("right");
            children[i].removeState("left");
            children[i].removeState("middle"); // if there is only one child
          } else if (i == 0 && i == children.length - 1) {
            children[i].removeState("left");
            children[i].removeState("middle");
            children[i].removeState("right");
          } else {
            children[i].addState("middle");
            children[i].removeState("right");
            children[i].removeState("left");
          }
        }

        ;
      },

      /**
       * Adds a separator to the toolbar part.
       */
      addSeparator: function addSeparator() {
        this.add(new qx.ui.toolbar.Separator());
      },

      /**
       * Returns all nested buttons which contains a menu to show. This is mainly
       * used for keyboard support.
       *
       * @return {Array} List of all menu buttons
       */
      getMenuButtons: function getMenuButtons() {
        var children = this.getChildren();
        var buttons = [];
        var child;

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (child instanceof qx.ui.menubar.Button) {
            buttons.push(child);
          }
        }

        return buttons;
      }
    }
  });
  qx.ui.toolbar.Part.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The container used by {@link Part} to insert the buttons.
   *
   * @internal
   */
  qx.Class.define("qx.ui.toolbar.PartContainer", {
    extend: qx.ui.container.Composite,
    construct: function construct() {
      qx.ui.container.Composite.constructor.call(this);

      this._setLayout(new qx.ui.layout.HBox());
    },
    events: {
      /** Fired if a child has been added or removed */
      changeChildren: "qx.event.type.Event"
    },
    properties: {
      appearance: {
        refine: true,
        init: "toolbar/part/container"
      },

      /** Whether icons, labels, both or none should be shown. */
      show: {
        init: "both",
        check: ["both", "label", "icon"],
        inheritable: true,
        event: "changeShow"
      }
    },
    members: {
      // overridden
      _afterAddChild: function _afterAddChild(child) {
        this.fireEvent("changeChildren");
      },
      // overridden
      _afterRemoveChild: function _afterRemoveChild(child) {
        this.fireEvent("changeChildren");
      }
    }
  });
  qx.ui.toolbar.PartContainer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.toolbar.CheckBox": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Radio buttons are used to manage a single selection. Radio buttons only
   * make sense used in a group of two or more of them. They are managed (connected)
   * to a {@link qx.ui.form.RadioGroup} to handle the selection.
   */
  qx.Class.define("qx.ui.toolbar.RadioButton", {
    extend: qx.ui.toolbar.CheckBox,
    include: [qx.ui.form.MModelProperty],
    implement: [qx.ui.form.IModel, qx.ui.form.IRadioItem],

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyValue: function _applyValue(value, old) {
        qx.ui.toolbar.RadioButton.prototype._applyValue.base.call(this, value, old);

        if (value) {
          var grp = this.getGroup();

          if (grp) {
            grp.setSelection([this]);
          }
        }
      },
      // overridden
      _onExecute: function _onExecute(e) {
        var grp = this.getGroup();

        if (grp && grp.getAllowEmptySelection()) {
          this.toggleValue();
        } else {
          this.setValue(true);
        }
      }
    }
  });
  qx.ui.toolbar.RadioButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A widget used for decoration proposes to structure a toolbar. Each
   * Separator renders a line between the buttons around.
   */
  qx.Class.define("qx.ui.toolbar.Separator", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "toolbar-separator"
      },
      // overridden
      anonymous: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 0
      },
      // overridden
      height: {
        refine: true,
        init: 0
      }
    }
  });
  qx.ui.toolbar.Separator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MChildrenHandling": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.util.PropertyUtil": {},
      "qx.ui.core.Spacer": {},
      "qx.ui.toolbar.Separator": {},
      "qx.ui.menubar.Button": {},
      "qx.ui.toolbar.Part": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The Toolbar class is the main part of the toolbar widget.
   *
   * It can handle added {@link Button}s, {@link CheckBox}es, {@link RadioButton}s
   * and {@link Separator}s in its {@link #add} method. The {@link #addSpacer} method
   * adds a spacer at the current toolbar position. This means that the widgets
   * added after the method call of {@link #addSpacer} are aligned to the right of
   * the toolbar.
   *
   * For more details on the documentation of the toolbar widget, take a look at the
   * documentation of the {@link qx.ui.toolbar}-Package.
   */
  qx.Class.define("qx.ui.toolbar.ToolBar", {
    extend: qx.ui.core.Widget,
    include: qx.ui.core.MChildrenHandling,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // add needed layout

      this._setLayout(new qx.ui.layout.HBox()); // initialize the overflow handling


      this.__removedItems = [];
      this.__removePriority = [];
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Appearance of the widget */
      appearance: {
        refine: true,
        init: "toolbar"
      },

      /** Holds the currently open menu (when the toolbar is used for menus) */
      openMenu: {
        check: "qx.ui.menu.Menu",
        event: "changeOpenMenu",
        nullable: true
      },

      /** Whether icons, labels, both or none should be shown. */
      show: {
        init: "both",
        check: ["both", "label", "icon"],
        inheritable: true,
        apply: "_applyShow",
        event: "changeShow"
      },

      /** The spacing between every child of the toolbar */
      spacing: {
        nullable: true,
        check: "Integer",
        themeable: true,
        apply: "_applySpacing"
      },

      /**
       * Widget which will be shown if at least one toolbar item is hidden.
       * Keep in mind to add this widget to the toolbar before you set it as
       * indicator!
       */
      overflowIndicator: {
        check: "qx.ui.core.Widget",
        nullable: true,
        apply: "_applyOverflowIndicator"
      },

      /** Enables the overflow handling which automatically removes items.*/
      overflowHandling: {
        init: false,
        check: "Boolean",
        apply: "_applyOverflowHandling"
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired if an item will be hidden by the {@link #overflowHandling}.*/
      "hideItem": "qx.event.type.Data",

      /** Fired if an item will be shown by the {@link #overflowHandling}.*/
      "showItem": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        OVERFLOW HANDLING
      ---------------------------------------------------------------------------
      */
      __removedItems: null,
      __removePriority: null,
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        // get the original hint
        var hint = qx.ui.toolbar.ToolBar.prototype._computeSizeHint.base.call(this);

        if (true && this.getOverflowHandling()) {
          var minWidth = 0; // if an overflow widget is given, use its width + spacing as min width

          var overflowWidget = this.getOverflowIndicator();

          if (overflowWidget) {
            minWidth = overflowWidget.getSizeHint().width + this.getSpacing();
          } // reset the minWidth because we reduce the count of elements


          hint.minWidth = minWidth;
        }

        return hint;
      },

      /**
       * Resize event handler.
       *
       * @param e {qx.event.type.Data} The resize event.
       */
      _onResize: function _onResize(e) {
        this._recalculateOverflow(e.getData().width);
      },

      /**
       * Responsible for calculation the overflow based on the available width.
       *
       * @param width {Integer?null} The available width.
       * @param requiredWidth {Integer?null} The required width for the widget
       *   if available.
       */
      _recalculateOverflow: function _recalculateOverflow(width, requiredWidth) {
        // do nothing if overflow handling is not enabled
        if (!this.getOverflowHandling()) {
          return;
        } // get all required sizes


        requiredWidth = requiredWidth || this.getSizeHint().width;
        var overflowWidget = this.getOverflowIndicator();
        var overflowWidgetWidth = 0;

        if (overflowWidget) {
          overflowWidgetWidth = overflowWidget.getSizeHint().width;
        }

        if (width == undefined && this.getBounds() != null) {
          width = this.getBounds().width;
        } // if we still don't have a width, than we are not added to a parent


        if (width == undefined) {
          // we should ignore it in that case
          return;
        } // if we have not enough space


        if (width < requiredWidth) {
          do {
            // get the next child
            var childToHide = this._getNextToHide(); // if there is no child to hide, just do nothing


            if (!childToHide) {
              return;
            } // get margins or spacing


            var margins = childToHide.getMarginLeft() + childToHide.getMarginRight();
            margins = Math.max(margins, this.getSpacing());
            var childWidth = childToHide.getSizeHint().width + margins;

            this.__hideChild(childToHide); // new width is the requiredWidth - the removed childs width


            requiredWidth -= childWidth; // show the overflowWidgetWidth

            if (overflowWidget && overflowWidget.getVisibility() != "visible") {
              overflowWidget.setVisibility("visible"); // if we need to add the overflow indicator, we need to add its width

              requiredWidth += overflowWidgetWidth; // add spacing or margins

              var overflowWidgetMargins = overflowWidget.getMarginLeft() + overflowWidget.getMarginRight();
              requiredWidth += Math.max(overflowWidgetMargins, this.getSpacing());
            }
          } while (requiredWidth > width); // if we can possibly show something

        } else if (this.__removedItems.length > 0) {
          do {
            var removedChild = this.__removedItems[0]; // if we have something we can show

            if (removedChild) {
              // get the margins or spacing
              var margins = removedChild.getMarginLeft() + removedChild.getMarginRight();
              margins = Math.max(margins, this.getSpacing()); // check if the element has been rendered before [BUG #4542]

              if (removedChild.getContentElement().getDomElement() == null) {
                // if not, apply the decorator element because it can change the
                // width of the child with padding e.g.
                removedChild.syncAppearance(); // also invalidate the layout cache to trigger size hint
                // recalculation

                removedChild.invalidateLayoutCache();
              }

              var removedChildWidth = removedChild.getSizeHint().width; // check if it fits in in case its the last child to replace

              var fits = false; // if we can remove the overflow widget if its available

              if (this.__removedItems.length == 1 && overflowWidgetWidth > 0) {
                var addedMargin = margins - this.getSpacing();
                var wouldRequiredWidth = requiredWidth - overflowWidgetWidth + removedChildWidth + addedMargin;
                fits = width > wouldRequiredWidth;
              } // if it just fits in || it fits in when we remove the overflow widget


              if (width > requiredWidth + removedChildWidth + margins || fits) {
                this.__showChild(removedChild);

                requiredWidth += removedChildWidth; // check if we need to remove the overflow widget

                if (overflowWidget && this.__removedItems.length == 0) {
                  overflowWidget.setVisibility("excluded");
                }
              } else {
                return;
              }
            }
          } while (width >= requiredWidth && this.__removedItems.length > 0);
        }
      },

      /**
       * Helper to show a toolbar item.
       *
       * @param child {qx.ui.core.Widget} The widget to show.
       */
      __showChild: function __showChild(child) {
        child.setVisibility("visible");

        this.__removedItems.shift();

        this.fireDataEvent("showItem", child);
      },

      /**
       * Helper to exclude a toolbar item.
       *
       * @param child {qx.ui.core.Widget} The widget to exclude.
       */
      __hideChild: function __hideChild(child) {
        // ignore the call if no child is given
        if (!child) {
          return;
        }

        this.__removedItems.unshift(child);

        child.setVisibility("excluded");
        this.fireDataEvent("hideItem", child);
      },

      /**
       * Responsible for returning the next item to remove. In It checks the
       * priorities added by {@link #setRemovePriority}. If all priorized widgets
       * already excluded, it takes the widget added at last.
       *
       * @return {qx.ui.core.Widget|null} The widget which should be removed next.
       *   If null is returned, no widget is available to remove.
       */
      _getNextToHide: function _getNextToHide() {
        // get the elements by priority
        for (var i = this.__removePriority.length - 1; i >= 0; i--) {
          var item = this.__removePriority[i]; // maybe a priority is left out and spacers don't have the visibility

          if (item && item.getVisibility && item.getVisibility() == "visible") {
            return item;
          }
        }

        ; // if there is non found by priority, check all available widgets

        var children = this._getChildren();

        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i]; // ignore the overflow widget

          if (child == this.getOverflowIndicator()) {
            continue;
          } // spacer don't have the visibility


          if (child.getVisibility && child.getVisibility() == "visible") {
            return child;
          }
        }

        ;
      },

      /**
       * The removal of the toolbar items is priority based. You can change these
       * priorities with this method. The higher a priority, the earlier it will
       * be excluded. Remember to use every priority only once! If you want
       * override an already set priority, use the override parameter.
       * Keep in mind to only use already added items.
       *
       * @param item {qx.ui.core.Widget} The item to give the priority.
       * @param priority {Integer} The priority, higher means removed earlier.
       * @param override {Boolean} true, if the priority should be overridden.
       */
      setRemovePriority: function setRemovePriority(item, priority, override) {
        // security check for overriding priorities
        if (!override && this.__removePriority[priority] != undefined) {
          throw new Error("Priority already in use!");
        }

        this.__removePriority[priority] = item;
      },
      // property apply
      _applyOverflowHandling: function _applyOverflowHandling(value, old) {
        // invalidate the own and the parents layout cache because the size hint changes
        this.invalidateLayoutCache();
        var parent = this.getLayoutParent();

        if (parent) {
          parent.invalidateLayoutCache();
        } // recalculate if possible


        var bounds = this.getBounds();

        if (bounds && bounds.width) {
          this._recalculateOverflow(bounds.width);
        } // if the handling has been enabled


        if (value) {
          // add the resize listener
          this.addListener("resize", this._onResize, this); // if the handles has been disabled
        } else {
          this.removeListener("resize", this._onResize, this); // set the overflow indicator to excluded

          var overflowIndicator = this.getOverflowIndicator();

          if (overflowIndicator) {
            overflowIndicator.setVisibility("excluded");
          } // set all buttons back to visible


          for (var i = 0; i < this.__removedItems.length; i++) {
            this.__removedItems[i].setVisibility("visible");
          }

          ; // reset the removed items

          this.__removedItems = [];
        }
      },
      // property apply
      _applyOverflowIndicator: function _applyOverflowIndicator(value, old) {
        if (old) {
          this._remove(old);
        }

        if (value) {
          // check if its a child of the toolbar
          if (this._indexOf(value) == -1) {
            throw new Error("Widget must be child of the toolbar.");
          } // hide the widget


          value.setVisibility("excluded");
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU OPEN
      ---------------------------------------------------------------------------
      */
      __allowMenuOpenHover: false,

      /**
       * Indicate if a menu could be opened on hover or not.
       *
       * @internal
       * @param value {Boolean} <code>true</code> if a menu could be opened,
       *    <code>false</code> otherwise.
       */
      _setAllowMenuOpenHover: function _setAllowMenuOpenHover(value) {
        this.__allowMenuOpenHover = value;
      },

      /**
       * Return if a menu could be opened on hover or not.
       *
       * @internal
       * @return {Boolean} <code>true</code> if a menu could be opened,
       *    <code>false</code> otherwise.
       */
      _isAllowMenuOpenHover: function _isAllowMenuOpenHover() {
        return this.__allowMenuOpenHover;
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applySpacing: function _applySpacing(value, old) {
        var layout = this._getLayout();

        value == null ? layout.resetSpacing() : layout.setSpacing(value);
      },
      // property apply
      _applyShow: function _applyShow(value) {
        var children = this._getChildren();

        for (var i = 0; i < children.length; i++) {
          if (children[i].setShow) {
            children[i].setShow(value);
          }
        }

        ;
      },

      /*
      ---------------------------------------------------------------------------
        CHILD HANDLING
      ---------------------------------------------------------------------------
      */
      // overridden
      _add: function _add(child, options) {
        qx.ui.toolbar.ToolBar.prototype._add.base.call(this, child, options); // sync the show property (bug #6743) - but only if show wasn't explicitly set for the child (bug #6823)


        if (child.setShow && !qx.util.PropertyUtil.getUserValue(child, "show")) {
          child.setShow(this.getShow());
        }

        var newWidth = this.getSizeHint().width + child.getSizeHint().width + 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);
      },
      // overridden
      _addAt: function _addAt(child, index, options) {
        qx.ui.toolbar.ToolBar.prototype._addAt.base.call(this, child, index, options); // sync the show property (bug #6743) - but only if show wasn't explicitly set for the child (bug #6823)


        if (child.setShow && !qx.util.PropertyUtil.getUserValue(child, "show")) {
          child.setShow(this.getShow());
        }

        var newWidth = this.getSizeHint().width + child.getSizeHint().width + 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);
      },
      // overridden
      _addBefore: function _addBefore(child, before, options) {
        qx.ui.toolbar.ToolBar.prototype._addBefore.base.call(this, child, before, options); // sync the show property (bug #6743) - but only if show wasn't explicitly set for the child (bug #6823)


        if (child.setShow && !qx.util.PropertyUtil.getUserValue(child, "show")) {
          child.setShow(this.getShow());
        }

        var newWidth = this.getSizeHint().width + child.getSizeHint().width + 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);
      },
      // overridden
      _addAfter: function _addAfter(child, after, options) {
        qx.ui.toolbar.ToolBar.prototype._addAfter.base.call(this, child, after, options); // sync the show property (bug #6743) - but only if show wasn't explicitly set for the child (bug #6823)


        if (child.setShow && !qx.util.PropertyUtil.getUserValue(child, "show")) {
          child.setShow(this.getShow());
        }

        var newWidth = this.getSizeHint().width + child.getSizeHint().width + 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);
      },
      // overridden
      _remove: function _remove(child) {
        qx.ui.toolbar.ToolBar.prototype._remove.base.call(this, child);

        var newWidth = this.getSizeHint().width - child.getSizeHint().width - 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);
      },
      // overridden
      _removeAt: function _removeAt(index) {
        var child = this._getChildren()[index];

        qx.ui.toolbar.ToolBar.prototype._removeAt.base.call(this, index);

        var newWidth = this.getSizeHint().width - child.getSizeHint().width - 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);

        return child;
      },
      // overridden
      _removeAll: function _removeAll() {
        var children = qx.ui.toolbar.ToolBar.prototype._removeAll.base.call(this);

        this._recalculateOverflow(null, 0);

        return children;
      },

      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */

      /**
       * Add a spacer to the toolbar. The spacer has a flex
       * value of one and will stretch to the available space.
       *
       * @return {qx.ui.core.Spacer} The newly added spacer object. A reference
       *   to the spacer is needed to remove this spacer from the layout.
       */
      addSpacer: function addSpacer() {
        var spacer = new qx.ui.core.Spacer();

        this._add(spacer, {
          flex: 1
        });

        return spacer;
      },

      /**
       * Adds a separator to the toolbar.
       */
      addSeparator: function addSeparator() {
        this.add(new qx.ui.toolbar.Separator());
      },

      /**
       * Returns all nested buttons which contains a menu to show. This is mainly
       * used for keyboard support.
       *
       * @return {Array} List of all menu buttons
       */
      getMenuButtons: function getMenuButtons() {
        var children = this.getChildren();
        var buttons = [];
        var child;

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (child instanceof qx.ui.menubar.Button) {
            buttons.push(child);
          } else if (child instanceof qx.ui.toolbar.Part) {
            buttons.push.apply(buttons, child.getMenuButtons());
          }
        }

        return buttons;
      }
    },
    destruct: function destruct() {
      if (this.hasListener("resize")) {
        this.removeListener("resize", this._onResize, this);
      }
    }
  });
  qx.ui.toolbar.ToolBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.MenuButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.toolbar.ToolBar": {},
      "qx.ui.menu.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A menubar button
   */
  qx.Class.define("qx.ui.menubar.Button", {
    extend: qx.ui.form.MenuButton,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct(label, icon, menu) {
      qx.ui.form.MenuButton.constructor.call(this, label, icon, menu);
      this.removeListener("keydown", this._onKeyDown);
      this.removeListener("keyup", this._onKeyUp);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "menubar-button"
      },
      show: {
        refine: true,
        init: "inherit"
      },
      focusable: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Inspects the parent chain to find the MenuBar
       *
       * @return {qx.ui.menubar.MenuBar} MenuBar instance or <code>null</code>.
       */
      getMenuBar: function getMenuBar() {
        var parent = this;

        while (parent) {
          /* this method is also used by toolbar.MenuButton, so we need to check
             for a ToolBar instance. */
          if (parent instanceof qx.ui.toolbar.ToolBar) {
            return parent;
          }

          parent = parent.getLayoutParent();
        }

        return null;
      },
      // overridden
      open: function open(selectFirst) {
        qx.ui.menubar.Button.prototype.open.base.call(this, selectFirst);
        var menubar = this.getMenuBar();

        if (menubar) {
          menubar._setAllowMenuOpenHover(true);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Listener for visibility property changes of the attached menu
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onMenuChange: function _onMenuChange(e) {
        var menu = this.getMenu();
        var menubar = this.getMenuBar();

        if (menu.isVisible()) {
          this.addState("pressed"); // Sync with open menu property

          if (menubar) {
            menubar.setOpenMenu(menu);
          }
        } else {
          this.removeState("pressed"); // Sync with open menu property

          if (menubar && menubar.getOpenMenu() == menu) {
            menubar.resetOpenMenu();

            menubar._setAllowMenuOpenHover(false);
          }
        }
      },
      // overridden
      _onPointerUp: function _onPointerUp(e) {
        qx.ui.menubar.Button.prototype._onPointerUp.base.call(this, e); // Set state 'pressed' to visualize that the menu is open.


        var menu = this.getMenu();

        if (menu && menu.isVisible() && !this.hasState("pressed")) {
          this.addState("pressed");
        }
      },

      /**
       * Event listener for pointerover event
       *
       * @param e {qx.event.type.Pointer} pointerover event object
       */
      _onPointerOver: function _onPointerOver(e) {
        // Add hovered state
        this.addState("hovered"); // Open submenu

        if (this.getMenu() && e.getPointerType() == "mouse") {
          var menubar = this.getMenuBar();

          if (menubar && menubar._isAllowMenuOpenHover()) {
            // Hide all open menus
            qx.ui.menu.Manager.getInstance().hideAll(); // Set it again, because hideAll remove it.

            menubar._setAllowMenuOpenHover(true); // Then show the attached menu


            if (this.isEnabled()) {
              this.open();
            }
          }
        }
      }
    }
  });
  qx.ui.menubar.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menubar.Button": {
        "require": true
      },
      "qx.ui.toolbar.PartContainer": {},
      "qx.ui.core.queue.Appearance": {},
      "qx.ui.basic.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * The button to fill the menubar
   *
   * @childControl arrow {qx.ui.basic.Image} arrow widget to show a submenu is available
   */
  qx.Class.define("qx.ui.toolbar.MenuButton", {
    extend: qx.ui.menubar.Button,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Appearance of the widget */
      appearance: {
        refine: true,
        init: "toolbar-menubutton"
      },

      /** Whether the button should show an arrow to indicate the menu behind it */
      showArrow: {
        check: "Boolean",
        init: false,
        themeable: true,
        apply: "_applyShowArrow"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _applyVisibility: function _applyVisibility(value, old) {
        qx.ui.toolbar.MenuButton.prototype._applyVisibility.base.call(this, value, old); // hide the menu too


        var menu = this.getMenu();

        if (value != "visible" && menu) {
          menu.hide();
        } // trigger a appearance recalculation of the parent


        var parent = this.getLayoutParent();

        if (parent && parent instanceof qx.ui.toolbar.PartContainer) {
          qx.ui.core.queue.Appearance.add(parent);
        }
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "arrow":
            control = new qx.ui.basic.Image();
            control.setAnonymous(true);

            this._addAt(control, 10);

            break;
        }

        return control || qx.ui.toolbar.MenuButton.prototype._createChildControlImpl.base.call(this, id);
      },
      // property apply routine
      _applyShowArrow: function _applyShowArrow(value, old) {
        if (value) {
          this._showChildControl("arrow");
        } else {
          this._excludeChildControl("arrow");
        }
      }
    }
  });
  qx.ui.toolbar.MenuButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.SplitButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.toolbar.Button": {},
      "qx.ui.toolbar.MenuButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A button which acts as a normal button and shows a menu on one
   * of the sides to open something like a history list.
   *
   * @childControl button {qx.ui.toolbar.Button} button to interact with
   * @childControl arrow {qx.ui.toolbar.MenuButton} menu button to show the menu connected to the split button
   */
  qx.Class.define("qx.ui.toolbar.SplitButton", {
    extend: qx.ui.form.SplitButton,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct(label, icon, menu, command) {
      qx.ui.form.SplitButton.constructor.call(this, label, icon, menu, command); // Toolbar buttons should not support the keyboard events

      this.removeListener("keydown", this._onKeyDown);
      this.removeListener("keyup", this._onKeyUp);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "toolbar-splitbutton"
      },
      // overridden
      focusable: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        hovered: true,
        focused: true,
        left: true,
        middle: true,
        right: true
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "button":
            control = new qx.ui.toolbar.Button();
            control.addListener("execute", this._onButtonExecute, this);

            this._addAt(control, 0);

            break;

          case "arrow":
            control = new qx.ui.toolbar.MenuButton();

            this._addAt(control, 1);

            break;
        }

        return control || qx.ui.toolbar.SplitButton.prototype._createChildControlImpl.base.call(this, id);
      }
    }
  });
  qx.ui.toolbar.SplitButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.tree.core.AbstractTreeItem": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
       2006 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Derrell Lipman (derrell)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The tree file is a leaf tree item. It cannot contain any nested tree items.
   */
  qx.Class.define("qx.ui.tree.TreeFile", {
    extend: qx.ui.tree.core.AbstractTreeItem,
    properties: {
      appearance: {
        refine: true,
        init: "tree-file"
      }
    },
    members: {
      // overridden
      _addWidgets: function _addWidgets() {
        this.addSpacer();
        this.addIcon();
        this.addLabel();
      }
    }
  });
  qx.ui.tree.TreeFile.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MLayoutHandling": {
        "require": true
      },
      "qx.ui.form.MModelSelection": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.core.ISingleSelection": {
        "require": true
      },
      "qx.ui.form.IModelSelection": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.form.RadioGroup": {
        "construct": true
      },
      "qx.ui.form.IRadioItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The radio container handles a collection of items from which only one item
   * can be selected. Selection another item will deselect the previously selected
   * item. For that, it uses the {@link qx.ui.form.RadioGroup} object.
   *
   * This class is used to create radio groups of {@link qx.ui.form.RadioButton}
   * instances.
   *
   * This widget takes care of the layout of the added items. If you want to
   * take full control of the layout and just use the selection behavior,
   * take a look at the {@link qx.ui.form.RadioGroup} object for a loose coupling.
   */
  qx.Class.define("qx.ui.form.RadioButtonGroup", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MLayoutHandling, qx.ui.form.MModelSelection],
    implement: [qx.ui.form.IForm, qx.ui.form.IField, qx.ui.core.ISingleSelection, qx.ui.form.IModelSelection],

    /**
     * @param layout {qx.ui.layout.Abstract} The new layout or
     *     <code>null</code> to reset the layout.
     */
    construct: function construct(layout) {
      qx.ui.core.Widget.constructor.call(this); // if no layout is given, use the default layout (VBox)

      if (layout == null) {
        this.setLayout(new qx.ui.layout.VBox(4));
      } else {
        this.setLayout(layout);
      } // create the radio group


      this.__radioGroup = new qx.ui.form.RadioGroup(); // attach the listener

      this.__radioGroup.addListener("changeSelection", this._onChangeSelection, this);
    },
    properties: {
      /**
       * Flag signaling if the group at all is valid. All children will have the
       * same state.
       */
      valid: {
        check: "Boolean",
        init: true,
        apply: "_applyValid",
        event: "changeValid"
      },

      /**
       * Flag signaling if the group is required.
       */
      required: {
        check: "Boolean",
        init: false,
        event: "changeRequired"
      },

      /**
       * Message which is shown in an invalid tooltip.
       */
      invalidMessage: {
        check: "String",
        init: "",
        event: "changeInvalidMessage",
        apply: "_applyInvalidMessage"
      },

      /**
       * Message which is shown in an invalid tooltip if the {@link #required} is
       * set to true.
       */
      requiredInvalidMessage: {
        check: "String",
        nullable: true,
        event: "changeInvalidMessage"
      }
    },
    events: {
      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data",

      /**
       * Fires after the selection was modified
       */
      "changeSelection": "qx.event.type.Data"
    },
    members: {
      __radioGroup: null,

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyInvalidMessage: function _applyInvalidMessage(value, old) {
        var children = this._getChildren();

        for (var i = 0; i < children.length; i++) {
          children[i].setInvalidMessage(value);
        }
      },
      // property apply
      _applyValid: function _applyValid(value, old) {
        var children = this._getChildren();

        for (var i = 0; i < children.length; i++) {
          children[i].setValid(value);
        }
      },

      /*
      ---------------------------------------------------------------------------
        REGISTRY
      ---------------------------------------------------------------------------
      */

      /**
       * The internally used radio group instance will be returned.
       *
       * @return {qx.ui.form.RadioGroup} Returns the used RadioGroup instance.
       */
      getRadioGroup: function getRadioGroup() {
        return this.__radioGroup;
      },

      /**
       * Returns the children list
       *
       * @return {qx.ui.core.LayoutItem[]} The children array.
       */
      getChildren: function getChildren() {
        return this._getChildren();
      },

      /**
       * Adds a new child widget.
       *
       * The supported keys of the layout options map depend on the layout
       * used to position the widget. The options are documented in the class
       * documentation of each layout manager {@link qx.ui.layout}.
       *
       * @param child {qx.ui.core.LayoutItem} the widget to add.
       * @param options {Map?null} Optional layout data for widget.
       */
      add: function add(child, options) {
        this.__radioGroup.add(child);

        this._add(child, options);
      },

      /**
       * Remove the given child widget.
       *
       * @param child {qx.ui.core.LayoutItem} the widget to remove
       */
      remove: function remove(child) {
        this.__radioGroup.remove(child);

        this._remove(child);
      },

      /**
       * Remove all children.
       *
       * @return {Array} An array of {@link qx.ui.core.LayoutItem}'s.
       */
      removeAll: function removeAll() {
        // remove all children from the radio group
        var radioItems = this.__radioGroup.getItems();

        for (var i = radioItems.length - 1; i >= 0; i--) {
          this.__radioGroup.remove(radioItems[i]);
        }

        return this._removeAll();
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION
      ---------------------------------------------------------------------------
      */

      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {qx.ui.core.Widget[]} List of items.
       */
      getSelection: function getSelection() {
        return this.__radioGroup.getSelection();
      },

      /**
       * Replaces current selection with the given items.
       *
       * @param items {qx.ui.core.Widget[]} Items to select.
       * @throws {Error} if the item is not a child element.
       */
      setSelection: function setSelection(items) {
        this.__radioGroup.setSelection(items);
      },

      /**
       * Clears the whole selection at once.
       */
      resetSelection: function resetSelection() {
        this.__radioGroup.resetSelection();
      },

      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {qx.ui.core.Widget} Any valid selectable item
       * @return {Boolean} Whether the item is selected.
       * @throws {Error} if the item is not a child element.
       */
      isSelected: function isSelected(item) {
        return this.__radioGroup.isSelected(item);
      },

      /**
       * Whether the selection is empty.
       *
       * @return {Boolean} Whether the selection is empty.
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__radioGroup.isSelectionEmpty();
      },

      /**
       * Returns all elements which are selectable.
       *
       * @param all {Boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       * @return {qx.ui.core.Widget[]} The contained items.
       */
      getSelectables: function getSelectables(all) {
        return this.__radioGroup.getSelectables(all);
      },

      /**
       * Select given value.
       *
       * @param item {null|var} Item to set as selected value.
       * @return {null|Error} The status of this operation.
       */
      setValue: function setValue(item) {
        if (item && 'object' === typeof item && item instanceof qx.ui.form.IRadioItem) {
          return this.__radioGroup.setValue(item);
        } else {
          return new Error("can not select radio item from value");
        }
      },

      /**
       * @return {null|var} Returns the selected value.
       */
      getValue: function getValue() {
        return this.__radioGroup.getValue();
      },

      /**
       * Reset radio item selection.
       */
      resetValue: function resetValue() {
        this.__radioGroup.resetValue();
      },

      /**
       * Called on {@link qx.ui.form.RadioGroup} selection change event.
       *
       * @param event {qx.event.type.Data} Event containing the {@link qx.ui.form.RadioGroup} selection data.
       */
      _onChangeSelection: function _onChangeSelection(event) {
        this.fireDataEvent("changeValue", event.getData(), event.getOldData());
        this.fireDataEvent("changeSelection", event.getData(), event.getOldData());
      }
    },
    destruct: function destruct() {
      this.__radioGroup.removeListener("changeSelection", this._onChangeSelection, this);

      this._disposeObjects("__radioGroup");
    }
  });
  qx.ui.form.RadioButtonGroup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.core.Init": {},
      "qx.Class": {},
      "qx.ui.window.IDesktop": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Provides move behavior to any widget.
   *
   * The widget using the mixin must register a widget as move handle so that
   * the pointer events needed for moving it are attached to this widget).
   * <pre class='javascript'>this._activateMoveHandle(widget);</pre>
   */
  qx.Mixin.define("qx.ui.core.MMovable", {
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Whether the widget is movable */
      movable: {
        check: "Boolean",
        init: true
      },

      /** Whether to use a frame instead of the original widget during move sequences */
      useMoveFrame: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __moveHandle: null,
      __moveFrame: null,
      __dragRange: null,
      __dragLeft: null,
      __dragTop: null,
      __parentLeft: null,
      __parentTop: null,
      __blockerAdded: false,
      __oldBlockerColor: null,
      __oldBlockerOpacity: 0,

      /*
      ---------------------------------------------------------------------------
        CORE FEATURES
      ---------------------------------------------------------------------------
      */

      /**
       * Configures the given widget as a move handle
       *
       * @param widget {qx.ui.core.Widget} Widget to activate as move handle
       */
      _activateMoveHandle: function _activateMoveHandle(widget) {
        if (this.__moveHandle) {
          throw new Error("The move handle could not be redefined!");
        }

        this.__moveHandle = widget;
        widget.addListener("pointerdown", this._onMovePointerDown, this);
        widget.addListener("pointerup", this._onMovePointerUp, this);
        widget.addListener("pointermove", this._onMovePointerMove, this);
        widget.addListener("losecapture", this.__onMoveLoseCapture, this);
      },

      /**
       * Get the widget, which draws the resize/move frame.
       *
       * @return {qx.ui.core.Widget} The resize frame
       */
      __getMoveFrame: function __getMoveFrame() {
        var frame = this.__moveFrame;

        if (!frame) {
          frame = this.__moveFrame = new qx.ui.core.Widget();
          frame.setAppearance("move-frame");
          frame.exclude();
          qx.core.Init.getApplication().getRoot().add(frame);
        }

        return frame;
      },

      /**
       * Creates, shows and syncs the frame with the widget.
       */
      __showMoveFrame: function __showMoveFrame() {
        var location = this.getContentLocation();
        var bounds = this.getBounds();

        var frame = this.__getMoveFrame();

        frame.setUserBounds(location.left, location.top, bounds.width, bounds.height);
        frame.show();
        frame.setZIndex(this.getZIndex() + 1);
      },

      /*
      ---------------------------------------------------------------------------
        MOVE SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Computes the new drag coordinates
       *
       * @param e {qx.event.type.Pointer} Pointer event
       * @return {Map} A map with the computed drag coordinates
       */
      __computeMoveCoordinates: function __computeMoveCoordinates(e) {
        var range = this.__dragRange;
        var pointerLeft = Math.max(range.left, Math.min(range.right, e.getDocumentLeft()));
        var pointerTop = Math.max(range.top, Math.min(range.bottom, e.getDocumentTop()));
        var viewportLeft = this.__dragLeft + pointerLeft;
        var viewportTop = this.__dragTop + pointerTop;
        return {
          viewportLeft: parseInt(viewportLeft, 10),
          viewportTop: parseInt(viewportTop, 10),
          parentLeft: parseInt(viewportLeft - this.__parentLeft, 10),
          parentTop: parseInt(viewportTop - this.__parentTop, 10)
        };
      },

      /*
      ---------------------------------------------------------------------------
        MOVE EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Roll handler which prevents the scrolling via tap & move on parent widgets
       * during the move of the widget.
       * @param e {qx.event.type.Roll} The roll event
       */
      _onMoveRoll: function _onMoveRoll(e) {
        e.stop();
      },

      /**
       * Enables the capturing of the caption bar and prepares the drag session and the
       * appearance (translucent, frame or opaque) for the moving of the window.
       *
       * @param e {qx.event.type.Pointer} pointer down event
       */
      _onMovePointerDown: function _onMovePointerDown(e) {
        if (!this.getMovable() || this.hasState("maximized")) {
          return;
        }

        this.addListener("roll", this._onMoveRoll, this); // Compute drag range

        var parent = this.getLayoutParent();
        var parentLocation = parent.getContentLocation();
        var parentBounds = parent.getBounds(); // Added a blocker, this solves the issue described in [BUG #1462]

        if (qx.Class.implementsInterface(parent, qx.ui.window.IDesktop)) {
          if (!parent.isBlocked()) {
            this.__oldBlockerColor = parent.getBlockerColor();
            this.__oldBlockerOpacity = parent.getBlockerOpacity();
            parent.setBlockerColor(null);
            parent.setBlockerOpacity(1);
            parent.blockContent(this.getZIndex() - 1);
            this.__blockerAdded = true;
          }
        }

        this.__dragRange = {
          left: parentLocation.left,
          top: parentLocation.top,
          right: parentLocation.left + parentBounds.width,
          bottom: parentLocation.top + parentBounds.height
        }; // Compute drag positions

        var widgetLocation = this.getContentLocation();
        this.__parentLeft = parentLocation.left;
        this.__parentTop = parentLocation.top;
        this.__dragLeft = widgetLocation.left - e.getDocumentLeft();
        this.__dragTop = widgetLocation.top - e.getDocumentTop(); // Add state

        this.addState("move"); // Enable capturing

        this.__moveHandle.capture(); // Enable drag frame


        if (this.getUseMoveFrame()) {
          this.__showMoveFrame();
        } // Stop event


        e.stop();
      },

      /**
       * Does the moving of the window by rendering the position
       * of the window (or frame) at runtime using direct dom methods.
       *
       * @param e {qx.event.type.Pointer} pointer move event
       */
      _onMovePointerMove: function _onMovePointerMove(e) {
        // Only react when dragging is active
        if (!this.hasState("move")) {
          return;
        } // Apply new coordinates using DOM


        var coords = this.__computeMoveCoordinates(e);

        if (this.getUseMoveFrame()) {
          this.__getMoveFrame().setDomPosition(coords.viewportLeft, coords.viewportTop);
        } else {
          var insets = this.getLayoutParent().getInsets();
          this.setDomPosition(coords.parentLeft - (insets.left || 0), coords.parentTop - (insets.top || 0));
        }

        e.stopPropagation();
      },

      /**
       * Disables the capturing of the caption bar and moves the window
       * to the last position of the drag session. Also restores the appearance
       * of the window.
       *
       * @param e {qx.event.type.Pointer} pointer up event
       */
      _onMovePointerUp: function _onMovePointerUp(e) {
        if (this.hasListener("roll")) {
          this.removeListener("roll", this._onMoveRoll, this);
        } // Only react when dragging is active


        if (!this.hasState("move")) {
          return;
        } // Remove drag state


        this.removeState("move"); // Removed blocker, this solves the issue described in [BUG #1462]

        var parent = this.getLayoutParent();

        if (qx.Class.implementsInterface(parent, qx.ui.window.IDesktop)) {
          if (this.__blockerAdded) {
            parent.unblock();
            parent.setBlockerColor(this.__oldBlockerColor);
            parent.setBlockerOpacity(this.__oldBlockerOpacity);
            this.__oldBlockerColor = null;
            this.__oldBlockerOpacity = 0;
            this.__blockerAdded = false;
          }
        } // Disable capturing


        this.__moveHandle.releaseCapture(); // Apply them to the layout


        var coords = this.__computeMoveCoordinates(e);

        var insets = this.getLayoutParent().getInsets();
        this.setLayoutProperties({
          left: coords.parentLeft - (insets.left || 0),
          top: coords.parentTop - (insets.top || 0)
        }); // Hide frame afterwards

        if (this.getUseMoveFrame()) {
          this.__getMoveFrame().exclude();
        }

        e.stopPropagation();
      },

      /**
       * Event listener for <code>losecapture</code> event.
       *
       * @param e {qx.event.type.Event} Lose capture event
       */
      __onMoveLoseCapture: function __onMoveLoseCapture(e) {
        // Check for active move
        if (!this.hasState("move")) {
          return;
        } // Remove drag state


        this.removeState("move"); // Hide frame afterwards

        if (this.getUseMoveFrame()) {
          this.__getMoveFrame().exclude();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__moveFrame", "__moveHandle");

      this.__dragRange = null;
    }
  });
  qx.ui.core.MMovable.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.window.IDesktop": {},
      "qx.ui.window.Window": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Required interface for all window manager.
   *
   * Window manager handle the z-order and modality blocking of windows managed
   * by the connected desktop {@link qx.ui.window.IDesktop}.
   */
  qx.Interface.define("qx.ui.window.IWindowManager", {
    members: {
      /**
       * Connect the window manager to the window desktop
       *
       * @param desktop {qx.ui.window.IDesktop|null} The connected desktop or null
       */
      setDesktop: function setDesktop(desktop) {
        if (desktop !== null) {
          this.assertInterface(desktop, qx.ui.window.IDesktop);
        }
      },

      /**
       * Inform the window manager about a new active window
       *
       * @param active {qx.ui.window.Window} new active window
       * @param oldActive {qx.ui.window.Window} old active window
       */
      changeActiveWindow: function changeActiveWindow(active, oldActive) {},

      /**
       * Update the window order and modality blocker
       */
      updateStack: function updateStack() {},

      /**
       * Ask the manager to bring a window to the front.
       *
       * @param win {qx.ui.window.Window} window to bring to front
       */
      bringToFront: function bringToFront(win) {
        this.assertInstance(win, qx.ui.window.Window);
      },

      /**
       * Ask the manager to send a window to the back.
       *
       * @param win {qx.ui.window.Window} window to sent to back
       */
      sendToBack: function sendToBack(win) {
        this.assertInstance(win, qx.ui.window.Window);
      }
    }
  });
  qx.ui.window.IWindowManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.window.IWindowManager": {
        "require": true
      },
      "qx.ui.core.queue.Widget": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The default window manager implementation
   */
  qx.Class.define("qx.ui.window.Manager", {
    extend: qx.core.Object,
    implement: qx.ui.window.IWindowManager,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __desktop: null,
      // interface implementation
      setDesktop: function setDesktop(desktop) {
        this.__desktop = desktop;

        if (desktop) {
          this.updateStack();
        } else {
          // the window manager should be removed
          // from the widget queue if the desktop
          // was set to null
          qx.ui.core.queue.Widget.remove(this);
        }
      },

      /**
       * Returns the connected desktop
       *
       * @return {qx.ui.window.IDesktop} The desktop
       */
      getDesktop: function getDesktop() {
        return this.__desktop;
      },
      // interface implementation
      changeActiveWindow: function changeActiveWindow(active, oldActive) {
        if (active) {
          this.bringToFront(active);
          active.setActive(true);
        }

        if (oldActive) {
          oldActive.resetActive();
        }
      },

      /** @type {Integer} Minimum zIndex to start with for windows */
      _minZIndex: 1e5,
      // interface implementation
      updateStack: function updateStack() {
        // we use the widget queue to do the sorting one before the queues are
        // flushed. The queue will call "syncWidget"
        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * This method is called during the flush of the
       * {@link qx.ui.core.queue.Widget widget queue}.
       */
      syncWidget: function syncWidget() {
        this.__desktop.forceUnblock();

        var windows = this.__desktop.getWindows(); // z-index for all three window kinds


        var zIndex = this._minZIndex;
        var zIndexOnTop = zIndex + windows.length * 2;
        var zIndexModal = zIndex + windows.length * 4; // marker if there is an active window

        var active = null;

        for (var i = 0, l = windows.length; i < l; i++) {
          var win = windows[i]; // ignore invisible windows

          if (!win.isVisible()) {
            continue;
          } // take the first window as active window


          active = active || win; // We use only every second z index to easily insert a blocker between
          // two windows
          // Modal Windows stays on top of AlwaysOnTop Windows, which stays on
          // top of Normal Windows.

          if (win.isModal()) {
            win.setZIndex(zIndexModal);

            this.__desktop.blockContent(zIndexModal - 1);

            zIndexModal += 2; //just activate it if it's modal

            active = win;
          } else if (win.isAlwaysOnTop()) {
            win.setZIndex(zIndexOnTop);
            zIndexOnTop += 2;
          } else {
            win.setZIndex(zIndex);
            zIndex += 2;
          } // store the active window


          if (!active.isModal() && win.isActive() || win.getZIndex() > active.getZIndex()) {
            active = win;
          }
        } //set active window or null otherwise


        this.__desktop.setActiveWindow(active);
      },
      // interface implementation
      bringToFront: function bringToFront(win) {
        var windows = this.__desktop.getWindows();

        var removed = qx.lang.Array.remove(windows, win);

        if (removed) {
          windows.push(win);
          this.updateStack();
        }
      },
      // interface implementation
      sendToBack: function sendToBack(win) {
        var windows = this.__desktop.getWindows();

        var removed = qx.lang.Array.remove(windows, win);

        if (removed) {
          windows.unshift(win);
          this.updateStack();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__desktop");
    }
  });
  qx.ui.window.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.core.MRemoteLayoutHandling": {
        "require": true
      },
      "qx.ui.core.MResizable": {
        "require": true
      },
      "qx.ui.core.MMovable": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.ui.core.FocusHandler": {
        "construct": true
      },
      "qx.ui.window.Manager": {
        "require": true
      },
      "qx.ui.window.IDesktop": {},
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.basic.Label": {},
      "qx.ui.layout.Grid": {},
      "qx.ui.basic.Image": {},
      "qx.ui.form.Button": {},
      "qx.event.type.Event": {},
      "qx.bom.client.Engine": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A window widget
   *
   * More information can be found in the package description {@link qx.ui.window}.
   *
   * @childControl statusbar {qx.ui.container.Composite} statusbar container which shows the statusbar text
   * @childControl statusbar-text {qx.ui.basic.Label} text of the statusbar
   * @childControl pane {qx.ui.container.Composite} window pane which holds the content
   * @childControl captionbar {qx.ui.container.Composite} Container for all widgets inside the captionbar
   * @childControl icon {qx.ui.basic.Image} icon at the left of the captionbar
   * @childControl title {qx.ui.basic.Label} caption of the window
   * @childControl minimize-button {qx.ui.form.Button} button to minimize the window
   * @childControl restore-button {qx.ui.form.Button} button to restore the window
   * @childControl maximize-button {qx.ui.form.Button} button to maximize the window
   * @childControl close-button {qx.ui.form.Button} button to close the window
   */
  qx.Class.define("qx.ui.window.Window", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.core.MRemoteLayoutHandling, qx.ui.core.MResizable, qx.ui.core.MMovable, qx.ui.core.MContentPadding],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param caption {String?} The caption text
     * @param icon {String?} The URL of the caption bar icon
     */
    construct: function construct(caption, icon) {
      qx.ui.core.Widget.constructor.call(this); // configure internal layout

      this._setLayout(new qx.ui.layout.VBox()); // force creation of captionbar


      this._createChildControl("captionbar");

      this._createChildControl("pane"); // apply constructor parameters


      if (icon != null) {
        this.setIcon(icon);
      }

      if (caption != null) {
        this.setCaption(caption);
      } // Update captionbar


      this._updateCaptionBar(); // Activation listener


      this.addListener("pointerdown", this._onWindowPointerDown, this, true); // Focusout listener

      this.addListener("focusout", this._onWindowFocusOut, this); // Automatically add to application root.

      qx.core.Init.getApplication().getRoot().add(this); // Initialize visibility

      this.initVisibility(); // Register as root for the focus handler

      qx.ui.core.FocusHandler.getInstance().addRoot(this); // Change the resize frames appearance

      this._getResizeFrame().setAppearance("window-resize-frame");
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {Class} The default window manager class. */
      DEFAULT_MANAGER_CLASS: qx.ui.window.Manager
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired before the window is closed.
       *
       * The close action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeClose": "qx.event.type.Event",

      /** Fired if the window is closed */
      "close": "qx.event.type.Event",

      /**
       * Fired before the window is minimize.
       *
       * The minimize action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeMinimize": "qx.event.type.Event",

      /** Fired if the window is minimized */
      "minimize": "qx.event.type.Event",

      /**
       * Fired before the window is maximize.
       *
       * The maximize action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeMaximize": "qx.event.type.Event",

      /** Fired if the window is maximized */
      "maximize": "qx.event.type.Event",

      /**
       * Fired before the window is restored from a minimized or maximized state.
       *
       * The restored action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeRestore": "qx.event.type.Event",

      /** Fired if the window is restored from a minimized or maximized state */
      "restore": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /*
      ---------------------------------------------------------------------------
        INTERNAL OPTIONS
      ---------------------------------------------------------------------------
      */
      // overridden
      appearance: {
        refine: true,
        init: "window"
      },
      // overridden
      visibility: {
        refine: true,
        init: "excluded"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /**
       * If the window is active, only one window in a single qx.ui.window.Manager could
       *  have set this to true at the same time.
       */
      active: {
        check: "Boolean",
        init: false,
        apply: "_applyActive",
        event: "changeActive"
      },

      /*
      ---------------------------------------------------------------------------
        BASIC OPTIONS
      ---------------------------------------------------------------------------
      */

      /** Should the window be always on top */
      alwaysOnTop: {
        check: "Boolean",
        init: false,
        event: "changeAlwaysOnTop"
      },

      /** Should the window be modal (this disables minimize and maximize buttons) */
      modal: {
        check: "Boolean",
        init: false,
        event: "changeModal",
        apply: "_applyModal"
      },

      /** The text of the caption */
      caption: {
        apply: "_applyCaptionBarChange",
        event: "changeCaption",
        nullable: true
      },

      /** The icon of the caption */
      icon: {
        check: "String",
        nullable: true,
        apply: "_applyCaptionBarChange",
        event: "changeIcon",
        themeable: true
      },

      /** The text of the statusbar */
      status: {
        check: "String",
        nullable: true,
        apply: "_applyStatus",
        event: "changeStatus"
      },

      /*
      ---------------------------------------------------------------------------
        HIDE CAPTIONBAR FEATURES
      ---------------------------------------------------------------------------
      */

      /** Should the close button be shown */
      showClose: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange",
        themeable: true
      },

      /** Should the maximize button be shown */
      showMaximize: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange",
        themeable: true
      },

      /** Should the minimize button be shown */
      showMinimize: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange",
        themeable: true
      },

      /*
      ---------------------------------------------------------------------------
        DISABLE CAPTIONBAR FEATURES
      ---------------------------------------------------------------------------
      */

      /** Should the user have the ability to close the window */
      allowClose: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange"
      },

      /** Should the user have the ability to maximize the window */
      allowMaximize: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange"
      },

      /** Should the user have the ability to minimize the window */
      allowMinimize: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange"
      },

      /*
      ---------------------------------------------------------------------------
        STATUSBAR CONFIG
      ---------------------------------------------------------------------------
      */

      /** Should the statusbar be shown */
      showStatusbar: {
        check: "Boolean",
        init: false,
        apply: "_applyShowStatusbar"
      },

      /*
      ---------------------------------------------------------------------------
        WHEN TO AUTOMATICALY CENTER
      ---------------------------------------------------------------------------
      */

      /** Whether this window should be automatically centered when it appears */
      centerOnAppear: {
        init: false,
        check: "Boolean",
        apply: "_applyCenterOnAppear"
      },

      /** 
       * Whether this window should be automatically centered when its container
       * is resized.
       */
      centerOnContainerResize: {
        init: false,
        check: "Boolean",
        apply: "_applyCenterOnContainerResize"
      },

      /*
      ---------------------------------------------------------------------------
        CLOSE BEHAVIOR
      ---------------------------------------------------------------------------
      */

      /** 
       * Should the window be automatically destroyed when it is closed.
       *
       * When false, closing the window behaves like hiding the window.
       * 
       * When true, the window is removed from its container (the root), all
       * listeners are removed, the window's widgets are removed, and the window
       * is destroyed.
       *
       * NOTE: If any widgets that were added to this window require special
       * clean-up, you should listen on the 'close' event and remove and clean
       * up those widgets there.
       */
      autoDestroy: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {Integer} Original top value before maximation had occurred */
      __restoredTop: null,

      /** @type {Integer} Original left value before maximation had occurred */
      __restoredLeft: null,

      /** @type {Integer} Listener ID for centering on appear */
      __centeringAppearId: null,

      /** @type {Integer} Listener ID for centering on resize */
      __centeringResizeId: null,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */

      /**
       * The children container needed by the {@link qx.ui.core.MRemoteChildrenHandling}
       * mixin
       *
       * @return {qx.ui.container.Composite} pane sub widget
       */
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("pane");
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        active: true,
        maximized: true,
        showStatusbar: true,
        modal: true
      },
      // overridden
      setLayoutParent: function setLayoutParent(parent) {
        var oldParent;
        {
          parent && this.assertInterface(parent, qx.ui.window.IDesktop, "Windows can only be added to widgets, which implement the interface qx.ui.window.IDesktop. All root widgets implement this interface.");
        } // Before changing the parent, if there's a prior one, remove our resize
        // listener

        oldParent = this.getLayoutParent();

        if (oldParent && this.__centeringResizeId) {
          oldParent.removeListenerById(this.__centeringResizeId);
          this.__centeringResizeId = null;
        } // Call the superclass


        qx.ui.window.Window.prototype.setLayoutParent.base.call(this, parent); // Re-add a listener for resize, if required

        if (parent && this.getCenterOnContainerResize()) {
          this.__centeringResizeId = parent.addListener("resize", this.center, this);
        }
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "statusbar":
            control = new qx.ui.container.Composite(new qx.ui.layout.HBox());

            this._add(control);

            control.add(this.getChildControl("statusbar-text"));
            break;

          case "statusbar-text":
            control = new qx.ui.basic.Label();
            control.setValue(this.getStatus());
            break;

          case "pane":
            control = new qx.ui.container.Composite();

            this._add(control, {
              flex: 1
            });

            break;

          case "captionbar":
            // captionbar
            var layout = new qx.ui.layout.Grid();
            layout.setRowFlex(0, 1);
            layout.setColumnFlex(1, 1);
            control = new qx.ui.container.Composite(layout);

            this._add(control); // captionbar events


            control.addListener("dbltap", this._onCaptionPointerDblTap, this); // register as move handle

            this._activateMoveHandle(control);

            break;

          case "icon":
            control = new qx.ui.basic.Image(this.getIcon());
            this.getChildControl("captionbar").add(control, {
              row: 0,
              column: 0
            });
            break;

          case "title":
            control = new qx.ui.basic.Label(this.getCaption());
            control.setWidth(0);
            control.setAllowGrowX(true);
            var captionBar = this.getChildControl("captionbar");
            captionBar.add(control, {
              row: 0,
              column: 1
            });
            break;

          case "minimize-button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.addListener("execute", this._onMinimizeButtonTap, this);
            this.getChildControl("captionbar").add(control, {
              row: 0,
              column: 2
            });
            break;

          case "restore-button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.addListener("execute", this._onRestoreButtonTap, this);
            this.getChildControl("captionbar").add(control, {
              row: 0,
              column: 3
            });
            break;

          case "maximize-button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.addListener("execute", this._onMaximizeButtonTap, this);
            this.getChildControl("captionbar").add(control, {
              row: 0,
              column: 4
            });
            break;

          case "close-button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.addListener("execute", this._onCloseButtonTap, this);
            this.getChildControl("captionbar").add(control, {
              row: 0,
              column: 6
            });
            break;
        }

        return control || qx.ui.window.Window.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        CAPTIONBAR INTERNALS
      ---------------------------------------------------------------------------
      */

      /**
       * Updates the status and the visibility of each element of the captionbar.
       */
      _updateCaptionBar: function _updateCaptionBar() {
        var btn;
        var icon = this.getIcon();

        if (icon) {
          this.getChildControl("icon").setSource(icon);

          this._showChildControl("icon");
        } else {
          this._excludeChildControl("icon");
        }

        var caption = this.getCaption();

        if (caption) {
          this.getChildControl("title").setValue(caption);

          this._showChildControl("title");
        } else {
          this._excludeChildControl("title");
        }

        if (this.getShowMinimize()) {
          this._showChildControl("minimize-button");

          btn = this.getChildControl("minimize-button");
          this.getAllowMinimize() ? btn.resetEnabled() : btn.setEnabled(false);
        } else {
          this._excludeChildControl("minimize-button");
        }

        if (this.getShowMaximize()) {
          if (this.isMaximized()) {
            this._showChildControl("restore-button");

            this._excludeChildControl("maximize-button");
          } else {
            this._showChildControl("maximize-button");

            this._excludeChildControl("restore-button");
          }

          btn = this.getChildControl("maximize-button");
          this.getAllowMaximize() ? btn.resetEnabled() : btn.setEnabled(false);
        } else {
          this._excludeChildControl("maximize-button");

          this._excludeChildControl("restore-button");
        }

        if (this.getShowClose()) {
          this._showChildControl("close-button");

          btn = this.getChildControl("close-button");
          this.getAllowClose() ? btn.resetEnabled() : btn.setEnabled(false);
        } else {
          this._excludeChildControl("close-button");
        }
      },

      /*
      ---------------------------------------------------------------------------
        USER API
      ---------------------------------------------------------------------------
      */

      /**
       * Close the current window instance.
       *
       * Simply calls the {@link qx.ui.core.Widget#hide} method if the
       * {@link qx.ui.win.Window#autoDestroy} property is false; otherwise 
       * removes and destroys the window.
       */
      close: function close() {
        if (!this.getAutoDestroy() && !this.isVisible()) {
          return;
        }

        if (this.fireNonBubblingEvent("beforeClose", qx.event.type.Event, [false, true])) {
          this.hide();
          this.fireEvent("close");
        } // If automatically destroying the window upon close was requested, do
        // so now. (Note that we explicitly re-obtain the autoDestroy property
        // value, allowing the user's close handler to enable/disable it before
        // here.)


        if (this.getAutoDestroy()) {
          this.dispose();
        }
      },

      /**
       * Open the window.
       */
      open: function open() {
        this.show();
        this.setActive(true);
        this.focus();
      },

      /**
       * Centers the window to the parent.
       *
       * This call works with the size of the parent widget and the size of
       * the window as calculated in the last layout flush. It is best to call
       * this method just after rendering the window in the "resize" event:
       * <pre class='javascript'>
       *   win.addListenerOnce("resize", this.center, this);
       * </pre>
       */
      center: function center() {
        var parent = this.getLayoutParent();

        if (parent) {
          var bounds = parent.getBounds();

          if (bounds) {
            var hint = this.getSizeHint();
            var left = Math.round((bounds.width - hint.width) / 2);
            var top = Math.round((bounds.height - hint.height) / 2);

            if (top < 0) {
              top = 0;
            }

            this.moveTo(left, top);
            return;
          }
        }

        {
          this.warn("Centering depends on parent bounds!");
        }
      },

      /**
       * Maximize the window.
       */
      maximize: function maximize() {
        // If the window is already maximized -> return
        if (this.isMaximized()) {
          return;
        } // First check if the parent uses a canvas layout
        // Otherwise maximize() is not possible


        var parent = this.getLayoutParent();

        if (parent != null && parent.supportsMaximize()) {
          if (this.fireNonBubblingEvent("beforeMaximize", qx.event.type.Event, [false, true])) {
            if (!this.isVisible()) {
              this.open();
            } // store current dimension and location


            var props = this.getLayoutProperties();
            this.__restoredLeft = props.left === undefined ? 0 : props.left;
            this.__restoredTop = props.top === undefined ? 0 : props.top; // Update layout properties

            this.setLayoutProperties({
              left: null,
              top: null,
              edge: 0
            }); // Add state

            this.addState("maximized"); // Update captionbar

            this._updateCaptionBar(); // Fire user event


            this.fireEvent("maximize");
          }
        }
      },

      /**
       * Minimized the window.
       */
      minimize: function minimize() {
        if (!this.isVisible()) {
          return;
        }

        if (this.fireNonBubblingEvent("beforeMinimize", qx.event.type.Event, [false, true])) {
          // store current dimension and location
          var props = this.getLayoutProperties();
          this.__restoredLeft = props.left === undefined ? 0 : props.left;
          this.__restoredTop = props.top === undefined ? 0 : props.top;
          this.removeState("maximized");
          this.hide();
          this.fireEvent("minimize");
        }
      },

      /**
       * Restore the window to <code>"normal"</code>, if it is
       * <code>"maximized"</code> or <code>"minimized"</code>.
       */
      restore: function restore() {
        if (this.getMode() === "normal") {
          return;
        }

        if (this.fireNonBubblingEvent("beforeRestore", qx.event.type.Event, [false, true])) {
          if (!this.isVisible()) {
            this.open();
          } // Restore old properties


          var left = this.__restoredLeft;
          var top = this.__restoredTop;
          this.setLayoutProperties({
            edge: null,
            left: left,
            top: top
          }); // Remove maximized state

          this.removeState("maximized"); // Update captionbar

          this._updateCaptionBar(); // Fire user event


          this.fireEvent("restore");
        }
      },

      /**
       * Set the window's position relative to its parent
       *
       * @param left {Integer} The left position
       * @param top {Integer} The top position
       */
      moveTo: function moveTo(left, top) {
        if (this.isMaximized()) {
          return;
        }

        this.setLayoutProperties({
          left: left,
          top: top
        });
      },

      /**
       * Return <code>true</code> if the window is in maximized state,
       * but note that the window in maximized state could also be invisible, this
       * is equivalent to minimized. So use the {@link qx.ui.window.Window#getMode}
       * to get the window mode.
       *
       * @return {Boolean} <code>true</code> if the window is maximized,
       *   <code>false</code> otherwise.
       */
      isMaximized: function isMaximized() {
        return this.hasState("maximized");
      },

      /**
       * Return the window mode as <code>String</code>:
       * <code>"maximized"</code>, <code>"normal"</code> or <code>"minimized"</code>.
       *
       * @return {String} The window mode as <code>String</code> value.
       */
      getMode: function getMode() {
        if (!this.isVisible()) {
          return "minimized";
        } else {
          if (this.isMaximized()) {
            return "maximized";
          } else {
            return "normal";
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyActive: function _applyActive(value, old) {
        if (old) {
          this.removeState("active");
        } else {
          this.addState("active");
        }
      },
      // property apply
      _applyModal: function _applyModal(value, old) {
        if (old) {
          this.removeState("modal");
        } else {
          this.addState("modal");
        }
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getChildControl("pane");
      },
      // property apply
      _applyShowStatusbar: function _applyShowStatusbar(value, old) {
        // store the state if the status bar is shown
        var resizeFrame = this._getResizeFrame();

        if (value) {
          this.addState("showStatusbar");
          resizeFrame.addState("showStatusbar");
        } else {
          this.removeState("showStatusbar");
          resizeFrame.removeState("showStatusbar");
        }

        if (value) {
          this._showChildControl("statusbar");
        } else {
          this._excludeChildControl("statusbar");
        }
      },
      // property apply
      _applyCaptionBarChange: function _applyCaptionBarChange(value, old) {
        this._updateCaptionBar();
      },
      // property apply
      _applyStatus: function _applyStatus(value, old) {
        var label = this.getChildControl("statusbar-text", true);

        if (label) {
          label.setValue(value);
        }
      },
      // overridden
      _applyFocusable: function _applyFocusable(value, old) {
        // Workaround for bug #7581: Don't set the tabIndex
        // to prevent native scrolling on focus in IE
        if (qx.core.Environment.get("engine.name") !== "mshtml") {
          qx.ui.window.Window.prototype._applyFocusable.base.call(this, value, old);
        }
      },
      _applyCenterOnAppear: function _applyCenterOnAppear(value, old) {
        // Remove prior listener for centering on appear
        if (this.__centeringAppearId !== null) {
          this.removeListenerById(this.__centeringAppearId);
          this.__centeringAppearId = null;
        } // If we are to center on appear, arrange to do so


        if (value) {
          this.__centeringAppearId = this.addListener("appear", this.center, this);
        }
      },
      _applyCenterOnContainerResize: function _applyCenterOnContainerResize(value, old) {
        var parent = this.getLayoutParent(); // Remove prior listener for centering on resize

        if (this.__centeringResizeId !== null) {
          parent.removeListenerById(this.__centeringResizeId);
          this.__centeringResizeId = null;
        } // If we are to center on resize, arrange to do so


        if (value) {
          if (parent) {
            this.__centeringResizeId = parent.addListener("resize", this.center, this);
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        BASIC EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Stops every event
       *
       * @param e {qx.event.type.Event} any event
       */
      _onWindowEventStop: function _onWindowEventStop(e) {
        e.stopPropagation();
      },

      /**
       * Focuses the window instance.
       *
       * @param e {qx.event.type.Pointer} pointer down event
       */
      _onWindowPointerDown: function _onWindowPointerDown(e) {
        this.setActive(true);
      },

      /**
       * Listens to the "focusout" event to deactivate the window (if the
       * currently focused widget is not a child of the window)
       *
       * @param e {qx.event.type.Focus} focus event
       */
      _onWindowFocusOut: function _onWindowFocusOut(e) {
        // only needed for non-modal windows
        if (this.getModal()) {
          return;
        } // get the current focused widget and check if it is a child


        var current = e.getRelatedTarget();

        if (current != null && !qx.ui.core.Widget.contains(this, current)) {
          this.setActive(false);
        }
      },

      /**
       * Maximizes the window or restores it if it is already
       * maximized.
       *
       * @param e {qx.event.type.Pointer} double tap event
       */
      _onCaptionPointerDblTap: function _onCaptionPointerDblTap(e) {
        if (this.getAllowMaximize() && (e.getTarget() === this.getChildControl("captionbar") || e.getTarget() === this.getChildControl("title"))) {
          this.isMaximized() ? this.restore() : this.maximize();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENTS FOR CAPTIONBAR BUTTONS
      ---------------------------------------------------------------------------
      */

      /**
       * Minimizes the window, removes all states from the minimize button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Pointer} pointer tap event
       */
      _onMinimizeButtonTap: function _onMinimizeButtonTap(e) {
        this.minimize();
        this.getChildControl("minimize-button").reset();
      },

      /**
       * Restores the window, removes all states from the restore button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Pointer} pointer pointer event
       */
      _onRestoreButtonTap: function _onRestoreButtonTap(e) {
        this.restore();
        this.getChildControl("restore-button").reset();
      },

      /**
       * Maximizes the window, removes all states from the maximize button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Pointer} pointer pointer event
       */
      _onMaximizeButtonTap: function _onMaximizeButtonTap(e) {
        this.maximize();
        this.getChildControl("maximize-button").reset();
      },

      /**
       * Closes the window, removes all states from the close button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Pointer} pointer pointer event
       */
      _onCloseButtonTap: function _onCloseButtonTap(e) {
        this.close();
        this.getChildControl("close-button").reset();
      }
    },
    destruct: function destruct() {
      var id;
      var parent; // Remove ourselves from the focus handler

      qx.ui.core.FocusHandler.getInstance().removeRoot(this); // If we haven't been removed from our parent, clean it up too.

      parent = this.getLayoutParent();

      if (parent) {
        // Remove the listener for resize, if there is one
        id = this.__centeringResizeId;
        id && parent.removeListenerById(id); // Remove ourself from our parent

        parent.remove(this);
      }
    }
  });
  qx.ui.window.Window.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.event.Registration": {
        "construct": true
      },
      "qx.bom.client.Event": {
        "construct": true
      },
      "qx.bom.Element": {
        "construct": true
      },
      "qx.event.Timer": {
        "construct": true
      },
      "qx.ui.menu.Menu": {},
      "qx.ui.menu.AbstractButton": {},
      "qx.lang.Array": {},
      "qx.ui.core.Widget": {},
      "qx.ui.menubar.Button": {},
      "qx.ui.menu.Button": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "event.touch": {
          "construct": true,
          "className": "qx.bom.client.Event"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * This singleton manages visible menu instances and supports some
   * core features to schedule menu open/close with timeout support.
   *
   * It also manages the whole keyboard support for the currently
   * registered widgets.
   *
   * The zIndex order is also managed by this class.
   */
  qx.Class.define("qx.ui.menu.Manager", {
    type: "singleton",
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this); // Create data structure

      this.__objects = [];
      var el = document.body;
      var Registration = qx.event.Registration; // React on pointer/mouse events, but on native, to support inline applications

      Registration.addListener(window.document.documentElement, "pointerdown", this._onPointerDown, this, true);
      Registration.addListener(el, "roll", this._onRoll, this, true); // React on keypress events

      Registration.addListener(el, "keydown", this._onKeyUpDown, this, true);
      Registration.addListener(el, "keyup", this._onKeyUpDown, this, true);
      Registration.addListener(el, "keypress", this._onKeyPress, this, true); // only use the blur event to hide windows on non touch devices [BUG #4033]
      // When the menu is located on top of an iFrame, the select will fail

      if (!qx.core.Environment.get("event.touch")) {
        // Hide all when the window is blurred
        qx.bom.Element.addListener(window, "blur", this.hideAll, this);
      } // Create open timer


      this.__openTimer = new qx.event.Timer();

      this.__openTimer.addListener("interval", this._onOpenInterval, this); // Create close timer


      this.__closeTimer = new qx.event.Timer();

      this.__closeTimer.addListener("interval", this._onCloseInterval, this);
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __scheduleOpen: null,
      __scheduleClose: null,
      __openTimer: null,
      __closeTimer: null,
      __objects: null,

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Query engine for menu children.
       *
       * @param menu {qx.ui.menu.Menu} Any menu instance
       * @param start {Integer} Child index to start with
       * @param iter {Integer} Iteration count, normally <code>+1</code> or <code>-1</code>
       * @param loop {Boolean?false} Whether to wrap when reaching the begin/end of the list
       * @return {qx.ui.menu.Button} Any menu button or <code>null</code>
       */
      _getChild: function _getChild(menu, start, iter, loop) {
        var children = menu.getChildren();
        var length = children.length;
        var child;

        for (var i = start; i < length && i >= 0; i += iter) {
          child = children[i];

          if (child.isEnabled() && !child.isAnonymous() && child.isVisible()) {
            return child;
          }
        }

        if (loop) {
          i = i == length ? 0 : length - 1;

          for (; i != start; i += iter) {
            child = children[i];

            if (child.isEnabled() && !child.isAnonymous() && child.isVisible()) {
              return child;
            }
          }
        }

        return null;
      },

      /**
       * Whether the given widget is inside any Menu instance.
       *
       * @param widget {qx.ui.core.Widget} Any widget
       * @return {Boolean} <code>true</code> when the widget is part of any menu
       */
      _isInMenu: function _isInMenu(widget) {
        while (widget) {
          if (widget instanceof qx.ui.menu.Menu) {
            return true;
          }

          widget = widget.getLayoutParent();
        }

        return false;
      },

      /**
       * Whether the given widget is one of the menu openers.
       *
       * @param widget {qx.ui.core.Widget} Any widget
       * @return {Boolean} <code>true</code> if the widget is a menu opener
       */
      _isMenuOpener: function _isMenuOpener(widget) {
        var menus = this.__objects;

        for (var i = 0; i < menus.length; i++) {
          if (menus[i].getOpener() === widget) {
            return true;
          }
        }

        return false;
      },

      /**
       * Returns an instance of a menu button if the given widget is a child
       *
       * @param widget {qx.ui.core.Widget} any widget
       * @return {qx.ui.menu.Button} Any menu button instance or <code>null</code>
       */
      _getMenuButton: function _getMenuButton(widget) {
        while (widget) {
          if (widget instanceof qx.ui.menu.AbstractButton) {
            return widget;
          }

          widget = widget.getLayoutParent();
        }

        return null;
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Adds a menu to the list of visible menus.
       *
       * @param obj {qx.ui.menu.Menu} Any menu instance.
       */
      add: function add(obj) {
        {
          if (!(obj instanceof qx.ui.menu.Menu)) {
            throw new Error("Object is no menu: " + obj);
          }
        }
        var reg = this.__objects;
        reg.push(obj);
        obj.setZIndex(1e6 + reg.length);
      },

      /**
       * Remove a menu from the list of visible menus.
       *
       * @param obj {qx.ui.menu.Menu} Any menu instance.
       */
      remove: function remove(obj) {
        {
          if (!(obj instanceof qx.ui.menu.Menu)) {
            throw new Error("Object is no menu: " + obj);
          }
        }
        var reg = this.__objects;

        if (reg) {
          qx.lang.Array.remove(reg, obj);
        }
      },

      /**
       * Hides all currently opened menus.
       */
      hideAll: function hideAll() {
        var reg = this.__objects;

        if (reg) {
          for (var i = reg.length - 1; i >= 0; i--) {
            reg[i].exclude();
          }
        }
      },

      /**
       * Returns the menu which was opened at last (which
       * is the active one this way)
       *
       * @return {qx.ui.menu.Menu} The current active menu or <code>null</code>
       */
      getActiveMenu: function getActiveMenu() {
        var reg = this.__objects;
        return reg.length > 0 ? reg[reg.length - 1] : null;
      },

      /*
      ---------------------------------------------------------------------------
        SCHEDULED OPEN/CLOSE SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Schedules the given menu to be opened after the
       * {@link qx.ui.menu.Menu#openInterval} configured by the
       * menu instance itself.
       *
       * @param menu {qx.ui.menu.Menu} The menu to schedule for open
       */
      scheduleOpen: function scheduleOpen(menu) {
        // Cancel close of given menu first
        this.cancelClose(menu); // When the menu is already visible

        if (menu.isVisible()) {
          // Cancel all other open requests
          if (this.__scheduleOpen) {
            this.cancelOpen(this.__scheduleOpen);
          }
        } // When the menu is not visible and not scheduled already
        // then schedule it for opening
        else if (this.__scheduleOpen != menu) {
            // menu.debug("Schedule open");
            this.__scheduleOpen = menu;

            this.__openTimer.restartWith(menu.getOpenInterval());
          }
      },

      /**
       * Schedules the given menu to be closed after the
       * {@link qx.ui.menu.Menu#closeInterval} configured by the
       * menu instance itself.
       *
       * @param menu {qx.ui.menu.Menu} The menu to schedule for close
       */
      scheduleClose: function scheduleClose(menu) {
        // Cancel open of the menu first
        this.cancelOpen(menu); // When the menu is already invisible

        if (!menu.isVisible()) {
          // Cancel all other close requests
          if (this.__scheduleClose) {
            this.cancelClose(this.__scheduleClose);
          }
        } // When the menu is visible and not scheduled already
        // then schedule it for closing
        else if (this.__scheduleClose != menu) {
            // menu.debug("Schedule close");
            this.__scheduleClose = menu;

            this.__closeTimer.restartWith(menu.getCloseInterval());
          }
      },

      /**
       * When the given menu is scheduled for open this pending
       * request is canceled.
       *
       * @param menu {qx.ui.menu.Menu} The menu to cancel for open
       */
      cancelOpen: function cancelOpen(menu) {
        if (this.__scheduleOpen == menu) {
          // menu.debug("Cancel open");
          this.__openTimer.stop();

          this.__scheduleOpen = null;
        }
      },

      /**
       * When the given menu is scheduled for close this pending
       * request is canceled.
       *
       * @param menu {qx.ui.menu.Menu} The menu to cancel for close
       */
      cancelClose: function cancelClose(menu) {
        if (this.__scheduleClose == menu) {
          // menu.debug("Cancel close");
          this.__closeTimer.stop();

          this.__scheduleClose = null;
        }
      },

      /*
      ---------------------------------------------------------------------------
        TIMER EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for a pending open request. Configured to the interval
       * of the current menu to open.
       *
       * @param e {qx.event.type.Event} Interval event
       */
      _onOpenInterval: function _onOpenInterval(e) {
        // Stop timer
        this.__openTimer.stop(); // Open menu and reset flag


        this.__scheduleOpen.open();

        this.__scheduleOpen = null;
      },

      /**
       * Event listener for a pending close request. Configured to the interval
       * of the current menu to close.
       *
       * @param e {qx.event.type.Event} Interval event
       */
      _onCloseInterval: function _onCloseInterval(e) {
        // Stop timer, reset scheduling flag
        this.__closeTimer.stop(); // Close menu and reset flag


        this.__scheduleClose.exclude();

        this.__scheduleClose = null;
      },

      /*
      ---------------------------------------------------------------------------
        CONTEXTMENU EVENT HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Internal function registers a handler to stop next
       * <code>contextmenu</code> event.
       * This function will be called by {@link qx.ui.menu.Button#_onTap}, if
       * right click was pressed.
       *
       * @internal
       */
      preventContextMenuOnce: function preventContextMenuOnce() {
        qx.event.Registration.addListener(document.body, "contextmenu", this.__onPreventContextMenu, this, true);
      },

      /**
       * Internal event handler to stop <code>contextmenu</code> event bubbling,
       * if target is inside the opened menu.
       *
       * @param e {qx.event.type.Mouse} contextmenu event
       *
       * @internal
       */
      __onPreventContextMenu: function __onPreventContextMenu(e) {
        var target = e.getTarget();
        target = qx.ui.core.Widget.getWidgetByElement(target, true);

        if (this._isInMenu(target)) {
          e.stopPropagation();
          e.preventDefault();
        } // stop only once


        qx.event.Registration.removeListener(document.body, "contextmenu", this.__onPreventContextMenu, this, true);
      },

      /*
      ---------------------------------------------------------------------------
        POINTER EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for pointerdown events
       *
       * @param e {qx.event.type.Pointer} pointerdown event
       */
      _onPointerDown: function _onPointerDown(e) {
        var target = e.getTarget();
        target = qx.ui.core.Widget.getWidgetByElement(target, true); // If the target is 'null' the tap appears on a DOM element witch is not
        // a widget. This happens normally with an inline application, when the user
        // taps not in the inline application. In this case all all currently
        // open menus should be closed.

        if (target == null) {
          this.hideAll();
          return;
        } // If the target is the one which has opened the current menu
        // we ignore the pointerdown to let the button process the event
        // further with toggling or ignoring the tap.


        if (target.getMenu && target.getMenu() && target.getMenu().isVisible()) {
          return;
        } // All taps not inside a menu will hide all currently open menus


        if (this.__objects.length > 0 && !this._isInMenu(target)) {
          this.hideAll();
        }
      },

      /*
      ---------------------------------------------------------------------------
        KEY EVENT HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * @type {Map} Map of all keys working on an active menu selection
       * @lint ignoreReferenceField(__selectionKeys)
       */
      __selectionKeys: {
        "Enter": 1,
        "Space": 1
      },

      /**
       * @type {Map} Map of all keys working without a selection
       * @lint ignoreReferenceField(__navigationKeys)
       */
      __navigationKeys: {
        "Escape": 1,
        "Up": 1,
        "Down": 1,
        "Left": 1,
        "Right": 1
      },

      /**
       * Event handler for all keyup/keydown events. Stops all events
       * when any menu is opened.
       *
       * @param e {qx.event.type.KeySequence} Keyboard event
       */
      _onKeyUpDown: function _onKeyUpDown(e) {
        var menu = this.getActiveMenu();

        if (!menu) {
          return;
        } // Stop for all supported key combos


        var iden = e.getKeyIdentifier();

        if (this.__navigationKeys[iden] || this.__selectionKeys[iden] && menu.getSelectedButton()) {
          e.stopPropagation();
        }
      },

      /**
       * Event handler for all keypress events. Delegates the event to the more
       * specific methods defined in this class.
       *
       * Currently processes the keys: <code>Up</code>, <code>Down</code>,
       * <code>Left</code>, <code>Right</code> and <code>Enter</code>.
       *
       * @param e {qx.event.type.KeySequence} Keyboard event
       */
      _onKeyPress: function _onKeyPress(e) {
        var menu = this.getActiveMenu();

        if (!menu) {
          return;
        }

        var iden = e.getKeyIdentifier();
        var navigation = this.__navigationKeys[iden];
        var selection = this.__selectionKeys[iden];

        if (navigation) {
          switch (iden) {
            case "Up":
              this._onKeyPressUp(menu);

              break;

            case "Down":
              this._onKeyPressDown(menu);

              break;

            case "Left":
              this._onKeyPressLeft(menu);

              break;

            case "Right":
              this._onKeyPressRight(menu);

              break;

            case "Escape":
              this.hideAll();
              break;
          }

          e.stopPropagation();
          e.preventDefault();
        } else if (selection) {
          // Do not process these events when no item is hovered
          var button = menu.getSelectedButton();

          if (button) {
            switch (iden) {
              case "Enter":
                this._onKeyPressEnter(menu, button, e);

                break;

              case "Space":
                this._onKeyPressSpace(menu, button, e);

                break;
            }

            e.stopPropagation();
            e.preventDefault();
          }
        }
      },

      /**
       * Event handler for <code>Up</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       */
      _onKeyPressUp: function _onKeyPressUp(menu) {
        // Query for previous child
        var selectedButton = menu.getSelectedButton();
        var children = menu.getChildren();
        var start = selectedButton ? menu.indexOf(selectedButton) - 1 : children.length - 1;

        var nextItem = this._getChild(menu, start, -1, true); // Reconfigure property


        if (nextItem) {
          menu.setSelectedButton(nextItem);
        } else {
          menu.resetSelectedButton();
        }
      },

      /**
       * Event handler for <code>Down</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       */
      _onKeyPressDown: function _onKeyPressDown(menu) {
        // Query for next child
        var selectedButton = menu.getSelectedButton();
        var start = selectedButton ? menu.indexOf(selectedButton) + 1 : 0;

        var nextItem = this._getChild(menu, start, 1, true); // Reconfigure property


        if (nextItem) {
          menu.setSelectedButton(nextItem);
        } else {
          menu.resetSelectedButton();
        }
      },

      /**
       * Event handler for <code>Left</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       */
      _onKeyPressLeft: function _onKeyPressLeft(menu) {
        var menuOpener = menu.getOpener();

        if (!menuOpener) {
          return;
        } // Back to the "parent" menu


        if (menuOpener instanceof qx.ui.menu.AbstractButton) {
          var parentMenu = menuOpener.getLayoutParent();
          parentMenu.resetOpenedButton();
          parentMenu.setSelectedButton(menuOpener);
        } // Goto the previous toolbar button
        else if (menuOpener instanceof qx.ui.menubar.Button) {
            var buttons = menuOpener.getMenuBar().getMenuButtons();
            var index = buttons.indexOf(menuOpener); // This should not happen, definitely!

            if (index === -1) {
              return;
            } // Get previous button, fallback to end if first arrived


            var prevButton = null;
            var length = buttons.length;

            for (var i = 1; i <= length; i++) {
              var button = buttons[(index - i + length) % length];

              if (button.isEnabled() && button.isVisible()) {
                prevButton = button;
                break;
              }
            }

            if (prevButton && prevButton != menuOpener) {
              prevButton.open(true);
            }
          }
      },

      /**
       * Event handler for <code>Right</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       */
      _onKeyPressRight: function _onKeyPressRight(menu) {
        var selectedButton = menu.getSelectedButton(); // Open sub-menu of hovered item and select first child

        if (selectedButton) {
          var subMenu = selectedButton.getMenu();

          if (subMenu) {
            // Open previously hovered item
            menu.setOpenedButton(selectedButton); // Hover first item in new submenu

            var first = this._getChild(subMenu, 0, 1);

            if (first) {
              subMenu.setSelectedButton(first);
            }

            return;
          }
        } // No hover and no open item
        // When first button has a menu, open it, otherwise only hover it
        else if (!menu.getOpenedButton()) {
            var first = this._getChild(menu, 0, 1);

            if (first) {
              menu.setSelectedButton(first);

              if (first.getMenu()) {
                menu.setOpenedButton(first);
              }

              return;
            }
          } // Jump to the next toolbar button


        var menuOpener = menu.getOpener(); // Look up opener hierarchy for menu button

        if (menuOpener instanceof qx.ui.menu.Button && selectedButton) {
          // From one inner selected button try to find the top level
          // menu button which has opened the whole menu chain.
          while (menuOpener) {
            menuOpener = menuOpener.getLayoutParent();

            if (menuOpener instanceof qx.ui.menu.Menu) {
              menuOpener = menuOpener.getOpener();

              if (menuOpener instanceof qx.ui.menubar.Button) {
                break;
              }
            } else {
              break;
            }
          }

          if (!menuOpener) {
            return;
          }
        } // Ask the toolbar for the next menu button


        if (menuOpener instanceof qx.ui.menubar.Button) {
          var buttons = menuOpener.getMenuBar().getMenuButtons();
          var index = buttons.indexOf(menuOpener); // This should not happen, definitely!

          if (index === -1) {
            return;
          } // Get next button, fallback to first if end arrived


          var nextButton = null;
          var length = buttons.length;

          for (var i = 1; i <= length; i++) {
            var button = buttons[(index + i) % length];

            if (button.isEnabled() && button.isVisible()) {
              nextButton = button;
              break;
            }
          }

          if (nextButton && nextButton != menuOpener) {
            nextButton.open(true);
          }
        }
      },

      /**
       * Event handler for <code>Enter</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       * @param button {qx.ui.menu.AbstractButton} The selected button
       * @param e {qx.event.type.KeySequence} The keypress event
       */
      _onKeyPressEnter: function _onKeyPressEnter(menu, button, e) {
        // Route keypress event to the selected button
        if (button.hasListener("keypress")) {
          // Clone and reconfigure event
          var clone = e.clone();
          clone.setBubbles(false);
          clone.setTarget(button); // Finally dispatch the clone

          button.dispatchEvent(clone);
        } // Hide all open menus


        this.hideAll();
      },

      /**
       * Event handler for <code>Space</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       * @param button {qx.ui.menu.AbstractButton} The selected button
       * @param e {qx.event.type.KeySequence} The keypress event
       */
      _onKeyPressSpace: function _onKeyPressSpace(menu, button, e) {
        // Route keypress event to the selected button
        if (button.hasListener("keypress")) {
          // Clone and reconfigure event
          var clone = e.clone();
          clone.setBubbles(false);
          clone.setTarget(button); // Finally dispatch the clone

          button.dispatchEvent(clone);
        }
      },

      /**
       * Event handler for roll which hides all windows on scroll.
       *
       * @param e {qx.event.type.Roll} The roll event.
       */
      _onRoll: function _onRoll(e) {
        var target = e.getTarget();
        target = qx.ui.core.Widget.getWidgetByElement(target, true);

        if (this.__objects.length > 0 && !this._isInMenu(target) && !this._isMenuOpener(target) && !e.getMomentum()) {
          this.hideAll();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      var Registration = qx.event.Registration;
      var el = document.body; // React on pointerdown events

      Registration.removeListener(window.document.documentElement, "pointerdown", this._onPointerDown, this, true); // React on keypress events

      Registration.removeListener(el, "keydown", this._onKeyUpDown, this, true);
      Registration.removeListener(el, "keyup", this._onKeyUpDown, this, true);
      Registration.removeListener(el, "keypress", this._onKeyPress, this, true);

      this._disposeObjects("__openTimer", "__closeTimer");

      this._disposeArray("__objects");
    }
  });
  qx.ui.menu.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.VBox": {
        "require": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Layouter used by the qooxdoo menu's to render their buttons
   *
   * @internal
   */
  qx.Class.define("qx.ui.menu.Layout", {
    extend: qx.ui.layout.VBox,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Spacing between each cell on the menu buttons */
      columnSpacing: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /**
       * Whether a column and which column should automatically span
       * when the following cell is empty. Spanning may be disabled
       * through setting this property to <code>null</code>.
       */
      spanColumn: {
        check: "Integer",
        init: 1,
        nullable: true,
        apply: "_applyLayoutChange"
      },

      /** Default icon column width if no icons are rendered */
      iconColumnWidth: {
        check: "Integer",
        init: 0,
        themeable: true,
        apply: "_applyLayoutChange"
      },

      /** Default arrow column width if no sub menus are rendered */
      arrowColumnWidth: {
        check: "Integer",
        init: 0,
        themeable: true,
        apply: "_applyLayoutChange"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __columnSizes: null,

      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var children = this._getLayoutChildren();

        var child, sizes, spacing;
        var spanColumn = this.getSpanColumn();
        var columnSizes = this.__columnSizes = [0, 0, 0, 0];
        var columnSpacing = this.getColumnSpacing();
        var spanColumnWidth = 0;
        var maxInset = 0; // Compute column sizes and insets

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (child.isAnonymous()) {
            continue;
          }

          sizes = child.getChildrenSizes();

          for (var column = 0; column < sizes.length; column++) {
            if (spanColumn != null && column == spanColumn && sizes[spanColumn + 1] == 0) {
              spanColumnWidth = Math.max(spanColumnWidth, sizes[column]);
            } else {
              columnSizes[column] = Math.max(columnSizes[column], sizes[column]);
            }
          }

          var insets = children[i].getInsets();
          maxInset = Math.max(maxInset, insets.left + insets.right);
        } // Fix label column width is cases where the maximum button with no shortcut
        // is larger than the maximum button with a shortcut


        if (spanColumn != null && columnSizes[spanColumn] + columnSpacing + columnSizes[spanColumn + 1] < spanColumnWidth) {
          columnSizes[spanColumn] = spanColumnWidth - columnSizes[spanColumn + 1] - columnSpacing;
        } // When merging the cells for label and shortcut
        // ignore the spacing between them


        if (spanColumnWidth == 0) {
          spacing = columnSpacing * 2;
        } else {
          spacing = columnSpacing * 3;
        } // Fix zero size icon column


        if (columnSizes[0] == 0) {
          columnSizes[0] = this.getIconColumnWidth();
        } // Fix zero size arrow column


        if (columnSizes[3] == 0) {
          columnSizes[3] = this.getArrowColumnWidth();
        }

        var height = qx.ui.menu.Layout.prototype._computeSizeHint.base.call(this).height; // Build hint


        return {
          minHeight: height,
          height: height,
          width: qx.lang.Array.sum(columnSizes) + maxInset + spacing
        };
      },

      /*
      ---------------------------------------------------------------------------
        CUSTOM ADDONS
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the column sizes detected during the pre-layout phase
       *
       * @return {Array} List of all column widths
       */
      getColumnSizes: function getColumnSizes() {
        return this.__columnSizes || null;
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this.__columnSizes = null;
    }
  });
  qx.ui.menu.Layout.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.SlideBar": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.HoverButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The MenuSlideBar is used to scroll menus if they don't fit on the screen.
   *
   * @childControl button-forward {qx.ui.form.HoverButton} scrolls forward of hovered
   * @childControl button-backward {qx.ui.form.HoverButton} scrolls backward if hovered
   *
   * @internal
   */
  qx.Class.define("qx.ui.menu.MenuSlideBar", {
    extend: qx.ui.container.SlideBar,
    construct: function construct() {
      qx.ui.container.SlideBar.constructor.call(this, "vertical");
    },
    properties: {
      appearance: {
        refine: true,
        init: "menu-slidebar"
      }
    },
    members: {
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "button-forward":
            control = new qx.ui.form.HoverButton();
            control.addListener("execute", this._onExecuteForward, this);

            this._addAt(control, 2);

            break;

          case "button-backward":
            control = new qx.ui.form.HoverButton();
            control.addListener("execute", this._onExecuteBackward, this);

            this._addAt(control, 0);

            break;
        }

        return control || qx.ui.menu.MenuSlideBar.prototype._createChildControlImpl.base.call(this, id);
      }
    }
  });
  qx.ui.menu.MenuSlideBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The slider of the SplitPane (used during drag sessions for fast feedback)
   *
   * @internal
   */
  qx.Class.define("qx.ui.splitpane.Slider", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      allowShrinkX: {
        refine: true,
        init: false
      },
      // overridden
      allowShrinkY: {
        refine: true,
        init: false
      }
    }
  });
  qx.ui.splitpane.Slider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.basic.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The splitter is the element between the two panes.
   *
   * @internal
   *
   * @childControl knob {qx.ui.basic.Image} knob to resize the splitpane
   */
  qx.Class.define("qx.ui.splitpane.Splitter", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param parentWidget {qx.ui.splitpane.Pane} The underlaying split pane.
     */
    construct: function construct(parentWidget) {
      qx.ui.core.Widget.constructor.call(this); // set layout

      if (parentWidget.getOrientation() == "vertical") {
        this._setLayout(new qx.ui.layout.HBox(0, "center"));

        this._getLayout().setAlignY("middle");
      } else {
        this._setLayout(new qx.ui.layout.VBox(0, "middle"));

        this._getLayout().setAlignX("center");
      } // create knob child control


      if (this.getVisible()) {
        this._createChildControl("knob");
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      allowShrinkX: {
        refine: true,
        init: false
      },
      // overridden
      allowShrinkY: {
        refine: true,
        init: false
      },

      /**
       * The visibility of the splitter.
       * Allows to remove the splitter in favor of other visual separation means like background color differences.
       */
      visible: {
        init: true,
        check: "Boolean",
        themeable: true,
        apply: "_applyVisible"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          // Create splitter knob
          case "knob":
            control = new qx.ui.basic.Image();

            this._add(control);

            break;
        }

        return control || qx.ui.splitpane.Splitter.prototype._createChildControlImpl.base.call(this, id);
      },
      _applyVisible: function _applyVisible(visible, old) {
        this.getChildControl("knob").setVisibility(visible ? "visible" : "excluded");
      }
    }
  });
  qx.ui.splitpane.Splitter.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.html.Element": {
        "construct": true,
        "require": true
      },
      "qx.bom.client.Engine": {
        "construct": true
      },
      "qx.util.ResourceManager": {
        "construct": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "construct": true,
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   * A special blocker element for the splitpane which is based on
   * {@link qx.html.Element} and takes care of the positioning of the div.
   *
   * @internal
   * @asset(qx/static/blank.gif)
   */
  qx.Class.define("qx.ui.splitpane.Blocker", {
    extend: qx.html.Element,

    /**
     * @param orientation {String} The orientation of the split pane control.
     */
    construct: function construct(orientation) {
      var styles = {
        position: "absolute",
        zIndex: 11
      }; // IE needs some extra love here to convince it to block events.

      if (qx.core.Environment.get("engine.name") == "mshtml") {
        styles.backgroundImage = "url(" + qx.util.ResourceManager.getInstance().toUri("qx/static/blank.gif") + ")";
        styles.backgroundRepeat = "repeat";
      }

      qx.html.Element.constructor.call(this, "div", styles); // Initialize orientation

      if (orientation) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      }
    },
    properties: {
      /**
       * The orientation of the blocker which should be the same as the
       * orientation of the splitpane.
       */
      orientation: {
        init: "horizontal",
        check: ["horizontal", "vertical"],
        apply: "_applyOrientation"
      }
    },
    members: {
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        if (value == "horizontal") {
          this.setStyle("height", "100%");
          this.setStyle("cursor", "col-resize");
          this.setStyle("top", null);
        } else {
          this.setStyle("width", "100%");
          this.setStyle("left", null);
          this.setStyle("cursor", "row-resize");
        }
      },

      /**
       * Takes the two parameters and set the propper width of the blocker.
       *
       * @param offset {Number} The offset of the splitpane.
       * @param spliterSize {Number} The width of the splitter.
       */
      setWidth: function setWidth(offset, spliterSize) {
        var width = spliterSize + 2 * offset;
        this.setStyle("width", width + "px");
      },

      /**
       * Takes the two parameter and sets the propper height of the blocker.
       *
       * @param offset {Number} The offset of the splitpane.
       * @param spliterSize {Number} The height of the splitter.
       */
      setHeight: function setHeight(offset, spliterSize) {
        var height = spliterSize + 2 * offset;
        this.setStyle("height", height + "px");
      },

      /**
       * Takes the two parameter and sets the propper left position of
       * the blocker.
       *
       * @param offset {Number} The offset of the splitpane.
       * @param splitterLeft {Number} The left position of the splitter.
       */
      setLeft: function setLeft(offset, splitterLeft) {
        var left = splitterLeft - offset;
        this.setStyle("left", left + "px");
      },

      /**
       * Takes the two parameter and sets the propper top position of
       * the blocker.
       *
       * @param offset {Number} The offset of the splitpane.
       * @param splitterTop {Number} The top position of the splitter.
       */
      setTop: function setTop(offset, splitterTop) {
        var top = splitterTop - offset;
        this.setStyle("top", top + "px");
      }
    }
  });
  qx.ui.splitpane.Blocker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "require": true
      },
      "qx.ui.layout.Util": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Layouter for vertical split panes.
   *
   * @internal
   */
  qx.Class.define("qx.ui.splitpane.VLayout", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        this.assert(name === "type" || name === "flex", "The property '" + name + "' is not supported by the split layout!");

        if (name == "flex") {
          this.assertNumber(value);
        }

        if (name == "type") {
          this.assertString(value);
        }
      },
      // overridden
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        var children = this._getLayoutChildren();

        var length = children.length;
        var child, type;
        var begin, splitter, slider, end;
        var paddingLeft = padding.left || 0;
        var paddingTop = padding.top || 0;

        for (var i = 0; i < length; i++) {
          child = children[i];
          type = child.getLayoutProperties().type;

          if (type === "splitter") {
            splitter = child;
          } else if (type === "slider") {
            slider = child;
          } else if (!begin) {
            begin = child;
          } else {
            end = child;
          }
        }

        if (begin && end) {
          var beginFlex = begin.getLayoutProperties().flex;
          var endFlex = end.getLayoutProperties().flex;

          if (beginFlex == null) {
            beginFlex = 1;
          }

          if (endFlex == null) {
            endFlex = 1;
          }

          var beginHint = begin.getSizeHint();
          var splitterHint = splitter.getSizeHint();
          var endHint = end.getSizeHint();
          var beginHeight = beginHint.height;
          var splitterHeight = splitterHint.height;
          var endHeight = endHint.height;

          if (beginFlex > 0 && endFlex > 0) {
            var flexSum = beginFlex + endFlex;
            var flexAvailable = availHeight - splitterHeight;
            var beginHeight = Math.round(flexAvailable / flexSum * beginFlex);
            var endHeight = flexAvailable - beginHeight;
            var sizes = qx.ui.layout.Util.arrangeIdeals(beginHint.minHeight, beginHeight, beginHint.maxHeight, endHint.minHeight, endHeight, endHint.maxHeight);
            beginHeight = sizes.begin;
            endHeight = sizes.end;
          } else if (beginFlex > 0) {
            beginHeight = availHeight - splitterHeight - endHeight;

            if (beginHeight < beginHint.minHeight) {
              beginHeight = beginHint.minHeight;
            }

            if (beginHeight > beginHint.maxHeight) {
              beginHeight = beginHint.maxHeight;
            }
          } else if (endFlex > 0) {
            endHeight = availHeight - beginHeight - splitterHeight;

            if (endHeight < endHint.minHeight) {
              endHeight = endHint.minHeight;
            }

            if (endHeight > endHint.maxHeight) {
              endHeight = endHint.maxHeight;
            }
          }

          begin.renderLayout(paddingLeft, paddingTop, availWidth, beginHeight);
          splitter.renderLayout(paddingLeft, beginHeight + paddingTop, availWidth, splitterHeight);
          end.renderLayout(paddingLeft, beginHeight + splitterHeight + paddingTop, availWidth, endHeight);
        } else {
          // Hide the splitter completely
          splitter.renderLayout(0, 0, 0, 0); // Render one child

          if (begin) {
            begin.renderLayout(paddingLeft, paddingTop, availWidth, availHeight);
          } else if (end) {
            end.renderLayout(paddingLeft, paddingTop, availWidth, availHeight);
          }
        }
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var children = this._getLayoutChildren();

        var length = children.length;
        var child, hint, props;
        var minHeight = 0,
            height = 0,
            maxHeight = 0;
        var minWidth = 0,
            width = 0,
            maxWidth = 0;

        for (var i = 0; i < length; i++) {
          child = children[i];
          props = child.getLayoutProperties(); // The slider is not relevant for auto sizing

          if (props.type === "slider") {
            continue;
          }

          hint = child.getSizeHint();
          minHeight += hint.minHeight;
          height += hint.height;
          maxHeight += hint.maxHeight;

          if (hint.minWidth > minWidth) {
            minWidth = hint.minWidth;
          }

          if (hint.width > width) {
            width = hint.width;
          }

          if (hint.maxWidth > maxWidth) {
            maxWidth = hint.maxWidth;
          }
        }

        return {
          minHeight: minHeight,
          height: height,
          maxHeight: maxHeight,
          minWidth: minWidth,
          width: width,
          maxWidth: maxWidth
        };
      }
    }
  });
  qx.ui.splitpane.VLayout.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "require": true
      },
      "qx.ui.layout.Util": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Layouter for horizontal split panes.
   *
   * @internal
   */
  qx.Class.define("qx.ui.splitpane.HLayout", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        this.assert(name === "type" || name === "flex", "The property '" + name + "' is not supported by the split layout!");

        if (name == "flex") {
          this.assertNumber(value);
        }

        if (name == "type") {
          this.assertString(value);
        }
      },
      // overridden
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        var children = this._getLayoutChildren();

        var length = children.length;
        var child, type;
        var begin, splitter, slider, end;
        var paddingLeft = padding.left || 0;
        var paddingTop = padding.top || 0;

        for (var i = 0; i < length; i++) {
          child = children[i];
          type = child.getLayoutProperties().type;

          if (type === "splitter") {
            splitter = child;
          } else if (type === "slider") {
            slider = child;
          } else if (!begin) {
            begin = child;
          } else {
            end = child;
          }
        }

        if (begin && end) {
          var beginFlex = begin.getLayoutProperties().flex;
          var endFlex = end.getLayoutProperties().flex;

          if (beginFlex == null) {
            beginFlex = 1;
          }

          if (endFlex == null) {
            endFlex = 1;
          }

          var beginHint = begin.getSizeHint();
          var splitterHint = splitter.getSizeHint();
          var endHint = end.getSizeHint();
          var beginWidth = beginHint.width;
          var splitterWidth = splitterHint.width;
          var endWidth = endHint.width;

          if (beginFlex > 0 && endFlex > 0) {
            var flexSum = beginFlex + endFlex;
            var flexAvailable = availWidth - splitterWidth;
            var beginWidth = Math.round(flexAvailable / flexSum * beginFlex);
            var endWidth = flexAvailable - beginWidth;
            var sizes = qx.ui.layout.Util.arrangeIdeals(beginHint.minWidth, beginWidth, beginHint.maxWidth, endHint.minWidth, endWidth, endHint.maxWidth);
            beginWidth = sizes.begin;
            endWidth = sizes.end;
          } else if (beginFlex > 0) {
            beginWidth = availWidth - splitterWidth - endWidth;

            if (beginWidth < beginHint.minWidth) {
              beginWidth = beginHint.minWidth;
            }

            if (beginWidth > beginHint.maxWidth) {
              beginWidth = beginHint.maxWidth;
            }
          } else if (endFlex > 0) {
            endWidth = availWidth - beginWidth - splitterWidth;

            if (endWidth < endHint.minWidth) {
              endWidth = endHint.minWidth;
            }

            if (endWidth > endHint.maxWidth) {
              endWidth = endHint.maxWidth;
            }
          }

          begin.renderLayout(paddingLeft, paddingTop, beginWidth, availHeight);
          splitter.renderLayout(beginWidth + paddingLeft, paddingTop, splitterWidth, availHeight);
          end.renderLayout(beginWidth + splitterWidth + paddingLeft, paddingTop, endWidth, availHeight);
        } else {
          // Hide the splitter completely
          splitter.renderLayout(0, 0, 0, 0); // Render one child

          if (begin) {
            begin.renderLayout(paddingLeft, paddingTop, availWidth, availHeight);
          } else if (end) {
            end.renderLayout(paddingLeft, paddingTop, availWidth, availHeight);
          }
        }
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var children = this._getLayoutChildren();

        var length = children.length;
        var child, hint, props;
        var minWidth = 0,
            width = 0,
            maxWidth = 0;
        var minHeight = 0,
            height = 0,
            maxHeight = 0;

        for (var i = 0; i < length; i++) {
          child = children[i];
          props = child.getLayoutProperties(); // The slider is not relevant for auto sizing

          if (props.type === "slider") {
            continue;
          }

          hint = child.getSizeHint();
          minWidth += hint.minWidth;
          width += hint.width;
          maxWidth += hint.maxWidth;

          if (hint.minHeight > minHeight) {
            minHeight = hint.minHeight;
          }

          if (hint.height > height) {
            height = hint.height;
          }

          if (hint.maxHeight > maxHeight) {
            maxHeight = hint.maxHeight;
          }
        }

        return {
          minWidth: minWidth,
          width: width,
          maxWidth: maxWidth,
          minHeight: minHeight,
          height: height,
          maxHeight: maxHeight
        };
      }
    }
  });
  qx.ui.splitpane.HLayout.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.RadioButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.basic.Label": {},
      "qx.ui.basic.Image": {},
      "qx.ui.form.Button": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A TabButton is the tapable part sitting on the {@link qx.ui.tabview.Page}.
   * By tapping on the TabButton the user can set a Page active.
   *
   * @childControl label {qx.ui.basic.Label} label of the tab button
   * @childControl icon {qx.ui.basic.Image} icon of the tab button
   * @childControl close-button {qx.ui.form.Button} close button of the tab button
   */
  qx.Class.define("qx.ui.tabview.TabButton", {
    extend: qx.ui.form.RadioButton,
    implement: qx.ui.form.IRadioItem,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.form.RadioButton.constructor.call(this);
      var layout = new qx.ui.layout.Grid(2, 0);
      layout.setRowAlign(0, "left", "middle");
      layout.setColumnAlign(0, "right", "middle");

      this._getLayout().dispose();

      this._setLayout(layout);

      this.initShowCloseButton();
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired by {@link qx.ui.tabview.Page} if the close button is tapped.
       *
       * Event data: The tab button.
       */
      "close": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Indicates if the close button of a TabButton should be shown. */
      showCloseButton: {
        check: "Boolean",
        init: false,
        apply: "_applyShowCloseButton"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        checked: true
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      _applyIconPosition: function _applyIconPosition(value, old) {
        var children = {
          icon: this.getChildControl("icon"),
          label: this.getChildControl("label"),
          closeButton: this.getShowCloseButton() ? this.getChildControl("close-button") : null
        }; // Remove all children before adding them again

        for (var child in children) {
          if (children[child]) {
            this._remove(children[child]);
          }
        }

        switch (value) {
          case "top":
            this._add(children.label, {
              row: 3,
              column: 2
            });

            this._add(children.icon, {
              row: 1,
              column: 2
            });

            if (children.closeButton) {
              this._add(children.closeButton, {
                row: 0,
                column: 4
              });
            }

            break;

          case "bottom":
            this._add(children.label, {
              row: 1,
              column: 2
            });

            this._add(children.icon, {
              row: 3,
              column: 2
            });

            if (children.closeButton) {
              this._add(children.closeButton, {
                row: 0,
                column: 4
              });
            }

            break;

          case "left":
            this._add(children.label, {
              row: 0,
              column: 2
            });

            this._add(children.icon, {
              row: 0,
              column: 0
            });

            if (children.closeButton) {
              this._add(children.closeButton, {
                row: 0,
                column: 4
              });
            }

            break;

          case "right":
            this._add(children.label, {
              row: 0,
              column: 0
            });

            this._add(children.icon, {
              row: 0,
              column: 2
            });

            if (children.closeButton) {
              this._add(children.closeButton, {
                row: 0,
                column: 4
              });
            }

            break;
        }
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "label":
            var control = new qx.ui.basic.Label(this.getLabel());
            control.setAnonymous(true);

            this._add(control, {
              row: 0,
              column: 2
            });

            this._getLayout().setColumnFlex(2, 1);

            break;

          case "icon":
            control = new qx.ui.basic.Image(this.getIcon());
            control.setAnonymous(true);

            this._add(control, {
              row: 0,
              column: 0
            });

            break;

          case "close-button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.setKeepActive(true);
            control.addListener("tap", this._onCloseButtonTap, this);

            this._add(control, {
              row: 0,
              column: 4
            });

            if (!this.getShowCloseButton()) {
              control.exclude();
            }

            break;
        }

        return control || qx.ui.tabview.TabButton.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Fires a "close" event when the close button is tapped.
       */
      _onCloseButtonTap: function _onCloseButtonTap() {
        this.fireDataEvent("close", this);
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyShowCloseButton: function _applyShowCloseButton(value, old) {
        if (value) {
          this._showChildControl("close-button");
        } else {
          this._excludeChildControl("close-button");
        }
      },
      // property apply
      _applyCenter: function _applyCenter(value) {
        var layout = this._getLayout();

        if (value) {
          layout.setColumnAlign(2, "center", "middle");
        } else {
          layout.setColumnAlign(2, "left", "middle");
        }
      }
    }
  });
  qx.ui.tabview.TabButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.window.IWindowManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * All parent widgets of windows must implement this interface.
   */
  qx.Interface.define("qx.ui.window.IDesktop", {
    members: {
      /**
       * Sets the desktop's window manager
       *
       * @param manager {qx.ui.window.IWindowManager} The window manager
       */
      setWindowManager: function setWindowManager(manager) {
        this.assertInterface(manager, qx.ui.window.IWindowManager);
      },

      /**
       * Get a list of all windows added to the desktop (including hidden windows)
       *
       * @return {qx.ui.window.Window[]} Array of managed windows
       */
      getWindows: function getWindows() {},

      /**
       * Whether the configured layout supports a maximized window
       * e.g. is a Canvas.
       *
       * @return {Boolean} Whether the layout supports maximized windows
       */
      supportsMaximize: function supportsMaximize() {},

      /**
       * Block direct child widgets with a zIndex below <code>zIndex</code>
       *
       * @param zIndex {Integer} All child widgets with a zIndex below this value
       *     will be blocked
       */
      blockContent: function blockContent(zIndex) {
        this.assertInteger(zIndex);
      },

      /**
       * Remove the blocker.
       */
      unblock: function unblock() {},

      /**
       * Whether the widget is currently blocked
       *
       * @return {Boolean} whether the widget is blocked.
       */
      isBlocked: function isBlocked() {}
    }
  });
  qx.ui.window.IDesktop.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.basic.Atom": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.event.AcceleratingTimer": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The HoverButton is an {@link qx.ui.basic.Atom}, which fires repeatedly
   * execute events while the pointer is over the widget.
   *
   * The rate at which the execute event is fired accelerates is the pointer keeps
   * inside of the widget. The initial delay and the interval time can be set using
   * the properties {@link #firstInterval} and {@link #interval}. The
   * {@link #execute} events will be fired in a shorter amount of time if the pointer
   * remains over the widget, until the min {@link #minTimer} is reached.
   * The {@link #timerDecrease} property sets the amount of milliseconds which will
   * decreased after every firing.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.form.HoverButton("Hello World");
   *
   *   button.addListener("execute", function(e) {
   *     alert("Button is hovered");
   *   }, this);
   *
   *   this.getRoot.add(button);
   * </pre>
   *
   * This example creates a button with the label "Hello World" and attaches an
   * event listener to the {@link #execute} event.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/hoverbutton.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.form.HoverButton", {
    extend: qx.ui.basic.Atom,
    include: [qx.ui.core.MExecutable],
    implement: [qx.ui.form.IExecutable],

    /**
     * @param label {String} Label to use
     * @param icon {String?null} Icon to use
     */
    construct: function construct(label, icon) {
      qx.ui.basic.Atom.constructor.call(this, label, icon);
      this.addListener("pointerover", this._onPointerOver, this);
      this.addListener("pointerout", this._onPointerOut, this);
      this.__timer = new qx.event.AcceleratingTimer();

      this.__timer.addListener("interval", this._onInterval, this);
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "hover-button"
      },

      /**
       * Interval used after the first run of the timer. Usually a smaller value
       * than the "firstInterval" property value to get a faster reaction.
       */
      interval: {
        check: "Integer",
        init: 80
      },

      /**
       * Interval used for the first run of the timer. Usually a greater value
       * than the "interval" property value to a little delayed reaction at the first
       * time.
       */
      firstInterval: {
        check: "Integer",
        init: 200
      },

      /** This configures the minimum value for the timer interval. */
      minTimer: {
        check: "Integer",
        init: 20
      },

      /** Decrease of the timer on each interval (for the next interval) until minTimer reached. */
      timerDecrease: {
        check: "Integer",
        init: 2
      }
    },
    members: {
      __timer: null,

      /**
       * Start timer on pointer over
       *
       * @param e {qx.event.type.Pointer} The pointer event
       */
      _onPointerOver: function _onPointerOver(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        this.__timer.set({
          interval: this.getInterval(),
          firstInterval: this.getFirstInterval(),
          minimum: this.getMinTimer(),
          decrease: this.getTimerDecrease()
        }).start();

        this.addState("hovered");
      },

      /**
       * Stop timer on pointer out
       *
       * @param e {qx.event.type.Pointer} The pointer event
       */
      _onPointerOut: function _onPointerOut(e) {
        this.__timer.stop();

        this.removeState("hovered");

        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }
      },

      /**
       * Fire execute event on timer interval event
       */
      _onInterval: function _onInterval() {
        if (this.isEnabled()) {
          this.execute();
        } else {
          this.__timer.stop();
        }
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__timer");
    }
  });
  qx.ui.form.HoverButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.layout.Grid": {},
      "qx.ui.container.Composite": {},
      "qx.ui.form.TextField": {},
      "qx.ui.form.ComboBox": {},
      "qx.ui.core.FocusHandler": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.Focus", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      getContainer: function getContainer() {
        if (!this._container) {
          var grid = new qx.ui.layout.Grid(10, 10);
          this._container = new qx.ui.container.Composite(grid).set({
            padding: 20
          });
          this.getRoot().add(this._container);
        }

        return this._container;
      },
      setUp: function setUp() {
        this.flush();
        this.ref = new qx.ui.form.TextField();
        this.addReferenceInput();
        this.ref.focus();
        this.flush();
        this.ref.addListener("blur", this.onRefBlur, this);
        this.ref_blur_called = false;
        this.target_focus_called = false;
        this.target_blur_called = false;
        this.flush();
        this.input = new qx.ui.form.TextField();
        this.input.addListener("focus", this.onInputFocus, this);
        this.input.addListener("blur", this.onInputBlur, this);
      },
      tearDown: function tearDown() {
        qx.test.ui.Focus.prototype.tearDown.base.call(this);

        if (this.input) {
          this.input.destroy();
        }

        if (this.ref) {
          this.ref.destroy();
        }

        if (this._container) {
          this._container.destroy();

          this._container = null;
        }

        this.flush();
      },
      addInput: function addInput() {
        this.getContainer().add(this.input, {
          row: 2,
          column: 0
        });
      },
      addReferenceInput: function addReferenceInput() {
        this.getContainer().add(this.ref, {
          row: 1,
          column: 0,
          colSpan: 2
        });
      },
      onRefBlur: function onRefBlur() {
        this.ref_blur_called = true;
      },
      onInputFocus: function onInputFocus() {
        this.target_focus_called = true;
      },
      onInputBlur: function onInputBlur() {
        this.target_blur_called = true;
      },
      testNotInsertedBeforeFlush: function testNotInsertedBeforeFlush() {
        this.input.focus();
        this.flush();
        this.assertFalse(this.ref_blur_called);
        this.assertFalse(this.target_focus_called);
        this.assertFalse(this.target_blur_called);
        this.addInput();
      },
      testExcludedBeforeFlush: function testExcludedBeforeFlush() {
        this.addInput();
        this.input.exclude();
        this.input.focus();
        this.flush();
        this.assertFalse(this.ref_blur_called);
        this.assertFalse(this.target_focus_called);
        this.assertFalse(this.target_blur_called);
        this.input.show();
      },
      testHiddenBeforeFlush: function testHiddenBeforeFlush() {
        this.addInput();
        this.input.hide();
        this.input.focus();
        this.flush();
        this.assertFalse(this.ref_blur_called);
        this.assertFalse(this.target_focus_called);
        this.assertFalse(this.target_blur_called);
        this.input.show();
      },
      testNotInsertedAfterFlush: function testNotInsertedAfterFlush() {
        this.addInput();
        this.flush();
        this.input.getLayoutParent().remove(this.input);
        this.flush();
        this.input.focus();
        this.flush();
        this.assertFalse(this.ref_blur_called);
        this.assertFalse(this.target_focus_called);
        this.assertFalse(this.target_blur_called);
        this.addInput();
      },
      testExcludedAfterFlush: function testExcludedAfterFlush() {
        this.addInput();
        this.flush();
        this.input.getLayoutParent().remove(this.input);
        this.flush();
        this.addInput();
        this.input.exclude();
        this.input.focus();
        this.flush();
        this.assertFalse(this.ref_blur_called);
        this.assertFalse(this.target_focus_called);
        this.assertFalse(this.target_blur_called);
        this.input.show();
      },
      testHiddenAfterFlush: function testHiddenAfterFlush() {
        this.addInput();
        this.flush();
        this.input.getLayoutParent().remove(this.input);
        this.flush();
        this.addInput();
        this.input.hide();
        this.input.focus();
        this.flush();
        this.assertFalse(this.ref_blur_called);
        this.assertFalse(this.target_focus_called);
        this.assertFalse(this.target_blur_called);
        this.input.show();
      },
      testInsertedBeforeFlush: function testInsertedBeforeFlush() {
        this.addInput();
        this.input.focus();
        this.flush();
        this.assertTrue(this.ref_blur_called, "reference must be blurred");
        this.assertTrue(this.target_focus_called, "target must be focused");
        this.assertFalse(this.target_blur_called, "target must not be blurred");
      },
      testFocusRemoveBeforeFlush: function testFocusRemoveBeforeFlush() {
        this.addInput();
        this.input.focus();
        this.flush();
        this.input.getLayoutParent().remove(this.input);
        this.flush();
        this.assertTrue(this.ref_blur_called);
        this.assertTrue(this.target_focus_called);
        this.assertTrue(this.target_blur_called);
        this.addInput();
      },
      testFocusExcludeBeforeFlush: function testFocusExcludeBeforeFlush() {
        this.addInput();
        this.input.focus();
        this.flush();
        this.input.exclude();
        this.flush();
        this.assertTrue(this.ref_blur_called);
        this.assertTrue(this.target_focus_called);
        this.assertTrue(this.target_blur_called);
        this.input.show();
      },
      testFocusHideBeforeFlush: function testFocusHideBeforeFlush() {
        this.addInput();
        this.input.focus();
        this.flush();
        this.input.hide();
        this.flush();
        this.assertTrue(this.ref_blur_called);
        this.assertTrue(this.target_focus_called);
        this.assertTrue(this.target_blur_called);
        this.input.show();
      },
      testInsertedAfterFlush: function testInsertedAfterFlush() {
        this.addInput();
        this.flush();
        this.input.focus();
        this.flush();
        this.assertTrue(this.ref_blur_called);
        this.assertTrue(this.target_focus_called);
        this.assertFalse(this.target_blur_called);
      },
      testFocusRemoveAfterFlush: function testFocusRemoveAfterFlush() {
        this.addInput();
        this.input.focus();
        this.flush();
        this.input.getLayoutParent().remove(this.input);
        this.flush();
        this.assertTrue(this.ref_blur_called);
        this.assertTrue(this.target_focus_called);
        this.assertTrue(this.target_blur_called);
        this.addInput();
      },
      testFocusExcludeAfterFlush: function testFocusExcludeAfterFlush() {
        this.addInput();
        this.flush();
        this.input.focus();
        this.flush();
        this.input.exclude();
        this.flush();
        this.assertTrue(this.ref_blur_called);
        this.assertTrue(this.target_focus_called);
        this.assertTrue(this.target_blur_called);
        this.input.show();
      },
      testFocusHideAfterFlush: function testFocusHideAfterFlush() {
        this.addInput();
        this.flush();
        this.input.focus();
        this.flush();
        this.input.hide();
        this.flush();
        this.assertTrue(this.ref_blur_called, "reference must be blurred");
        this.assertTrue(this.target_focus_called, "target must be focused");
        this.assertTrue(this.target_blur_called, "target must be blurred");
        this.input.show();
      },
      testFocusComboBox: function testFocusComboBox() {
        var comboBox = new qx.ui.form.ComboBox();
        this.getRoot().add(comboBox);
        comboBox.focus();
        this.flush();
        this.assertEquals(comboBox.getChildControl("textfield"), qx.ui.core.FocusHandler.getInstance().getActiveWidget());
        comboBox.destroy();
      }
    },
    destruct: function destruct() {
      this.ref = this.input = null;
    }
  });
  qx.test.ui.Focus.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.ui.decoration.Decorator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.Insets", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      testPadding: function testPadding() {
        var widget = new qx.ui.core.Widget();
        this.getRoot().add(widget);
        this.assertPadding(widget, 0, 0, 0, 0);
        widget.setPadding(1, 2, 3, 4);
        this.assertPadding(widget, 1, 2, 3, 4); // shorthand mode

        widget.setPadding(1);
        this.assertPadding(widget, 1, 1, 1, 1);
        widget.setPadding(2, 5);
        this.assertPadding(widget, 2, 5, 2, 5);
        this.getRoot().remove(widget);
        widget.dispose();
        var widget = new qx.ui.core.Widget();
        this.getRoot().add(widget);
        var deco;
        this.assertPadding(widget, 0, 0, 0, 0);
        deco = new qx.ui.decoration.Decorator().set({
          width: 1
        });
        widget.setDecorator(deco);
        this.assertPadding(widget, 0, 0, 0, 0);
        deco.dispose();
        deco = new qx.ui.decoration.Decorator().set({
          width: 2
        });
        widget.setDecorator(deco);
        widget.setPadding(2);
        this.assertPadding(widget, 2, 2, 2, 2);
        deco.dispose();
        deco = new qx.ui.decoration.Decorator().set({
          width: [2, 3, 5, 7]
        });
        widget.setDecorator(deco);
        widget.setPadding(1, 4, 16, 64);
        this.assertPadding(widget, 1, 4, 16, 64);
        widget.setDecorator(null);
        this.assertPadding(widget, 1, 4, 16, 64);
        deco.dispose();
        deco = new qx.ui.decoration.Decorator().set({
          width: 2,
          innerWidth: 2
        });
        widget.setDecorator(deco);
        widget.setPadding(2);
        this.assertPadding(widget, 4, 4, 4, 4);
        this.getRoot().remove(widget);
        widget.dispose();
        deco.dispose();
      },
      testDecoration: function testDecoration() {
        var widget = new qx.ui.core.Widget();
        this.getRoot().add(widget);
        var deco = new qx.ui.decoration.Decorator();
        widget.setDecorator(deco);
        this.assertPadding(widget, 0, 0, 0, 0);
        this.getRoot().remove(widget);
        widget.dispose();
        deco.dispose();
      }
    }
  });
  qx.test.ui.Insets.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "construct": true,
        "require": true
      },
      "qx.locale.MTranslation": {
        "require": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.ui.command.Command": {},
      "qx.ui.menu.Button": {},
      "qx.ui.basic.Label": {},
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.LocaleSwitch", {
    extend: qx.test.ui.LayoutTestCase,
    include: qx.locale.MTranslation,
    construct: function construct() {
      qx.test.ui.LayoutTestCase.constructor.call(this);
      this.manager = qx.locale.Manager.getInstance();
    },
    members: {
      manager: null,
      __translationAdded: null,
      setUp: function setUp() {
        if (!this.__translationAdded) {
          // add dummy translations
          this.manager.addTranslation("en_QX", {
            "test one": "test one",
            "test two": "test two",
            "test Hello %1!": "test Hello %1!",
            "test Jonny": "test Jonny",
            "test One car": "test One car",
            "test %1 cars": "test %1 cars",
            "key_short_Shift": "Shift"
          });
          this.manager.addTranslation("de_QX", {
            "test one": "Eins",
            "test two": "Zwei",
            "test Hello %1!": "Servus %1!",
            "test Jonny": "Jonathan",
            "test One car": "Ein Auto",
            "test %1 cars": "%1 Autos",
            "key_short_Shift": "Umschalt"
          });
          this.__translationAdded = true;
        }

        this.manager.setLocale("en_QX");
      },
      tearDown: function tearDown() {
        this.manager.resetLocale();
      },
      testCommandInMenuButton: function testCommandInMenuButton() {
        var command = new qx.ui.command.Command("Shift-A");
        var menuButton = new qx.ui.menu.Button("Juhu", null, command);
        this.assertEquals("Shift+A", command.toString());
        this.assertEquals("Shift+A", menuButton.getChildControl("shortcut").getValue());
        this.manager.setLocale("de_QX");
        this.assertEquals("Umschalt+A", command.toString());
        this.assertEquals("Umschalt+A", menuButton.getChildControl("shortcut").getValue());
        menuButton.dispose();
        command.dispose();
      },
      testLabel: function testLabel() {
        var label = new qx.ui.basic.Label(this.tr("test one"));
        this.getRoot().add(label);
        this.assertEquals("test one", label.getValue());
        this.manager.setLocale("de_QX");
        this.assertEquals("Eins", label.getValue());
        this.manager.setLocale("en_QX");
        label.setValue(this.tr("test Hello %1!", this.tr("test Jonny")));
        this.assertEquals("test Hello test Jonny!", label.getValue());
        this.manager.setLocale("de_QX");
        this.assertEquals("Servus Jonathan!", label.getValue()); // de -> en

        label.setValue(this.tr("test two"));
        this.assertEquals("Zwei", label.getValue());
        this.manager.setLocale("en_QX");
        this.assertEquals("test two", label.getValue());
        label.destroy();
      },
      testToolTipText: function testToolTipText() {
        var widget = new qx.ui.core.Widget();
        this.getRoot().add(widget);
        widget.setToolTipText(this.tr("test one"));
        this.assertEquals("test one", widget.getToolTipText());
        this.manager.setLocale("de_QX");
        this.assertEquals("Eins", widget.getToolTipText());
        widget.destroy();
      }
    }
  });
  qx.test.ui.LocaleSwitch.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.bom.Shortcut": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Mustafa Sak (msak)
  
  ************************************************************************ */

  /**
   * Commands can be used to globally define keyboard shortcuts. They could
   * also be used to assign an execution of a command sequence to multiple
   * widgets. It is possible to use the same Command in a MenuButton and
   * ToolBarButton for example.
   * 
   * NOTE: Instances of this class must be disposed of after use
   *
   */
  qx.Class.define("qx.ui.command.Command", {
    extend: qx.core.Object,

    /**
     * @param shortcut {String} Shortcuts can be composed of optional modifier
     *    keys Control, Alt, Shift, Meta and a non modifier key.
     *    If no non modifier key is specified, the second parameter is evaluated.
     *    The key must be separated by a <code>+</code> or <code>-</code> character.
     *    Examples: Alt+F1, Control+C, Control+Alt+Delete
     */
    construct: function construct(shortcut) {
      qx.core.Object.constructor.call(this);
      this._shortcut = new qx.bom.Shortcut(shortcut);

      this._shortcut.addListener("execute", this.execute, this);

      if (shortcut !== undefined) {
        this.setShortcut(shortcut);
      }
    },
    events: {
      /**
       * Fired when the command is executed. Sets the "data" property of the
       * event to the object that issued the command.
       */
      "execute": "qx.event.type.Data"
    },
    properties: {
      /** Whether the command should be activated. If 'false' execute event
       * wouldn't fire. This property will be used by command groups when
       * activating/deactivating all commands of the group.*/
      active: {
        init: true,
        check: "Boolean",
        event: "changeActive",
        apply: "_applyActive"
      },

      /** Whether the command should be respected/enabled. If 'false' execute event
       * wouldn't fire. If value of property {@link qx.ui.command.Command#active}
       * is 'false', enabled value can be set but has no effect until
       * {@link qx.ui.command.Command#active} will be set to 'true'.*/
      enabled: {
        init: true,
        check: "Boolean",
        event: "changeEnabled",
        apply: "_applyEnabled"
      },

      /** The command shortcut as a string */
      shortcut: {
        check: "String",
        apply: "_applyShortcut",
        nullable: true
      },

      /** The label, which will be set in all connected widgets (if available) */
      label: {
        check: "String",
        nullable: true,
        event: "changeLabel"
      },

      /** The icon, which will be set in all connected widgets (if available) */
      icon: {
        check: "String",
        nullable: true,
        event: "changeIcon"
      },

      /**
       * The tooltip text, which will be set in all connected
       * widgets (if available)
       */
      toolTipText: {
        check: "String",
        nullable: true,
        event: "changeToolTipText"
      },

      /** The value of the connected widgets */
      value: {
        nullable: true,
        event: "changeValue"
      },

      /** The menu, which will be set in all connected widgets (if available) */
      menu: {
        check: "qx.ui.menu.Menu",
        nullable: true,
        event: "changeMenu"
      }
    },
    members: {
      _shortcut: null,
      // property apply
      _applyActive: function _applyActive(value) {
        if (value === false) {
          this._shortcut.setEnabled(false);
        } else {
          // synchronize value with current "enabled" value of this command
          this._shortcut.setEnabled(this.getEnabled());
        }
      },
      // property apply
      _applyEnabled: function _applyEnabled(value) {
        if (this.getActive()) {
          this._shortcut.setEnabled(value);
        }
      },
      // property apply
      _applyShortcut: function _applyShortcut(value) {
        this._shortcut.setShortcut(value);
      },

      /**
       * Fire the "execute" event on this command. If property
       * <code>active</code> and <code>enabled</code> set to
       * <code>true</code>.
       * @param target {Object?} Object which issued the execute event
       */
      execute: function execute(target) {
        if (this.getActive() && this.getEnabled()) {
          this.fireDataEvent("execute", target);
        }
      },

      /**
       * Returns the used shortcut as string using the currently selected locale.
       *
       * @return {String} shortcut
       */
      toString: function toString() {
        if (this._shortcut) {
          return this._shortcut.toString();
        }

        return qx.ui.command.Command.prototype.toString.base.call(this);
      }
    },
    destruct: function destruct() {
      this._shortcut.removeListener("execute", this.execute, this);

      this._disposeObjects("_shortcut");
    }
  });
  qx.ui.command.Command.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.RadioButton": {},
      "qx.ui.menu.RadioButton": {},
      "qx.ui.toolbar.RadioButton": {},
      "qx.ui.form.RadioGroup": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * mw (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.RadioItems", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      testTwiceClickForm: function testTwiceClickForm() {
        var item = new qx.ui.form.RadioButton();

        this.__testTwiceClick(item);

        item.destroy();
      },
      testTwiceClickMenu: function testTwiceClickMenu() {
        var item = new qx.ui.menu.RadioButton();

        this.__testTwiceClick(item);

        item.destroy();
      },
      testTwiceClickToolbar: function testTwiceClickToolbar() {
        var item = new qx.ui.toolbar.RadioButton();

        this.__testTwiceClick(item);

        item.destroy();
      },
      __testTwiceClick: function __testTwiceClick(widget) {
        this.assertFalse(widget.getValue()); // execute the widget

        widget.execute();
        this.assertTrue(widget.getValue(), "1"); // execute again to see that it is still selected

        widget.execute();
        this.assertTrue(widget.getValue(), "2");
      },
      testTwiceClickEmptySelectionForm: function testTwiceClickEmptySelectionForm() {
        var item = new qx.ui.form.RadioButton();

        this.__testTwiceClickEmptySelection(item);

        item.destroy();
      },
      testTwiceClickEmptySelectionMenu: function testTwiceClickEmptySelectionMenu() {
        var item = new qx.ui.menu.RadioButton();

        this.__testTwiceClickEmptySelection(item);

        item.destroy();
      },
      testTwiceClickEmptySelectionToolbar: function testTwiceClickEmptySelectionToolbar() {
        var item = new qx.ui.toolbar.RadioButton();

        this.__testTwiceClickEmptySelection(item);

        item.destroy();
      },
      __testTwiceClickEmptySelection: function __testTwiceClickEmptySelection(widget) {
        var grp = new qx.ui.form.RadioGroup();
        grp.setAllowEmptySelection(true);
        widget.setGroup(grp);
        this.assertFalse(widget.getValue()); // execute the widget

        widget.execute();
        this.assertTrue(widget.getValue(), "1"); // execute again to see that it is still selected

        widget.execute();
        this.assertFalse(widget.getValue(), "2");
        grp.dispose();
      }
    }
  });
  qx.test.ui.RadioItems.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.Widget", {
    extend: qx.dev.unit.TestCase,
    members: {
      __widget: null,
      setUp: function setUp() {
        this.__widget = new qx.ui.core.Widget();
      },
      tearDown: function tearDown() {
        this.__widget.destroy();
      },
      testAddState: function testAddState() {
        this.__widget.addState("test");

        this.assertTrue(this.__widget.hasState("test"));
      },
      testRemoveState: function testRemoveState() {
        this.__widget.addState("test");

        this.assertTrue(this.__widget.hasState("test"));

        this.__widget.removeState("test");

        this.assertFalse(this.__widget.hasState("test"));
      },
      testReplaceState: function testReplaceState() {
        this.__widget.addState("test");

        this.assertTrue(this.__widget.hasState("test"));

        this.__widget.replaceState("test", "affe");

        this.assertTrue(this.__widget.hasState("affe"));
        this.assertFalse(this.__widget.hasState("test"));
      },
      testWidgetThatContainsItself: function testWidgetThatContainsItself() {
        this.assertFalse(qx.ui.core.Widget.contains(this.__widget, this.__widget));
      }
    }
  });
  qx.test.ui.Widget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.window.Window": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.Window", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      _win: null,
      setUp: function setUp() {
        qx.test.ui.Window.prototype.setUp.base.call(this);
        this._win = [];

        for (var i = 0; i < 5; i++) {
          var win = new qx.ui.window.Window("My Window " + i);

          this._win.push(win);

          this.getRoot().add(win);
        }

        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.Window.prototype.tearDown.base.call(this);

        this._disposeArray("_win");
      },
      testActiveWindowBeforeWindowOpened: function testActiveWindowBeforeWindowOpened() {
        this.assertNull(this.getRoot().getActiveWindow());
      },
      testActiveWindowAfterWindowOpened: function testActiveWindowAfterWindowOpened() {
        this._win[0].open();

        this.flush();
        this.assertIdentical(this._win[0], this.getRoot().getActiveWindow());
      },
      testActiveWindowAfterWindowOpened2: function testActiveWindowAfterWindowOpened2() {
        this._win[0].open();

        this._win[1].open();

        this.flush();
        this.assertIdentical(this._win[1], this.getRoot().getActiveWindow());
      },
      testActiveWindowAfterWindowClosed: function testActiveWindowAfterWindowClosed() {
        this._win[0].open();

        this.flush();

        this._win[0].close();

        this.flush();
        this.assertNull(this.getRoot().getActiveWindow());
      },
      testActiveWindowAfterWindowClosed2: function testActiveWindowAfterWindowClosed2() {
        this._win[0].open();

        this._win[1].open();

        this.flush();

        this._win[1].close();

        this.flush();
        this.assertIdentical(this._win[0], this.getRoot().getActiveWindow());
      },
      testActiveWindowAfterAllWindowsOpened: function testActiveWindowAfterAllWindowsOpened() {
        for (var i = 0; i < this._win.length; i++) {
          this._win[i].open();
        }

        this.flush();
        this.assertIdentical(this._win[this._win.length - 1], this.getRoot().getActiveWindow());
      },
      testActiveWindowAfterRemovingOpenedWindow: function testActiveWindowAfterRemovingOpenedWindow() {
        this._win[0].open();

        this.flush();
        this.getRoot().remove(this._win[0]);
        this.flush();
        this.assertNull(this.getRoot().getActiveWindow());
      },
      testActiveWindowAfterRemovingOpenedWindow2: function testActiveWindowAfterRemovingOpenedWindow2() {
        this._win[0].open();

        this._win[1].open();

        this.flush();
        this.getRoot().remove(this._win[1]);
        this.flush();
        this.assertIdentical(this._win[0], this.getRoot().getActiveWindow());
      },
      testActiveWindowAfterRemovingAllWindows: function testActiveWindowAfterRemovingAllWindows() {
        for (var i = 0; i < this._win.length; i++) {
          this._win[i].open();
        }

        this.flush();
        this.getRoot().removeAll();
        this.flush();
        this.assertNull(this.getRoot().getActiveWindow());
      },
      testModalWindowIsAlwaysActiveIfOpen: function testModalWindowIsAlwaysActiveIfOpen() {
        this._win[0].setModal(true);

        this._win[0].open();

        this._win[1].open();

        this.flush();
        this.assertIdentical(this._win[0], this.getRoot().getActiveWindow());
      },
      testOrderModalOverAlwaysOnTopOverNormalWindow: function testOrderModalOverAlwaysOnTopOverNormalWindow() {
        var modal = this._win[0];
        var alwaysOnTop = this._win[1];
        var normal = this._win[2];
        modal.setModal(true);
        alwaysOnTop.setAlwaysOnTop(true);
        modal.open();
        alwaysOnTop.open();
        normal.open();
        this.flush();
        this.assertTrue(+modal.getZIndex() > +alwaysOnTop.getZIndex());
        this.assertTrue(+alwaysOnTop.getZIndex() > +normal.getZIndex());
      }
    }
  });
  qx.test.ui.Window.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.ui.basic.Atom": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016- Oetiker+Partner AG, Switzerland, http://www.oetiker.ch
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fritz Zaucker (fritz.zaucker@oetiker.ch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.basic.Atom", {
    extend: qx.test.ui.LayoutTestCase,
    include: [qx.dev.unit.MMock],
    members: {
      tearDown: function tearDown() {
        this.getSandbox().restore();
      },
      testSelectableSetOnCreation: function testSelectableSetOnCreation() {
        var a = new qx.ui.basic.Atom('test').set({
          selectable: true
        });
        this.getRoot().add(a);
        this.flush();
        var l = a.getChildControl('label');
        this.assertEquals("on", l.getContentElement().getDomElement().getAttribute("qxselectable"));
        a.destroy();
      },
      testSelectableUnSetOnCreation: function testSelectableUnSetOnCreation() {
        var a = new qx.ui.basic.Atom('test').set({
          selectable: false
        });
        this.getRoot().add(a);
        this.flush();
        var l = a.getChildControl('label');
        this.assertEquals("off", l.getContentElement().getDomElement().getAttribute("qxselectable"));
        a.destroy();
      },
      testSelectableSet: function testSelectableSet() {
        var a = new qx.ui.basic.Atom('test');
        a.setSelectable(true);
        this.getRoot().add(a);
        this.flush();
        var l = a.getChildControl('label');
        this.assertEquals("on", l.getContentElement().getDomElement().getAttribute("qxselectable"));
        a.destroy();
      },
      testSelectableUnset: function testSelectableUnset() {
        var a = new qx.ui.basic.Atom('test');
        a.setSelectable(false);
        this.getRoot().add(a);
        this.flush();
        var l = a.getChildControl('label');
        this.assertEquals("off", l.getContentElement().getDomElement().getAttribute("qxselectable"));
        a.destroy();
      }
    }
  });
  qx.test.ui.basic.Atom.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.ui.basic.Image": {},
      "qx.bom.client.Css": {},
      "qx.io.ImageLoader": {},
      "qx.dev.unit.RequirementError": {},
      "qx.html.Image": {},
      "qx.html.Label": {},
      "qx.bom.client.Device": {},
      "qx.util.ResourceManager": {},
      "qx.bom.client.Engine": {},
      "qx.theme.manager.Font": {},
      "qx.Theme": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.alphaimageloaderneeded": {
          "className": "qx.bom.client.Css"
        },
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Alexander Steitz (aback)
  
  ************************************************************************ */

  /**
   * @asset(qx/test/webfonts/fontawesome-webfont.*)
   * @asset(qx/icon/Tango/48/places/folder.png)
   * @asset(qx/icon/Tango/32/places/folder.png)
   * @asset(qx/static/blank.gif)
   * @asset(qx/static/drawer.png)
   * @asset(qx/static/drawer@2x.png)
   */
  qx.Class.define("qx.test.ui.basic.Image", {
    extend: qx.test.ui.LayoutTestCase,
    include: qx.dev.unit.MMock,
    members: {
      tearDown: function tearDown() {
        this.getSandbox().restore();
      },
      testSwitchScaling: function testSwitchScaling() {
        var image = new qx.ui.basic.Image();
        this.addAutoDispose(image);
        image.set({
          source: "qx/icon/Tango/48/places/folder.png",
          scale: false
        });
        this.getRoot().add(image);
        this.flush();
        var tagName = image.getContentElement().getNodeName();
        this.assertTrue(tagName == "div");
        image.setScale(true);
        this.flush();
        var tagNameAfter = image.getContentElement().getNodeName();

        if (qx.core.Environment.get("css.alphaimageloaderneeded")) {
          this.assertTrue(tagNameAfter == "div");
        } else {
          this.assertTrue(tagNameAfter == "img");
        }

        image.destroy();
      },
      testSwitchPngToGif: function testSwitchPngToGif() {
        var image = new qx.ui.basic.Image("qx/icon/Tango/48/places/folder.png");
        this.addAutoDispose(image);
        this.getRoot().add(image);
        this.flush();
        var tagName = image.getContentElement().getNodeName();
        this.assertTrue(tagName == "div");
        image.setSource("qx/static/blank.gif");
        this.flush();
        var tagNameAfter = image.getContentElement().getNodeName();
        this.assertTrue(tagNameAfter == "div");
        image.destroy();
      },
      testSwitchGifToPng: function testSwitchGifToPng() {
        var image = new qx.ui.basic.Image("qx/static/blank.gif");
        this.addAutoDispose(image);
        image.setScale(true);
        this.getRoot().add(image);
        this.flush();
        var contentElement = image.getContentElement();

        if (qx.core.Environment.get("css.alphaimageloaderneeded")) {
          contentElement = contentElement.getChildren()[0];
        }

        var tagName = contentElement.getNodeName();
        this.assertTrue(tagName == "img");
        image.setSource("qx/icon/Tango/48/places/folder.png");
        this.flush();
        contentElement = image.getContentElement();

        if (qx.core.Environment.get("css.alphaimageloaderneeded")) {
          contentElement = contentElement.getChildren()[0];
        }

        var tagNameAfter = contentElement.getNodeName();

        if (qx.core.Environment.get("css.alphaimageloaderneeded")) {
          this.assertTrue(tagNameAfter == "div");
        } else {
          this.assertTrue(tagNameAfter == "img");
        }

        image.destroy();
      },
      testSwitchDimension: function testSwitchDimension() {
        var image = new qx.ui.basic.Image("qx/icon/Tango/48/places/folder.png");
        this.addAutoDispose(image);
        this.getRoot().add(image);
        image.set({
          width: 100,
          height: 100
        });
        this.flush();
        var contentElement = image.getContentElement();

        if (qx.core.Environment.get("css.alphaimageloaderneeded")) {
          contentElement = contentElement.getChildren()[0];
        }

        var width = contentElement.getStyle("width");
        var height = contentElement.getStyle("height");
        image.setScale(true);
        this.flush();
        contentElement = image.getContentElement();

        if (qx.core.Environment.get("css.alphaimageloaderneeded")) {
          contentElement = contentElement.getChildren()[0];
        }

        this.assertEquals(parseInt(contentElement.getStyle("width")), parseInt(width));
        this.assertEquals(parseInt(contentElement.getStyle("height")), parseInt(height));
        image.destroy();
      },
      testSwitchWithDecorator: function testSwitchWithDecorator() {
        var image = new qx.ui.basic.Image("qx/icon/Tango/48/places/folder.png");
        this.addAutoDispose(image);
        this.getRoot().add(image);
        image.setDecorator("main");
        this.flush();
        var decorator = image.getContentElement().getChild(2);
        image.setScale(true);
        this.flush();
        this.assertEquals(image.getContentElement().getChild(2), decorator);
        image.destroy();
      },
      testSwitchWithSelectable: function testSwitchWithSelectable() {
        var image = new qx.ui.basic.Image("qx/icon/Tango/48/places/folder.png");
        this.addAutoDispose(image);
        this.getRoot().add(image);
        image.setSelectable(true);
        this.flush();
        var selectable = image.getContentElement().getAttribute("qxselectable");
        image.setScale(true);
        this.flush();
        var selectableAfter = image.getContentElement().getAttribute("qxselectable");
        this.assertEquals(selectable, selectableAfter);
        image.destroy();
      },
      testFailedEvent: function testFailedEvent() {
        var image = new qx.ui.basic.Image("affe.xyz" + Math.random());
        this.addAutoDispose(image);
        image.addListener("loadingFailed", function () {
          this.resume(function () {
            // use a timeout to dispose the image because it needs to
            // end its processing after the event has been fired.
            window.setTimeout(function () {
              image.destroy();
            });
          });
        }, this);
        this.wait();
      },
      testLoadedEvent: function testLoadedEvent() {
        var source = "../resource/qx/icon/Tango/16/places/folder.png?" + Date.now();
        this.assertFalse(qx.io.ImageLoader.isLoaded(source), "Image already loaded, but this should not happen!");
        var image = new qx.ui.basic.Image(source);
        this.addAutoDispose(image);
        image.addListener("loaded", function () {
          this.resume(function () {
            // use a timeout to dispose the image because it needs to
            // end its processing after the event has been fired.
            window.setTimeout(function () {
              image.destroy();
            });
          });
        }, this);
        this.wait(1000);
      },
      "test: Abort image loading on changing source": function testAbortImageLoadingOnChangingSource() {
        // image will be received with a delay of 2 sec
        var sourceA = "../resource/qx/test/delayedImage.php?" + Date.now();
        var sourceB = "../resource/qx/icon/Tango/16/places/folder.png?" + Date.now();
        var image = new qx.ui.basic.Image(sourceA);
        this.addAutoDispose(image); // spy the load event, it must be called twice at the end of this test

        var spyhandler = this.spy();
        image.addListener("aborted", spyhandler, this);
        this.assertTrue(qx.io.ImageLoader.isLoading(sourceA), "SourceA should be in loading state!");
        image.setSource(sourceB);
        this.assertFalse(qx.io.ImageLoader.isLoaded(sourceA), "SourceA should not be loaded after source change!");
        this.assertCalledOnce(spyhandler);
      },
      "test: Abort image loading through the ImageLoader": function testAbortImageLoadingThroughTheImageLoader() {
        // image will be received with a delay of 2 sec
        var Source = "../resource/qx/test/delayedImage.php?" + Date.now();
        var image = new qx.ui.basic.Image(Source);
        this.addAutoDispose(image); // spy the load event, it must be called twice at the end of this test

        var spyhandler = this.spy();
        image.addListener("aborted", spyhandler, this);
        this.assertTrue(qx.io.ImageLoader.isLoading(Source), "Source should be in loading state!");
        qx.io.ImageLoader.abort(Source);
        this.assertFalse(qx.io.ImageLoader.isLoaded(Source), "Source should not be loaded after source change!");
        this.assertCalledOnce(spyhandler);
      },
      testLoadedEventForUnmanagedImage: function testLoadedEventForUnmanagedImage() {
        // Known to fail in firefox:
        if (this.isFirefox()) {
          throw new qx.dev.unit.RequirementError();
        }

        var source = "../resource/qx/icon/Tango/16/places/folder.png?" + Date.now();
        this.assertFalse(qx.io.ImageLoader.isLoaded(source), "Image already loaded, but this should not happen!");
        var image = new qx.ui.basic.Image();
        this.addAutoDispose(image); // spy the load event, it must be called twice at the end of this test

        var spyhandler = this.spy();
        image.addListener("loaded", spyhandler, this); // load first time

        image.setSource(source); // load second time

        image.addListenerOnce("loaded", function () {
          image.resetSource();
          image.setSource(source);
        }, this);
        this.wait(500, function () {
          this.assertCalledTwice(spyhandler); // use a timeout to dispose the image because it needs to
          // end its processing after the event has been fired.

          window.setTimeout(function () {
            image.destroy();
          });
        }.bind(this));
      },
      testLoadedEventForManagedImage: function testLoadedEventForManagedImage() {
        var source = "qx/icon/Tango/48/places/folder.png";
        var image = new qx.ui.basic.Image();
        this.addAutoDispose(image); // spy the load event, it must be called twice at the end of this test

        var spyhandler = this.spy();
        image.addListener("loaded", spyhandler, this); // load first time

        image.setSource(source); // load second time

        image.addListenerOnce("loaded", function () {
          image.resetSource();
          image.setSource(source);
        }, this);
        this.wait(500, function () {
          this.assertCalledTwice(spyhandler); // use a timeout to dispose the image because it needs to
          // end its processing after the event has been fired.

          window.setTimeout(function () {
            image.destroy();
          });
        }.bind(this));
      },
      testAbortedEventForUnmanagedImage: function testAbortedEventForUnmanagedImage() {
        // Known to fail in firefox:
        if (this.isFirefox()) {
          throw new qx.dev.unit.RequirementError();
        }

        var source = "../resource/qx/icon/Tango/16/places/folder.png?" + Date.now();
        this.assertFalse(qx.io.ImageLoader.isLoaded(source), "Image already loaded, but this should not happen!");
        var image = new qx.ui.basic.Image();
        this.addAutoDispose(image); // spy the load event, it must be called twice at the end of this test

        var spyhandler = this.spy();
        image.addListener("aborted", spyhandler, this); // load first time

        image.setSource(source); // load second time

        image.addListenerOnce("loaded", function () {
          image.resetSource();
          image.setSource(source); // load thrice

          image.resetSource();
          image.setSource(source);
        }, this);
        this.wait(500, function () {
          //even if we called setSource thrice, the loaded event must be called only twice
          this.assertCalledOnce(spyhandler); // use a timeout to dispose the image because it needs to
          // end its processing after the event has been fired.

          window.setTimeout(function () {
            image.destroy();
          });
        }.bind(this));
      },
      testWebFontImage: function testWebFontImage() {
        this._initWebFont();

        var image = new qx.ui.basic.Image("@FontAwesome/heart");
        this.addAutoDispose(image);
        var el = image.getContentElement();
        this.assertEquals("", el.getValue());
        var width = image.getWidth();
        var height = image.getHeight(); // No scale

        image.setScale(false);
        image.setWidth(20);
        this.assertEquals("40px", el.getStyle("fontSize")); // Scale

        image.setScale(true);
        this.assertEquals("20px", el.getStyle("fontSize"));
        image.setWidth(30);
        this.assertEquals("30px", el.getStyle("fontSize")); // Back to no scale

        image.setScale(false);
        image.setWidth(40);
        this.assertEquals("40px", el.getStyle("fontSize")); // Set size via name postfix

        image.setSource("@FontAwesome/heart/55");
        this.assertEquals("55px", el.getStyle("fontSize")); // Check revert to default size

        image.setSource("@FontAwesome/heart");
        this.assertEquals("40px", el.getStyle("fontSize")); // Change content element

        image.setSource("icon/16/apps/office-spreadsheet.png");
        el = image.getContentElement();
        this.assertInstance(el, qx.html.Image);
        image.setSource("@FontAwesome/arrow_right");
        el = image.getContentElement();
        this.assertInstance(el, qx.html.Label); // Set back by unicode number

        image.setSource("@FontAwesome/f004");
        this.assertEquals("", el.getValue()); // reset source

        image.resetSource();
        this.assertEquals(null, el.getValue());
        image.destroy();
      },
      testHighResImage: function testHighResImage() {
        if (qx.core.Environment.get("css.alphaimageloaderneeded")) {
          this.skip();
        }

        var devicePixelRatioStub = this.stub(qx.bom.client.Device, "getDevicePixelRatio", function () {
          return 2;
        });
        var image = new qx.ui.basic.Image("qx/static/drawer.png");
        this.addAutoDispose(image);
        var resourceManager = qx.util.ResourceManager.getInstance();
        this.assertTrue(resourceManager.has("qx/static/drawer@2x.png"));
        this.assertEquals("qx/static/drawer@2x.png", image.getContentElement().getSource());
        image.destroy();
        devicePixelRatioStub.restore();
      },
      testHighResImageWithDecoratorAndSourceInConstructor: function testHighResImageWithDecoratorAndSourceInConstructor() {
        if (qx.core.Environment.get("css.alphaimageloaderneeded")) {
          this.skip();
        }

        var devicePixelRatioStub = this.stub(qx.bom.client.Device, "getDevicePixelRatio", function () {
          return 2;
        });
        var image = new qx.ui.basic.Image("qx/static/drawer.png");
        this.addAutoDispose(image);
        image.setDecorator("toolbar-part");
        var resourceManager = qx.util.ResourceManager.getInstance();
        this.assertTrue(resourceManager.has("qx/static/drawer@2x.png"));
        var backgroundImage = image.getContentElement().getStyle("backgroundImage");
        this.assertTrue(backgroundImage.indexOf("drawer@2x.png") > -1);
        this.assertTrue(backgroundImage.indexOf("toolbar-part.gif") > -1);
        image.destroy();
        devicePixelRatioStub.restore();
      },
      testHighResImageWithDecoratorAndSourceInSetter: function testHighResImageWithDecoratorAndSourceInSetter() {
        if (qx.core.Environment.get("css.alphaimageloaderneeded")) {
          this.skip();
        }

        var devicePixelRatioStub = this.stub(qx.bom.client.Device, "getDevicePixelRatio", function () {
          return 2;
        });
        var image = new qx.ui.basic.Image();
        this.addAutoDispose(image);
        image.setDecorator("toolbar-part");
        image.setSource("qx/static/drawer.png");
        var resourceManager = qx.util.ResourceManager.getInstance();
        this.assertTrue(resourceManager.has("qx/static/drawer@2x.png"));
        var backgroundImage = image.getContentElement().getStyle("backgroundImage");
        this.assertTrue(backgroundImage.indexOf("drawer@2x.png") > -1);
        this.assertTrue(backgroundImage.indexOf("toolbar-part.gif") > -1);
        image.destroy();
        devicePixelRatioStub.restore();
      },
      isFirefox: function isFirefox() {
        return qx.core.Environment.get("engine.name") === "gecko";
      },

      /**
       * @ignore(qx.theme.icon.Font)
       */
      _initWebFont: function _initWebFont() {
        qx.$$resources["@FontAwesome/heart"] = [40, 40, 61444];
        qx.$$resources["@FontAwesome/arrow_right"] = [40, 47, 61537];
        var currentFont = qx.theme.manager.Font.getInstance().getTheme(); // Add font definitions

        var config = {
          fonts: {
            "FontAwesome": {
              size: 40,
              lineHeight: 1,
              comparisonString: "\uf1e3\uf1f7\uf11b\uf19d",
              family: ["FontAwesome"],
              sources: [{
                family: "FontAwesome",
                source: ["qx/test/webfonts/fontawesome-webfont.ttf", "qx/test/webfonts/fontawesome-webfont.woff"]
              }]
            }
          }
        };
        qx.Theme.define("qx.theme.icon.Font", config);
        qx.Theme.include(currentFont, qx.theme.icon.Font);
      }
    }
  });
  qx.test.ui.basic.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.bom.client.Browser": {},
      "qx.bom.webfonts.Manager": {},
      "qx.ui.container.Composite": {},
      "qx.ui.layout.Grow": {},
      "qx.ui.basic.Label": {},
      "qx.bom.webfonts.WebFont": {},
      "qx.util.ResourceManager": {},
      "qx.event.Timer": {},
      "qx.bom.Font": {},
      "qx.ui.form.TextField": {},
      "qx.lang.Array": {},
      "qx.locale.Manager": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "browser.version": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @asset(qx/test/webfonts/*)
   */
  qx.Class.define("qx.test.ui.basic.Label", {
    extend: qx.test.ui.LayoutTestCase,
    include: [qx.dev.unit.MRequirements, qx.dev.unit.MMock],
    members: {
      hasWebFontSupport: function hasWebFontSupport() {
        var browser = qx.core.Environment.get("browser.name");
        var version = qx.core.Environment.get("browser.version");

        if (browser == "firefox" && version < 3.5 || browser == "opera" && version < 10) {
          return false;
        }

        return true;
      },
      tearDown: function tearDown() {
        qx.test.ui.basic.Label.prototype.tearDown.base.call(this);
        this.getSandbox().restore();
        qx.bom.webfonts.Manager.getInstance().dispose();
        delete qx.bom.webfonts.Manager.$$instance;
      },
      testHeightForWidth: function testHeightForWidth() {
        var container = new qx.ui.container.Composite(new qx.ui.layout.Grow());
        this.getRoot().add(container);
        var label = new qx.ui.basic.Label("juhu kinners juhu kinners juhu kinners juhu kinners juhu kinners juhu kinners ").set({
          rich: true
        });
        container.add(label);
        this.flush();
        var width = label.getBounds().width;
        this.assertEquals(width, container.getBounds().width);
        container.setWidth(10);
        this.flush();
        container.resetWidth();
        this.flush();
        this.assertEquals(width, label.getBounds().width);
        container.destroy();
      },
      testSelectableSetOnCreate: function testSelectableSetOnCreate() {
        var l = new qx.ui.basic.Label().set({
          selectable: true
        });
        this.getRoot().add(l);
        this.flush();
        this.assertEquals("on", l.getContentElement().getDomElement().getAttribute("qxselectable"));
        l.destroy();
      },
      testSelectableUnSetOnCreate: function testSelectableUnSetOnCreate() {
        var l = new qx.ui.basic.Label().set({
          selectable: false
        });
        this.getRoot().add(l);
        this.flush();
        this.assertEquals("off", l.getContentElement().getDomElement().getAttribute("qxselectable"));
        l.destroy();
      },
      testSelectableSet: function testSelectableSet() {
        var l = new qx.ui.basic.Label();
        l.setSelectable(true);
        this.getRoot().add(l);
        this.flush();
        this.assertEquals("on", l.getContentElement().getDomElement().getAttribute("qxselectable"));
        l.destroy();
      },
      testSelectableUnset: function testSelectableUnset() {
        var l = new qx.ui.basic.Label();
        l.setSelectable(false);
        this.getRoot().add(l);
        this.flush();
        this.assertEquals("off", l.getContentElement().getDomElement().getAttribute("qxselectable"));
        l.destroy();
      },
      testWrapSet: function testWrapSet() {
        var l = new qx.ui.basic.Label();
        l.setRich(true);
        l.setWrap(true);
        this.assertEquals("normal", l.getContentElement().getStyle("whiteSpace"));
        l.dispose();
      },
      testTextAlign: function testTextAlign() {
        var l = new qx.ui.basic.Label();
        l.setRich(true);
        l.setTextAlign("justify");
        this.assertEquals("justify", l.getContentElement().getStyle("textAlign"));
        l.dispose();
        var l = new qx.ui.basic.Label();
        l.setRich(true);
        l.setTextAlign("right");
        this.assertEquals("right", l.getContentElement().getStyle("textAlign"));
        l.dispose();
        var l = new qx.ui.basic.Label();
        l.setRich(true);
        l.setTextAlign("left");
        this.assertEquals("left", l.getContentElement().getStyle("textAlign"));
        l.dispose();
        var l = new qx.ui.basic.Label();
        l.setRich(true);
        l.setTextAlign("center");
        this.assertEquals("center", l.getContentElement().getStyle("textAlign"));
        l.dispose();
      },
      testWrapNotSet: function testWrapNotSet() {
        var l = new qx.ui.basic.Label();
        l.setRich(true);
        l.setWrap(false);
        this.assertEquals("nowrap", l.getContentElement().getStyle("whiteSpace"));
        l.dispose();
      },
      testApplyWebFont: function testApplyWebFont() {
        this.require(["webFontSupport"]);

        var l = new qx.ui.basic.Label("Laugh while you can, monkey boy!");
        var f = new qx.bom.webfonts.WebFont();
        f.set({
          size: 18,
          family: ["monospace"],
          sources: [{
            family: "FinelinerScriptRegular",
            source: [qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fineliner_script-webfont.woff"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fineliner_script-webfont.ttf"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fineliner_script-webfont.eot")]
          }, {
            family: "YanoneKaffeesatzRegular",
            source: [qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/yanonekaffeesatz-regular-webfont.woff"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/yanonekaffeesatz-regular-webfont.ttf"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/yanonekaffeesatz-regular-webfont.eot")]
          }]
        });
        var statusChangeSpy = this.spy(l, "_onWebFontStatusChange");
        l.setFont(f);
        qx.event.Timer.once(function () {
          this.resume(function () {
            l.dispose();
            f.dispose();
            this.assertCalledTwice(statusChangeSpy);
          }, this);
        }, this, 4000);
        this.wait(8000);
      },
      testApplyFontColorAndTextColor: function testApplyFontColorAndTextColor() {
        var font1 = new qx.bom.Font();
        font1.setColor("#FF0000");
        var label1 = new qx.ui.basic.Label("test 1");
        label1.setTextColor("#00FF00");
        label1.setFont(font1);
        this.getRoot().add(label1);
        this.flush();
        this.assertEquals("#00FF00", label1.getContentElement().getStyle("color"), "Color property should have more priority than font color.");
        label1.destroy();
        font1.dispose();
      },
      testBuddy: function testBuddy() {
        var label = new qx.ui.basic.Label();
        var textfield1 = new qx.ui.form.TextField();
        var textfield2 = new qx.ui.form.TextField(); // set first text field as buddy

        label.setBuddy(textfield1); // label and textfield1 must have the same binding

        this.assertEquals(1, label.getBindings().length, "There must be one binding!");
        this.assertEquals(1, textfield1.getBindings().length, "There must be one binding!");
        this.assertTrue(qx.lang.Array.equals(label.getBindings()[0], textfield1.getBindings()[0]), "label and textfield1 must have the same binding"); // change the buddy of label to textfield2

        label.setBuddy(textfield2); // textfield1 must not have a binding anymore

        this.assertEquals(0, textfield1.getBindings().length, "There is still a binding!"); // label and textfield2 must have the same binding

        this.assertEquals(1, label.getBindings().length, "There must be one binding!");
        this.assertEquals(1, textfield2.getBindings().length, "There must be one binding!");
        this.assertTrue(qx.lang.Array.equals(label.getBindings()[0], textfield2.getBindings()[0]), "label and textfield1 must have the same binding");
        label.dispose();
      },
      testLocaleInitialization: function testLocaleInitialization() {
        var label = new qx.ui.basic.Label();
        var localeManager = qx.locale.Manager.getInstance();
        localeManager.addTranslation("en", {
          "TEST": "EN"
        });
        localeManager.addTranslation("de", {
          "TEST": "DE"
        });
        localeManager.setLocale("en");
        var test = qx.locale.Manager.tr("TEST");
        localeManager.setLocale("de");
        label.setValue(test);
        this.assertEquals("DE", label.getContentElement().getValue(), "label must have the current locale set");
      }
    }
  });
  qx.test.ui.basic.Label.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.ui.command.Command": {},
      "qx.ui.form.Button": {},
      "qx.ui.toolbar.Button": {},
      "qx.ui.menu.Button": {},
      "qx.locale.Manager": {},
      "qx.ui.menu.CheckBox": {},
      "qx.ui.menu.RadioButton": {},
      "qx.ui.form.ToggleButton": {},
      "qx.ui.form.SplitButton": {},
      "qx.ui.menu.Menu": {},
      "qx.ui.core.queue.Manager": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.command.bindEnabled": {}
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Mustafa Sak (msak)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.command.Command", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      __cmd: null,
      __button: null,
      __toolbarButton: null,
      __menuButton: null,
      setUp: function setUp() {
        this.__cmd = new qx.ui.command.Command();
        this.__button = new qx.ui.form.Button("a");

        this.__button.setCommand(this.__cmd);

        this.__toolbarButton = new qx.ui.toolbar.Button("b");

        this.__toolbarButton.setCommand(this.__cmd);

        this.__menuButton = new qx.ui.menu.Button("c");

        this.__menuButton.setCommand(this.__cmd);

        qx.locale.Manager.getInstance().setLocale("en");
      },
      tearDown: function tearDown() {
        this.__cmd.dispose();

        this.__button.destroy();

        this.__toolbarButton.destroy();

        this.__menuButton.destroy();

        qx.locale.Manager.getInstance().resetLocale();
      },
      testLabel: function testLabel() {
        // set a label
        this.__cmd.setLabel("a");

        this.assertEquals(this.__cmd.getLabel(), this.__button.getLabel());
        this.assertEquals(this.__cmd.getLabel(), this.__toolbarButton.getLabel());
        this.assertEquals(this.__cmd.getLabel(), this.__menuButton.getLabel()); // set null

        this.__cmd.setLabel(null);

        this.assertEquals(this.__cmd.getLabel(), this.__button.getLabel());
        this.assertEquals(this.__cmd.getLabel(), this.__toolbarButton.getLabel());
        this.assertEquals(this.__cmd.getLabel(), this.__menuButton.getLabel()); // set a second string

        this.__cmd.setLabel("b");

        this.assertEquals(this.__cmd.getLabel(), this.__button.getLabel());
        this.assertEquals(this.__cmd.getLabel(), this.__toolbarButton.getLabel());
        this.assertEquals(this.__cmd.getLabel(), this.__menuButton.getLabel()); // reset

        this.__cmd.resetLabel();

        this.assertEquals(this.__cmd.getLabel(), this.__button.getLabel());
        this.assertEquals(this.__cmd.getLabel(), this.__toolbarButton.getLabel());
        this.assertEquals(this.__cmd.getLabel(), this.__menuButton.getLabel());
      },
      testEnabled: function testEnabled() {
        if (qx.core.Environment.get("qx.command.bindEnabled")) {
          // set disabled
          this.__cmd.setEnabled(false);

          this.assertEquals(this.__cmd.getEnabled(), this.__button.getEnabled());
          this.assertEquals(this.__cmd.getEnabled(), this.__toolbarButton.getEnabled());
          this.assertEquals(this.__cmd.getEnabled(), this.__menuButton.getEnabled()); // set enabled

          this.__cmd.setEnabled(true);

          this.assertEquals(this.__cmd.getEnabled(), this.__button.getEnabled());
          this.assertEquals(this.__cmd.getEnabled(), this.__toolbarButton.getEnabled());
          this.assertEquals(this.__cmd.getEnabled(), this.__menuButton.getEnabled());
        } else {
          this.skip("Skipped because binding the Enabled property has been deprecated");
        }
      },
      testIcon: function testIcon() {
        // set a string
        this.__cmd.setIcon("a");

        this.assertEquals(this.__cmd.getIcon(), this.__button.getIcon());
        this.assertEquals(this.__cmd.getIcon(), this.__toolbarButton.getIcon());
        this.assertEquals(this.__cmd.getIcon(), this.__menuButton.getIcon()); // set null

        this.__cmd.setIcon(null);

        this.assertEquals(this.__cmd.getIcon(), this.__button.getIcon());
        this.assertEquals(this.__cmd.getIcon(), this.__toolbarButton.getIcon());
        this.assertEquals(this.__cmd.getIcon(), this.__menuButton.getIcon()); // set a second string

        this.__cmd.setIcon("b");

        this.assertEquals(this.__cmd.getIcon(), this.__button.getIcon());
        this.assertEquals(this.__cmd.getIcon(), this.__toolbarButton.getIcon());
        this.assertEquals(this.__cmd.getIcon(), this.__menuButton.getIcon()); // reset

        this.__cmd.resetIcon();

        this.assertEquals(this.__cmd.getIcon(), this.__button.getIcon());
        this.assertEquals(this.__cmd.getIcon(), this.__toolbarButton.getIcon());
        this.assertEquals(this.__cmd.getIcon(), this.__menuButton.getIcon());
      },
      testToolTipText: function testToolTipText() {
        // set a string
        this.__cmd.setToolTipText("a");

        this.assertEquals(this.__cmd.getToolTipText(), this.__button.getToolTipText());
        this.assertEquals(this.__cmd.getToolTipText(), this.__toolbarButton.getToolTipText());
        this.assertEquals(this.__cmd.getToolTipText(), this.__menuButton.getToolTipText()); // set null

        this.__cmd.setIcon(null);

        this.assertEquals(this.__cmd.getToolTipText(), this.__button.getToolTipText());
        this.assertEquals(this.__cmd.getToolTipText(), this.__toolbarButton.getToolTipText());
        this.assertEquals(this.__cmd.getToolTipText(), this.__menuButton.getToolTipText()); // set a second string

        this.__cmd.setIcon("b");

        this.assertEquals(this.__cmd.getToolTipText(), this.__button.getToolTipText());
        this.assertEquals(this.__cmd.getToolTipText(), this.__toolbarButton.getToolTipText());
        this.assertEquals(this.__cmd.getToolTipText(), this.__menuButton.getToolTipText()); // reset

        this.__cmd.resetIcon();

        this.assertEquals(this.__cmd.getToolTipText(), this.__button.getToolTipText());
        this.assertEquals(this.__cmd.getToolTipText(), this.__toolbarButton.getToolTipText());
        this.assertEquals(this.__cmd.getToolTipText(), this.__menuButton.getToolTipText());
      },
      testRemoveCommand: function testRemoveCommand() {
        // remove the command (has been set in the setUp method)
        this.__button.setCommand(null);

        this.__toolbarButton.setCommand(null);

        this.__menuButton.setCommand(null); // set a label


        this.__cmd.setLabel("x"); // check if the label has been set


        this.assertEquals("a", this.__button.getLabel());
        this.assertEquals("b", this.__toolbarButton.getLabel());
        this.assertEquals("c", this.__menuButton.getLabel());
      },
      testValue: function testValue() {
        var menuCheckBox = new qx.ui.menu.CheckBox();
        var menuRadioButton = new qx.ui.menu.RadioButton();
        var toggleButton = new qx.ui.form.ToggleButton(); // set the command

        menuRadioButton.setCommand(this.__cmd);
        menuCheckBox.setCommand(this.__cmd);
        toggleButton.setCommand(this.__cmd); // set the value

        this.__cmd.setValue(true);

        this.assertEquals(this.__cmd.getValue(), menuCheckBox.getValue());
        this.assertEquals(this.__cmd.getValue(), menuRadioButton.getValue());
        this.assertEquals(this.__cmd.getValue(), toggleButton.getValue()); // set the value

        this.__cmd.setValue(false);

        this.assertEquals(this.__cmd.getValue(), menuCheckBox.getValue());
        this.assertEquals(this.__cmd.getValue(), menuRadioButton.getValue());
        this.assertEquals(this.__cmd.getValue(), toggleButton.getValue());
        toggleButton.dispose();
        menuCheckBox.dispose();
        menuRadioButton.dispose();
      },
      testMenu: function testMenu() {
        var splitButton = new qx.ui.form.SplitButton();
        splitButton.setCommand(this.__cmd);
        var menu = new qx.ui.menu.Menu(); // set the menu

        this.__cmd.setMenu(menu);

        this.assertEquals(menu, splitButton.getMenu());
        this.assertEquals(menu, this.__menuButton.getMenu()); // reset the menu

        this.__cmd.resetMenu();

        this.assertNull(splitButton.getMenu());
        this.assertNull(this.__menuButton.getMenu());
        splitButton.dispose();
        menu.destroy();
      },
      testInit: function testInit() {
        // check if the init values after setting the command was added
        this.assertEquals("a", this.__button.getLabel());
        this.assertEquals("b", this.__toolbarButton.getLabel());
        this.assertEquals("c", this.__menuButton.getLabel()); // add a new command

        var cmd = new qx.ui.command.Command();
        cmd.setLabel("x");

        this.__button.setCommand(cmd);

        this.__toolbarButton.setCommand(cmd);

        this.__menuButton.setCommand(cmd);

        this.assertEquals(cmd.getLabel(), this.__button.getLabel());
        this.assertEquals(cmd.getLabel(), this.__toolbarButton.getLabel());
        this.assertEquals(cmd.getLabel(), this.__menuButton.getLabel());
        cmd.dispose();
      },
      testIconAsToolTipText: function testIconAsToolTipText() {
        // for [BUG #4534]
        var cmd = new qx.ui.command.Command("Control+D");
        cmd.setToolTipText("affe");
        var button1 = new qx.ui.form.Button("x", "y");
        button1.setCommand(cmd);
        this.assertEquals("affe", button1.getToolTipText());
        button1.dispose();
        cmd.dispose();
      },
      testDestructExecutable: function testDestructExecutable() {
        // Create the command
        var cmd = new qx.ui.command.Command("Meta+T"); // Create a button linked to cmd

        var button = new qx.ui.form.Button("Command button", null, cmd);
        cmd.setEnabled(false);
        button.destroy(); // make sure the dispose queue is flushed

        qx.ui.core.queue.Manager.flush();
        cmd.setEnabled(true);
        cmd.dispose(); // test makes sure that code is running, no assert needed
      },
      testFireExecuteCount: function testFireExecuteCount() {
        var handler = this.spy(); // Create the command

        var cmd = new qx.ui.command.Command("Meta+T");
        cmd.addListener("execute", handler);
        cmd.setEnabled(false);
        cmd.setActive(false);
        cmd.execute();
        this.assertCallCount(handler, 0);
        cmd.setEnabled(true);
        cmd.setActive(false);
        cmd.execute();
        this.assertCallCount(handler, 0);
        cmd.setEnabled(true);
        cmd.setActive(true);
        cmd.execute();
        this.assertCallCount(handler, 1);
        cmd.dispose();
      },
      testGetShortcut: function testGetShortcut() {
        // for bug #7036
        var cmd = new qx.ui.command.Command("Control+X");
        this.assertEquals('Control+X', cmd.getShortcut());
        cmd.dispose();
      },
      testShortCutToString: function testShortCutToString() {
        // for bug #8465
        var cmd = new qx.ui.command.Command("Ctrl+X");
        this.assertEquals("Ctrl+X", cmd.toString());
        cmd.dispose();
        this.assertEquals("qx.ui.command.Command[undefined]", cmd.toString());
      }
    }
  });
  qx.test.ui.command.Command.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.ui.command.Group": {},
      "qx.ui.command.Command": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Mustafa Sak (msak)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.command.Group", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      testAddingAndActivating: function testAddingAndActivating() {
        var handler = this.spy();
        var group = new qx.ui.command.Group();
        var cmd = new qx.ui.command.Command("Meta+T");
        cmd.addListener("execute", handler);
        this.assertTrue(group.add("test", cmd));
        group.setActive(false);
        cmd.execute();
        this.assertCallCount(handler, 0);
        group.setActive(true);
        cmd.execute();
        this.assertCallCount(handler, 1);
      },
      testHasCommand: function testHasCommand() {
        var handler = this.spy();
        var group = new qx.ui.command.Group();
        var cmd = new qx.ui.command.Command("Meta+T");
        this.assertTrue(group.add("test", cmd));
        this.assertTrue(group.has("test"), "The command added with key 'test' must be registered.");
        this.assertFalse(group.has("foo"), "The command 'foo' must not be registered.");
      },
      testRemoveCommand: function testRemoveCommand() {
        var group = new qx.ui.command.Group();
        var cmd = new qx.ui.command.Command("Meta+T");
        this.assertTrue(group.add("test", cmd));
        this.assertInstance(group.get("test"), qx.ui.command.Command, "Returned value is not an instance of qx.ui.command.Command.");
        this.assertInstance(group.remove("test"), qx.ui.command.Command);
        this.assertNull(group.get("test"), "The returned value is not null. We expected null after removing the command from group.");
      }
    }
  });
  qx.test.ui.command.Group.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.command.Command": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     Authors:
       * Mustafa Sak (msak)
  
  ************************************************************************ */

  /**
   * Registrar for commands to be able to group them.
   */
  qx.Class.define("qx.ui.command.Group", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this._cmds = {};
    },
    properties: {
      /**
       * Activates or deactivates all commands in group.
       */
      active: {
        init: true,
        check: "Boolean",
        apply: "_applyActive"
      }
    },
    members: {
      _cmds: null,
      // property apply
      _applyActive: function _applyActive(value) {
        for (var cmdkey in this._cmds) {
          this._cmds[cmdkey].setActive(value);
        }
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Adds a command with a key to the group.
       *
       * @param key {String} Key to be able to addresses the command
       * @param command {qx.ui.command.Command} Command
       *
       * @return {Boolean} <code>false</code> if key already added before
       */
      add: function add(key, command) {
        {
          this.assertArgumentsCount(arguments, 2, 2, "Given parameter count mismatch! Please provide a key as string and a command intsance.");
          this.assertString(key, "Key parameter must be a string.");
          this.assertInstance(command, qx.ui.command.Command, "Given command is not an instance of qx.ui.command.Command");
        }

        if (this.has(key)) {
          {
            this.debug("Command with key: '" + key + "' already exists!");
          }
          return false;
        }

        this._cmds[key] = command;
        return true;
      },

      /**
       * Returns a command by key.
       *
       * @param key {String} Key which addresses the command
       *
       * @return {qx.ui.command.Command | null} Corresponding command instance or null
       */
      get: function get(key) {
        {
          this.assertString(key, "Key parameter must be a string.");
        }
        var cmd = this._cmds[key];

        if (!cmd) {
          {
            this.debug("The key: '" + key + "' was not added before. Please use " + "'add()' method to add the command.");
          }
          return null;
        }

        return cmd;
      },

      /**
       * Returns true if a command is registered by key.
       *
       * @param key {String} Key which addresses the command
       *
       * @return {Boolean} Returns <code>true</code> if a command is registered by a key
       */
      has: function has(key) {
        {
          this.assertString(key, "Key parameter must be a string.");
        }
        return !!this._cmds[key];
      },

      /**
       * Removes a command by key from group. Returns the command.
       *
       * @param key {String} Key which addresses the command
       *
       * @return {qx.ui.command.Command | null} Corresponding command instance or null
       */
      remove: function remove(key) {
        {
          this.assertString(key, "Key parameter must be a string.");
        }
        var cmd = this._cmds[key];

        if (!cmd) {
          {
            this.debug("The key: '" + key + "' was not added before. Please use " + "'add()' method to add the command.");
          }
          return null;
        }

        delete this._cmds[key];
        return cmd;
      }
    },
    destruct: function destruct() {
      this._cmds = null;
    }
  });
  qx.ui.command.Group.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.ui.command.GroupManager": {},
      "qx.ui.command.Group": {},
      "qx.ui.command.Command": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Mustafa Sak (msak)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.command.GroupManager", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      testGroupManager: function testGroupManager() {
        var handler = this.spy();
        var manager = new qx.ui.command.GroupManager();
        var group = new qx.ui.command.Group();
        var cmd = new qx.ui.command.Command("Meta+T");
        var group2 = new qx.ui.command.Group();
        var cmd2 = new qx.ui.command.Command("Meta+T");
        cmd.addListener("execute", handler);
        cmd2.addListener("execute", handler);
        group.add("cmd", cmd);
        group2.add("cmd2", cmd2);
        manager.add(group);
        manager.add(group2);
        manager.setActive(group);
        cmd.execute();
        cmd2.execute();
        this.assertCallCount(handler, 1);
        manager.setActive(group);
        cmd.execute();
        cmd2.execute();
        this.assertCallCount(handler, 2);
        manager.unblock(group);
        cmd.execute();
        cmd2.execute();
        this.assertCallCount(handler, 3);
        manager.block(group);
        cmd.execute();
        cmd2.execute();
        this.assertCallCount(handler, 3);
      },
      "test: add and remove group": function testAddAndRemoveGroup() {
        var manager = new qx.ui.command.GroupManager();
        var group = new qx.ui.command.Group();
        var cmd = new qx.ui.command.Command("Meta+T");
        var group2 = new qx.ui.command.Group();
        var cmd2 = new qx.ui.command.Command("Meta+T");
        manager.add(group);
        manager.add(group2);
        manager.setActive(group);
        manager.remove(group);
        this.assertFalse(manager.has(group));
        this.assertNull(manager.getActive(group));
      }
    }
  });
  qx.test.ui.command.GroupManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.command.Group": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     Authors:
       * Mustafa Sak (msak)
  
  
  ************************************************************************ */

  /**
   * Registrar for command groups to be able to active or deactive them.
   */
  qx.Class.define("qx.ui.command.GroupManager", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__groups = [];
    },
    members: {
      __groups: null,
      __activeGroup: null,

      /**
       * Add command group.
       *
       * @param group {qx.ui.command.Group} Command group
       *
       * @return {Boolean} <code>false</code> if group was already added before
       */
      add: function add(group) {
        {
          this.assertInstance(group, qx.ui.command.Group, "Given group is not an instance of qx.ui.command.Group");
        }

        if (this.__groups.includes(group)) {
          {
            this.debug("Group is already added!");
          }
          return false;
        }

        this.__groups.push(group); // deactivate added group to prevent collusions


        group.setActive(false);
        return true;
      },

      /**
       * Whether a command manager was added.
       *
       * @param group {qx.ui.command.Group} Command group
       *
       * @return {Boolean} <code>true</code> if group already added
       */
      has: function has(group) {
        {
          this.assertInstance(group, qx.ui.command.Group, "Given group is not an instance of qx.ui.command.Group");
        }
        return !!this._getGroup(group);
      },

      /**
       * Removes a command group from group manager. If removed group was the
       * active group, active group will be set to <code>null</code> Returns the
       * group.
       *
       * @param group {qx.ui.command.Group} Command group
       *
       * @return {qx.ui.command.Group | null} Command group or null if group was not added before
       */
      remove: function remove(group) {
        {
          this.assertInstance(group, qx.ui.command.Group, "Group must be an instance of qx.ui.command.Group");
        }

        var index = this.__groups.indexOf(group);

        if (index === -1) {
          {
            this.debug("Group was not added before. Please use 'add()' method to add the group.");
          }
        } // reset active group


        if (this.getActive() === group) {
          this.__activeGroup = null;
        } // remove group from internal array


        this.__groups.splice(index, 1);

        return group;
      },

      /**
       * Activates a command group and deactivates all other added groups.
       *
       * @param group {qx.ui.command.Group} Command group
       *
       * @return {Boolean} <code>false</code> if group was not added before
       */
      setActive: function setActive(group) {
        {
          this.assertInstance(group, qx.ui.command.Group, "Given group is not an instance of qx.ui.command.Group");
        }

        if (!this.has(group)) {
          {
            this.debug("Group was not added before! You have to use 'addCommand()' method before activating!");
          }
          return false;
        } // iterate through all groups and deactivate all expect the given one


        for (var i = 0; i < this.__groups.length; i++) {
          var item = this.__groups[i];

          if (item == group) {
            item.setActive(true);
            this.__activeGroup = item;
            continue;
          }

          item.setActive(false);
        }

        return true;
      },

      /**
       * Returns active command group.
       *
       * @return {qx.ui.command.Group | null} Active command group
       */
      getActive: function getActive() {
        return this.__activeGroup;
      },

      /**
       * Blocks the active command group.
       */
      block: function block() {
        if (this.__activeGroup) {
          this.__activeGroup.setActive(false);
        }
      },

      /**
       * Unblocks the active command group.
       */
      unblock: function unblock() {
        if (this.__activeGroup) {
          this.__activeGroup.setActive(true);
        }
      },

      /**
       * Helper function returns added command group.
       *
       * @param group {qx.ui.command.Group} Command group
       *
       * @return {qx.ui.command.Group | null} Command group or null
       */
      _getGroup: function _getGroup(group) {
        var index = this.__groups.indexOf(group);

        if (index === -1) {
          return null;
        }

        return this.__groups[index];
      }
    },
    destruct: function destruct() {
      this.__groups = this.__activeGroup = null;
    }
  });
  qx.ui.command.GroupManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.container.Stack": {},
      "qx.ui.container.Composite": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.container.Stack", {
    extend: qx.dev.unit.TestCase,
    members: {
      __stack: null,
      __c1: null,
      __c2: null,
      __c3: null,
      setUp: function setUp() {
        var stack = this.__stack = new qx.ui.container.Stack();
        var c1 = this.__c1 = new qx.ui.container.Composite();
        var c2 = this.__c2 = new qx.ui.container.Composite();
        var c3 = this.__c3 = new qx.ui.container.Composite();
        c1.set({
          backgroundColor: "#F00",
          width: 200,
          height: 200
        });
        c2.set({
          backgroundColor: "#0F0",
          width: 200,
          height: 200
        });
        c3.set({
          backgroundColor: "#00F",
          width: 200,
          height: 200
        });
      },
      tearDown: function tearDown() {
        this.__stack.destroy();

        this.__c1.destroy();

        this.__c2.destroy();

        this.__c3.destroy();
      },

      /**
       * if stack doesn't have a child selected,
       * the new added child should be selected
       */
      testAddAndSelectChild: function testAddAndSelectChild() {
        this.__stack.add(this.__c1);

        this.assertIdentical(this.__c1, this.__stack.getSelection()[0]);
      },

      /**
       * if stack has a selected child,
       * the new added one should be excluded/hide but not selected.
       */
      testAddAndDontSelectChildInADynamicStack: function testAddAndDontSelectChildInADynamicStack() {
        this.__stack.setDynamic(false);

        this.__stack.add(this.__c1);

        this.__stack.add(this.__c2);

        this.assertIdentical(this.__c1, this.__stack.getSelection()[0]);
        this.assertTrue(this.__c2.isHidden());
      },

      /**
       * if stack has a selected child,
       * the new added one should be excluded/hide but not selected.
       */
      testAddAndDontSelectChildInANonDynamicStack: function testAddAndDontSelectChildInANonDynamicStack() {
        this.__stack.setDynamic(true);

        this.__stack.add(this.__c1);

        this.__stack.add(this.__c2);

        this.assertIdentical(this.__c1, this.__stack.getSelection()[0]);
        this.assertTrue(this.__c2.isExcluded());
      },

      /**
       *if we remove child, selected the first one
       */
      testRemoveSelectedChildSelectFirstOne: function testRemoveSelectedChildSelectFirstOne() {
        this.__stack.add(this.__c1);

        this.__stack.add(this.__c2);

        this.__stack.setSelection([this.__c2]);

        this.__stack.remove(this.__c2);

        this.assertIdentical(this.__c1, this.__stack.getSelection()[0]);
      },

      /**
       * if we remove child, and stack doesn't have any children left,
       * reset selection.
       */
      testRemoveSelectedChildResetSelection: function testRemoveSelectedChildResetSelection() {
        this.__stack.add(this.__c1);

        this.__stack.add(this.__c2);

        this.__stack.add(this.__c3);

        this.__stack.remove(this.__c1);

        this.__stack.remove(this.__c2);

        this.__stack.remove(this.__c3);

        this.assertArrayEquals([], this.__stack.getSelection());
      }
    }
  });
  qx.test.ui.container.Stack.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.ui.core.scroll.AbstractScrollArea": {},
      "qx.ui.container.Composite": {},
      "qx.ui.layout.Grow": {},
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Martijn Evers, The Netherlands
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martijn Evers (mever)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.ui.core.AbstractScrollArea.fixture.CustomWidget)
   */
  qx.Class.define("qx.test.ui.core.AbstractScrollArea", {
    extend: qx.test.ui.LayoutTestCase,
    include: qx.dev.unit.MMock,
    members: {
      /** @type {qx.test.ui.core.AbstractScrollArea.fixture.CustomWidget} */
      __widget: null,

      /** @type {qx.ui.container.Composite} */
      __outer: null,
      setUp: function setUp() {
        qx.Class.define("qx.test.ui.core.AbstractScrollArea.fixture.CustomWidget", {
          extend: qx.ui.core.scroll.AbstractScrollArea,
          members: {
            /**
             * @param widget {qx.ui.core.LayoutItem} 
             */
            setSingleChild: function setSingleChild(widget) {
              this.getChildControl('pane').add(widget);
            },

            /**
             * @param side {String} Either 'x' or 'y'.
             * @returns {boolean}
             */
            hasScrollBar: function hasScrollBar(side) {
              this._computeScrollbars();

              return this._isChildControlVisible("scrollbar-" + side);
            }
          }
        });
        this.__outer = new qx.ui.container.Composite(new qx.ui.layout.Grow());

        this.__outer.set({
          maxWidth: 100,
          maxHeight: 100
        });

        this.__widget = new qx.test.ui.core.AbstractScrollArea.fixture.CustomWidget();

        this.__outer.add(this.__widget);

        this.getRoot().add(this.__outer);
        qx.test.ui.core.AbstractScrollArea.prototype.setUp.base.call(this);
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();
        qx.Class.undefine("qx.test.ui.core.AbstractScrollArea.fixture.CustomWidget");
        qx.test.ui.core.AbstractScrollArea.prototype.tearDown.base.call(this);
      },

      /**
       * @param expected {qx.ui.core.Widget|Bounds} 
       * @param actual {qx.ui.core.Widget} 
       */
      assertBounds: function assertBounds(expected, actual) {
        var expectedBounds, actualBounds;

        if (expected instanceof qx.ui.core.Widget) {
          expectedBounds = expected.getBounds();
        } else {
          expectedBounds = expected;
        }

        actualBounds = actual.getBounds();
        this.assertIdentical(expectedBounds.top, actualBounds.top);
        this.assertIdentical(expectedBounds.left, actualBounds.left);
        this.assertIdentical(expectedBounds.width, actualBounds.width);
        this.assertIdentical(expectedBounds.height, actualBounds.height);
      },
      "test default behaviour": function testDefaultBehaviour() {
        var inner = new qx.ui.core.Widget();

        this.__widget.setSingleChild(inner);

        this.flush();
        this.assertBounds(inner, this.__widget);
      },
      "test smaller widget than container": function testSmallerWidgetThanContainer() {
        var inner = new qx.ui.core.Widget();
        inner.set({
          minWidth: 80,
          minHeight: 80
        });

        this.__widget.setSingleChild(inner);

        this.flush();
        this.assertBounds(inner, this.__widget);
        this.assertFalse(this.__widget.hasScrollBar('x'));
        this.assertFalse(this.__widget.hasScrollBar('y'));
      },
      "test bigger widget than container": function testBiggerWidgetThanContainer() {
        var inner = new qx.ui.core.Widget();
        inner.set({
          minWidth: 120,
          minHeight: 120
        });

        this.__widget.setSingleChild(inner);

        this.flush();
        this.assertBounds({
          left: 0,
          top: 0,
          width: 100,
          height: 100
        }, this.__widget);
        this.assertBounds({
          left: 0,
          top: 0,
          width: 120,
          height: 120
        }, inner);
        this.assertTrue(this.__widget.hasScrollBar('x'));
        this.assertTrue(this.__widget.hasScrollBar('y'));
      },
      "test bigger preferred widget than container": function testBiggerPreferredWidgetThanContainer() {
        var inner = new qx.ui.core.Widget();
        inner.set({
          width: 120,
          height: 120
        });

        this.__widget.setSingleChild(inner);

        this.flush();
        this.assertBounds({
          left: 0,
          top: 0,
          width: 100,
          height: 100
        }, this.__widget);
        this.assertBounds({
          left: 0,
          top: 0,
          width: 100,
          height: 100
        }, inner);
        this.assertFalse(this.__widget.hasScrollBar('x'));
        this.assertFalse(this.__widget.hasScrollBar('y'));
      },
      "test bigger widget than smaller preferred container": function testBiggerWidgetThanSmallerPreferredContainer() {
        var inner = new qx.ui.core.Widget();
        inner.set({
          minWidth: 120,
          minHeight: 120
        });

        this.__widget.setSingleChild(inner);

        this.__outer.set({
          width: 100,
          height: 100
        });

        this.__outer.resetMaxWidth();

        this.__outer.resetMaxHeight();

        this.flush();
        this.assertBounds({
          left: 0,
          top: 0,
          width: 100,
          height: 100
        }, this.__widget);
        this.assertBounds({
          left: 0,
          top: 0,
          width: 120,
          height: 120
        }, inner);
        this.assertTrue(this.__widget.hasScrollBar('x'));
        this.assertTrue(this.__widget.hasScrollBar('y'));
      }
    }
  });
  qx.test.ui.core.AbstractScrollArea.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.theme.manager.Appearance": {},
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Grow": {
        "construct": true
      },
      "qx.ui.form.TextField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.ui.core.Theme, qx.test.ui.core.Test)
   */
  qx.Class.define("qx.test.ui.core.Appearance", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __oldAppearance: null,
      setUp: function setUp() {
        this.__oldAppearance = qx.theme.manager.Appearance.getInstance().getTheme();
        qx.theme.manager.Appearance.getInstance().setTheme(qx.test.ui.core.Theme);
      },
      tearDown: function tearDown() {
        qx.test.ui.core.Appearance.prototype.tearDown.base.call(this);
        qx.theme.manager.Appearance.getInstance().setTheme(this.__oldAppearance);
      },
      testDefault: function testDefault() {
        var a = new qx.test.ui.core.Test();
        a.setAppearance("test");
        this.getRoot().add(a);
        a.getChildControl("text");
        this.flush();
        this.assertEquals("red", a.getBackgroundColor());
        this.assertEquals("blue", a.getChildControl("text").getBackgroundColor());
        a.destroy();
      },
      testFallback: function testFallback() {
        var a = new qx.test.ui.core.Test();
        a.setAppearance("test2");
        this.getRoot().add(a);
        a.getChildControl("text");
        this.flush();
        this.assertEquals("yellow", a.getBackgroundColor());
        this.assertEquals("green", a.getChildControl("text").getBackgroundColor());
        a.destroy();
      },
      testChange: function testChange() {
        var a = new qx.test.ui.core.Test();
        a.setAppearance("test2");
        this.getRoot().add(a);
        a.getChildControl("text");
        this.flush();
        this.assertEquals("yellow", a.getBackgroundColor());
        this.assertEquals("green", a.getChildControl("text").getBackgroundColor());
        a.setAppearance("test");
        this.flush();
        this.assertEquals("red", a.getBackgroundColor());
        this.assertEquals("blue", a.getChildControl("text").getBackgroundColor());
        a.destroy();
      },
      testReuseNotDefined: function testReuseNotDefined() {
        var a = new qx.test.ui.core.Test();
        a.setAppearance("test");
        this.getRoot().add(a);
        a.getChildControl("text");
        a.getChildControl("text2").setAppearance("nix");
        this.flush();
        this.assertEquals("red", a.getBackgroundColor());
        this.assertEquals("blue", a.getChildControl("text").getBackgroundColor());
        a.setAppearance("test2");
        this.flush();
        this.assertEquals("yellow", a.getBackgroundColor());
        this.assertEquals("black", a.getChildControl("text2").getBackgroundColor()); // check for the textfield fallback

        this.assertEquals("green", a.getChildControl("text").getBackgroundColor());
        a.destroy();
      }
    }
  });
  qx.Theme.define("qx.test.ui.core.Theme", {
    appearances: {
      "test": {
        style: function style(states) {
          return {
            backgroundColor: "red"
          };
        }
      },
      "test/text": {
        style: function style(states) {
          return {
            backgroundColor: "blue"
          };
        }
      },
      "textfield": {
        style: function style(states) {
          return {
            backgroundColor: "green"
          };
        }
      },
      "test2": {
        style: function style(states) {
          return {
            backgroundColor: "yellow"
          };
        }
      },
      "test2/text2": {
        style: function style(states) {
          return {
            backgroundColor: "black"
          };
        }
      }
    }
  });
  qx.Class.define("qx.test.ui.core.Test", {
    extend: qx.ui.core.Widget,
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this);

      this._setLayout(new qx.ui.layout.Grow());
    },
    members: {
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        if (id == "text" || id == "text2") {
          var control = new qx.ui.form.TextField("affe");

          this._add(control);

          return control;
        }

        return qx.test.ui.core.Test.prototype._createChildControlImpl.base.call(this, id);
      }
    }
  });
  qx.test.ui.core.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.core.Blocker": {},
      "qx.event.Registration": {},
      "qx.event.handler.Focus": {},
      "qx.ui.form.TextField": {},
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.core.Blocker", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __blocker: null,
      setUp: function setUp() {
        qx.test.ui.core.Blocker.prototype.setUp.base.call(this);
        this.__blocker = new qx.ui.core.Blocker(this.getRoot());

        this.__blocker.setColor("green");

        this.__blocker.setOpacity(0.5);
      },
      tearDown: function tearDown() {
        qx.test.ui.core.Blocker.prototype.tearDown.base.call(this);

        this.__blocker.dispose();
      },
      testBlocker: function testBlocker() {
        var blockerElement = this.__blocker.getBlockerElement();

        this.__blocker.block();

        this.flush();
        this.assertTrue(this.__blocker.isBlocked(), "isBlocked()");
        this.assertTrue(blockerElement.isIncluded(), "isIncluded()");

        this.__blocker.unblock();

        this.flush();
        this.assertFalse(this.__blocker.isBlocked(), "isBlocked()");
        this.assertFalse(blockerElement.isIncluded(), "isIncluded()");
      },
      testBlockerThrice: function testBlockerThrice() {
        var blockerElement = this.__blocker.getBlockerElement();

        this.__blocker.block();

        this.flush();
        this.assertTrue(this.__blocker.isBlocked(), "isBlocked()");
        this.assertTrue(blockerElement.isIncluded(), "isIncluded()");

        this.__blocker.block();

        this.flush();
        this.assertTrue(this.__blocker.isBlocked(), "isBlocked()");
        this.assertTrue(blockerElement.isIncluded(), "isIncluded()");

        this.__blocker.block();

        this.flush();
        this.assertTrue(this.__blocker.isBlocked(), "isBlocked()");
        this.assertTrue(blockerElement.isIncluded(), "isIncluded()");

        this.__blocker.unblock();

        this.flush();
        this.assertTrue(this.__blocker.isBlocked(), "isBlocked()");
        this.assertTrue(blockerElement.isIncluded(), "isIncluded()");

        this.__blocker.unblock();

        this.flush();
        this.assertTrue(this.__blocker.isBlocked(), "isBlocked()");
        this.assertTrue(blockerElement.isIncluded(), "isIncluded()");

        this.__blocker.unblock();

        this.flush();
        this.assertFalse(this.__blocker.isBlocked(), "isBlocked()");
        this.assertFalse(blockerElement.isIncluded(), "isIncluded()");
      },
      testForceUnblock: function testForceUnblock() {
        var blockerElement = this.__blocker.getBlockerElement();

        this.__blocker.block();

        this.flush();
        this.assertTrue(this.__blocker.isBlocked(), "isBlocked()");
        this.assertTrue(blockerElement.isIncluded(), "isIncluded()");

        this.__blocker.block();

        this.flush();
        this.assertTrue(this.__blocker.isBlocked(), "isBlocked()");
        this.assertTrue(blockerElement.isIncluded(), "isIncluded()");

        this.__blocker.forceUnblock();

        this.flush();
        this.assertFalse(this.__blocker.isBlocked(), "isBlocked()");
        this.assertFalse(blockerElement.isIncluded(), "isIncluded()");
      },
      testBlockedEvent: function testBlockedEvent() {
        this.__blockedEventFired = false;
        this.__unblockedEventFired = false;

        this.__blocker.addListenerOnce("blocked", function (e) {
          this.__blockedEventFired = true;
        }, this);

        this.__blocker.addListenerOnce("unblocked", function (e) {
          this.__unblockedEventFired = true;
        }, this);

        this.__blocker.block();

        this.__blocker.unblock();

        this.wait(100, function () {
          this.assertTrue(this.__blockedEventFired, "'blocked' event was not fired, after block() was executed!");
          this.assertTrue(this.__unblockedEventFired, "'unblocked' event was not fired, after unblock() was executed!");
        }, this);
      },
      testRestoreActiveAndFocusedWidgets: function testRestoreActiveAndFocusedWidgets() {
        var activeWidget, focusedWidget;
        var focusHandler = qx.event.Registration.getManager(window).getHandler(qx.event.handler.Focus);
        var txt2 = new qx.ui.form.TextField();
        this.getRoot().add(txt2, {
          left: 100,
          top: 0
        });
        txt2.focus();
        var txt1 = new qx.ui.form.TextField();
        this.getRoot().add(txt1); // set active widget after focusing a widget, because focus() sets the same widget as active one.

        txt1.activate();
        this.flush();

        var blockerElement = this.__blocker.getBlockerElement();

        this.__blocker.block();

        this.flush();
        this.assertTrue(this.__blocker.isBlocked(), "isBlocked()");
        this.assertTrue(blockerElement.isIncluded(), "isIncluded()");
        activeWidget = qx.ui.core.Widget.getWidgetByElement(focusHandler.getActive());
        this.assertFalse(activeWidget === txt1, "text field 1 must not be active");
        focusedWidget = qx.ui.core.Widget.getWidgetByElement(focusHandler.getFocus());
        this.assertFalse(focusedWidget === txt2, "text field 2 must not be focused");

        this.__blocker.unblock();

        this.flush();
        this.assertFalse(this.__blocker.isBlocked(), "isBlocked()");
        this.assertFalse(blockerElement.isIncluded(), "isIncluded()");
        activeWidget = qx.ui.core.Widget.getWidgetByElement(focusHandler.getActive());
        this.assertTrue(activeWidget === txt1, "text field 1 must be active");
        focusedWidget = qx.ui.core.Widget.getWidgetByElement(focusHandler.getFocus());
        this.assertTrue(focusedWidget === txt2, "text field 2 must be focused"); // clear

        txt1.destroy();
        txt2.destroy();
        this.flush();
      },
      testRestoreDisposedWidget: function testRestoreDisposedWidget() {
        var widget;
        var focusHandler = qx.event.Registration.getManager(window).getHandler(qx.event.handler.Focus);
        var txt = new qx.ui.form.TextField();
        this.getRoot().add(txt);
        txt.focus();
        this.flush();

        var blockerElement = this.__blocker.getBlockerElement();

        this.__blocker.block();

        this.flush();
        this.assertTrue(this.__blocker.isBlocked(), "isBlocked()");
        this.assertTrue(blockerElement.isIncluded(), "isIncluded()"); // destroy text field

        txt.destroy();
        this.flush();

        this.__blocker.unblock();

        this.flush();
        this.assertFalse(this.__blocker.isBlocked(), "isBlocked()");
        this.assertFalse(blockerElement.isIncluded(), "isIncluded()"); // text field must not be focused

        widget = qx.ui.core.Widget.getWidgetByElement(focusHandler.getFocus());
        this.assertFalse(widget === txt, "text field must be focused, because it is destroyed");
        txt.destroy();
        this.flush();
      }
    }
  });
  qx.test.ui.core.Blocker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.core.MDragDropScrolling": {
        "require": true
      },
      "qx.ui.form.List": {},
      "qx.ui.form.ListItem": {},
      "qx.ui.core.DragDropScrolling": {},
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.core.DragDropScrolling", {
    extend: qx.test.ui.LayoutTestCase,
    // the mixin under test:
    include: qx.ui.core.MDragDropScrolling,
    members: {
      list: null,
      setUp: function setUp() {
        this.list = this._createDummyList();
        this.getRoot().add(this.list, {
          left: 150
        }); // render the widgets

        this.flush();
      },
      tearDown: function tearDown() {
        this.list.destroy();
      },
      _createDummyList: function _createDummyList() {
        var list = new qx.ui.form.List();

        for (var i = 0; i < 20; i++) {
          list.add(new qx.ui.form.ListItem("Item " + i));
        }

        return list;
      },
      testFindScrollableParent: function testFindScrollableParent() {
        var li = this.list.findItem("Item 7");
        this.assertNotNull(this._findScrollableParent(li));
      },
      testIsScrollable: function testIsScrollable() {
        this.assertTrue(this._isScrollable(this.list));
        this.assertFalse(this._isScrollable(this));
      },
      testGetBounds: function testGetBounds() {
        var bounds = this._getBounds(this.list);

        this.assertKeyInMap("top", bounds);
        this.assertKeyInMap("right", bounds);
        this.assertKeyInMap("bottom", bounds);
        this.assertKeyInMap("left", bounds);
      },
      testGetEdgeType: function testGetEdgeType() {
        var diff = {};
        diff = {
          "left": -20,
          "right": 0,
          "bottom": 0,
          "top": 0
        };
        this.assertEquals("left", this._getEdgeType(diff, 20, 30));
        diff = {
          "left": 0,
          "right": 20,
          "bottom": 0,
          "top": 0
        };
        this.assertEquals("right", this._getEdgeType(diff, 20, 30));
        diff = {
          "left": 0,
          "right": 0,
          "bottom": 0,
          "top": -30
        };
        this.assertEquals("top", this._getEdgeType(diff, 20, 30));
        diff = {
          "left": 0,
          "right": 0,
          "bottom": 30,
          "top": 0
        };
        this.assertEquals("bottom", this._getEdgeType(diff, 20, 30));
      },
      testGetAxis: function testGetAxis() {
        this.assertEquals("x", this._getAxis("left"));
        this.assertEquals("x", this._getAxis("right"));
        this.assertEquals("y", this._getAxis("top"));
        this.assertEquals("y", this._getAxis("bottom"));
        this.assertException(function () {
          this._getAxis("notLeftRightTopOrBottom");
        }, Error);
      },
      testGetThresholdByEdgeType: function testGetThresholdByEdgeType() {
        this.setDragScrollThresholdX(15);
        this.assertEquals(15, this._getThresholdByEdgeType("left"));
        this.assertEquals(15, this._getThresholdByEdgeType("right"));
        this.setDragScrollThresholdY(25);
        this.assertEquals(25, this._getThresholdByEdgeType("top"));
        this.assertEquals(25, this._getThresholdByEdgeType("bottom"));
      },
      testIsScrollbarVisible: function testIsScrollbarVisible() {
        this.assertTrue(this._isScrollbarVisible(this.list, "y"));
        this.assertFalse(this._isScrollbarVisible(this.list, "x"));
      },
      testIsScrollbarExceedingMaxPos: function testIsScrollbarExceedingMaxPos() {
        var scrollbar = this.list.getChildControl("scrollbar-y", true);
        this.assertFalse(this._isScrollbarExceedingMaxPos(scrollbar, "y", 30));
      },
      testCalculateThresholdExeedance: function testCalculateThresholdExeedance() {
        this.assertEquals(10, this._calculateThresholdExceedance(10, 20));
        this.assertEquals(-10, this._calculateThresholdExceedance(-10, 20));
      },
      testCalculateScrollAmount: function testCalculateScrollAmount() {
        this.assertEquals(10, this._calculateScrollAmount(500, 20));
        this.assertEquals(-10, this._calculateScrollAmount(-500, 20));
      },
      testScrollBy: function testScrollBy() {
        var scrollbar = this.list.getChildControl("scrollbar-y", true),
            initPos = scrollbar.getPosition(),
            exceedanceAmount = 20,
            amount = this._calculateScrollAmount(scrollbar.getBounds().height, exceedanceAmount);

        this._scrollBy(this.list, "y", exceedanceAmount);

        this.assertEquals(Math.ceil(initPos + amount), scrollbar.getPosition());
      },
      testRootWidget: function testRootWidget() {
        var behavior; // application root

        behavior = new qx.ui.core.DragDropScrolling();
        this.assertTrue(behavior._getWidget() === this.getRoot(), "Root widget must be application root!");
        behavior.dispose(); // explicit widget

        var widget = new qx.ui.core.Widget();
        behavior = new qx.ui.core.DragDropScrolling(widget);
        this.assertTrue(behavior._getWidget() === widget, "Wrong root widget!");
        behavior.dispose();
        widget.dispose();
      },
      testListenerTargets: function testListenerTargets() {
        var behavior; // application root

        behavior = new qx.ui.core.DragDropScrolling();
        this.assertTrue(behavior._getWidget().hasListener("drag"), "'drag' event listener not found !");
        this.assertTrue(behavior._getWidget().hasListener("dragend"), "'dragend' event listener not found !");
        behavior.dispose(); // explicit widget

        var widget = new qx.ui.core.Widget();
        behavior = new qx.ui.core.DragDropScrolling(widget);
        this.assertTrue(widget.hasListener("drag"), "'drag' event listener not found !");
        this.assertTrue(widget.hasListener("dragend"), "'dragend' event listener not found !");
        behavior.dispose();
        widget.dispose(); // list widget

        this.assertTrue(this.list.hasListener("drag"), "'drag' event listener not found !");
        this.assertTrue(this.list.hasListener("dragend"), "'dragend' event listener not found !");
      }
    }
  });
  qx.test.ui.core.DragDropScrolling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.ui.core.MPlacement": {},
      "qx.ui.popup.Popup": {},
      "qx.ui.menu.Menu": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.core.Placement", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __nogo: null,
      setUp: function setUp() {
        this.__nogo = new qx.ui.core.Widget().set({
          backgroundColor: "red",
          width: 100,
          height: 300
        });
        this.getRoot().add(this.__nogo, {
          left: 150
        }); // set the always visible element

        qx.ui.core.MPlacement.setVisibleElement(this.__nogo);
      },
      tearDown: function tearDown() {
        qx.test.ui.core.Placement.prototype.tearDown.base.call(this);
        qx.ui.core.MPlacement.setVisibleElement(null);

        this.__nogo.destroy();
      },
      __testAlwaysVisibleElement: function __testAlwaysVisibleElement(w) {
        // force an addition to the dom!
        w.show();
        w.hide(); // modify the placed widget

        w.setWidth(100);
        w.setVisibility("visible"); // render the widgets

        this.flush(); // move and flush

        w.moveTo(100, 0);
        this.flush(); // the right position of the widget should be left of the nogo

        var bounds = w.getBounds();
        var right = bounds.left + bounds.width;
        this.assertEquals(150, right);
        this.assertEquals(50, bounds.left);
      },
      testVisibleWithPopoup: function testVisibleWithPopoup() {
        var w = new qx.ui.popup.Popup();

        this.__testAlwaysVisibleElement(w);

        w.destroy();
      },
      testVisibleWithMenu: function testVisibleWithMenu() {
        var w = new qx.ui.menu.Menu();

        this.__testAlwaysVisibleElement(w);

        w.destroy();
      },
      __testAlwaysVisibleElementTooBig: function __testAlwaysVisibleElementTooBig(w) {
        // force an addition to the dom!
        w.show();
        w.hide(); // modify the placed widget

        w.setWidth(200);
        w.setVisibility("visible"); // render the widgets

        this.flush(); // move and flush

        w.moveTo(100, 0);
        this.flush(); // The widget should be moved to the left border of the screen and still
        // overlap the visible item

        var bounds = w.getBounds();
        var right = bounds.left + bounds.width;
        this.assertEquals(200, right);
        this.assertEquals(0, bounds.left);
      },
      testVisibleWithPopoupTooBig: function testVisibleWithPopoupTooBig() {
        var w = new qx.ui.popup.Popup();

        this.__testAlwaysVisibleElementTooBig(w);

        w.destroy();
      },
      testVisibleWithMenuTooBig: function testVisibleWithMenuTooBig() {
        var w = new qx.ui.menu.Menu();

        this.__testAlwaysVisibleElementTooBig(w);

        w.destroy();
      },
      __testAlwaysVisibleElementAbove: function __testAlwaysVisibleElementAbove(w) {
        // force an addition to the dom!
        w.show();
        w.hide();

        this.__nogo.setLayoutProperties({
          top: 100
        }); // modify the placed widget


        w.setWidth(100);
        w.setVisibility("visible"); // render the widgets

        this.flush(); // move and flush

        w.moveTo(100, 0);
        this.flush(); // Positions should be as set

        var bounds = w.getBounds();
        var right = bounds.left + bounds.width;
        this.assertEquals(200, right);
        this.assertEquals(100, bounds.left);
      },
      testVisibleWithPopoupAbove: function testVisibleWithPopoupAbove() {
        var w = new qx.ui.popup.Popup();

        this.__testAlwaysVisibleElementAbove(w);

        w.destroy();
      },
      testVisibleWithMenuAbove: function testVisibleWithMenuAbove() {
        var w = new qx.ui.menu.Menu();

        this.__testAlwaysVisibleElementAbove(w);

        w.destroy();
      },
      __testAlwaysVisibleElementBelow: function __testAlwaysVisibleElementBelow(w) {
        // force an addition to the dom!
        w.show();
        w.hide(); // modify the placed widget

        w.setWidth(100);
        w.setVisibility("visible"); // render the widgets

        this.flush(); // move and flush

        w.moveTo(100, 400);
        this.flush(); // Positions should be as set

        var bounds = w.getBounds();
        var right = bounds.left + bounds.width;
        this.assertEquals(200, right);
        this.assertEquals(100, bounds.left);
      },
      testVisibleWithPopoupBelow: function testVisibleWithPopoupBelow() {
        var w = new qx.ui.popup.Popup();

        this.__testAlwaysVisibleElementBelow(w);

        w.destroy();
      },
      testVisibleWithMenuBelow: function testVisibleWithMenuBelow() {
        var w = new qx.ui.menu.Menu();

        this.__testAlwaysVisibleElementBelow(w);

        w.destroy();
      }
    }
  });
  qx.test.ui.core.Placement.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.ui.core.queue.Manager": {},
      "qx.ui.core.Widget": {},
      "qx.ui.core.queue.Widget": {},
      "qx.ui.core.queue.Appearance": {},
      "qx.ui.core.queue.Visibility": {},
      "qx.ui.core.queue.Dispose": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.core.Queues", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      __widget1: null,
      __widget2: null,
      __widget3: null,
      __widget4: null,
      setUp: function setUp() {
        // ensure an empty dispose queue before starting the test
        qx.ui.core.queue.Manager.flush();
        this.__widget1 = new qx.ui.core.Widget();
        this.__widget1.$$hash = 10e5;
        this.__widget2 = new qx.ui.core.Widget();
        this.__widget2.$$hash = 1000001;
        this.__widget3 = new qx.ui.core.Widget();
        this.__widget3.$$hash = 1000002;
        this.__widget4 = new qx.ui.core.Widget();
        this.__widget4.$$hash = 1000003;
      },
      tearDown: function tearDown() {
        // dispose the widgets
        this.__widget1.dispose();

        this.__widget2.dispose();

        this.__widget3.dispose();

        this.__widget4.dispose();
      },
      testWidgetOrder: function testWidgetOrder() {
        qx.ui.core.queue.Widget.add(this.__widget4);
        qx.ui.core.queue.Widget.add(this.__widget3);
        qx.ui.core.queue.Widget.add(this.__widget2);
        qx.ui.core.queue.Widget.add(this.__widget1);
        var spy1 = this.spy(this.__widget1, "syncWidget");
        var spy2 = this.spy(this.__widget2, "syncWidget");
        var spy3 = this.spy(this.__widget3, "syncWidget");
        var spy4 = this.spy(this.__widget4, "syncWidget");
        qx.ui.core.queue.Widget.flush();
        this.assertCalledOnce(spy1);
        this.assertCalledOnce(spy2);
        this.assertCalledOnce(spy3);
        this.assertCalledOnce(spy4);
        this.assertCallOrder(spy4, spy3, spy2, spy1);
      },
      testAppearanceOrder: function testAppearanceOrder() {
        qx.ui.core.queue.Appearance.add(this.__widget4);
        qx.ui.core.queue.Appearance.add(this.__widget3);
        qx.ui.core.queue.Appearance.add(this.__widget2);
        qx.ui.core.queue.Appearance.add(this.__widget1);
        var spy1 = this.spy(this.__widget1, "syncAppearance");
        var spy2 = this.spy(this.__widget2, "syncAppearance");
        var spy3 = this.spy(this.__widget3, "syncAppearance");
        var spy4 = this.spy(this.__widget4, "syncAppearance");
        var stub = this.stub(qx.ui.core.queue.Visibility, "isVisible").returns(true);
        qx.ui.core.queue.Appearance.flush();
        stub.restore();
        this.assertCalledOnce(spy1);
        this.assertCalledOnce(spy2);
        this.assertCalledOnce(spy3);
        this.assertCalledOnce(spy4);
        this.assertCallOrder(spy4, spy3, spy2, spy1);
      },
      testDisposeOrder: function testDisposeOrder() {
        qx.ui.core.queue.Dispose.add(this.__widget4);
        qx.ui.core.queue.Dispose.add(this.__widget3);
        qx.ui.core.queue.Dispose.add(this.__widget2);
        qx.ui.core.queue.Dispose.add(this.__widget1);
        var spy1 = this.spy(this.__widget1, "dispose");
        var spy2 = this.spy(this.__widget2, "dispose");
        var spy3 = this.spy(this.__widget3, "dispose");
        var spy4 = this.spy(this.__widget4, "dispose");
        qx.ui.core.queue.Dispose.flush();
        this.assertCalledOnce(spy1);
        this.assertCalledOnce(spy2);
        this.assertCalledOnce(spy3);
        this.assertCalledOnce(spy4);
        this.assertCallOrder(spy4, spy3, spy2, spy1);
      },
      testVisibilityOrder: function testVisibilityOrder() {
        qx.ui.core.queue.Visibility.add(this.__widget4);
        qx.ui.core.queue.Visibility.add(this.__widget3);
        qx.ui.core.queue.Visibility.add(this.__widget2);
        qx.ui.core.queue.Visibility.add(this.__widget1);
        var spy1 = this.spy(this.__widget1, "isRootWidget");
        var spy2 = this.spy(this.__widget2, "isRootWidget");
        var spy3 = this.spy(this.__widget3, "isRootWidget");
        var spy4 = this.spy(this.__widget4, "isRootWidget");
        qx.ui.core.queue.Visibility.flush();
        this.assertCalledOnce(spy1);
        this.assertCalledOnce(spy2);
        this.assertCalledOnce(spy3);
        this.assertCalledOnce(spy4);
        this.assertCallOrder(spy4, spy3, spy2, spy1);
      },
      testWidgetAddJobs: function testWidgetAddJobs() {
        qx.ui.core.queue.Widget.add(this.__widget4, "job4");
        qx.ui.core.queue.Widget.add(this.__widget3, "job3");
        qx.ui.core.queue.Widget.add(this.__widget2);
        qx.ui.core.queue.Widget.add(this.__widget1, "job1");
        qx.ui.core.queue.Widget.add(this.__widget1, "job1");
        qx.ui.core.queue.Widget.add(this.__widget1, "job3");
        qx.ui.core.queue.Widget.add(this.__widget1, "job2");
        var spy1 = this.spy(this.__widget1, "syncWidget");
        var spy2 = this.spy(this.__widget2, "syncWidget");
        var spy3 = this.spy(this.__widget3, "syncWidget");
        var spy4 = this.spy(this.__widget4, "syncWidget");
        qx.ui.core.queue.Widget.flush();
        this.assertCalledOnce(spy1, "widgte1");
        this.assertCalledOnce(spy2, "widget2");
        this.assertCalledOnce(spy3, "widget3");
        this.assertCalledOnce(spy4, "widget4");
        this.assertCallOrder(spy4, spy3, spy2, spy1);
        this.assertTrue(spy1.args[0][0].job1);
        this.assertTrue(spy1.args[0][0].job2);
        this.assertTrue(spy1.args[0][0].job3);
        this.assertTrue(spy2.args[0][0]["$$default"]);
        this.assertTrue(spy3.args[0][0].job3);
        this.assertTrue(spy4.args[0][0].job4);
      },
      testWidgetRemoveJobs: function testWidgetRemoveJobs() {
        qx.ui.core.queue.Widget.add(this.__widget2);
        qx.ui.core.queue.Widget.add(this.__widget1, "job1");
        qx.ui.core.queue.Widget.add(this.__widget1, "job1");
        qx.ui.core.queue.Widget.add(this.__widget1, "job3");
        qx.ui.core.queue.Widget.add(this.__widget1, "job2");
        qx.ui.core.queue.Widget.remove(this.__widget1, "job1");
        var spy1 = this.spy(this.__widget1, "syncWidget");
        var spy2 = this.spy(this.__widget2, "syncWidget");
        qx.ui.core.queue.Widget.flush();
        this.assertCalledOnce(spy1, "widgte1");
        this.assertCalledOnce(spy2, "widget2");
        this.assertTrue(spy1.args[0][0].job2);
        this.assertTrue(spy1.args[0][0].job3);
        this.assertUndefined(spy1.args[0][0].job1);
        this.assertTrue(spy2.args[0][0]["$$default"]);
      }
    }
  });
  qx.test.ui.core.Queues.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.core.AssertionError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.core.SizeHint", {
    extend: qx.dev.unit.TestCase,
    type: "abstract",
    members: {
      setUp: function setUp() {
        this.widget = new qx.ui.core.Widget();
      },
      tearDown: function tearDown() {
        this.widget.dispose();
      },
      getHint: function getHint() {
        this.widget.invalidateLayoutCache();
        return this.widget.getSizeHint();
      },
      assertHint: function assertHint(min, size, max) {
        throw new Error("abstract method call");
      },
      getDefaultSize: function getDefaultSize() {
        throw new Error("abstract method call");
      },
      setSize: function setSize(min, size, max) {
        throw new Error("abstract method call");
      },
      setStretching: function setStretching(shrink, grow) {
        throw new Error("abstract method call");
      },
      testDefaultSize: function testDefaultSize() {
        this.assertHint(0, this.getDefaultSize(), Infinity);
      },
      testSize: function testSize() {
        this.setStretching(true, true);
        this.setSize(null, 200, null);
        this.assertHint(0, 200, Infinity);
      },
      testMinLargerThanSize: function testMinLargerThanSize() {
        this.setStretching(true, true);
        this.setSize(200, 100, null);
        this.assertHint(200, 200, Infinity);
      },
      testMinSmallerThanSize: function testMinSmallerThanSize() {
        this.setStretching(true, true);
        this.setSize(50, 150, null);
        this.assertHint(50, 150, Infinity);
      },
      testMaxSmallerThanSize: function testMaxSmallerThanSize() {
        this.setStretching(true, true);
        this.setSize(null, 100, 10);
        this.assertHint(0, 10, 10);
      },
      testMaxLargerThanSize: function testMaxLargerThanSize() {
        this.setStretching(true, true);
        this.setSize(null, 100, 150);
        this.assertHint(0, 100, 150);
      },
      testNoGrow: function testNoGrow() {
        this.setStretching(true, false);
        this.setSize(null, 100, null);
        this.assertHint(0, 100, 100);
      },
      testNoShrink: function testNoShrink() {
        this.setStretching(false, true);
        this.setSize(null, 100, null);
        this.assertHint(100, 100, Infinity);
      },
      testNoStretch: function testNoStretch() {
        this.setStretching(false, false);
        this.setSize(null, 100, null);
        this.assertHint(100, 100, 100);
      },
      testNoGrowAndMaxLargerThanSize: function testNoGrowAndMaxLargerThanSize() {
        this.setStretching(true, false);
        this.setSize(null, 100, 150);
        this.assertHint(0, 100, 100);
      },
      testNoGrowAndMaxSmallerThanSize: function testNoGrowAndMaxSmallerThanSize() {
        this.setStretching(true, false);
        this.setSize(null, 100, 50);
        this.assertHint(0, 50, 50);
      },
      testNoGrowAndMinLargerThanSize: function testNoGrowAndMinLargerThanSize() {
        this.setStretching(true, false);
        this.setSize(150, 100, null);
        this.assertHint(150, 150, 150);
      },
      testNoShrinkAndMinLargerSize: function testNoShrinkAndMinLargerSize() {
        this.setStretching(false, true);
        this.setSize(150, 100, null);
        this.assertHint(150, 150, Infinity);
      },
      testNoShrinkAndMinSmallerSize: function testNoShrinkAndMinSmallerSize() {
        this.setStretching(false, true);
        this.setSize(50, 100, null);
        this.assertHint(100, 100, Infinity);
      },
      testNoShrinkAndMaxSmallerSize: function testNoShrinkAndMaxSmallerSize() {
        this.setStretching(false, true);
        this.setSize(null, 100, 50);
        this.assertHint(50, 50, 50);
      },
      testMinLargerThanMax: function testMinLargerThanMax() {
        this.setStretching(true, true);
        this.setSize(200, 100, 150);

        if (this.isDebugOn()) {
          var that = this;
          this.assertException(function () {
            that.getHint();
          }, qx.core.AssertionError);
        }
      },
      testMinAndMaxLargerThanSize: function testMinAndMaxLargerThanSize() {
        this.setStretching(true, true);
        this.setSize(150, 100, 200);
        this.assertHint(150, 150, 200);
      },
      testMinAndMaxSmallerThanSize: function testMinAndMaxSmallerThanSize() {
        this.setStretching(true, true);
        this.setSize(150, 300, 200);
        this.assertHint(150, 200, 200);
      }
    }
  });
  qx.test.ui.core.SizeHint.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.core.SizeHint": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.core.SizeHintX", {
    extend: qx.test.ui.core.SizeHint,
    members: {
      assertHint: function assertHint(min, size, max) {
        var hint = this.getHint();
        this.assertEquals(min, hint.minWidth, "min width");
        this.assertEquals(size, hint.width, "width");
        this.assertEquals(max, hint.maxWidth, "max width");
      },
      getDefaultSize: function getDefaultSize() {
        return 100;
      },
      setSize: function setSize(min, size, max) {
        this.widget.set({
          minWidth: min,
          width: size,
          maxWidth: max
        });
      },
      setStretching: function setStretching(allowShrink, allowGrow) {
        this.widget.setAllowStretchX(allowGrow, allowShrink);
      }
    }
  });
  qx.test.ui.core.SizeHintX.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.core.SizeHint": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.core.SizeHintY", {
    extend: qx.test.ui.core.SizeHint,
    members: {
      assertHint: function assertHint(min, size, max) {
        var hint = this.getHint();
        this.assertEquals(min, hint.minHeight, "min height");
        this.assertEquals(size, hint.height, "height");
        this.assertEquals(max, hint.maxHeight, "max height");
      },
      getDefaultSize: function getDefaultSize() {
        return 50;
      },
      setSize: function setSize(min, size, max) {
        this.widget.set({
          minHeight: min,
          height: size,
          maxHeight: max
        });
      },
      setStretching: function setStretching(allowShrink, allowGrow) {
        this.widget.setAllowStretchY(allowGrow, allowShrink);
      }
    }
  });
  qx.test.ui.core.SizeHintY.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.ui.core.Spacer": {},
      "qx.ui.core.queue.Dispose": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.container.Composite": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2016 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.core.Spacer", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      tearDown: function tearDown() {
        // Restore all stubs, spies and overridden host objects.
        this.getSandbox().restore();
      },
      testConstructor: function testConstructor() {
        var spacer = new qx.ui.core.Spacer();
        this.assertEquals(0, spacer.getWidth());
        this.assertEquals(0, spacer.getHeight()); // cleanup memory

        spacer.destroy();
      },
      testConstructorWithParams: function testConstructorWithParams() {
        var spacer = new qx.ui.core.Spacer(100, 200);
        this.assertEquals(100, spacer.getWidth());
        this.assertEquals(200, spacer.getHeight()); // cleanup memory

        spacer.destroy();
      },
      testDestroy: function testDestroy() {
        this.spy(qx.ui.core.queue.Dispose, "add");
        var spacer = new qx.ui.core.Spacer();
        spacer.destroy();
        this.assertCalledOnce(qx.ui.core.queue.Dispose.add);
        this.assertCalledWith(qx.ui.core.queue.Dispose.add, spacer);
      },
      testDestroyOnAlreadyDestroyed: function testDestroyOnAlreadyDestroyed() {
        var spacer = new qx.ui.core.Spacer(); // destroy it and flush the dispose queue

        spacer.destroy();
        qx.ui.core.queue.Dispose.flush(); // add spy now, otherwise the previous destroy call is counted

        this.spy(qx.ui.core.queue.Dispose, "add"); // now test it

        spacer.destroy();
        this.assertNotCalled(qx.ui.core.queue.Dispose.add);
      },
      testDestroyWithParent: function testDestroyWithParent() {
        var layout = new qx.ui.layout.HBox();
        var container = new qx.ui.container.Composite(layout);
        var spacer = new qx.ui.core.Spacer();
        container.add(spacer);
        this.spy(container, "_remove");
        spacer.destroy();
        this.assertCalledOnce(container._remove);
        this.assertCalledWith(container._remove, spacer); // cleanup memory

        container.destroy();
        layout.dispose();
      }
    }
  });
  qx.test.ui.core.Spacer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.ui.container.Composite": {},
      "qx.ui.layout.Canvas": {},
      "qx.ui.container.Scroll": {},
      "qx.ui.layout.VBox": {},
      "qx.event.Timer": {},
      "qx.core.AssertionError": {},
      "qx.bom.Font": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.ui.core.W)
   */
  qx.Class.define("qx.test.ui.core.Widget", {
    extend: qx.test.ui.LayoutTestCase,
    include: [qx.dev.unit.MMock, qx.dev.unit.MRequirements],
    members: {
      testIsTabable: function testIsTabable() {
        var widget = new qx.ui.core.Widget().set({
          focusable: true
        });
        this.assertFalse(widget.isTabable(), "Non rendered widgets are not tabable");
        this.getRoot().add(widget);
        this.flush();
        this.assertTrue(widget.isTabable(), "Rendered focusable widgets are tabable");
        widget.setFocusable(false);
        this.assertFalse(widget.isTabable(), "Non focusable widgets are not tabable");
        widget.destroy();
      },
      testIsSeeableDepth0AfterFlush: function testIsSeeableDepth0AfterFlush() {
        var w = new qx.ui.core.Widget();
        this.getRoot().add(w);
        this.flush();
        this.assertTrue(w.isSeeable());
        w.hide();
        this.flush();
        this.assertFalse(w.isSeeable());
        w.destroy();
      },
      testIsSeeableDepth1AfterFlush: function testIsSeeableDepth1AfterFlush() {
        var c = new qx.ui.container.Composite();
        var l = new qx.ui.layout.Canvas();
        c.setLayout(l);
        this.getRoot().add(c);
        var w = new qx.ui.core.Widget();
        c.add(w);
        this.flush();
        this.assertTrue(w.isSeeable());
        c.hide();
        this.flush();
        this.assertFalse(w.isSeeable());
        l.dispose();
        w.destroy();
        c.destroy();
      },
      testIsSeeableDepth2AfterFlush: function testIsSeeableDepth2AfterFlush() {
        var cc = new qx.ui.container.Composite();
        var ll = new qx.ui.layout.Canvas();
        cc.setLayout(ll);
        this.getRoot().add(cc);
        var c = new qx.ui.container.Composite();
        var l = new qx.ui.layout.Canvas();
        c.setLayout(l);
        cc.add(c);
        var w = new qx.ui.core.Widget();
        c.add(w);
        this.flush();
        this.assertTrue(w.isSeeable());
        cc.hide();
        this.flush();
        this.assertFalse(w.isSeeable());
        ll.dispose();
        cc.destroy();
        l.dispose();
        w.destroy();
        c.destroy();
      },
      testIsSeeableDepth0: function testIsSeeableDepth0() {
        var w = new qx.ui.core.Widget();
        this.getRoot().add(w);
        this.assertTrue(w.isSeeable());
        w.hide();
        this.assertFalse(w.isSeeable());
        w.destroy();
      },
      testIsSeeableDepth1: function testIsSeeableDepth1() {
        var c = new qx.ui.container.Composite();
        var l = new qx.ui.layout.Canvas();
        c.setLayout(l);
        this.getRoot().add(c);
        var w = new qx.ui.core.Widget();
        c.add(w);
        this.assertTrue(w.isSeeable());
        c.hide();
        this.assertFalse(w.isSeeable());
        l.dispose();
        w.destroy();
        c.destroy();
      },
      testIsSeeableDepth2: function testIsSeeableDepth2() {
        var cc = new qx.ui.container.Composite();
        var ll = new qx.ui.layout.Canvas();
        cc.setLayout(ll);
        this.getRoot().add(cc);
        var c = new qx.ui.container.Composite();
        var l = new qx.ui.layout.Canvas();
        c.setLayout(l);
        cc.add(c);
        var w = new qx.ui.core.Widget();
        c.add(w);
        this.assertTrue(w.isSeeable());
        cc.hide();
        this.assertFalse(w.isSeeable());
        ll.dispose();
        cc.destroy();
        l.dispose();
        w.destroy();
        c.destroy();
      },
      testIsSeeableDepth0AfterFlushExclude: function testIsSeeableDepth0AfterFlushExclude() {
        var w = new qx.ui.core.Widget();
        this.getRoot().add(w);
        this.flush();
        this.assertTrue(w.isSeeable());
        w.exclude();
        this.flush();
        this.assertFalse(w.isSeeable());
        w.destroy();
      },
      testIsSeeableNotInRoot: function testIsSeeableNotInRoot() {
        var w = new qx.ui.core.Widget();
        this.assertFalse(w.isSeeable());
        w.destroy();
      },
      testScrollChildIntoViewChangesScheduled: function testScrollChildIntoViewChangesScheduled() {
        var msg, scrollPane, scrollTopInitial, scrollTop;
        var scroll = new qx.ui.container.Scroll().set({
          width: 100,
          height: 100
        });
        this.getRoot().add(scroll);
        var outer = new qx.ui.container.Composite(new qx.ui.layout.VBox());
        scroll.add(outer);
        var inner1 = new qx.ui.core.Widget().set({
          height: 100,
          backgroundColor: "red"
        });
        outer.add(inner1);
        var inner2 = new qx.ui.core.Widget().set({
          height: 20,
          backgroundColor: "green"
        });
        outer.add(inner2);
        scrollPane = scroll._getChildren()[0]; // Scroll and flush

        scroll.scrollChildIntoView(inner2);
        this.flush();
        scrollTopInitial = scrollPane.getContentElement().getDomElement().scrollTop; // Scroll, do not flush

        inner1.setHeight(200);
        scroll.scrollChildIntoView(inner2);
        qx.event.Timer.once(function () {
          scrollTop = scrollPane.getContentElement().getDomElement().scrollTop;
        }, this, 250);
        this.wait(500, function () {
          msg = "Must scroll further down, but was: " + scrollTopInitial + " is: " + scrollTop;
          this.assert(scrollTop > scrollTopInitial, msg);
          scroll.destroy();
        }, this);
      },
      testLazyScrollChildIntoViewY: function testLazyScrollChildIntoViewY() {
        var scroll = new qx.ui.container.Scroll().set({
          width: 100,
          height: 100
        });
        this.getRoot().add(scroll);
        var outer = new qx.ui.container.Composite(new qx.ui.layout.VBox());
        scroll.add(outer);
        var inner1 = new qx.ui.core.Widget().set({
          height: 150,
          backgroundColor: "red"
        });
        outer.add(inner1);
        var inner2 = new qx.ui.core.Widget().set({
          height: 20,
          backgroundColor: "green"
        });
        outer.add(inner2);
        var scrollTop = null;
        var listener1 = scroll.addListener("disappear", function (ev) {
          var child = this.getChildren()[0].getChildren()[1];
          this.scrollChildIntoView(child);
          this.setVisibility("visible");
        });
        var listener2 = scroll.addListener("appear", function (ev) {
          var scrollPane = this._getChildren()[0];

          scrollTop = scrollPane.getContentElement().getDomElement().scrollTop;
        });
        qx.event.Timer.once(function () {
          scroll.setVisibility("hidden");
        }, this, 250);
        this.wait(1000, function () {
          this.assert(scrollTop > 0, "Child was not scrolled!");
          scroll.removeListenerById(listener1);
          scroll.removeListenerById(listener2);
          scroll.destroy();
        }, this);
      },
      testReleaseChildControl: function testReleaseChildControl() {
        qx.Class.define("qx.test.ui.core.W", {
          extend: qx.ui.core.Widget,
          members: {
            _createChildControlImpl: function _createChildControlImpl(id) {
              return new qx.ui.core.Widget();
            }
          }
        });
        var w = new qx.test.ui.core.W();
        var child = w.getChildControl("xyz");
        this.flush();
        this.assertEquals(w._getCreatedChildControls()["xyz"], child);

        w._releaseChildControl("xyz");

        this.assertUndefined(w._getCreatedChildControls()["xyz"]);
        child.dispose();
        w.dispose();
        qx.Class.undefine("qx.test.ui.core.W");
      },
      testChildGetSubcontrolId: function testChildGetSubcontrolId() {
        qx.Class.define("qx.test.ui.core.W", {
          extend: qx.ui.core.Widget,
          members: {
            _createChildControlImpl: function _createChildControlImpl(id, hash) {
              var control;

              switch (id) {
                case "xyz":
                  control = new qx.ui.core.Widget();
                  break;
              }

              return control || qx.test.ui.core.W.prototype._createChildControlImpl.base.call(this, id);
            }
          }
        });
        var w = new qx.test.ui.core.W();
        var child = w.getChildControl("xyz");
        this.flush();
        this.assertEquals("xyz", child.getSubcontrolId());
        this.assertNull(w.getSubcontrolId());
        child.dispose();
        w.dispose();
        qx.Class.undefine("qx.test.ui.core.W");
      },
      testCreateChildControlHash: function testCreateChildControlHash() {
        qx.Class.define("qx.test.ui.core.W", {
          extend: qx.ui.core.Widget,
          members: {
            _createChildControlImpl: function _createChildControlImpl(id, hash) {
              this.test = id + "-" + hash;
              return this;
            }
          }
        });
        var w = new qx.test.ui.core.W();
        w.getChildControl("affe#afffe");
        this.assertEquals("affe-afffe", w.test);
        w.getChildControl("affe#afffe#juhu");
        this.assertEquals("affe-afffe#juhu", w.test);
        w.dispose();
        qx.Class.undefine("qx.test.ui.core.W");
      },
      testComputeSizeHintMinWidthBiggerMax: function testComputeSizeHintMinWidthBiggerMax() {
        var w = new qx.ui.core.Widget();
        w.setMaxWidth(100);
        this.stub(w, "_getContentHint").returns({
          minWidth: 200
        });

        var hint = w._computeSizeHint();

        this.assertEquals(100, hint.minWidth);
        w.dispose();
      },
      testComputeSizeHintMinHeightBiggerMax: function testComputeSizeHintMinHeightBiggerMax() {
        var w = new qx.ui.core.Widget();
        w.setMaxHeight(100);
        this.stub(w, "_getContentHint").returns({
          minHeight: 200
        });

        var hint = w._computeSizeHint();

        this.assertEquals(100, hint.minHeight);
        w.dispose();
      },
      testComputeSizeHintMaxWidthSmallerMin: function testComputeSizeHintMaxWidthSmallerMin() {
        var w = new qx.ui.core.Widget();
        w.setMinWidth(200);
        this.stub(w, "_getContentHint").returns({
          maxWidth: 100
        });

        var hint = w._computeSizeHint();

        this.assertEquals(200, hint.maxWidth);
        w.dispose();
      },
      testComputeSizeHintMaxHeightSmallerMin: function testComputeSizeHintMaxHeightSmallerMin() {
        var w = new qx.ui.core.Widget();
        w.setMinHeight(200);
        this.stub(w, "_getContentHint").returns({
          maxHeight: 100
        });

        var hint = w._computeSizeHint();

        this.assertEquals(200, hint.maxHeight);
        w.dispose();
      },
      testAddUndefined: function testAddUndefined() {
        this.require(["qx.debug"]);

        var w = new qx.ui.core.Widget();
        this.assertException(function () {
          w._add(undefined);
        }, qx.core.AssertionError.constructor, /Expected value to be instanceof 'qx.ui.core.LayoutItem'/);
        w.dispose();
      },
      testAddNoWidget: function testAddNoWidget() {
        this.require(["qx.debug"]);

        var w = new qx.ui.core.Widget();
        this.assertException(function () {
          w._add(new qx.bom.Font());
        }, qx.core.AssertionError.constructor, /Expected value to be instanceof 'qx.ui.core.LayoutItem'/);
        w.dispose();
      },
      testAddWidget: function testAddWidget() {
        this.require(["qx.debug"]);

        var w = new qx.ui.core.Widget();

        w._add(new qx.ui.container.Composite());

        w.dispose();
      }
    }
  });
  qx.test.ui.core.Widget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.ui.decoration.Decorator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.decoration.LinearGradient", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.__w = new qx.ui.core.Widget();

        this.__w.setHeight(100);

        this.__dec = new qx.ui.decoration.Decorator();

        this.__dec.set({
          startColor: "red",
          endColor: "black"
        });

        this.getRoot().add(this.__w);
      },
      tearDown: function tearDown() {
        this.__w.destroy();

        this.__dec.dispose();
      },
      testDefault: function testDefault() {
        this.__dec.set({
          startColorPosition: 0,
          endColorPosition: 100
        });

        this.__w.setDecorator(this.__dec);

        this.flush();
      },
      testDefaultPx: function testDefaultPx() {
        this.__dec.set({
          startColorPosition: 0,
          endColorPosition: 200,
          colorPositionUnit: "px"
        });

        this.__w.setDecorator(this.__dec);

        this.flush();
      },
      testNegativeStart: function testNegativeStart() {
        this.__dec.set({
          startColorPosition: -100,
          endColorPosition: 100
        });

        this.__w.setDecorator(this.__dec);

        this.flush();
      },
      testBigEnd: function testBigEnd() {
        this.__dec.set({
          startColorPosition: 0,
          endColorPosition: 200
        });

        this.__w.setDecorator(this.__dec);

        this.flush();
      },
      testBigEndPx: function testBigEndPx() {
        this.__dec.set({
          startColorPosition: 0,
          endColorPosition: 200,
          colorPositionUnit: "px"
        });

        this.__w.setDecorator(this.__dec);

        this.flush();
      },
      testNegativeStartPx: function testNegativeStartPx() {
        this.__dec.set({
          startColorPosition: 0,
          endColorPosition: 200,
          colorPositionUnit: "px"
        });

        this.__w.setDecorator(this.__dec);

        this.flush();
      }
    }
  });
  qx.test.ui.decoration.LinearGradient.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.ui.embed.Flash": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.test.travis": {},
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/UnitTestFlash.swf)
   */
  qx.Class.define("qx.test.ui.embed.Flash", {
    extend: qx.test.ui.LayoutTestCase,
    include: [qx.dev.unit.MMock, qx.dev.unit.MRequirements],
    statics: {
      isFlashReady: false,
      flashCallback: function flashCallback() {
        qx.test.ui.embed.Flash.isFlashReady = true;
      }
    },
    members: {
      __flash: null,
      __params: null,
      __variables: null,
      setUp: function setUp() {
        this.require(["plugin.flash"]);

        this.flush();
        this.__params = {
          wmode: "opaque",
          quality: "best",
          allowScriptAccess: "sameDomain",
          swLiveConnect: "true",
          play: "true",
          loop: "true",
          menu: "true"
        };
        this.__variables = {
          init: "qx.test.ui.embed.Flash.flashCallback",
          flashVar1: "bli bla blub",
          flashVar2: "bulb alb ilb"
        };
        var flash = this.__flash = new qx.ui.embed.Flash("qx/test/UnitTestFlash.swf", "flashmovie");
        flash.setVariables(this.__variables);
        flash.setScale("noscale");
        flash.setPlay(true);
        flash.setLoop(true);
        flash.setMenu(true);
        this.getRoot().add(this.__flash, {
          edge: 10
        });
      },
      tearDown: function tearDown() {
        qx.test.ui.embed.Flash.isFlashReady = false;
        this.getRoot().removeAll();

        this.__flash.destroy();

        this.__flash = null;
      },
      testEvents: function testEvents() {
        // disable event tests for chrome on linux to have travis ci
        // succeed again
        // see https://github.com/qooxdoo/qooxdoo/issues/9167
        this.require(["noChromeOnLinux"]);

        var test = {
          loading: function loading() {},
          loaded: function loaded() {},
          timeout: function timeout() {}
        };
        var loading = this.spy(test, "loading");
        var loaded = this.spy(test, "loaded");
        var timeout = this.spy(test, "timeout");

        this.__flash.addListener("loading", test.loading);

        this.__flash.addListener("loaded", test.loaded);

        this.__flash.addListener("timeout", test.timeout);

        var that = this;
        this.wait(2000, function () {
          that.assertCalled(loading);
          that.assertCalled(loaded);
          that.assertNotCalled(timeout);
          loaded.calledAfter(loading);
        });
      },
      testLoadTimeout: function testLoadTimeout() {
        if (qx.core.Environment.get("qx.test.travis") == "true") {
          this.skip("Test disabled on travis");
        }

        var test = {
          loading: function loading() {},
          loaded: function loaded() {},
          timeout: function timeout() {}
        };
        var loading = this.spy(test, "loading");
        var loaded = this.spy(test, "loaded");
        var timeout = this.spy(test, "timeout");
        var flash = new qx.ui.embed.Flash("qx/test/invalidmovie.swf", "invalidmovie");
        flash.setLoadTimeout(1000);
        this.getRoot().removeAll();
        this.getRoot().add(flash, {
          edge: 10
        });
        flash.addListener("loading", test.loading);
        flash.addListener("loaded", test.loaded);
        flash.addListener("timeout", test.timeout);
        var that = this;
        this.wait(2000, function () {
          that.assertCalled(loading);
          that.assertNotCalled(loaded);
          that.assertCalled(timeout);
          timeout.calledAfter(loading);
        });
      },
      testCreateFlash: function testCreateFlash() {
        var that = this;
        this.wait(2000, function () {
          var flash = that.__flash.getFlashElement();

          that.assertNotNull(flash, "DOM element for Flash movie is not created!");
          that.assertIdentical("object", flash.nodeName.toLowerCase()); // general object attribute tests

          that.assertIdentical("100%", flash.width);
          that.assertIdentical("100%", flash.height);
          that.assertIdentical("flashmovie", flash.id); // object attribute tests for IE or other browser

          if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 11) {
            that.assertIdentical("clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", flash.classid);
          } else {
            var index = flash.data.lastIndexOf("qx/test/UnitTestFlash.swf");
            var substring = flash.data.substring(index, flash.data.length);
            that.assertIdentical("qx/test/UnitTestFlash.swf", substring);
            that.assertIdentical("application/x-shockwave-flash", flash.type);
          } // test params and flashvars


          var params = that.__params;
          params.flashvars = "init=qx.test.ui.embed.Flash.flashCallback&flashVar1=bli bla blub&flashVar2=bulb alb ilb";
          var children = flash.childNodes;

          for (var name in params) {
            var testSuccessful = false;

            for (var i = 0; i < children.length; i++) {
              that.assertIdentical("param", children[i].nodeName.toLowerCase());

              if (children[i].name === name) {
                testSuccessful = true;
                that.assertIdentical(params[name], children[i].value);
                break;
              }
            }

            that.assertTrue(testSuccessful, "Param element with name:'" + name + "' not found!");
          }
        });
      },
      testProperties: function testProperties() {
        var that = this;
        this.wait(5000, function () {
          that.assertException(function () {
            that.__flash.setSource("new.swf");
          }, Error, null, "Error expected by calling 'setSource'!");
          that.assertException(function () {
            that.__flash.setId("newId");
          }, Error, null, "Error expected by calling 'setId'!");
          that.assertException(function () {
            that.__flash.setQuality("low");
          }, Error, null, "Error expected by calling 'setQuality'!");
          that.assertException(function () {
            that.__flash.setScale("excactfit");
          }, Error, null, "Error expected by calling 'setScale'!");
          that.assertException(function () {
            that.__flash.setWmode("transparent");
          }, Error, null, "Error expected by calling 'setWmode'!");
          that.assertException(function () {
            that.__flash.setPlay(false);
          }, Error, null, "Error expected by calling 'setPlay'!");
          that.assertException(function () {
            that.__flash.setLoop(false);
          }, Error, null, "Error expected by calling 'setLoop'!");
          that.assertException(function () {
            that.__flash.setMenu(false);
          }, Error, null, "Error expected by calling 'setMenu'!");
          that.assertException(function () {
            that.__flash.setAllowScriptAccess("never");
          }, Error, null, "Error expected by calling 'setAllowScriptAccess'!");
          that.assertException(function () {
            that.__flash.setLiveConnect(false);
          }, Error, null, "Error expected by calling 'setLiveConnect'!");
          that.assertException(function () {
            that.__flash.setVariables({
              key: "value"
            });
          }, Error, null, "Error expected by calling 'setVariables'!");
        });
      },
      testExternalInterface: function testExternalInterface() {
        // skip this test because it only runs with a webserver
        if (location.protocol.indexOf("http") !== 0) {
          this.warn("Skipped test 'testExternalInterface', because a webserver is needed to run this test.");
          return;
        }

        var result = "";
        var that = this;
        this.wait(5000, function () {
          if (!qx.test.ui.embed.Flash.isFlashReady) {
            that.warn("ExternalInterface not ready -> skipped test");
            return;
          }

          var flash = that.__flash.getFlashElement();

          if (flash.echo) {
            result = flash.echo("hello echo!");
          }

          that.assertIdentical("hello echo!", result);
        });
      }
    }
  });
  qx.test.ui.embed.Flash.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      },
      "qx.html.Flash": {},
      "qx.util.TimerManager": {},
      "qx.util.ResourceManager": {},
      "qx.ui.core.queue.Layout": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The Flash widget embeds the HMTL Flash element
   */
  qx.Class.define("qx.ui.embed.Flash", {
    extend: qx.ui.core.Widget,

    /**
     * Constructs a flash widget.
     *
     * @param source {String} The URL of the Flash movie to display.
     * @param id {String?null} The unique id for the Flash movie.
     */
    construct: function construct(source, id) {
      qx.ui.core.Widget.constructor.call(this);
      {
        qx.core.Assert.assertString(source, "Invalid parameter 'source'.");

        if (id) {
          qx.core.Assert.assertString(id, "Invalid parameter 'id'.");
        }
      }
      this.setSource(source);

      if (id) {
        this.setId(id);
      } else {
        this.setId("flash" + this.toHashCode());
      } //init properties


      this.initQuality();
      this.initWmode();
      this.initAllowScriptAccess();
      this.initLiveConnect(); // Creates the Flash DOM element (movie) on appear,
      // because otherwise IE 7 and higher blocks the
      // ExternelInterface from Flash.

      this.addListenerOnce("appear", function () {
        this._checkLoading();

        this.getContentElement().createFlash();
      }, this);
    },
    events: {
      /**
       * Fired when the flash object still is loading.
       *
       * The loading action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "loading": "qx.event.type.Event",

      /**
       * Fired after the flash object has been loaded.
       *
       * The loaded action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "loaded": "qx.event.type.Event",

      /**
       * Fired after the flash object has got a timeout.
       *
       * The timeout action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "timeout": "qx.event.type.Event"
    },
    properties: {
      /**
       * The URL of the Flash movie.
       */
      source: {
        check: "String",
        apply: "_applySource"
      },

      /**
       * The unique Flash movie id.
       */
      id: {
        check: "String",
        apply: "_applyId"
      },

      /**
       * Set the quality attribute for the Flash movie.
       */
      quality: {
        check: ["low", "autolow", "autohigh", "medium", "high", "best"],
        init: "best",
        nullable: true,
        apply: "_applyQuality"
      },

      /**
       * Set the scale attribute for the Flash movie.
       */
      scale: {
        check: ["showall", "noborder", "exactfit", "noscale"],
        nullable: true,
        apply: "_applyScale"
      },

      /**
       * Set the wmode attribute for the Flash movie.
       */
      wmode: {
        check: ["window", "opaque", "transparent"],
        init: "opaque",
        nullable: true,
        apply: "_applyWmode"
      },

      /**
       * Set the play attribute for the Flash movie.
       */
      play: {
        check: "Boolean",
        nullable: true,
        apply: "_applyPlay"
      },

      /**
       * Set the loop attribute for the Flash movie.
       */
      loop: {
        check: "Boolean",
        nullable: true,
        apply: "_applyLoop"
      },

      /**
       * Set the mayscript attribute for the Flash movie.
       */
      mayScript: {
        check: "Boolean",
        nullable: false,
        apply: "_applyMayScript"
      },

      /**
       * Set the menu attribute for the Flash movie.
       */
      menu: {
        check: "Boolean",
        nullable: true,
        apply: "_applyMenu"
      },

      /**
       * Set allow script access
       **/
      allowScriptAccess: {
        check: ["sameDomain", "always", "never"],
        init: "sameDomain",
        nullable: true,
        apply: "_applyAllowScriptAccess"
      },

      /**
       * Enable/disable live connection
       **/
      liveConnect: {
        check: "Boolean",
        init: true,
        nullable: true,
        apply: "_applyLiveConnect"
      },

      /**
       * Set the 'FlashVars' to pass variables to the Flash movie.
       */
      variables: {
        init: {},
        check: "Map",
        apply: "_applyVariables"
      },

      /**
       * A timeout when trying to load the flash source.
       */
      loadTimeout: {
        check: "Integer",
        init: 10000
      }
    },
    members: {
      /** @type {Integer} The time stamp when the loading begins. */
      __time: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC WIDGET API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the DOM element of the Flash movie.
       *
       * Note: If you call the method before the widget is rendered, it will
       * always return <code>null</code>. Therefore call the method after
       * the {@link #appear} event is fired.
       *
       * @return {Element|null} The DOM element of the Flash movie.
       */
      getFlashElement: function getFlashElement() {
        var element = this.getContentElement();

        if (element) {
          return element.getFlashElement();
        } else {
          return null;
        }
      },

      /**
       * Checks if the movie is loaded.
       *
       * @return {Boolean} <code>true</code> When the movie is completely loaded,
       *   otherwise <code>false</code>.
       */
      isLoaded: function isLoaded() {
        return this.getPercentLoaded() === 100;
      },

      /**
       * Returns the current loaded state from the Flash movie.
       *
       * @return {Integer} The loaded percent value.
       */
      getPercentLoaded: function getPercentLoaded() {
        var flashFE = this.getFlashElement(); // First make sure the movie is defined and has received a non-zero object id.

        if (typeof flashFE != "undefined" && flashFE != null) {
          try {
            return flashFE.PercentLoaded();
          } catch (err) {
            // Not an accessible function yet.
            return 0;
          }
        } else {
          return 0;
        }
      },
      // overridden
      _createContentElement: function _createContentElement() {
        var el = new qx.html.Flash();
        el.connectWidget(this);
        return el;
      },

      /**
       * Checks the current loaded state and fires one of the defined events:
       * {@link #loading}, {@link #loaded} or {@link #timeout}.
       *
       * Note the {@link #timeout} event is fired when the check reached the
       * defined {@link #loadTimeout}.
       */
      _checkLoading: function _checkLoading() {
        var source = this.getSource();

        if (source != "" && source != null && source != "undefined") {
          if (!this.isLoaded()) {
            if (!this.__time) {
              this.__time = new Date().getTime();
            }

            var timeDiff = new Date().getTime() - this.__time;

            if (this.getLoadTimeout() > timeDiff) {
              var timer = qx.util.TimerManager.getInstance();
              timer.start(this._checkLoading, 0, this, null, 10);
              this.fireEvent("loading");
            } else {
              {
                this.debug("Timeout after: " + timeDiff);
              }
              this.fireEvent("timeout");
              this.__time = null;
            }
          } else {
            this.fireEvent("loaded");
            this.__time = null;
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
       APPLY METHODS
      ---------------------------------------------------------------------------
      */
      // property apply
      _applySource: function _applySource(value, old) {
        var source = qx.util.ResourceManager.getInstance().toUri(value);
        this.getContentElement().setSource(source);
        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyId: function _applyId(value, old) {
        this.getContentElement().setId(value);
        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyVariables: function _applyVariables(value, old) {
        this.getContentElement().setVariables(value);
        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyMayScript: function _applyMayScript(value, old) {
        this.getContentElement().setAttribute("mayscript", value ? "" : false);
        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyQuality: function _applyQuality(value, old) {
        this.__flashParamHelper("quality", value);
      },
      // property apply
      _applyScale: function _applyScale(value, old) {
        this.__flashParamHelper("scale", value);
      },
      // property apply
      _applyWmode: function _applyWmode(value, old) {
        this.__flashParamHelper("wmode", value);
      },
      // property apply
      _applyPlay: function _applyPlay(value, old) {
        this.__flashParamHelper("play", value);
      },
      // property apply
      _applyLoop: function _applyLoop(value, old) {
        this.__flashParamHelper("loop", value);
      },
      // property apply
      _applyMenu: function _applyMenu(value, old) {
        this.__flashParamHelper("menu", value);
      },
      // property apply
      _applyAllowScriptAccess: function _applyAllowScriptAccess(value, old) {
        this.__flashParamHelper("allowScriptAccess", value);
      },
      // property apply
      _applyLiveConnect: function _applyLiveConnect(value, old) {
        this.__flashParamHelper("swLiveConnect", value);
      },

      /*
      ---------------------------------------------------------------------------
       HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Set the attribute for the Flash DOM element.
       *
       * @param key {String} Flash Player attribute name.
       * @param value {String?null} The value for the attribute, <code>null</code>
       *    if the attribute should be removed from the DOM element.
       */
      __flashParamHelper: function __flashParamHelper(key, value) {
        this.getContentElement().setParam(key, value);
        qx.ui.core.queue.Layout.add(this);
      }
    }
  });
  qx.ui.embed.Flash.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.event.Idle": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Timer manipulation for handling multiple timed callbacks with the use of
   * only a single native timer object.
   *
   * Use of these timers is via the methods start() and stop().  Examples:
   * <pre class='javascript'>
   * var timer = qx.util.TimerManager.getInstance();
   *
   * // Start a 5-second recurrent timer.
   * // Note that the first expiration is after 3 seconds
   * // (last parameter is 3000) but each subsequent expiration is
   * // at 5 second intervals.
   * timer.start(function(userData, timerId)
   *             {
   *               this.debug("Recurrent 5-second timer: " + timerId);
   *             },
   *             5000,
   *             this,
   *             null,
   *             3000);
   *
   * // Start a 1-second one-shot timer
   * timer.start(function(userData, timerId)
   *             {
   *               this.debug("One-shot 1-second timer: " + timerId);
   *             },
   *             0,
   *             this,
   *             null,
   *             1000);
   *
   * // Start a 2-second recurrent timer that stops itself after
   * // three iterations
   * timer.start(function(userData, timerId)
   *             {
   *               this.debug("Recurrent 2-second timer with limit 3:" +
   *                          timerId);
   *               if (++userData.count == 3)
   *               {
   *                 this.debug("Stopping recurrent 2-second timer");
   *                 timer.stop(timerId);
   *               }
   *             },
   *             2000,
   *             this,
   *             { count : 0 });
   *
   * // Start an immediate one-shot timer
   * timer.start(function(userData, timerId)
   *             {
   *               this.debug("Immediate one-shot timer: " + timerId);
   *             });
   * </pre>
   */
  qx.Class.define("qx.util.TimerManager", {
    extend: qx.core.Object,
    type: "singleton",
    statics: {
      /** Time-ordered queue of timers */
      __timerQueue: [],

      /** Saved data for each timer */
      __timerData: {},

      /** Next timer id value is determined by incrementing this */
      __timerId: 0
    },
    members: {
      /** Whether we're currently listening on the interval timer event */
      __timerListenerActive: false,

      /**
       * Start a new timer
       *
       * @param callback {Function}
       *   Function to be called upon expiration of the timer.  The function is
       *   passed these parameters:
       *   <dl>
       *     <dt>userData</dt>
       *       <dd>The user data provided to the start() method</dd>
       *     <dt>timerId</dt>
       *       <dd>The timer id, as was returned by the start() method</dd>
       *   </dl>
       *
       * @param recurTime {Integer|null}
       *   If null, the timer will not recur.  Once the callback function
       *   returns the first time, the timer will be removed from the timer
       *   queue.  If non-null, upon return from the callback function, the
       *   timer will be reset to this number of milliseconds.
       *
       * @param context {qx.core.Object|null}
       *   Context (this) the callback function is called with.  If not
       *   provided, this Timer singleton object is used.
       *
       * @param userData {var}
       *   Data which is passed to the callback function upon timer expiry
       *
       * @param initialTime {Integer|null}
       *   Milliseconds before the callback function is called the very first
       *   time.  If not specified and recurTime is specified, then recurTime
       *   will be used as initialTime; otherwise initialTime will default
       *   to zero.
       *
       * @return {Integer}
       *   The timer id of this unique timer.  It may be provided to the stop()
       *   method to cancel a timer before expiration.
       */
      start: function start(callback, recurTime, context, userData, initialTime) {
        // Get the expiration time for this timer
        if (typeof initialTime != "number") {
          initialTime = recurTime || 0;
        }

        var expireAt = new Date().getTime() + initialTime; // Save the callback, user data, and requested recurrency time as well
        // as the current expiry time

        qx.util.TimerManager.__timerData[++qx.util.TimerManager.__timerId] = {
          callback: callback,
          userData: userData || null,
          expireAt: expireAt,
          recurTime: recurTime,
          context: context || this
        }; // Insert this new timer on the time-ordered timer queue

        this.__insertNewTimer(expireAt, qx.util.TimerManager.__timerId); // Give 'em the timer id


        return qx.util.TimerManager.__timerId;
      },

      /**
       * Stop a running timer
       *
       * @param timerId {Integer}
       *   A timer id previously returned by start()
       */
      stop: function stop(timerId) {
        // Find this timer id in the time-ordered list
        var timerQueue = qx.util.TimerManager.__timerQueue;
        var length = timerQueue.length;

        for (var i = 0; i < length; i++) {
          // Is this the one we're looking for?
          if (timerQueue[i] == timerId) {
            // Yup.  Remove it.
            timerQueue.splice(i, 1); // We found it so no need to continue looping through the queue

            break;
          }
        } // Ensure it's gone from the timer data map as well


        delete qx.util.TimerManager.__timerData[timerId]; // If there are no more timers pending...

        if (timerQueue.length == 0 && this.__timerListenerActive) {
          // ... then stop listening for the periodic timer
          qx.event.Idle.getInstance().removeListener("interval", this.__processQueue, this);
          this.__timerListenerActive = false;
        }
      },

      /**
       * Insert a timer on the time-ordered list of active timers.
       *
       * @param expireAt {Integer}
       *   Milliseconds from now when this timer should expire
       *
       * @param timerId {Integer}
       *   Id of the timer to be time-ordered
       *
       */
      __insertNewTimer: function __insertNewTimer(expireAt, timerId) {
        // The timer queue is time-ordered so that processing timers need not
        // search the queue; rather, it can simply look at the first element
        // and if not yet ready to fire, be done.  Search the queue for the
        // appropriate place to insert this timer.
        var timerQueue = qx.util.TimerManager.__timerQueue;
        var timerData = qx.util.TimerManager.__timerData;
        var length = timerQueue.length;

        for (var i = 0; i < length; i++) {
          // Have we reached a later time?
          if (timerData[timerQueue[i]].expireAt > expireAt) {
            // Yup.  Insert our new timer id before this element.
            timerQueue.splice(i, 0, timerId); // No need to loop through the queue further

            break;
          }
        } // Did we find someplace in the middle of the queue for it?


        if (timerQueue.length == length) {
          // Nope.  Insert it at the end.
          timerQueue.push(timerId);
        } // If this is the first element on the queue...


        if (!this.__timerListenerActive) {
          // ... then start listening for the periodic timer.
          qx.event.Idle.getInstance().addListener("interval", this.__processQueue, this);
          this.__timerListenerActive = true;
        }
      },

      /**
       * Process the queue of timers.  Call the registered callback function for
       * any timer which has expired.  If the timer is marked as recurrent, the
       * timer is restarted with the recurrent timeout following completion of
       * the callback function.
       *
       */
      __processQueue: function __processQueue() {
        // Get the current time
        var timeNow = new Date().getTime(); // While there are timer elements that need processing...

        var timerQueue = qx.util.TimerManager.__timerQueue;
        var timerData = qx.util.TimerManager.__timerData; // Is it time to process the first timer element yet?

        while (timerQueue.length > 0 && timerData[timerQueue[0]].expireAt <= timeNow) {
          // Yup.  Do it.  First, remove element from the queue.
          var expiredTimerId = timerQueue.shift(); // Call the handler function for this timer

          var expiredTimerData = timerData[expiredTimerId];
          expiredTimerData.callback.call(expiredTimerData.context, expiredTimerData.userData, expiredTimerId); // If this is a recurrent timer which wasn't stopped by the callback...

          if (expiredTimerData.recurTime && timerData[expiredTimerId]) {
            // ... then restart it.
            var now = new Date().getTime();
            expiredTimerData.expireAt = now + expiredTimerData.recurTime; // Insert this timer back on the time-ordered timer queue

            this.__insertNewTimer(expiredTimerData.expireAt, expiredTimerId);
          } else {
            // If it's not a recurrent timer, we can purge its data too.
            delete timerData[expiredTimerId];
          }
        } // If there are no more timers pending...


        if (timerQueue.length == 0 && this.__timerListenerActive) {
          // ... then stop listening for the periodic timer
          qx.event.Idle.getInstance().removeListener("interval", this.__processQueue, this);
          this.__timerListenerActive = false;
        }
      }
    }
  });
  qx.util.TimerManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.embed.Iframe": {},
      "qx.ui.core.queue.Manager": {},
      "qx.util.ResourceManager": {},
      "qx.util.Uri": {},
      "qx.bom.client.Browser": {},
      "qx.ui.container.Composite": {},
      "qx.ui.layout.VBox": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "browser.name": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.embed.Iframe", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __iframe: null,
      setUp: function setUp() {
        this.__iframe = new qx.ui.embed.Iframe();

        this.__iframe.set({
          width: 200,
          height: 500
        });
      },
      tearDown: function tearDown() {
        this.__iframe.destroy();
      },
      testHiddenSetSourceInitial: function testHiddenSetSourceInitial() {
        this.__iframe.set({
          visibility: "hidden"
        });

        this.getRoot().add(this.__iframe);
        qx.ui.core.queue.Manager.flush();
        this.assertNotNull(this.__iframe.getContentElement().getDomElement());
      },
      testHiddenSetSource: function testHiddenSetSource() {
        this.getRoot().add(this.__iframe);
        qx.ui.core.queue.Manager.flush();

        this.__iframe.hide();

        qx.ui.core.queue.Manager.flush();
        var src = qx.util.ResourceManager.getInstance().toUri("qx/static/blank.html");
        src = qx.util.Uri.getAbsolute(src);

        this.__iframe.setSource(src);

        qx.ui.core.queue.Manager.flush();

        this.__iframe.addListenerOnce("load", function () {
          this.resume(function () {
            this.assertEquals(this.__iframe.getSource(), this.__iframe.getWindow().location.href);
          });
        }, this);

        this.wait(10000);
      },
      testGetWindow: function testGetWindow() {
        this.getRoot().add(this.__iframe);

        this.__iframe.addListener("load", function () {
          this.resume(function () {
            this.assertNotNull(this.__iframe.getWindow());
          }, this);
        }, this);

        var src = qx.util.ResourceManager.getInstance().toUri("qx/static/blank.html");

        this.__iframe.setSource(src);

        this.wait(10000);
      },
      testSyncSourceAfterDOMMove: function testSyncSourceAfterDOMMove() {
        // This breaks (very) frequently when run under headless chrome on Travis; we can't
        //  track down the cause and it works just fine elsewhere.  Disabling this test on 
        //  Chrome is an effective quick hack until someone can figure it out.
        if (qx.core.Environment.get("browser.name") == "chrome") {
          this.skip("Optimization makes this test fail frequently for chrome - skipping");
        }

        var rm = qx.util.ResourceManager.getInstance();
        var src1 = rm.toUri("qx/static/blank.html"); // <body></body>

        var src2 = rm.toUri("qx/test/hello.html"); // <body>Hello World!</body>

        var iframe = this.__iframe;
        var container0 = new qx.ui.container.Composite(new qx.ui.layout.VBox());
        var container1 = new qx.ui.container.Composite(new qx.ui.layout.VBox());
        var container2 = new qx.ui.container.Composite(new qx.ui.layout.VBox());
        container0.add(container1, {
          flex: 1
        });
        container0.add(container2, {
          flex: 1
        });
        this.getRoot().add(container0);
        iframe.setSource(src1); // "qx/static/blank.html"

        container1.add(iframe, {
          flex: 1
        }); // Move iframe to another DOM location after half a second

        window.setTimeout(function () {
          iframe.setSource(src2); // "qx/test/hello.html"

          container2.add(iframe, {
            flex: 1
          });
        }, 500); // Check iframe body content after one second

        window.setTimeout(function () {
          this.resume(function () {
            var innerText = iframe.getWindow().document.body.innerText; // IE and edge deliver an extra blank at the end of 
            // body.innerText

            if (typeof innerText == "string" && (qx.core.Environment.get("browser.name") == "edge" || qx.core.Environment.get("browser.name") == "ie")) {
              innerText = innerText.replace(/\s$/gm, '');
            }

            this.assertEquals("Hello World!", innerText);
          });
        }.bind(this), 4000);
        this.wait(10000);
      }
    }
  });
  qx.test.ui.embed.Iframe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.ComboBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.AbstractSelectBox", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.__selectBox = new qx.ui.form.SelectBox();
        this.getRoot().add(this.__selectBox);
        this.__comboBox = new qx.ui.form.ComboBox();
        this.getRoot().add(this.__comboBox);
        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.form.AbstractSelectBox.prototype.tearDown.base.call(this);

        this.__selectBox.dispose();

        this.__selectBox = null;

        this.__comboBox.dispose();

        this.__comboBox = null;
      },
      testStatePopupOpen: function testStatePopupOpen() {
        this.__selectBox.open();

        this.flush();
        this.assertTrue(this.__selectBox.hasState("popupOpen"));

        this.__selectBox.close();

        this.flush();
        this.assertFalse(this.__selectBox.hasState("popupOpen"));

        this.__comboBox.open();

        this.flush();
        this.assertTrue(this.__comboBox.hasState("popupOpen"));

        this.__comboBox.close();

        this.flush();
        this.assertFalse(this.__comboBox.hasState("popupOpen"));
      }
    }
  });
  qx.test.ui.form.AbstractSelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.VirtualSelectBox": {},
      "qx.ui.form.VirtualComboBox": {},
      "qx.data.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.AbstractVirtualBox", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.__selectBox = new qx.ui.form.VirtualSelectBox();
        this.getRoot().add(this.__selectBox);
        this.__comboBox = new qx.ui.form.VirtualComboBox();
        this.getRoot().add(this.__comboBox);
        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.form.AbstractVirtualBox.prototype.tearDown.base.call(this);

        this.__selectBox.dispose();

        this.__selectBox = null;

        this.__comboBox.dispose();

        this.__comboBox = null;
      },
      testStatePopupOpen: function testStatePopupOpen() {
        this.__selectBox.open();

        this.flush();
        this.assertTrue(this.__selectBox.hasState("popupOpen"));

        this.__selectBox.close();

        this.flush();
        this.assertFalse(this.__selectBox.hasState("popupOpen"));

        this.__comboBox.open();

        this.flush();
        this.assertTrue(this.__comboBox.hasState("popupOpen"));

        this.__comboBox.close();

        this.flush();
        this.assertFalse(this.__comboBox.hasState("popupOpen"));
      },
      testListLengthAfterModelChangeSelectBox: function testListLengthAfterModelChangeSelectBox() {
        var model = new qx.data.Array(["a", "b", "c"]);

        this.__selectBox.setModel(model);

        this.__selectBox.open();

        this.flush();

        var dropDown = this.__selectBox.getChildControl("dropdown");

        var firstHeight = dropDown.getBounds().height;
        this.assertPositiveInteger(firstHeight);
        model.replace(["d", "e", "f", "g", "h", "j", "k", "l"]);
        this.flush();
        var secondHeight = dropDown.getBounds().height;
        this.assertPositiveInteger(secondHeight);
        this.assertNotEquals(secondHeight, firstHeight);
        this.assertTrue(secondHeight > firstHeight);

        this.__selectBox.close();

        this.__selectBox.resetModel();
      },
      testListLengthAfterModelChangeComboBox: function testListLengthAfterModelChangeComboBox() {
        var model = new qx.data.Array(["a", "b", "c"]);

        this.__comboBox.setModel(model);

        this.__comboBox.open();

        this.flush();

        var dropDown = this.__comboBox.getChildControl("dropdown");

        var firstHeight = dropDown.getBounds().height;
        this.assertPositiveInteger(firstHeight);
        model.replace(["d", "e", "f", "g", "h", "j", "k", "l"]);
        this.flush();
        var secondHeight = dropDown.getBounds().height;
        this.assertPositiveInteger(secondHeight);
        this.assertNotEquals(secondHeight, firstHeight);
        this.assertTrue(secondHeight > firstHeight);

        this.__comboBox.close();

        this.__comboBox.resetModel();
      }
    }
  });
  qx.test.ui.form.AbstractVirtualBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.ui.core.queue.Widget": {},
      "qx.ui.form.core.VirtualDropDownList": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Basic class for widgets which need a virtual list as popup for example a
   * SelectBox. It's basically supports a drop-down as popup with a virtual list
   * and the whole children management.
   *
   * @childControl dropdown {qx.ui.form.core.VirtualDropDownList} The drop-down list.
   */
  qx.Class.define("qx.ui.form.core.AbstractVirtualBox", {
    extend: qx.ui.core.Widget,
    include: qx.ui.form.MForm,
    implement: qx.ui.form.IForm,
    type: "abstract",

    /**
     * @param model {qx.data.Array?null} The model data for the widget.
     */
    construct: function construct(model) {
      qx.ui.core.Widget.constructor.call(this); // set the layout

      var layout = new qx.ui.layout.HBox();

      this._setLayout(layout);

      layout.setAlignY("middle"); // Register listeners

      this.addListener("keypress", this._handleKeyboard, this);
      this.addListener("tap", this._handlePointer, this);
      this.addListener("blur", this._onBlur, this);
      this.addListener("resize", this._onResize, this);

      this._createChildControl("dropdown");

      this.bind('allowGrowDropDown', this.getChildControl('dropdown'), 'allowGrowDropDown');

      if (model != null) {
        this.initModel(model);
      } else {
        this.__defaultModel = new qx.data.Array();
        this.initModel(this.__defaultModel);
      }
    },
    properties: {
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 120
      },

      /** Data array containing the data which should be shown in the drop-down. */
      model: {
        check: "qx.data.Array",
        apply: "_applyModel",
        event: "changeModel",
        nullable: false,
        deferredInit: true
      },

      /**
       * Delegation object which can have one or more functions defined by the
       * {@link qx.ui.list.core.IListDelegate} interface.
       */
      delegate: {
        apply: "_applyDelegate",
        event: "changeDelegate",
        init: null,
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as a label. This is only needed if objects are stored in the
       * model.
       */
      labelPath: {
        check: "String",
        apply: "_applyLabelPath",
        event: "changeLabelPath",
        nullable: true
      },

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      labelOptions: {
        apply: "_applyLabelOptions",
        event: "changeLabelOptions",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as an icon. This is only needed if objects are stored in the
       * model and icons should be displayed.
       */
      iconPath: {
        check: "String",
        event: "changeIconPath",
        apply: "_applyIconPath",
        nullable: true
      },

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      iconOptions: {
        apply: "_applyIconOptions",
        event: "changeIconOptions",
        nullable: true
      },

      /** Default item height. */
      itemHeight: {
        check: "Integer",
        init: 25,
        apply: "_applyRowHeight",
        themeable: true
      },

      /**
       * The maximum height of the drop-down list. Setting this value to
       * <code>null</code> will set cause the list to be auto-sized.
       */
      maxListHeight: {
        check: "Number",
        apply: "_applyMaxListHeight",
        nullable: true,
        init: 200
      },

      /**
       * Allow the drop-down to grow wider than its parent.
       */
      allowGrowDropDown: {
        init: false,
        nullable: false,
        check: "Boolean",
        event: "changeAllowGrowDropDown"
      }
    },
    members: {
      /** @type {qx.data.Array} The initial model array of this virtual box. */
      __defaultModel: null,

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        invalid: true
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Trigger a rebuild from the internal data structure.
       */
      refresh: function refresh() {
        this.getChildControl("dropdown").getChildControl("list").refresh();
        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * Shows the drop-down.
       */
      open: function open() {
        this._beforeOpen();

        this.getChildControl("dropdown").open();
      },

      /**
       * Hides the drop-down.
       */
      close: function close() {
        this._beforeClose();

        this.getChildControl("dropdown").close();
      },

      /**
       * Toggles the drop-down visibility.
       */
      toggle: function toggle() {
        var dropDown = this.getChildControl("dropdown");

        if (dropDown.isVisible()) {
          this.close();
        } else {
          this.open();
        }
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "dropdown":
            control = new qx.ui.form.core.VirtualDropDownList(this);
            control.addListener("changeVisibility", this._onPopupChangeVisibility, this);
            break;
        }

        return control || qx.ui.form.core.AbstractVirtualBox.prototype._createChildControlImpl.base.call(this, id, hash);
      },

      /**
       * This method is called before the drop-down is opened.
       */
      _beforeOpen: function _beforeOpen() {},

      /**
       * This method is called before the drop-down is closed.
       */
      _beforeClose: function _beforeClose() {},

      /**
       * Returns the action dependent on the user interaction: e. q. <code>open</code>,
       * or <code>close</code>.
       *
       * @param event {qx.event.type.KeySequence} The keyboard event.
       * @return {String|null} The action or <code>null</code> when interaction
       *  doesn't hit any action.
       */
      _getAction: function _getAction(event) {
        var keyIdentifier = event.getKeyIdentifier();
        var isOpen = this.getChildControl("dropdown").isVisible();

        var isModifierPressed = this._isModifierPressed(event);

        if (!isOpen && !isModifierPressed && (keyIdentifier === "Down" || keyIdentifier === "Up")) {
          return "open";
        } else if (isOpen && !isModifierPressed && keyIdentifier === "Escape") {
          return "close";
        } else {
          return null;
        }
      },

      /**
       * Helper Method to create bind path depended on the passed path.
       *
       * @param source {String} The path to the selection.
       * @param path {String?null} The path to the item's property.
       * @return {String} The created path.
       */
      _getBindPath: function _getBindPath(source, path) {
        var bindPath = source + "[0]";

        if (path != null && path != "") {
          bindPath += "." + path;
        }

        return bindPath;
      },

      /**
       * Helper method to check if one modifier key is pressed. e.q.
       * <code>Control</code>, <code>Shift</code>, <code>Meta</code> or
       * <code>Alt</code>.
       *
       * @param event {qx.event.type.KeySequence} The keyboard event.
       * @return {Boolean} <code>True</code> when a modifier key is pressed,
       *   <code>false</code> otherwise.
       */
      _isModifierPressed: function _isModifierPressed(event) {
        var isAltPressed = event.isAltPressed();
        var isCtrlOrCommandPressed = event.isCtrlOrCommandPressed();
        var isShiftPressed = event.isShiftPressed();
        var isMetaPressed = event.isMetaPressed();
        return isAltPressed || isCtrlOrCommandPressed || isShiftPressed || isMetaPressed;
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Handler for the blur event of the current widget.
       *
       * @param event {qx.event.type.Focus} The blur event.
       */
      _onBlur: function _onBlur(event) {
        this.close();
      },

      /**
       * Handles the complete keyboard events for user interaction. If there is
       * no defined user interaction {@link #_getAction}, the event is delegated
       * to the {@link qx.ui.form.core.VirtualDropDownList#_handleKeyboard} method.
       *
       * @param event {qx.event.type.KeySequence} The keyboard event.
       */
      _handleKeyboard: function _handleKeyboard(event) {
        var action = this._getAction(event);

        var isOpen = this.getChildControl("dropdown").isVisible();

        switch (action) {
          case "open":
            this.open();
            break;

          case "close":
            this.close();
            break;

          default:
            if (isOpen) {
              this.getChildControl("dropdown")._handleKeyboard(event);
            }

            break;
        }
      },

      /**
       * Handles all pointer events dispatched on the widget.
       *
       * @param event {qx.event.type.Pointer|qx.event.type.Roll} The pointer event.
       */
      _handlePointer: function _handlePointer(event) {},

      /**
       * Updates drop-down minimum size.
       *
       * @param event {qx.event.type.Data} Data event.
       */
      _onResize: function _onResize(event) {
        this.getChildControl("dropdown").setMinWidth(event.getData().width);
      },

      /**
       * Adds/removes the state 'popupOpen' depending on the visibility of the popup
       *
       * @param event {qx.event.type.Data} Data event
       */
      _onPopupChangeVisibility: function _onPopupChangeVisibility(event) {
        event.getData() == "visible" ? this.addState("popupOpen") : this.removeState("popupOpen");
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyModel: function _applyModel(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setModel(value);
        qx.ui.core.queue.Widget.add(this);
      },
      // property apply
      _applyDelegate: function _applyDelegate(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setDelegate(value);
      },
      // property apply
      _applyLabelPath: function _applyLabelPath(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setLabelPath(value);
        qx.ui.core.queue.Widget.add(this);
      },
      // property apply
      _applyLabelOptions: function _applyLabelOptions(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setLabelOptions(value);
        qx.ui.core.queue.Widget.add(this);
      },
      // property apply
      _applyIconPath: function _applyIconPath(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setIconPath(value);
        qx.ui.core.queue.Widget.add(this);
      },
      // property apply
      _applyIconOptions: function _applyIconOptions(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setIconOptions(value);
        qx.ui.core.queue.Widget.add(this);
      },
      // property apply
      _applyRowHeight: function _applyRowHeight(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setItemHeight(value);
      },
      // property apply
      _applyMaxListHeight: function _applyMaxListHeight(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setMaxHeight(value);
      }
    },
    destruct: function destruct() {
      if (this.__defaultModel) {
        this.__defaultModel.dispose();
      }
    }
  });
  qx.ui.form.core.AbstractVirtualBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.core.AbstractVirtualBox": {
        "construct": true,
        "require": true
      },
      "qx.data.controller.ISelection": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.event.Timer": {
        "construct": true
      },
      "qx.ui.core.Spacer": {},
      "qx.ui.form.ListItem": {},
      "qx.ui.basic.Image": {},
      "qx.ui.core.queue.Widget": {},
      "qx.data.SingleValueBinding": {},
      "qx.util.Delegate": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A form virtual widget which allows a single selection. Looks somewhat like
   * a normal button, but opens a virtual list of items to select when tapping
   * on it.
   *
   * @childControl spacer {qx.ui.core.Spacer} Flexible spacer widget.
   * @childControl atom {qx.ui.basic.Atom} Shows the text and icon of the content.
   * @childControl arrow {qx.ui.basic.Image} Shows the arrow to open the drop-down
   *   list.
   */
  qx.Class.define("qx.ui.form.VirtualSelectBox", {
    extend: qx.ui.form.core.AbstractVirtualBox,
    implement: [qx.data.controller.ISelection, qx.ui.form.IField],
    construct: function construct(model) {
      qx.ui.form.core.AbstractVirtualBox.constructor.call(this, model);

      this._createChildControl("atom");

      this._createChildControl("spacer");

      this._createChildControl("arrow"); // Register listener


      this.addListener("pointerover", this._onPointerOver, this);
      this.addListener("pointerout", this._onPointerOut, this);
      this.__bindings = [];
      this.initSelection(this.getChildControl("dropdown").getSelection());
      this.__searchTimer = new qx.event.Timer(500);

      this.__searchTimer.addListener("interval", this.__preselect, this);

      this.getSelection().addListener("change", this._updateSelectionValue, this);
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "virtual-selectbox"
      },
      // overridden
      width: {
        refine: true,
        init: 120
      },

      /** Current selected items. */
      selection: {
        check: "qx.data.Array",
        event: "changeSelection",
        apply: "_applySelection",
        nullable: false,
        deferredInit: true
      }
    },
    events: {
      /**
       * This event is fired as soon as the content of the selection property changes, but
       * this is not equal to the change of the selection of the widget. If the selection
       * of the widget changes, the content of the array stored in the selection property
       * changes. This means you have to listen to the change event of the selection array
       * to get an event as soon as the user changes the selected item.
       * <pre class="javascript">obj.getSelection().addListener("change", listener, this);</pre>
       */
      "changeSelection": "qx.event.type.Data",

      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data"
    },
    members: {
      /** @type {String} The search value to {@link #__preselect} an item. */
      __searchValue: "",

      /**
       * @type {qx.event.Timer} The time which triggers the search for pre-selection.
       */
      __searchTimer: null,

      /** @type {Array} Contains the id from all bindings. */
      __bindings: null,

      /**
       * @param selected {var|null} Item to select as value.
       * @returns {null|TypeError} The status of this operation.
       */
      setValue: function setValue(selected) {
        if (null === selected) {
          this.getSelection().removeAll();
          return null;
        }

        this.getSelection().setItem(0, selected);
        return null;
      },

      /**
       * @returns {null|var} The currently selected item or null if there is none.
       */
      getValue: function getValue() {
        var s = this.getSelection();
        return s.length === 0 ? null : s.getItem(0);
      },
      resetValue: function resetValue() {
        this.setValue(null);
      },
      // overridden
      syncWidget: function syncWidget(jobs) {
        this._removeBindings();

        this._addBindings();
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAl API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "spacer":
            control = new qx.ui.core.Spacer();

            this._add(control, {
              flex: 1
            });

            break;

          case "atom":
            control = new qx.ui.form.ListItem("");
            control.setCenter(false);
            control.setAnonymous(true);

            this._add(control, {
              flex: 1
            });

            break;

          case "arrow":
            control = new qx.ui.basic.Image();
            control.setAnonymous(true);

            this._add(control);

            break;
        }

        return control || qx.ui.form.VirtualSelectBox.prototype._createChildControlImpl.base.call(this, id, hash);
      },
      // overridden
      _getAction: function _getAction(event) {
        var keyIdentifier = event.getKeyIdentifier();
        var isOpen = this.getChildControl("dropdown").isVisible();

        var isModifierPressed = this._isModifierPressed(event);

        if (!isOpen && !isModifierPressed && (keyIdentifier === "Enter" || keyIdentifier === "Space")) {
          return "open";
        } else if (isOpen && event.isPrintable()) {
          return "search";
        } else {
          return qx.ui.form.VirtualSelectBox.prototype._getAction.base.call(this, event);
        }
      },

      /**
       * This method is called when the binding can be added to the
       * widget. For e.q. bind the drop-down selection with the widget.
       */
      _addBindings: function _addBindings() {
        var atom = this.getChildControl("atom");

        var modelPath = this._getBindPath("selection", "");

        var id = this.bind(modelPath, atom, "model", null);

        this.__bindings.push(id);

        var labelSourcePath = this._getBindPath("selection", this.getLabelPath());

        id = this.bind(labelSourcePath, atom, "label", this.getLabelOptions());

        this.__bindings.push(id);

        if (this.getIconPath() != null) {
          var iconSourcePath = this._getBindPath("selection", this.getIconPath());

          id = this.bind(iconSourcePath, atom, "icon", this.getIconOptions());

          this.__bindings.push(id);
        }
      },

      /**
       * This method is called when the binding can be removed from the
       * widget. For e.q. remove the bound drop-down selection.
       */
      _removeBindings: function _removeBindings() {
        while (this.__bindings.length > 0) {
          var id = this.__bindings.pop();

          this.removeBinding(id);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      // overridden
      _handlePointer: function _handlePointer(event) {
        qx.ui.form.VirtualSelectBox.prototype._handlePointer.base.call(this, event);

        var type = event.getType();

        if (type === "tap") {
          this.toggle();
        }
      },
      // overridden
      _handleKeyboard: function _handleKeyboard(event) {
        var action = this._getAction(event);

        switch (action) {
          case "search":
            this.__searchValue += this.__convertKeyIdentifier(event.getKeyIdentifier());

            this.__searchTimer.restart();

            break;

          default:
            qx.ui.form.VirtualSelectBox.prototype._handleKeyboard.base.call(this, event);

            break;
        }
      },

      /**
       * Listener method for "pointerover" event.
       *
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state
       *   is set)</li>
       * </ul>
       *
       * @param event {qx.event.type.Pointer} Pointer event
       */
      _onPointerOver: function _onPointerOver(event) {
        if (!this.isEnabled() || event.getTarget() !== this) {
          return;
        }

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
          this.addState("pressed");
        }

        this.addState("hovered");
      },

      /**
       * Listener method for "pointerout" event.
       *
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" and removes "pressed" state (if "pressed" state
       *   is set)</li>
       * </ul>
       *
       * @param event {qx.event.type.Pointer} Pointer event
       */
      _onPointerOut: function _onPointerOut(event) {
        if (!this.isEnabled() || event.getTarget() !== this) {
          return;
        }

        this.removeState("hovered");

        if (this.hasState("pressed")) {
          this.removeState("pressed");
          this.addState("abandoned");
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applySelection: function _applySelection(value, old) {
        this.getChildControl("dropdown").setSelection(value);
        qx.ui.core.queue.Widget.add(this);
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Preselects an item in the drop-down, when item starts with the
       * __searchValue value.
       */
      __preselect: function __preselect() {
        this.__searchTimer.stop();

        var searchValue = this.__searchValue;

        if (searchValue === null || searchValue === "") {
          return;
        }

        var model = this.getModel();
        var list = this.getChildControl("dropdown").getChildControl("list");
        var selection = list.getSelection();

        var length = list._getLookupTable().length;

        var startIndex = model.indexOf(selection.getItem(0));

        var startRow = list._reverseLookup(startIndex);

        for (var i = 1; i <= length; i++) {
          var row = (i + startRow) % length;
          var item = model.getItem(list._lookup(row));

          if (!item) {
            // group items aren't in the model
            continue;
          }

          var value = item;

          if (this.getLabelPath()) {
            value = qx.data.SingleValueBinding.resolvePropertyChain(item, this.getLabelPath());
            var labelOptions = this.getLabelOptions();

            if (labelOptions) {
              var converter = qx.util.Delegate.getMethod(labelOptions, "converter");

              if (converter) {
                value = converter(value, item);
              }
            }
          }

          if (value.toLowerCase().startsWith(searchValue.toLowerCase())) {
            selection.push(item);
            break;
          }
        }

        this.__searchValue = "";
      },

      /**
       * Converts the keyIdentifier to a printable character e.q. <code>"Space"</code>
       * to <code>" "</code>.
       *
       * @param keyIdentifier {String} The keyIdentifier to convert.
       * @return {String} The converted keyIdentifier.
       */
      __convertKeyIdentifier: function __convertKeyIdentifier(keyIdentifier) {
        if (keyIdentifier === "Space") {
          return " ";
        } else {
          return keyIdentifier;
        }
      },

      /**
       * Called when selection changes.
       *
       * @param event {qx.event.type.Data} {@link qx.data.Array} change event.
       */
      _updateSelectionValue: function _updateSelectionValue(event) {
        var d = event.getData();
        var old = d.removed.length ? d.removed[0] : null;
        this.fireDataEvent("changeValue", d.added[0], old);
      }
    },
    destruct: function destruct() {
      this._removeBindings();

      this.getSelection().removeListener("change", this._updateSelectionValue, this);

      this.__searchTimer.removeListener("interval", this.__preselect, this);

      this.__searchTimer.dispose();

      this.__searchTimer = null;
    }
  });
  qx.ui.form.VirtualSelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.core.AbstractVirtualBox": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IStringForm": {
        "require": true
      },
      "qx.event.type.Focus": {
        "construct": true
      },
      "qx.ui.form.TextField": {},
      "qx.ui.form.Button": {},
      "qx.data.SingleValueBinding": {},
      "qx.lang.Type": {},
      "qx.util.Delegate": {},
      "qx.lang.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A virtual form widget that allows text entry as well as selection from a
   * drop-down.
   *
   * @childControl textfield {qx.ui.form.TextField} Field for text entry.
   * @childControl button {qx.ui.form.Button} Opens the drop-down.
   */
  qx.Class.define("qx.ui.form.VirtualComboBox", {
    extend: qx.ui.form.core.AbstractVirtualBox,
    implement: [qx.ui.form.IStringForm],
    construct: function construct(model) {
      qx.ui.form.core.AbstractVirtualBox.constructor.call(this, model);

      var textField = this._createChildControl("textfield");

      this._createChildControl("button");

      var dropdown = this.getChildControl("dropdown");
      dropdown.getChildControl("list").setSelectionMode("single");
      this.__selection = dropdown.getSelection();

      this.__selection.addListener("change", this.__onSelectionChange, this);

      this.bind("value", textField, "value");
      textField.bind("value", this, "value"); // forward the focusin and focusout events to the textfield. The textfield
      // is not focusable so the events need to be forwarded manually.

      this.addListener("focusin", function (e) {
        textField.fireNonBubblingEvent("focusin", qx.event.type.Focus);
      }, this);
      this.addListener("focusout", function (e) {
        textField.fireNonBubblingEvent("focusout", qx.event.type.Focus);
        this.fireNonBubblingEvent("blur", qx.event.type.Focus);
      }, this);
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "virtual-combobox"
      },
      // overridden
      width: {
        refine: true,
        init: 120
      },

      /**
       * The currently selected or entered value.
       */
      value: {
        nullable: true,
        event: "changeValue"
      },

      /**
       * String value which will be shown as a hint if the field is all of:
       * unset, unfocused and enabled. Set to null to not show a placeholder
       * text.
       */
      placeholder: {
        check: "String",
        nullable: true,
        apply: "_applyPlaceholder"
      },

      /**
       * Formatting function that will be applied to the value of a selected model
       * item's label before it is written to the text field. Also used to find
       * and preselect the first list entry that begins with the current content
       * of the text field when the drop-down list is opened. Can be used e.g. to
       * strip HTML tags from rich-formatted item labels. The function will be
       * called with the item's label (String) as the only parameter.
       */
      defaultFormat: {
        check: "Function",
        init: null,
        nullable: true
      }
    },
    members: {
      /** @type {var} Binding id between local value and text field value. */
      __localBindId: null,

      /** @type {var} Binding id between text field value and local value. */
      __textFieldBindId: null,

      /** @type {qx.data.Array} the drop-down selection. */
      __selection: null,

      /** @type {Boolean} Indicator to ignore selection changes from the list. */
      __ignoreChangeSelection: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the current selection. This method only works if the widget is
       * already created and added to the document.
       *
       * @return {String|null} The current text selection.
       */
      getTextSelection: function getTextSelection() {
        return this.getChildControl("textfield").getTextSelection();
      },

      /**
       * Returns the current selection length. This method only works if the
       * widget is already created and added to the document.
       *
       * @return {Integer|null} The current text selection length.
       */
      getTextSelectionLength: function getTextSelectionLength() {
        return this.getChildControl("textfield").getTextSelectionLength();
      },

      /**
       * Set the selection to the given start and end (zero-based). If no end
       * value is given the selection will extend to the end of the textfield's
       * content. This method only works if the widget is already created and
       * added to the document.
       *
       * @param start {Integer} Start of the selection (zero-based).
       * @param end {Integer} End of the selection.
       */
      setTextSelection: function setTextSelection(start, end) {
        this.getChildControl("textfield").setTextSelection(start, end);
      },

      /**
       * Clears the current selection. This method only works if the widget is
       * already created and added to the document.
       */
      clearTextSelection: function clearTextSelection() {
        this.getChildControl("textfield").clearTextSelection();
      },

      /**
       * Selects the whole content.
       */
      selectAllText: function selectAllText() {
        this.getChildControl("textfield").selectAllText();
      },

      /**
       * Clear any text selection, then select all text.
       */
      resetAllTextSelection: function resetAllTextSelection() {
        this.clearTextSelection();
        this.selectAllText();
      },
      // overridden
      tabFocus: function tabFocus() {
        var field = this.getChildControl("textfield");
        field.getFocusElement().focus();
        field.selectAllText();
      },
      // overridden
      focus: function focus() {
        qx.ui.form.VirtualComboBox.prototype.focus.base.call(this);
        this.getChildControl("textfield").getFocusElement().focus();
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "textfield":
            control = new qx.ui.form.TextField();
            control.setFocusable(false);
            control.addState("inner");

            this._add(control, {
              flex: 1
            });

            break;

          case "button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.setKeepActive(true);
            control.addState("inner");
            control.addListener("execute", this.toggle, this);

            this._add(control);

            break;
        }

        return control || qx.ui.form.VirtualComboBox.prototype._createChildControlImpl.base.call(this, id, hash);
      },
      // overridden
      _beforeOpen: function _beforeOpen() {
        this.__selectFirstMatch();
      },
      // overridden
      _handleKeyboard: function _handleKeyboard(event) {
        var action = this._getAction(event);

        switch (action) {
          case "select":
            this.setValue(this.getChildControl("textfield").getValue());
            break;

          default:
            qx.ui.form.VirtualComboBox.prototype._handleKeyboard.base.call(this, event);

            break;
        }
      },
      // overridden
      _getAction: function _getAction(event) {
        var keyIdentifier = event.getKeyIdentifier();
        var isOpen = this.getChildControl("dropdown").isVisible();

        var isModifierPressed = this._isModifierPressed(event);

        if (!isOpen && !isModifierPressed && keyIdentifier === "Enter") {
          return "select";
        } else {
          return qx.ui.form.VirtualComboBox.prototype._getAction.base.call(this, event);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      // overridden
      _handlePointer: function _handlePointer(event) {
        qx.ui.form.VirtualComboBox.prototype._handlePointer.base.call(this, event);

        var type = event.getType();

        if (type !== "tap") {
          return;
        }

        this.close();
      },

      /**
       * Handler to synchronize selection changes with the value property.
       *
       * @param event {qx.event.type.Data} The change event from the qx.data.Array.
       */
      __onSelectionChange: function __onSelectionChange(event) {
        if (this.__ignoreChangeSelection == true) {
          return;
        }

        var selected = this.__selection.getItem(0);

        if (selected) {
          selected = this.__convertValue(selected);
          this.setValue(selected);
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyPlaceholder: function _applyPlaceholder(value, old) {
        this.getChildControl("textfield").setPlaceholder(value);
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Selects the first list item that starts with the text field's value.
       */
      __selectFirstMatch: function __selectFirstMatch() {
        var value = this.getValue();
        var dropdown = this.getChildControl("dropdown");
        var selection = dropdown.getSelection();
        var selected = selection.getItem(0); // try to preselect the matching item even if there is no current selection

        if (selected === undefined || this.__convertValue(selected) !== value) {
          // only reset the old selection if there is one
          if (selected !== undefined) {
            // reset the old selection
            this.__ignoreChangeSelection = true;
            selection.removeAll();
            this.__ignoreChangeSelection = false;
          } // No calculation is needed when the value is empty


          if (value == null || value == "") {
            return;
          }

          var model = this.getModel();

          var lookupTable = dropdown.getChildControl("list")._getLookupTable();

          for (var i = 0, l = lookupTable.length; i < l; i++) {
            var modelItem = model.getItem(lookupTable[i]);

            var itemLabel = this.__convertValue(modelItem);

            if (itemLabel && itemLabel.indexOf(value) == 0) {
              dropdown.setPreselected(modelItem);
              break;
            }
          }
        }
      },

      /**
       * Helper method to convert the model item to a String.
       *
       * @param modelItem {var} The model item to convert.
       * @return {String} The converted value.
       */
      __convertValue: function __convertValue(modelItem) {
        var labelOptions = this.getLabelOptions();
        var formatter = this.getDefaultFormat();
        var labelPath = this.getLabelPath();
        var result = null;

        if (labelPath != null) {
          result = qx.data.SingleValueBinding.resolvePropertyChain(modelItem, labelPath);
        } else if (qx.lang.Type.isString(modelItem)) {
          result = modelItem;
        }

        var converter = qx.util.Delegate.getMethod(labelOptions, "converter");

        if (converter != null) {
          result = converter(result);
        }

        if (result != null && formatter != null) {
          result = formatter(qx.lang.String.stripTags(result));
        }

        return result;
      }
    },
    destruct: function destruct() {
      var textField = this.getChildControl("textfield");
      this.removeAllBindings();
      textField.removeAllBindings();

      this.__selection.removeListener("change", this.__onSelectionChange, this);

      this.__selection = null;
    }
  });
  qx.ui.form.VirtualComboBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.popup.Popup": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      },
      "qx.ui.form.core.AbstractVirtualBox": {
        "construct": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.ui.list.List": {},
      "qx.bom.Viewport": {},
      "qx.util.Delegate": {},
      "qx.ui.form.ListItem": {},
      "qx.theme.manager.Font": {},
      "qx.bom.Font": {},
      "qx.bom.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A drop-down (popup) widget which contains a virtual list for selection.
   *
   * @childControl list {qx.ui.list.List} The virtual list.
   *
   * @internal
   */
  qx.Class.define("qx.ui.form.core.VirtualDropDownList", {
    extend: qx.ui.popup.Popup,

    /**
     * Creates the drop-down list.
     *
     * @param target {qx.ui.form.core.AbstractVirtualBox} The composite widget.
     */
    construct: function construct(target) {
      qx.core.Assert.assertNotNull(target, "Invalid parameter 'target'!");
      qx.core.Assert.assertNotUndefined(target, "Invalid parameter 'target'!");
      qx.core.Assert.assertInterface(target, qx.ui.form.core.AbstractVirtualBox, "Invalid parameter 'target'!");
      qx.ui.popup.Popup.constructor.call(this, new qx.ui.layout.VBox());
      this._target = target;

      this._createChildControl("list");

      this.addListener("changeVisibility", this.__onChangeVisibility, this);
      this.__defaultSelection = new qx.data.Array();
      this.initSelection(this.__defaultSelection);
    },
    properties: {
      // overridden
      autoHide: {
        refine: true,
        init: false
      },
      // overridden
      keepActive: {
        refine: true,
        init: true
      },

      /** Current selected items. */
      selection: {
        check: "qx.data.Array",
        event: "changeSelection",
        apply: "_applySelection",
        nullable: false,
        deferredInit: true
      },

      /**
       * Allow the drop-down to grow wider than its parent.
       */
      allowGrowDropDown: {
        init: false,
        nullable: false,
        check: "Boolean",
        apply: "_adjustSize",
        event: "changeAllowGrowDropDown"
      }
    },
    events: {
      /**
       * This event is fired as soon as the content of the selection property changes, but
       * this is not equal to the change of the selection of the widget. If the selection
       * of the widget changes, the content of the array stored in the selection property
       * changes. This means you have to listen to the change event of the selection array
       * to get an event as soon as the user changes the selected item.
       * <pre class="javascript">obj.getSelection().addListener("change", listener, this);</pre>
       */
      "changeSelection": "qx.event.type.Data"
    },
    members: {
      /** @type {qx.ui.form.core.AbstractVirtualBox} The composite widget. */
      _target: null,

      /** @type {var} The pre-selected model item. */
      _preselected: null,

      /**
       * @type {Boolean} Indicator to ignore selection changes from the
       * {@link #selection} array.
       */
      __ignoreSelection: false,

      /** @type {Boolean} Indicator to ignore selection changes from the list. */
      __ignoreListSelection: false,

      /** @type {qx.data.Array} The initial selection array. */
      __defaultSelection: null,

      /**
       * When the drop-down is allowed to grow wider than its parent,
       * this member variable will contain the cached maximum list item width in pixels.
       * This variable gets updated whenever the model or model length changes.
       *
       * @type {Number}
       */
      __cachedMaxListItemWidth: 0,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Shows the drop-down.
       */
      open: function open() {
        this.placeToWidget(this._target, true);
        this.show();
      },

      /**
       * Hides the drop-down.
       */
      close: function close() {
        this.hide();
      },

      /**
       * Pre-selects the drop-down item corresponding to the given model object.
       *
       * @param modelItem {Object} Item to be pre-selected.
       */
      setPreselected: function setPreselected(modelItem) {
        this._preselected = modelItem;
        this.__ignoreListSelection = true;
        var listSelection = this.getChildControl("list").getSelection();
        var helper = new qx.data.Array([modelItem]);

        this.__synchronizeSelection(helper, listSelection);

        helper.dispose();
        this.__ignoreListSelection = false;
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "list":
            control = new qx.ui.list.List().set({
              focusable: false,
              keepFocus: true,
              keepActive: true,
              height: null,
              width: null,
              maxHeight: this._target.getMaxListHeight(),
              selectionMode: "one",
              quickSelection: true
            });
            control.getSelection().addListener("change", this._onListChangeSelection, this);
            control.addListener("tap", this._handlePointer, this);
            control.addListener("changeModel", this._onChangeModel, this);
            control.addListener("changeModelLength", this._onChangeModelLength, this);
            control.addListener("changeDelegate", this._onChangeDelegate, this);
            this.add(control, {
              flex: 1
            });
            break;
        }

        return control || qx.ui.form.core.VirtualDropDownList.prototype._createChildControlImpl.base.call(this, id, hash);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Handles the complete keyboard events dispatched on the widget.
       *
       * @param event {qx.event.type.KeySequence} The keyboard event.
       */
      _handleKeyboard: function _handleKeyboard(event) {
        if (this.isVisible() && event.getKeyIdentifier() === "Enter") {
          this.__selectPreselected();

          return;
        }

        var clone = event.clone();
        clone.setTarget(this.getChildControl("list"));
        clone.setBubbles(false);
        this.getChildControl("list").dispatchEvent(clone);
      },

      /**
       * Handles all mouse events dispatched on the widget.
       *
       * @param event {qx.event.type.Mouse} The mouse event.
       */
      _handlePointer: function _handlePointer(event) {
        this.__selectPreselected();
      },

      /**
       * Handler for the local selection change. The method is responsible for
       * the synchronization between the own selection and the selection
       * form the drop-down.
       *
       * @param event {qx.event.type.Data} The data event.
       */
      __onChangeSelection: function __onChangeSelection(event) {
        if (this.__ignoreSelection) {
          return;
        }

        var selection = this.getSelection();
        var listSelection = this.getChildControl("list").getSelection();
        this.__ignoreListSelection = true;

        this.__synchronizeSelection(selection, listSelection);

        this.__ignoreListSelection = false;
        this.__ignoreSelection = true;

        this.__synchronizeSelection(listSelection, selection);

        this.__ignoreSelection = false;
      },

      /**
       * Handler for the selection change on the list. The method is responsible
       * for the synchronization between the list selection and the own selection.
       *
       * @param event {qx.event.type.Data} The data event.
       */
      _onListChangeSelection: function _onListChangeSelection(event) {
        if (this.__ignoreListSelection) {
          return;
        }

        var listSelection = this.getChildControl("list").getSelection();

        if (this.isVisible()) {
          this.setPreselected(listSelection.getItem(0));
        } else {
          this.__ignoreSelection = true;

          this.__synchronizeSelection(listSelection, this.getSelection());

          this.__ignoreSelection = false;
        }
      },

      /**
       * Handler for the own visibility changes. The method is responsible that
       * the list selects the current selected item.
       *
       * @param event {qx.event.type.Data} The event.
       */
      __onChangeVisibility: function __onChangeVisibility(event) {
        if (this.isVisible()) {
          if (this._preselected == null) {
            var selection = this.getSelection();
            var listSelection = this.getChildControl("list").getSelection();

            this.__synchronizeSelection(selection, listSelection);
          }

          this._adjustSize();
        } else {
          this.setPreselected(null);
        }
      },

      /**
       * Handler for the model change event.
       * Called when the whole model changes, not when its length changes.
       *
       * @param event {qx.event.type.Data} The change event.
       * @protected
       */
      _onChangeModel: function _onChangeModel(event) {
        if (this.getAllowGrowDropDown()) {
          this._recalculateMaxListItemWidth();
        }

        this._adjustSize();
      },

      /**
       * Handler for the model length change event.
       * Called whenever items get added or removed from the model,
       * not when the model itself changes.
       *
       * @param event {qx.event.type.Data}
       * @protected
       */
      _onChangeModelLength: function _onChangeModelLength(event) {
        if (this.getAllowGrowDropDown()) {
          this._recalculateMaxListItemWidth();
        }

        this._adjustSize();
      },

      /**
       * Handler for the delegate change event.
       *
       * @param event {qx.event.type.Data} The change event.
       */
      _onChangeDelegate: function _onChangeDelegate(event) {
        this.getSelection().removeAll();
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applySelection: function _applySelection(value, old) {
        value.addListener("change", this.__onChangeSelection, this);

        if (old != null) {
          old.removeListener("change", this.__onChangeSelection, this);
        }

        this.__synchronizeSelection(value, this.getChildControl("list").getSelection(value));
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Helper method to select the current preselected item, also closes the
       * drop-down.
       */
      __selectPreselected: function __selectPreselected() {
        if (this._preselected != null) {
          var selection = this.getSelection();
          selection.splice(0, 1, this._preselected);
          this._preselected = null;
          this.close();
        }
      },

      /**
       * Helper method to synchronize both selection. The target selection has
       * the same selection like the source selection after the synchronization.
       *
       * @param source {qx.data.Array} The source selection.
       * @param target {qx.data.Array} The target selection.
       */
      __synchronizeSelection: function __synchronizeSelection(source, target) {
        if (source.equals(target)) {
          return;
        }

        if (source.getLength() <= 0) {
          target.removeAll();
        } else {
          // build arguments array for splice(0, target.length, source[0], source[1], ...)
          var spliceArg = [0, target.length];
          spliceArg = spliceArg.concat(source.toArray()); // use apply since it allow to use an array as the argument array
          // (calling splice directly with an array insert it in the array on which splice is called)
          // don't forget to dispose the array created by splice

          target.splice.apply(target, spliceArg).dispose();
        }
      },

      /**
       * Adjust the drop-down to the available width and height, by calling
       * {@link #_adjustWidth} and {@link #_adjustHeight}.
       */
      _adjustSize: function _adjustSize() {
        if (!this._target.getBounds()) {
          this.addListenerOnce("appear", this._adjustSize, this);
          return;
        }

        this._adjustWidth();

        this._adjustHeight();
      },

      /**
       * Adjust the drop-down to the available width. The width is limited by
       * the current width from the _target, unless allowGrowDropDown is true.
       */
      _adjustWidth: function _adjustWidth() {
        var width = this._target.getBounds().width;

        var uiList = this.getChildControl('list');

        if (this.getAllowGrowDropDown()) {
          // Let the drop-down handle its own width.
          this.setWidth(null);

          if (this.__cachedMaxListItemWidth > 0) {
            uiList.setWidth(this.__cachedMaxListItemWidth);
          } else {
            uiList.setWidth(width);
          }
        } else {
          // Make the drop-down as wide as the virtual-box that it is owned by.
          this.setWidth(width);
          uiList.resetWidth();
        }
      },

      /**
       * Adjust the drop-down to the available height. Ensure that the list
       * is never bigger that the max list height and the available space
       * in the viewport.
       */
      _adjustHeight: function _adjustHeight() {
        var availableHeight = this._getAvailableHeight();

        if (availableHeight === null) {
          return;
        }

        var maxHeight = this._target.getMaxListHeight();

        var list = this.getChildControl("list");
        var itemsHeight = list.getPane().getRowConfig().getTotalSize();

        if (maxHeight == null || itemsHeight < maxHeight) {
          maxHeight = itemsHeight;
        }

        if (maxHeight > availableHeight) {
          maxHeight = availableHeight;
        }

        var minHeight = list.getMinHeight();

        if (null !== minHeight && minHeight > maxHeight) {
          maxHeight = minHeight;
        }

        list.setMaxHeight(maxHeight);
      },

      /**
       * Calculates the available height in the viewport.
       *
       * @return {Integer|null} Available height in the viewport.
       */
      _getAvailableHeight: function _getAvailableHeight() {
        var distance = this.getLayoutLocation(this._target);

        if (!distance) {
          return null;
        }

        var viewPortHeight = qx.bom.Viewport.getHeight(); // distance to the bottom and top borders of the viewport

        var toTop = distance.top;
        var toBottom = viewPortHeight - distance.bottom;
        return toTop > toBottom ? toTop : toBottom;
      },

      /**
       * Loop over all model items to recalculate the maximum list item width.
       *
       * @protected
       */
      _recalculateMaxListItemWidth: function _recalculateMaxListItemWidth() {
        var maxWidth = 0;
        var list = this.getChildControl("list");
        var model = list.getModel();

        if (model && model.length) {
          var createWidget = qx.util.Delegate.getMethod(list.getDelegate(), "createItem");

          if (!createWidget) {
            createWidget = function createWidget() {
              return new qx.ui.form.ListItem();
            };
          }

          var tempListItem = createWidget(); // Make sure the widget has the correct padding properties.

          tempListItem.syncAppearance();
          var styles;
          var font = tempListItem.getFont();

          if (font) {
            styles = qx.theme.manager.Font.getInstance().resolve(font).getStyles();
          }

          if (!styles) {
            styles = qx.bom.Font.getDefaultStyles();
          }

          var paddingX = list.getPaddingLeft() + list.getPaddingRight() + tempListItem.getPaddingLeft() + tempListItem.getPaddingRight() + tempListItem.getMarginLeft() + tempListItem.getMarginRight();
          var label = tempListItem.getChildControl('label');

          if (label) {
            // Make sure the widget has the correct padding properties.
            label.syncAppearance();
            paddingX += label.getPaddingLeft() + label.getPaddingRight() + label.getMarginLeft() + label.getMarginRight();
          }

          model.forEach(function (item) {
            var width = 0;
            var content;

            if (typeof item === "string") {
              content = item;
            } else if (typeof item === "object" && item !== null) {
              content = item.get(list.getLabelPath());
            }

            if (content) {
              width = qx.bom.Label.getHtmlSize(content, styles, undefined).width + paddingX;

              if (width > maxWidth) {
                maxWidth = width;
              }
            }
          });
          tempListItem.dispose();
        }

        this.__cachedMaxListItemWidth = maxWidth;
      },

      /**
       * Get the cached maximum list item width.
       *
       * @return {Number}
       * @protected
       */
      _getMaxListItemWidth: function _getMaxListItemWidth() {
        return this.__cachedMaxListItemWidth;
      }
    },
    destruct: function destruct() {
      if (this.__defaultSelection) {
        this.__defaultSelection.dispose();
      }
    }
  });
  qx.ui.form.core.VirtualDropDownList.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.scroll.AbstractScrollArea": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.Pane": {
        "construct": true
      },
      "qx.bom.client.Scroll": {
        "construct": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "os.scrollBarOverlayed": {
          "construct": true,
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The Scroller wraps a {@link Pane} and provides scroll bars to interactively
   * scroll the pane's content.
   *
   * @childControl pane {qx.ui.virtual.core.Pane} Virtual pane.
   */
  qx.Class.define("qx.ui.virtual.core.Scroller", {
    extend: qx.ui.core.scroll.AbstractScrollArea,

    /**
     * @param rowCount {Integer?0} The number of rows of the virtual grid.
     * @param columnCount {Integer?0} The number of columns of the virtual grid.
     * @param cellHeight {Integer?10} The default cell height.
     * @param cellWidth {Integer?10} The default cell width.
     */
    construct: function construct(rowCount, columnCount, cellHeight, cellWidth) {
      qx.ui.core.scroll.AbstractScrollArea.constructor.call(this);
      this.__pane = new qx.ui.virtual.core.Pane(rowCount, columnCount, cellHeight, cellWidth);

      this.__pane.addListener("update", this._computeScrollbars, this);

      this.__pane.addListener("scrollX", this._onScrollPaneX, this);

      this.__pane.addListener("scrollY", this._onScrollPaneY, this);

      if (qx.core.Environment.get("os.scrollBarOverlayed")) {
        this._add(this.__pane, {
          edge: 0
        });
      } else {
        this._add(this.__pane, {
          row: 0,
          column: 0
        });
      }
    },
    members: {
      /** @type {qx.ui.virtual.core.Pane} Virtual pane. */
      __pane: null,

      /*
      ---------------------------------------------------------------------------
        ACCESSOR METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Get the scroller's virtual pane.
       *
       * @return {qx.ui.virtual.core.Pane} The scroller's pane.
       */
      getPane: function getPane() {
        return this.__pane;
      },

      /*
      ---------------------------------------------------------------------------
        CHILD CONTROL SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        if (id === "pane") {
          return this.__pane;
        } else {
          return qx.ui.virtual.core.Scroller.prototype._createChildControlImpl.base.call(this, id);
        }
      },

      /*
      ---------------------------------------------------------------------------
        ITEM LOCATION SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * NOT IMPLEMENTED
       *
       * @param item {qx.ui.core.Widget} Item to query.
       * @return {Integer} Top offset.
       * @abstract
       */
      getItemTop: function getItemTop(item) {
        throw new Error("The method 'getItemTop' is not implemented!");
      },

      /**
       * NOT IMPLEMENTED
       *
       * @param item {qx.ui.core.Widget} Item to query.
       * @return {Integer} Top offset.
       * @abstract
       */
      getItemBottom: function getItemBottom(item) {
        throw new Error("The method 'getItemBottom' is not implemented!");
      },

      /**
       * NOT IMPLEMENTED
       *
       * @param item {qx.ui.core.Widget} Item to query.
       * @return {Integer} Top offset.
       * @abstract
       */
      getItemLeft: function getItemLeft(item) {
        throw new Error("The method 'getItemLeft' is not implemented!");
      },

      /**
       * NOT IMPLEMENTED
       *
       * @param item {qx.ui.core.Widget} Item to query.
       * @return {Integer} Right offset.
       * @abstract
       */
      getItemRight: function getItemRight(item) {
        throw new Error("The method 'getItemRight' is not implemented!");
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      // overridden
      _onScrollBarX: function _onScrollBarX(e) {
        this.__pane.setScrollX(e.getData());
      },
      // overridden
      _onScrollBarY: function _onScrollBarY(e) {
        this.__pane.setScrollY(e.getData());
      }
    },
    destruct: function destruct() {
      this.__pane.dispose();

      this.__pane = null;
    }
  });
  qx.ui.virtual.core.Scroller.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.ui.virtual.selection.Row": {},
      "qx.lang.Type": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Implements the different selection modes single, multi, additive and one
   * selection with there drag and quick selection.
   *
   * Example how to use selection:
   * <pre class="javascript">
   * var rawData = [];
   * for (var i = 0; i < 2500; i++) {
   *  rawData[i] = "Item No " + i;
   * }
   *
   * var model = qx.data.marshal.Json.createModel(rawData);
   * var list = new qx.ui.list.List(model);
   *
   * // Pre-Select "Item No 20"
   * list.getSelection().push(model.getItem(20));
   *
   * // log change selection
   * list.getSelection().addListener("change", function(e) {
   *   this.debug("Selection: " + list.getSelection().getItem(0));
   * }, this);
   * </pre>
   *
   * @internal
   */
  qx.Mixin.define("qx.ui.virtual.selection.MModel", {
    construct: function construct() {
      this._initSelectionManager();

      this.__selection = new qx.data.Array();

      this.__selection.addListener("change", this._onChangeSelection, this);

      this._applySelection(this.__selection, null);
    },
    properties: {
      /** Current selected items */

      /* psuedo property - implemented manually in code below
      selection :
      {
        check : "qx.data.Array",
        event : "changeSelection",
        apply : "_applySelection",
        nullable : false,
        deferredInit : true
      },
      */

      /**
       * The selection mode to use.
       *
       * For further details please have a look at:
       * {@link qx.ui.core.selection.Abstract#mode}
       */
      selectionMode: {
        check: ["single", "multi", "additive", "one"],
        init: "single",
        apply: "_applySelectionMode"
      },

      /**
       * Enable drag selection (multi selection of items through
       * dragging the pointer in pressed states).
       *
       * Only possible for the selection modes <code>multi</code> and <code>additive</code>
       */
      dragSelection: {
        check: "Boolean",
        init: false,
        apply: "_applyDragSelection"
      },

      /**
       * Enable quick selection mode, where no tap is needed to change the selection.
       *
       * Only possible for the modes <code>single</code> and <code>one</code>.
       */
      quickSelection: {
        check: "Boolean",
        init: false,
        apply: "_applyQuickSelection"
      }
    },
    events: {
      /**
       * This event is fired as soon as the content of the selection property changes, but
       * this is not equal to the change of the selection of the widget. If the selection
       * of the widget changes, the content of the array stored in the selection property
       * changes. This means you have to listen to the change event of the selection array
       * to get an event as soon as the user changes the selected item.
       * <pre class="javascript">obj.getSelection().addListener("change", listener, this);</pre>
       */
      "changeSelection": "qx.event.type.Data",

      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data"
    },
    members: {
      /** @type {qx.ui.virtual.selection.Row} selection manager */
      _manager: null,

      /** @type {Boolean} flag to ignore the selection change from {@link #selection} */
      __ignoreChangeSelection: false,

      /** @type {Boolean} flag to ignore the selection change from <code>_manager</code> */
      __ignoreManagerChangeSelection: false,
      __selection: null,

      /**
       * setValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @param selection {qx.data.IListData|null} List data to select as value.
       * @return {null} The status of this operation.
       */
      setValue: function setValue(selection) {
        if (null === selection) {
          this.resetSelection();
        } else {
          this.setSelection(selection);
        }

        return null;
      },

      /**
       * getValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @return {qx.data.IListData} The current selection.
       */
      getValue: function getValue() {
        return this.getSelection();
      },

      /**
       * resetValue implements part of the {@link qx.ui.form.IField} interface.
       */
      resetValue: function resetValue() {
        this.resetSelection();
      },

      /**
       * Initialize the selection manager with his delegate.
       */
      _initSelectionManager: function _initSelectionManager() {
        var self = this;
        var selectionDelegate = {
          isItemSelectable: function isItemSelectable(row) {
            return self._provider.isSelectable(row);
          },
          styleSelectable: function styleSelectable(row, type, wasAdded) {
            if (type != "selected") {
              return;
            }

            if (wasAdded) {
              self._provider.styleSelectabled(row);
            } else {
              self._provider.styleUnselectabled(row);
            }
          }
        };
        this._manager = new qx.ui.virtual.selection.Row(this.getPane(), selectionDelegate);

        this._manager.attachPointerEvents(this.getPane());

        this._manager.attachKeyEvents(this);

        this._manager.addListener("changeSelection", this._onManagerChangeSelection, this);
      },

      /**
       * Determines, if automatically scrolling of selected item is active.
       * Set <code>false</code> to suspend auto scrolling.
       *
       * @param value {Boolean} Set <code>false</code> to suspend auto scrolling.
       */
      setAutoScrollIntoView: function setAutoScrollIntoView(value) {
        this._manager._autoScrollIntoView = value;
      },

      /**
       * Returns true, if automatically scrolling of selected item is active.
       *
       * @return {Boolean} Returns <code>false</code> if auto scrolling is suspended.
       */
      getAutoScrollIntoView: function getAutoScrollIntoView() {
        return this._manager._autoScrollIntoView;
      },

      /**
       * Method to update the selection, this method can be used when the model has
       * changes.
       */
      _updateSelection: function _updateSelection() {
        if (this._manager == null) {
          return;
        }

        this._onChangeSelection();
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */

      /**
       * Setter for selection property; takes the selection on, and does not change the
       * array instance in `this.selection`
       * 
       * @param value {qx.data.Array} the new selection
       */
      setSelection: function setSelection(value) {
        if (value) {
          this.__selection.replace(value);
        } else {
          this.__selection.removeAll();
        }
      },

      /**
       * Getter for selection property
       * 
       * @return {qx.data.Array}
       */
      getSelection: function getSelection() {
        return this.__selection;
      },

      /**
       * Reset for selection property
       */
      resetSelection: function resetSelection() {
        this.__selection.removeAll();
      },

      /**
       * Init for selection property; takes the selection on, and does not change the
       * array instance in `this.selection`
       * 
       * @param value {qx.data.Array} the new selection
       */
      initSelection: function initSelection(value) {
        this.warn("Using initSelection on " + this.classname + " is probably not what you intended - the selection instance does not change");
        this.setSelection(value);
      },

      /**
       * Apply method for selection property
       * 
       * @param value {qx.data.Array} new value
       * @param old {qx.data.Array} old value
       */
      _applySelection: function _applySelection(value, old) {
        this._onChangeSelection();
      },
      // apply method
      _applySelectionMode: function _applySelectionMode(value, old) {
        this._manager.setMode(value);
      },
      // apply method
      _applyDragSelection: function _applyDragSelection(value, old) {
        this._manager.setDrag(value);
      },
      // apply method
      _applyQuickSelection: function _applyQuickSelection(value, old) {
        this._manager.setQuick(value);
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the internal selection change {@link #selection}.
       *
       * @param e {qx.event.type.Data} the change event.
       */
      _onChangeSelection: function _onChangeSelection(e) {
        if (this.__ignoreManagerChangeSelection == true) {
          return;
        }

        this.__ignoreChangeSelection = true;
        var selection = this.getSelection();
        var newSelection = [];

        for (var i = 0; i < selection.getLength(); i++) {
          var item = selection.getItem(i);

          var selectables = this._getSelectables();

          var index = -1;

          if (selectables != null) {
            index = selectables.indexOf(item);
          }

          var row = this._reverseLookup(index);

          if (row >= 0) {
            newSelection.push(row);
          }
        }

        if (this._beforeApplySelection != null && qx.lang.Type.isFunction(this._beforeApplySelection)) {
          this._beforeApplySelection(newSelection);
        }

        try {
          if (!qx.lang.Array.equals(newSelection, this._manager.getSelection())) {
            this._manager.replaceSelection(newSelection);
          }
        } catch (ex) {
          this._manager.selectItem(newSelection[newSelection.length - 1]);
        }

        this.__synchronizeSelection();

        if (this._afterApplySelection != null && qx.lang.Type.isFunction(this._afterApplySelection)) {
          this._afterApplySelection();
        }

        this.__ignoreChangeSelection = false;
      },

      /**
       * Event handler for the selection change from the <code>_manager</code>.
       *
       * @param e {qx.event.type.Data} the change event.
       */
      _onManagerChangeSelection: function _onManagerChangeSelection(e) {
        if (this.__ignoreChangeSelection == true) {
          return;
        }

        this.__ignoreManagerChangeSelection = true;

        this.__synchronizeSelection();

        this.__ignoreManagerChangeSelection = false;
        this.fireDataEvent("changeValue", e.getData(), e.getOldData());
      },

      /**
       * Synchronized the selection form the manager with the local one.
       */
      __synchronizeSelection: function __synchronizeSelection() {
        if (this.__isSelectionEquals()) {
          return;
        }

        var managerSelection = this._manager.getSelection();

        var newSelection = [];

        for (var i = 0; i < managerSelection.length; i++) {
          var item = this._getDataFromRow(managerSelection[i]);

          if (item != null) {
            newSelection.push(item);
          }
        }

        this.__replaceSelection(newSelection);
      },

      /**
       * Replace the current selection with the passed selection Array.
       *
       * @param newSelection {qx.data.Array} The new selection.
       */
      __replaceSelection: function __replaceSelection(newSelection) {
        var selection = this.getSelection();

        if (newSelection.length > 0) {
          var args = [0, selection.getLength()];
          args = args.concat(newSelection); // dispose data array returned by splice to avoid memory leak

          var temp = selection.splice.apply(selection, args);
          temp.dispose();
        } else {
          selection.removeAll();
        }
      },

      /**
       * Checks whether the local and the manager selection are equal.
       *
       * @return {Boolean} <code>true</code> if the selections are equal,
       *   <code>false</code> otherwise.
       */
      __isSelectionEquals: function __isSelectionEquals() {
        var selection = this.getSelection();

        var managerSelection = this._manager.getSelection();

        if (selection.getLength() !== managerSelection.length) {
          return false;
        }

        for (var i = 0; i < selection.getLength(); i++) {
          var item = selection.getItem(i);

          var selectables = this._getSelectables();

          var index = -1;

          if (selectables != null) {
            index = selectables.indexOf(item);
          }

          var row = this._reverseLookup(index);

          if (row !== managerSelection[i]) {
            return false;
          }

          ;
        }

        return true;
      },

      /**
       * Helper Method to select default item.
       */
      _applyDefaultSelection: function _applyDefaultSelection() {
        if (this._manager != null) {
          this._manager._applyDefaultSelection();
        }
      }
    },
    destruct: function destruct() {
      this._manager.dispose();

      this._manager = null;

      if (this.__selection) {
        this.__selection.dispose();
      }
    }
  });
  qx.ui.virtual.selection.MModel.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.Axis": {
        "construct": true
      },
      "qx.ui.container.Composite": {
        "construct": true
      },
      "qx.ui.virtual.core.ILayer": {},
      "qx.event.Timer": {},
      "qx.ui.virtual.core.CellEvent": {},
      "qx.lang.Array": {},
      "qx.ui.core.queue.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The Pane provides a window of a larger virtual grid.
   *
   * The actual rendering is performed by one or several layers ({@link ILayer}.
   * The pane computes, which cells of the virtual area is visible and instructs
   * the layers to render these cells.
   */
  qx.Class.define("qx.ui.virtual.core.Pane", {
    extend: qx.ui.core.Widget,

    /**
     * @param rowCount {Integer?0} The number of rows of the virtual grid.
     * @param columnCount {Integer?0} The number of columns of the virtual grid.
     * @param cellHeight {Integer?10} The default cell height.
     * @param cellWidth {Integer?10} The default cell width.
     */
    construct: function construct(rowCount, columnCount, cellHeight, cellWidth) {
      qx.ui.core.Widget.constructor.call(this);
      this.__rowConfig = new qx.ui.virtual.core.Axis(cellHeight, rowCount);
      this.__columnConfig = new qx.ui.virtual.core.Axis(cellWidth, columnCount);
      this.__scrollTop = 0;
      this.__scrollLeft = 0;
      this.__paneHeight = 0;
      this.__paneWidth = 0;
      this.__layerWindow = {};
      this.__jobs = {}; // create layer container. The container does not have a layout manager
      // layers are positioned using "setUserBounds"

      this.__layerContainer = new qx.ui.container.Composite();

      this.__layerContainer.setUserBounds(0, 0, 0, 0);

      this._add(this.__layerContainer);

      this.__layers = [];

      this.__rowConfig.addListener("change", this.fullUpdate, this);

      this.__columnConfig.addListener("change", this.fullUpdate, this);

      this.addListener("resize", this._onResize, this);
      this.addListenerOnce("appear", this._onAppear, this);
      this.addListener("pointerdown", this._onPointerDown, this);
      this.addListener("tap", this._onTap, this);
      this.addListener("dbltap", this._onDbltap, this);
      this.addListener("contextmenu", this._onContextmenu, this);
    },
    events: {
      /** Fired if a cell is tapped. */
      cellTap: "qx.ui.virtual.core.CellEvent",

      /** Fired if a cell is right-clicked. */
      cellContextmenu: "qx.ui.virtual.core.CellEvent",

      /** Fired if a cell is double-tapped. */
      cellDbltap: "qx.ui.virtual.core.CellEvent",

      /** Fired on resize of either the container or the (virtual) content. */
      update: "qx.event.type.Event",

      /** Fired if the pane is scrolled horizontally. */
      scrollX: "qx.event.type.Data",

      /** Fired if the pane is scrolled vertically. */
      scrollY: "qx.event.type.Data"
    },
    properties: {
      // overridden
      width: {
        refine: true,
        init: 400
      },
      // overridden
      height: {
        refine: true,
        init: 300
      }
    },
    members: {
      __rowConfig: null,
      __columnConfig: null,
      __scrollTop: null,
      __scrollLeft: null,
      __paneHeight: null,
      __paneWidth: null,
      __layerWindow: null,
      __jobs: null,
      __layerContainer: null,
      __layers: null,
      __dontFireUpdate: null,
      __columnSizes: null,
      __rowSizes: null,
      __pointerDownCoords: null,

      /*
      ---------------------------------------------------------------------------
        ACCESSOR METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Get the axis object, which defines the row numbers and the row sizes.
       *
       * @return {qx.ui.virtual.core.Axis} The row configuration.
       */
      getRowConfig: function getRowConfig() {
        return this.__rowConfig;
      },

      /**
       * Get the axis object, which defines the column numbers and the column sizes.
       *
       * @return {qx.ui.virtual.core.Axis} The column configuration.
       */
      getColumnConfig: function getColumnConfig() {
        return this.__columnConfig;
      },

      /*
      ---------------------------------------------------------------------------
        LAYER MANAGEMENT
      ---------------------------------------------------------------------------
      */

      /**
       * Returns an array containing the layer container.
       *
       * @return {Object[]} The layer container array.
       */
      getChildren: function getChildren() {
        return [this.__layerContainer];
      },

      /**
       * Add a layer to the layer container.
       *
       * @param layer {qx.ui.virtual.core.ILayer} The layer to add.
       */
      addLayer: function addLayer(layer) {
        {
          this.assertInterface(layer, qx.ui.virtual.core.ILayer);
        }

        this.__layers.push(layer);

        layer.setUserBounds(0, 0, 0, 0);

        this.__layerContainer.add(layer);
      },

      /**
       * Get a list of all layers.
       *
       * @return {qx.ui.virtual.core.ILayer[]} List of the pane's layers.
       */
      getLayers: function getLayers() {
        return this.__layers;
      },

      /**
       * Get a list of all visible layers.
       *
       * @return {qx.ui.virtual.core.ILayer[]} List of the pane's visible layers.
       */
      getVisibleLayers: function getVisibleLayers() {
        var layers = [];

        for (var i = 0; i < this.__layers.length; i++) {
          var layer = this.__layers[i];

          if (layer.isVisible()) {
            layers.push(layer);
          }
        }

        return layers;
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * The maximum horizontal scroll position.
       *
       * @return {Integer} Maximum horizontal scroll position.
       */
      getScrollMaxX: function getScrollMaxX() {
        var paneSize = this.getInnerSize();

        if (paneSize) {
          return Math.max(0, this.__columnConfig.getTotalSize() - paneSize.width);
        }

        return 0;
      },

      /**
       * The maximum vertical scroll position.
       *
       * @return {Integer} Maximum vertical scroll position.
       */
      getScrollMaxY: function getScrollMaxY() {
        var paneSize = this.getInnerSize();

        if (paneSize) {
          return Math.max(0, this.__rowConfig.getTotalSize() - paneSize.height);
        }

        return 0;
      },

      /**
       * Scrolls the content to the given left coordinate.
       *
       * @param value {Integer} The vertical position to scroll to.
       */
      setScrollY: function setScrollY(value) {
        var max = this.getScrollMaxY();

        if (value < 0) {
          value = 0;
        } else if (value > max) {
          value = max;
        }

        if (this.__scrollTop !== value) {
          var old = this.__scrollTop;
          this.__scrollTop = value;

          this._deferredUpdateScrollPosition();

          this.fireDataEvent("scrollY", value, old);
        }
      },

      /**
       * Returns the vertical scroll offset.
       *
       * @return {Integer} The vertical scroll offset.
       */
      getScrollY: function getScrollY() {
        return this.__scrollTop;
      },

      /**
       * Scrolls the content to the given top coordinate.
       *
       * @param value {Integer} The horizontal position to scroll to.
       */
      setScrollX: function setScrollX(value) {
        var max = this.getScrollMaxX();

        if (value < 0) {
          value = 0;
        } else if (value > max) {
          value = max;
        }

        if (value !== this.__scrollLeft) {
          var old = this.__scrollLeft;
          this.__scrollLeft = value;

          this._deferredUpdateScrollPosition();

          this.fireDataEvent("scrollX", value, old);
        }
      },

      /**
       * Returns the horizontal scroll offset.
       *
       * @return {Integer} The horizontal scroll offset.
       */
      getScrollX: function getScrollX() {
        return this.__scrollLeft;
      },

      /**
       * The (virtual) size of the content.
       *
       * @return {Map} Size of the content (keys: <code>width</code> and
       *     <code>height</code>).
       */
      getScrollSize: function getScrollSize() {
        return {
          width: this.__columnConfig.getTotalSize(),
          height: this.__rowConfig.getTotalSize()
        };
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL INTO VIEW SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Scrolls a row into the visible area of the pane.
       *
       * @param row {Integer} The row's index.
       */
      scrollRowIntoView: function scrollRowIntoView(row) {
        var bounds = this.getBounds();

        if (!bounds) {
          this.addListenerOnce("appear", function () {
            // It's important that the registered events are first dispatched.
            qx.event.Timer.once(function () {
              this.scrollRowIntoView(row);
            }, this, 0);
          }, this);
          return;
        }

        var itemTop = this.__rowConfig.getItemPosition(row);

        var itemBottom = itemTop + this.__rowConfig.getItemSize(row);

        var scrollTop = this.getScrollY();

        if (itemTop < scrollTop) {
          this.setScrollY(itemTop);
        } else if (itemBottom > scrollTop + bounds.height) {
          this.setScrollY(itemBottom - bounds.height);
        }
      },

      /**
       * Scrolls a column into the visible area of the pane.
       *
       * @param column {Integer} The column's index.
       */
      scrollColumnIntoView: function scrollColumnIntoView(column) {
        var bounds = this.getBounds();

        if (!bounds) {
          this.addListenerOnce("appear", function () {
            // It's important that the registered events are first dispatched.
            qx.event.Timer.once(function () {
              this.scrollColumnIntoView(column);
            }, this, 0);
          }, this);
          return;
        }

        var itemLeft = this.__columnConfig.getItemPosition(column);

        var itemRight = itemLeft + this.__columnConfig.getItemSize(column);

        var scrollLeft = this.getScrollX();

        if (itemLeft < scrollLeft) {
          this.setScrollX(itemLeft);
        } else if (itemRight > scrollLeft + bounds.width) {
          this.setScrollX(itemRight - bounds.width);
        }
      },

      /**
       * Scrolls a grid cell into the visible area of the pane.
       *
       * @param row {Integer} The cell's row index.
       * @param column {Integer} The cell's column index.
       */
      scrollCellIntoView: function scrollCellIntoView(column, row) {
        var bounds = this.getBounds();

        if (!bounds) {
          this.addListenerOnce("appear", function () {
            // It's important that the registered events are first dispatched.
            qx.event.Timer.once(function () {
              this.scrollCellIntoView(column, row);
            }, this, 0);
          }, this);
          return;
        }

        this.scrollColumnIntoView(column);
        this.scrollRowIntoView(row);
      },

      /*
      ---------------------------------------------------------------------------
        CELL SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Get the grid cell at the given absolute document coordinates. This method
       * can be used to convert the pointer position returned by
       * {@link qx.event.type.Pointer#getDocumentLeft} and
       * {@link qx.event.type.Pointer#getDocumentLeft} into cell coordinates.
       *
       * @param documentX {Integer} The x coordinate relative to the viewport
       *    origin.
       * @param documentY {Integer} The y coordinate relative to the viewport
       *    origin.
       * @return {Map|null} A map containing the <code>row</code> and <code>column</code>
       *    of the found cell. If the coordinate is outside of the pane's bounds
       *    or there is no cell at the coordinate <code>null</code> is returned.
       */
      getCellAtPosition: function getCellAtPosition(documentX, documentY) {
        var rowData, columnData;
        var paneLocation = this.getContentLocation();

        if (!paneLocation || documentY < paneLocation.top || documentY >= paneLocation.bottom || documentX < paneLocation.left || documentX >= paneLocation.right) {
          return null;
        }

        rowData = this.__rowConfig.getItemAtPosition(this.getScrollY() + documentY - paneLocation.top);
        columnData = this.__columnConfig.getItemAtPosition(this.getScrollX() + documentX - paneLocation.left);

        if (!rowData || !columnData) {
          return null;
        }

        return {
          row: rowData.index,
          column: columnData.index
        };
      },

      /*
      ---------------------------------------------------------------------------
        PREFETCH SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Increase the layers width beyond the needed width to improve
       * horizontal scrolling. The layers are only resized if invisible parts
       * left/right of the pane window are smaller than minLeft/minRight.
       *
       * @param minLeft {Integer} Only prefetch if the invisible part left of the
       *    pane window if smaller than this (pixel) value.
       * @param maxLeft {Integer} The amount of pixel the layers should reach
       *    left of the pane window.
       * @param minRight {Integer} Only prefetch if the invisible part right of the
       *    pane window if smaller than this (pixel) value.
       * @param maxRight {Integer} The amount of pixel the layers should reach
       *    right of the pane window.
       */
      prefetchX: function prefetchX(minLeft, maxLeft, minRight, maxRight) {
        var layers = this.getVisibleLayers();

        if (layers.length == 0) {
          return;
        }

        var bounds = this.getBounds();

        if (!bounds) {
          return;
        }

        var paneRight = this.__scrollLeft + bounds.width;
        var rightAvailable = this.__paneWidth - paneRight;

        if (this.__scrollLeft - this.__layerWindow.left < Math.min(this.__scrollLeft, minLeft) || this.__layerWindow.right - paneRight < Math.min(rightAvailable, minRight)) {
          var left = Math.min(this.__scrollLeft, maxLeft);
          var right = Math.min(rightAvailable, maxRight);

          this._setLayerWindow(layers, this.__scrollLeft - left, this.__scrollTop, bounds.width + left + right, bounds.height, false);
        }
      },

      /**
       * Increase the layers height beyond the needed height to improve
       * vertical scrolling. The layers are only resized if invisible parts
       * above/below the pane window are smaller than minAbove/minBelow.
       *
       * @param minAbove {Integer} Only prefetch if the invisible part above the
       *    pane window if smaller than this (pixel) value.
       * @param maxAbove {Integer} The amount of pixel the layers should reach
       *    above the pane window.
       * @param minBelow {Integer} Only prefetch if the invisible part below the
       *    pane window if smaller than this (pixel) value.
       * @param maxBelow {Integer} The amount of pixel the layers should reach
       *    below the pane window.
       */
      prefetchY: function prefetchY(minAbove, maxAbove, minBelow, maxBelow) {
        var layers = this.getVisibleLayers();

        if (layers.length == 0) {
          return;
        }

        var bounds = this.getBounds();

        if (!bounds) {
          return;
        }

        var paneBottom = this.__scrollTop + bounds.height;
        var belowAvailable = this.__paneHeight - paneBottom;

        if (this.__scrollTop - this.__layerWindow.top < Math.min(this.__scrollTop, minAbove) || this.__layerWindow.bottom - paneBottom < Math.min(belowAvailable, minBelow)) {
          var above = Math.min(this.__scrollTop, maxAbove);
          var below = Math.min(belowAvailable, maxBelow);

          this._setLayerWindow(layers, this.__scrollLeft, this.__scrollTop - above, bounds.width, bounds.height + above + below, false);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENER
      ---------------------------------------------------------------------------
      */

      /**
       * Resize event handler.
       *
       * Updates the visible window.
       */
      _onResize: function _onResize() {
        if (this.getContentElement().getDomElement()) {
          this.__dontFireUpdate = true;

          this._updateScrollPosition();

          this.__dontFireUpdate = null;
          this.fireEvent("update");
        }
      },

      /**
       * Resize event handler. Do a full update on first appear.
       */
      _onAppear: function _onAppear() {
        this.fullUpdate();
      },

      /**
       * Event listener for pointer down. Remembers cell position to prevent pointer event when cell position change.
       *
       * @param e {qx.event.type.Pointer} The incoming pointer event.
       */
      _onPointerDown: function _onPointerDown(e) {
        this.__pointerDownCoords = this.getCellAtPosition(e.getDocumentLeft(), e.getDocumentTop());
      },

      /**
       * Event listener for pointer taps. Fires an cellTap event.
       *
       * @param e {qx.event.type.Pointer} The incoming pointer event.
       */
      _onTap: function _onTap(e) {
        this.__handlePointerCellEvent(e, "cellTap");
      },

      /**
       * Event listener for context menu taps. Fires an cellContextmenu event.
       *
       * @param e {qx.event.type.Pointer} The incoming pointer event.
       */
      _onContextmenu: function _onContextmenu(e) {
        this.__handlePointerCellEvent(e, "cellContextmenu");
      },

      /**
       * Event listener for double taps. Fires an cellDbltap event.
       *
       * @param e {qx.event.type.Pointer} The incoming pointer event.
       */
      _onDbltap: function _onDbltap(e) {
        this.__handlePointerCellEvent(e, "cellDbltap");
      },

      /**
       * Fixed scrollbar position whenever it is out of range
       * it can happen when removing an item from the list reducing
       * the max value for scrollY #8976
       */
      _checkScrollBounds: function _checkScrollBounds() {
        var maxx = this.getScrollMaxX();
        var maxy = this.getScrollMaxY();

        if (this.__scrollLeft < 0) {
          this.__scrollLeft = 0;
        } else if (this.__scrollLeft > maxx) {
          this.__scrollLeft = maxx;
        }

        if (this.__scrollTop < 0) {
          this.__scrollTop = 0;
        } else if (this.__scrollTop > maxy) {
          this.__scrollTop = maxy;
        }
      },

      /**
       * Converts a pointer event into a cell event and fires the cell event if the
       * pointer is over a cell.
       *
       * @param e {qx.event.type.Pointer} The pointer event.
       * @param cellEventType {String} The name of the cell event to fire.
       */
      __handlePointerCellEvent: function __handlePointerCellEvent(e, cellEventType) {
        var coords = this.getCellAtPosition(e.getDocumentLeft(), e.getDocumentTop());

        if (!coords) {
          return;
        }

        var pointerDownCoords = this.__pointerDownCoords;

        if (pointerDownCoords == null || pointerDownCoords.row !== coords.row || pointerDownCoords.column !== coords.column) {
          return;
        }

        this.fireNonBubblingEvent(cellEventType, qx.ui.virtual.core.CellEvent, [this, e, coords.row, coords.column]);
      },

      /*
      ---------------------------------------------------------------------------
        PANE UPDATE
      ---------------------------------------------------------------------------
      */
      // overridden
      syncWidget: function syncWidget(jobs) {
        if (this.__jobs._fullUpdate) {
          this._checkScrollBounds();

          this._fullUpdate();
        } else if (this.__jobs._updateScrollPosition) {
          this._checkScrollBounds();

          this._updateScrollPosition();
        }

        this.__jobs = {};
      },

      /**
       * Sets the size of the layers to contain the cells at the pixel position
       * "left/right" up to "left+minHeight/right+minHeight". The offset of the
       * layer container is adjusted to respect the pane's scroll top and scroll
       * left values.
       *
       * @param layers {qx.ui.virtual.core.ILayer[]} List of layers to update.
       * @param left {Integer} Maximum left pixel coordinate of the layers.
       * @param top {Integer} Maximum top pixel coordinate of the layers.
       * @param minWidth {Integer} The minimum end coordinate of the layers will
       *    be larger than <code>left+minWidth</code>.
       * @param minHeight {Integer} The minimum end coordinate of the layers will
       *    be larger than <code>top+minHeight</code>.
       * @param doFullUpdate {Boolean?false} Whether a full update on the layer
       *    should be performed of if only the layer window should be updated.
       */
      _setLayerWindow: function _setLayerWindow(layers, left, top, minWidth, minHeight, doFullUpdate) {
        var rowCellData = this.__rowConfig.getItemAtPosition(top);

        if (rowCellData) {
          var firstRow = rowCellData.index;

          var rowSizes = this.__rowConfig.getItemSizes(firstRow, minHeight + rowCellData.offset);

          var layerHeight = qx.lang.Array.sum(rowSizes);
          var layerTop = top - rowCellData.offset;
          var layerBottom = top - rowCellData.offset + layerHeight;
        } else {
          var firstRow = 0;
          var rowSizes = [];
          var layerHeight = 0;
          var layerTop = 0;
          var layerBottom = 0;
        }

        var columnCellData = this.__columnConfig.getItemAtPosition(left);

        if (columnCellData) {
          var firstColumn = columnCellData.index;

          var columnSizes = this.__columnConfig.getItemSizes(firstColumn, minWidth + columnCellData.offset);

          var layerWidth = qx.lang.Array.sum(columnSizes);
          var layerLeft = left - columnCellData.offset;
          var layerRight = left - columnCellData.offset + layerWidth;
        } else {
          var firstColumn = 0;
          var columnSizes = [];
          var layerWidth = 0;
          var layerLeft = 0;
          var layerRight = 0;
        }

        this.__layerWindow = {
          top: layerTop,
          bottom: layerBottom,
          left: layerLeft,
          right: layerRight
        };

        this.__layerContainer.setUserBounds((this.getPaddingLeft() || 0) + (this.__layerWindow.left - this.__scrollLeft), (this.getPaddingTop() || 0) + (this.__layerWindow.top - this.__scrollTop), layerWidth, layerHeight);

        this.__columnSizes = columnSizes;
        this.__rowSizes = rowSizes;

        for (var i = 0; i < this.__layers.length; i++) {
          var layer = this.__layers[i];
          layer.setUserBounds(0, 0, layerWidth, layerHeight);

          if (doFullUpdate) {
            layer.fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
          } else {
            layer.updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes);
          }
        }
      },

      /**
       * Check whether the pane was resized and fire an {@link #update} event if
       * it was.
       */
      __checkPaneResize: function __checkPaneResize() {
        if (this.__dontFireUpdate) {
          return;
        }

        var scrollSize = this.getScrollSize();

        if (this.__paneHeight !== scrollSize.height || this.__paneWidth !== scrollSize.width) {
          this.__paneHeight = scrollSize.height;
          this.__paneWidth = scrollSize.width;
          this.fireEvent("update");
        }
      },

      /**
       * Schedule a full update on all visible layers.
       */
      fullUpdate: function fullUpdate() {
        this.__jobs._fullUpdate = 1;
        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * Whether a full update is scheduled.
       *
       * @return {Boolean} Whether a full update is scheduled.
       */
      isUpdatePending: function isUpdatePending() {
        return !!this.__jobs._fullUpdate;
      },

      /**
       * Perform a full update on all visible layers. All cached data will be
       * discarded.
       */
      _fullUpdate: function _fullUpdate() {
        var layers = this.getVisibleLayers();

        if (layers.length == 0) {
          this.__checkPaneResize();

          return;
        }

        var bounds = this.getBounds();

        if (!bounds) {
          return; // the pane has not yet been rendered -> wait for the appear event
        }

        this._setLayerWindow(layers, this.__scrollLeft, this.__scrollTop, bounds.width, bounds.height, true);

        this.__checkPaneResize();
      },

      /**
       * Schedule an update the visible window of the grid according to the top
       * and left scroll positions.
       */
      _deferredUpdateScrollPosition: function _deferredUpdateScrollPosition() {
        this.__jobs._updateScrollPosition = 1;
        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * Update the visible window of the grid according to the top and left scroll
       * positions.
       */
      _updateScrollPosition: function _updateScrollPosition() {
        var layers = this.getVisibleLayers();

        if (layers.length == 0) {
          this.__checkPaneResize();

          return;
        }

        var bounds = this.getBounds();

        if (!bounds) {
          return; // the pane has not yet been rendered -> wait for the appear event
        } // the visible window of the virtual coordinate space


        var paneWindow = {
          top: this.__scrollTop,
          bottom: this.__scrollTop + bounds.height,
          left: this.__scrollLeft,
          right: this.__scrollLeft + bounds.width
        };

        if (this.__layerWindow.top <= paneWindow.top && this.__layerWindow.bottom >= paneWindow.bottom && this.__layerWindow.left <= paneWindow.left && this.__layerWindow.right >= paneWindow.right) {
          // only update layer container offset
          this.__layerContainer.setUserBounds((this.getPaddingLeft() || 0) + (this.__layerWindow.left - paneWindow.left), (this.getPaddingTop() || 0) + (this.__layerWindow.top - paneWindow.top), this.__layerWindow.right - this.__layerWindow.left, this.__layerWindow.bottom - this.__layerWindow.top);
        } else {
          this._setLayerWindow(layers, this.__scrollLeft, this.__scrollTop, bounds.width, bounds.height, false);
        }

        this.__checkPaneResize();
      }
    },
    destruct: function destruct() {
      this._disposeArray("__layers");

      this._disposeObjects("__rowConfig", "__columnConfig", "__layerContainer");

      this.__layerWindow = this.__jobs = this.__columnSizes = this.__rowSizes = null;
    }
  });
  qx.ui.virtual.core.Pane.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.core.Scroller": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.selection.MModel": {
        "require": true
      },
      "qx.data.controller.ISelection": {
        "require": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.ui.virtual.layer.Row": {},
      "qx.ui.list.provider.WidgetProvider": {},
      "qx.event.type.Data": {},
      "qx.util.DeferredCall": {},
      "qx.util.Delegate": {},
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The <code>qx.ui.list.List</code> is based on the virtual infrastructure and
   * supports filtering, sorting, grouping, single selection, multi selection,
   * data binding and custom rendering.
   *
   * Using the virtual infrastructure has considerable advantages when there is a
   * huge amount of model items to render because the virtual infrastructure only
   * creates widgets for visible items and reuses them. This saves both creation
   * time and memory.
   *
   * With the {@link qx.ui.list.core.IListDelegate} interface it is possible
   * to configure the list's behavior (item and group renderer configuration,
   * filtering, sorting, grouping, etc.).
   *
   * Here's an example of how to use the widget:
   * <pre class="javascript">
   * //create the model data
   * var rawData = [];
   * for (var i = 0; i < 2500; i++) {
   *  rawData[i] = "Item No " + i;
   * }
   * var model = qx.data.marshal.Json.createModel(rawData);
   *
   * //create the list
   * var list = new qx.ui.list.List(model);
   *
   * //configure the lists's behavior
   * var delegate = {
   *   sorter : function(a, b) {
   *     return a > b ? 1 : a < b ? -1 : 0;
   *   }
   * };
   * list.setDelegate(delegate);
   *
   * //Pre-Select "Item No 20"
   * list.getSelection().push(model.getItem(20));
   *
   * //log selection changes
   * list.getSelection().addListener("change", function(e) {
   *   this.debug("Selection: " + list.getSelection().getItem(0));
   * }, this);
   * </pre>
   *
   * @childControl row-layer {qx.ui.virtual.layer.Row} layer for all rows
   */
  qx.Class.define("qx.ui.list.List", {
    extend: qx.ui.virtual.core.Scroller,
    include: [qx.ui.virtual.selection.MModel],
    implement: qx.data.controller.ISelection,

    /**
     * Creates the <code>qx.ui.list.List</code> with the passed model.
     *
     * @param model {qx.data.IListData|null?} model for the list.
     */
    construct: function construct(model) {
      qx.ui.virtual.core.Scroller.constructor.call(this, 0, 1, 20, 100);

      this._init();

      this.__defaultGroups = new qx.data.Array();
      this.initGroups(this.__defaultGroups);

      if (model != null) {
        this.initModel(model);
      }

      this.initItemHeight();
    },
    events: {
      /**
       * Fired when the length of {@link #model} changes.
       */
      "changeModelLength": "qx.event.type.Data"
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "virtual-list"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 100
      },
      // overridden
      height: {
        refine: true,
        init: 200
      },

      /** Data array containing the data which should be shown in the list. */
      model: {
        check: "qx.data.IListData",
        apply: "_applyModel",
        event: "changeModel",
        nullable: true,
        deferredInit: true
      },

      /** Default item height */
      itemHeight: {
        check: "Integer",
        init: 25,
        apply: "_applyRowHeight",
        themeable: true
      },

      /** Group item height */
      groupItemHeight: {
        check: "Integer",
        init: null,
        nullable: true,
        apply: "_applyGroupRowHeight",
        themeable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as a label. This is only needed if objects are stored in the
       * model.
       */
      labelPath: {
        check: "String",
        apply: "_applyLabelPath",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as an icon. This is only needed if objects are stored in the
       * model and icons should be displayed.
       */
      iconPath: {
        check: "String",
        apply: "_applyIconPath",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as a group label. This is only needed if objects are stored in the
       * model.
       */
      groupLabelPath: {
        check: "String",
        apply: "_applyGroupLabelPath",
        nullable: true
      },

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      labelOptions: {
        apply: "_applyLabelOptions",
        nullable: true
      },

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      iconOptions: {
        apply: "_applyIconOptions",
        nullable: true
      },

      /**
       * A map containing the options for the group label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      groupLabelOptions: {
        apply: "_applyGroupLabelOptions",
        nullable: true
      },

      /**
       * Delegation object which can have one or more functions defined by the
       * {@link qx.ui.list.core.IListDelegate} interface.
       */
      delegate: {
        apply: "_applyDelegate",
        event: "changeDelegate",
        init: null,
        nullable: true
      },

      /**
       * Indicates that the list is managing the {@link #groups} automatically.
       */
      autoGrouping: {
        check: "Boolean",
        init: true
      },

      /**
       * Contains all groups for data binding, but do only manipulate the array
       * when the {@link #autoGrouping} is set to <code>false</code>.
       */
      groups: {
        check: "qx.data.Array",
        event: "changeGroups",
        nullable: false,
        deferredInit: true
      },

      /** 
       * Render list items with variable height, 
       * calculated from the individual item size. 
       */
      variableItemHeight: {
        check: "Boolean",
        apply: "_applyVariableItemHeight",
        nullable: false,
        init: true
      }
    },
    members: {
      /** @type {qx.ui.virtual.layer.Row} background renderer */
      _background: null,

      /** @type {qx.ui.list.provider.IListProvider} provider for cell rendering */
      _provider: null,

      /** @type {qx.ui.virtual.layer.Abstract} layer which contains the items. */
      _layer: null,

      /**
       * @type {Array} lookup table to get the model index from a row. To get the
       *   correct value after applying filter, sorter, group.
       *
       * Note the value <code>-1</code> indicates that the value is a group item.
       */
      __lookupTable: null,

      /** @type {Array} lookup table for getting the group index from the row */
      __lookupTableForGroup: null,

      /**
       * @type {Map} contains all groups with the items as children. The key is
       *   the group name and the value is an <code>Array</code> containing each
       *   item's model index.
       */
      __groupHashMap: null,

      /**
       * @type {Boolean} indicates when one or more <code>String</code> are used for grouping.
       */
      __groupStringsUsed: false,

      /**
       * @type {Boolean} indicates when one or more <code>Object</code> are used for grouping.
       */
      __groupObjectsUsed: false,

      /**
       * @type {Boolean} indicates when a default group is used for grouping.
       */
      __defaultGroupUsed: false,
      __defaultGroups: null,
      __deferredLayerUpdate: null,

      /**
       * Trigger a rebuild from the internal data structure.
       */
      refresh: function refresh() {
        this.__buildUpLookupTable();
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "row-layer":
            control = new qx.ui.virtual.layer.Row(null, null);
            break;
        }

        return control || qx.ui.list.List.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Initialize the virtual list provider.
       */
      _initWidgetProvider: function _initWidgetProvider() {
        this._provider = new qx.ui.list.provider.WidgetProvider(this);
      },

      /**
       * Initializes the virtual list.
       */
      _init: function _init() {
        this._initWidgetProvider();

        this.__lookupTable = [];
        this.__lookupTableForGroup = [];
        this.__groupHashMap = {};
        this.__groupStringsUsed = false;
        this.__groupObjectsUsed = false;
        this.__defaultGroupUsed = false;
        this.getPane().addListener("resize", this._onResize, this);

        this._initBackground();

        this._initLayer();
      },

      /**
       * Initializes the background renderer.
       */
      _initBackground: function _initBackground() {
        this._background = this.getChildControl("row-layer");
        this.getPane().addLayer(this._background);
      },

      /**
       * Initializes the layer for rendering.
       */
      _initLayer: function _initLayer() {
        this._layer = this._provider.createLayer();

        this._layer.addListener("updated", this._onLayerUpdated, this);

        this.getPane().addLayer(this._layer);
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the model data for the given row.
       *
       * @param row {Integer} row to get data for.
       * @return {var|null} the row's model data.
       */
      _getDataFromRow: function _getDataFromRow(row) {
        var data = null;
        var model = this.getModel();

        if (model == null) {
          return null;
        }

        if (this._isGroup(row)) {
          data = this.getGroups().getItem(this._lookupGroup(row));
        } else {
          data = model.getItem(this._lookup(row));
        }

        if (data != null) {
          return data;
        } else {
          return null;
        }
      },

      /**
       * Return the internal lookup table. But do not manipulate the
       * lookup table!
       *
       * @return {Array} The internal lookup table.
       */
      _getLookupTable: function _getLookupTable() {
        return this.__lookupTable;
      },

      /**
       * Performs a lookup from row to model index.
       *
       * @param row {Number} The row to look at.
       * @return {Number} The model index or
       *   <code>-1</code> if the row is a group item.
       */
      _lookup: function _lookup(row) {
        return this.__lookupTable[row];
      },

      /**
       * Performs a lookup from row to group index.
       *
       * @param row {Number} The row to look at.
       * @return {Number} The group index or
       *   <code>-1</code> if the row is a not a group item.
       */
      _lookupGroup: function _lookupGroup(row) {
        return this.__lookupTableForGroup.indexOf(row);
      },

      /**
       * Performs a lookup from model index to row.
       *
       * @param index {Number} The index to look at.
       * @return {Number} The row or <code>-1</code>
       *  if the index is not a model index.
       */
      _reverseLookup: function _reverseLookup(index) {
        if (index < 0) {
          return -1;
        }

        return this.__lookupTable.indexOf(index);
      },

      /**
       * Checks if the passed row is a group or an item.
       *
       * @param row {Integer} row to check.
       * @return {Boolean} <code>true</code> if the row is a group element,
       *  <code>false</code> if the row is an item element.
       */
      _isGroup: function _isGroup(row) {
        return this._lookup(row) == -1;
      },

      /**
       * Returns the selectable model items.
       *
       * @return {qx.data.Array | null} The selectable items.
       */
      _getSelectables: function _getSelectables() {
        return this.getModel();
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // apply method
      _applyModel: function _applyModel(value, old) {
        if (value != null) {
          value.addListener("changeLength", this._onModelChange, this);
        }

        if (old != null) {
          old.removeListener("changeLength", this._onModelChange, this);
        }

        this._onModelChange();
      },
      // apply method
      _applyRowHeight: function _applyRowHeight(value, old) {
        this.getPane().getRowConfig().setDefaultItemSize(value);
      },
      // apply method
      _applyGroupRowHeight: function _applyGroupRowHeight(value, old) {
        this.__updateGroupRowHeight();
      },
      // apply method
      _applyLabelPath: function _applyLabelPath(value, old) {
        this._provider.setLabelPath(value);
      },
      // apply method
      _applyIconPath: function _applyIconPath(value, old) {
        this._provider.setIconPath(value);
      },
      // apply method
      _applyGroupLabelPath: function _applyGroupLabelPath(value, old) {
        this._provider.setGroupLabelPath(value);
      },
      // apply method
      _applyLabelOptions: function _applyLabelOptions(value, old) {
        this._provider.setLabelOptions(value);
      },
      // apply method
      _applyIconOptions: function _applyIconOptions(value, old) {
        this._provider.setIconOptions(value);
      },
      // apply method
      _applyGroupLabelOptions: function _applyGroupLabelOptions(value, old) {
        this._provider.setGroupLabelOptions(value);
      },
      // apply method
      _applyDelegate: function _applyDelegate(value, old) {
        this._provider.setDelegate(value);

        this.__buildUpLookupTable();
      },
      // property apply
      _applyVariableItemHeight: function _applyVariableItemHeight(value, old) {
        if (value) {
          this._setRowItemSize();
        } else {
          this.getPane().getRowConfig().resetItemSizes();
          this.getPane().fullUpdate();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the resize event.
       *
       * @param e {qx.event.type.Data} resize event.
       */
      _onResize: function _onResize(e) {
        this.getPane().getColumnConfig().setItemSize(0, e.getData().width);
      },

      /**
       * Event handler for the model change event.
       *
       * @param e {qx.event.type.Data} model change event.
       */
      _onModelChange: function _onModelChange(e) {
        // we have to remove the bindings before we rebuild the lookup table
        // otherwise bindings might be dispatched to wrong items
        // see: https://github.com/qooxdoo/qooxdoo/issues/196
        this._provider.removeBindings();

        this.__buildUpLookupTable();

        this._applyDefaultSelection();

        if (e instanceof qx.event.type.Data) {
          this.fireDataEvent("changeModelLength", e.getData(), e.getOldData());
        }
      },

      /**
       * Event handler for the updated event of the 
       * qx.ui.virtual.layer.WidgetCell layer.
       *
       * Recalculates the item sizes in a deffered call,
       * which only happens if we have variable item heights
       */
      _onLayerUpdated: function _onLayerUpdated() {
        if (this.isVariableItemHeight() === false) {
          return;
        }

        if (this.__deferredLayerUpdate === null) {
          this.__deferredLayerUpdate = new qx.util.DeferredCall(function () {
            this._setRowItemSize();
          }, this);
        }

        this.__deferredLayerUpdate.schedule();
      },

      /*
      ---------------------------------------------------------------------------
        HELPER ROUTINES
      ---------------------------------------------------------------------------
      */

      /**
       * Helper method to update the row count.
       */
      __updateRowCount: function __updateRowCount() {
        this.getPane().getRowConfig().setItemCount(this.__lookupTable.length);
        this.getPane().fullUpdate();
      },

      /**
       * Helper method to update group row heights.
       */
      __updateGroupRowHeight: function __updateGroupRowHeight() {
        /*
         * In case of having variableItemHeight set to true,
         * the group item height has a variable height as well
         * and will be set again in method _setRowItemSize 
         * which is a deferred call, being run after all changes.
         * Resetting the complete item sizes here and setting
         * the height of the group items, only leads to an
         * unnecessary flicker of the list items by shrinking and
         * growing them again.
         */
        if (this.isVariableItemHeight()) {
          return;
        }

        var rc = this.getPane().getRowConfig();
        var gh = this.getGroupItemHeight();
        rc.resetItemSizes();

        if (gh) {
          for (var i = 0, l = this.__lookupTable.length; i < l; ++i) {
            if (this.__lookupTable[i] == -1) {
              rc.setItemSize(i, gh);
            }
          }
        }
      },

      /**
       * Internal method for building the lookup table.
       */
      __buildUpLookupTable: function __buildUpLookupTable() {
        this.__lookupTable = [];
        this.__lookupTableForGroup = [];
        this.__groupHashMap = {};

        if (this.isAutoGrouping()) {
          this.getGroups().removeAll();
        }

        var model = this.getModel();

        if (model != null) {
          this._runDelegateFilter(model);

          this._runDelegateSorter(model);

          this._runDelegateGroup(model);
        }

        this._updateSelection();

        this.__updateGroupRowHeight();

        this.__updateRowCount();
      },

      /**
       * Invokes filtering using the filter given in the delegate.
       *
       * @param model {qx.data.IListData} The model.
       */
      _runDelegateFilter: function _runDelegateFilter(model) {
        var filter = qx.util.Delegate.getMethod(this.getDelegate(), "filter");

        for (var i = 0, l = model.length; i < l; ++i) {
          if (filter == null || filter(model.getItem(i))) {
            this.__lookupTable.push(i);
          }
        }
      },

      /**
       * Invokes sorting using the sorter given in the delegate.
       *
       * @param model {qx.data.IListData} The model.
       */
      _runDelegateSorter: function _runDelegateSorter(model) {
        if (this.__lookupTable.length == 0) {
          return;
        }

        var sorter = qx.util.Delegate.getMethod(this.getDelegate(), "sorter");

        if (sorter != null) {
          this.__lookupTable.sort(function (a, b) {
            return sorter(model.getItem(a), model.getItem(b));
          });
        }
      },

      /**
       * Invokes grouping using the group result given in the delegate.
       *
       * @param model {qx.data.IListData} The model.
       */
      _runDelegateGroup: function _runDelegateGroup(model) {
        var groupMethod = qx.util.Delegate.getMethod(this.getDelegate(), "group");

        if (groupMethod != null) {
          for (var i = 0, l = this.__lookupTable.length; i < l; ++i) {
            var index = this.__lookupTable[i];
            var item = this.getModel().getItem(index);
            var group = groupMethod(item);

            this.__addGroup(group, index);
          }

          this.__lookupTable = this.__createLookupFromGroup();
        }
      },

      /**
       * Adds a model index the the group.
       *
       * @param group {String|Object|null} the group.
       * @param index {Integer} model index to add.
       */
      __addGroup: function __addGroup(group, index) {
        // if group is null add to default group
        if (group == null) {
          this.__defaultGroupUsed = true;
          group = "???";
        }

        var name = this.__getUniqueGroupName(group);

        if (this.__groupHashMap[name] == null) {
          this.__groupHashMap[name] = [];

          if (this.isAutoGrouping()) {
            this.getGroups().push(group);
          }
        }

        this.__groupHashMap[name].push(index);
      },

      /**
       * Creates a lookup table form the internal group hash map.
       *
       * @return {Array} the lookup table based on the internal group hash map.
       */
      __createLookupFromGroup: function __createLookupFromGroup() {
        this.__checkGroupStructure();

        var result = [];
        var row = 0;
        var groups = this.getGroups();

        for (var i = 0; i < groups.getLength(); i++) {
          var group = groups.getItem(i); // indicate that the value is a group

          result.push(-1);

          this.__lookupTableForGroup.push(row);

          row++;

          var key = this.__getUniqueGroupName(group);

          var groupMembers = this.__groupHashMap[key];

          if (groupMembers != null) {
            for (var k = 0; k < groupMembers.length; k++) {
              result.push(groupMembers[k]);
              row++;
            }
          }
        }

        return result;
      },

      /**
       * Returns an unique group name for the passed group.
       *
       * @param group {String|Object} Group to find unique group name.
       * @return {String} Unique group name.
       */
      __getUniqueGroupName: function __getUniqueGroupName(group) {
        var name = null;

        if (!qx.lang.Type.isString(group)) {
          var index = this.getGroups().indexOf(group);
          this.__groupObjectsUsed = true;
          name = "group";

          if (index == -1) {
            name += this.getGroups().getLength();
          } else {
            name += index;
          }
        } else {
          this.__groupStringsUsed = true;
          var name = group;
        }

        return name;
      },

      /**
       * Checks that <code>Object</code> and <code>String</code> are not mixed
       * as group identifier, otherwise an exception occurs.
       */
      __checkGroupStructure: function __checkGroupStructure() {
        if (this.__groupObjectsUsed && this.__defaultGroupUsed || this.__groupObjectsUsed && this.__groupStringsUsed) {
          throw new Error("GroupingTypeError: You can't mix 'Objects' and 'Strings' as group identifier!");
        }
      },

      /**
       * Get the height of each visible item and set it as the
       * row size
       */
      _setRowItemSize: function _setRowItemSize() {
        var rowConfig = this.getPane().getRowConfig();
        var layer = this._layer;
        var firstRow = layer.getFirstRow();
        var lastRow = firstRow + layer.getRowSizes().length;

        for (var row = firstRow; row < lastRow; row++) {
          var widget = layer.getRenderedCellWidget(row, 0);

          if (widget !== null) {
            var height = widget.getSizeHint().height;
            rowConfig.setItemSize(row, height);
          }
        }
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__deferredLayerUpdate");

      var model = this.getModel();

      if (model != null) {
        model.removeListener("changeLength", this._onModelChange, this);
      }

      var pane = this.getPane();

      if (pane != null) {
        pane.removeListener("resize", this._onResize, this);
      }

      this._background.dispose();

      this._provider.dispose();

      this._layer.dispose();

      this._background = this._provider = this._layer = this.__lookupTable = this.__lookupTableForGroup = this.__groupHashMap = null;

      if (this.__defaultGroups) {
        this.__defaultGroups.dispose();
      }
    }
  });
  qx.ui.list.List.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.selection.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.Pane": {
        "construct": true
      },
      "qx.bom.element.Location": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Abstract base class for selection manager, which manage selectable items
   * rendered in a virtual {@link qx.ui.virtual.core.Pane}.
   */
  qx.Class.define("qx.ui.virtual.selection.Abstract", {
    extend: qx.ui.core.selection.Abstract,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */

    /**
     * @param pane {qx.ui.virtual.core.Pane} The virtual pane on which the
     *    selectable item are rendered
     * @param selectionDelegate {qx.ui.virtual.selection.ISelectionDelegate?null} An optional delegate,
     *    which can be used to customize the behavior of the selection manager
     *    without sub classing it.
     */
    construct: function construct(pane, selectionDelegate) {
      qx.ui.core.selection.Abstract.constructor.call(this);
      {
        this.assertInstance(pane, qx.ui.virtual.core.Pane);
      }
      this._pane = pane;
      this._delegate = selectionDelegate || {};
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // Determines if automatically scrolling of selected item into view is active.
      _autoScrollIntoView: true,

      /*
      ---------------------------------------------------------------------------
        DELEGATE METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _isSelectable: function _isSelectable(item) {
        return this._delegate.isItemSelectable ? this._delegate.isItemSelectable(item) : true;
      },
      // overridden
      _styleSelectable: function _styleSelectable(item, type, enabled) {
        if (this._delegate.styleSelectable) {
          this._delegate.styleSelectable(item, type, enabled);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENTS
      ---------------------------------------------------------------------------
      */

      /**
       * Attach pointer events to the managed pane.
       */
      attachPointerEvents: function attachPointerEvents() {
        var paneElement = this._pane.getContentElement();

        paneElement.addListener("pointerdown", this.handlePointerDown, this);
        paneElement.addListener("tap", this.handleTap, this);
        paneElement.addListener("pointerover", this.handlePointerOver, this);
        paneElement.addListener("pointermove", this.handlePointerMove, this);
        paneElement.addListener("losecapture", this.handleLoseCapture, this);
      },

      /**
       * Detach pointer events from the managed pane.
       *
       * @deprecated {6.0} misspelled, please use detachPointerEvents instead!
       */
      detatchPointerEvents: function detatchPointerEvents() {
        this.detachPointerEvents();
      },

      /**
       * Detach pointer events from the managed pane.
       */
      detachPointerEvents: function detachPointerEvents() {
        var paneElement = this._pane.getContentElement();

        paneElement.removeListener("pointerdown", this.handlePointerDown, this);
        paneElement.removeListener("tap", this.handleTap, this);
        paneElement.removeListener("pointerover", this.handlePointerOver, this);
        paneElement.removeListener("pointermove", this.handlePointerMove, this);
        paneElement.removeListener("losecapture", this.handleLoseCapture, this);
      },

      /**
       * Attach key events to manipulate the selection using the keyboard. The
       * event target doesn't need to be the pane itself. It can be an widget,
       * which received key events. Usually the key event target is the
       * {@link qx.ui.virtual.core.Scroller}.
       *
       * @param target {qx.core.Object} the key event target.
       *
       */
      attachKeyEvents: function attachKeyEvents(target) {
        target.addListener("keypress", this.handleKeyPress, this);
      },

      /**
       * Detach key events.
       *
       * @param target {qx.core.Object} the key event target.
       */
      detachKeyEvents: function detachKeyEvents(target) {
        target.removeListener("keypress", this.handleKeyPress, this);
      },

      /**
       * Attach list events. The selection mode <code>one</code> need to know,
       * when selectable items are added or removed. If this mode is used the
       * <code>list</code> parameter must fire <code>addItem</code> and
       * <code>removeItem</code> events.
       *
       * @param list {qx.core.Object} the event target for <code>addItem</code> and
       *    <code>removeItem</code> events
       */
      attachListEvents: function attachListEvents(list) {
        list.addListener("addItem", this.handleAddItem, this);
        list.addListener("removeItem", this.handleRemoveItem, this);
      },

      /**
       * Detach list events.
       *
       * @param list {qx.core.Object} the event target for <code>addItem</code> and
       *    <code>removeItem</code> events
       */
      detachListEvents: function detachListEvents(list) {
        list.removeListener("addItem", this.handleAddItem, this);
        list.removeListener("removeItem", this.handleRemoveItem, this);
      },

      /*
      ---------------------------------------------------------------------------
        IMPLEMENT ABSTRACT METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _capture: function _capture() {
        this._pane.capture();
      },
      // overridden
      _releaseCapture: function _releaseCapture() {
        this._pane.releaseCapture();
      },
      // overridden
      _getScroll: function _getScroll() {
        return {
          left: this._pane.getScrollX(),
          top: this._pane.getScrollY()
        };
      },
      // overridden
      _scrollBy: function _scrollBy(xoff, yoff) {
        this._pane.setScrollX(this._pane.getScrollX() + xoff);

        this._pane.setScrollY(this._pane.getScrollY() + yoff);
      },
      // overridden
      _getLocation: function _getLocation() {
        var elem = this._pane.getContentElement().getDomElement();

        return elem ? qx.bom.element.Location.get(elem) : null;
      },
      // overridden
      _getDimension: function _getDimension() {
        return this._pane.getInnerSize();
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this._pane = this._delegate = null;
    }
  });
  qx.ui.virtual.selection.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.selection.Abstract": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Row selection manager
   */
  qx.Class.define("qx.ui.virtual.selection.Row", {
    extend: qx.ui.virtual.selection.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the number of all items in the pane. This number may contain
       * unselectable items as well.
       *
       * @return {Integer} number of items
       */
      _getItemCount: function _getItemCount() {
        return this._pane.getRowConfig().getItemCount();
      },

      /*
      ---------------------------------------------------------------------------
        IMPLEMENT ABSTRACT METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _getSelectableFromPointerEvent: function _getSelectableFromPointerEvent(event) {
        var cell = this._pane.getCellAtPosition(event.getDocumentLeft(), event.getDocumentTop());

        if (!cell) {
          return null;
        }

        return this._isSelectable(cell.row) ? cell.row : null;
      },
      // overridden
      getSelectables: function getSelectables(all) {
        var selectables = [];

        for (var i = 0, l = this._getItemCount(); i < l; i++) {
          if (this._isSelectable(i)) {
            selectables.push(i);
          }
        }

        return selectables;
      },
      // overridden
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        var selectables = [];
        var min = Math.min(item1, item2);
        var max = Math.max(item1, item2);

        for (var i = min; i <= max; i++) {
          if (this._isSelectable(i)) {
            selectables.push(i);
          }
        }

        return selectables;
      },
      // overridden
      _getFirstSelectable: function _getFirstSelectable() {
        var count = this._getItemCount();

        for (var i = 0; i < count; i++) {
          if (this._isSelectable(i)) {
            return i;
          }
        }

        return null;
      },
      // overridden
      _getLastSelectable: function _getLastSelectable() {
        var count = this._getItemCount();

        for (var i = count - 1; i >= 0; i--) {
          if (this._isSelectable(i)) {
            return i;
          }
        }

        return null;
      },
      // overridden
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        if (relation == "above") {
          var startIndex = item - 1;
          var endIndex = 0;
          var increment = -1;
        } else if (relation == "under") {
          var startIndex = item + 1;
          var endIndex = this._getItemCount() - 1;
          var increment = 1;
        } else {
          return null;
        }

        for (var i = startIndex; i !== endIndex + increment; i += increment) {
          if (this._isSelectable(i)) {
            return i;
          }
        }

        return null;
      },
      // overridden
      _getPage: function _getPage(lead, up) {
        var paneSize;
        var scrollY;
        var newItem;

        var rowConfig = this._pane.getRowConfig(); // Determine the height of the pane


        paneSize = this._pane.getInnerSize(); // Determine our current y position

        scrollY = this._pane.getScrollY(); // Scroll to the new page

        if (up) {
          // Add item size so we include the immediately previous item, i.e., so
          // that pageDown followed by pageUp returns to the same location
          this._pane.setScrollY(scrollY - paneSize.height + rowConfig.getDefaultItemSize());
        } else {
          this._pane.setScrollY(scrollY + paneSize.height);
        } // Determine new y position, and from that, what row we moved to


        scrollY = this._pane.getScrollY();
        newItem = rowConfig.getItemAtPosition(scrollY);
        return newItem.index;
      },
      // overridden
      _selectableToHashCode: function _selectableToHashCode(item) {
        return item;
      },
      // overridden
      _scrollItemIntoView: function _scrollItemIntoView(item) {
        if (this._autoScrollIntoView) {
          this._pane.scrollRowIntoView(item);
        }
      },
      // overridden
      _getSelectableLocationX: function _getSelectableLocationX(item) {
        return {
          left: 0,
          right: this._pane.getColumnConfig().getTotalSize() - 1
        };
      },
      // overridden
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        var rowConfig = this._pane.getRowConfig();

        var itemTop = rowConfig.getItemPosition(item);
        var itemBottom = itemTop + rowConfig.getItemSize(item) - 1;
        return {
          top: itemTop,
          bottom: itemBottom
        };
      }
    }
  });
  qx.ui.virtual.selection.Row.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A layer is responsible to render one aspect of a virtual pane. The pane tells
   * each layer to render/update a specific window of the virtual grid.
   */
  qx.Interface.define("qx.ui.virtual.core.ILayer", {
    members: {
      /**
       * Do a complete update of the layer. All cached data should be discarded.
       * This method is called e.g. after changes to the grid geometry
       * (row/column sizes, row/column count, ...).
       *
       * Note: This method can only be called after the widgets initial appear
       * event has been fired because it may work with the widget's DOM elements.
       *
       * @param firstRow {Integer} Index of the first row to display.
       * @param firstColumn {Integer} Index of the first column to display.
       * @param rowSizes {Integer[]} Array of heights for each row to display.
       * @param columnSizes {Integer[]} Array of widths for each column to display.
       */
      fullUpdate: function fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        this.assertArgumentsCount(arguments, 6, 6);
        this.assertPositiveInteger(firstRow);
        this.assertPositiveInteger(firstColumn);
        this.assertArray(rowSizes);
        this.assertArray(columnSizes);
      },

      /**
       * Update the layer to display a different window of the virtual grid.
       * This method is called if the pane is scrolled, resized or cells
       * are prefetched. The implementation can assume that no other grid
       * data has been changed since the last "fullUpdate" of "updateLayerWindow"
       * call.
       *
       * Note: This method can only be called after the widgets initial appear
       * event has been fired because it may work with the widget's DOM elements.
       *
       * @param firstRow {Integer} Index of the first row to display.
       * @param firstColumn {Integer} Index of the first column to display.
       * @param rowSizes {Integer[]} Array of heights for each row to display.
       * @param columnSizes {Integer[]} Array of widths for each column to display.
       */
      updateLayerWindow: function updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        this.assertArgumentsCount(arguments, 6, 6);
        this.assertPositiveInteger(firstRow);
        this.assertPositiveInteger(firstColumn);
        this.assertArray(rowSizes);
        this.assertArray(columnSizes);
      },

      /**
       * Update the layer to reflect changes in the data the layer displays.
       */
      updateLayerData: function updateLayerData() {}
    }
  });
  qx.ui.virtual.core.ILayer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.ILayer": {
        "require": true
      },
      "qx.ui.core.queue.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Abstract base class for layers of a virtual pane.
   *
   * This class queues calls to {@link #fullUpdate}, {@link #updateLayerWindow}
   * and {@link #updateLayerData} and only performs the absolute necessary
   * actions. Concrete implementation of this class must at least implement
   * the {@link #_fullUpdate} method. Additionally the two methods
   * {@link #_updateLayerWindow} and {@link #_updateLayerData} may be implemented
   * to increase the performance.
   */
  qx.Class.define("qx.ui.virtual.layer.Abstract", {
    extend: qx.ui.core.Widget,
    type: "abstract",
    implement: [qx.ui.virtual.core.ILayer],

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this);
      this.__jobs = {};
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      anonymous: {
        refine: true,
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __jobs: null,
      __arguments: null,
      __firstRow: null,
      __firstColumn: null,
      __rowSizes: null,
      __columnSizes: null,

      /**
       * Get the first rendered row
       *
       * @return {Integer} The first rendered row
       */
      getFirstRow: function getFirstRow() {
        return this.__firstRow;
      },

      /**
       * Get the first rendered column
       *
       * @return {Integer} The first rendered column
       */
      getFirstColumn: function getFirstColumn() {
        return this.__firstColumn;
      },

      /**
       * Get the sizes of the rendered rows
       *
       * @return {Integer[]} List of row heights
       */
      getRowSizes: function getRowSizes() {
        return this.__rowSizes || [];
      },

      /**
       * Get the sizes of the rendered column
       *
       * @return {Integer[]} List of column widths
       */
      getColumnSizes: function getColumnSizes() {
        return this.__columnSizes || [];
      },
      // overridden
      syncWidget: function syncWidget(jobs) {
        // return if the layer is not yet rendered
        // it will rendered in the appear event
        if (!this.getContentElement().getDomElement()) {
          return;
        }

        if (this.__jobs.fullUpdate || this.__jobs.updateLayerWindow && this.__jobs.updateLayerData) {
          this._fullUpdate.apply(this, this.__arguments);
        } else if (this.__jobs.updateLayerWindow) {
          this._updateLayerWindow.apply(this, this.__arguments);
        } else if (this.__jobs.updateLayerData && this.__rowSizes) {
          this._updateLayerData();
        }

        if (this.__jobs.fullUpdate || this.__jobs.updateLayerWindow) {
          var args = this.__arguments;
          this.__firstRow = args[0];
          this.__firstColumn = args[1];
          this.__rowSizes = args[2];
          this.__columnSizes = args[3];
        }

        this.__jobs = {};
      },

      /**
       * Update the layer to reflect changes in the data the layer displays.
       *
       * Note: It is guaranteed that this method is only called after the layer
       * has been rendered.
       */
      _updateLayerData: function _updateLayerData() {
        this._fullUpdate(this.__firstRow, this.__firstColumn, this.__rowSizes, this.__columnSizes);
      },

      /**
       * Do a complete update of the layer. All cached data should be discarded.
       * This method is called e.g. after changes to the grid geometry
       * (row/column sizes, row/column count, ...).
       *
       * Note: It is guaranteed that this method is only called after the layer
       * has been rendered.
       *
       * @param firstRow {Integer} Index of the first row to display
       * @param firstColumn {Integer} Index of the first column to display
       * @param rowSizes {Integer[]} Array of heights for each row to display
       * @param columnSizes {Integer[]} Array of widths for each column to display
       */
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        throw new Error("Abstract method '_fullUpdate' called!");
      },

      /**
       * Update the layer to display a different window of the virtual grid.
       * This method is called if the pane is scrolled, resized or cells
       * are prefetched. The implementation can assume that no other grid
       * data has been changed since the last "fullUpdate" of "updateLayerWindow"
       * call.
       *
       * Note: It is guaranteed that this method is only called after the layer
       * has been rendered.
       *
       * @param firstRow {Integer} Index of the first row to display
       * @param firstColumn {Integer} Index of the first column to display
       * @param rowSizes {Integer[]} Array of heights for each row to display
       * @param columnSizes {Integer[]} Array of widths for each column to display
       */
      _updateLayerWindow: function _updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        this._fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
      },
      // interface implementation
      updateLayerData: function updateLayerData() {
        this.__jobs.updateLayerData = true;
        qx.ui.core.queue.Widget.add(this);
      },
      // interface implementation
      fullUpdate: function fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        this.__arguments = arguments;
        this.__jobs.fullUpdate = true;
        qx.ui.core.queue.Widget.add(this);
      },
      // interface implementation
      updateLayerWindow: function updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        this.__arguments = arguments;
        this.__jobs.updateLayerWindow = true;
        qx.ui.core.queue.Widget.add(this);
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__jobs = this.__arguments = this.__rowSizes = this.__columnSizes = null;
    }
  });
  qx.ui.virtual.layer.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.theme.manager.Color": {},
      "qx.theme.manager.Decoration": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Abstract base class for the {@link Row} and {@link Column} layers.
   */
  qx.Class.define("qx.ui.virtual.layer.AbstractBackground", {
    extend: qx.ui.virtual.layer.Abstract,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */

    /**
     * @param colorEven {Color?null} color for even indexes
     * @param colorOdd {Color?null} color for odd indexes
     */
    construct: function construct(colorEven, colorOdd) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);

      if (colorEven) {
        this.setColorEven(colorEven);
      }

      if (colorOdd) {
        this.setColorOdd(colorOdd);
      }

      this.__customColors = {};
      this.__decorators = {};
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** color for event indexes */
      colorEven: {
        nullable: true,
        check: "Color",
        apply: "_applyColorEven",
        themeable: true
      },

      /** color for odd indexes */
      colorOdd: {
        nullable: true,
        check: "Color",
        apply: "_applyColorOdd",
        themeable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __colorEven: null,
      __colorOdd: null,
      __customColors: null,
      __decorators: null,

      /*
      ---------------------------------------------------------------------------
        COLOR HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the color for the given index
       *
       * @param index {Integer} Index to set the color for
       * @param color {Color|null} the color to set. A value of <code>null</code>
       *    will reset the color.
       */
      setColor: function setColor(index, color) {
        if (color) {
          this.__customColors[index] = qx.theme.manager.Color.getInstance().resolve(color);
        } else {
          delete this.__customColors[index];
        }
      },

      /**
       * Clear all colors set using {@link #setColor}.
       */
      clearCustomColors: function clearCustomColors() {
        this.__customColors = {};
        this.updateLayerData();
      },

      /**
       * Get the color at the given index
       *
       * @param index {Integer} The index to get the color for.
       * @return {Color} The color at the given index
       */
      getColor: function getColor(index) {
        var customColor = this.__customColors[index];

        if (customColor) {
          return customColor;
        } else {
          return index % 2 == 0 ? this.__colorEven : this.__colorOdd;
        }
      },
      // property apply
      _applyColorEven: function _applyColorEven(value, old) {
        if (value) {
          this.__colorEven = qx.theme.manager.Color.getInstance().resolve(value);
        } else {
          this.__colorEven = null;
        }

        this.updateLayerData();
      },
      // property apply
      _applyColorOdd: function _applyColorOdd(value, old) {
        if (value) {
          this.__colorOdd = qx.theme.manager.Color.getInstance().resolve(value);
        } else {
          this.__colorOdd = null;
        }

        this.updateLayerData();
      },

      /**
       * Sets the decorator for the given index
       *
       * @param index {Integer} Index to set the color for
       * @param decorator {qx.ui.decoration.IDecorator|null} the decorator to set. A value of
       *    <code>null</code> will reset the decorator.
       */
      setBackground: function setBackground(index, decorator) {
        if (decorator) {
          this.__decorators[index] = qx.theme.manager.Decoration.getInstance().resolve(decorator);
        } else {
          delete this.__decorators[index];
        }

        this.updateLayerData();
      },

      /**
       * Get the decorator at the given index
       *
       * @param index {Integer} The index to get the decorator for.
       * @return {qx.ui.decoration.IDecorator} The decorator at the given index
       */
      getBackground: function getBackground(index) {
        return this.__decorators[index];
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this.__customColors = this.__decorators = null;
    }
  });
  qx.ui.virtual.layer.AbstractBackground.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.AbstractBackground": {
        "require": true
      },
      "qx.lang.Array": {},
      "qx.bom.element.Style": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The Row layer renders row background colors.
   */
  qx.Class.define("qx.ui.virtual.layer.Row", {
    extend: qx.ui.virtual.layer.AbstractBackground,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "row-layer"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];
        var width = qx.lang.Array.sum(columnSizes);
        var top = 0;
        var row = firstRow;
        var childIndex = 0;

        for (var y = 0; y < rowSizes.length; y++) {
          var color = this.getColor(row);
          var backgroundColor = color ? "background-color:" + color + ";" : "";
          var decorator = this.getBackground(row);
          var styles = decorator ? qx.bom.element.Style.compile(decorator.getStyles()) : "";
          html.push("<div style='", "position: absolute;", "left: 0;", "top:", top, "px;", "height:", rowSizes[y], "px;", "width:", width, "px;", backgroundColor, styles, "'>", "</div>");
          childIndex++;
          top += rowSizes[y];
          row += 1;
        }

        var el = this.getContentElement().getDomElement(); // hide element before changing the child nodes to avoid
        // premature reflow calculations

        el.style.display = "none";
        el.innerHTML = html.join("");
        el.style.display = "block";
        this._width = width;
      },
      // overridden
      _updateLayerWindow: function _updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        if (firstRow !== this.getFirstRow() || rowSizes.length !== this.getRowSizes().length || this._width < qx.lang.Array.sum(columnSizes)) {
          this._fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
        }
      },
      // overridden
      setColor: function setColor(index, color) {
        qx.ui.virtual.layer.Row.prototype.setColor.base.call(this, index, color);

        if (this.__isRowRendered(index)) {
          this.updateLayerData();
        }
      },
      // overridden
      setBackground: function setBackground(index, decorator) {
        qx.ui.virtual.layer.Row.prototype.setBackground.base.call(this, index, decorator);

        if (this.__isRowRendered(index)) {
          this.updateLayerData();
        }
      },

      /**
       * Whether the row with the given index is currently rendered (i.e. in the
       * layer's view port).
       *
       * @param index {Integer} The row's index
       * @return {Boolean} Whether the row is rendered
       */
      __isRowRendered: function __isRowRendered(index) {
        var firstRow = this.getFirstRow();
        var lastRow = firstRow + this.getRowSizes().length - 1;
        return index >= firstRow && index <= lastRow;
      }
    }
  });
  qx.ui.virtual.layer.Row.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A widget cell provider provides the {@link qx.ui.virtual.layer.WidgetCell}
   * with configured widgets to render the cells and pools/releases unused
   * cell widgets.
   */
  qx.Interface.define("qx.ui.virtual.core.IWidgetCellProvider", {
    members: {
      /**
       * This method returns the configured cell for the given cell. The return
       * value may be <code>null</code> to indicate that the cell should be empty.
       *
       * @param row {Integer} The cell's row index.
       * @param column {Integer} The cell's column index.
       * @return {qx.ui.core.LayoutItem} The configured widget for the given cell.
       */
      getCellWidget: function getCellWidget(row, column) {},

      /**
       * Release the given cell widget. Either pool or destroy the widget.
       *
       * @param widget {qx.ui.core.LayoutItem} The cell widget to pool.
       */
      poolCellWidget: function poolCellWidget(widget) {}
    }
  });
  qx.ui.virtual.core.IWidgetCellProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * This interface needs to implemented from all {@link qx.ui.list.List} providers.
   *
   * @internal
   */
  qx.Interface.define("qx.ui.list.provider.IListProvider", {
    members: {
      /**
       * Creates a layer for item and group rendering.
       *
       * @return {qx.ui.virtual.layer.Abstract} new layer.
       */
      createLayer: function createLayer() {},

      /**
       * Creates a renderer for item rendering.
       *
       * @return {var} new item renderer.
       */
      createItemRenderer: function createItemRenderer() {},

      /**
       * Creates a renderer for group rendering.
       *
       * @return {var} new group renderer.
       */
      createGroupRenderer: function createGroupRenderer() {},

      /**
       * Styles a selected item.
       *
       * @param row {Integer} row to style.
       */
      styleSelectabled: function styleSelectabled(row) {},

      /**
       * Styles a not selected item.
       *
       * @param row {Integer} row to style.
       */
      styleUnselectabled: function styleUnselectabled(row) {},

      /**
       * Returns if the passed row can be selected or not.
       *
       * @param row {Integer} row to select.
       * @return {Boolean} <code>true</code> when the row can be selected,
       *    <code>false</code> otherwise.
       */
      isSelectable: function isSelectable(row) {},

      /**
       * The path to the property which holds the information that should be
       * shown as a label. This is only needed if objects are stored in the model.
       *
       * @param path {String} path to the property.
       */
      setLabelPath: function setLabelPath(path) {},

      /**
       * The path to the property which holds the information that should be
       * shown as an icon. This is only needed if objects are stored in the model
       * and if the icon should be shown.
       *
       * @param path {String} path to the property.
       */
      setIconPath: function setIconPath(path) {},

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       *
       * @param options {Map} options for the label binding.
       */
      setLabelOptions: function setLabelOptions(options) {},

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       *
       * @param options {Map} options for the icon binding.
       */
      setIconOptions: function setIconOptions(options) {},

      /**
       * Delegation object, which can have one or more functions defined by the
       * {@link qx.ui.list.core.IListDelegate} interface.
       *
       * @param delegate {Object} delegation object.
       */
      setDelegate: function setDelegate(delegate) {},

      /**
       * Remove all bindings from all bounded items.
       */
      removeBindings: function removeBindings() {}
    }
  });
  qx.ui.list.provider.IListProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The mixin controls the binding between model and item.
   *
   * @internal
   */
  qx.Mixin.define("qx.ui.list.core.MWidgetController", {
    construct: function construct() {
      this.__boundItems = [];
    },
    properties: {
      /**
       * The path to the property which holds the information that should be
       * shown as a label. This is only needed if objects are stored in the model.
       */
      labelPath: {
        check: "String",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * shown as an icon. This is only needed if objects are stored in the model
       * and if the icon should be shown.
       */
      iconPath: {
        check: "String",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as a group label. This is only needed if objects are stored in the
       * model.
       */
      groupLabelPath: {
        check: "String",
        nullable: true
      },

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      labelOptions: {
        nullable: true
      },

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      iconOptions: {
        nullable: true
      },

      /**
       * A map containing the options for the group label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      groupLabelOptions: {
        nullable: true
      },

      /**
       * Delegation object, which can have one or more functions defined by the
       * {@link qx.ui.list.core.IListDelegate} interface.
       */
      delegate: {
        event: "changeDelegate",
        init: null,
        nullable: true
      }
    },
    members: {
      /** @type {Array} which contains the bounded items */
      __boundItems: null,

      /**
       * Helper-Method for binding the default properties from
       * the model to the target widget. The used default properties
       * depends on the passed item. When the passed item is
       * a list item the "label" and "icon" property is used.
       * When the passed item is a group item the "value" property is
       * used.
       *
       * This method should only be called in the
       * {@link IListDelegate#bindItem} function
       * implemented by the {@link #delegate} property.
       *
       * @param item {qx.ui.core.Widget} The internally created and used
       *   list or group item.
       * @param index {Integer} The index of the item.
       */
      bindDefaultProperties: function bindDefaultProperties(item, index) {
        if (item.getUserData("cell.type") != "group") {
          // bind model first
          this.bindProperty("", "model", null, item, index);
          this.bindProperty(this.getLabelPath(), "label", this.getLabelOptions(), item, index);

          if (this.getIconPath() != null) {
            this.bindProperty(this.getIconPath(), "icon", this.getIconOptions(), item, index);
          }
        } else {
          this.bindProperty(this.getGroupLabelPath(), "value", this.getGroupLabelOptions(), item, index);
        }
      },

      /**
       * Helper-Method for binding a given property from the model to the target
       * widget.
       * This method should only be called in the
       * {@link IListDelegate#bindItem} function implemented by the
       * {@link #delegate} property.
       *
       * @param sourcePath {String | null} The path to the property in the model.
       *   If you use an empty string, the whole model item will be bound.
       * @param targetProperty {String} The name of the property in the target widget.
       * @param options {Map | null} The options to use for the binding.
       * @param targetWidget {qx.ui.core.Widget} The target widget.
       * @param index {Integer} The index of the current binding.
       */
      bindProperty: function bindProperty(sourcePath, targetProperty, options, targetWidget, index) {
        var type = targetWidget.getUserData("cell.type");

        var bindPath = this.__getBindPath(index, sourcePath, type);

        if (options) {
          options.ignoreConverter = "model";
        }

        var id = this._list.bind(bindPath, targetWidget, targetProperty, options);

        this.__addBinding(targetWidget, id);
      },

      /**
       * Helper-Method for binding a given property from the target widget to
       * the model.
       * This method should only be called in the
       * {@link IListDelegate#bindItem} function implemented by the
       * {@link #delegate} property.
       *
       * @param targetPath {String | null} The path to the property in the model.
       * @param sourceProperty {String} The name of the property in the target.
       * @param options {Map | null} The options to use for the binding.
       * @param sourceWidget {qx.ui.core.Widget} The source widget.
       * @param index {Integer} The index of the current binding.
       */
      bindPropertyReverse: function bindPropertyReverse(targetPath, sourceProperty, options, sourceWidget, index) {
        var type = sourceWidget.getUserData("cell.type");

        var bindPath = this.__getBindPath(index, targetPath, type);

        var id = sourceWidget.bind(sourceProperty, this._list, bindPath, options);

        this.__addBinding(sourceWidget, id);
      },

      /**
       * Remove all bindings from all bounded items.
       */
      removeBindings: function removeBindings() {
        while (this.__boundItems.length > 0) {
          var item = this.__boundItems.pop();

          this._removeBindingsFrom(item);
        }
      },

      /**
       * Configure the passed item if a delegate is set and the needed
       * function {@link IListDelegate#configureItem} is available.
       *
       * @param item {qx.ui.core.Widget} item to configure.
       */
      _configureItem: function _configureItem(item) {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.configureItem != null) {
          delegate.configureItem(item);
        }
      },

      /**
       * Configure the passed item if a delegate is set and the needed
       * function {@link IListDelegate#configureGroupItem} is available.
       *
       * @param item {qx.ui.core.Widget} item to configure.
       */
      _configureGroupItem: function _configureGroupItem(item) {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.configureGroupItem != null) {
          delegate.configureGroupItem(item);
        }
      },

      /**
       * Sets up the binding for the given item and index.
       *
       * @param item {qx.ui.core.Widget} The internally created and used item.
       * @param index {Integer} The index of the item.
       */
      _bindItem: function _bindItem(item, index) {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.bindItem != null) {
          delegate.bindItem(this, item, index);
        } else {
          this.bindDefaultProperties(item, index);
        }
      },

      /**
       * Sets up the binding for the given group item and index.
       *
       * @param item {qx.ui.core.Widget} The internally created and used item.
       * @param index {Integer} The index of the item.
       */
      _bindGroupItem: function _bindGroupItem(item, index) {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.bindGroupItem != null) {
          delegate.bindGroupItem(this, item, index);
        } else {
          this.bindDefaultProperties(item, index);
        }
      },

      /**
       * Removes the binding of the given item.
       *
       * @param item {qx.ui.core.Widget} The item which the binding should
       *   be removed.
       */
      _removeBindingsFrom: function _removeBindingsFrom(item) {
        var bindings = this.__getBindings(item);

        while (bindings.length > 0) {
          var id = bindings.pop();

          try {
            this._list.removeBinding(id);
          } catch (e) {
            item.removeBinding(id);
          }
        }

        if (this.__boundItems.includes(item)) {
          qx.lang.Array.remove(this.__boundItems, item);
        }
      },

      /**
       * Helper method to create the path for binding.
       *
       * @param index {Integer} The index of the item.
       * @param path {String|null} The path to the property.
       * @param type {String} The type <code>["item", "group"]</code>.
       * @return {String} The binding path
       */
      __getBindPath: function __getBindPath(index, path, type) {
        var bindPath = "model[" + index + "]";

        if (type == "group") {
          bindPath = "groups[" + index + "]";
        }

        if (path != null && path != "") {
          bindPath += "." + path;
        }

        return bindPath;
      },

      /**
       * Helper method to save the binding for the widget.
       *
       * @param widget {qx.ui.core.Widget} widget to save binding.
       * @param id {var} the id from the binding.
       */
      __addBinding: function __addBinding(widget, id) {
        var bindings = this.__getBindings(widget);

        if (!bindings.includes(id)) {
          bindings.push(id);
        }

        if (!this.__boundItems.includes(widget)) {
          this.__boundItems.push(widget);
        }
      },

      /**
       * Helper method which returns all bound id from the widget.
       *
       * @param widget {qx.ui.core.Widget} widget to get all binding.
       * @return {Array} all bound id's.
       */
      __getBindings: function __getBindings(widget) {
        var bindings = widget.getUserData("BindingIds");

        if (bindings == null) {
          bindings = [];
          widget.setUserData("BindingIds", bindings);
        }

        return bindings;
      }
    },
    destruct: function destruct() {
      this.__boundItems = null;
    }
  });
  qx.ui.list.core.MWidgetController.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.IWidgetCellProvider": {
        "require": true
      },
      "qx.ui.list.provider.IListProvider": {
        "require": true
      },
      "qx.ui.list.core.MWidgetController": {
        "require": true
      },
      "qx.ui.virtual.layer.WidgetCell": {},
      "qx.util.Delegate": {},
      "qx.ui.form.ListItem": {},
      "qx.ui.virtual.cell.WidgetCell": {},
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The provider implements the {@link qx.ui.virtual.core.IWidgetCellProvider} API,
   * which can be used as delegate for the widget cell rendering and it
   * provides a API to bind the model with the rendered item.
   *
   * @internal
   */
  qx.Class.define("qx.ui.list.provider.WidgetProvider", {
    extend: qx.core.Object,
    implement: [qx.ui.virtual.core.IWidgetCellProvider, qx.ui.list.provider.IListProvider],
    include: [qx.ui.list.core.MWidgetController],

    /**
     * Creates the <code>WidgetProvider</code>
     *
     * @param list {qx.ui.list.List} list to provide.
     */
    construct: function construct(list) {
      qx.core.Object.constructor.call(this);
      this._list = list;
      this._itemRenderer = this.createItemRenderer();
      this._groupRenderer = this.createGroupRenderer();

      this._itemRenderer.addListener("created", this._onItemCreated, this);

      this._groupRenderer.addListener("created", this._onGroupItemCreated, this);

      this._list.addListener("changeDelegate", this._onChangeDelegate, this);
    },
    members: {
      /** @type {qx.ui.virtual.cell.WidgetCell} the used item renderer */
      _itemRenderer: null,

      /** @type {qx.ui.virtual.cell.WidgetCell} the used group renderer */
      _groupRenderer: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */
      // interface implementation
      getCellWidget: function getCellWidget(row, column) {
        var widget = null;

        if (!this._list._isGroup(row)) {
          widget = this._itemRenderer.getCellWidget();
          widget.setUserData("cell.type", "item");

          this._bindItem(widget, this._list._lookup(row));

          if (this._list._manager.isItemSelected(row)) {
            this._styleSelectabled(widget);
          } else {
            this._styleUnselectabled(widget);
          }
        } else {
          widget = this._groupRenderer.getCellWidget();
          widget.setUserData("cell.type", "group");

          this._bindGroupItem(widget, this._list._lookupGroup(row));
        }

        return widget;
      },
      // interface implementation
      poolCellWidget: function poolCellWidget(widget) {
        this._removeBindingsFrom(widget);

        if (widget.getUserData("cell.type") == "item") {
          this._itemRenderer.pool(widget);
        } else if (widget.getUserData("cell.type") == "group") {
          this._groupRenderer.pool(widget);
        }

        this._onPool(widget);
      },
      // interface implementation
      createLayer: function createLayer() {
        return new qx.ui.virtual.layer.WidgetCell(this);
      },
      // interface implementation
      createItemRenderer: function createItemRenderer() {
        var createWidget = qx.util.Delegate.getMethod(this.getDelegate(), "createItem");

        if (createWidget == null) {
          createWidget = function createWidget() {
            return new qx.ui.form.ListItem();
          };
        }

        var renderer = new qx.ui.virtual.cell.WidgetCell();
        renderer.setDelegate({
          createWidget: createWidget
        });
        return renderer;
      },
      // interface implementation
      createGroupRenderer: function createGroupRenderer() {
        var createWidget = qx.util.Delegate.getMethod(this.getDelegate(), "createGroupItem");

        if (createWidget == null) {
          createWidget = function createWidget() {
            var group = new qx.ui.basic.Label();
            group.setAppearance("group-item");
            return group;
          };
        }

        var renderer = new qx.ui.virtual.cell.WidgetCell();
        renderer.setDelegate({
          createWidget: createWidget
        });
        return renderer;
      },
      // interface implementation
      styleSelectabled: function styleSelectabled(row) {
        var widget = this.__getWidgetFrom(row);

        this._styleSelectabled(widget);
      },
      // interface implementation
      styleUnselectabled: function styleUnselectabled(row) {
        var widget = this.__getWidgetFrom(row);

        this._styleUnselectabled(widget);
      },
      // interface implementation
      isSelectable: function isSelectable(row) {
        if (this._list._isGroup(row)) {
          return false;
        }

        var widget = this._list._layer.getRenderedCellWidget(row, 0);

        if (widget != null) {
          return widget.isEnabled();
        } else {
          return true;
        }
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */

      /**
       * Styles a selected item.
       *
       * @param widget {qx.ui.core.Widget} widget to style.
       */
      _styleSelectabled: function _styleSelectabled(widget) {
        this.__updateStates(widget, {
          selected: 1
        });
      },

      /**
       * Styles a not selected item.
       *
       * @param widget {qx.ui.core.Widget} widget to style.
       */
      _styleUnselectabled: function _styleUnselectabled(widget) {
        this.__updateStates(widget, {});
      },

      /**
       * Calls the delegate <code>onPool</code> method when it is used in the
       * {@link #delegate} property.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      _onPool: function _onPool(item) {
        var onPool = qx.util.Delegate.getMethod(this.getDelegate(), "onPool");

        if (onPool != null) {
          onPool(item);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the created item widget event.
       *
       * @param event {qx.event.type.Data} fired event.
       */
      _onItemCreated: function _onItemCreated(event) {
        var widget = event.getData();

        this._configureItem(widget);
      },

      /**
       * Event handler for the created item widget event.
       *
       * @param event {qx.event.type.Data} fired event.
       */
      _onGroupItemCreated: function _onGroupItemCreated(event) {
        var widget = event.getData();

        this._configureGroupItem(widget);
      },

      /**
       * Event handler for the change delegate event.
       *
       * @param event {qx.event.type.Data} fired event.
       */
      _onChangeDelegate: function _onChangeDelegate(event) {
        this._itemRenderer.dispose();

        this._itemRenderer = this.createItemRenderer();

        this._itemRenderer.addListener("created", this._onItemCreated, this);

        this._groupRenderer.dispose();

        this._groupRenderer = this.createGroupRenderer();

        this._groupRenderer.addListener("created", this._onGroupItemCreated, this);

        this.removeBindings();

        this._list.getPane().fullUpdate();
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Helper method to get the widget from the passed row.
       *
       * @param row {Integer} row to search.
       * @return {qx.ui.core.Widget|null} The found widget or <code>null</code> when no widget found.
       */
      __getWidgetFrom: function __getWidgetFrom(row) {
        return this._list._layer.getRenderedCellWidget(row, 0);
      },

      /**
       * Helper method to update the states from a widget.
       *
       * @param widget {qx.ui.core.Widget} widget to set states.
       * @param states {Map} the state to set.
       */
      __updateStates: function __updateStates(widget, states) {
        if (widget == null) {
          return;
        }

        this._itemRenderer.updateStates(widget, states);
      }
    },
    destruct: function destruct() {
      this._itemRenderer.dispose();

      this._groupRenderer.dispose();

      this._itemRenderer = this._groupRenderer = null;
    }
  });
  qx.ui.list.provider.WidgetProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The axis maps virtual screen coordinates to item indexes. By default all
   * items have the same size but it is also possible to give specific items
   * a different size.
   */
  qx.Class.define("qx.ui.virtual.core.Axis", {
    extend: qx.core.Object,

    /**
     * @param defaultItemSize {Integer} The default size of the items.
     * @param itemCount {Integer} The number of item on the axis.
     */
    construct: function construct(defaultItemSize, itemCount) {
      qx.core.Object.constructor.call(this);
      this.itemCount = itemCount;
      this.defaultItemSize = defaultItemSize; // sparse array

      this.customSizes = {};
    },
    events: {
      /** Every change to the axis configuration triggers this event. */
      "change": "qx.event.type.Event"
    },
    members: {
      __ranges: null,

      /**
       * Get the default size of the items.
       *
       * @return {Integer} The default item size.
       */
      getDefaultItemSize: function getDefaultItemSize() {
        return this.defaultItemSize;
      },

      /**
       * Set the default size the items.
       *
       * @param defaultItemSize {Integer} The default size of the items.
       */
      setDefaultItemSize: function setDefaultItemSize(defaultItemSize) {
        if (this.defaultItemSize !== defaultItemSize) {
          this.defaultItemSize = defaultItemSize;
          this.__ranges = null;
          this.fireNonBubblingEvent("change");
        }
      },

      /**
       * Get the number of items in the axis.
       *
       * @return {Integer} The number of items.
       */
      getItemCount: function getItemCount() {
        return this.itemCount;
      },

      /**
       * Set the number of items in the axis.
       *
       * @param itemCount {Integer} The new item count.
       */
      setItemCount: function setItemCount(itemCount) {
        if (this.itemCount !== itemCount) {
          this.itemCount = itemCount;
          this.__ranges = null;
          this.fireNonBubblingEvent("change");
        }
      },

      /**
       * Sets the size of a specific item. This allow item, which have a size
       * different from the default size.
       *
       * @param index {Integer} Index of the item to change.
       * @param size {Integer} New size of the item.
       */
      setItemSize: function setItemSize(index, size) {
        {
          this.assertArgumentsCount(arguments, 2, 2);
          this.assert(size >= 0 || size === null, "'size' must be 'null' or an integer larger than 0.");
        }

        if (this.customSizes[index] == size) {
          return;
        }

        if (size === null) {
          delete this.customSizes[index];
        } else {
          this.customSizes[index] = size;
        }

        this.__ranges = null;
        this.fireNonBubblingEvent("change");
      },

      /**
       * Get the size of the item at the given index.
       *
       * @param index {Integer} Index of the item to get the size for.
       * @return {Integer} Size of the item.
       */
      getItemSize: function getItemSize(index) {
        // custom size of 0 is not allowed
        return this.customSizes[index] || this.defaultItemSize;
      },

      /**
       * Reset all custom sizes set with {@link #setItemSize}.
       */
      resetItemSizes: function resetItemSizes() {
        this.customSizes = {};
        this.__ranges = null;
        this.fireNonBubblingEvent("change");
      },

      /**
       * Split the position range into disjunct intervals. Each interval starts
       * with a custom sized cell. Each position is contained in exactly one range.
       * The ranges are sorted according to their start position.
       *
       * Complexity: O(n log n) (n = number of custom sized cells)
       *
       * @return {Map[]} The sorted list of ranges.
       */
      __getRanges: function __getRanges() {
        if (this.__ranges) {
          return this.__ranges;
        }

        var defaultSize = this.defaultItemSize;
        var itemCount = this.itemCount;
        var indexes = [];

        for (var key in this.customSizes) {
          var index = parseInt(key, 10);

          if (index < itemCount) {
            indexes.push(index);
          }
        }

        if (indexes.length == 0) {
          var ranges = [{
            startIndex: 0,
            endIndex: itemCount - 1,
            firstItemSize: defaultSize,
            rangeStart: 0,
            rangeEnd: itemCount * defaultSize - 1
          }];
          this.__ranges = ranges;
          return ranges;
        }

        indexes.sort(function (a, b) {
          return a > b ? 1 : -1;
        });
        var ranges = [];
        var correctionSum = 0;

        for (var i = 0; i < indexes.length; i++) {
          var index = indexes[i];

          if (index >= itemCount) {
            break;
          }

          var cellSize = this.customSizes[index];
          var rangeStart = index * defaultSize + correctionSum;
          correctionSum += cellSize - defaultSize;
          ranges[i] = {
            startIndex: index,
            firstItemSize: cellSize,
            rangeStart: rangeStart
          };

          if (i > 0) {
            ranges[i - 1].rangeEnd = rangeStart - 1;
            ranges[i - 1].endIndex = index - 1;
          }
        } // fix first range


        if (ranges[0].rangeStart > 0) {
          ranges.unshift({
            startIndex: 0,
            endIndex: ranges[0].startIndex - 1,
            firstItemSize: defaultSize,
            rangeStart: 0,
            rangeEnd: ranges[0].rangeStart - 1
          });
        } // fix last range


        var lastRange = ranges[ranges.length - 1];
        var remainingItemsSize = (itemCount - lastRange.startIndex - 1) * defaultSize;
        lastRange.rangeEnd = lastRange.rangeStart + lastRange.firstItemSize + remainingItemsSize - 1;
        lastRange.endIndex = itemCount - 1;
        this.__ranges = ranges;
        return ranges;
      },

      /**
       * Returns the range, which contains the position
       *
       * Complexity: O(log n) (n = number of custom sized cells)
       *
       * @param position {Integer} The position.
       * @return {Map} The range, which contains the given position.
       */
      __findRangeByPosition: function __findRangeByPosition(position) {
        var ranges = this.__ranges || this.__getRanges();

        var start = 0;
        var end = ranges.length - 1; // binary search in the sorted ranges list

        while (true) {
          var pivot = start + (end - start >> 1);
          var range = ranges[pivot];

          if (range.rangeEnd < position) {
            start = pivot + 1;
          } else if (range.rangeStart > position) {
            end = pivot - 1;
          } else {
            return range;
          }
        }
      },

      /**
       * Get the item and the offset into the item at the given position.
       *
       * @param position {Integer|null} The position to get the item for.
       * @return {Map} A map with the keys <code>index</code> and
       *    <code>offset</code>. The index is the index of the item containing the
       *    position and offsets specifies offset into this item. If the position
       *    is outside of the range, <code>null</code> is returned.
       */
      getItemAtPosition: function getItemAtPosition(position) {
        if (position < 0 || position >= this.getTotalSize()) {
          return null;
        }

        var range = this.__findRangeByPosition(position);

        var startPos = range.rangeStart;
        var index = range.startIndex;
        var firstItemSize = range.firstItemSize;

        if (startPos + firstItemSize > position) {
          return {
            index: index,
            offset: position - startPos
          };
        } else {
          var defaultSize = this.defaultItemSize;
          return {
            index: index + 1 + Math.floor((position - startPos - firstItemSize) / defaultSize),
            offset: (position - startPos - firstItemSize) % defaultSize
          };
        }
      },

      /**
       * Returns the range, which contains the position.
       *
       * Complexity: O(log n) (n = number of custom sized cells)
       *
       * @param index {Integer} The index of the item to get the range for.
       * @return {Map} The range for the index.
       */
      __findRangeByIndex: function __findRangeByIndex(index) {
        var ranges = this.__ranges || this.__getRanges();

        var start = 0;
        var end = ranges.length - 1; // binary search in the sorted ranges list

        while (true) {
          var pivot = start + (end - start >> 1);
          var range = ranges[pivot];

          if (range.endIndex < index) {
            start = pivot + 1;
          } else if (range.startIndex > index) {
            end = pivot - 1;
          } else {
            return range;
          }
        }
      },

      /**
       * Get the start position of the item with the given index.
       *
       * @param index {Integer} The item's index.
       * @return {Integer|null} The start position of the item. If the index is outside
       *    of the axis range <code>null</code> is returned.
       */
      getItemPosition: function getItemPosition(index) {
        if (index < 0 || index >= this.itemCount) {
          return null;
        }

        var range = this.__findRangeByIndex(index);

        if (range.startIndex == index) {
          return range.rangeStart;
        } else {
          return range.rangeStart + range.firstItemSize + (index - range.startIndex - 1) * this.defaultItemSize;
        }
      },

      /**
       * Returns the sum of all cell sizes.
       *
       * @return {Integer} The sum of all item sizes.
       */
      getTotalSize: function getTotalSize() {
        var ranges = this.__ranges || this.__getRanges();

        return ranges[ranges.length - 1].rangeEnd + 1;
      },

      /**
       * Get an array of item sizes starting with the item at "startIndex". The
       * sum of all sizes in the returned array is at least "minSizeSum".
       *
       * @param startIndex {Integer} The index of the first item.
       * @param minSizeSum {Integer} The minimum sum of the item sizes.
       * @return {Integer[]} List of item sizes starting with the size of the item
       *    at index <code>startIndex</code>. The sum of the item sizes is at least
       *    <code>minSizeSum</code>.
       */
      getItemSizes: function getItemSizes(startIndex, minSizeSum) {
        var customSizes = this.customSizes;
        var defaultSize = this.defaultItemSize;
        var sum = 0;
        var sizes = [];
        var i = 0;

        while (sum < minSizeSum) {
          var itemSize = customSizes[startIndex] != null ? customSizes[startIndex] : defaultSize;
          startIndex++;
          sum += itemSize;
          sizes[i++] = itemSize;

          if (startIndex >= this.itemCount) {
            break;
          }
        }

        return sizes;
      }
    },
    destruct: function destruct() {
      this.customSizes = this.__ranges = null;
    }
  });
  qx.ui.virtual.core.Axis.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.type.Pointer": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * David Perez Carmona (david-perez)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A cell event instance contains all data for pointer events related to cells in
   * a pane.
   **/
  qx.Class.define("qx.ui.virtual.core.CellEvent", {
    extend: qx.event.type.Pointer,
    properties: {
      /** The table row of the event target. */
      row: {
        check: "Integer",
        nullable: true
      },

      /** The table column of the event target. */
      column: {
        check: "Integer",
        nullable: true
      }
    },
    members: {
      /**
       * Initialize the event.
       *
       * @param scroller {qx.ui.table.pane.Scroller} The tables pane scroller.
       * @param me {qx.event.type.Pointer} The original pointer event.
       * @param row {Integer?null} The cell's row index.
       * @param column {Integer?null} The cell's column index.
       */
      init: function init(scroller, me, row, column) {
        me.clone(this);
        this.setBubbles(false);
        this.setRow(row);
        this.setColumn(column);
      }
    }
  });
  qx.ui.virtual.core.CellEvent.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MChildrenHandling": {
        "require": true
      },
      "qx.ui.virtual.core.IWidgetCellProvider": {
        "construct": true
      },
      "qx.ui.core.Spacer": {},
      "qx.ui.core.FocusHandler": {},
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The WidgetCell layer renders each cell with a qooxdoo widget. The concrete
   * widget instance for each cell is provided by a cell provider.
   */
  qx.Class.define("qx.ui.virtual.layer.WidgetCell", {
    extend: qx.ui.virtual.layer.Abstract,
    include: [qx.ui.core.MChildrenHandling],

    /**
     * @param widgetCellProvider {qx.ui.virtual.core.IWidgetCellProvider} This
     *    class manages the life cycle of the cell widgets.
     */
    construct: function construct(widgetCellProvider) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this.setZIndex(12);
      {
        this.assertInterface(widgetCellProvider, qx.ui.virtual.core.IWidgetCellProvider);
      }
      this._cellProvider = widgetCellProvider;
      this.__spacerPool = [];
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      anonymous: {
        refine: true,
        init: false
      }
    },
    events: {
      /**
       * Is fired when the {@link #_fullUpdate} or the
       * {@link #_updateLayerWindow} is finished.
       */
      updated: "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __spacerPool: null,

      /**
      * Returns the widget used to render the given cell. May return null if the
      * cell isn’t rendered currently rendered.
      *
      * @param row {Integer} The cell's row index
      * @param column {Integer} The cell's column index
      * @return {qx.ui.core.LayoutItem|null} the widget used to render the given
      *    cell or <code>null</code>
      */
      getRenderedCellWidget: function getRenderedCellWidget(row, column) {
        if (this._getChildren().length === 0) {
          return null;
        }

        var columnCount = this.getColumnSizes().length;
        var rowCount = this.getRowSizes().length;
        var firstRow = this.getFirstRow();
        var firstColumn = this.getFirstColumn();

        if (row < firstRow || row >= firstRow + rowCount || column < firstColumn || column >= firstColumn + columnCount) {
          return null;
        }

        var childIndex = column - firstColumn + (row - firstRow) * columnCount;

        var widget = this._getChildren()[childIndex];

        if (!widget || widget.getUserData("cell.empty")) {
          return null;
        } else {
          return widget;
        }
      },

      /**
       * Get the spacer widget, for empty cells
       *
       * @return {qx.ui.core.Spacer} The spacer widget.
       */
      _getSpacer: function _getSpacer() {
        var spacer = this.__spacerPool.pop();

        if (!spacer) {
          spacer = new qx.ui.core.Spacer();
          spacer.setUserData("cell.empty", 1);
        }

        return spacer;
      },

      /**
       * Activates one of the still not empty items.
       * @param elementToPool {qx.ui.core.Widget} The widget which gets pooled.
       */
      _activateNotEmptyChild: function _activateNotEmptyChild(elementToPool) {
        // get the current active element
        var active = qx.ui.core.FocusHandler.getInstance().getActiveWidget(); // if the element to pool is active or one of its children

        if (active == elementToPool || qx.ui.core.Widget.contains(elementToPool, active)) {
          // search for a new child to activate
          var children = this._getChildren();

          for (var i = children.length - 1; i >= 0; i--) {
            if (!children[i].getUserData("cell.empty")) {
              children[i].activate();
              break;
            }
          }

          ;
        }
      },
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var cellProvider = this._cellProvider;

        var children = this._getChildren().concat();

        for (var i = 0; i < children.length; i++) {
          var child = children[i];

          if (child.getUserData("cell.empty")) {
            this.__spacerPool.push(child);
          } else {
            this._activateNotEmptyChild(child);

            cellProvider.poolCellWidget(child);
          }
        }

        var top = 0;
        var left = 0;
        var visibleItems = [];

        for (var y = 0; y < rowSizes.length; y++) {
          for (var x = 0; x < columnSizes.length; x++) {
            var row = firstRow + y;
            var column = firstColumn + x;

            var item = cellProvider.getCellWidget(row, column) || this._getSpacer();

            visibleItems.push(item);
            item.setUserBounds(left, top, columnSizes[x], rowSizes[y]);
            item.setUserData("cell.row", row);
            item.setUserData("cell.column", column);

            this._add(item);

            left += columnSizes[x];
          }

          top += rowSizes[y];
          left = 0;
        }

        children.forEach(function (child) {
          if (visibleItems.indexOf(child) === -1) {
            this._remove(child);
          }
        }.bind(this));
        this.fireEvent("updated");
      },
      _updateLayerWindow: function _updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        // compute overlap of old and new window
        //
        //      +---+
        //      |  ##--+
        //      |  ##  |
        //      +--##  |
        //         +---+
        //
        {
          this.assertPositiveInteger(firstRow);
          this.assertPositiveInteger(firstColumn);
          this.assertArray(rowSizes);
          this.assertArray(columnSizes);
        }
        var lastRow = firstRow + rowSizes.length - 1;
        var lastColumn = firstColumn + columnSizes.length - 1;
        var overlap = {
          firstRow: Math.max(firstRow, this.getFirstRow()),
          lastRow: Math.min(lastRow, this._lastRow),
          firstColumn: Math.max(firstColumn, this.getFirstColumn()),
          lastColumn: Math.min(lastColumn, this._lastColumn)
        };
        this._lastColumn = lastColumn;
        this._lastRow = lastRow;

        if (overlap.firstRow > overlap.lastRow || overlap.firstColumn > overlap.lastColumn) {
          return this._fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
        } // collect the widgets to move


        var children = this._getChildren();

        var lineLength = this.getColumnSizes().length;
        var widgetsToMove = [];
        var widgetsToMoveIndexes = {};

        for (var row = firstRow; row <= lastRow; row++) {
          widgetsToMove[row] = [];

          for (var column = firstColumn; column <= lastColumn; column++) {
            if (row >= overlap.firstRow && row <= overlap.lastRow && column >= overlap.firstColumn && column <= overlap.lastColumn) {
              var x = column - this.getFirstColumn();
              var y = row - this.getFirstRow();
              var index = y * lineLength + x;
              widgetsToMove[row][column] = children[index];
              widgetsToMoveIndexes[index] = true;
            }
          }
        }

        var cellProvider = this._cellProvider; // pool widgets

        var children = this._getChildren().concat();

        for (var i = 0; i < children.length; i++) {
          if (!widgetsToMoveIndexes[i]) {
            var child = children[i];

            if (child.getUserData("cell.empty")) {
              this.__spacerPool.push(child);
            } else {
              this._activateNotEmptyChild(child);

              cellProvider.poolCellWidget(child);
            }
          }
        }

        var top = 0;
        var left = 0;
        var visibleItems = [];

        for (var y = 0; y < rowSizes.length; y++) {
          for (var x = 0; x < columnSizes.length; x++) {
            var row = firstRow + y;
            var column = firstColumn + x;

            var item = widgetsToMove[row][column] || cellProvider.getCellWidget(row, column) || this._getSpacer();

            visibleItems.push(item);
            item.setUserBounds(left, top, columnSizes[x], rowSizes[y]);
            item.setUserData("cell.row", row);
            item.setUserData("cell.column", column);

            this._add(item);

            left += columnSizes[x];
          }

          top += rowSizes[y];
          left = 0;
        }

        children.forEach(function (child) {
          if (visibleItems.indexOf(child) === -1) {
            this._remove(child);
          }
        }.bind(this));
        this.fireEvent("updated");
      }
    },
    destruct: function destruct() {
      var children = this._getChildren();

      for (var i = 0; i < children.length; i++) {
        children[i].dispose();
      }

      this._cellProvider = this.__spacerPool = null;
    }
  });
  qx.ui.virtual.layer.WidgetCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A widget cell renderer manages a pool of widgets to render cells in a
   * {@link qx.ui.virtual.layer.WidgetCell} layer.
   */
  qx.Interface.define("qx.ui.virtual.cell.IWidgetCell", {
    members: {
      /**
       * Get a widget instance to render the cell
       *
       * @param data {var} Data needed for the cell to render.
       * @param states {Map} The states set on the cell (e.g. <i>selected</i>,
       * <i>focused</i>, <i>editable</i>).
       *
       * @return {qx.ui.core.LayoutItem} The cell widget
       */
      getCellWidget: function getCellWidget(data, states) {},

      /**
       * Release the given widget instance.
       *
       * Either pool or dispose the widget.
       *
       * @param widget {qx.ui.core.LayoutItem} The cell widget to pool
       */
      pool: function pool(widget) {},

      /**
       * Update the states of the given widget.
       *
       * @param widget {qx.ui.core.LayoutItem} The cell widget to update
       * @param states {Map} The cell widget's states
       */
      updateStates: function updateStates(widget, states) {},

      /**
       * Update the data the cell widget should display
       *
       * @param widget {qx.ui.core.LayoutItem} The cell widget to update
       * @param data {var} The data to display
       */
      updateData: function updateData(widget, data) {}
    }
  });
  qx.ui.virtual.cell.IWidgetCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.cell.IWidgetCell": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * Abstract base class for widget based cell renderer.
   */
  qx.Class.define("qx.ui.virtual.cell.AbstractWidget", {
    extend: qx.core.Object,
    implement: [qx.ui.virtual.cell.IWidgetCell],
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__pool = [];
    },
    events: {
      /** Fired when a new <code>LayoutItem</code> is created. */
      "created": "qx.event.type.Data"
    },
    members: {
      __pool: null,

      /**
       * Creates the widget instance.
       *
       * @abstract
       * @return {qx.ui.core.LayoutItem} The widget used to render a cell
       */
      _createWidget: function _createWidget() {
        throw new Error("abstract method call");
      },
      // interface implementation
      updateData: function updateData(widget, data) {
        throw new Error("abstract method call");
      },
      // interface implementation
      updateStates: function updateStates(widget, states) {
        var oldStates = widget.getUserData("cell.states"); // remove old states

        if (oldStates) {
          var newStates = states || {};

          for (var state in oldStates) {
            if (!newStates[state]) {
              widget.removeState(state);
            }
          }
        } else {
          oldStates = {};
        } // apply new states


        if (states) {
          for (var state in states) {
            if (!oldStates.state) {
              widget.addState(state);
            }
          }
        }

        widget.setUserData("cell.states", states);
      },
      // interface implementation
      getCellWidget: function getCellWidget(data, states) {
        var widget = this.__getWidgetFromPool();

        this.updateStates(widget, states);
        this.updateData(widget, data);
        return widget;
      },
      // interface implementation
      pool: function pool(widget) {
        this.__pool.push(widget);
      },

      /**
       * Cleanup all <code>LayoutItem</code> and destroy them.
       */
      _cleanupPool: function _cleanupPool() {
        var widget = this.__pool.pop();

        while (widget) {
          widget.destroy();
          widget = this.__pool.pop();
        }
      },

      /**
       * Returns a <code>LayoutItem</code> from the pool, when the pool is empty
       * a new <code>LayoutItem</code> is created.
       *
       * @return {qx.ui.core.LayoutItem} The cell widget
       */
      __getWidgetFromPool: function __getWidgetFromPool() {
        var widget = this.__pool.shift();

        if (widget == null) {
          widget = this._createWidget();
          this.fireDataEvent("created", widget);
        }

        return widget;
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this._cleanupPool();

      this.__pool = null;
    }
  });
  qx.ui.virtual.cell.AbstractWidget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.AbstractWidget": {
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.util.PropertyUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Cell renderer can be used for Widget rendering. The Widget creation can be configured with the
   * {@link #delegate} property:
   *
   * <pre class="javascript">
   * widgetCell.setDelegate(
   * {
   *   createWidget : function() {
   *     return new qx.ui.form.ListItem();
   *   }
   * });
   * </pre>
   *
   * When the {@link #delegate} property is not used {@link qx.ui.core.Widget} instances are created as
   * fallback.
   *
   * The {@link #updateData} method can be used to update any Widget property. Just use a <code>Map</code>
   * with property name as key:
   *
   * <pre class="javascript">
   * // widget is a qx.ui.form.ListItem instance
   * widgetCell.updateData(widget,
   * {
   *   label: "my label value",
   *   icon: "qx/icon/22/emotes/face-angel.png"
   * });
   * </pre>
   */
  qx.Class.define("qx.ui.virtual.cell.WidgetCell", {
    extend: qx.ui.virtual.cell.AbstractWidget,
    properties: {
      /**
       * Delegation object, which can have one or more functions defined by the
       * {@link qx.ui.virtual.cell.IWidgetCellDelegate} interface.
       */
      delegate: {
        apply: "_applyDelegate",
        init: null,
        nullable: true
      }
    },
    members: {
      // apply method
      _applyDelegate: function _applyDelegate(value, old) {
        this._cleanupPool();
      },
      // overridden
      _createWidget: function _createWidget() {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.createWidget != null) {
          return delegate.createWidget();
        } else {
          return new qx.ui.core.Widget();
        }
      },
      // overridden
      updateData: function updateData(widget, data) {
        for (var key in data) {
          if (qx.Class.hasProperty(widget.constructor, key)) {
            qx.util.PropertyUtil.setUserValue(widget, key, data[key]);
          } else {
            throw new Error("Can't update data! The key '" + key + "' is not a Property!");
          }
        }
      }
    }
  });
  qx.ui.virtual.cell.WidgetCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.IBooleanForm": {},
      "qx.ui.form.CheckBox": {},
      "qx.ui.form.ToggleButton": {},
      "qx.ui.menu.CheckBox": {},
      "qx.ui.form.RadioButton": {},
      "qx.ui.menu.RadioButton": {},
      "qx.ui.groupbox.RadioGroupBox": {},
      "qx.ui.groupbox.CheckGroupBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.BooleanFormat", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __test: function __test(widget, initValue) {
        // check if the interface is implemented
        this.assertTrue(qx.Class.hasInterface(widget.constructor, qx.ui.form.IBooleanForm), "Interface is not implemented."); // check for the init value

        this.assertEquals(initValue, widget.getValue(), "Wrong init value set."); // just check if the method is available

        widget.resetValue(); // check the getter and setter

        widget.setValue(true);
        this.assertEquals(true, widget.getValue(), "Set or get does not work.");
        var self = this;
        this.assertEventFired(widget, "changeValue", function () {
          widget.setValue(false);
        }, function (e) {
          self.assertEquals(false, e.getData(), "Not the right data in the event.");
          self.assertEquals(true, e.getOldData(), "Wrong old data in the event.");
        }, "Event is wrong!"); // test for null values

        widget.setValue(null);
        widget.destroy();
      },
      testCheckBox: function testCheckBox() {
        this.__test(new qx.ui.form.CheckBox(), false);
      },
      testToggleButton: function testToggleButton() {
        this.__test(new qx.ui.form.ToggleButton(), false);
      },
      testMenuCheckBox: function testMenuCheckBox() {
        this.__test(new qx.ui.menu.CheckBox(), false);
      },
      testRadioButton: function testRadioButton() {
        this.__test(new qx.ui.form.RadioButton(), false);
      },
      testMenuRadioButton: function testMenuRadioButton() {
        this.__test(new qx.ui.menu.RadioButton(), false);
      },
      testRadioGroupBox: function testRadioGroupBox() {
        this.__test(new qx.ui.groupbox.RadioGroupBox(), true);
      },
      testCheckGroupBox: function testCheckGroupBox() {
        this.__test(new qx.ui.groupbox.CheckGroupBox(), true);
      }
    }
  });
  qx.test.ui.form.BooleanFormat.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.IColorForm": {},
      "qx.ui.control.ColorSelector": {},
      "qx.ui.control.ColorPopup": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.Color", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __test: function __test(widget) {
        // check if the interface is implemented
        this.assertTrue(qx.Class.hasInterface(widget.constructor, qx.ui.form.IColorForm), "Interface is not implemented."); // check for the init value

        this.assertNull(widget.getValue(), "Wrong init value set."); // just check if the method is available

        widget.resetValue(); // check the getter and setter

        widget.setValue("#008000");
        this.assertEquals("#008000", widget.getValue(), "Set or get does not work.");
        var self = this;
        this.assertEventFired(widget, "changeValue", function () {
          widget.setValue("#CCCCCC");
        }, function (e) {
          self.assertEquals("#CCCCCC", e.getData(), "Wrong data in the event.");
        }, "Event is wrong!"); // test for null values

        widget.setValue(null);
        widget.destroy();
      },
      testColorSelector: function testColorSelector() {
        this.__test(new qx.ui.control.ColorSelector());
      },
      testColorPopup: function testColorPopup() {
        this.__test(new qx.ui.control.ColorPopup());
      }
    }
  });
  qx.test.ui.form.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.ui.form.ComboBox": {},
      "qx.ui.form.ListItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.ComboBox", {
    extend: qx.test.ui.LayoutTestCase,
    include: qx.dev.unit.MMock,
    members: {
      testWithSetValueWithArbitraryValue: function testWithSetValueWithArbitraryValue() {
        var combobox = this.__createComboBox("arbitrary value");

        this.getRoot().add(combobox);
        this.flush();
        this.assertIdentical("arbitrary value", combobox.getValue(), "Wrong result from getValue()");
        combobox.open();
        this.flush();
        this.assertIdentical(0, combobox.getChildrenContainer().getSelection().length, "The pop-up list has an item selected!");
        this.getRoot().removeAll();
        combobox.dispose();
        this.flush();
      },
      testWithSetValueWith: function testWithSetValueWith() {
        var combobox = this.__createComboBox("Item 0");

        this.getRoot().add(combobox);
        this.flush();
        this.assertIdentical("Item 0", combobox.getValue(), "Wrong result from getValue()");
        combobox.open();
        this.flush();
        var list = combobox.getChildrenContainer();
        var item = list.findItem("Item 0");
        this.assertIdentical(item, list.getSelection()[0], "The wrong item selected in pop-up list!"); // check if the combobox is case sensitive, [BUG #3024]

        combobox.setValue("item 2");
        this.assertEquals("item 2", combobox.getValue());
        this.assertEquals(0, list.getSelection().length);
        this.getRoot().removeAll();
        combobox.dispose();
        this.flush();
      },
      testWithoutSetValue: function testWithoutSetValue() {
        var combobox = this.__createComboBox();

        this.getRoot().add(combobox);
        this.flush();
        this.assertIdentical(null, combobox.getValue(), "Wrong result from getValue()");
        combobox.open();
        this.flush();
        this.assertIdentical(0, combobox.getChildrenContainer().getSelection().length, "The pop-up list has an item selected!");
        this.getRoot().removeAll();
        combobox.dispose();
        this.flush();
      },
      testFocusTextOnClose: function testFocusTextOnClose() {
        var combobox = this.__createComboBox();

        this.getRoot().add(combobox);
        this.flush(); // Open list popup

        combobox.open();
        this.flush(); // Select item

        var list = combobox.getChildControl("list");
        var item = list.findItem("Item 0");
        list.setSelection([item]);
        this.flush(); // Asssert focus on close

        this.spy(combobox, "tabFocus");
        combobox.close();
        this.assertCalled(combobox.tabFocus);
        this.getRoot().removeAll();
        combobox.dispose();
      },
      testNotFocusTextOnCloseWhenInvisibleBefore: function testNotFocusTextOnCloseWhenInvisibleBefore() {
        var combobox = this.__createComboBox();

        this.getRoot().add(combobox);
        this.flush(); // Enter value

        combobox.setValue("Item 0");
        this.flush(); // Assert not focus on close

        this.spy(combobox, "tabFocus");
        combobox.close();
        this.assertNotCalled(combobox.tabFocus);
        this.getRoot().removeAll();
        combobox.dispose();
      },
      __createComboBox: function __createComboBox(initValue) {
        var comboBox = new qx.ui.form.ComboBox();

        if (initValue) {
          comboBox.setValue(initValue);
        }

        for (var i = 0; i < 10; i++) {
          comboBox.add(new qx.ui.form.ListItem("Item " + i));
        }

        return comboBox;
      }
    }
  });
  qx.test.ui.form.ComboBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.IDateForm": {},
      "qx.ui.form.DateField": {},
      "qx.ui.control.DateChooser": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.Date", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __test: function __test(widget) {
        // check if the interface is implemented
        this.assertTrue(qx.Class.hasInterface(widget.constructor, qx.ui.form.IDateForm), "Interface is not implemented."); // check for the init value

        this.assertNull(widget.getValue(), "Wrong init value set."); // just check if the method is available

        widget.resetValue(); // check the getter and setter

        var date = new Date(1981, 1, 10);
        widget.setValue(date);
        this.assertEquals(date.toString(), widget.getValue().toString(), "Set or get does not work.");
        var date2 = new Date(2009, 4, 1);
        this.assertEventFired(widget, "changeValue", function () {
          widget.setValue(date2);
        }, function (e) {// do nothing
        }, "Event is wrong!"); // test for null values

        widget.setValue(null);
        widget.destroy();
      },
      testDateField: function testDateField() {
        var df = new qx.ui.form.DateField();

        this.__test(df);

        df.dispose();
      },
      testDateChooser: function testDateChooser() {
        var dc = new qx.ui.control.DateChooser();

        this.__test(dc);

        dc.dispose();
      },
      testDateFieldIsEmpty: function testDateFieldIsEmpty() {
        var field = new qx.ui.form.DateField();
        this.assertTrue(field.isEmpty(), "DateField should be empty on initialization.");
        field.dispose();
      },
      testDateFieldPopupState: function testDateFieldPopupState() {
        var field = new qx.ui.form.DateField();
        this.getRoot().add(field);
        this.flush();
        field.open();
        this.flush();
        this.assertTrue(field.hasState("popupOpen"));
        field.close();
        this.flush();
        this.assertFalse(field.hasState("popupOpen"));
        this.getRoot().remove(field);
        this.flush();
        field.dispose();
        field = null;
      }
    }
  });
  qx.test.ui.form.Date.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IDateForm": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.event.type.Focus": {
        "construct": true
      },
      "qx.locale.Date": {},
      "qx.util.format.DateFormat": {},
      "qx.locale.Manager": {},
      "qx.ui.form.TextField": {},
      "qx.ui.form.Button": {},
      "qx.ui.control.DateChooser": {},
      "qx.ui.popup.Popup": {},
      "qx.ui.layout.VBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * A *date field* is like a combo box with the date as popup. As button to
   * open the calendar a calendar icon is shown at the right to the textfield.
   *
   * To be conform with all form widgets, the {@link qx.ui.form.IForm} interface
   * is implemented.
   *
   * The following example creates a date field and sets the current
   * date as selected.
   *
   * <pre class='javascript'>
   * var dateField = new qx.ui.form.DateField();
   * this.getRoot().add(dateField, {top: 20, left: 20});
   * dateField.setValue(new Date());
   * </pre>
   *
   * @childControl list {qx.ui.control.DateChooser} date chooser component
   * @childControl popup {qx.ui.popup.Popup} popup which shows the list control
   * @childControl textfield {qx.ui.form.TextField} text field for manual date entry
   * @childControl button {qx.ui.form.Button} button that opens the list control
   */
  qx.Class.define("qx.ui.form.DateField", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.form.MForm],
    implement: [qx.ui.form.IForm, qx.ui.form.IDateForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // set the layout

      var layout = new qx.ui.layout.HBox();

      this._setLayout(layout);

      layout.setAlignY("middle"); // text field

      var textField = this._createChildControl("textfield");

      this._createChildControl("button"); // register listeners


      this.addListener("tap", this._onTap, this);
      this.addListener("blur", this._onBlur, this); // forward the focusin and focusout events to the textfield. The textfield
      // is not focusable so the events need to be forwarded manually.

      this.addListener("focusin", function (e) {
        textField.fireNonBubblingEvent("focusin", qx.event.type.Focus);
      }, this);
      this.addListener("focusout", function (e) {
        textField.fireNonBubblingEvent("focusout", qx.event.type.Focus);
      }, this); // initializes the DateField with the default format

      this._setDefaultDateFormat(); // adds a locale change listener


      this._addLocaleChangeListener();
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Whenever the value is changed this event is fired
       *
       *  Event data: The new text value of the field.
       */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The formatter, which converts the selected date to a string. **/
      dateFormat: {
        check: "qx.util.format.DateFormat",
        apply: "_applyDateFormat"
      },

      /**
       * String value which will be shown as a hint if the field is all of:
       * unset, unfocused and enabled. Set to null to not show a placeholder
       * text.
       */
      placeholder: {
        check: "String",
        nullable: true,
        apply: "_applyPlaceholder"
      },
      // overridden
      appearance: {
        refine: true,
        init: "datefield"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 120
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    statics: {
      __dateFormat: null,
      __formatter: null,

      /**
       * Get the shared default date formatter
       *
       * @return {qx.util.format.DateFormat} The shared date formatter
       */
      getDefaultDateFormatter: function getDefaultDateFormatter() {
        var format = qx.locale.Date.getDateFormat("medium").toString();

        if (format == this.__dateFormat) {
          return this.__formatter;
        }

        if (this.__formatter) {
          this.__formatter.dispose();
        }

        this.__formatter = new qx.util.format.DateFormat(format, qx.locale.Manager.getInstance().getLocale());
        this.__dateFormat = format;
        return this.__formatter;
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __localeListenerId: null,

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        invalid: true
      },

      /*
      ---------------------------------------------------------------------------
        PROTECTED METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the default date format which is returned by
       * {@link #getDefaultDateFormatter}. You can override this method to
       * define your own default format.
       */
      _setDefaultDateFormat: function _setDefaultDateFormat() {
        this.setDateFormat(qx.ui.form.DateField.getDefaultDateFormatter());
      },

      /**
       * Checks for "qx.dynlocale" and adds a listener to the locale changes.
       * On every change, {@link #_setDefaultDateFormat} is called to reinitialize
       * the format. You can easily override that method to prevent that behavior.
       */
      _addLocaleChangeListener: function _addLocaleChangeListener() {
        // listen for locale changes
        {
          this.__localeListenerId = qx.locale.Manager.getInstance().addListener("changeLocale", function () {
            this._setDefaultDateFormat();
          }, this);
        }
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC METHODS
      ---------------------------------------------------------------------------
      */

      /**
      * This method sets the date, which will be formatted according to
      * #dateFormat to the date field. It will also select the date in the
      * calendar popup.
      *
      * @param value {Date} The date to set.
       */
      setValue: function setValue(value) {
        // set the date to the textfield
        var textField = this.getChildControl("textfield");
        textField.setValue(this.getDateFormat().format(value)); // set the date in the datechooser

        var dateChooser = this.getChildControl("list");
        dateChooser.setValue(value);
      },

      /**
       * Returns the current set date, parsed from the input-field
       * corresponding to the {@link #dateFormat}.
       * If the given text could not be parsed, <code>null</code> will be returned.
       *
       * @return {Date} The currently set date.
       */
      getValue: function getValue() {
        // get the value of the textfield
        var textfieldValue = this.getChildControl("textfield").getValue(); // return the parsed date

        try {
          if (textfieldValue == null || textfieldValue.length == 0) {
            return null;
          }

          return this.getDateFormat().parse(textfieldValue);
        } catch (ex) {
          return null;
        }
      },

      /**
       * Resets the DateField. The textfield will be empty and the datechooser
       * will also have no selection.
       */
      resetValue: function resetValue() {
        // set the date to the textfield
        var textField = this.getChildControl("textfield");
        textField.setValue(""); // set the date in the datechooser

        var dateChooser = this.getChildControl("list");
        dateChooser.setValue(null);
      },

      /*
      ---------------------------------------------------------------------------
        LIST STUFF
      ---------------------------------------------------------------------------
      */

      /**
       * Shows the date chooser popup.
       */
      open: function open() {
        var popup = this.getChildControl("popup");
        popup.placeToWidget(this, true);
        popup.show();
      },

      /**
       * Hides the date chooser popup.
       */
      close: function close() {
        this.getChildControl("popup").hide();
      },

      /**
       * Toggles the date chooser popup visibility.
       */
      toggle: function toggle() {
        var isListOpen = this.getChildControl("popup").isVisible();

        if (isListOpen) {
          this.close();
        } else {
          this.open();
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY METHODS
      ---------------------------------------------------------------------------
      */
      // property apply routine
      _applyDateFormat: function _applyDateFormat(value, old) {
        // if old is undefined or null do nothing
        if (!old) {
          return;
        } // get the date with the old date format


        try {
          var textfield = this.getChildControl("textfield");
          var dateStr = textfield.getValue();

          if (dateStr != null) {
            var currentDate = old.parse(dateStr);
            textfield.setValue(value.format(currentDate));
          }
        } catch (ex) {// do nothing if the former date could not be parsed
        }
      },
      // property apply routine
      _applyPlaceholder: function _applyPlaceholder(value, old) {
        this.getChildControl("textfield").setPlaceholder(value);
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "textfield":
            control = new qx.ui.form.TextField();
            control.setFocusable(false);
            control.addState("inner");
            control.addListener("changeValue", this._onTextFieldChangeValue, this);
            control.addListener("blur", this.close, this);

            this._add(control, {
              flex: 1
            });

            break;

          case "button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.setKeepActive(true);
            control.addState("inner");
            control.addListener("execute", this.toggle, this);

            this._add(control);

            break;

          case "list":
            control = new qx.ui.control.DateChooser();
            control.setFocusable(false);
            control.setKeepFocus(true);
            control.addListener("execute", this._onChangeDate, this);
            break;

          case "popup":
            control = new qx.ui.popup.Popup(new qx.ui.layout.VBox());
            control.setAutoHide(false);
            control.add(this.getChildControl("list"));
            control.addListener("pointerup", this._onChangeDate, this);
            control.addListener("changeVisibility", this._onPopupChangeVisibility, this);
            break;
        }

        return control || qx.ui.form.DateField.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Handler method which handles the tap on the calender popup.
       *
       * @param e {qx.event.type.Pointer} The pointer event.
       */
      _onChangeDate: function _onChangeDate(e) {
        var textField = this.getChildControl("textfield");
        var selectedDate = this.getChildControl("list").getValue();
        textField.setValue(this.getDateFormat().format(selectedDate));
        this.close();
      },

      /**
       * Toggles the popup's visibility.
       *
       * @param e {qx.event.type.Pointer} Pointer tap event
       */
      _onTap: function _onTap(e) {
        this.close();
      },

      /**
       * Handler for the blur event of the current widget.
       *
       * @param e {qx.event.type.Focus} The blur event.
       */
      _onBlur: function _onBlur(e) {
        this.close();
      },

      /**
       * Handler method which handles the key press. It forwards all key event
       * to the opened date chooser except the escape key event. Escape closes
       * the popup.
       * If the list is cloned, all key events will not be processed further.
       *
       * @param e {qx.event.type.KeySequence} Keypress event
       */
      _onKeyPress: function _onKeyPress(e) {
        // get the key identifier
        var iden = e.getKeyIdentifier();

        if (iden == "Down" && e.isAltPressed()) {
          this.toggle();
          e.stopPropagation();
          return;
        } // if the popup is closed, ignore all


        var popup = this.getChildControl("popup");

        if (popup.getVisibility() == "hidden") {
          return;
        } // hide the list always on escape


        if (iden == "Escape") {
          this.close();
          e.stopPropagation();
          return;
        } // Stop navigation keys when popup is open


        if (iden === "Left" || iden === "Right" || iden === "Down" || iden === "Up") {
          e.preventDefault();
        } // forward the rest of the events to the date chooser


        this.getChildControl("list").handleKeyPress(e);
      },

      /**
       * Redirects changeVisibility event from the list to this widget.
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onPopupChangeVisibility: function _onPopupChangeVisibility(e) {
        e.getData() == "visible" ? this.addState("popupOpen") : this.removeState("popupOpen"); // Synchronize the chooser with the current value on every
        // opening of the popup. This is needed when the value has been
        // modified and not saved yet (e.g. no blur)

        var popup = this.getChildControl("popup");

        if (popup.isVisible()) {
          var chooser = this.getChildControl("list");
          var date = this.getValue();
          chooser.setValue(date);
        }
      },

      /**
       * Reacts on value changes of the text field and syncs the
       * value to the combobox.
       *
       * @param e {qx.event.type.Data} Change event
       */
      _onTextFieldChangeValue: function _onTextFieldChangeValue(e) {
        // Apply to popup
        var date = this.getValue();

        if (date != null) {
          var list = this.getChildControl("list");
          list.setValue(date);
        } // Fire event


        this.fireDataEvent("changeValue", this.getValue());
      },

      /**
       * Checks if the textfield of the DateField is empty.
       *
       * @return {Boolean} True, if the textfield of the DateField is empty.
       */
      isEmpty: function isEmpty() {
        var value = this.getChildControl("textfield").getValue();
        return value == null || value == "";
      },
      // overridden
      focus: function focus() {
        qx.ui.form.DateField.prototype.focus.base.call(this);
        this.getChildControl("textfield").getFocusElement().focus();
      }
    },
    destruct: function destruct() {
      // listen for locale changes
      {
        if (this.__localeListenerId) {
          qx.locale.Manager.getInstance().removeListenerById(this.__localeListenerId);
        }
      }
    }
  });
  qx.ui.form.DateField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.DateField": {},
      "qx.dev.unit.RequirementError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.DateField", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.__datefield = new qx.ui.form.DateField();
        this.getRoot().add(this.__datefield);
      },
      tearDown: function tearDown() {
        this.__datefield.destroy();

        qx.test.ui.form.DateField.prototype.tearDown.base.call(this);
      },
      "test: setting value sets date of chooser": function testSettingValueSetsDateOfChooser() {
        var datefield = this.__datefield,
            chooser = datefield.getChildControl("list"),
            date = new Date();
        datefield.setValue(date);
        this.assertEquals(date, chooser.getValue());
      },
      "test: choosing date fills in formatted date": function testChoosingDateFillsInFormattedDate() {
        var datefield = this.__datefield,
            textfield = datefield.getChildControl("textfield"),
            chooser = datefield.getChildControl("list"),
            date = new Date(),
            dateStr = this.formatDate(date);
        chooser.setValue(date); // Fake "execute" on calendar popup

        datefield._onChangeDate();

        this.assertEquals(dateStr, textfield.getValue());
      },
      formatDate: function formatDate(date) {
        return this.__datefield.getDateFormat().format(date);
      },
      skip: function skip(msg) {
        throw new qx.dev.unit.RequirementError(null, msg);
      }
    }
  });
  qx.test.ui.form.DateField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.IExecutable": {},
      "qx.ui.command.Command": {},
      "qx.ui.form.ToggleButton": {},
      "qx.ui.form.CheckBox": {},
      "qx.ui.form.Button": {},
      "qx.ui.form.RepeatButton": {},
      "qx.ui.form.MenuButton": {},
      "qx.ui.form.RadioButton": {},
      "qx.ui.toolbar.Button": {},
      "qx.ui.toolbar.SplitButton": {},
      "qx.ui.menu.CheckBox": {},
      "qx.ui.menu.RadioButton": {},
      "qx.ui.menu.Button": {},
      "qx.ui.groupbox.CheckGroupBox": {},
      "qx.ui.groupbox.RadioGroupBox": {},
      "qx.ui.control.DateChooser": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.Executable", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __test: function __test(widget) {
        // check if the interface is implemented
        this.assertTrue(qx.Class.hasInterface(widget.constructor, qx.ui.form.IExecutable), "Interface is not implemented.");
        var command = new qx.ui.command.Command(); // check if the setter works

        widget.setCommand(command);
        this.assertEquals(command, widget.getCommand(), "Setter / Getter not working."); // check the event and execute method

        this.assertEventFired(widget, "execute", function () {
          widget.execute();
        }, function (e) {// do nothing
        }, "Execute event on the widget is wrong! (1)");
        this.assertEventFired(command, "execute", function () {
          widget.execute();
        }, function (e) {// do nothing
        }, "Execute event on the command is wrong! (2)");
        this.assertEventFired(command, "execute", function () {
          command.execute();
        }, function (e) {// do nothing
        }, "Execute event on the command is wrong! (3)");
        this.assertEventFired(widget, "execute", function () {
          command.execute();
        }, function (e) {// do nothing
        }, "Execute event on the widget is wrong! (4)"); // test removing of the command

        widget.setCommand(null); // check if the listener has been removed

        this.assertEventNotFired(widget, "execute", function () {
          command.execute();
        }, function (e) {// do nothing
        }, "Execute event on the widget is wrong! (5)");
        command.dispose();
        widget.destroy();
      },
      testToggleButton: function testToggleButton() {
        this.__test(new qx.ui.form.ToggleButton());
      },
      testCheckBox: function testCheckBox() {
        this.__test(new qx.ui.form.CheckBox());
      },
      testButton: function testButton() {
        this.__test(new qx.ui.form.Button());
      },
      testRepeatButton: function testRepeatButton() {
        this.__test(new qx.ui.form.RepeatButton());
      },
      testMenuButton: function testMenuButton() {
        this.__test(new qx.ui.form.MenuButton());
      },
      testRadioButton: function testRadioButton() {
        this.__test(new qx.ui.form.RadioButton());
      },
      testToolbarButton: function testToolbarButton() {
        this.__test(new qx.ui.toolbar.Button());
      },
      testSplitButton: function testSplitButton() {
        this.__test(new qx.ui.toolbar.SplitButton());
      },
      testMenuCheckBox: function testMenuCheckBox() {
        this.__test(new qx.ui.menu.CheckBox());
      },
      testMenuRadioButton: function testMenuRadioButton() {
        this.__test(new qx.ui.menu.RadioButton());
      },
      testButtonInMenu: function testButtonInMenu() {
        this.__test(new qx.ui.menu.Button());
      },
      testCheckGroupBox: function testCheckGroupBox() {
        this.__test(new qx.ui.groupbox.CheckGroupBox());
      },
      testRadioGroupBox: function testRadioGroupBox() {
        this.__test(new qx.ui.groupbox.RadioGroupBox());
      },
      testDateChooser: function testDateChooser() {
        this.__test(new qx.ui.control.DateChooser());
      }
    }
  });
  qx.test.ui.form.Executable.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.bom.client.Browser": {},
      "qx.bom.webfonts.Manager": {},
      "qx.ui.form.TextField": {},
      "qx.bom.webfonts.WebFont": {},
      "qx.util.ResourceManager": {},
      "qx.event.Timer": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "browser.version": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /* ************************************************************************
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/webfonts/*)
   */
  qx.Class.define("qx.test.ui.form.Field", {
    extend: qx.test.ui.LayoutTestCase,
    include: [qx.dev.unit.MRequirements, qx.dev.unit.MMock],
    members: {
      hasWebFontSupport: function hasWebFontSupport() {
        var browser = qx.core.Environment.get("browser.name");
        var version = qx.core.Environment.get("browser.version");

        if (browser == "firefox" && version < 3.5 || browser == "opera" && version < 10) {
          return false;
        }

        return true;
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();
        qx.bom.webfonts.Manager.getInstance().dispose();
        delete qx.bom.webfonts.Manager.$$instance;
      },
      testSelectTextAllBeforeFlush: function testSelectTextAllBeforeFlush() {
        var textfield = new qx.ui.form.TextField("affe");
        this.getRoot().add(textfield);
        textfield.focus();
        textfield.selectAllText();
        this.flush(); // test this asynchronous because opera 9.x seems to cache the creation of DOM elements

        var self = this;
        this.wait(1000, function () {
          self.assertEquals("affe", textfield.getTextSelection());
          textfield.destroy();
        });
      },
      testSelectAllTextAfterFlush: function testSelectAllTextAfterFlush() {
        var textfield = new qx.ui.form.TextField("affe");
        this.getRoot().add(textfield);
        textfield.focus();
        this.flush();
        textfield.selectAllText(); // test this asynchronous because opera 9.x seems to cache the creation of DOM elements

        var self = this;
        this.wait(1000, function () {
          self.assertEquals("affe", textfield.getTextSelection());
          textfield.destroy();
        });
      },
      testClearTextSelectionBeforeFlush: function testClearTextSelectionBeforeFlush() {
        var textfield = new qx.ui.form.TextField("affe");
        this.getRoot().add(textfield);
        textfield.focus();
        textfield.selectAllText();
        textfield.clearTextSelection();
        this.flush(); // test this asynchronous because opera 9.x seems to cache the creation of DOM elements

        var self = this;
        this.wait(100, function () {
          self.assertEquals("", textfield.getTextSelection());
          textfield.destroy();
        });
      },
      testClearTextSelectionAfterFlush: function testClearTextSelectionAfterFlush() {
        var textfield = new qx.ui.form.TextField("affe");
        this.getRoot().add(textfield);
        textfield.focus();
        this.flush(); // test this asynchronous because opera 9.x seems to cache the creation of DOM elements

        var self = this;
        this.wait(1000, function () {
          textfield.selectAllText();
          textfield.clearTextSelection();
          self.assertEquals("", textfield.getTextSelection());
          textfield.destroy();
        });
      },
      testGetTextSelectionStartEndAfterFlush: function testGetTextSelectionStartEndAfterFlush() {
        var textfield = new qx.ui.form.TextField("affe");
        this.getRoot().add(textfield);
        textfield.focus();
        this.flush(); // test this asynchronous because opera 9.x seems to cache the creation of DOM elements

        var self = this;
        this.wait(1000, function () {
          textfield.setTextSelection(1, 2);
          self.assertEquals(1, textfield.getTextSelectionStart());
          self.assertEquals(2, textfield.getTextSelectionEnd());
          textfield.destroy();
        });
      },
      testGetTextSelectionStartEndBeforeFlush: function testGetTextSelectionStartEndBeforeFlush() {
        var textfield = new qx.ui.form.TextField("affe");
        this.getRoot().add(textfield);
        textfield.focus();
        textfield.setTextSelection(2, 3);
        this.flush(); // test this asynchronous because opera 9.x seems to cache the creation of DOM elements

        var self = this;
        this.wait(100, function () {
          self.assertEquals(2, textfield.getTextSelectionStart());
          self.assertEquals(3, textfield.getTextSelectionEnd());
          textfield.destroy();
        });
      },
      testApplyWebFont: function testApplyWebFont() {
        this.require(["webFontSupport"]);

        var tf = new qx.ui.form.TextField("Laugh while you can, monkey boy!");
        var f = new qx.bom.webfonts.WebFont();
        f.set({
          size: 18,
          family: ["monospace"],
          sources: [{
            family: "FinelinerScriptRegular",
            source: [qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fineliner_script-webfont.woff"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fineliner_script-webfont.ttf"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fineliner_script-webfont.eot")]
          }, {
            family: "YanoneKaffeesatzRegular",
            source: [qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/yanonekaffeesatz-regular-webfont.woff"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/yanonekaffeesatz-regular-webfont.ttf"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/yanonekaffeesatz-regular-webfont.eot")]
          }]
        });
        var statusChangeSpy = this.spy(tf, "_onWebFontStatusChange");
        tf.setFont(f);
        qx.event.Timer.once(function () {
          this.resume(function () {
            tf.dispose();
            f.dispose();
            this.assertCalledTwice(statusChangeSpy);
          }, this);
        }, this, 4000);
        this.wait(8000);
      }
    }
  });
  qx.test.ui.form.Field.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.ui.form.IForm": {},
      "qx.ui.form.Spinner": {},
      "qx.ui.form.Slider": {},
      "qx.ui.form.TextField": {},
      "qx.ui.form.TextArea": {},
      "qx.ui.form.PasswordField": {},
      "qx.ui.form.ComboBox": {},
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.CheckBox": {},
      "qx.ui.form.RadioButton": {},
      "qx.ui.groupbox.GroupBox": {},
      "qx.ui.groupbox.RadioGroupBox": {},
      "qx.ui.groupbox.CheckGroupBox": {},
      "qx.ui.form.List": {},
      "qx.ui.tree.Tree": {},
      "qx.ui.form.DateField": {},
      "qx.ui.form.RadioGroup": {},
      "qx.ui.form.RadioButtonGroup": {},
      "qx.ui.form.Form": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.Form", {
    extend: qx.test.ui.LayoutTestCase,
    include: qx.dev.unit.MMock,
    members: {
      __testRequired: function __testRequired(widget) {
        // check if the interface is implemented
        this.assert(qx.Class.hasInterface(widget.constructor, qx.ui.form.IForm), "Interface not implemented."); // test for the default (false)

        this.assertFalse(widget.getRequired(), "Default required state is wrong."); // check for the event

        var self = this;
        widget.setRequired(false);
        this.assertEventFired(widget, "changeRequired", function () {
          widget.setRequired(true);
        }, function (e) {
          self.assertTrue(e.getData(), "Wrong data in the event!");
          self.assertFalse(e.getOldData(), "Wrong old data in the event!");
        }, "Change event not fired!"); // check if the state is set

        this.assertTrue(widget.getRequired(), "Setting of the required flag did not work.");
        widget.dispose();
      },
      __testValid: function __testValid(widget, where) {
        // check if the interface is implemented
        this.assert(qx.Class.hasInterface(widget.constructor, qx.ui.form.IForm), "Interface not implemented.");
        this.getRoot().add(widget); // test for the default (true)

        this.assertTrue(widget.getValid(), "Default valid state is wrong.");
        this.assertFalse(!!widget.hasState("invalid"), "Should not have the invalid state.");
        widget.setValid(false); // check if the state is set

        this.assertFalse(widget.getValid(), "Setting of the valid flag did not work.");
        this.assertTrue(widget.hasState("invalid"), "Should have the invalid state."); // check for the event

        var self = this;
        this.assertEventFired(widget, "changeValid", function () {
          widget.setValid(true);
        }, function (e) {
          self.assertTrue(e.getData(), "Wrong data in the event.");
          self.assertFalse(e.getOldData(), "Wrong old data in the event.");
        }, "Change event not fired!"); // check for the event

        this.assertEventFired(widget, "changeInvalidMessage", function () {
          widget.setInvalidMessage("affe");
        }, function (e) {
          self.assertEquals("affe", e.getData(), "Wrong data in the event.");
          self.assertEquals("", e.getOldData(), "Wrong old data in the event.");
        }, "Change event not fired!"); // set the widget to invalid

        widget.setValid(false);

        if (where !== "dont") {
          // needs to be tests async because of a strange behavior in opera 9
          var self = this;
          window.setTimeout(function () {
            self.resume(function () {
              this.__testInvalidBorder(widget);

              widget.destroy();
            }, self);
          }, 100);
          this.wait();
        }

        widget.destroy();
      },
      __testInvalidBorder: function __testInvalidBorder(widget) {
        this.flush(); // check for the invalid decorator

        this.assertNotEquals(-1, widget.getDecorator().indexOf("invalid"), "Decorator not set!"); // check the focus

        widget.focus();
        this.flush();
        this.assertNotEquals(-1, widget.getDecorator().indexOf("invalid"), "Decorator not set!");
      },
      testRequiredSpinner: function testRequiredSpinner() {
        this.__testRequired(new qx.ui.form.Spinner());
      },
      testValidSpinner: function testValidSpinner() {
        this.__testValid(new qx.ui.form.Spinner());
      },
      testRequiredSlider: function testRequiredSlider() {
        this.__testRequired(new qx.ui.form.Slider());
      },
      testValidSlider: function testValidSlider() {
        this.__testValid(new qx.ui.form.Slider());
      },
      testRequiredTextField: function testRequiredTextField() {
        this.__testRequired(new qx.ui.form.TextField());
      },
      testValidTextField: function testValidTextField() {
        this.__testValid(new qx.ui.form.TextField());
      },
      testRequiredTextArea: function testRequiredTextArea() {
        this.__testRequired(new qx.ui.form.TextArea());
      },
      testValidTextArea: function testValidTextArea() {
        this.__testValid(new qx.ui.form.TextArea());
      },
      testRequiredPasswordField: function testRequiredPasswordField() {
        this.__testRequired(new qx.ui.form.PasswordField());
      },
      testValidPasswordField: function testValidPasswordField() {
        this.__testValid(new qx.ui.form.PasswordField());
      },
      testRequiredComboBox: function testRequiredComboBox() {
        this.__testRequired(new qx.ui.form.ComboBox());
      },
      testValidComboBox: function testValidComboBox() {
        this.__testValid(new qx.ui.form.ComboBox());
      },
      testRequiredSelectBox: function testRequiredSelectBox() {
        this.__testRequired(new qx.ui.form.SelectBox());
      },
      testValidSelectBox: function testValidSelectBox() {
        this.__testValid(new qx.ui.form.SelectBox());
      },
      testRequiredCheckBox: function testRequiredCheckBox() {
        this.__testRequired(new qx.ui.form.CheckBox());
      },
      testValidCheckBox: function testValidCheckBox() {
        this.__testValid(new qx.ui.form.CheckBox(), "dont");
      },
      testValidRadioButton: function testValidRadioButton() {
        this.__testValid(new qx.ui.form.RadioButton(), "dont");
      },
      testRequiredRadioButton: function testRequiredRadioButton() {
        this.__testRequired(new qx.ui.form.RadioButton());
      },
      testValidGroupBox: function testValidGroupBox() {
        this.__testValid(new qx.ui.groupbox.GroupBox(), "dont");
      },
      testRequiredGroupBox: function testRequiredGroupBox() {
        this.__testRequired(new qx.ui.groupbox.GroupBox());
      },
      testValidRadioGroupBox: function testValidRadioGroupBox() {
        this.__testValid(new qx.ui.groupbox.RadioGroupBox(), "dont");
      },
      testRequiredRadioGroupBox: function testRequiredRadioGroupBox() {
        this.__testRequired(new qx.ui.groupbox.RadioGroupBox());
      },
      testValidCheckGroupBox: function testValidCheckGroupBox() {
        this.__testValid(new qx.ui.groupbox.CheckGroupBox(), "dont");
      },
      testRequiredCheckGroupBox: function testRequiredCheckGroupBox() {
        this.__testRequired(new qx.ui.groupbox.CheckGroupBox());
      },
      testValidList: function testValidList() {
        this.__testValid(new qx.ui.form.List());
      },
      testRequiredList: function testRequiredList() {
        this.__testRequired(new qx.ui.form.List());
      },
      testValidTree: function testValidTree() {
        this.__testValid(new qx.ui.tree.Tree());
      },
      testRequiredTree: function testRequiredTree() {
        this.__testRequired(new qx.ui.tree.Tree());
      },
      testRequiredDateField: function testRequiredDateField() {
        this.__testRequired(new qx.ui.form.DateField());
      },
      testValidDateField: function testValidDateField() {
        this.__testValid(new qx.ui.form.DateField());
      },
      testRequiredDateChooser: function testRequiredDateChooser() {
        this.__testRequired(new qx.ui.form.DateField());
      },
      testValidDateChooser: function testValidDateChooser() {
        this.__testValid(new qx.ui.form.DateField());
      },
      testValidRadioGroup: function testValidRadioGroup() {
        var group = new qx.ui.form.RadioGroup();
        var rb = new qx.ui.form.RadioButton();
        group.add(rb); // check if the interface is implemented

        this.assert(qx.Class.hasInterface(group.constructor, qx.ui.form.IForm), "Interface not implemented."); // test for the default (true)

        this.assertTrue(group.getValid(), "Default valid state is wrong.");
        group.setValid(false); // check if the state is set

        this.assertFalse(group.getValid(), "Setting of the valid flag did not work."); // check for the event

        var self = this;
        this.assertEventFired(group, "changeValid", function () {
          group.setValid(true);
        }, function (e) {
          self.assertTrue(e.getData(), "Wrong data in the event.");
          self.assertFalse(e.getOldData(), "Wrong old data in the event.");
        }, "Change event not fired!"); // check for the event

        this.assertEventFired(group, "changeInvalidMessage", function () {
          group.setInvalidMessage("affe");
        }, function (e) {
          self.assertEquals("affe", e.getData(), "Wrong data in the event.");
          self.assertEquals("", e.getOldData(), "Wrong old data in the event.");
        }, "Change event not fired!"); // set the widget to invalid

        group.setValid(false); // check if the child is invalid

        this.assertFalse(rb.getValid(), "Child is valid!"); // check the invalid message of the child

        this.assertEquals("affe", rb.getInvalidMessage(), "Invalid messages not set on child.");
        group.dispose();
        rb.destroy();
      },
      testRequiredRadioGroup: function testRequiredRadioGroup() {
        this.__testRequired(new qx.ui.form.RadioGroup());
      },
      testRequiredRadioButtonGroup: function testRequiredRadioButtonGroup() {
        this.__testRequired(new qx.ui.form.RadioButtonGroup());
      },
      testValidRadioButtonGroup: function testValidRadioButtonGroup() {
        var cont = new qx.ui.form.RadioButtonGroup();
        var rb = new qx.ui.form.RadioButton();
        cont.add(rb); // check if the interface is implemented

        this.assert(qx.Class.hasInterface(cont.constructor, qx.ui.form.IForm), "Interface not implemented."); // test for the default (true)

        this.assertTrue(cont.getValid(), "Default valid state is wrong.");
        cont.setValid(false); // check if the state is set

        this.assertFalse(cont.getValid(), "Setting of the valid flag did not work."); // check for the event

        var self = this;
        this.assertEventFired(cont, "changeValid", function () {
          cont.setValid(true);
        }, function (e) {
          self.assertTrue(e.getData(), "Wrong data in the event.");
          self.assertFalse(e.getOldData(), "Wrong old data in the event.");
        }, "Change event not fired!"); // check for the event

        this.assertEventFired(cont, "changeInvalidMessage", function () {
          cont.setInvalidMessage("affe");
        }, function (e) {
          self.assertEquals("affe", e.getData(), "Wrong data in the event.");
          self.assertEquals("", e.getOldData(), "Wrong old data in the event.");
        }, "Change event not fired!"); // set the widget to invalid

        cont.setValid(false); // check if the child is invalid

        this.assertFalse(rb.getValid(), "Child is valid!"); // check the invalid message of the child

        this.assertEquals("affe", rb.getInvalidMessage(), "Invalid messages not set on child.");
        cont.dispose();
        rb.destroy();
      },
      testRedefineItem: function testRedefineItem() {
        var form = new qx.ui.form.Form();
        var resetter = form._resetter;
        resetter.redefineItem = this.spy(resetter.redefineItem);
        var item = new qx.ui.form.TextField();
        form.add(item, "xyz");
        form.redefineResetterItem(item);
        this.assertCalledOnce(resetter.redefineItem);
        item.dispose();
        form.dispose();
      }
    }
  });
  qx.test.ui.form.Form.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "construct": true,
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.ui.form.renderer.AbstractRenderer": {
        "construct": true
      },
      "qx.ui.form.renderer.IFormRenderer": {},
      "qx.ui.form.Form": {},
      "qx.ui.form.TextField": {},
      "qx.util.Validate": {},
      "qx.ui.form.Button": {},
      "qx.ui.form.RepeatButton": {},
      "qx.ui.control.DateChooser": {},
      "qx.ui.form.CheckBox": {},
      "qx.ui.form.ComboBox": {},
      "qx.ui.form.DateField": {},
      "qx.ui.form.List": {},
      "qx.ui.form.PasswordField": {},
      "qx.ui.form.RadioButton": {},
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.Slider": {},
      "qx.ui.form.Spinner": {},
      "qx.ui.form.TextArea": {},
      "qx.ui.groupbox.CheckGroupBox": {},
      "qx.ui.form.RadioButtonGroup": {},
      "qx.ui.groupbox.RadioGroupBox": {},
      "qx.ui.form.renderer.Single": {},
      "qx.ui.form.renderer.SinglePlaceholder": {},
      "qx.ui.form.renderer.Double": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.DummyFormRenderer)
   */
  qx.Class.define("qx.test.ui.form.FormManager", {
    extend: qx.test.ui.LayoutTestCase,
    include: qx.dev.unit.MMock,
    construct: function construct() {
      qx.test.ui.LayoutTestCase.constructor.call(this); // create the test renderer

      qx.Class.define("qx.test.DummyFormRenderer", {
        extend: qx.ui.form.renderer.AbstractRenderer,
        implement: qx.ui.form.renderer.IFormRenderer,
        construct: function construct(form) {
          this.groups = [];
          this.buttons = [];
          qx.ui.form.renderer.AbstractRenderer.constructor.call(this, form);
        },
        properties: {
          buttons: {},
          groups: {}
        },
        members: {
          addItems: function addItems(items, names, title, itemsOptions, headerOptions) {
            this.groups.push({
              items: items,
              names: names,
              title: title,
              headerOptions: headerOptions,
              options: itemsOptions
            });
          },
          addButton: function addButton(button, options) {
            this.buttons.push({
              button: button,
              options: options
            });
          }
        }
      });
    },
    members: {
      __form: null,
      __tf1: null,
      __tf2: null,
      setUp: function setUp() {
        this.__form = new qx.ui.form.Form();
        this.__tf1 = new qx.ui.form.TextField();
        this.__tf2 = new qx.ui.form.TextField();
      },
      tearDown: function tearDown() {
        this.__tf2.dispose();

        this.__tf1.dispose();

        this.__form.dispose();
      },
      testValidationContext: function testValidationContext() {
        var self = this; // add the widgets

        this.__form.add(this.__tf2, "TF2", function () {
          self.assertEquals(1, this.a);
        }, null, {
          a: 1
        });

        this.__form.validate();
      },
      testAddTwo: function testAddTwo() {
        // add the widgets
        this.__form.add(this.__tf1, "TF1");

        this.__form.add(this.__tf2, "TF2"); // get the view


        var view = new qx.test.DummyFormRenderer(this.__form); // check the items

        this.assertEquals(view.groups[0].items[0], this.__tf1);
        this.assertEquals(view.groups[0].items[1], this.__tf2); // check the names

        this.assertEquals(view.groups[0].names[0], "TF1");
        this.assertEquals(view.groups[0].names[1], "TF2");
        view.dispose();
      },
      testRemove: function testRemove() {
        // add the widgets
        this.__form.add(this.__tf1, "TF1");

        this.__form.add(this.__tf2, "TF2"); // get the view


        var view = new qx.test.DummyFormRenderer(this.__form); // check the items

        this.assertEquals(view.groups[0].items[0], this.__tf1);
        this.assertEquals(view.groups[0].items[1], this.__tf2);
        view.dispose(); // remove twice to see if the remove is reported correctly

        this.assertTrue(this.__form.remove(this.__tf1));
        this.assertFalse(this.__form.remove(this.__tf1)); // get the view

        var view = new qx.test.DummyFormRenderer(this.__form); // check the items

        this.assertEquals(view.groups[0].items[0], this.__tf2);
        view.dispose();
      },
      testAddTwoWithValidator: function testAddTwoWithValidator() {
        // add the widgets
        this.__tf1.setRequired(true);

        this.__form.add(this.__tf1, "TF1");

        this.__form.add(this.__tf2, "TF2", qx.util.Validate.email()); // validation should fail


        this.assertFalse(this.__form.validate());
        this.assertFalse(this.__tf1.getValid());
        this.assertFalse(this.__tf2.getValid()); // correct the values

        this.__tf1.setValue("a");

        this.__tf2.setValue("ab@cd.ef"); // validation should be ok


        this.assertTrue(this.__form.validate());
        this.assertTrue(this.__tf1.getValid());
        this.assertTrue(this.__tf2.getValid()); // check the validation manager itself

        this.assertTrue(this.__form.getValidationManager().validate());
      },
      testAddTwoWithHeader: function testAddTwoWithHeader() {
        this.__form.addGroupHeader("affe"); // add the widgets


        this.__form.add(this.__tf1, "TF1");

        this.__form.add(this.__tf2, "TF2"); // get the view


        var view = new qx.test.DummyFormRenderer(this.__form); // check the items

        this.assertEquals(view.groups[0].items[0], this.__tf1);
        this.assertEquals(view.groups[0].items[1], this.__tf2); // check the names

        this.assertEquals(view.groups[0].names[0], "TF1");
        this.assertEquals(view.groups[0].names[1], "TF2"); // check the title

        this.assertEquals("affe", view.groups[0].title);
        view.dispose();
      },
      testRemoveHeader: function testRemoveHeader() {
        this.__form.addGroupHeader("affe0");

        this.__form.add(this.__tf1, "TF1");

        this.__form.addGroupHeader("affe1");

        this.__form.add(this.__tf2, "TF2"); // get the view


        var view = new qx.test.DummyFormRenderer(this.__form); // check the items

        this.assertEquals(view.groups[0].items[0], this.__tf1);
        this.assertEquals(view.groups[1].items[0], this.__tf2); // check the title

        this.assertEquals("affe0", view.groups[0].title);
        this.assertEquals("affe1", view.groups[1].title);
        view.dispose(); // remove twice to see if the remove is reported correctly

        this.assertTrue(this.__form.removeGroupHeader("affe1"));
        this.assertFalse(this.__form.removeGroupHeader("affe1")); // get the view

        var view = new qx.test.DummyFormRenderer(this.__form); // check the items

        this.assertEquals(view.groups[0].items[0], this.__tf1);
        this.assertEquals(view.groups[0].items[1], this.__tf2);
        this.assertEquals("affe0", view.groups[0].title);
        view.dispose();
      },
      testAddTwoWithTwoGroups: function testAddTwoWithTwoGroups() {
        this.__form.addGroupHeader("affe");

        this.__form.add(this.__tf1, "TF1");

        this.__form.addGroupHeader("affee");

        this.__form.add(this.__tf2, "TF2"); // get the view


        var view = new qx.test.DummyFormRenderer(this.__form); // check the items

        this.assertEquals(view.groups[0].items[0], this.__tf1);
        this.assertEquals(view.groups[1].items[0], this.__tf2); // check the names

        this.assertEquals(view.groups[0].names[0], "TF1");
        this.assertEquals(view.groups[1].names[0], "TF2"); // check the title

        this.assertEquals("affe", view.groups[0].title);
        this.assertEquals("affee", view.groups[1].title);
        view.dispose();
      },
      testAddTwoButtons: function testAddTwoButtons() {
        var b1 = new qx.ui.form.Button();
        var b2 = new qx.ui.form.RepeatButton();

        this.__form.addButton(b1);

        this.__form.addButton(b2); // get the view


        var view = new qx.test.DummyFormRenderer(this.__form); // check the buttons

        this.assertEquals(b1, view.buttons[0].button);
        this.assertEquals(b2, view.buttons[1].button);
        b2.dispose();
        b1.dispose();
        view.dispose();
      },
      testRemoveButton: function testRemoveButton() {
        var b1 = new qx.ui.form.Button();
        var b2 = new qx.ui.form.RepeatButton();

        this.__form.addButton(b1);

        this.__form.addButton(b2); // get the view


        var view = new qx.test.DummyFormRenderer(this.__form); // check the buttons

        this.assertEquals(b1, view.buttons[0].button);
        this.assertEquals(b2, view.buttons[1].button);
        view.dispose(); // remove twice to see if the remove is reported correctly

        this.assertTrue(this.__form.removeButton(b1));
        this.assertFalse(this.__form.removeButton(b1)); // get the view

        var view = new qx.test.DummyFormRenderer(this.__form); // check the button

        this.assertEquals(b2, view.buttons[0].button);
        view.dispose();
        b2.dispose();
        b1.dispose();
      },
      testAddTwoWithButtons: function testAddTwoWithButtons() {
        var b1 = new qx.ui.form.Button();
        var b2 = new qx.ui.form.RepeatButton(); // add the widgets

        this.__form.add(this.__tf1, "TF1");

        this.__form.addButton(b1);

        this.__form.add(this.__tf2, "TF2");

        this.__form.addButton(b2); // get the view


        var view = new qx.test.DummyFormRenderer(this.__form); // check the items

        this.assertEquals(view.groups[0].items[0], this.__tf1);
        this.assertEquals(view.groups[0].items[1], this.__tf2); // check the names

        this.assertEquals(view.groups[0].names[0], "TF1");
        this.assertEquals(view.groups[0].names[1], "TF2"); // check the buttons

        this.assertEquals(b1, view.buttons[0].button);
        this.assertEquals(b2, view.buttons[1].button);
        b2.dispose();
        b1.dispose();
        view.dispose();
      },
      testAddTwoWithOptions: function testAddTwoWithOptions() {
        // add the widgets
        this.__form.add(this.__tf1, "TF1", null, "tf1", null, {
          a: 1
        });

        this.__form.add(this.__tf2, "TF2", null, "tf2", null, {
          a: 2
        }); // get the view


        var view = new qx.test.DummyFormRenderer(this.__form); // check the items

        this.assertEquals(1, view.groups[0].options[0].a);
        this.assertEquals(2, view.groups[0].options[1].a);
        view.dispose();
      },
      testAddTwoWithButtonsOptions: function testAddTwoWithButtonsOptions() {
        var b1 = new qx.ui.form.Button();
        var b2 = new qx.ui.form.RepeatButton(); // add the widgets

        this.__form.add(this.__tf1, "TF1");

        this.__form.addButton(b1, {
          a: 1
        });

        this.__form.add(this.__tf2, "TF2");

        this.__form.addButton(b2, {
          a: 2
        }); // get the view


        var view = new qx.test.DummyFormRenderer(this.__form); // check the buttons options

        this.assertEquals(1, view.buttons[0].options.a);
        this.assertEquals(2, view.buttons[1].options.a);
        b2.dispose();
        b1.dispose();
        view.dispose();
      },
      testAddTwoWithHeaderOptions: function testAddTwoWithHeaderOptions() {
        this.__form.addGroupHeader("affe", {
          a: 1
        });

        this.__form.add(this.__tf1, "TF1");

        this.__form.addGroupHeader("affee", {
          a: 2
        });

        this.__form.add(this.__tf2, "TF2"); // get the view


        var view = new qx.test.DummyFormRenderer(this.__form); // check the title

        this.assertEquals(1, view.groups[0].headerOptions.a);
        this.assertEquals(2, view.groups[1].headerOptions.a);
        view.dispose();
      },
      testResetter: function testResetter() {
        // set the init values of the textfields
        this.__tf1.setValue("aaaa");

        this.__tf2.setValue("bbbb"); // add the widgets


        this.__form.add(this.__tf1, "TF1");

        this.__form.add(this.__tf2, "TF2"); // set some other values


        this.__tf1.setValue("111");

        this.__tf2.setValue("222");

        this.__form.reset(); // check


        this.assertEquals("aaaa", this.__tf1.getValue());
        this.assertEquals("bbbb", this.__tf2.getValue());
      },
      testAll: function testAll() {
        var widgets = [];
        widgets.push(new qx.ui.control.DateChooser());
        widgets.push(new qx.ui.form.CheckBox());
        widgets.push(new qx.ui.form.ComboBox());
        widgets.push(new qx.ui.form.DateField());
        widgets.push(new qx.ui.form.List());
        widgets.push(new qx.ui.form.PasswordField());
        widgets.push(new qx.ui.form.RadioButton());
        widgets.push(new qx.ui.form.SelectBox());
        widgets.push(new qx.ui.form.Slider());
        widgets.push(new qx.ui.form.Spinner());
        widgets.push(new qx.ui.form.TextArea());
        widgets.push(new qx.ui.form.TextField());
        widgets.push(new qx.ui.groupbox.CheckGroupBox());
        widgets.push(new qx.ui.form.RadioButtonGroup());
        widgets.push(new qx.ui.groupbox.RadioGroupBox()); // add all

        for (var i = 0; i < widgets.length; i++) {
          this.__form.add(widgets[i], "name" + i);
        } // reset


        this.__form.reset(); // validate


        this.assertTrue(this.__form.validate()); // get rid of the widgets

        for (var i = 0; i < widgets.length; i++) {
          widgets[i].dispose();
        }
      },
      testGetItems: function testGetItems() {
        // add the widgets
        this.__form.add(this.__tf1, "TF1", null, "a");

        this.__form.add(this.__tf2, "TF2", null, "b");

        var items = this.__form.getItems();

        this.assertEquals(items.a, this.__tf1);
        this.assertEquals(items.b, this.__tf2);
      },
      testGetItemsFallback: function testGetItemsFallback() {
        // add the widgets
        this.__form.add(this.__tf1, "TF1");

        this.__form.add(this.__tf2, "T F 2");

        var items = this.__form.getItems();

        this.assertEquals(items.TF1, this.__tf1);
        this.assertEquals(items.TF2, this.__tf2);
      },
      testGetItemsMixedWithGroups: function testGetItemsMixedWithGroups() {
        // add the widgets
        this.__form.add(this.__tf1, "TF1");

        this.__form.add(this.__tf2, "TF2", null, "b");

        this.__form.addGroupHeader("x");

        var tf3 = new qx.ui.form.TextField();

        this.__form.add(tf3, "TF3");

        var items = this.__form.getItems();

        this.assertEquals(items.TF1, this.__tf1);
        this.assertEquals(items.b, this.__tf2);
        this.assertEquals(items.TF3, tf3);
        tf3.destroy();
      },
      testRedefineResetter: function testRedefineResetter() {
        // just call the method and check if its not throwing an error
        // all other stuff is tested in the resetter unit tests
        this.__form.redefineResetter();
      },
      testEvent: function testEvent() {
        var handler = this.spy();

        this.__form.addListener("change", handler);

        this.__form.add(this.__tf1, "TF1");

        this.assertCalledOnce(handler);

        this.__form.addGroupHeader("GROUP");

        this.assertCalledTwice(handler);

        this.__form.add(this.__tf2, "TF2");

        this.assertEquals(3, handler.callCount);

        this.__form.remove(this.__tf1);

        this.assertEquals(4, handler.callCount);

        this.__form.removeGroupHeader("GROUP");

        this.assertEquals(5, handler.callCount);
        var b = new qx.ui.form.Button();

        this.__form.addButton(b);

        this.assertEquals(6, handler.callCount);

        this.__form.removeButton(b);

        this.assertEquals(7, handler.callCount);
        b.dispose();
      },
      testSingleRenderer: function testSingleRenderer() {
        var b1 = new qx.ui.form.Button(); // add the widgets

        this.__form.addGroupHeader("header");

        this.__form.add(this.__tf1, "TF1");

        this.__form.addButton(b1); // just check if the renderer is created without an error


        new qx.ui.form.renderer.Single(this.__form).dispose();
        b1.dispose();
      },
      testSinglePlaceholderRenderer: function testSinglePlaceholderRenderer() {
        var b1 = new qx.ui.form.Button(); // add the widgets

        this.__form.addGroupHeader("header");

        this.__form.add(this.__tf1, "TF1");

        this.__form.addButton(b1); // just check if the renderer is created without an error


        new qx.ui.form.renderer.SinglePlaceholder(this.__form).dispose();
        b1.dispose();
      },
      testDoubleRenderer: function testDoubleRenderer() {
        var b1 = new qx.ui.form.Button(); // add the widgets

        this.__form.addGroupHeader("header");

        this.__form.add(this.__tf1, "TF1");

        this.__form.addButton(b1); // just check if the renderer is created without an error


        new qx.ui.form.renderer.Double(this.__form).dispose();
        b1.dispose();
      },
      testGetItem: function testGetItem() {
        var f1 = new qx.ui.form.TextField();
        var f2 = new qx.ui.form.TextField();
        var f3 = new qx.ui.form.TextField();

        this.__form.add(f1, "a");

        this.__form.add(f2, "c");

        this.__form.add(f3, "label", null, "x");

        this.assertIdentical(f1, this.__form.getItem("a"));
        this.assertNull(this.__form.getItem("b"));
        this.assertIdentical(f2, this.__form.getItem("c"));
        this.assertNull(this.__form.getItem("label"));
        this.assertIdentical(f3, this.__form.getItem("x"));
        [f1, f2, f3].forEach(function (o) {
          o.dispose();
        });
      }
    }
  });
  qx.test.ui.form.FormManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.renderer.IFormRenderer": {
        "require": true
      },
      "qx.locale.Manager": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Abstract renderer for {@link qx.ui.form.Form}. This abstract renderer should
   * be the superclass of all form renderer. It takes the form, which is
   * supplied as constructor parameter and configures itself. So if you need to
   * set some additional information on your renderer before adding the widgets,
   * be sure to do that before calling this.base(arguments, form).
   */
  qx.Class.define("qx.ui.form.renderer.AbstractRenderer", {
    type: "abstract",
    extend: qx.ui.core.Widget,
    implement: qx.ui.form.renderer.IFormRenderer,

    /**
     * @param form {qx.ui.form.Form} The form to render.
     */
    construct: function construct(form) {
      qx.ui.core.Widget.constructor.call(this);
      this._labels = []; // translation support

      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
        this._names = [];
      }
      this._form = form;

      this._render();

      form.addListener("change", this._onFormChange, this);
    },
    properties: {
      /**
       * A string that is appended to the label if it is not empty.
       * Defaults to " :"
       */
      labelSuffix: {
        check: "String",
        init: " :",
        event: "changeLabelSuffix",
        nullable: true
      },

      /**
       * A string that is appended to the label and the label suffix if the corresponding
       * form field is mandatory. Defaults to space plus a red asterisk.
       */
      requiredSuffix: {
        check: "String",
        init: " <span style='color:red'>*</span> ",
        event: "changeRequiredSuffix",
        nullable: false
      }
    },
    members: {
      _names: null,
      _form: null,
      _labels: null,

      /**
       * Renders the form: adds the items and buttons.
       */
      _render: function _render() {
        // add the groups
        var groups = this._form.getGroups();

        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          this.addItems(group.items, group.labels, group.title, group.options, group.headerOptions);
        } // add the buttons


        var buttons = this._form.getButtons();

        var buttonOptions = this._form.getButtonOptions();

        for (var i = 0; i < buttons.length; i++) {
          this.addButton(buttons[i], buttonOptions[i]);
        }
      },

      /**
       * Handler responsible for updating the rendered widget as soon as the
       * form changes.
       */
      _onFormChange: function _onFormChange() {
        this._removeAll(); // remove all created labels


        for (var i = 0; i < this._labels.length; i++) {
          this._labels[i].dispose();
        }

        this._labels = [];

        this._render();
      },

      /**
       * Helper to bind the item's visibility to the label's visibility.
       * @param item {qx.ui.core.Widget} The form element.
       * @param label {qx.ui.basic.Label} The label for the form element.
       */
      _connectVisibility: function _connectVisibility(item, label) {
        // map the items visibility to the label
        item.bind("visibility", label, "visibility");
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale: function _onChangeLocale(e) {
        for (var i = 0; i < this._names.length; i++) {
          var entry = this._names[i];

          if (entry.name && entry.name.translate) {
            entry.name = entry.name.translate();
          }

          var newText = this._createLabelText(entry.name, entry.item);

          entry.label.setValue(newText);
        }
      },

      /**
       * Creates the label text for the given form item.
       *
       * @param name {String} The content of the label without the
       *   trailing * and :
       * @param item {qx.ui.form.IForm} The item, which has the required state.
       * @return {String} The text for the given item.
       */
      _createLabelText: function _createLabelText(name, item) {
        var requiredSuffix = "";

        if (item.getRequired()) {
          requiredSuffix = this.getRequiredSuffix();
        } // Create the label. Append a suffix only if there's text to display.


        var labelSuffix = name.length > 0 || item.getRequired() ? this.getLabelSuffix() : "";
        return name + requiredSuffix + labelSuffix;
      },
      // interface implementation
      addItems: function addItems(items, names, title) {
        throw new Error("Abstract method call");
      },
      // interface implementation
      addButton: function addButton(button) {
        throw new Error("Abstract method call");
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
      this._names = null;

      this._form.removeListener("change", this._onFormChange, this);

      this._form = null;
    }
  });
  qx.ui.form.renderer.AbstractRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.renderer.AbstractRenderer": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Single column renderer for {@link qx.ui.form.Form}.
   */
  qx.Class.define("qx.ui.form.renderer.Single", {
    extend: qx.ui.form.renderer.AbstractRenderer,
    construct: function construct(form) {
      var layout = new qx.ui.layout.Grid();
      layout.setSpacing(6);
      layout.setColumnFlex(1, 1);
      layout.setColumnAlign(0, "right", "top");

      this._setLayout(layout);

      qx.ui.form.renderer.AbstractRenderer.constructor.call(this, form);
    },
    members: {
      _row: 0,
      _buttonRow: null,
      // overridden
      _onFormChange: function _onFormChange() {
        if (this._buttonRow) {
          this._buttonRow.destroy();

          this._buttonRow = null;
        }

        this._row = 0;

        qx.ui.form.renderer.Single.prototype._onFormChange.base.call(this);
      },

      /**
       * Add a group of form items with the corresponding names. The names are
       * displayed as label.
       * The title is optional and is used as grouping for the given form
       * items.
       *
       * @param items {qx.ui.core.Widget[]} An array of form items to render.
       * @param names {String[]} An array of names for the form items.
       * @param title {String?} A title of the group you are adding.
       */
      addItems: function addItems(items, names, title) {
        // add the header
        if (title != null) {
          this._add(this._createHeader(title), {
            row: this._row,
            column: 0,
            colSpan: 2
          });

          this._row++;
        } // add the items


        for (var i = 0; i < items.length; i++) {
          var label = this._createLabel(names[i], items[i]);

          this._add(label, {
            row: this._row,
            column: 0
          });

          var item = items[i];
          label.setBuddy(item);

          this._add(item, {
            row: this._row,
            column: 1
          });

          this._row++;

          this._connectVisibility(item, label); // store the names for translation


          {
            this._names.push({
              name: names[i],
              label: label,
              item: items[i]
            });
          }
        }
      },

      /**
       * Adds a button the form renderer. All buttons will be added in a
       * single row at the bottom of the form.
       *
       * @param button {qx.ui.form.Button} The button to add.
       */
      addButton: function addButton(button) {
        if (this._buttonRow == null) {
          // create button row
          this._buttonRow = new qx.ui.container.Composite();

          this._buttonRow.setMarginTop(5);

          var hbox = new qx.ui.layout.HBox();
          hbox.setAlignX("right");
          hbox.setSpacing(5);

          this._buttonRow.setLayout(hbox); // add the button row


          this._add(this._buttonRow, {
            row: this._row,
            column: 0,
            colSpan: 2
          }); // increase the row


          this._row++;
        } // add the button


        this._buttonRow.add(button);
      },

      /**
       * Returns the set layout for configuration.
       *
       * @return {qx.ui.layout.Grid} The grid layout of the widget.
       */
      getLayout: function getLayout() {
        return this._getLayout();
      },

      /**
       * Creates a label for the given form item.
       *
       * @param name {String} The content of the label without the
       *   trailing * and :
       * @param item {qx.ui.core.Widget} The item, which has the required state.
       * @return {qx.ui.basic.Label} The label for the given item.
       */
      _createLabel: function _createLabel(name, item) {
        var label = new qx.ui.basic.Label(this._createLabelText(name, item)); // store labels for disposal

        this._labels.push(label);

        label.setRich(true);
        label.setAppearance("form-renderer-label");
        return label;
      },

      /**
       * Creates a header label for the form groups.
       *
       * @param title {String} Creates a header label.
       * @return {qx.ui.basic.Label} The header for the form groups.
       */
      _createHeader: function _createHeader(title) {
        var header = new qx.ui.basic.Label(title); // store labels for disposal

        this._labels.push(header);

        header.setFont("bold");

        if (this._row != 0) {
          header.setMarginTop(10);
        }

        header.setAlignX("left");
        return header;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      // first, remove all buttons from the button row because they
      // should not be disposed
      if (this._buttonRow) {
        this._buttonRow.removeAll();

        this._disposeObjects("_buttonRow");
      }
    }
  });
  qx.ui.form.renderer.Single.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.renderer.Single": {
        "require": true
      },
      "qx.ui.form.renderer.IFormRenderer": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Renderer using the placeholder property of {@link qx.ui.form.AbstractField}
   * to visualize the name.
   */
  qx.Class.define("qx.ui.form.renderer.SinglePlaceholder", {
    extend: qx.ui.form.renderer.Single,
    implement: qx.ui.form.renderer.IFormRenderer,
    members: {
      // overridden
      addItems: function addItems(items, names, title) {
        // add the header
        if (title != null) {
          this._add(this._createHeader(title), {
            row: this._row,
            column: 0,
            colSpan: 2
          });

          this._row++;
        } // add the items


        for (var i = 0; i < items.length; i++) {
          if (items[i].setPlaceholder === undefined) {
            throw new Error("Only widgets with placeholders supported.");
          }

          items[i].setPlaceholder(names[i]);

          this._add(items[i], {
            row: this._row,
            column: 0
          });

          this._row++;
        }
      }
    }
  });
  qx.ui.form.renderer.SinglePlaceholder.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.renderer.AbstractRenderer": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Double column renderer for {@link qx.ui.form.Form}.
   */
  qx.Class.define("qx.ui.form.renderer.Double", {
    extend: qx.ui.form.renderer.AbstractRenderer,
    construct: function construct(form) {
      var layout = new qx.ui.layout.Grid();
      layout.setSpacing(6);
      layout.setColumnAlign(0, "right", "top");
      layout.setColumnAlign(1, "left", "top");
      layout.setColumnAlign(2, "right", "top");
      layout.setColumnAlign(3, "left", "top");

      this._setLayout(layout);

      qx.ui.form.renderer.AbstractRenderer.constructor.call(this, form);
    },
    members: {
      _row: 0,
      _buttonRow: null,
      // overridden
      _onFormChange: function _onFormChange() {
        if (this._buttonRow) {
          this._buttonRow.destroy();

          this._buttonRow = null;
        }

        this._row = 0;

        qx.ui.form.renderer.Double.prototype._onFormChange.base.call(this);
      },

      /**
       * Add a group of form items with the corresponding names. The names are
       * displayed as label.
       * The title is optional and is used as grouping for the given form
       * items.
       *
       * @param items {qx.ui.core.Widget[]} An array of form items to render.
       * @param names {String[]} An array of names for the form items.
       * @param title {String?} A title of the group you are adding.
       */
      addItems: function addItems(items, names, title) {
        // add the header
        if (title != null) {
          this._add(this._createHeader(title), {
            row: this._row,
            column: 0,
            colSpan: 4
          });

          this._row++;
        } // add the items


        for (var i = 0; i < items.length; i++) {
          var label = this._createLabel(names[i], items[i]);

          this._add(label, {
            row: this._row,
            column: i * 2 % 4
          });

          var item = items[i];
          label.setBuddy(item);

          this._connectVisibility(item, label);

          this._add(item, {
            row: this._row,
            column: i * 2 % 4 + 1
          });

          if (i % 2 == 1) {
            this._row++;
          } // store the names for translation


          {
            this._names.push({
              name: names[i],
              label: label,
              item: items[i]
            });
          }
        }

        if (i % 2 == 1) {
          this._row++;
        }
      },

      /**
       * Adds a button the form renderer. All buttons will be added in a
       * single row at the bottom of the form.
       *
       * @param button {qx.ui.form.Button} The button to add.
       */
      addButton: function addButton(button) {
        if (this._buttonRow == null) {
          // create button row
          this._buttonRow = new qx.ui.container.Composite();

          this._buttonRow.setMarginTop(5);

          var hbox = new qx.ui.layout.HBox();
          hbox.setAlignX("right");
          hbox.setSpacing(5);

          this._buttonRow.setLayout(hbox); // add the button row


          this._add(this._buttonRow, {
            row: this._row,
            column: 0,
            colSpan: 4
          }); // increase the row


          this._row++;
        } // add the button


        this._buttonRow.add(button);
      },

      /**
       * Returns the set layout for configuration.
       *
       * @return {qx.ui.layout.Grid} The grid layout of the widget.
       */
      getLayout: function getLayout() {
        return this._getLayout();
      },

      /**
       * Creates a label for the given form item.
       *
       * @param name {String} The content of the label without the
       *   trailing * and :
       * @param item {qx.ui.core.Widget} The item, which has the required state.
       * @return {qx.ui.basic.Label} The label for the given item.
       */
      _createLabel: function _createLabel(name, item) {
        var label = new qx.ui.basic.Label(this._createLabelText(name, item)); // store labels for disposal

        this._labels.push(label);

        label.setRich(true);
        return label;
      },

      /**
       * Creates a header label for the form groups.
       *
       * @param title {String} Creates a header label.
       * @return {qx.ui.basic.Label} The header for the form groups.
       */
      _createHeader: function _createHeader(title) {
        var header = new qx.ui.basic.Label(title); // store labels for disposal

        this._labels.push(header);

        header.setFont("bold");

        if (this._row != 0) {
          header.setMarginTop(10);
        }

        header.setAlignX("left");
        return header;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      // first, remove all buttons from the bottom row because they
      // should not be disposed
      if (this._buttonRow) {
        this._buttonRow.removeAll();

        this._disposeObjects("_buttonRow");
      }
    }
  });
  qx.ui.form.renderer.Double.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.TextField": {},
      "qx.ui.form.validation.Manager": {},
      "qx.lang.Type": {},
      "qx.core.ValidationError": {},
      "qx.ui.form.validation.AsyncValidator": {},
      "qx.ui.form.RadioButtonGroup": {},
      "qx.ui.form.RadioButton": {},
      "qx.ui.form.Spinner": {},
      "qx.core.Object": {},
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.VirtualSelectBox": {},
      "qx.data.marshal.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.FormValidator", {
    extend: qx.test.ui.LayoutTestCase,
    construct: function construct() {
      qx.test.ui.LayoutTestCase.constructor.call(this);
    },
    members: {
      __username: null,
      __password1: null,
      __password2: null,
      __manager: null,
      setUp: function setUp() {
        this.__username = new qx.ui.form.TextField();
        this.__password1 = new qx.ui.form.TextField();
        this.__password2 = new qx.ui.form.TextField();
        this.__manager = new qx.ui.form.validation.Manager();
      },
      tearDown: function tearDown() {
        this.__manager.dispose();

        this.__username.dispose();

        this.__password1.dispose();

        this.__password2.dispose();
      },
      // validator
      __notEmptyValidator: function __notEmptyValidator(value, formItem) {
        var isString = qx.lang.Type.isString(value);
        var valid = isString && value.length > 0;
        valid ? formItem.setInvalidMessage("") : formItem.setInvalidMessage("fail");
        return valid;
      },
      __notEmptyValidatorError: function __notEmptyValidatorError(value) {
        var isString = qx.lang.Type.isString(value);

        if (!isString || value.length == 0) {
          throw new qx.core.ValidationError("fail");
        }
      },
      __asyncValidator: function __asyncValidator(validator, value) {
        window.setTimeout(function () {
          var valid = value != null && value.length > 0;
          validator.setValid(valid, "fail");
        }, 100);
      },
      // context //////////////////////
      testSyncContext: function testSyncContext() {
        var self = this;

        this.__manager.add(this.__username, function (value, formItem) {
          self.assertEquals(1, this.a);
        }, {
          a: 1
        });

        this.__manager.validate();
      },
      testSync2Context: function testSync2Context() {
        var self = this;

        this.__manager.add(this.__username, function (value, formItem) {
          self.assertEquals(1, this.a);
        }, {
          a: 1
        });

        this.__manager.add(this.__password1, function (value, formItem) {
          self.assertEquals(2, this.a);
        }, {
          a: 2
        });

        this.__manager.validate();
      },
      testAsyncContext: function testAsyncContext() {
        var self = this;
        var asyncValidator = new qx.ui.form.validation.AsyncValidator(function (value, formItem) {
          self.assertEquals(1, this.a);
        });

        this.__manager.add(this.__username, asyncValidator, {
          a: 1
        });

        this.__manager.validate();

        asyncValidator.dispose();
      },
      testAsync2Context: function testAsync2Context() {
        var self = this;
        var asyncValidator = new qx.ui.form.validation.AsyncValidator(function (value, formItem) {
          self.assertEquals(1, this.a);
        });
        var asyncValidator2 = new qx.ui.form.validation.AsyncValidator(function (value, formItem) {
          self.assertEquals(2, this.a);
        });

        this.__manager.add(this.__username, asyncValidator, {
          a: 1
        });

        this.__manager.add(this.__password1, asyncValidator2, {
          a: 2
        });

        this.__manager.validate();

        asyncValidator.dispose();
        asyncValidator2.dispose();
      },
      testSyncFormContext: function testSyncFormContext() {
        var self = this;

        this.__manager.setValidator(function () {
          self.assertEquals(1, this.a);
        });

        this.__manager.setContext({
          a: 1
        });

        this.__manager.validate();
      },
      testAsyncFormContext: function testAsyncFormContext() {
        var self = this;
        var asyncValidator = new qx.ui.form.validation.AsyncValidator(function () {
          self.assertEquals(1, this.a);
        });

        this.__manager.setValidator(asyncValidator);

        this.__manager.setContext({
          a: 1
        });

        this.__manager.validate();

        asyncValidator.dispose();
      },
      // //////////////////////////////
      //  sync self contained ///////////////
      testSyncSelfContained1NotNull: function testSyncSelfContained1NotNull() {
        this.__manager.add(this.__username, this.__notEmptyValidator); // validate = fail (no text entered)


        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__manager.getValid());
        this.assertFalse(this.__username.getValid()); // check the invalid messages

        this.assertEquals("fail", this.__username.getInvalidMessage());
        this.assertEquals("fail", this.__manager.getInvalidMessages()[0]); // enter text in the usernamen

        this.__username.setValue("affe"); // validate = true


        this.assertTrue(this.__manager.validate());
        this.assertTrue(this.__manager.getValid());
        this.assertTrue(this.__username.getValid()); // remove the username

        this.__username.resetValue(); // validate = fail


        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__manager.getValid());
        this.assertFalse(this.__username.getValid());
      },
      testSyncSelfContained1NotNullRadioButtonGroup: function testSyncSelfContained1NotNullRadioButtonGroup() {
        var rbg = new qx.ui.form.RadioButtonGroup();
        rbg.setRequired(true);
        rbg.getRadioGroup().setAllowEmptySelection(true);
        var rb1 = new qx.ui.form.RadioButton("a");
        var rb2 = new qx.ui.form.RadioButton("b");
        rbg.add(rb1);
        rbg.add(rb2);

        this.__manager.add(rbg); // validate = fail (no text entered)


        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__manager.getValid());
        this.assertFalse(rbg.getValid()); // select something

        rbg.setSelection([rb1]); // validate = true

        this.assertTrue(this.__manager.validate());
        this.assertTrue(this.__manager.getValid());
        this.assertTrue(rbg.getValid());
        rbg.dispose();
      },
      testSyncSelfContained1NotNullEvents: function testSyncSelfContained1NotNullEvents(attributes) {
        this.__manager.add(this.__username, this.__notEmptyValidator);

        var self = this;
        this.assertEventFired(this.__manager, "changeValid", function () {
          self.__manager.validate();
        }, function (e) {
          self.assertFalse(e.getData());
          self.assertNull(e.getOldData());
        }); // make the form valid

        this.__username.setValue("affe");

        this.assertEventFired(this.__manager, "changeValid", function () {
          self.__manager.validate();
        }, function (e) {
          self.assertTrue(e.getData());
          self.assertFalse(e.getOldData());
        });
      },
      __testSyncSelfContained3NotNull: function __testSyncSelfContained3NotNull(validator) {
        this.__manager.add(this.__username, validator);

        this.__manager.add(this.__password1, validator);

        this.__manager.add(this.__password2, validator); // validate = fail (no text entered)


        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__username.getValid());
        this.assertFalse(this.__password1.getValid());
        this.assertFalse(this.__password2.getValid()); // check the invalid messages

        this.assertEquals("fail", this.__username.getInvalidMessage());
        this.assertEquals("fail", this.__password1.getInvalidMessage());
        this.assertEquals("fail", this.__password2.getInvalidMessage());
        this.assertEquals("fail", this.__manager.getInvalidMessages()[0]);
        this.assertEquals("fail", this.__manager.getInvalidMessages()[1]);
        this.assertEquals("fail", this.__manager.getInvalidMessages()[2]);
        this.assertEquals(3, this.__manager.getInvalidMessages().length); // enter text to the two passwordfields

        this.__password1.setValue("1");

        this.__password2.setValue("2"); // validate again = fail (username empty)


        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__username.getValid());
        this.assertTrue(this.__password1.getValid());
        this.assertTrue(this.__password2.getValid()); // check the invalid messages

        this.assertEquals("fail", this.__username.getInvalidMessage());
        this.assertEquals("fail", this.__manager.getInvalidMessages()[0]);
        this.assertEquals(1, this.__manager.getInvalidMessages().length); // enter text in the usernamen

        this.__username.setValue("affe"); // validate = true


        this.assertTrue(this.__manager.validate());
        this.assertTrue(this.__username.getValid());
        this.assertTrue(this.__password1.getValid());
        this.assertTrue(this.__password2.getValid());
        this.assertEquals(0, this.__manager.getInvalidMessages().length); // remove the username

        this.__username.resetValue(); // validate last time = false


        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__username.getValid());
        this.assertTrue(this.__password1.getValid());
        this.assertTrue(this.__password2.getValid());
        this.assertEquals(1, this.__manager.getInvalidMessages().length);
      },
      testSyncSelfContained3NotNull: function testSyncSelfContained3NotNull() {
        this.__testSyncSelfContained3NotNull(this.__notEmptyValidator);
      },
      testSyncSelfContained3NotNullError: function testSyncSelfContained3NotNullError() {
        this.__testSyncSelfContained3NotNull(this.__notEmptyValidatorError);
      },
      // //////////////////////////////
      // sync related //////////////
      __testSyncRelatedNoIndividual: function __testSyncRelatedNoIndividual(validator) {
        this.__manager.add(this.__username);

        this.__manager.add(this.__password1);

        this.__manager.add(this.__password2);

        this.__password1.setValue("affe");

        this.__manager.setValidator(validator);

        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__manager.getValid());
        this.assertEquals("fail", this.__manager.getInvalidMessage());
        this.assertEquals("fail", this.__manager.getInvalidMessages()[0]);

        this.__password2.setValue("affe");

        this.assertTrue(this.__manager.validate());
        this.assertTrue(this.__manager.getValid());
        this.assertEquals(0, this.__manager.getInvalidMessages().length);
      },
      testSyncRelatedNoIndividual: function testSyncRelatedNoIndividual() {
        this.__testSyncRelatedNoIndividual(function (formItems, manager) {
          var valid = formItems[1].getValue() == formItems[2].getValue();

          if (!valid) {
            manager.setInvalidMessage("fail");
          }

          return valid;
        });
      },
      testSyncRelatedNoIndividualError: function testSyncRelatedNoIndividualError() {
        this.__testSyncRelatedNoIndividual(function (formItems, manager) {
          if (formItems[1].getValue() != formItems[2].getValue()) {
            throw new qx.core.ValidationError("fail");
          }
        });
      },
      testSyncRelatedWithIndividual: function testSyncRelatedWithIndividual() {
        this.__manager.add(this.__username, this.__notEmptyValidator);

        this.__manager.add(this.__password1, this.__notEmptyValidator);

        this.__manager.add(this.__password2, this.__notEmptyValidator);

        this.__password1.setValue("affe");

        this.__manager.setValidator(function (formItems, manager) {
          var valid = formItems[1].getValue() == formItems[2].getValue();

          if (!valid) {
            manager.setInvalidMessage("fail");
          }

          return valid;
        }); // false: username and password2 empty && password 1 != password2


        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__manager.getValid());
        this.assertFalse(this.__username.getValid());
        this.assertFalse(this.__password2.getValid());

        var messages = this.__manager.getInvalidMessages();

        this.assertEquals("fail", this.__manager.getInvalidMessage());
        this.assertEquals("fail", messages[0]);
        this.assertEquals("fail", messages[1]);
        this.assertEquals("fail", messages[2]);
        this.assertEquals(3, messages.length);

        this.__password2.setValue("affe"); // fail: username empty


        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__manager.getValid());
        this.assertEquals("fail", this.__manager.getInvalidMessages()[0]);
        this.assertEquals(1, this.__manager.getInvalidMessages().length);

        this.__username.setValue("user"); // ok


        this.assertTrue(this.__manager.validate());
        this.assertTrue(this.__manager.getValid());
        this.assertEquals(0, this.__manager.getInvalidMessages().length);
        this.assertTrue(this.__username.getValid());
        this.assertTrue(this.__password1.getValid());
        this.assertTrue(this.__password2.getValid()); // change back to not valid

        this.__password1.setValue("user"); // not ok


        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__manager.getValid());
        this.assertEquals(1, this.__manager.getInvalidMessages().length);
        this.assertTrue(this.__username.getValid());
      },
      // //////////////////////////////
      // required /////////////////////
      testRequired: function testRequired() {
        // set all 3 fields to required
        this.__username.setRequired(true);

        this.__password1.setRequired(true);

        this.__password2.setRequired(true); // add the fields to the form manager


        this.__manager.add(this.__username);

        this.__manager.add(this.__password1);

        this.__manager.add(this.__password2); // validate = fail (no text entered)


        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__username.getValid());
        this.assertFalse(this.__password1.getValid());
        this.assertFalse(this.__password2.getValid()); // enter text to the two passwordfields

        this.__password1.setValue("1");

        this.__password2.setValue("2"); // validate again = fail (username empty)


        this.assertFalse(this.__manager.validate());
        this.assertFalse(this.__username.getValid());
        this.assertTrue(this.__password1.getValid());
        this.assertTrue(this.__password2.getValid()); // enter text in the usernamen

        this.__username.setValue("affe"); // validate last time = true


        this.assertTrue(this.__manager.validate());
        this.assertTrue(this.__username.getValid());
        this.assertTrue(this.__password1.getValid());
        this.assertTrue(this.__password2.getValid());
      },
      testRequiredFieldMessage: function testRequiredFieldMessage() {
        // set a global and an individual required field message
        this.__manager.setRequiredFieldMessage("affe");

        this.__password1.setRequiredInvalidMessage("AFFEN"); // set fields to required


        this.__username.setRequired(true);

        this.__password1.setRequired(true); // add the fields to the form manager


        this.__manager.add(this.__username);

        this.__manager.add(this.__password1); // validate = fail (no text entered)


        this.assertFalse(this.__manager.validate()); // check the messages

        this.assertEquals("affe", this.__username.getInvalidMessage());
        this.assertEquals("AFFEN", this.__password1.getInvalidMessage());
      },
      testRequiredNumberZero: function testRequiredNumberZero() {
        // initialize with value 1
        var spinner = new qx.ui.form.Spinner(-1, 1, 1);
        spinner.setRequired(true);

        this.__manager.add(spinner); // validate --> should be valid due to value 1 set


        this.assertTrue(this.__manager.validate());
        this.assertTrue(spinner.getValid());
        spinner.setValue(0); // validate --> should be valid due to value 0 set

        this.assertTrue(this.__manager.validate());
        this.assertTrue(spinner.getValid());
        spinner.dispose();
      },
      // //////////////////////////////
      // Async self contained //////////
      testAsyncSelfContained1NotNullFail: function testAsyncSelfContained1NotNullFail() {
        var asyncValidator = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertFalse(this.__manager.isValid());
            this.assertFalse(this.__username.getValid());
            this.assertEquals("fail", this.__username.getInvalidMessage());
          }, this);
        }, this);

        this.__manager.validate();

        this.wait();
      },
      testAsyncSelfContained1NotNull: function testAsyncSelfContained1NotNull() {
        var asyncValidator = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator);

        this.__username.setValue("affe");

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertTrue(this.__manager.isValid());
            this.assertTrue(this.__username.getValid());
          }, this);
        }, this);

        this.__manager.validate();

        this.wait();
      },
      testAsyncSelfContained3NotNullFail: function testAsyncSelfContained3NotNullFail() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator2 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator3 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, asyncValidator2);

        this.__manager.add(this.__password2, asyncValidator3);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertFalse(this.__manager.isValid());
            this.assertFalse(this.__username.getValid());
            this.assertEquals("fail", this.__username.getInvalidMessage());
            this.assertEquals("fail", this.__password1.getInvalidMessage());
            this.assertEquals("fail", this.__password2.getInvalidMessage());
            this.assertEquals(3, this.__manager.getInvalidMessages().length);
            this.assertEquals("fail", this.__manager.getInvalidMessages()[0]);
            this.assertEquals("fail", this.__manager.getInvalidMessages()[1]);
            this.assertEquals("fail", this.__manager.getInvalidMessages()[2]);
          }, this);
        }, this);

        this.__manager.validate();

        this.wait();
      },
      testAsyncSelfContained3NotNull: function testAsyncSelfContained3NotNull() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator2 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator3 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, asyncValidator2);

        this.__manager.add(this.__password2, asyncValidator3);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertTrue(this.__manager.isValid());
            this.assertTrue(this.__username.getValid());
          }, this);
        }, this); // add values to all three input fields


        this.__username.setValue("a");

        this.__password1.setValue("b");

        this.__password2.setValue("c");

        this.__manager.validate();

        this.wait();
      },
      testAsyncSelfContained2NotNullFailMixed: function testAsyncSelfContained2NotNullFailMixed() {
        // BUG #3735
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator2 = new qx.ui.form.validation.AsyncValidator(function (validator, value) {
          window.setTimeout(function () {
            validator.setValid(false, "fail");
          }, 300);
        });
        var asyncValidator3 = new qx.ui.form.validation.AsyncValidator(function (validator, value) {
          window.setTimeout(function () {
            validator.setValid(true, "WIN");
          }, 500);
        });

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, asyncValidator2);

        this.__manager.add(this.__password2, asyncValidator3);

        this.__username.setValid(false);

        this.__password1.setValid(false);

        this.__password2.setValid(false);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertFalse(this.__manager.isValid());
            this.assertTrue(this.__username.getValid());
            this.assertFalse(this.__password1.getValid());
            this.assertTrue(this.__password2.getValid());
          }, this);
        }, this);

        this.__username.setValue("a");

        this.__manager.validate();

        this.wait();
      },
      testAsyncSelfContained3NotNullHalfFail: function testAsyncSelfContained3NotNullHalfFail() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator2 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator3 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, asyncValidator2);

        this.__manager.add(this.__password2, asyncValidator3);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertFalse(this.__manager.isValid());
            this.assertFalse(this.__username.getValid());
            this.assertEquals("fail", this.__username.getInvalidMessage());
            this.assertEquals("fail", this.__manager.getInvalidMessages()[0]);
            this.assertEquals(1, this.__manager.getInvalidMessages().length);
          }, this);
        }, this); // add values to all three input fields


        this.__password1.setValue("b");

        this.__password2.setValue("c");

        this.__manager.validate();

        this.wait();
      },
      // //////////////////////////////
      // Async related //////////
      testAsyncRelated3NotNullFail: function testAsyncRelated3NotNullFail() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator2 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator3 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, asyncValidator2);

        this.__manager.add(this.__password2, asyncValidator3);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertFalse(this.__manager.isValid());
            this.assertTrue(this.__username.getValid());
            this.assertTrue(this.__password1.getValid());
            this.assertTrue(this.__password2.getValid());
          }, this);
        }, this);

        this.__manager.setValidator(new qx.ui.form.validation.AsyncValidator(function (formItems, validator) {
          window.setTimeout(function () {
            validator.setValid(formItems[1].getValue() == formItems[2].getValue());
          }, 100);
        }));

        this.__username.setValue("u");

        this.__password1.setValue("a");

        this.__password2.setValue("b");

        this.__manager.validate();

        this.wait();
      },
      testAsyncRelated3NotNull: function testAsyncRelated3NotNull() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator2 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator3 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, asyncValidator2);

        this.__manager.add(this.__password2, asyncValidator3);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertTrue(this.__manager.isValid());
            this.assertTrue(this.__username.getValid());
            this.assertTrue(this.__password1.getValid());
            this.assertTrue(this.__password2.getValid());
          }, this);
        }, this);

        this.__manager.setValidator(new qx.ui.form.validation.AsyncValidator(function (formItems, validator) {
          window.setTimeout(function () {
            validator.setValid(formItems[1].getValue() == formItems[2].getValue());
          }, 100);
        }));

        this.__username.setValue("u");

        this.__password1.setValue("a");

        this.__password2.setValue("a");

        this.__manager.validate();

        this.wait();
      },
      // //////////////////////////////
      // Mixed self contained //////////
      testMixedSelfContained3NotNullAsyncFail: function testMixedSelfContained3NotNullAsyncFail() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, this.__notEmptyValidator);

        this.__manager.add(this.__password2, this.__notEmptyValidator);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertFalse(this.__manager.isValid());
            this.assertFalse(this.__username.getValid());
            this.assertTrue(this.__password1.getValid());
            this.assertTrue(this.__password2.getValid());
          }, this);
        }, this);

        this.__password1.setValue("a");

        this.__password2.setValue("b");

        this.__manager.validate();

        this.wait();
      },
      testMixedSelfContained3NotNullSyncFail: function testMixedSelfContained3NotNullSyncFail() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, this.__notEmptyValidator);

        this.__manager.add(this.__password2, this.__notEmptyValidator);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertFalse(this.__manager.isValid());
            this.assertTrue(this.__username.getValid());
            this.assertFalse(this.__password1.getValid());
            this.assertTrue(this.__password2.getValid());
          }, this);
        }, this);

        this.__username.setValue("a");

        this.__password2.setValue("b");

        this.__manager.validate();

        this.wait();
      },
      testMixedSelfContained3NotNullSync: function testMixedSelfContained3NotNullSync() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, this.__notEmptyValidator);

        this.__manager.add(this.__password2, this.__notEmptyValidator);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertTrue(this.__manager.isValid());
            this.assertTrue(this.__username.getValid());
            this.assertTrue(this.__password1.getValid());
            this.assertTrue(this.__password2.getValid());
          }, this);
        }, this);

        this.__username.setValue("a");

        this.__password1.setValue("b");

        this.__password2.setValue("c");

        this.__manager.validate();

        this.wait();
      },
      testMixedSelfContained2SyncRequired: function testMixedSelfContained2SyncRequired(attribute) {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__password1.setRequired(true);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertFalse(this.__manager.isValid());
            this.assertTrue(this.__username.getValid());
            this.assertFalse(this.__password1.getValid());
          }, this);
        }, this);

        this.__username.setValue("a");

        this.__manager.validate();

        this.wait();
      },
      // //////////////////////////////
      // Mixed related //////////
      testMixedRelated3NotNull: function testMixedRelated3NotNull() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator3 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, this.__notEmptyValidator);

        this.__manager.add(this.__password2, asyncValidator3);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertTrue(this.__manager.isValid());
            this.assertTrue(this.__username.getValid());
            this.assertTrue(this.__password1.getValid());
            this.assertTrue(this.__password2.getValid());
          }, this);
        }, this);

        this.__manager.setValidator(new qx.ui.form.validation.AsyncValidator(function (formItems, validator) {
          window.setTimeout(function () {
            validator.setValid(formItems[1].getValue() == formItems[2].getValue());
          }, 100);
        }));

        this.__username.setValue("u");

        this.__password1.setValue("a");

        this.__password2.setValue("a");

        this.__manager.validate();

        this.wait();
      },
      testMixedRelated3NotNullSyncFail: function testMixedRelated3NotNullSyncFail() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator3 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, this.__notEmptyValidator);

        this.__manager.add(this.__password2, asyncValidator3);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertFalse(this.__manager.isValid());
            this.assertTrue(this.__username.getValid());
            this.assertFalse(this.__password1.getValid());
            this.assertTrue(this.__password2.getValid());
          }, this);
        }, this);

        this.__manager.setValidator(new qx.ui.form.validation.AsyncValidator(function (formItems, validator) {
          window.setTimeout(function () {
            validator.setValid(formItems[1].getValue() == formItems[2].getValue());
          }, 100);
        }));

        this.__username.setValue("u");

        this.__password2.setValue("a");

        this.__manager.validate();

        this.wait();
      },
      testMixedRelated3NotNullAsyncFail: function testMixedRelated3NotNullAsyncFail() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator3 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, this.__notEmptyValidator);

        this.__manager.add(this.__password2, asyncValidator3);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertFalse(this.__manager.isValid());
            this.assertFalse(this.__username.getValid());
            this.assertTrue(this.__password1.getValid());
            this.assertTrue(this.__password2.getValid());
          }, this);
        }, this);

        this.__manager.setValidator(new qx.ui.form.validation.AsyncValidator(function (formItems, validator) {
          window.setTimeout(function () {
            validator.setValid(formItems[1].getValue() == formItems[2].getValue());
          }, 100);
        }));

        this.__password1.setValue("a");

        this.__password2.setValue("a");

        this.__manager.validate();

        this.wait();
      },
      testMixedRelated3NotNullAsyncFormFail: function testMixedRelated3NotNullAsyncFormFail() {
        var asyncValidator1 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);
        var asyncValidator3 = new qx.ui.form.validation.AsyncValidator(this.__asyncValidator);

        this.__manager.add(this.__username, asyncValidator1);

        this.__manager.add(this.__password1, this.__notEmptyValidator);

        this.__manager.add(this.__password2, asyncValidator3);

        this.__manager.addListener("complete", function () {
          this.resume(function () {
            // check the status after the complete
            this.assertFalse(this.__manager.isValid());
            this.assertTrue(this.__username.getValid());
            this.assertTrue(this.__password1.getValid());
            this.assertTrue(this.__password2.getValid());
          }, this);
        }, this);

        this.__manager.setValidator(new qx.ui.form.validation.AsyncValidator(function (formItems, validator) {
          window.setTimeout(function () {
            validator.setValid(formItems[1].getValue() == formItems[2].getValue());
          }, 100);
        }));

        this.__username.setValue("u");

        this.__password1.setValue("a");

        this.__password2.setValue("b");

        this.__manager.validate();

        this.wait();
      },
      // //////////////////////////////
      // add error ////////////////////
      testAddWrong: function testAddWrong() {
        this.assertException(function () {
          this.__manager.add(new qx.core.Object());
        });
        this.assertException(function () {
          this.__manager.add(123);
        });
        this.assertException(function () {
          this.__manager.add({});
        });
      },
      testAddSelectBoxWithValidator: function testAddSelectBoxWithValidator() {
        var box = new qx.ui.form.SelectBox();
        this.assertException(function () {
          this.__manager.add(box, function () {});
        });
        box.dispose();
      },
      // //////////////////////////////
      // remove ///////////////////////
      testRemove: function testRemove() {
        this.__manager.add(this.__username, function (value, formItem) {
          this.assertFalse(true, "validation method called!");
        }, this);

        this.assertEquals(this.__username, this.__manager.remove(this.__username));

        this.__manager.validate();
      },
      // //////////////////////////////
      // get items ////////////////////
      testGetItems: function testGetItems() {
        this.__manager.add(this.__username);

        this.__manager.add(this.__password1);

        var items = this.__manager.getItems();

        this.assertInArray(this.__username, items);
        this.assertInArray(this.__password1, items);
      },
      // //////////////////////////////
      // validate //////////////////////
      testValidateDataBindingSelection: function testValidateDataBindingSelection() {
        "use strict";

        var vsb = new qx.ui.form.VirtualSelectBox();
        vsb.setRequired(true);

        this.__manager.add(vsb);

        this.__manager.validate();

        this.assertFalse(vsb.isValid());
        var m = qx.data.marshal.Json.createModel(['a', 'b']);
        vsb.setModel(m);

        this.__manager.validate();

        this.assertTrue(vsb.isValid());
        vsb.dispose();
        m.dispose();
      } // //////////////////////////////

    }
  });
  qx.test.ui.form.FormValidator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.basic.Label": {},
      "qx.ui.form.TextField": {},
      "qx.ui.form.Spinner": {},
      "qx.ui.form.CheckBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.Label", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __formWidget: null,
      __label: null,
      setUp: function setUp() {
        this.__label = new qx.ui.basic.Label("abc");
      },
      tearDown: function tearDown() {
        this.__label.destroy();

        this.__formWidget.destroy();
      },
      __testEnabled: function __testEnabled() {
        this.__label.setBuddy(this.__formWidget); // check the initial enabled state


        this.assertTrue(this.__formWidget.getEnabled(), "Form widget is disabled.");
        this.assertTrue(this.__label.getEnabled(), "Label widget is disabled."); // disable the textfield. Label should be disabled too

        this.__formWidget.setEnabled(false); // check if both are disabled


        this.assertFalse(this.__formWidget.getEnabled(), "Form widget is not disabled.");
        this.assertFalse(this.__label.getEnabled(), "Label widget is not disabled."); // enabled the label, textfield should stay

        this.__label.setEnabled(true); // check if the enabled properties are still correct


        this.assertFalse(this.__formWidget.getEnabled(), "Form widget is not disabled at the end.");
        this.assertTrue(this.__label.getEnabled(), "Label widget is ensabled at the end.");
      },
      __testEnabledRemove: function __testEnabledRemove() {
        this.__label.setBuddy(this.__formWidget); // disable the textfield. Label should be disabled too


        this.__formWidget.setEnabled(false); // check if both are disabled


        this.assertFalse(this.__formWidget.getEnabled(), "Form widget is not disabled.");
        this.assertFalse(this.__label.getEnabled(), "Label widget is not disabled."); // remove the buddy

        this.__label.setBuddy(null); // enabled the textfield. label should stay


        this.__formWidget.setEnabled(true); // check if the enabled properties are still correct


        this.assertFalse(this.__label.getEnabled(), "Label widget is not disabled at the end.");
        this.assertTrue(this.__formWidget.getEnabled(), "Form widget is ensabled at the end.");
      },
      __testFocus: function __testFocus() {
        // NEEDED FOR THE FOCUS
        this.getRoot().add(this.__formWidget);

        this.__label.setBuddy(this.__formWidget);

        this.__formWidget.addListener("focus", function () {
          this.resume(function () {// do nothing. Just check for the event
          }, this);
        }, this);

        this.tapOn(this.__label);
        this.wait();
      },
      __testFocusRemove: function __testFocusRemove() {
        // NEEDED FOR THE FOCUS
        this.getRoot().add(this.__formWidget);

        this.__label.setBuddy(this.__formWidget);

        this.__label.setBuddy(null);

        var focused = false;

        this.__formWidget.addListener("focus", function () {
          focused = true;
        }, this);

        var self = this;
        window.setTimeout(function () {
          self.resume(function () {
            this.assertFalse(self.__label.hasListener("click"), "Listener still there.");
            this.assertFalse(focused, "Element has been focused");
          }, self);
        }, 1000);
        this.tapOn(this.__label);
        this.wait();
      },
      testEnabledRemoveTextField: function testEnabledRemoveTextField() {
        this.__formWidget = new qx.ui.form.TextField("abc");

        this.__testEnabledRemove();
      },
      testEnabledTextField: function testEnabledTextField() {
        this.__formWidget = new qx.ui.form.TextField("abc");

        this.__testEnabled();
      },
      testEnabledRemoveSpinner: function testEnabledRemoveSpinner() {
        this.__formWidget = new qx.ui.form.Spinner();

        this.__testEnabledRemove();
      },
      testEnabledSpinner: function testEnabledSpinner() {
        this.__formWidget = new qx.ui.form.Spinner();

        this.__testEnabled();
      },
      testEnabledRemoveCheckBox: function testEnabledRemoveCheckBox() {
        this.__formWidget = new qx.ui.form.CheckBox();

        this.__testEnabledRemove();
      },
      testEnabledCheckBox: function testEnabledCheckBox() {
        this.__formWidget = new qx.ui.form.CheckBox();

        this.__testEnabled();
      },
      testFocusTextField: function testFocusTextField() {
        this.__formWidget = new qx.ui.form.TextField("abc");

        this.__testFocus();
      },
      testFocusSpinner: function testFocusSpinner() {
        this.__formWidget = new qx.ui.form.Spinner();

        this.__testFocus();
      },
      testFocusCheckBox: function testFocusCheckBox() {
        this.__formWidget = new qx.ui.form.CheckBox();

        this.__testFocus();
      },
      testFocusRemoveTextField: function testFocusRemoveTextField() {
        this.__formWidget = new qx.ui.form.TextField("abc");

        this.__testFocusRemove();
      },
      testFocusRemoveSpinner: function testFocusRemoveSpinner() {
        this.__formWidget = new qx.ui.form.Spinner();

        this.__testFocusRemove();
      },
      testFocusRemoveCheckBox: function testFocusRemoveCheckBox() {
        this.__formWidget = new qx.ui.form.CheckBox();

        this.__testFocusRemove();
      },
      testFocusNotFocusableTextField: function testFocusNotFocusableTextField() {
        this.__formWidget = new qx.ui.form.TextField();

        this.__formWidget.setReadOnly(true);

        this.__label.setBuddy(this.__formWidget);

        this.tapOn(this.__label);
      }
    },
    destruct: function destruct() {
      this.__label = this.__formWidget = null;
    }
  });
  qx.test.ui.form.Label.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.List": {},
      "qx.ui.form.ListItem": {},
      "qx.ui.container.Composite": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.List", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __list: null,
      setUp: function setUp() {
        var list = this.__list = new qx.ui.form.List();
        var items = ["AAA", "BBB", "CCC"];
        items.forEach(function (item) {
          item = new qx.ui.form.ListItem(item);
          list.add(item);
        });
        this.getRoot().add(list);
        this.flush();
      },
      "test: find regular item": function testFindRegularItem() {
        var list = this.__list;
        var found = list.findItem("AAA");
        this.assertInstance(found, qx.ui.form.ListItem, "Item not found");
      },
      "test: find rich-text item": function testFindRichTextItem() {
        var list = this.__list;
        var item = new qx.ui.form.ListItem("<b>Bold</b>").set({
          rich: true
        });
        list.add(item);
        this.flush();
        var found = list.findItem("Bold");
        this.assertInstance(found, qx.ui.form.ListItem, "Item not found");
      },
      "test: get container for list items": function testGetContainerForListItems() {
        var container = this.__list._createListItemContainer();

        this.assertInstance(container, qx.ui.container.Composite, "Wrong return value of '_createListItemContainer'");
        container.dispose();
      },
      tearDown: function tearDown() {
        qx.test.ui.form.List.prototype.tearDown.base.call(this);

        this.__list.destroy();
      }
    }
  });
  qx.test.ui.form.List.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.menu.Menu": {},
      "qx.ui.menu.Button": {},
      "qx.ui.form.MenuButton": {},
      "qx.ui.menu.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.MenuButton", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __menu: null,
      __menuButton: null,
      setUp: function setUp() {
        qx.test.ui.form.MenuButton.prototype.setUp.base.call(this);
        this.__menu = new qx.ui.menu.Menu();

        this.__menu.add(new qx.ui.menu.Button("Undo"));

        this.__menu.add(new qx.ui.menu.Button("Redo"));

        this.__menu.add(new qx.ui.menu.Button("Cut"));

        this.__menuButton = new qx.ui.form.MenuButton("Menu Button", null, this.__menu);
        this.getRoot().add(this.__menuButton);
        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.form.MenuButton.prototype.tearDown.base.call(this);

        var buttons = this.__menu.getChildren();

        for (var i = 0; i < buttons.length; i++) {
          buttons[i].dispose();
        }

        this.__menu.dispose();

        this.__menuButton.dispose();

        this.flush();
      },
      testOpen: function testOpen() {
        this.__menuButton.open();

        this.assertTrue(this.__menu.isVisible());
        this.assertNull(this.__menu.getSelectedButton());
        qx.ui.menu.Manager.getInstance().hideAll();
        this.assertFalse(this.__menu.isVisible());
      },
      testOpenSelectFirst: function testOpenSelectFirst() {
        this.__menuButton.open(true);

        this.assertTrue(this.__menu.isVisible());
        this.assertEquals(this.__menu.getChildren()[0], this.__menu.getSelectedButton());
        qx.ui.menu.Manager.getInstance().hideAll();
        this.assertFalse(this.__menu.isVisible());
      },
      testOpenSelectFirstWithDisabledElement: function testOpenSelectFirstWithDisabledElement() {
        this.__menu.getChildren()[0].setEnabled(false);

        this.__menuButton.open(true);

        this.assertTrue(this.__menu.isVisible());
        this.assertEquals(this.__menu.getChildren()[1], this.__menu.getSelectedButton());
        qx.ui.menu.Manager.getInstance().hideAll();
        this.assertFalse(this.__menu.isVisible());
      }
    }
  });
  qx.test.ui.form.MenuButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.IModel": {},
      "qx.ui.form.ListItem": {},
      "qx.ui.form.RadioButton": {},
      "qx.ui.groupbox.RadioGroupBox": {},
      "qx.ui.form.CheckBox": {},
      "qx.ui.groupbox.CheckGroupBox": {},
      "qx.ui.tree.TreeFolder": {},
      "qx.ui.tree.TreeFile": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.ModelProperty", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __test: function __test(widget) {
        // check for the interface
        this.assertTrue(qx.Class.hasInterface(widget.constructor, qx.ui.form.IModel), "Interface not implemented"); // test the init value (null)

        this.assertNull(widget.getModel()); // set a string

        widget.setModel("affe");
        this.assertEquals("affe", widget.getModel()); // set a number (check that no check is implemented)

        widget.setModel(123);
        this.assertEquals(123, widget.getModel()); // test the reset

        widget.resetModel();
        this.assertNull(widget.getModel()); // check the event

        var self = this;
        this.assertEventFired(widget, "changeModel", function () {
          widget.setModel(true);
        }, function (e) {
          self.assertEquals(true, e.getData());
          self.assertEquals(null, e.getOldData());
        }, "Event is wrong!"); // check the event again with data in the event

        var self = this;
        this.assertEventFired(widget, "changeModel", function () {
          widget.setModel("abc");
        }, function (e) {
          self.assertEquals("abc", e.getData());
          self.assertEquals(true, e.getOldData());
        }, "Event is wrong!");
        widget.dispose();
      },
      testListItem: function testListItem() {
        this.__test(new qx.ui.form.ListItem());
      },
      testRadioButton: function testRadioButton() {
        this.__test(new qx.ui.form.RadioButton());
      },
      testRadioGroupBox: function testRadioGroupBox() {
        this.__test(new qx.ui.groupbox.RadioGroupBox());
      },
      testCheckBox: function testCheckBox() {
        this.__test(new qx.ui.form.CheckBox());
      },
      testCheckGroupBox: function testCheckGroupBox() {
        this.__test(new qx.ui.groupbox.CheckGroupBox());
      },
      testTreeFolder: function testTreeFolder() {
        this.__test(new qx.ui.tree.TreeFolder());
      },
      testTreeFile: function testTreeFile() {
        this.__test(new qx.ui.tree.TreeFile());
      }
    }
  });
  qx.test.ui.form.ModelProperty.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.List": {},
      "qx.ui.form.ListItem": {},
      "qx.ui.form.RadioGroup": {},
      "qx.ui.form.RadioButtonGroup": {},
      "qx.ui.form.RadioButton": {},
      "qx.ui.tree.Tree": {},
      "qx.ui.tree.TreeFolder": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.ModelSelection", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __testGetSingle: function __testGetSingle(widget, children) {
        var children = children || widget.getChildren(); // check the model selection

        widget.setSelection([children[0]]);
        this.assertEquals(1, widget.getModelSelection().getItem(0)); // check the model selection again

        widget.setSelection([children[2]]);
        this.assertEquals(3, widget.getModelSelection().getItem(0));
      },
      __testGetMulti: function __testGetMulti(widget, children) {
        var children = children || widget.getChildren(); // check the model selection

        widget.setSelection([children[0]]);
        this.assertEquals(1, widget.getModelSelection().getItem(0)); // check the model selection again

        widget.setSelection([children[1], children[2]]);
        this.assertEquals(2, widget.getModelSelection().getLength(), "Wrong length");
        this.assertTrue(widget.getModelSelection().contains(2));
        this.assertTrue(widget.getModelSelection().contains(3));
      },
      __testSetSingle: function __testSetSingle(widget, children) {
        var children = children || widget.getChildren(); // check the set selection

        widget.setModelSelection([2]);
        this.assertEquals(children[1], widget.getSelection()[0]); // check the set selection again

        widget.setModelSelection([3]);
        this.assertEquals(children[2], widget.getSelection()[0]);
      },
      __testSetMulti: function __testSetMulti(widget, children) {
        var children = children || widget.getChildren(); // check the set selection

        widget.setModelSelection([2]);
        this.assertEquals(children[1], widget.getSelection()[0]); // check the set selection again

        widget.setModelSelection([2, 3]);
        this.assertEquals(2, widget.getSelection().length);
        this.assertTrue(widget.getSelection().includes(children[1]));
        this.assertTrue(widget.getSelection().includes(children[2]));
      },
      __createSelectBox: function __createSelectBox() {
        var box = new qx.ui.form.SelectBox();

        this.__addListItems(box);

        return box;
      },
      __createList: function __createList() {
        var list = new qx.ui.form.List();

        this.__addListItems(list);

        return list;
      },
      __addListItems: function __addListItems(widget) {
        for (var i = 0; i < 3; i++) {
          var l = new qx.ui.form.ListItem("I" + (i + 1));
          l.setModel(i + 1);
          widget.add(l);
        }
      },
      __createRadioGroup: function __createRadioGroup() {
        var group = new qx.ui.form.RadioGroup();

        this.__addRadioButton(group);

        return group;
      },
      __createRadioButtonGroup: function __createRadioButtonGroup() {
        var group = new qx.ui.form.RadioButtonGroup();

        this.__addRadioButton(group);

        return group;
      },
      __addRadioButton: function __addRadioButton(widget) {
        for (var i = 0; i < 3; i++) {
          var r = new qx.ui.form.RadioButton();
          r.setModel(i + 1);
          widget.add(r);
        }
      },
      __createTree: function __createTree() {
        var tree = new qx.ui.tree.Tree();
        var t2 = new qx.ui.tree.TreeFolder().set({
          model: 3
        });
        var t1 = new qx.ui.tree.TreeFolder().set({
          model: 2
        });
        var t0 = new qx.ui.tree.TreeFolder().set({
          model: 1
        });
        tree.setRoot(t0);
        t0.add(t1);
        t1.add(t2); // keep one folder closed because the behavior could change if the
        // folders should be opened

        t1.setOpen(true);
        return tree;
      },
      __getRidOf: function __getRidOf(box) {
        var children = box.getChildren();

        for (var i = 0; i < children.length; i++) {
          children[i].dispose();
        }

        box.dispose();
      },
      testSelectBoxGetSingle: function testSelectBoxGetSingle() {
        var box = this.__createSelectBox();

        this.__testGetSingle(box);

        this.__getRidOf(box);
      },
      testSelectBoxSetSingle: function testSelectBoxSetSingle() {
        var box = this.__createSelectBox();

        this.__testSetSingle(box);

        this.__getRidOf(box);
      },
      testListGetSingle: function testListGetSingle() {
        var list = this.__createList();

        this.__testGetSingle(list);

        this.__getRidOf(list);
      },
      testListSetSingle: function testListSetSingle() {
        var list = this.__createList();

        this.__testSetSingle(list);

        this.__getRidOf(list);
      },
      testListGetMulti: function testListGetMulti() {
        var list = this.__createList();

        list.setSelectionMode("multi");

        this.__testGetMulti(list);

        this.__getRidOf(list);
      },
      testListSetMulti: function testListSetMulti() {
        var list = this.__createList();

        list.setSelectionMode("multi");

        this.__testSetMulti(list);

        this.__getRidOf(list);
      },
      testRadioGroupGetSingle: function testRadioGroupGetSingle() {
        var group = this.__createRadioGroup();

        this.__testGetSingle(group);

        this.__getRidOf(group);
      },
      testRadioGroupSetSingle: function testRadioGroupSetSingle() {
        var group = this.__createRadioGroup();

        this.__testSetSingle(group);

        this.__getRidOf(group);
      },
      testRadioButtonGroupGetSingle: function testRadioButtonGroupGetSingle() {
        var group = this.__createRadioButtonGroup();

        this.__testGetSingle(group);

        this.__getRidOf(group);
      },
      testRadioButtonGroupSetSingle: function testRadioButtonGroupSetSingle() {
        var group = this.__createRadioButtonGroup();

        this.__testSetSingle(group);

        this.__getRidOf(group);
      },
      testTreeGetSingle: function testTreeGetSingle() {
        var widget = this.__createTree();

        var children = widget.getItems(true);

        this.__testGetSingle(widget, children);

        widget.destroy();
      },
      testTreeSetSingle: function testTreeSetSingle() {
        var widget = this.__createTree();

        var children = widget.getItems(true);

        this.__testSetSingle(widget, children);

        widget.destroy();
      },
      testTreeGetMulti: function testTreeGetMulti() {
        var widget = this.__createTree();

        widget.setSelectionMode("multi");
        var children = widget.getItems(true);

        this.__testGetMulti(widget, children);

        widget.destroy();
      },
      testTreeSetMulti: function testTreeSetMulti() {
        var widget = this.__createTree();

        widget.setSelectionMode("multi");
        var children = widget.getItems(true);

        this.__testSetMulti(widget, children);

        widget.destroy();
      }
    }
  });
  qx.test.ui.form.ModelSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.INumberForm": {},
      "qx.ui.form.Spinner": {},
      "qx.ui.form.Slider": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.NumberFormat", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __test: function __test(widget) {
        // check if the interface is implemented
        this.assertTrue(qx.Class.hasInterface(widget.constructor, qx.ui.form.INumberForm), "Interface not implemented"); // check for the init value

        this.assertEquals(0, widget.getValue(), "Wrong init value set."); // just check if the method is available

        widget.resetValue(); // check the getter and setter

        widget.setValue(10);
        this.assertEquals(10, widget.getValue(), "Set or get does not work.");
        var self = this;
        this.assertEventFired(widget, "changeValue", function () {
          widget.setValue(11);
        }, function (e) {
          self.assertEquals(11, e.getData(), "Not the right number in the event.");
          self.assertEquals(10, e.getOldData(), "Wrong old data in the event.");
        }, "Event is wrong!"); // test for null values

        widget.setValue(null); // get rid of the widget

        widget.destroy();
      },
      testSpinner: function testSpinner() {
        this.__test(new qx.ui.form.Spinner());
      },
      testSlider: function testSlider() {
        this.__test(new qx.ui.form.Slider());
      }
    }
  });
  qx.test.ui.form.NumberFormat.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.ComboBox": {},
      "qx.ui.form.DateField": {},
      "qx.ui.form.AbstractField": {},
      "qx.bom.client.Css": {},
      "qx.ui.core.FocusHandler": {},
      "qx.ui.form.TextField": {},
      "qx.ui.form.TextArea": {},
      "qx.ui.form.PasswordField": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.placeholder": {
          "className": "qx.bom.client.Css"
        },
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.Placeholder", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __testInit: function __testInit(clazz, childControlName) {
        var widget = new clazz();
        widget.setValue("affe");
        widget.setPlaceholder("aaa");
        this.getRoot().add(widget);
        this.flush();
        this.assertEquals("affe", this.__getVisibleValueOf(widget), "placeholder visible");
        this.assertEquals("affe", widget.getValue(), "Wrong value returned.");
        this.assertFalse(this.__isPlaceholderVisible(widget));
        widget.destroy();
        widget = new clazz();
        widget.setPlaceholder("abc");
        this.getRoot().add(widget); // sync the appearance

        this.__syncAppearance(widget);

        this.assertTrue(this.__isPlaceholderVisible(widget));
        this.assertEquals("abc", this.__getPlaceholderValueOf(widget), "placeholder not visible");
        this.assertNull(widget.getValue(), "Wrong value returned."); // get rid of the widget

        widget.destroy();
      },
      __testChangeValue: function __testChangeValue(clazz) {
        var widget = new clazz();
        widget.setPlaceholder("abc");
        this.getRoot().add(widget); // set a value

        widget.setValue("def");
        this.assertEquals("def", widget.getValue(), "wrong value");
        this.assertEquals("def", this.__getVisibleValueOf(widget), "wrong visible value");
        this.assertFalse(this.__isPlaceholderVisible(widget)); // remove the value

        widget.resetValue(); // sync the appearance

        this.__syncAppearance(widget);

        this.assertNull(widget.getValue(), "wrong value");
        this.assertTrue(this.__isPlaceholderVisible(widget));
        this.assertEquals("abc", this.__getPlaceholderValueOf(widget), "wrong visible value"); // get rid of the widget

        widget.destroy();
      },
      __testFocus: function __testFocus(clazz) {
        var widget = new clazz();
        widget.setPlaceholder("abc");
        this.getRoot().add(widget); // test focus in

        widget.focus();
        this.flush();
        this.assertEquals("", this.__getVisibleValueOf(widget), "wrong visible value after focus");
        this.assertFalse(this.__isPlaceholderVisible(widget), "1"); // test focus out

        this.getRoot().focus();
        this.flush();
        window.setTimeout(function () {
          this.resume(function () {
            this.getRoot().focus();
            this.flush();
            this.assertTrue(this.__isPlaceholderVisible(widget), "2");
            this.assertEquals("abc", this.__getPlaceholderValueOf(widget), "wrong visible value after blur"); // get rid of the widget

            widget.destroy();
          }, this);
        }.bind(this), 500);
        this.wait();
      },
      __testRemovePlaceholder: function __testRemovePlaceholder(clazz) {
        var widget = new clazz();
        widget.setPlaceholder("abc");
        widget.setPlaceholder(null);
        this.assertFalse(this.__isPlaceholderVisible(widget));
        this.assertNull(widget.getValue(), "wrong value");
        this.assertEquals("", this.__getVisibleValueOf(widget), "wrong visible value after focus"); // get rid of the widget

        widget.destroy();
      },
      __testDisabled: function __testDisabled(clazz) {
        var widget = new clazz();
        this.getRoot().add(widget);
        widget.setPlaceholder("abc");
        widget.setEnabled(false);
        this.flush();
        this.assertNull(widget.getValue(), "wrong value");
        this.assertFalse(this.__isPlaceholderVisible(widget));
        this.assertEquals("", this.__getVisibleValueOf(widget), "wrong visible value");
        widget.setEnabled(true); // sync the appearance

        this.__syncAppearance(widget);

        this.assertNull(widget.getValue(), "wrong value");
        this.assertTrue(this.__isPlaceholderVisible(widget));
        this.assertEquals("abc", this.__getPlaceholderValueOf(widget), "wrong visible value"); // get rid of the widget

        widget.destroy();
      },
      __hasTextfieldChildControl: function __hasTextfieldChildControl(widget) {
        return qx.Class.isSubClassOf(widget.constructor, qx.ui.form.ComboBox) || qx.Class.isSubClassOf(widget.constructor, qx.ui.form.DateField);
      },
      __syncAppearance: function __syncAppearance(widget) {
        if (qx.Class.isSubClassOf(widget.constructor, qx.ui.form.AbstractField)) {
          widget.syncAppearance();
        } else if (this.__hasTextfieldChildControl(widget)) {
          widget.getChildControl("textfield").syncAppearance();
        }
      },
      __getVisibleValueOf: function __getVisibleValueOf(widget) {
        if (qx.Class.isSubClassOf(widget.constructor, qx.ui.form.AbstractField)) {
          return widget.getContentElement().getValue();
        } else if (this.__hasTextfieldChildControl(widget)) {
          return widget.getChildControl("textfield").getContentElement().getValue();
        }
      },
      __getPlaceholderValueOf: function __getPlaceholderValueOf(widget) {
        var useQxPlaceholder = !qx.core.Environment.get("css.placeholder");

        if (!useQxPlaceholder) {
          if (qx.Class.isSubClassOf(widget.constructor, qx.ui.form.AbstractField)) {
            return widget.getContentElement().getAttribute("placeholder");
          } else if (this.__hasTextfieldChildControl(widget)) {
            return widget.getChildControl("textfield").getContentElement().getAttribute("placeholder");
          }
        } else {
          if (qx.Class.isSubClassOf(widget.constructor, qx.ui.form.AbstractField)) {
            return widget._getPlaceholderElement().getValue();
          } else if (this.__hasTextfieldChildControl(widget)) {
            return widget.getChildControl("textfield")._getPlaceholderElement().getValue();
          }
        }
      },
      __isPlaceholderVisible: function __isPlaceholderVisible(widget) {
        var useQxPlaceholder = !qx.core.Environment.get("css.placeholder");

        if (!useQxPlaceholder) {
          var contentElem;

          if (qx.Class.isSubClassOf(widget.constructor, qx.ui.form.AbstractField)) {
            contentElem = widget.getContentElement();
            return (widget.getValue() == null || widget.getValue() == "") && contentElem.getAttribute("placeholder") != "" && contentElem.getAttribute("placeholder") != null && !qx.ui.core.FocusHandler.getInstance().isFocused(widget);
          } else if (this.__hasTextfieldChildControl(widget)) {
            contentElem = widget.getChildControl("textfield").getContentElement();
            return (widget.getChildControl("textfield").getValue() == null || widget.getChildControl("textfield").getValue() == "") && contentElem.getAttribute("placeholder") != "" && contentElem.getAttribute("placeholder") != null && !qx.ui.core.FocusHandler.getInstance().isFocused(widget);
          }
        } else {
          if (qx.Class.isSubClassOf(widget.constructor, qx.ui.form.AbstractField)) {
            return widget._getPlaceholderElement().getStyle("visibility") != "hidden";
          } else if (this.__hasTextfieldChildControl(widget)) {
            return widget.getChildControl("textfield")._getPlaceholderElement().getStyle("visibility") != "hidden";
          }
        }
      },
      /////////// TextField ///////////
      testInitTextField: function testInitTextField() {
        this.__testInit(qx.ui.form.TextField);
      },
      testChangeValueTextField: function testChangeValueTextField() {
        this.__testChangeValue(qx.ui.form.TextField);
      },
      testFocusTextField: function testFocusTextField() {
        this.__testFocus(qx.ui.form.TextField);
      },
      testRemovePlaceholderTextField: function testRemovePlaceholderTextField() {
        this.__testRemovePlaceholder(qx.ui.form.TextField);
      },
      testDisabledTextField: function testDisabledTextField() {
        this.__testDisabled(qx.ui.form.TextField);
      },
      /////////// TextArea ///////////
      testInitTextArea: function testInitTextArea() {
        this.__testInit(qx.ui.form.TextArea);
      },
      testChangeValueTextArea: function testChangeValueTextArea() {
        this.__testChangeValue(qx.ui.form.TextArea);
      },
      testFocusTextArea: function testFocusTextArea() {
        this.__testFocus(qx.ui.form.TextArea);
      },
      testRemovePlaceholderTextArea: function testRemovePlaceholderTextArea() {
        this.__testRemovePlaceholder(qx.ui.form.TextArea);
      },
      testDisabledTextArea: function testDisabledTextArea() {
        this.__testDisabled(qx.ui.form.TextArea);
      },
      /////////// PasswordField ///////////
      testInitPasswordField: function testInitPasswordField() {
        this.__testInit(qx.ui.form.PasswordField);
      },
      testChangeValuePasswordField: function testChangeValuePasswordField() {
        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9) {
          this.skip("Skipped in IE 8 until bug #8424 is fixed.");
        }

        this.__testChangeValue(qx.ui.form.PasswordField);
      },
      testFocusPasswordField: function testFocusPasswordField() {
        this.__testFocus(qx.ui.form.PasswordField);
      },
      testRemovePlaceholderPasswordField: function testRemovePlaceholderPasswordField() {
        this.__testRemovePlaceholder(qx.ui.form.PasswordField);
      },
      testDisabledPasswordField: function testDisabledPasswordField() {
        this.__testDisabled(qx.ui.form.PasswordField);
      },
      /////////// ComboBox ///////////
      testInitComboBox: function testInitComboBox() {
        this.__testInit(qx.ui.form.ComboBox);
      },
      testChangeValueComboBox: function testChangeValueComboBox() {
        this.__testChangeValue(qx.ui.form.ComboBox);
      },
      testFocusComboBox: function testFocusComboBox() {
        this.__testFocus(qx.ui.form.ComboBox);
      },
      testRemovePlaceholderComboBox: function testRemovePlaceholderComboBox() {
        this.__testRemovePlaceholder(qx.ui.form.ComboBox);
      },
      testDisabledComboBox: function testDisabledComboBox() {
        this.__testDisabled(qx.ui.form.ComboBox);
      },
      /////////// DateField ///////////
      testFocusDateField: function testFocusDateField() {
        this.__testFocus(qx.ui.form.DateField);
      },
      testRemovePlaceholderDateField: function testRemovePlaceholderDateField() {
        this.__testRemovePlaceholder(qx.ui.form.DateField);
      },
      testDisabledDateField: function testDisabledDateField() {
        this.__testDisabled(qx.ui.form.DateField);
      }
    }
  });
  qx.test.ui.form.Placeholder.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.RadioButtonGroup": {},
      "qx.ui.form.RadioButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
   qooxdoo - the new era of web development
  
   http://qooxdoo.org
  
   Copyright:
   2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
   License:
       MIT: https://opensource.org/licenses/MIT
   See the LICENSE file in the project's top-level directory for details.
  
   Authors:
   * Tobias Oberrauch <tobias.oberrauch@1und1.de>
  
   ************************************************************************ */
  qx.Class.define("qx.test.ui.form.RadioButtonGroup", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.__radioButtonGroup = new qx.ui.form.RadioButtonGroup();
        this.__radioButtons = [];
        var radioButton;

        for (var i = 0, j = 10; i < j; i++) {
          radioButton = new qx.ui.form.RadioButton("option " + i);
          radioButton.setModel("option" + i);

          this.__radioButtons.push(radioButton);

          this.__radioButtonGroup.add(radioButton);
        }
      },
      tearDown: function tearDown() {
        qx.test.ui.form.RadioButtonGroup.prototype.tearDown.base.call(this);

        this.__radioButtonGroup.removeAll();

        this.__radioButtons = null;
      },
      testRemoveAll: function testRemoveAll() {
        this.__radioButtonGroup.removeAll();

        var amountOfRadioButtons = this.__radioButtonGroup.getRadioGroup().getItems().length;

        this.assertEquals(0, amountOfRadioButtons, "There are still some radio buttons left.");
      }
    }
  });
  qx.test.ui.form.RadioButtonGroup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.RadioGroup": {},
      "qx.ui.form.RadioButton": {},
      "qx.ui.container.Composite": {},
      "qx.core.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.RadioGroup", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.__radioGroup = new qx.ui.form.RadioGroup();

        this.__radioGroup.setAllowEmptySelection(true);

        this.__radioButtons = [];
        var radioButton;

        for (var i = 0, j = 3; i < j; i++) {
          radioButton = new qx.ui.form.RadioButton("option " + i);
          radioButton.setModel("option" + i);

          this.__radioButtons.push(radioButton);

          this.__radioGroup.add(radioButton);
        }
      },
      tearDown: function tearDown() {
        qx.test.ui.form.RadioGroup.prototype.tearDown.base.call(this);
        var radioButton;

        for (var i = 0, j = this.__radioButtons.length; i < j; i++) {
          this.__radioGroup.remove(this.__radioButtons[i]);

          radioButton = this.__radioButtons.shift();
          radioButton.dispose();
        }

        this.__radioGroup.dispose();

        this.__radioButtons = null;
      },
      testHiddenRadioButtons: function testHiddenRadioButtons() {
        var composite = new qx.ui.container.Composite();

        for (var i = 0, j = this.__radioButtons.length; i < j; i++) {
          composite.add(this.__radioButtons[i]);
        }

        this.getRoot().add(composite, {
          left: 100,
          top: 50
        }); // check the 'modelSelection' with all radio buttons visible

        this.__radioGroup.setModelSelection([this.__radioButtons[1].getModel()]);

        this.assertEquals(this.__radioButtons[1].getModel(), this.__radioGroup.getModelSelection().getItem(0), "Model selection does not work correctly!");
        this.assertTrue(this.__radioGroup.isSelected(this.__radioButtons[1]), "Wrong radio button selected!"); // now hide the radio group and check if the selection change still works

        for (var i = 0, j = this.__radioButtons.length; i < j; i++) {
          this.__radioButtons[i].exclude();
        }

        this.__radioGroup.setModelSelection([this.__radioButtons[0].getModel()]);

        this.assertEquals(this.__radioButtons[0].getModel(), this.__radioGroup.getModelSelection().getItem(0), "Model selection does not work correctly!");
        this.assertTrue(this.__radioGroup.isSelected(this.__radioButtons[0]), "Hidden radio button not selected!");
        composite.destroy();
      },

      /**
       * @ignore(qx.test.ui.form.RadioGroupTest)
       */
      testAlteredGroupProperty: function testAlteredGroupProperty() {
        qx.Class.define("qx.test.ui.form.RadioGroupTest", {
          extend: qx.core.Object,
          properties: {
            locked: {
              init: false,
              check: "Boolean",
              event: "changeLocked",
              nullable: false
            },
            // set by the RadioGroup
            lockedGroup: {
              init: null,
              check: "qx.ui.form.RadioGroup",
              nullable: true
            }
          }
        });
        var rg;
        var testObj1, testObj2, testObj3;
        rg = new qx.ui.form.RadioGroup();
        rg.set({
          groupedProperty: "locked",
          groupProperty: "lockedGroup"
        });
        testObj1 = new qx.test.ui.form.RadioGroupTest();
        testObj2 = new qx.test.ui.form.RadioGroupTest();
        testObj3 = new qx.test.ui.form.RadioGroupTest(); // Add the test objects to the radio group. This should automatically
        // select the first one.

        rg.add(testObj1, testObj2, testObj3); // Ensure it did and the other ones are off

        this.assertTrue(testObj1.getLocked());
        this.assertFalse(testObj2.getLocked());
        this.assertFalse(testObj3.getLocked()); // Select the second one.

        rg.setSelection([testObj2]); // Ensure it's now on and the other ones are off

        this.assertTrue(testObj2.getLocked());
        this.assertFalse(testObj1.getLocked());
        this.assertFalse(testObj3.getLocked()); // Also ensure that the selection is as we expect

        this.assertEquals(rg.getSelection()[0], testObj2); // Clean up

        testObj1.dispose();
        testObj2.dispose();
        testObj3.dispose();
        qx.Class.undefine("qx.test.ui.form.RadioGroupTest");
      }
    }
  });
  qx.test.ui.form.RadioGroup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.Spinner": {},
      "qx.ui.form.Slider": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.Range", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __test: function __test(widget) {
        // min
        widget.setMinimum(10);
        this.assertEquals(10, widget.getMinimum(), "Set or get does not work. (min)");
        var self = this;
        this.assertEventFired(widget, "changeMinimum", function () {
          widget.setMinimum(11);
        }, function (e) {
          self.assertEquals(11, e.getData(), "Not the right number in the event.");
          self.assertEquals(10, e.getOldData(), "Wrong old data in the event.");
        }, "Event is wrong!"); // max

        widget.setMaximum(20);
        this.assertEquals(20, widget.getMaximum(), "Set or get does not work. (max)");
        var self = this;
        this.assertEventFired(widget, "changeMaximum", function () {
          widget.setMaximum(21);
        }, function (e) {
          self.assertEquals(21, e.getData(), "Not the right number in the event.");
          self.assertEquals(20, e.getOldData(), "Wrong old data in the event.");
        }, "Event is wrong!"); // singleStep

        widget.setSingleStep(2);
        this.assertEquals(2, widget.getSingleStep(), "Set or get does not work. (singleStep)"); // pageStep

        widget.setPageStep(11);
        this.assertEquals(11, widget.getPageStep(), "Set or get does not work. (pageStep)"); // get rid of the widget

        widget.destroy();
      },
      testSpinner: function testSpinner() {
        this.__test(new qx.ui.form.Spinner());
      },
      testSlider: function testSlider() {
        this.__test(new qx.ui.form.Slider());
      }
    }
  });
  qx.test.ui.form.Range.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.Form": {},
      "qx.ui.form.Button": {},
      "qx.ui.form.renderer.Single": {},
      "qx.ui.form.renderer.Double": {},
      "qx.ui.form.TextField": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.Renderer", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __form: null,
      __b: null,
      setUp: function setUp() {
        this.__form = new qx.ui.form.Form();
        this.__b = new qx.ui.form.Button("a");

        this.__form.addButton(this.__b);
      },
      tearDown: function tearDown() {
        this.__form.dispose();

        this.__b.dispose();
      },
      testDisposeSingle: function testDisposeSingle() {
        var renderer = new qx.ui.form.renderer.Single(this.__form);
        renderer.dispose(); // check if the button container has been disposed

        this.assertNull(renderer._buttonRow);
        this.assertNotNull(this.__b);
        this.assertFalse(this.__b.isDisposed());
      },
      testDisposeDouble: function testDisposeDouble() {
        var renderer = new qx.ui.form.renderer.Double(this.__form);
        renderer.dispose(); // check if the button container has been disposed

        this.assertNull(renderer._buttonRow);
        this.assertNotNull(this.__b);
        this.assertFalse(this.__b.isDisposed());
      },
      __testExclude: function __testExclude(clazz) {
        var text = new qx.ui.form.TextField();

        this.__form.add(text, "test");

        var renderer = new clazz(this.__form);

        var label = renderer._getChildren()[0];

        text.setVisibility("excluded");
        this.assertEquals(text.getVisibility(), label.getVisibility());
        renderer.dispose();
        text.dispose();
      },
      testExcludeSingle: function testExcludeSingle() {
        this.__testExclude(qx.ui.form.renderer.Single);
      },
      testExcludeDouble: function testExcludeDouble() {
        this.__testExclude(qx.ui.form.renderer.Double);
      },
      __testBindings: function __testBindings(clazz) {
        // after adding the text field get length of bindings for text field, label, form and renderer
        var text = new qx.ui.form.TextField();

        this.__form.add(text, "test");

        var renderer = new clazz(this.__form);

        var label = renderer._getChildren()[0]; // text field bindings


        this.assertEquals(2, text.getBindings().length, "Text field should have one binding!"); // label bindings

        this.assertEquals(2, label.getBindings().length, "Label should have one binding!"); // text field and label bindings must be equal

        this.assertTrue(qx.lang.Array.equals(text.getBindings(), label.getBindings()), "Text field and label bindings must be equal"); // dispose renderer must dispose text field, label and its self

        renderer.dispose();
        this.assertTrue(text.isDisposed(), "Disposing renderer should have disposed text field as well.");
        this.assertTrue(label.isDisposed(), "Disposing renderer should have disposed label as well.");
        this.assertTrue(renderer.isDisposed(), "Renderer must be disposed."); // text field bindings

        this.assertEquals(0, text.getBindings().length, "Still bindings there!"); // label bindings

        this.assertEquals(0, label.getBindings().length, "Still bindings there!");
      },
      testBindingsSingle: function testBindingsSingle() {
        this.__testBindings(qx.ui.form.renderer.Single);
      },
      testBindingsDouble: function testBindingsDouble() {
        this.__testBindings(qx.ui.form.renderer.Double);
      }
    }
  });
  qx.test.ui.form.Renderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.TextField": {},
      "qx.ui.form.Resetter": {},
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.ListItem": {},
      "qx.ui.form.Slider": {},
      "qx.ui.form.TextArea": {},
      "qx.ui.form.RadioButton": {},
      "qx.ui.form.List": {},
      "qx.data.Array": {},
      "qx.ui.form.VirtualSelectBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.Resetter", {
    extend: qx.test.ui.LayoutTestCase,
    construct: function construct() {
      qx.test.ui.LayoutTestCase.constructor.call(this);
    },
    members: {
      __username: null,
      __password1: null,
      __password2: null,
      __resetter: null,
      setUp: function setUp() {
        this.__username = new qx.ui.form.TextField();
        this.__password1 = new qx.ui.form.TextField();
        this.__password2 = new qx.ui.form.TextField();
        this.__resetter = new qx.ui.form.Resetter();
      },
      tearDown: function tearDown() {
        this.__resetter.dispose();

        this.__username.dispose();

        this.__password1.dispose();

        this.__password2.dispose();
      },
      testReset: function testReset() {
        // set the initial values
        this.__username.setValue("A");

        this.__password1.setValue("B");

        this.__password2.setValue("C"); // add the fields to the form manager


        this.__resetter.add(this.__username);

        this.__resetter.add(this.__password1);

        this.__resetter.add(this.__password2); // change the values of the fields


        this.__username.setValue("a");

        this.__password1.setValue("b");

        this.__password2.setValue("c"); // reset the manager


        this.__resetter.reset(); // check if the initial values are reset


        this.assertEquals("A", this.__username.getValue());
        this.assertEquals("B", this.__password1.getValue());
        this.assertEquals("C", this.__password2.getValue());
      },
      testRemove: function testRemove() {
        // set the initial values
        this.__username.setValue("A");

        this.__password1.setValue("B"); // add the fields to the form manager


        this.__resetter.add(this.__username);

        this.__resetter.add(this.__password1); // change the values of the fields


        this.__username.setValue("a");

        this.__password1.setValue("b"); // remove one item


        this.assertTrue(this.__resetter.remove(this.__password1)); // remove again to see that it has not been removed

        this.assertFalse(this.__resetter.remove(this.__password1)); // reset the manager

        this.__resetter.reset(); // check if the initial values are reset or kept


        this.assertEquals("A", this.__username.getValue());
        this.assertEquals("b", this.__password1.getValue());
      },
      testResetWithSelectBox: function testResetWithSelectBox() {
        var box = new qx.ui.form.SelectBox();
        var item1 = new qx.ui.form.ListItem("1");
        var item2 = new qx.ui.form.ListItem("2");
        box.add(item1);
        box.add(item2);
        box.setSelection([item2]); // check the initial selection

        this.assertEquals(item2, box.getSelection()[0], "1"); // add the box to the manager

        this.__resetter.add(box); // change the selection


        box.setSelection([item1]); // check the new selection

        this.assertEquals(item1, box.getSelection()[0], ""); // reset the manager

        this.__resetter.reset(); // check if the selection has been reseted


        this.assertEquals(item2, box.getSelection()[0], "3");
        item2.dispose();
        item1.dispose();
        box.dispose();
      },
      testDifferentWidgets: function testDifferentWidgets() {
        // set up
        var slider = new qx.ui.form.Slider();
        var textarea = new qx.ui.form.TextArea();
        var radiobutton = new qx.ui.form.RadioButton();
        var list = new qx.ui.form.List();
        var l1 = new qx.ui.form.ListItem("1");
        list.add(l1);
        var l2 = new qx.ui.form.ListItem("2");
        list.add(l2);
        var model = new qx.data.Array("a", "b", "c");
        var vsb = new qx.ui.form.VirtualSelectBox(model); // set the init values

        slider.setValue(22);
        textarea.setValue("aaa");
        radiobutton.setValue(false);
        list.setSelection([l2]);
        vsb.getSelection().setItem(0, "b"); // add the resetter

        this.__resetter.add(slider);

        this.__resetter.add(textarea);

        this.__resetter.add(radiobutton);

        this.__resetter.add(list);

        this.__resetter.add(vsb); // change the values


        slider.setValue(55);
        textarea.setValue("bbb");
        radiobutton.setValue(true);
        list.setSelection([l1]);
        vsb.getSelection().setItem(0, "c"); // reset

        this.__resetter.reset(); // check


        this.assertEquals(22, slider.getValue());
        this.assertEquals("aaa", textarea.getValue());
        this.assertEquals(false, radiobutton.getValue());
        this.assertEquals(l2, list.getSelection()[0]);
        this.assertEquals("b", vsb.getSelection().getItem(0)); // tear down

        list.dispose();
        radiobutton.dispose();
        textarea.dispose();
        slider.dispose();
        vsb.destroy();
        model.dispose();
      },
      testRedefine: function testRedefine() {
        // set the initial values
        this.__username.setValue("A");

        this.__password1.setValue("B");

        this.__password2.setValue("C"); // add the fields to the form manager


        this.__resetter.add(this.__username);

        this.__resetter.add(this.__password1);

        this.__resetter.add(this.__password2); // change the values of the fields


        this.__username.setValue("a");

        this.__password1.setValue("b");

        this.__password2.setValue("c"); // redefine the manager


        this.__resetter.redefine(); // change the values of the fields


        this.__username.setValue("aa");

        this.__password1.setValue("bb");

        this.__password2.setValue("cc"); // reset the manager


        this.__resetter.reset(); // check if the initial values are reset


        this.assertEquals("a", this.__username.getValue());
        this.assertEquals("b", this.__password1.getValue());
        this.assertEquals("c", this.__password2.getValue());
      },
      testRefineSelection: function testRefineSelection() {
        var box = new qx.ui.form.SelectBox();
        var item1 = new qx.ui.form.ListItem("1");
        var item2 = new qx.ui.form.ListItem("2");
        box.add(item1);
        box.add(item2);
        box.setSelection([item2]); // add the box to the manager

        this.__resetter.add(box); // change the selection


        box.setSelection([item1]); // check the new selection

        this.assertEquals(item1, box.getSelection()[0]); // redefine the manager

        this.__resetter.redefine(); // change the selection


        box.setSelection([item2]); // reset the manager

        this.__resetter.reset(); // check if the selection has been reseted


        this.assertEquals(item1, box.getSelection()[0]);
        item2.dispose();
        item1.dispose();
        box.dispose();
      },
      testResetOneItem: function testResetOneItem() {
        // set the initial values
        this.__username.setValue("A");

        this.__password1.setValue("B");

        this.__password2.setValue("C"); // add the fields to the form manager


        this.__resetter.add(this.__username);

        this.__resetter.add(this.__password1);

        this.__resetter.add(this.__password2); // change the values of the fields


        this.__username.setValue("a");

        this.__password1.setValue("b");

        this.__password2.setValue("c"); // reset the first two items


        this.__resetter.resetItem(this.__username);

        this.__resetter.resetItem(this.__password1); // check if the initial values are reset


        this.assertEquals("A", this.__username.getValue());
        this.assertEquals("B", this.__password1.getValue());
        this.assertEquals("c", this.__password2.getValue()); // check for a not added item

        var self = this;
        this.assertException(function () {
          self.__resetter.resetItem(this);
        }, Error);
      },
      testRedefineOneItem: function testRedefineOneItem() {
        // set the initial values
        this.__username.setValue("A");

        this.__password1.setValue("B");

        this.__password2.setValue("C"); // add the fields to the form manager


        this.__resetter.add(this.__username);

        this.__resetter.add(this.__password1);

        this.__resetter.add(this.__password2); // change the values of the fields


        this.__username.setValue("a");

        this.__password1.setValue("b");

        this.__password2.setValue("c"); // redefine the first two items


        this.__resetter.redefineItem(this.__username);

        this.__resetter.redefineItem(this.__password1); // change the first two items


        this.__username.setValue("1");

        this.__password1.setValue("2"); // reset the manager


        this.__resetter.reset(); // check if the initial values are reset


        this.assertEquals("a", this.__username.getValue());
        this.assertEquals("b", this.__password1.getValue());
        this.assertEquals("C", this.__password2.getValue()); // check for a not added item

        var self = this;
        this.assertException(function () {
          self.__resetter.redefineItem(this);
        }, Error);
      }
    }
  });
  qx.test.ui.form.Resetter.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.Slider": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.Slider", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.__slider = new qx.ui.form.Slider();

        this.__slider.setWidth(100);

        this.getRoot().add(this.__slider);
        this.flush();
      },
      tearDown: function tearDown() {
        this.__slider.destroy();
      },
      testKnobPositionAfterBlur: function testKnobPositionAfterBlur() {
        this.__slider.setValue(0);

        this.flush();

        var pos0 = this.__slider.getChildControl("knob").getContentElement().getStyle("left");

        this.__slider.setValue(30);

        this.flush();

        var pos30 = this.__slider.getChildControl("knob").getContentElement().getStyle("left");

        this.__slider.focus();

        this.flush();

        var posFocus = this.__slider.getChildControl("knob").getContentElement().getStyle("left");

        this.assertNotEquals(pos0, posFocus);
        this.assertEquals(pos30, posFocus);
      },
      testInitOrientation: function testInitOrientation() {
        var newSlider1 = new qx.ui.form.Slider();
        this.assertIdentical(newSlider1.getOrientation(), "horizontal");
        var newSlider2 = new qx.ui.form.Slider("horizontal");
        this.assertIdentical(newSlider2.getOrientation(), "horizontal");
        var newSlider3 = new qx.ui.form.Slider("vertical");
        this.assertIdentical(newSlider3.getOrientation(), "vertical");
      },
      testSlideMethods: function testSlideMethods() {
        var min = this.__slider.getMinimum();

        var max = this.__slider.getMaximum();

        this.__slider.slideToBegin();

        this.assertIdentical(this.__slider.getValue(), min);

        this.__slider.slideToEnd();

        this.assertIdentical(this.__slider.getValue(), max);

        var singleStep = this.__slider.getSingleStep();

        var before = this.__slider.getValue();

        this.__slider.slideForward();

        this.assertIdentical(this.__slider.getValue(), Math.min(before + singleStep, max));
        before = this.__slider.getValue();

        this.__slider.slideBack();

        this.assertIdentical(this.__slider.getValue(), Math.max(before - singleStep, min));

        var pageStep = this.__slider.getPageStep();

        before = this.__slider.getValue();

        this.__slider.slidePageForward();

        this.assertIdentical(this.__slider.getValue(), Math.min(before + pageStep, max));
        before = this.__slider.getValue();

        this.__slider.slidePageBack();

        this.assertIdentical(this.__slider.getValue(), Math.max(before - pageStep, min));
      }
    }
  });
  qx.test.ui.form.Slider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.form.Spinner": {},
      "qx.util.format.NumberFormat": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * William Oprandi (woprandi)
       * Tobias Oberrauch (toberrauch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.Spinner", {
    extend: qx.dev.unit.TestCase,
    members: {
      /**
       * Test if spinner use NumberFormat locale
       */
      testCorrectLocaleUsed: function testCorrectLocaleUsed() {
        var spinner = new qx.ui.form.Spinner(); // "de" locale has comma as decimal separator

        var nf = new qx.util.format.NumberFormat("de");
        spinner.setNumberFormat(nf);
        spinner.setValue(1.23);
        this.assertEquals("1,23", spinner.getChildControl("textfield").getValue());
        spinner.destroy();
        nf.dispose();
      },

      /**
       * Test if postfix is always set after textfield of the spinner has been edited
       */
      testPostfixIsAlwaysSet: function testPostfixIsAlwaysSet() {
        var spinner = new qx.ui.form.Spinner();
        spinner.set({
          maximum: 120,
          minimum: 1
        });
        var numberFormat = new qx.util.format.NumberFormat();
        numberFormat.setPostfix("min");
        spinner.setNumberFormat(numberFormat);
        var tf = spinner.getChildControl("textfield"); // Basic tests

        tf.setValue("113");
        this.assertEquals("113min", tf.getValue());
        tf.setValue("121");
        this.assertEquals("120min", tf.getValue()); // Check if postfix is added even if the spinner value won't change (value set to maximum)

        tf.setValue("122");
        this.assertEquals("120min", tf.getValue()); // Same for here (value set to minimum)

        tf.setValue("-67");
        this.assertEquals("1min", tf.getValue());
        tf.setValue("-99");
        this.assertEquals("1min", tf.getValue()); // And same here with a valid number

        tf.setValue("50");
        this.assertEquals("50min", tf.getValue());
        tf.setValue("50");
        this.assertEquals("50min", tf.getValue());
        spinner.destroy();
        numberFormat.dispose();
      }
    }
  });
  qx.test.ui.form.Spinner.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.util.format.IFormat": {
        "require": true
      },
      "qx.core.IDisposable": {
        "require": true
      },
      "qx.lang.Type": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.locale.Number": {},
      "qx.lang.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A formatter and parser for numbers.
   * 
   * NOTE: Instances of this class must be disposed of after use
   *
   */
  qx.Class.define("qx.util.format.NumberFormat", {
    extend: qx.core.Object,
    implement: [qx.util.format.IFormat, qx.core.IDisposable],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param locale {String} optional locale to be used
     * @throws {Error} If the argument is not a string.
     */
    construct: function construct(locale) {
      qx.core.Object.constructor.call(this);

      if (arguments.length > 0) {
        if (arguments.length === 1) {
          if (qx.lang.Type.isString(locale)) {
            this.setLocale(locale);
          } else {
            throw new Error("Wrong argument type. String is expected.");
          }
        } else {
          throw new Error("Wrong number of arguments.");
        }
      }

      if (!locale) {
        this.setLocale(qx.locale.Manager.getInstance().getLocale());
        {
          qx.locale.Manager.getInstance().bind("locale", this, "locale");
        }
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The minimum number of integer digits (digits before the decimal separator).
       * Missing digits will be filled up with 0 ("19" -> "0019").
       */
      minimumIntegerDigits: {
        check: "Number",
        init: 0
      },

      /**
       * The maximum number of integer digits (superfluous digits will be cut off
       * ("1923" -> "23").
       */
      maximumIntegerDigits: {
        check: "Number",
        nullable: true
      },

      /**
       * The minimum number of fraction digits (digits after the decimal separator).
       * Missing digits will be filled up with 0 ("1.5" -> "1.500")
       */
      minimumFractionDigits: {
        check: "Number",
        init: 0
      },

      /**
       * The maximum number of fraction digits (digits after the decimal separator).
       * Superfluous digits will cause rounding ("1.8277" -> "1.83")
       */
      maximumFractionDigits: {
        check: "Number",
        nullable: true
      },

      /** Whether thousand groupings should be used {e.g. "1,432,234.65"}. */
      groupingUsed: {
        check: "Boolean",
        init: true
      },

      /** The prefix to put before the number {"EUR " -> "EUR 12.31"}. */
      prefix: {
        check: "String",
        init: "",
        event: "changeNumberFormat"
      },

      /** Sets the postfix to put after the number {" %" -> "56.13 %"}. */
      postfix: {
        check: "String",
        init: "",
        event: "changeNumberFormat"
      },

      /** Locale used */
      locale: {
        check: "String",
        init: null,
        event: "changeLocale"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Formats a number.
       *
       * @param num {Number} the number to format.
       * @return {String} the formatted number as a string.
       */
      format: function format(num) {
        // handle special cases
        if (isNaN(num)) {
          return "NaN";
        }

        switch (num) {
          case Infinity:
            return "Infinity";

          case -Infinity:
            return "-Infinity";
        }

        var negative = num < 0;

        if (negative) {
          num = -num;
        }

        if (this.getMaximumFractionDigits() != null) {
          // Do the rounding
          var mover = Math.pow(10, this.getMaximumFractionDigits());
          num = Math.round(num * mover) / mover;
        }

        var integerDigits = String(Math.floor(num)).length;
        var numStr = "" + num; // Prepare the integer part

        var integerStr = numStr.substring(0, integerDigits);

        while (integerStr.length < this.getMinimumIntegerDigits()) {
          integerStr = "0" + integerStr;
        }

        if (this.getMaximumIntegerDigits() != null && integerStr.length > this.getMaximumIntegerDigits()) {
          // NOTE: We cut off even though we did rounding before, because there
          //     may be rounding errors ("12.24000000000001" -> "12.24")
          integerStr = integerStr.substring(integerStr.length - this.getMaximumIntegerDigits());
        } // Prepare the fraction part


        var fractionStr = numStr.substring(integerDigits + 1);

        while (fractionStr.length < this.getMinimumFractionDigits()) {
          fractionStr += "0";
        }

        if (this.getMaximumFractionDigits() != null && fractionStr.length > this.getMaximumFractionDigits()) {
          // We have already rounded -> Just cut off the rest
          fractionStr = fractionStr.substring(0, this.getMaximumFractionDigits());
        } // Add the thousand groupings


        if (this.getGroupingUsed()) {
          var origIntegerStr = integerStr;
          integerStr = "";
          var groupPos;

          for (groupPos = origIntegerStr.length; groupPos > 3; groupPos -= 3) {
            integerStr = "" + qx.locale.Number.getGroupSeparator(this.getLocale()) + origIntegerStr.substring(groupPos - 3, groupPos) + integerStr;
          }

          integerStr = origIntegerStr.substring(0, groupPos) + integerStr;
        } // Workaround: prefix and postfix are null even their defaultValue is "" and
        //             allowNull is set to false?!?


        var prefix = this.getPrefix() ? this.getPrefix() : "";
        var postfix = this.getPostfix() ? this.getPostfix() : ""; // Assemble the number

        var str = prefix + (negative ? "-" : "") + integerStr;

        if (fractionStr.length > 0) {
          str += "" + qx.locale.Number.getDecimalSeparator(this.getLocale()) + fractionStr;
        }

        str += postfix;
        return str;
      },

      /**
       * Parses a number.
       *
       * @param str {String} the string to parse.
       * @return {Double} the number.
       * @throws {Error} If the number string does not match the number format.
       */
      parse: function parse(str) {
        // use the escaped separators for regexp
        var groupSepEsc = qx.lang.String.escapeRegexpChars(qx.locale.Number.getGroupSeparator(this.getLocale()) + "");
        var decimalSepEsc = qx.lang.String.escapeRegexpChars(qx.locale.Number.getDecimalSeparator(this.getLocale()) + "");
        var regex = new RegExp("^(" + qx.lang.String.escapeRegexpChars(this.getPrefix()) + ')?([-+]){0,1}' + '([0-9]{1,3}(?:' + groupSepEsc + '{0,1}[0-9]{3}){0,}){0,1}' + '(' + decimalSepEsc + '\\d+){0,1}(' + qx.lang.String.escapeRegexpChars(this.getPostfix()) + ")?$");
        var hit = regex.exec(str);

        if (hit == null) {
          throw new Error("Number string '" + str + "' does not match the number format");
        } // hit[1] = potential prefix


        var negative = hit[2] == "-";
        var integerStr = hit[3] || "0";
        var fractionStr = hit[4]; // hit[5] = potential postfix
        // Remove the thousand groupings

        integerStr = integerStr.replace(new RegExp(groupSepEsc, "g"), "");
        var asStr = (negative ? "-" : "") + integerStr;

        if (fractionStr != null && fractionStr.length != 0) {
          // Remove the leading decimal separator from the fractions string
          fractionStr = fractionStr.replace(new RegExp(decimalSepEsc), "");
          asStr += "." + fractionStr;
        }

        return parseFloat(asStr);
      }
    },
    destruct: function destruct() {
      {
        qx.locale.Manager.getInstance().removeRelatedBindings(this);
      }
    }
  });
  qx.util.format.NumberFormat.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.SplitButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.SplitButton", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this._split = new qx.ui.form.SplitButton();
        this.getRoot().add(this._split);
      },
      tearDown: function tearDown() {
        this._split.destroy();

        this.flush();
      },
      testArrowAvailable: function testArrowAvailable() {
        this._split.setIcon("qx/icon/Oxygen/22/emotes/face-smile.png");

        var arrow = this._split.getChildControl("arrow").getChildControl("icon");

        var icon = this._split.getChildControl("button").getChildControl("icon");

        this.flush(); // check initial values

        this.assertTrue(arrow.isVisible(), "init arrow");
        this.assertTrue(icon.isVisible(), "init icon");

        this._split.setShow("label");

        this.flush(); // check changed values

        this.assertTrue(arrow.isVisible(), "changed arrow");
        this.assertFalse(icon.isVisible(), "changed icon");
      }
    }
  });
  qx.test.ui.form.SplitButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.IStringForm": {},
      "qx.ui.form.TextField": {},
      "qx.ui.form.PasswordField": {},
      "qx.ui.form.TextArea": {},
      "qx.ui.form.ComboBox": {},
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.StringFormat", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __test: function __test(widget) {
        // check if the interface is implemented
        this.assertTrue(qx.Class.hasInterface(widget.constructor, qx.ui.form.IStringForm), "Interface is not implemented."); // check for the init value

        this.assertNull(widget.getValue(), "Wrong init value set."); // just check if the method is available

        widget.resetValue(); // check the getter and setter

        widget.setValue("affe");
        this.assertEquals("affe", widget.getValue(), "Set or get does not work.");
        var self = this; // event with value

        this.assertEventFired(widget, "changeValue", function () {
          widget.setValue("affen");
        }, function (e) {
          self.assertEquals("affen", e.getData(), "Not the right number in the event.");
          self.assertEquals("affe", e.getOldData(), "Wrong old data in the event.");
        }, "Event is wrong!"); // event with null

        this.assertEventFired(widget, "changeValue", function () {
          widget.setValue(null);
        }, function (e) {
          self.assertEquals(null, e.getData(), "Not the right number in the event.");
          self.assertEquals("affen", e.getOldData(), "Wrong old data in the event.");
        }, "Event is wrong!"); // get rid of the widget

        widget.destroy();
      },
      testTextField: function testTextField() {
        this.__test(new qx.ui.form.TextField());
      },
      testPasswordField: function testPasswordField() {
        this.__test(new qx.ui.form.PasswordField());
      },
      testTextArea: function testTextArea() {
        this.__test(new qx.ui.form.TextArea());
      },
      testComboBox: function testComboBox() {
        this.__test(new qx.ui.form.ComboBox());
      },
      testLabel: function testLabel() {
        this.__test(new qx.ui.basic.Label());
      }
    }
  });
  qx.test.ui.form.StringFormat.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.ui.form.TextArea": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.type.Array": {},
      "qx.dev.unit.RequirementError": {},
      "qx.ui.core.queue.Dispose": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.TextArea", {
    extend: qx.test.ui.LayoutTestCase,
    include: qx.dev.unit.MRequirements,
    members: {
      __textArea: null,
      setUp: function setUp() {
        var textArea = this.__textArea = new qx.ui.form.TextArea();
        this.getRoot().add(textArea);
      },
      hasNoBuggyIe: function hasNoBuggyIe() {
        return qx.core.Environment.get("engine.name") != "mshtml" || qx.core.Environment.get("browser.documentmode") > 10;
      },
      //
      // "Plain" textarea
      //
      "test: textarea set value": function testTextareaSetValue() {
        var textArea = this.__textArea;
        textArea.setValue("Affe");
        this.flush();
        this.assertEquals("Affe", textArea.getValue());
      },
      "test: textarea set minimal line-height": function testTextareaSetMinimalLineHeight() {
        var textArea = this.__textArea;
        this.flush();
        var heightInitial = textArea.getSizeHint().height;
        textArea.setMinimalLineHeight(1);
        this.flush();
        var heightSmall = textArea.getSizeHint().height;
        var msg = "Widget height must decrease (was: " + heightInitial + " is: " + heightSmall + ")";
        this.assert(heightSmall < heightInitial, msg);
      },
      //
      // Auto-Size
      //
      "test: textarea with autoSize grows when input would trigger scrollbar": function testTextareaWithAutoSizeGrowsWhenInputWouldTriggerScrollbar() {
        this.require(["noBuggyIe"]);

        var textArea = this.__textArea;
        textArea.setAutoSize(true);
        this.flush();
        textArea.setValue("Affe\nMaus\nElefant");
        this.flush();
        var heightSmall = textArea.getSizeHint().height; // Grow

        textArea.setValue("Affe\nMaus\nElefant\nGiraffe\nTiger");
        this.flush();
        var heightTall = textArea.getSizeHint().height;
        var msg = "Widget height must increase (was: " + heightSmall + " is: " + heightTall + ")";
        this.assert(heightTall > heightSmall, msg);
      },
      "test: textarea with autoSize shrinks when removal would hide scrollbar": function testTextareaWithAutoSizeShrinksWhenRemovalWouldHideScrollbar() {
        this.require(["noBuggyIe"]);

        var textArea = this.__textArea;
        textArea.setAutoSize(true);
        this.flush();
        textArea.setValue("Affe\nMaus\nElefant");
        this.flush(); // Grow

        textArea.setValue("Affe\nMaus\nElefant\nGiraffe\nTiger");
        this.flush();
        var heightTall = textArea.getSizeHint().height; // Shrink

        textArea.setValue("Affe\nMaus\nElefant");
        this.flush();
        var heightShrink = textArea.getSizeHint().height;
        var msg = "Widget height must decrease (was: " + heightTall + " is: " + heightShrink + ")";
        this.assert(heightShrink < heightTall, msg);
      },
      "test: textarea with autoSize does not shrink below original height": function testTextareaWithAutoSizeDoesNotShrinkBelowOriginalHeight() {
        this.require(["noBuggyIe"]);

        var textArea = this.__textArea;
        textArea.setAutoSize(true);
        this.flush();
        var originalHeight = textArea.getBounds().height;
        textArea.setValue("Affe\nMaus\nElefant\nGiraffe\nTiger");
        this.flush(); // Shrink

        textArea.setValue("Affe\nMaus\nElefant");
        var heightShrink = textArea.getSizeHint().height;
        this.flush();
        var msg = "Widget height must not shrink below original height (is: " + heightShrink + " original: " + originalHeight + ")";
        this.assert(!(heightShrink < originalHeight), msg);
      },
      "test: textarea with autoSize shows scroll-bar when above maxHeight": function testTextareaWithAutoSizeShowsScrollBarWhenAboveMaxHeight() {
        this.require(["noBuggyIe"]);

        var textArea = this.__textArea;
        textArea.set({
          autoSize: true,
          maxHeight: 50,
          value: "Affe\nMaus\nElefant"
        });
        this.flush(); // Grow

        textArea.setValue("Affe\nMaus\nElefant\nGiraffe\nTiger");
        this.flush();
        var overflow = textArea.getContentElement().getStyle("overflowY");
        this.assertEquals("auto", overflow);
      },
      "test: textarea with autoSize shows scroll-bar when finally above maxHeight": function testTextareaWithAutoSizeShowsScrollBarWhenFinallyAboveMaxHeight() {
        this.require(["noBuggyIe"]);

        var textArea = this.__textArea;
        textArea.set({
          autoSize: true,
          value: "Affe\nMaus\nElefant"
        });
        this.flush(); // Grow

        textArea.setValue("Affe\nMaus\nElefant\nGiraffe\nTiger");
        this.flush(); // Limit height

        textArea.setMaxHeight(50);
        this.flush();
        var overflow = textArea.getContentElement().getStyle("overflowY");
        this.assertEquals("auto", overflow);
      },
      "test: textarea with autoSize hides scroll-bar when finally below maxHeight": function testTextareaWithAutoSizeHidesScrollBarWhenFinallyBelowMaxHeight() {
        this.require(["noBuggyIe"]);

        var textArea = this.__textArea;
        textArea.set({
          autoSize: true,
          maxHeight: 50
        });
        this.flush(); // Grow

        textArea.setValue("Affe\nMaus\nElefant\nGiraffe\nTiger");
        this.flush(); // Shrink

        textArea.setValue("Affe");
        this.flush();
        var overflow = textArea.getContentElement().getStyle("overflowY");
        this.assertEquals("hidden", overflow);
      },
      "test: textarea with autoSize respects initial value": function testTextareaWithAutoSizeRespectsInitialValue() {
        this.require(["noBuggyIe"]);

        var textArea = this.__textArea;
        textArea.set({
          autoSize: true,
          value: this.__getLongValue()
        });
        var textAreaNoValue = new qx.ui.form.TextArea();
        textAreaNoValue.set({
          autoSize: true,
          value: ""
        });
        this.getRoot().add(textAreaNoValue, {
          left: 100
        });
        this.flush();
        var heightValue = textArea.getBounds().height;
        var heightNoValue = textAreaNoValue.getBounds().height;
        var msg = "Must be higher with long value than without value";
        this.assert(heightValue > heightNoValue, msg);
        textAreaNoValue.destroy();
      },
      "test: textarea with autoSize respects initial wrap": function testTextareaWithAutoSizeRespectsInitialWrap() {
        this.require(["noBuggyIe"]);

        var textArea = this.__textArea;
        textArea.set({
          autoSize: true,
          wrap: false,
          minimalLineHeight: 2,
          value: this.__getLongValue()
        }); // No wrap

        this.flush();
        var heightInitial = textArea.getBounds().height; // Wrap

        textArea.setWrap(true);
        this.flush(); // No wrap

        textArea.setWrap(false);
        this.flush();
        var heightFinal = textArea.getBounds().height;
        this.assertEquals(heightInitial, heightFinal);
      },
      "test: textarea with autoSize shrinks when long line is unwrapped": function testTextareaWithAutoSizeShrinksWhenLongLineIsUnwrapped() {
        this.require(["noBuggyIe"]);

        if (!this.__supportsLiveWrap()) {
          this.skip();
        }

        var textArea = this.__textArea;
        textArea.setAutoSize(true);
        this.flush(); // Grow

        var longValue = this.__getLongValue();

        textArea.setValue(longValue);
        this.flush();
        var wrapHeight = textArea.getSizeHint().height; // Shrink

        textArea.setWrap(false);
        this.flush();
        var noWrapHeight = textArea.getSizeHint().height;
        var msg = "Must shrink when long line is unwrapped";
        this.assertNotEquals(wrapHeight, noWrapHeight, msg);
        this.assert(noWrapHeight < wrapHeight, msg);
      },
      "test: textarea with autoSize grows when long line is wrapped": function testTextareaWithAutoSizeGrowsWhenLongLineIsWrapped() {
        this.require(["noBuggyIe"]);

        if (!this.__supportsLiveWrap()) {
          this.skip();
        }

        var textArea = this.__textArea;
        textArea.set({
          autoSize: true,
          wrap: true
        });
        this.flush(); // Does not work unfortunately
        //
        // var longValue = new qx.type.Array(50).map(function() {
        //   return "AffeMausElefantGiraffeTiger";
        // }).join("");

        var longValue = this.__getLongValue(); // Wrap


        textArea.setValue(longValue);
        this.flush();
        var initialWrapHeight = textArea.getSizeHint().height; // Unwrap

        textArea.setWrap(false);
        this.flush();
        var noWrapHeight = textArea.getSizeHint().height; // Wrap

        textArea.setWrap(true);
        this.flush();
        var wrapHeight = textArea.getSizeHint().height;
        var msg = "Must grow when long line is unwrapped";
        this.assertNotEquals(wrapHeight, noWrapHeight, msg);
        this.assert(wrapHeight > noWrapHeight, msg);
        msg = "Must be same height when wrap is toggled";
        this.assertEquals(initialWrapHeight, wrapHeight, msg);
      },
      __getLongValue: function __getLongValue() {
        var val = new qx.type.Array(50);

        for (var i = 0; i < val.length; i++) {
          val[i] = "AAAAA ";
        }

        return val.join("");
      },
      __supportsLiveWrap: function __supportsLiveWrap() {
        // Opera ignores changes to wrap settings
        // once the textarea is in the DOM
        return qx.core.Environment.get("engine.name") != "opera";
      },
      skip: function skip(msg) {
        throw new qx.dev.unit.RequirementError(null, msg);
      },
      tearDown: function tearDown() {
        qx.test.ui.form.TextArea.prototype.tearDown.base.call(this);

        this.__textArea.destroy();

        qx.ui.core.queue.Dispose.flush();
      }
    }
  });
  qx.test.ui.form.TextArea.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.TextField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Henner Kollmann
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.TextField", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.__field = new qx.ui.form.TextField();
        this.getRoot().add(this.__field);
      },
      tearDown: function tearDown() {
        this.__field.destroy();

        this.__field = null;
        qx.test.ui.form.TextField.prototype.tearDown.base.call(this);
      },
      "test: get default length": function testGetDefaultLength() {
        var l = this.__field.getMaxLength();

        this.assertEquals(Infinity, l);
      },
      "test: set max length": function testSetMaxLength() {
        this.__field.setMaxLength(4);

        var l = this.__field.getMaxLength();

        this.assertEquals(4, l);
      },
      "test: reset max length": function testResetMaxLength() {
        this.__field.setMaxLength(4);

        var l = this.__field.getMaxLength();

        this.assertEquals(4, l);

        this.__field.resetMaxLength();

        var l = this.__field.getMaxLength();

        this.assertEquals(Infinity, l);
      },
      "test: validate input with filter": function testValidateInputWithFilter() {
        this.__field.setFilter(/[0-9]/);

        var s = this.__field._validateInput("a");

        this.assertEquals("", s);

        var s = this.__field._validateInput("111");

        this.assertEquals("111", s);
      },
      "test: validate input with complex filter": function testValidateInputWithComplexFilter() {
        this.__field.setFilter(/^(\+|-)?\d*$/);

        var s = this.__field._validateInput("a");

        this.assertEquals("", s);

        var s = this.__field._validateInput("1");

        this.assertEquals("1", s);

        var s = this.__field._validateInput("-");

        this.assertEquals("-", s);

        var s = this.__field._validateInput("111");

        this.assertEquals("111", s);

        var s = this.__field._validateInput("-111");

        this.assertEquals("-111", s);

        var s = this.__field._validateInput("-11-1");

        this.assertEquals("", s);
      },
      "test: validate input with complex filter 2": function testValidateInputWithComplexFilter2() {
        this.__field.setFilter(/^xy$/);

        var s = this.__field._validateInput("x? y?");

        this.assertEquals("", s);
      },
      __field: null
    }
  });
  qx.test.ui.form.TextField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.ToggleButton": {},
      "qx.event.type.Event": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.ToggleButton", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __button: null,
      setUp: function setUp() {
        var button = this.__button = new qx.ui.form.ToggleButton();
        this.getRoot().add(button);
        this.flush();
      },
      //
      // 2-state button
      //
      testInitial: function testInitial() {
        var button = this.__button;
        this.assertNotState(button, "checked");
      },
      testCheck: function testCheck() {
        var button = this.__button;
        button.setValue(true);
        this.assertState(button, "checked");
      },
      testUncheck: function testUncheck() {
        var button = this.__button;
        button.setValue(false);
        this.assertNotState(button, "checked");
      },
      //
      // 3-state button
      //
      testImplicitCheckTri: function testImplicitCheckTri() {
        var button = this.__button;
        button.setTriState(true);
        button.setValue(null); // [x] checked
        // [v] undetermined

        this.assertNotState(button, "checked");
        this.assertState(button, "undetermined");
      },
      testImplicitCheckTriLater: function testImplicitCheckTriLater() {
        var button = this.__button;
        button.setValue(null);
        button.setTriState(true); // [x] checked
        // [v] undetermined

        this.assertNotState(button, "checked");
        this.assertState(button, "undetermined");
      },
      testCheckTri: function testCheckTri() {
        var button = this.__button;
        button.setTriState(true);
        button.setValue(null);
        button.setValue(true); // [v] checked
        // [x] undetermined

        this.assertState(button, "checked");
        this.assertNotState(button, "undetermined");
      },
      testUncheckTri: function testUncheckTri() {
        var button = this.__button;
        button.setTriState(true);
        button.setValue(null);
        button.setValue(false); // [x] checked
        // [x] undetermined

        this.assertNotState(button, "checked");
        this.assertNotState(button, "undetermined");
      },
      //
      // Helper methods
      //
      assertState: function assertState(widget, state) {
        this.assertTrue(widget.hasState(state), "State " + state + " not set");
      },
      assertNotState: function assertNotState(widget, state) {
        this.assertFalse(widget.hasState(state), "State " + state + " is set");
      },
      executeOn: function executeOn(widget) {
        var that = this;
        window.setTimeout(function () {
          that.immediateExecuteOn(widget);
        });
      },
      immediateExecuteOn: function immediateExecuteOn(widget) {
        widget.fireEvent("execute", qx.event.type.Event, [false, true]);
      },
      tearDown: function tearDown() {
        qx.test.ui.form.ToggleButton.prototype.tearDown.base.call(this);

        this.__button.destroy();
      }
    }
  });
  qx.test.ui.form.ToggleButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.VirtualSelectBox": {},
      "qx.data.marshal.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Martijn Evers, The Netherlands
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martijn Evers (mever)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.VirtualSelectBox", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.__selectBox = new qx.ui.form.VirtualSelectBox();
        this.getRoot().add(this.__selectBox);
        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.form.VirtualSelectBox.prototype.tearDown.base.call(this);

        this.__selectBox.destroy();

        this.__selectBox = null;
      },
      __simulateUiInteraction: function __simulateUiInteraction() {
        // focus -> array key down -> array key down -> enter
        this.__selectBox.getSelection().setItem(0, this.__selectBox.getModel().getItem(1));
      },
      testChangeValueEvent: function testChangeValueEvent() {
        var m = qx.data.marshal.Json.createModel(["a", "b"]);

        this.__selectBox.addListenerOnce("changeValue", function (e) {
          this.assertIdentical("a", e.getData());
          this.assertNull(e.getOldData());
        }.bind(this));

        this.__selectBox.setModel(m);

        this.__selectBox.addListenerOnce("changeValue", function (e) {
          this.assertIdentical("b", e.getData());
          this.assertIdentical("a", e.getOldData());
        }.bind(this));

        this.__simulateUiInteraction();
      },
      testChangeModelWhileNotVisible: function testChangeModelWhileNotVisible() {
        "use strict";

        var selectBox = new qx.ui.form.VirtualSelectBox(); // We don't want to use a selectbox that has been added to a layout item.

        selectBox.setLabelPath('b');
        var items = qx.data.marshal.Json.createModel([{
          a: 123,
          b: 'item 1'
        }, {
          a: 456,
          b: 'item 2'
        }]);
        items.setAutoDisposeItems(true);
        selectBox.setModel(items);

        try {
          items.pop();
        } catch (e) {
          this.assertTrue(false, "Changing the model should not cause an exception in VirtualDropDownList#_getAvailableHeight");
        }

        items.dispose();
      },
      "test dropdown list same width as selectbox": function testDropdownListSameWidthAsSelectbox() {
        "use strict";

        var test = this;
        var m = qx.data.marshal.Json.createModel(["asdddddddddddddddddddddddddddddddddddddddddddddddddddd", "dsaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]);

        this.__selectBox.setAllowGrowDropDown(false);

        this.__selectBox.setModel(m);

        this.__selectBox.setWidth(150);

        this.__selectBox.open();

        this.flush();
        setTimeout(function () {
          test.assertIdentical(test.__selectBox.getWidth(), test.__selectBox.getBounds().width);
          test.assertIdentical(test.__selectBox.getWidth(), test.__selectBox.getChildControl('dropdown').getBounds().width);
          test.resume();
        }, 10);
        this.wait();
      },
      "test dropdown list wider than selectbox": function testDropdownListWiderThanSelectbox() {
        "use strict";

        var test = this;
        var m = qx.data.marshal.Json.createModel(["asddddddddddddddddddddddddddddddddddddddddddddddddddddasddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd", "dsaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]);

        this.__selectBox.setAllowGrowDropDown(true);

        this.__selectBox.setModel(m);

        this.__selectBox.setWidth(150);

        this.__selectBox.open();

        this.flush();
        setTimeout(function () {
          test.assertIdentical(test.__selectBox.getWidth(), test.__selectBox.getBounds().width);
          test.assertTrue(test.__selectBox.getChildControl('dropdown').getBounds().width > 666, "dropdown could not fit the whole item");
          test.resume();
        }, 10);
        this.wait();
      }
    }
  });
  qx.test.ui.form.VirtualSelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.VirtualComboBox": {},
      "qx.data.Array": {},
      "qx.data.marshal.Json": {},
      "qx.lang.String": {},
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.virtual.VirtualComboBox", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __comboBox: null,
      __model: null,
      setUp: function setUp() {
        qx.test.ui.form.virtual.VirtualComboBox.prototype.setUp.base.call(this);
        this.__comboBox = new qx.ui.form.VirtualComboBox();
        this.getRoot().add(this.__comboBox);
        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.form.virtual.VirtualComboBox.prototype.tearDown.base.call(this);

        this.__comboBox.destroy();

        this.__comboBox = null;

        this.__model.dispose();

        this.flush();
      },
      __createSimpleModel: function __createSimpleModel() {
        var model = new qx.data.Array();

        for (var i = 0; i < 100; i++) {
          model.push("item " + (i + 1));
        }

        return model;
      },
      __createRichModel: function __createRichModel() {
        var model = new qx.data.Array();

        for (var i = 0; i < 100; i++) {
          model.push("<b>item " + (i + 1) + "</b>");
        }

        return model;
      },
      __createNestedModel: function __createNestedModel() {
        var rawData = [{
          firstname: "James",
          lastname: "Kirk"
        }, {
          firstname: "Jean-Luc",
          lastname: "Picard"
        }, {
          firstname: "Benjamin",
          lastname: "Sisko"
        }];
        var model = qx.data.marshal.Json.createModel(rawData);
        return model;
      },
      testPreselectOnOpen: function testPreselectOnOpen() {
        this.__model = this.__createSimpleModel();

        this.__comboBox.setModel(this.__model);

        this.__comboBox.setValue("i");

        this.flush();

        this.__comboBox.open();

        this.flush();

        this.__comboBox.close();

        this.flush(); // Preselection may not change the actual value

        this.assertNotEquals("item 1", this.__comboBox.getValue());
        this.assertEquals("i", this.__comboBox.getValue());
      },
      testSelectFirstMatch: function testSelectFirstMatch() {
        this.__model = this.__createSimpleModel();

        this.__comboBox.setModel(this.__model);

        this.__comboBox.setValue("item 4");

        this.flush();

        this.__comboBox.open();

        this.flush();

        var preselected = this.__comboBox.getChildControl("dropdown")._preselected;

        this.assertEquals("item 4", preselected);
        this.assertEquals("item 4", this.__comboBox.getValue());
      },
      testSelectFirstMatchWithSortedModel: function testSelectFirstMatchWithSortedModel() {
        this.__model = this.__createSimpleModel();

        this.__comboBox.setModel(this.__model);

        var delegate = {
          // invert sort order
          sorter: function sorter(a, b) {
            return a < b ? 1 : a > b ? -1 : 0;
          }
        };

        this.__comboBox.setDelegate(delegate);

        this.__comboBox.setValue("item 4");

        this.flush();

        this.__comboBox.open();

        this.flush();

        var preselected = this.__comboBox.getChildControl("dropdown")._preselected;

        this.assertEquals("item 49", preselected);
        this.assertEquals("item 4", this.__comboBox.getValue()); // The virtual list uses a timeout to asynchronously flush the layout
        // queue and scroll the (pre)selected item into view. tearDown is called
        // before this timer's callback so the list container tries to scroll a
        // disposed widget which causes an exception. To get around this, we use
        // a timeout to delay the tearDown call.

        var that = this;
        window.setTimeout(function () {
          that.resume();
        }, 100);
        this.wait(200);
      },
      testSelectFirstMatchWithFilteredModel: function testSelectFirstMatchWithFilteredModel() {
        this.__model = this.__createSimpleModel();

        this.__comboBox.setModel(this.__model);

        var delegate = {
          // remove even-numbered items
          filter: function filter(item) {
            var num = parseInt(/([0-9]+)/.exec(item)[1], 10);
            return num % 2 ? true : false;
          }
        };

        this.__comboBox.setDelegate(delegate);

        this.__comboBox.setValue("item 22");

        this.flush();

        this.__comboBox.open();

        this.flush(); // item 22 is not in the list, nothing should be preselected

        var preselected = this.__comboBox.getChildControl("dropdown")._preselected;

        this.assertNull(preselected);
        this.assertEquals("item 22", this.__comboBox.getValue());
      },
      testSelectFirstMatchWithFormatter: function testSelectFirstMatchWithFormatter() {
        this.__model = this.__createRichModel();

        this.__comboBox.setModel(this.__model);

        var delegate = {
          configureItem: function configureItem(item) {
            item.setRich(true);
          }
        };

        this.__comboBox.setDelegate(delegate);

        this.__comboBox.setDefaultFormat(function (data) {
          if (data) {
            data = qx.lang.String.stripTags(data);
            data = qx.bom.String.unescape(data);
          }

          return data;
        });

        this.__comboBox.setValue("item 4");

        this.flush();

        this.__comboBox.open();

        this.flush();

        var preselected = this.__comboBox.getChildControl("dropdown")._preselected;

        this.assertEquals("<b>item 4</b>", preselected);
        this.assertEquals("item 4", this.__comboBox.getValue());
      },
      testSelectFirstMatchByLabelPath: function testSelectFirstMatchByLabelPath() {
        this.__model = this.__createNestedModel();

        this.__comboBox.setLabelPath("lastname");

        this.__comboBox.setModel(this.__model);

        this.__comboBox.setValue("Si");

        this.flush();

        this.__comboBox.open();

        this.flush();

        var preselected = this.__comboBox.getChildControl("dropdown")._preselected.getLastname();

        this.assertEquals("Sisko", preselected);
        this.assertEquals("Si", this.__comboBox.getValue());
      },
      testEmptySelection: function testEmptySelection() {
        this.__comboBox.setLabelPath("label");

        var rawData = [{
          label: "foo"
        }];
        var model = this.__model = qx.data.marshal.Json.createModel(rawData);

        this.__comboBox.setModel(model);

        var selection = this.__comboBox.getChildControl("dropdown").getSelection();

        selection.push(this.__comboBox.getModel().getItem(0));
        selection.removeAll();
      },
      testOpenWithUnrenderedWidget: function testOpenWithUnrenderedWidget() {
        var cb = new qx.ui.form.VirtualComboBox();
        cb.open();
        this.getRoot().add(cb);
      }
    }
  });
  qx.test.ui.form.virtual.VirtualComboBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Mixin.define("qx.test.ui.list.MAssert", {
    members: {
      assertModelEqualsRowData: function assertModelEqualsRowData(model, list) {
        for (var i = 0; i < model.getLength(); i++) {
          this.assertIdentical(model.getItem(i), list._getDataFromRow(i));
        }
      },
      assertDataArrayEquals: function assertDataArrayEquals(expected, value) {
        this.assertIdentical(expected.getLength(), value.getLength(), "The length of both arrays are not equal!");

        for (var i = 0; i < expected.getLength(); i++) {
          this.assertTrue(value.contains(expected.getItem(i)), "The array doesn't contain item '" + expected.getItem(i) + "'");
        }
      }
    }
  });
  qx.test.ui.list.MAssert.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "construct": true,
        "require": true
      },
      "qx.test.ui.list.MAssert": {
        "require": true
      },
      "qx.ui.form.core.AbstractVirtualBox": {},
      "qx.ui.form.core.VirtualDropDownList": {},
      "qx.ui.core.Widget": {},
      "qx.data.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * @ignore(qx.ui.form.core.AbstractVirtualBoxMock)
   */
  qx.Class.define("qx.test.ui.form.virtual.VirtualDropDownList", {
    extend: qx.test.ui.LayoutTestCase,
    include: qx.test.ui.list.MAssert,
    construct: function construct() {
      qx.test.ui.LayoutTestCase.constructor.call(this);
      qx.Class.define("qx.ui.form.core.AbstractVirtualBoxMock", {
        extend: qx.ui.form.core.AbstractVirtualBox,
        members: {
          _addBindings: function _addBindings() {},
          _removeBindings: function _removeBindings() {}
        }
      });
    },
    members: {
      __target: null,
      __dropdown: null,
      __model: null,
      setUp: function setUp() {
        qx.test.ui.form.virtual.VirtualDropDownList.prototype.setUp.base.call(this);
        this.__target = new qx.ui.form.core.AbstractVirtualBoxMock();
        this.__dropdown = new qx.ui.form.core.VirtualDropDownList(this.__target);
        this.__model = this.__createModelData();

        this.__dropdown.getChildControl("list").setModel(this.__model);

        this.getRoot().add(this.__target);
      },
      tearDown: function tearDown() {
        qx.test.ui.form.virtual.VirtualDropDownList.prototype.tearDown.base.call(this);

        this.__target.destroy();

        this.__dropdown.destroy();

        this.__target = null;
        this.__dropdown = null;

        this.__model.dispose();

        this.__model = null;
      },
      testException: function testException() {
        this.assertException(function () {
          new qx.ui.form.core.VirtualDropDownList();
        }, Error, "Invalid parameter 'target'!");
        this.assertException(function () {
          new qx.ui.form.core.VirtualDropDownList(null);
        }, Error, "Invalid parameter 'target'!");
        var widget = new qx.ui.core.Widget();
        this.assertException(function () {
          new qx.ui.form.core.VirtualDropDownList(widget);
        }, Error, "Invalid parameter 'target'!");
        widget.dispose();
      },
      testCreation: function testCreation() {
        var model = this.__model;

        var listModel = this.__dropdown.getChildControl("list").getModel();

        this.assertEquals(model, listModel, "Model instance not equals!");

        this.__testCreation(model);
      },
      testCreationWithSorter: function testCreationWithSorter() {
        var sortedModel = this.__applySortingAndReturnSortedModel();

        this.__testCreation(sortedModel);

        sortedModel.dispose();
      },
      testCreationWithFilter: function testCreationWithFilter() {
        var filteredModel = this.__applyFilterAndReturnFilteredModel();

        this.__testCreation(filteredModel);

        filteredModel.dispose();
      },
      __testCreation: function __testCreation(model) {
        var list = this.__dropdown.getChildControl("list");

        this.assertModelEqualsRowData(model, list);

        this.__checkSelection(model.getItem(0));
      },
      testSelection: function testSelection() {
        this.__testSelection(this.__model);
      },
      testSelectionWithSorter: function testSelectionWithSorter() {
        var sortedModel = this.__applySortingAndReturnSortedModel();

        this.__testSelection(sortedModel);

        sortedModel.dispose();
      },
      testSelectionWithFilter: function testSelectionWithFilter() {
        var filteredModel = this.__applyFilterAndReturnFilteredModel();

        this.__testCreation(filteredModel);

        var model = this.__model;

        var selection = this.__dropdown.getSelection();

        var invalidItem = model.getItem(2);
        this.assertFalse(filteredModel.contains(invalidItem));
        var that = this;

        this.__checkEvent(selection, function () {
          selection.push(invalidItem);
        }, 2);

        this.__checkSelection(filteredModel.getItem(0));

        filteredModel.dispose();
      },
      __testSelection: function __testSelection(model) {
        var selection = this.__dropdown.getSelection();

        var that = this;
        var newItem = model.getItem(2);

        this.__checkEvent(selection, function () {
          selection.push(newItem);
        }, 2);

        this.__checkSelection(newItem);

        var that = this;
        newItem = model.getItem(4);

        this.__checkEvent(selection, function () {
          selection.splice(0, 1, newItem).dispose();
        }, 1);

        this.__checkSelection(newItem);
      },
      __createModelData: function __createModelData() {
        var model = new qx.data.Array();

        for (var i = 0; i < 100; i++) {
          model.push("item " + i);
        }

        return model;
      },
      __checkSelection: function __checkSelection(item) {
        this.assertTrue(this.__model.contains(item), "The itme '" + item + "' is not in the model!");

        var modelIndex = this.__model.indexOf(item);

        var selection = this.__dropdown.getSelection();

        var listSelection = this.__dropdown.getChildControl("list").getSelection();

        this.assertEquals(1, selection.getLength(), "Selection length not equals!");
        this.assertEquals(this.__model.getItem(modelIndex), selection.getItem(0), "Selection instance not equals!");
        this.assertEquals(selection.getLength(), listSelection.getLength(), "Selection length not equals with list selection length!");
        this.assertEquals(selection.getItem(0), listSelection.getItem(0), "Selection instance not equals with list selection instance!");
      },
      __checkEvent: function __checkEvent(target, callback, fired) {
        var count = 0;
        this.assertEventFired(target, "change", callback, function () {
          count++;
        });
        this.assertEquals(fired, count, "The event is not fired the expected times!");
      },
      __applySortingAndReturnSortedModel: function __applySortingAndReturnSortedModel() {
        var sorter = function sorter(a, b) {
          return a < b ? 1 : a > b ? -1 : 0;
        };

        this.__dropdown.getChildControl("list").setDelegate({
          sorter: sorter
        });

        var sortedModel = this.__model.copy();

        sortedModel.sort(sorter);
        return sortedModel;
      },
      __applyFilterAndReturnFilteredModel: function __applyFilterAndReturnFilteredModel() {
        var filter = function filter(data) {
          // Filters all even items
          return parseInt(data.slice(5, data.length), 10) % 2 == 1;
        };

        this.__dropdown.getChildControl("list").setDelegate({
          filter: filter
        });

        var filteredModel = new qx.data.Array();

        for (var i = 0; i < this.__model.getLength(); i++) {
          var item = this.__model.getItem(i);

          if (filter(item)) {
            filteredModel.push(item);
          }
        }

        return filteredModel;
      }
    },
    destruct: function destruct() {
      qx.Class.undefine("qx.ui.form.core.AbstractVirtualBoxMock");
    }
  });
  qx.test.ui.form.virtual.VirtualDropDownList.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.VirtualSelectBox": {},
      "qx.data.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.form.virtual.VirtualSelectBox", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __selectBox: null,
      setUp: function setUp() {
        qx.test.ui.form.virtual.VirtualSelectBox.prototype.setUp.base.call(this);
        this.__model = this.__createModelData();
        this.__selectBox = new qx.ui.form.VirtualSelectBox(this.__model);
        this.getRoot().add(this.__selectBox);
        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.form.virtual.VirtualSelectBox.prototype.tearDown.base.call(this);

        this.__selectBox.destroy();

        this.__selectBox = null;

        this.__model.dispose();

        this.__model = null;
      },
      __createModelData: function __createModelData() {
        var model = new qx.data.Array();

        for (var i = 0; i < 100; i++) {
          model.push("item " + (i + 1));
        }

        return model;
      },
      testCreation: function testCreation() {
        this.assertEquals(this.__model.getLength(), this.__selectBox.getModel().getLength(), "Model length not equals!");
        this.assertEquals(this.__model, this.__selectBox.getModel(), "Model instance not equals!");
        this.assertEquals(this.__model, this.__selectBox.getChildControl("dropdown").getChildControl("list").getModel(), "Model instance on list not equals!");
        this.assertEquals(1, this.__selectBox.getSelection().getLength(), "Selection length not equals!");
        this.assertEquals(this.__model.getItem(0), this.__selectBox.getSelection().getItem(0), "Selection instance not equals!");
      }
    }
  });
  qx.test.ui.form.virtual.VirtualSelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.groupbox.CheckGroupBox": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2018 The Qooxdoo Project
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.groupbox.CheckGroupBox", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      _checkGroupBox: null,
      _label: null,
      setUp: function setUp() {
        qx.test.ui.groupbox.CheckGroupBox.prototype.setUp.base.call(this);
        var groupBox = this._checkGroupBox = new qx.ui.groupbox.CheckGroupBox();
        this.getRoot().add(groupBox);
        groupBox.setLayout(new qx.ui.layout.HBox());
        this._label = new qx.ui.basic.Label();
        groupBox.add(this._label);
        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.groupbox.CheckGroupBox.prototype.tearDown.base.call(this);

        this._disposeObjects("_checkGroupBox");
      },

      /**
       * Tests whether 'enabled' is in consistent state for both groupbox content widgets
       * and groupbox parent, i.e. after groupbox legend is unchecked and then checked
       * again, disabling groupbox parent must disable groupbox content widgets (see [1]).
       * 1. https://github.com/qooxdoo/qooxdoo/issues/9350
       */
      testEnabledConsistencyBetweenContentAndParent: function testEnabledConsistencyBetweenContentAndParent() {
        this.assertTrue(this._checkGroupBox.isEnabled());
        this.assertTrue(this._label.isEnabled()); // Uncheck/check legend

        this._checkGroupBox.setValue(false);

        this.assertFalse(this._label.isEnabled());

        this._checkGroupBox.setValue(true);

        this.assertTrue(this._label.isEnabled()); // Disable parent, content label must switch to disabled

        this._checkGroupBox.getLayoutParent().setEnabled(false);

        this.assertFalse(this._checkGroupBox.isEnabled());
        this.assertFalse(this._label.isEnabled()); // Enable parent, content label must switch to enabled

        this._checkGroupBox.getLayoutParent().setEnabled(true);

        this.assertTrue(this._checkGroupBox.isEnabled());
        this.assertTrue(this._label.isEnabled());
      }
    }
  });
  qx.test.ui.groupbox.CheckGroupBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.indicator.ProgressBar": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.indicator.ProgressBar", {
    extend: qx.dev.unit.TestCase,
    members: {
      __pb: null,
      tearDown: function tearDown() {
        this.__pb.destroy();
      },
      testConstructor: function testConstructor() {
        //defaults
        var val = 0,
            max = 100;
        this.__pb = new qx.ui.indicator.ProgressBar();
        this.assertIdentical(val, this.__pb.getValue());
        this.assertIdentical(max, this.__pb.getMaximum()); //value

        val = 10;

        this.__pb.dispose();

        this.__pb = new qx.ui.indicator.ProgressBar(val);
        this.assertIdentical(val, this.__pb.getValue());
        this.assertIdentical(max, this.__pb.getMaximum()); //value, max

        max = 120;

        this.__pb.dispose();

        this.__pb = new qx.ui.indicator.ProgressBar(val, max);
        this.assertIdentical(val, this.__pb.getValue());
        this.assertIdentical(max, this.__pb.getMaximum()); //limit value to max

        this.__pb.dispose();

        this.__pb = new qx.ui.indicator.ProgressBar(1200, 1000);
        this.assertIdentical(1000, this.__pb.getValue());
        this.assertIdentical(1000, this.__pb.getMaximum());
      },
      testValue: function testValue() {
        var val = 20;
        this.__pb = new qx.ui.indicator.ProgressBar(); //returns exactly what was set

        this.assertIdentical(val, this.__pb.setValue(val));
        this.assertIdentical(val, this.__pb.getValue());
      },
      testLimitValueToZero: function testLimitValueToZero() {
        this.__pb = new qx.ui.indicator.ProgressBar();

        this.__pb.setValue(-20);

        this.assertIdentical(0, this.__pb.getValue());
      },
      testLimitValueToMaximum: function testLimitValueToMaximum() {
        this.__pb = new qx.ui.indicator.ProgressBar();

        this.__pb.setValue(this.__pb.getMaximum() + 1);

        this.assertIdentical(this.__pb.getMaximum(), this.__pb.getValue());
      },
      testMaximum: function testMaximum() {
        var max = 200;
        this.__pb = new qx.ui.indicator.ProgressBar(); //returns exactly what was set

        this.assertIdentical(max, this.__pb.setMaximum(max));
        this.assertIdentical(max, this.__pb.getMaximum());
      },
      testDoNothingIfMaximumIsSetToZero: function testDoNothingIfMaximumIsSetToZero() {
        this.__pb = new qx.ui.indicator.ProgressBar();

        this.__pb.setMaximum(0); //default is 100


        this.assertIdentical(100, this.__pb.getMaximum());
      },
      testLimitMaximumToValue: function testLimitMaximumToValue() {
        var val = 20;
        this.__pb = new qx.ui.indicator.ProgressBar();

        this.__pb.setValue(val);

        this.__pb.setMaximum(val - 1);

        this.assertIdentical(val, this.__pb.getMaximum());
      },
      testChangeEvent: function testChangeEvent() {
        var that = this,
            val = 10;
        this.__pb = new qx.ui.indicator.ProgressBar();
        this.assertEventFired(this.__pb, "change", function () {
          that.__pb.setValue(val);
        }, function (e) {
          that.assertIdentical(0, e.getOldData());
          that.assertIdentical(val, e.getData());
        }, "event not fired.");
      },
      testCompleteEvent: function testCompleteEvent() {
        var that = this,
            max = this.__pb.getMaximum();

        this.__pb = new qx.ui.indicator.ProgressBar();
        this.assertEventFired(this.__pb, "complete", function () {
          that.__pb.setValue(max);
        }, null, "event not fired.");
        max = 200;

        this.__pb.dispose();

        this.__pb = new qx.ui.indicator.ProgressBar(0, max);
        this.assertEventFired(this.__pb, "complete", function () {
          that.__pb.setValue(max);
        }, null, "event not fired.");
      },
      testCompleteEventFiresOnTime: function testCompleteEventFiresOnTime() {
        var that = this,
            max = 200;
        this.__pb = new qx.ui.indicator.ProgressBar(0, max);
        this.assertEventNotFired(this.__pb, "complete", function () {
          that.__pb.setValue(max - 1);
        }, null, "event fired.");
        this.assertEventFired(this.__pb, "complete", function () {
          that.__pb.setValue(max);
        }, null, "event not fired.");
      }
    }
  });
  qx.test.ui.indicator.ProgressBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.lang.Type": {},
      "qx.ui.layout.Canvas": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2015 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */

  /**
   * The Progress bar is designed to simply display the current % complete
   * for a process.
   *
   * The Value is limited between 0 and Maximum value.
   * It's not allowed to set a Maximum value of 0.  If you set a Maximum value
   * bigger than 0, but smaller than Value, it will be limited to Value.
   *
   * The following example creates and adds a progress bar to the root element.
   * A listener is used to show the user if the value is changed,
   * and another one when the progress is complete.
   *
   * <pre class='javascript'>
   * var pb = new qx.ui.indicator.ProgressBar();
   * this.getRoot().add(pb, { left : 20, top: 20});
   *
   * pb.addListener("change", function(e) {
   *   this.debug(e.getData()); // % complete
   *   this.debug(pb.getValue()); // absolute value
   * });
   *
   * pb.addListener("complete", function(e) {
   *   this.debug("complete");
   * });
   *
   * //set a value
   * pb.setValue(20);
   * </pre>
   *
   * @childControl progress {qx.ui.container.Composite} The progress bar
   */
  qx.Class.define("qx.ui.indicator.ProgressBar", {
    extend: qx.ui.container.Composite,

    /**
     * @param value {Number ? 0} Progress bar value
     * @param maximum {Number ? 100} Progress bar maximum value
     */
    construct: function construct(value, maximum) {
      qx.ui.container.Composite.constructor.call(this);

      this._createChildControl("progress");

      this.setLayout(new qx.ui.layout.HBox());

      if (maximum != null) {
        this.setMaximum(maximum);
      }

      if (value != null) {
        this.setValue(value);
      }
    },
    properties: {
      appearance: {
        refine: true,
        init: "progressbar"
      },

      /** Maximum value of the progress bar */
      maximum: {
        init: 100,
        event: "changeMaximum",
        apply: "_applyMaximum"
      },

      /** Current value of the progress bar */
      value: {
        init: 0,
        event: "changeValue",
        apply: "_applyValue"
      }
    },
    events: {
      /**
       * Fired when the process is complete (value === maximum value)
       */
      complete: "qx.event.type.Event",

      /**
       * Fired when the % complete value is changed.
       */
      change: "qx.event.type.Data"
    },
    members: {
      // property apply
      _applyValue: function _applyValue(value, old) {
        var max = this.getMaximum(); //do nothing if is not a number

        if (!qx.lang.Type.isNumber(value) || !isFinite(value)) {
          value = old;
        }

        if (value < 0) {
          // limit value to 0
          value = 0;
        } else if (value > max) {
          // limit value to max
          value = max;
        } //set value


        this.setValue(value); //update progress

        this._changeProgress(value / max);
      },
      // property apply
      _applyMaximum: function _applyMaximum(value, old) {
        var max = value;
        var val = this.getValue(); //do nothing if is not a number, is negative or zero

        if (!qx.lang.Type.isNumber(max) || !isFinite(max) || max <= 0) {
          max = old;
        } //limit max to a greater than 0 value


        if (max < val) {
          max = val;
        } //set max


        this.setMaximum(max); //update progress

        this._changeProgress(val / max);
      },
      //overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "progress":
            control = new qx.ui.container.Composite(new qx.ui.layout.Canvas());

            this._add(control, {
              width: "0%"
            });

            break;
        }

        return control || qx.ui.indicator.ProgressBar.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Update the progress bar.
       *
       * @param value {Number} future value of progress bar
       */
      _changeProgress: function _changeProgress(value) {
        var bar = this.getChildControl("progress");
        var to = Math.floor(value * 100);
        var from = parseInt(bar.getLayoutProperties().width, 10);
        bar.setLayoutProperties({
          width: to + "%"
        }); //fire change event

        if (to != from) {
          this.fireDataEvent("change", to, from);
        } //fire complete event if 100% complete


        if (to === 100) {
          this.fireEvent("complete");
        }
      }
    }
  });
  qx.ui.indicator.ProgressBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.test.ui.layout.LayoutRoot": {},
      "qx.ui.container.Composite": {},
      "qx.ui.core.Widget": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.layout.VBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.layout.Box", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        qx.test.ui.layout.Box.prototype.setUp.base.call(this);
        this.root = new qx.test.ui.layout.LayoutRoot();
      },
      tearDown: function tearDown() {
        qx.test.ui.layout.Box.prototype.tearDown.base.call(this);
        this.root.dispose();
      },
      __testExclude: function __testExclude(layout, test) {
        // composite
        var comp = new qx.ui.container.Composite();
        comp.setBackgroundColor("#AA0000");
        comp.setLayout(layout);
        this.getRoot().add(comp, {
          edge: 0
        }); // first excluded, not flex child

        var c1 = new qx.ui.core.Widget();
        c1.setBackgroundColor("#662222");
        c1.exclude();
        comp.add(c1); // second child: flex and visible

        var c2 = new qx.ui.core.Widget();
        c2.setBackgroundColor("#FF6666");
        comp.add(c2, {
          flex: 1
        }); // flush and show the first child

        this.flush();
        c1.show(); // flush again to render it

        this.flush();

        if (test == "height") {
          var computedHeight = parseInt(c1.getContentElement().getStyle("height"), 10);
          var height = c1.getSizeHint().height;
          this.assertEquals(height, computedHeight, "height");
        } else if (test == "width") {
          var computedWidth = parseInt(c1.getContentElement().getStyle("width"), 10);
          var width = c1.getSizeHint().width;
          this.assertEquals(width, computedWidth, "width");
        }

        comp.destroy();
      },
      testExcludeHBox: function testExcludeHBox() {
        var layout = new qx.ui.layout.HBox();

        this.__testExclude(layout, "width");

        layout.dispose();
      },
      testExcludeVBox: function testExcludeVBox() {
        var layout = new qx.ui.layout.VBox();

        this.__testExclude(layout, "height");

        layout.dispose();
      }
    }
  });
  qx.test.ui.layout.Box.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.LayoutItem": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.queue.Layout": {},
      "qx.ui.core.queue.Visibility": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.layout.LayoutItem", {
    extend: qx.ui.core.LayoutItem,
    construct: function construct(width, height) {
      qx.ui.core.LayoutItem.constructor.call(this);

      if (width !== undefined) {
        this.setWidth(width);
      }

      if (height !== undefined) {
        this.setHeight(height);
      }

      this.bounds = {};
    },
    properties: {
      visibility: {
        check: ["visible", "hidden", "excluded"],
        init: "visible",
        apply: "_applyVisibility",
        event: "changeVisibility"
      }
    },
    members: {
      bounds: null,
      __layout: null,
      __children: null,
      renderLayout: function renderLayout(left, top, width, height) {
        var changes = qx.test.ui.layout.LayoutItem.prototype.renderLayout.base.call(this, left, top, width, height);

        if (!changes) {
          return;
        }

        this.bounds = {
          left: left,
          top: top,
          width: width,
          height: height
        };

        if (changes.size || changes.local || changes.margin) {
          if (this.__layout && this.getLayoutChildren().length > 0) {
            this.__layout.renderLayout(width, height, {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            });
          }
        }

        return changes;
      },
      setLayout: function setLayout(layout) {
        layout.connectToWidget(this);
        qx.ui.core.queue.Layout.add(this);
        this.__layout = layout;
      },
      _getLayout: function _getLayout() {
        return this.__layout;
      },
      // overridden
      invalidateLayoutCache: function invalidateLayoutCache() {
        qx.test.ui.layout.LayoutItem.prototype.invalidateLayoutCache.base.call(this);

        if (this.__layout) {
          this.__layout.invalidateLayoutCache();
        }
      },
      invalidateLayoutChildren: function invalidateLayoutChildren() {
        var layout = this.__layout;

        if (layout) {
          layout.invalidateChildrenCache();
        }

        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyVisibility: function _applyVisibility(value, old) {
        // only force a layout update if visibility change from/to "exclude"
        var parent = this.$$parent;

        if (parent && (old == null || value == null || old === "excluded" || value === "excluded")) {
          parent.invalidateLayoutChildren();
        } // Update visibility cache


        qx.ui.core.queue.Visibility.add(this);
      },
      _getContentHint: function _getContentHint() {
        if (this.__layout && this.getLayoutChildren().length > 0) {
          return this.__layout.getSizeHint();
        } else {
          return {
            width: 0,
            height: 0
          };
        }
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        // Start with the user defined values
        var width = this.getWidth();
        var minWidth = this.getMinWidth();
        var maxWidth = this.getMaxWidth();
        var height = this.getHeight();
        var minHeight = this.getMinHeight();
        var maxHeight = this.getMaxHeight(); // Ask content

        var contentHint = this._getContentHint();

        if (width == null) {
          width = contentHint.width;
        }

        if (height == null) {
          height = contentHint.height;
        }

        if (minWidth == null) {
          if (contentHint.minWidth != null) {
            minWidth = contentHint.minWidth;
          }
        }

        if (minHeight == null) {
          if (contentHint.minHeight != null) {
            minHeight = contentHint.minHeight;
          }
        }

        if (maxWidth == null) {
          if (contentHint.maxWidth == null) {
            maxWidth = Infinity;
          } else {
            maxWidth = contentHint.maxWidth;
          }
        }

        if (maxHeight == null) {
          if (contentHint.maxHeight == null) {
            maxHeight = Infinity;
          } else {
            maxHeight = contentHint.maxHeight;
          }
        }

        return {
          width: width,
          minWidth: minWidth,
          maxWidth: maxWidth,
          height: height,
          minHeight: minHeight,
          maxHeight: maxHeight
        };
      },
      add: function add(child, options) {
        if (!this.__children) {
          this.__children = [];
        }

        this.__children.push(child);

        this.__layout.invalidateChildrenCache();

        if (options) {
          child.setLayoutProperties(options);
        } else {
          this.updateLayoutProperties();
        }

        child.setLayoutParent(this);
        qx.ui.core.queue.Layout.add(this);
      },
      remove: function remove(child) {
        if (!this.__children) {
          this.__children = [];
        }

        qx.lang.Array.remove(this.__children, child); // Clear parent connection

        child.setLayoutParent(null); // clear the layout's children cache

        if (this.__layout) {
          this.__layout.invalidateChildrenCache();
        } // Add to layout queue


        qx.ui.core.queue.Layout.add(this);
      },
      getLayoutChildren: function getLayoutChildren() {
        var children = this.__children || [];
        var layoutChildren = [];

        for (var i = 0; i < children.length; i++) {
          var child = children[i];

          if (child.getVisibility() !== "excluded") {
            layoutChildren.push(child);
          }
        }

        return layoutChildren;
      },
      checkAppearanceNeeds: function checkAppearanceNeeds() {},
      // copied from qx.ui.core.Widget
      addChildrenToQueue: function addChildrenToQueue(queue) {
        var children = this.__children;

        if (!children) {
          return;
        }

        var child;

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];
          queue.push(child);
          child.addChildrenToQueue(queue);
        }
      }
    },
    destruct: function destruct() {
      this.bounds = this.__layout = this.__children = null;
    }
  });
  qx.test.ui.layout.LayoutItem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.layout.LayoutItem": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Basic": {
        "construct": true
      },
      "qx.ui.core.queue.Visibility": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.layout.LayoutRoot", {
    extend: qx.test.ui.layout.LayoutItem,
    construct: function construct() {
      qx.test.ui.layout.LayoutItem.constructor.call(this, 10000, 10000);
      this.setLayout(new qx.ui.layout.Basic());
      qx.ui.core.queue.Visibility.add(this);
    },
    members: {
      isRootWidget: function isRootWidget() {
        return true;
      }
    },
    destruct: function destruct() {
      this._getLayout().dispose();
    }
  });
  qx.test.ui.layout.LayoutRoot.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.ui.layout.LayoutRoot": {},
      "qx.ui.core.queue.Manager": {},
      "qx.test.ui.layout.LayoutItem": {},
      "qx.ui.layout.Flow": {},
      "qx.ui.layout.HBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.layout.Flow", {
    extend: qx.dev.unit.TestCase,
    members: {
      _container: null,
      setUp: function setUp() {
        this.root = new qx.test.ui.layout.LayoutRoot();
        this.flush();
      },
      tearDown: function tearDown() {
        this.root.dispose();

        var children = this._container.getLayoutChildren();

        for (var i = 0, l = children.length; i < l; i++) {
          this._container.remove(children[i]);

          children[i].dispose();
        }

        this.root.remove(this._container);

        this._container._getLayout().dispose();

        this._container.dispose();
      },
      flush: function flush() {
        qx.ui.core.queue.Manager.flush();
      },
      // test for bug #6818
      testChangeThemeFromFlow: function testChangeThemeFromFlow() {
        var c1 = new qx.test.ui.layout.LayoutItem(100, 50);
        this._container = new qx.test.ui.layout.LayoutItem(200, 200);

        this._container.setLayout(new qx.ui.layout.Flow());

        this._container.add(c1);

        this.root.add(this._container); // change the theme should not throw an exception

        this._container.setLayout(new qx.ui.layout.HBox());
      },
      testChildrenFitInLine: function testChildrenFitInLine() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(400, 50).set({
          layout: layout
        });
        this.root.add(container);
        var c1 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c1);
        var c2 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c2);
        var c3 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c3);
        this.flush();
        this.assertJsonEquals({
          left: 0,
          top: 0,
          width: 100,
          height: 50
        }, c1.bounds);
        this.assertJsonEquals({
          left: 100,
          top: 0,
          width: 100,
          height: 50
        }, c2.bounds);
        this.assertJsonEquals({
          left: 200,
          top: 0,
          width: 100,
          height: 50
        }, c3.bounds);
      },
      testAutoSize: function testAutoSize() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(null, null).set({
          layout: layout
        });
        this.root.add(container);
        container.add(new qx.test.ui.layout.LayoutItem(100, 50));
        container.add(new qx.test.ui.layout.LayoutItem(100, 50));
        container.add(new qx.test.ui.layout.LayoutItem(100, 50));
        this.flush();
        this.assertJsonEquals({
          left: 0,
          top: 0,
          width: 300,
          height: 50
        }, container.bounds); // resize first

        container.getLayoutChildren()[0].setHeight(60);
        this.flush();
        this.assertEquals(60, container.bounds.height);
        this.assertEquals(60, container.getLayoutChildren()[0].bounds.height);
        this.assertEquals(50, container.getLayoutChildren()[1].bounds.height);
      },
      testWrapThirdChild: function testWrapThirdChild() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(250, 300).set({
          layout: layout
        });
        this.root.add(container);
        container.add(new qx.test.ui.layout.LayoutItem(100, 50));
        container.add(new qx.test.ui.layout.LayoutItem(100, 50));
        container.add(new qx.test.ui.layout.LayoutItem(100, 50));
        this.flush();
        var children = container.getLayoutChildren();
        this.assertEquals(0, children[0].bounds.top);
        this.assertEquals(0, children[0].bounds.left);
        this.assertEquals(0, children[1].bounds.top);
        this.assertEquals(100, children[1].bounds.left);
        this.assertEquals(50, children[2].bounds.top);
        this.assertEquals(0, children[2].bounds.left);
      },
      testAlignX: function testAlignX() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(500, 300).set({
          layout: layout
        });
        this.root.add(container);
        container.add(new qx.test.ui.layout.LayoutItem(100, 50));
        container.add(new qx.test.ui.layout.LayoutItem(100, 50));
        container.add(new qx.test.ui.layout.LayoutItem(100, 50));
        layout.setAlignX("left");
        this.flush();
        var children = container.getLayoutChildren();
        this.assertEquals(0, children[0].bounds.left, "align left");
        this.assertEquals(100, children[1].bounds.left, "align left");
        this.assertEquals(200, children[2].bounds.left, "align left");
        layout.setAlignX("right");
        this.flush();
        var children = container.getLayoutChildren();
        this.assertEquals(200, children[0].bounds.left, "align right");
        this.assertEquals(300, children[1].bounds.left, "align right");
        this.assertEquals(400, children[2].bounds.left, "align right");
        layout.setAlignX("center");
        this.flush();
        var children = container.getLayoutChildren();
        this.assertEquals(100, children[0].bounds.left, "align center");
        this.assertEquals(200, children[1].bounds.left, "align center");
        this.assertEquals(300, children[2].bounds.left, "align center");
      },
      testAlignXWithWrapping: function testAlignXWithWrapping() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(80, 300).set({
          layout: layout
        });
        this.root.add(container);
        container.add(new qx.test.ui.layout.LayoutItem(50, 50));
        container.add(new qx.test.ui.layout.LayoutItem(60, 50));
        container.add(new qx.test.ui.layout.LayoutItem(70, 50));
        layout.setAlignX("right");
        this.flush();
        var children = container.getLayoutChildren();
        this.assertEquals(30, children[0].bounds.left, "align right");
        this.assertEquals(20, children[1].bounds.left, "align right");
        this.assertEquals(10, children[2].bounds.left, "align right");
        layout.setAlignX("center");
        this.flush();
        var children = container.getLayoutChildren();
        this.assertEquals(15, children[0].bounds.left);
        this.assertEquals(10, children[1].bounds.left);
        this.assertEquals(5, children[2].bounds.left);
      },
      testLayoutAlignY: function testLayoutAlignY() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(null, null).set({
          layout: layout
        });
        this.root.add(container);
        container.add(new qx.test.ui.layout.LayoutItem(100, 60));
        container.add(new qx.test.ui.layout.LayoutItem(100, 100));
        container.add(new qx.test.ui.layout.LayoutItem(100, 40)); // reference

        container.add(new qx.test.ui.layout.LayoutItem(100, 160));
        layout.setAlignY("top");
        this.flush();
        var children = container.getLayoutChildren();
        this.assertEquals(0, children[0].bounds.top);
        this.assertEquals(0, children[1].bounds.top);
        this.assertEquals(0, children[2].bounds.top);
        layout.setAlignY("middle");
        this.flush();
        var children = container.getLayoutChildren();
        this.assertEquals(50, children[0].bounds.top);
        this.assertEquals(30, children[1].bounds.top);
        this.assertEquals(60, children[2].bounds.top);
        layout.setAlignY("bottom");
        this.flush();
        var children = container.getLayoutChildren();
        this.assertEquals(100, children[0].bounds.top);
        this.assertEquals(60, children[1].bounds.top);
        this.assertEquals(120, children[2].bounds.top);
      },
      testChildAlignY: function testChildAlignY() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(null, null).set({
          layout: layout
        });
        this.root.add(container);
        var c1 = new qx.test.ui.layout.LayoutItem(100, 60).set({
          alignY: "top"
        });
        container.add(c1);
        var c2 = new qx.test.ui.layout.LayoutItem(100, 100).set({
          alignY: "middle"
        });
        container.add(c2);
        var c3 = new qx.test.ui.layout.LayoutItem(100, 40).set({
          alignY: "bottom"
        });
        container.add(c3); // reference

        container.add(new qx.test.ui.layout.LayoutItem(100, 160));
        this.flush();
        this.assertEquals(0, c1.bounds.top);
        this.assertEquals(30, c2.bounds.top);
        this.assertEquals(120, c3.bounds.top);
      },
      testReversed: function testReversed() {
        var layout = new qx.ui.layout.Flow().set({
          reversed: false
        });
        var container = this._container = new qx.test.ui.layout.LayoutItem(400, 50).set({
          layout: layout
        });
        this.root.add(container);
        var c1 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c1);
        var c2 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c2);
        var c3 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c3);
        this.flush();
        this.assertArrayEquals([c1, c2, c3], container.getLayoutChildren());
        layout.setReversed(true);
        this.flush();
        this.assertArrayEquals([c1, c2, c3], container.getLayoutChildren());
        this.assertEquals(200, c1.bounds.left);
        this.assertEquals(100, c2.bounds.left);
        this.assertEquals(0, c3.bounds.left);
      },
      testLineBreakAutoSize: function testLineBreakAutoSize() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(null, null).set({
          layout: layout
        });
        this.root.add(container);
        container.add(new qx.test.ui.layout.LayoutItem(100, 50));
        container.add(new qx.test.ui.layout.LayoutItem(100, 50), {
          lineBreak: true
        });
        container.add(new qx.test.ui.layout.LayoutItem(100, 50));
        this.flush();
        this.assertJsonEquals({
          left: 0,
          top: 0,
          width: 200,
          height: 100
        }, container.bounds);
        var children = container.getLayoutChildren();
        this.assertEquals(0, children[0].bounds.top);
        this.assertEquals(0, children[1].bounds.top);
        this.assertEquals(50, children[2].bounds.top);
        this.assertEquals(0, children[2].bounds.left);
      },
      testMargins: function testMargins() {
        var layout = new qx.ui.layout.Flow().set();
        var container = this._container = new qx.test.ui.layout.LayoutItem(null, null).set({
          layout: layout
        });
        this.root.add(container);
        var c1 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c1);
        var c2 = new qx.test.ui.layout.LayoutItem(100, 50).set({
          margin: [10, 20, 30, 40]
        });
        container.add(c2);
        var c3 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c3);
        this.flush();
        this.assertJsonEquals({
          left: 0,
          top: 0,
          width: 360,
          height: 90
        }, container.bounds);
        this.assertJsonEquals({
          left: 140,
          top: 10,
          width: 100,
          height: 50
        }, c2.bounds);
        this.assertEquals(260, c3.bounds.left);
      },
      testMarginXCollapse: function testMarginXCollapse() {
        var layout = new qx.ui.layout.Flow().set();
        var container = this._container = new qx.test.ui.layout.LayoutItem(300, null).set({
          layout: layout
        });
        this.root.add(container);
        var c1 = new qx.test.ui.layout.LayoutItem(100, 50).set({
          margin: [5, 10, 15, 20]
        });
        container.add(c1);
        var c2 = new qx.test.ui.layout.LayoutItem(100, 50).set({
          margin: [10, 20, 30, 40]
        });
        container.add(c2);
        var c3 = new qx.test.ui.layout.LayoutItem(100, 50).set({
          margin: [15]
        });
        container.add(c3);
        this.flush(); // no Y collapsing of margins

        this.assertJsonEquals({
          left: 0,
          top: 0,
          width: 300,
          height: 170
        }, container.bounds);
        this.assertEquals(20, c1.bounds.left);
        this.assertEquals(160, c2.bounds.left);
      },
      testSpacingX: function testSpacingX() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(null, null).set({
          layout: layout
        });
        this.root.add(container);
        var c1 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c1);
        var c2 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c2);
        var c3 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c3);
        this.flush();
        layout.setSpacingX(10);
        this.flush();
        this.assertEquals(320, container.bounds.width);
        this.assertEquals(0, c1.bounds.left);
        this.assertEquals(110, c2.bounds.left);
        this.assertEquals(220, c3.bounds.left);
      },
      testSpacingXAndMarginCollapsing: function testSpacingXAndMarginCollapsing() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(null, null).set({
          layout: layout
        });
        this.root.add(container);
        var c1 = new qx.test.ui.layout.LayoutItem(100, 50).set({
          margin: 5
        });
        container.add(c1);
        var c2 = new qx.test.ui.layout.LayoutItem(100, 50).set({
          margin: 5
        });
        container.add(c2);
        var c3 = new qx.test.ui.layout.LayoutItem(100, 50).set({
          margin: 15
        });
        container.add(c3);
        layout.setSpacingX(10);
        this.flush();
        this.assertEquals(330, container.bounds.width);
        this.assertEquals(5, c1.bounds.left);
        this.assertEquals(115, c2.bounds.left);
        this.assertEquals(230, c3.bounds.left);
      },
      testSpacingY: function testSpacingY() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(110, null).set({
          layout: layout
        });
        this.root.add(container);
        var c1 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c1);
        var c2 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c2);
        var c3 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c3);
        this.flush();
        layout.setSpacingY(10);
        this.flush();
        this.assertEquals(170, container.bounds.height);
        this.assertEquals(0, c1.bounds.top);
        this.assertEquals(60, c2.bounds.top);
        this.assertEquals(120, c3.bounds.top);
      },
      testHeightForWidth: function testHeightForWidth() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(110, null).set({
          layout: layout
        });
        this.root.add(container);
        var c1 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c1);
        var c2 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c2);
        var c3 = new qx.test.ui.layout.LayoutItem(100, 50);
        container.add(c3);
        this.flush();
        this.assertJsonEquals({
          left: 0,
          top: 0,
          width: 110,
          height: 150
        }, container.bounds);
        this.assertEquals(0, c1.bounds.top);
        this.assertEquals(50, c2.bounds.top);
        this.assertEquals(100, c3.bounds.top);
      },
      testLargeChildInLine: function testLargeChildInLine() {
        var layout = new qx.ui.layout.Flow();
        var container = this._container = new qx.test.ui.layout.LayoutItem(100, null).set({
          layout: layout
        });
        this.root.add(container);
        var c1 = new qx.test.ui.layout.LayoutItem(150, 50);
        container.add(c1);
        var c2 = new qx.test.ui.layout.LayoutItem(80, 50);
        container.add(c2);
        this.flush();
        this.assertEquals(0, c1.bounds.top);
        this.assertEquals(0, c1.bounds.left);
        this.assertEquals(50, c2.bounds.top);
      }
    },
    destruct: function destruct() {
      this.root = null;
    }
  });
  qx.test.ui.layout.Flow.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.LineSizeIterator": {},
      "qx.ui.layout.Util": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
     http://qooxdoo.org
  
     Copyright:
       2008 Dihedrals.com, http://www.dihedrals.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Chris Banford (zermattchris)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A basic layout, which supports positioning of child widgets in a 'flowing'
   * manner, starting at the container's top/left position, placing children left to right
   * (like a HBox) until the there's no remaining room for the next child. When
   * out of room on the current line of elements, a new line is started, cleared
   * below the tallest child of the preceding line -- a bit like using 'float'
   * in CSS, except that a new line wraps all the way back to the left.
   *
   * *Features*
   *
   * <ul>
   * <li> Reversing children order </li>
   * <li> Manual line breaks </li>
   * <li> Horizontal alignment of lines </li>
   * <li> Vertical alignment of individual widgets within a line </li>
   * <li> Margins with horizontal margin collapsing </li>
   * <li> Horizontal and vertical spacing </li>
   * <li> Height for width calculations </li>
   * <li> Auto-sizing </li>
   * </ul>
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>lineBreak</strong> <em>(Boolean)</em>: If set to <code>true</code>
   *   a forced line break will happen after this child widget.
   * </li>
   * <li><strong>stretch</strong> <em>(Boolean)</em>: If set to <code>true</code>
   *   the widget will be stretched to the remaining line width. This requires
   *   lineBreak to be true.
   * </li>
  
   * </ul>
   *
   * *Example*
   *
   * Here is a little example of how to use the Flow layout.
   *
   * <pre class="javascript">
   *  var flowlayout = new qx.ui.layout.Flow();
   *
   *  flowlayout.setAlignX( "center" );  // Align children to the X axis of the container (left|center|right)
   *
   *  var container = new qx.ui.container.Composite(flowlayout);
   *  this.getRoot().add(container, {edge: 0});
   *
   *  var button1 = new qx.ui.form.Button("1. First Button", "flowlayout/test.png");
   *  container.add(button1);
   *
   *  var button2 = new qx.ui.form.Button("2. Second longer Button...", "flowlayout/test.png");
   *  // Have this child create a break in the current Line (next child will always start a new Line)
   *  container.add(button2, {lineBreak: true});
   *
   *  var button3 = new qx.ui.form.Button("3rd really, really, really long Button", "flowlayout/test.png");
   *  button3.setHeight(100);  // tall button
   *  container.add(button3);
   *
   *  var button4 = new qx.ui.form.Button("Number 4", "flowlayout/test.png");
   *  button4.setAlignY("bottom");
   *  container.add(button4);
   *
   *  var button5 = new qx.ui.form.Button("20px Margins around the great big 5th button!");
   *  button5.setHeight(100);  // tall button
   *  button5.setMargin(20);
   *  container.add(button5, {lineBreak: true});    // Line break after this button.
   *
   *  var button6 = new qx.ui.form.Button("Number 6", "flowlayout/test.png");
   *  button6.setAlignY("middle");  // Align this child to the vertical center of this line.
   *  container.add(button6);
   *
   *  var button7 = new qx.ui.form.Button("7th a wide, short button", "flowlayout/test.png");
   *  button7.setMaxHeight(20);  // short button
   *  container.add(button7);
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/flow.html'>
   * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.
   */
  qx.Class.define("qx.ui.layout.Flow", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param spacingX {Integer?0} The spacing between child widgets {@link #spacingX}.
     * @param spacingY {Integer?0} The spacing between the lines {@link #spacingY}.
     * @param alignX {String?"left"} Horizontal alignment of the whole children
     *     block {@link #alignX}.
     */
    construct: function construct(spacingX, spacingY, alignX) {
      qx.ui.layout.Abstract.constructor.call(this);

      if (spacingX) {
        this.setSpacingX(spacingX);
      }

      if (spacingY) {
        this.setSpacingY(spacingY);
      }

      if (alignX) {
        this.setAlignX(alignX);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Horizontal alignment of the whole children block. The horizontal
       * alignment of the child is completely ignored in HBoxes (
       * {@link qx.ui.core.LayoutItem#alignX}).
       */
      alignX: {
        check: ["left", "center", "right"],
        init: "left",
        apply: "_applyLayoutChange"
      },

      /**
       * Vertical alignment of each child. Can be overridden through
       * {@link qx.ui.core.LayoutItem#alignY}.
       */
      alignY: {
        check: ["top", "middle", "bottom"],
        init: "top",
        apply: "_applyLayoutChange"
      },

      /** Horizontal spacing between two children */
      spacingX: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /**
       * The vertical spacing between the lines.
       */
      spacingY: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /** Whether the actual children list should be laid out in reversed order. */
      reversed: {
        check: "Boolean",
        init: false,
        apply: "_applyLayoutChange"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        var validProperties = ["lineBreak", "stretch"];
        this.assertInArray(name, validProperties, "The property '" + name + "' is not supported by the flow layout!");
      },
      // overridden
      connectToWidget: function connectToWidget(widget) {
        qx.ui.layout.Flow.prototype.connectToWidget.base.call(this, widget); // Necessary to be able to calculate the lines for the flow layout.
        // Otherwise the layout calculates the needed width and height by using
        // only one line of items which is leading to the wrong height. This
        // wrong height does e.g. suppress scrolling since the scroll pane does
        // not know about the correct needed height.

        if (widget) {
          widget.setAllowShrinkY(false);
        }
      },

      /**
       * The FlowLayout tries to add as many Children as possible to the current 'Line'
       * and when it sees that the next Child won't fit, it starts on a new Line, continuing
       * until all the Children have been added.
       * To enable alignX "left", "center", "right" renderLayout has to calculate the positions
       * of all a Line's children before it draws them.
       *
       * @param availWidth {Integer} Final width available for the content (in pixel)
       * @param availHeight {Integer} Final height available for the content (in pixel)
       * @param padding {Map} Map containing the padding values. Keys:
       * <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>
       */
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        var children = this._getLayoutChildren();

        if (this.getReversed()) {
          children = children.concat().reverse();
        }

        var lineCalculator = new qx.ui.layout.LineSizeIterator(children, this.getSpacingX());
        var lineTop = padding.top;

        while (lineCalculator.hasMoreLines()) {
          var line = lineCalculator.computeNextLine(availWidth);

          this.__renderLine(line, lineTop, availWidth, padding);

          lineTop += line.height + this.getSpacingY();
        }
      },

      /**
       * Render a line in the flow layout
       *
       * @param line {Map} A line configuration as returned by
       *    {@link LineSizeIterator#computeNextLine}.
       * @param lineTop {Integer} The line's top position
       * @param availWidth {Integer} The available line width
       * @param padding {Map} Map containing the padding values. Keys:
       * <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>
       */
      __renderLine: function __renderLine(line, lineTop, availWidth, padding) {
        var util = qx.ui.layout.Util;
        var left = padding.left;

        if (this.getAlignX() != "left") {
          left = padding.left + availWidth - line.width;

          if (this.getAlignX() == "center") {
            left = padding.left + Math.round((availWidth - line.width) / 2);
          }
        }

        for (var i = 0; i < line.children.length; i++) {
          var child = line.children[i];
          var size = child.getSizeHint();
          var marginTop = child.getMarginTop();
          var marginBottom = child.getMarginBottom();
          var top = util.computeVerticalAlignOffset(child.getAlignY() || this.getAlignY(), marginTop + size.height + marginBottom, line.height, marginTop, marginBottom);
          var layoutProps = child.getLayoutProperties();

          if (layoutProps.stretch && layoutProps.stretch) {
            size.width += availWidth - line.width;
          }

          child.renderLayout(left + line.gapsBefore[i], lineTop + top, size.width, size.height);
          left += line.gapsBefore[i] + size.width;
        }
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        return this.__computeSize(Infinity);
      },
      // overridden
      hasHeightForWidth: function hasHeightForWidth() {
        return true;
      },
      // overridden
      getHeightForWidth: function getHeightForWidth(width) {
        return this.__computeSize(width).height;
      },

      /**
       * Returns the list of children fitting in the last row of the given width.
       * @param width {Number} The width to use for the calculation.
       * @return {Array} List of children in the first row.
       */
      getLastLineChildren: function getLastLineChildren(width) {
        var lineCalculator = new qx.ui.layout.LineSizeIterator(this._getLayoutChildren(), this.getSpacingX());
        var lineData = [];

        while (lineCalculator.hasMoreLines()) {
          lineData = lineCalculator.computeNextLine(width).children;
        }

        return lineData;
      },

      /**
       * Compute the preferred size optionally constrained by the available width
       *
       * @param availWidth {Integer} The available width
       * @return {Map} Map containing the preferred height and width of the layout
       */
      __computeSize: function __computeSize(availWidth) {
        var lineCalculator = new qx.ui.layout.LineSizeIterator(this._getLayoutChildren(), this.getSpacingX());
        var height = 0;
        var width = 0;
        var lineCount = 0;

        while (lineCalculator.hasMoreLines()) {
          var line = lineCalculator.computeNextLine(availWidth);
          lineCount += 1;
          width = Math.max(width, line.width);
          height += line.height;
        }

        return {
          width: width,
          height: height + this.getSpacingY() * (lineCount - 1)
        };
      }
    }
  });
  qx.ui.layout.Flow.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
     http://qooxdoo.org
  
     Copyright:
       2008 Dihedrals.com, http://www.dihedrals.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Chris Banford (zermattchris)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This class iterates over the lines in a flow layout.
   *
   * @internal
   */
  qx.Class.define("qx.ui.layout.LineSizeIterator", {
    extend: Object,

    /**
     * @param children {qx.ui.core.Widget[]} The children of the flow layout to
     *    compute the lines from
     * @param spacing {Integer} The horizontal spacing between the children
     */
    construct: function construct(children, spacing) {
      this.__children = children;
      this.__spacing = spacing;
      this.__hasMoreLines = children.length > 0;
      this.__childIndex = 0;
    },
    members: {
      __children: null,
      __spacing: null,
      __hasMoreLines: null,
      __childIndex: null,

      /**
       * Computes the properties of the next line taking the available width into
       * account
       *
       * @param availWidth {Integer} The available width for the next line
       * @return {Map} A map containing the line's properties.
       */
      computeNextLine: function computeNextLine(availWidth) {
        var availWidth = availWidth || Infinity;

        if (!this.__hasMoreLines) {
          throw new Error("No more lines to compute");
        }

        var children = this.__children;
        var lineHeight = 0;
        var lineWidth = 0;
        var lineChildren = [];
        var gapsBefore = [];

        for (var i = this.__childIndex; i < children.length; i++) {
          var child = children[i];
          var size = child.getSizeHint();

          var gapBefore = this.__computeGapBeforeChild(i);

          var childWidth = size.width + gapBefore;
          var isFirstChild = i == this.__childIndex;

          if (!isFirstChild && lineWidth + childWidth > availWidth) {
            this.__childIndex = i;
            break;
          }

          var childHeight = size.height + child.getMarginTop() + child.getMarginBottom();
          lineChildren.push(child);
          gapsBefore.push(gapBefore);
          lineWidth += childWidth;
          lineHeight = Math.max(lineHeight, childHeight);

          if (child.getLayoutProperties().lineBreak) {
            this.__childIndex = i + 1;
            break;
          }
        }

        if (i >= children.length) {
          this.__hasMoreLines = false;
        }

        return {
          height: lineHeight,
          width: lineWidth,
          children: lineChildren,
          gapsBefore: gapsBefore
        };
      },

      /**
       * Computes the gap before the child at the given index
       *
       * @param childIndex {Integer} The index of the child widget
       * @return {Integer} The gap before the given child
       */
      __computeGapBeforeChild: function __computeGapBeforeChild(childIndex) {
        var isFirstInLine = childIndex == this.__childIndex;

        if (isFirstInLine) {
          return this.__children[childIndex].getMarginLeft();
        } else {
          return Math.max(this.__children[childIndex - 1].getMarginRight(), this.__children[childIndex].getMarginLeft(), this.__spacing);
        }
      },

      /**
       * Whether there are more lines
       *
       * @return {Boolean} Whether there are more lines
       */
      hasMoreLines: function hasMoreLines() {
        return this.__hasMoreLines;
      }
    }
  });
  qx.ui.layout.LineSizeIterator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.ui.layout.LayoutItem": {},
      "qx.ui.layout.Grid": {},
      "qx.test.ui.layout.LayoutRoot": {},
      "qx.ui.core.queue.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.layout.Grid", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this._gridWidget = new qx.test.ui.layout.LayoutItem(100, 50);
        this._gridLayout = new qx.ui.layout.Grid();

        this._gridWidget.setLayout(this._gridLayout);

        this.root = new qx.test.ui.layout.LayoutRoot();
        this.root.add(this._gridWidget);
      },
      tearDown: function tearDown() {
        this.root.dispose();

        this._gridWidget.dispose();

        this._gridLayout.dispose();
      },
      flush: function flush() {
        qx.ui.core.queue.Manager.flush();
      },
      assertSize: function assertSize(layoutItem, width, height) {
        this.flush();
        this.assertEquals(width, layoutItem.bounds.width);
        this.assertEquals(height, layoutItem.bounds.height);
      },
      _getFixedWidget: function _getFixedWidget() {
        var widget = new qx.test.ui.layout.LayoutItem(200, 100);
        widget.set({
          allowGrowX: false,
          allowShrinkX: false,
          allowGrowY: false,
          allowShrinkY: false
        });
        return widget;
      },
      testRowSpanWithoutFlex: function testRowSpanWithoutFlex() {
        // test with spacing
        this._gridLayout.setSpacingY(6);

        var w1 = new qx.test.ui.layout.LayoutItem(100, 100);

        this._gridWidget.add(w1, {
          row: 0,
          column: 1
        });

        var w2 = new qx.test.ui.layout.LayoutItem(100, 100);

        this._gridWidget.add(w2, {
          row: 1,
          column: 1
        });

        var w3 = new qx.test.ui.layout.LayoutItem(100, 300);

        this._gridWidget.add(w3, {
          row: 0,
          column: 0,
          rowSpan: 2
        });

        this.flush();
        this.assertEquals(300, this._gridWidget.bounds.height);
        w1.dispose();
        w2.dispose();
        w3.dispose();
      },
      testColSpanWithoutFlexAllowGrowTrue: function testColSpanWithoutFlexAllowGrowTrue() {
        this._gridLayout.setSpacingX(6);

        this._gridLayout.setAllowGrowSpannedCellWidth(true);

        var w1 = new qx.test.ui.layout.LayoutItem(100, 100);

        this._gridWidget.add(w1, {
          row: 1,
          column: 0
        });

        var w2 = new qx.test.ui.layout.LayoutItem(100, 100);

        this._gridWidget.add(w2, {
          row: 1,
          column: 1
        });

        this.flush();
        this.assertEquals(206, this._gridWidget.bounds.width);
        var w3 = new qx.test.ui.layout.LayoutItem(300, 100);

        this._gridWidget.add(w3, {
          row: 0,
          column: 0,
          colSpan: 2
        });

        this.flush();
        this.assertEquals(300, this._gridWidget.bounds.width);

        this._gridLayout.resetAllowGrowSpannedCellWidth();

        w1.dispose();
        w2.dispose();
        w3.dispose();
      },
      testColSpanWithoutFlexAllowGrowFalse: function testColSpanWithoutFlexAllowGrowFalse() {
        this._gridLayout.setSpacingX(6);

        this._gridLayout.setAllowGrowSpannedCellWidth(false);

        var w1 = new qx.test.ui.layout.LayoutItem(100, 100);

        this._gridWidget.add(w1, {
          row: 1,
          column: 0
        });

        var w2 = new qx.test.ui.layout.LayoutItem(100, 100);

        this._gridWidget.add(w2, {
          row: 1,
          column: 1
        });

        this.flush();
        this.assertEquals(206, this._gridWidget.bounds.width);
        var w3 = new qx.test.ui.layout.LayoutItem(300, 100);
        w3.setAllowShrinkX(true);

        this._gridWidget.add(w3, {
          row: 0,
          column: 0,
          colSpan: 2
        });

        this.flush();
        this.assertEquals(206, this._gridWidget.bounds.width);

        this._gridLayout.resetAllowGrowSpannedCellWidth();

        w1.dispose();
        w2.dispose();
        w3.dispose();
      },
      testColSpanWithoutFlexAllowGrowFalseChangeToTrue: function testColSpanWithoutFlexAllowGrowFalseChangeToTrue() {
        this._gridLayout.setSpacingX(6);

        this._gridLayout.setAllowGrowSpannedCellWidth(false);

        var w1 = new qx.test.ui.layout.LayoutItem(100, 100);

        this._gridWidget.add(w1, {
          row: 1,
          column: 0
        });

        var w2 = new qx.test.ui.layout.LayoutItem(100, 100);

        this._gridWidget.add(w2, {
          row: 1,
          column: 1
        });

        this.flush();
        this.assertEquals(206, this._gridWidget.bounds.width);
        var w3 = new qx.test.ui.layout.LayoutItem(300, 100);
        w3.setAllowShrinkX(true);

        this._gridWidget.add(w3, {
          row: 0,
          column: 0,
          colSpan: 2
        });

        this.flush();
        this.assertEquals(206, this._gridWidget.bounds.width);

        this._gridLayout.setAllowGrowSpannedCellWidth(true);

        this.flush();
        this.assertEquals(300, this._gridWidget.bounds.width);

        this._gridLayout.resetAllowGrowSpannedCellWidth();

        w1.dispose();
        w2.dispose();
        w3.dispose();
      },
      testGetCellWidget: function testGetCellWidget() {
        var grid = this._gridLayout;
        this.assertNull(grid.getCellWidget(0, 0));
        this.assertNull(grid.getCellWidget(1, 1));

        var w00 = this._getFixedWidget();

        this._gridWidget.add(w00, {
          row: 0,
          column: 0
        });

        this.assertEquals(w00, grid.getCellWidget(0, 0));
        this.assertNull(grid.getCellWidget(1, 1));

        var w11 = this._getFixedWidget();

        this._gridWidget.add(w11, {
          row: 1,
          column: 1
        });

        this.assertEquals(w00, grid.getCellWidget(0, 0));
        this.assertEquals(w11, grid.getCellWidget(1, 1));
        this.assertNull(grid.getCellWidget(1, 0));
      },
      testAutoSize: function testAutoSize() {
        this._gridWidget.add(this._getFixedWidget(), {
          row: 0,
          column: 0
        });

        this._gridWidget.add(this._getFixedWidget(), {
          row: 0,
          column: 1
        });

        this._gridWidget.add(this._getFixedWidget(), {
          row: 1,
          column: 0
        });

        this._gridWidget.add(this._getFixedWidget(), {
          row: 1,
          column: 1
        });

        this.assertSize(this._gridWidget, 400, 200); // spacing

        this._gridLayout.setSpacingY(10);

        this._gridLayout.setSpacingX(20);

        this.assertSize(this._gridWidget, 420, 210);
      },
      testAddRemove: function testAddRemove() {
        var a = this._getFixedWidget();

        var b = this._getFixedWidget();

        var c = this._getFixedWidget();

        var d = this._getFixedWidget();

        this._gridLayout.setSpacingY(10);

        this._gridLayout.setSpacingX(20); // initial layout:
        // ab
        // cd


        this._gridWidget.add(a, {
          row: 0,
          column: 0
        });

        this._gridWidget.add(b, {
          row: 0,
          column: 1
        });

        this._gridWidget.add(c, {
          row: 1,
          column: 0
        });

        this._gridWidget.add(d, {
          row: 1,
          column: 1
        });

        this.assertSize(this._gridWidget, 420, 210); // layout:
        // a
        // c

        this._gridWidget.remove(b);

        this._gridWidget.remove(d);

        this.assertSize(this._gridWidget, 200, 210); // layout:
        // a, d, b, c

        this._gridWidget.remove(c);

        this._gridWidget.add(d, {
          row: 0,
          column: 1
        });

        this._gridWidget.add(b, {
          row: 0,
          column: 2
        });

        this._gridWidget.add(c, {
          row: 0,
          column: 3
        });

        this.assertSize(this._gridWidget, 860, 100);
      },
      testVisibility: function testVisibility() {
        var a = this._getFixedWidget();

        var b = this._getFixedWidget();

        var c = this._getFixedWidget();

        var d = this._getFixedWidget();

        this._gridLayout.setSpacingY(10);

        this._gridLayout.setSpacingX(20); // initial layout:
        // ab
        // cd


        this._gridWidget.add(a, {
          row: 0,
          column: 0
        });

        this._gridWidget.add(b, {
          row: 0,
          column: 1
        });

        this._gridWidget.add(c, {
          row: 1,
          column: 0
        });

        this._gridWidget.add(d, {
          row: 1,
          column: 1
        });

        this.assertSize(this._gridWidget, 420, 210); // layout:
        // ab
        // cd

        a.setVisibility("hidden");
        b.setVisibility("hidden");
        c.setVisibility("hidden");
        this.assertSize(this._gridWidget, 420, 210); // layout:
        // ab

        b.setVisibility("visible");
        c.setVisibility("excluded");
        d.setVisibility("excluded");
        this.assertSize(this._gridWidget, 420, 100); // layout:
        // cd

        a.setVisibility("excluded");
        b.setVisibility("excluded");
        c.setVisibility("visible");
        d.setVisibility("visible");
        this.assertSize(this._gridWidget, 420, 110);
      },
      testCellSize: function testCellSize() {
        this._gridLayout.setRowHeight(0, 40);

        this._gridLayout.setRowHeight(1, 150);

        this._gridLayout.setColumnWidth(0, 70);

        this._gridLayout.setColumnWidth(1, 290);

        var a = new qx.test.ui.layout.LayoutItem(100, 50);
        var b = new qx.test.ui.layout.LayoutItem(100, 50);
        var c = new qx.test.ui.layout.LayoutItem(100, 50);
        var d = new qx.test.ui.layout.LayoutItem(100, 50);

        this._gridWidget.add(a, {
          row: 0,
          column: 0
        });

        this._gridWidget.add(b, {
          row: 0,
          column: 1
        });

        this._gridWidget.add(c, {
          row: 1,
          column: 0
        });

        this._gridWidget.add(d, {
          row: 1,
          column: 1
        });

        this.assertSize(a, 70, 40);
        this.assertSize(b, 290, 40);
        this.assertSize(c, 70, 150);
        this.assertSize(d, 290, 150);
      },
      testCellMinSize: function testCellMinSize() {
        var a = new qx.test.ui.layout.LayoutItem(100, 50).set({
          minWidth: 200,
          minHeight: 200
        });
        var b = new qx.test.ui.layout.LayoutItem(100, 50);
        var c = new qx.test.ui.layout.LayoutItem(100, 50);
        var d = new qx.test.ui.layout.LayoutItem(100, 50);

        this._gridWidget.add(a, {
          row: 0,
          column: 0
        });

        this._gridWidget.add(b, {
          row: 0,
          column: 1
        });

        this._gridWidget.add(c, {
          row: 1,
          column: 0
        });

        this._gridWidget.add(d, {
          row: 1,
          column: 1
        });

        this.assertSize(a, 200, 200);
        this.assertSize(b, 100, 200);
        this.assertSize(c, 200, 50);
        this.assertSize(d, 100, 50);
      },
      testGetRowCount: function testGetRowCount() {
        this.assertEquals(0, this._gridLayout.getRowCount());

        this._gridWidget.add(new qx.test.ui.layout.LayoutItem(100, 50), {
          row: 0,
          column: 0
        });

        this.assertEquals(1, this._gridLayout.getRowCount());

        this._gridWidget.add(new qx.test.ui.layout.LayoutItem(100, 50), {
          row: 4,
          column: 0
        });

        this.assertEquals(5, this._gridLayout.getRowCount());
      },
      testGetColumnCount: function testGetColumnCount() {
        this.assertEquals(0, this._gridLayout.getColumnCount());

        this._gridWidget.add(new qx.test.ui.layout.LayoutItem(100, 50), {
          row: 0,
          column: 0
        });

        this.assertEquals(1, this._gridLayout.getColumnCount());

        this._gridWidget.add(new qx.test.ui.layout.LayoutItem(100, 50), {
          row: 0,
          column: 4
        });

        this.assertEquals(5, this._gridLayout.getColumnCount());
      }
    },
    destruct: function destruct() {
      this._gridWidget = this._gridLayout = null;
    }
  });
  qx.test.ui.layout.Grid.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.layout.Util": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.layout.Util", {
    extend: qx.dev.unit.TestCase,
    members: {
      testFlex: function testFlex() {
        var numRuns = 500;

        for (var run = 0; run < numRuns; run++) {
          var len = Math.round(Math.random() * 20) + 1;
          var sumMin = 0;
          var sumMax = 0;
          var sumValue = 0;
          var flexibles = {};

          for (var j = 0; j < len; j++) {
            var min = Math.round(Math.random() * 20);
            var max = min + Math.round(Math.random() * 50) + 1;
            var value = min + Math.round(Math.random() * (max - min));
            sumMax += max;
            sumMin += min;
            sumValue += value;
            flexibles[j] = {
              min: min,
              value: value,
              max: max,
              flex: Math.ceil(Math.random() * 5) // flex range from 1 .. 5

            };
          }

          var availWidth = Math.round(Math.random() * 500);
          var result = qx.ui.layout.Util.computeFlexOffsets(flexibles, availWidth, sumValue); // check sum

          var sum = 0;

          for (var i in result) {
            var newSize = flexibles[i].value + result[i].offset;
            sum += newSize;
            this.assert(flexibles[i].min <= newSize);
            this.assert(flexibles[i].max >= newSize);
          }

          if (availWidth !== sum) {
            this.assert(sum == sumMin || sum == sumMax);
          } else {
            this.assertEquals(availWidth, sum);
          }
        }
      },

      /**
       * Test whether flex distributes the value fair concerning the flex factors
       */
      testFlexFairness: function testFlexFairness() {
        var numRuns = 500;

        for (var run = 0; run < numRuns; run++) {
          var len = Math.round(Math.random() * 20) + 1;
          var sumMin = 0;
          var sumMax = 0;
          var sumValue = 0;
          var sumWeights = 0;
          var flexibles = {};

          for (var j = 0; j < len; j++) {
            var min = 0;
            var max = 32000;
            var value = Math.round(Math.random() * 20);
            sumMax += max;
            sumMin += min;
            sumValue += value;
            flexibles[j] = {
              min: min,
              value: value,
              max: max,
              flex: 1 + Math.ceil(Math.random() * 5) // flex range from 1 .. 5

            };
            sumWeights += flexibles[j].flex;
          }

          var availWidth = sumValue + Math.round(Math.random() * 100);
          var result = qx.ui.layout.Util.computeFlexOffsets(flexibles, availWidth, sumValue);
          var offsets = 0;

          for (var i in result) {
            offsets += result[i].offset;
          }

          if (sumWeights > 0) {
            var unit = offsets / sumWeights;

            for (var j in result) {
              var error = result[j].offset - unit * flexibles[j].flex;
              this.assertTrue(Math.abs(error) <= 1, "The error must be at most one pixel!");
            }
          }
        }
      }
    }
  });
  qx.test.ui.layout.Util.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.test.ui.list.MAssert": {
        "require": true
      },
      "qx.ui.list.List": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.list.AbstractListTest", {
    type: "abstract",
    extend: qx.test.ui.LayoutTestCase,
    include: [qx.test.ui.list.MAssert],
    members: {
      _model: null,
      _list: null,
      setUp: function setUp() {
        qx.test.ui.list.AbstractListTest.prototype.setUp.base.call(this);
        this._model = this.createModelData();
        this._list = new qx.ui.list.List(this._model);
        this.configureList();
        this.getRoot().add(this._list);
        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.list.AbstractListTest.prototype.tearDown.base.call(this);

        this._list.dispose();

        this._list = null;

        this._model.dispose();

        this._model = null;
      },
      createModelData: function createModelData() {
        throw new Error("Abstract 'createModelData' method call!");
      },
      configureList: function configureList() {}
    }
  });
  qx.test.ui.list.AbstractListTest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.list.AbstractListTest": {
        "require": true
      },
      "qx.data.marshal.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.list.Group", {
    extend: qx.test.ui.list.AbstractListTest,
    members: {
      __names: ["Luise Siemer", "Trauhard Franke", "Sarina Wilde", "Florine Bähr", "Sigurd Adolph", "Sigmund Kurz", "Pankratius Hill", "Gerlinda Seel", "Trixi Clauß", "Cecilia Hemmer", "Rosely Fröhlich", "Annemargret Hunger", "Dietgar Münster", "Bertwin Joseph", "Edwina Schwarz", "Riana Dirks"],
      createModelData: function createModelData() {
        return qx.data.marshal.Json.createModel(this.__names);
      },
      testGroup: function testGroup() {
        var groupedModel = qx.data.marshal.Json.createModel(["L", "Luise Siemer", "T", "Trauhard Franke", "Trixi Clauß", "S", "Sarina Wilde", "Sigurd Adolph", "Sigmund Kurz", "F", "Florine Bähr", "P", "Pankratius Hill", "G", "Gerlinda Seel", "C", "Cecilia Hemmer", "R", "Rosely Fröhlich", "Riana Dirks", "A", "Annemargret Hunger", "D", "Dietgar Münster", "B", "Bertwin Joseph", "E", "Edwina Schwarz"]);
        var delegate = {
          group: function group(item) {
            return item.charAt(0).toUpperCase();
          }
        };

        this._list.setDelegate(delegate);

        this.flush();
        this.assertModelEqualsRowData(groupedModel, this._list);
        this.assertEquals(groupedModel.getLength(), this._list.getPane().getRowConfig().getItemCount(), "On Layer");
        this.assertEquals(12, this._list.getGroups().getLength(), "On List");
        groupedModel.dispose();
      },
      testDefaultGroup: function testDefaultGroup() {
        var groupedModel = qx.data.marshal.Json.createModel(["L", "Luise Siemer", "T", "Trauhard Franke", "Trixi Clauß", "???", "Sarina Wilde", "Sigurd Adolph", "Sigmund Kurz", "F", "Florine Bähr", "P", "Pankratius Hill", "G", "Gerlinda Seel", "C", "Cecilia Hemmer", "R", "Rosely Fröhlich", "Riana Dirks", "A", "Annemargret Hunger", "D", "Dietgar Münster", "B", "Bertwin Joseph", "E", "Edwina Schwarz"]);
        var delegate = {
          group: function group(item) {
            var group = item.charAt(0).toUpperCase();

            if (group == "S") {
              return null;
            }

            return item.charAt(0).toUpperCase();
          }
        };

        this._list.setDelegate(delegate);

        this.flush();
        this.assertModelEqualsRowData(groupedModel, this._list);
        this.assertEquals(groupedModel.getLength(), this._list.getPane().getRowConfig().getItemCount(), "On Layer");
        this.assertEquals(12, this._list.getGroups().getLength(), "On List");
        groupedModel.dispose();
      },
      testGroupWithSorter: function testGroupWithSorter() {
        var groupedModel = qx.data.marshal.Json.createModel(["T", "Trixi Clauß", "Trauhard Franke", "S", "Sigurd Adolph", "Sigmund Kurz", "Sarina Wilde", "R", "Rosely Fröhlich", "Riana Dirks", "P", "Pankratius Hill", "L", "Luise Siemer", "G", "Gerlinda Seel", "F", "Florine Bähr", "E", "Edwina Schwarz", "D", "Dietgar Münster", "C", "Cecilia Hemmer", "B", "Bertwin Joseph", "A", "Annemargret Hunger"]);
        var delegate = {
          sorter: function sorter(a, b) {
            return a < b ? 1 : a > b ? -1 : 0;
          },
          group: function group(item) {
            return item.charAt(0).toUpperCase();
          }
        };

        this._list.setDelegate(delegate);

        this.flush();
        this.assertModelEqualsRowData(groupedModel, this._list);
        this.assertEquals(groupedModel.getLength(), this._list.getPane().getRowConfig().getItemCount(), "On Layer");
        this.assertEquals(12, this._list.getGroups().getLength(), "On List");
        groupedModel.dispose();
      }
    }
  });
  qx.test.ui.list.Group.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.list.AbstractListTest": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.data.Array": {},
      "qx.data.marshal.Json": {},
      "qx.event.Timer": {},
      "qx.event.type.Data": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * @asset(qx/icon/${qx.icontheme}/16/places/folder.png)
   */
  qx.Class.define("qx.test.ui.list.List", {
    extend: qx.test.ui.list.AbstractListTest,
    include: qx.dev.unit.MMock,
    members: {
      createModelData: function createModelData() {
        var model = new qx.data.Array();

        for (var i = 0; i < 100; i++) {
          model.push("item " + (i + 1));
        }

        return model;
      },
      testCreation: function testCreation() {
        this._list.setWidth(300);

        this._list.setItemHeight(30);

        this.flush();
        this.assertEquals(this._list.getPane().getBounds().width, this._list.getPane().getColumnConfig().getItemSize(0));
        this.assertEquals(30, this._list.getPane().getRowConfig().getDefaultItemSize());
        this.assertEquals(this._model.getLength(), this._list.getPane().getRowConfig().getItemCount());
        this.assertEquals(this._model, this._list.getModel());
        this.assertEquals(0, this._list.getSelection().getLength());
      },
      testNullModel: function testNullModel() {
        this._list.setModel(null);

        this.assertEquals(0, this._list.getPane().getRowConfig().getItemCount());
        this.assertEquals(0, this._list.getSelection().getLength());
      },
      testChangeModelSize: function testChangeModelSize() {
        this._model.push("new item");

        this.assertModelEqualsRowData(this._model, this._list);
        this.assertEquals(this._model.getLength(), this._list.getPane().getRowConfig().getItemCount());

        this._model.dispose();

        this._model = new qx.data.Array();

        this._model.push("item");

        this._list.setModel(this._model);

        this.assertModelEqualsRowData(this._model, this._list);
        this.assertEquals(this._model.getLength(), this._list.getPane().getRowConfig().getItemCount());
      },
      testChangeModelContent: function testChangeModelContent() {
        this._model.setItem(0, "new item");

        this.flush();
        this.assertModelEqualsRowData(this._model, this._list);
        this.assertEquals(this._model.getLength(), this._list.getPane().getRowConfig().getItemCount());
        this.assertEquals("new item", this._list._layer.getRenderedCellWidget(0, 0).getLabel());
      },
      testResetModel: function testResetModel() {
        var model = new qx.data.Array();
        model.push("item");

        this._list.setModel(model);

        this.flush();
        this.assertModelEqualsRowData(model, this._list);

        this._list.resetModel();

        this.flush();
        this.assertModelEqualsRowData(this._model, this._list);
        this.assertEquals(this._model, this._list.getModel());
        this.assertEquals(this._list.getModel().getLength(), this._list.getPane().getRowConfig().getItemCount(), "b");
        model.dispose();
      },
      testComplexModel: function testComplexModel() {
        var rawData = [];

        for (var i = 0; i < 10; i++) {
          rawData[i] = {
            label: "Item " + i,
            icon: "icon/16/places/folder.png"
          };
        }

        var model = qx.data.marshal.Json.createModel(rawData);

        this._list.setLabelPath("label");

        this._list.setIconPath("icon");

        this._list.setModel(model);

        this.flush();
        this.assertModelEqualsRowData(model, this._list);
        this.assertEquals(model.getLength(), this._list.getPane().getRowConfig().getItemCount());
        this.assertEquals("Item 5", this._list._layer.getRenderedCellWidget(5, 0).getLabel());
        this.assertEquals("icon/16/places/folder.png", this._list._layer.getRenderedCellWidget(0, 0).getIcon());
        model.dispose();
      },
      testReverseBinding: function testReverseBinding() {
        var delegate = {
          bindItem: function bindItem(controller, item, id) {
            controller.bindDefaultProperties(item, id);
            controller.bindPropertyReverse(null, "label", null, item, id);
          }
        };

        this._list.setDelegate(delegate);

        this.flush();

        var widget = this._list._layer.getRenderedCellWidget(0, 0);

        widget.setLabel("abcde");
        this.flush();
        this.assertEquals(this._model.getLength(), this._list.getPane().getRowConfig().getItemCount(), "Model size <-> pane size");
        this.assertEquals("abcde", this._list._layer.getRenderedCellWidget(0, 0).getLabel(), "Widget value");
        this.assertEquals("abcde", this._list.getModel().getItem(0), "Model value");
      },
      testFilter: function testFilter() {
        var filteredModel = new qx.data.Array();

        for (var i = 0; i < this._model.getLength(); i++) {
          if (i % 2 == 0) {
            filteredModel.push("item " + (i + 1));
          }
        }

        var delegate = {
          filter: function filter(data) {
            return (parseInt(data.slice(5, data.length), 10) - 1) % 2 == 0;
          }
        };

        this._list.setDelegate(delegate);

        this.flush();
        this.assertModelEqualsRowData(filteredModel, this._list);
        this.assertEquals(filteredModel.getLength(), this._list.getPane().getRowConfig().getItemCount(), "two");
        filteredModel.dispose();
      },
      testSorter: function testSorter() {
        var sortedModel = new qx.data.Array();

        var sorter = function sorter(a, b) {
          return a < b ? 1 : a > b ? -1 : 0;
        };

        for (var i = 0; i < this._model.getLength(); i++) {
          sortedModel.push(this._model.getItem(i));
        }

        sortedModel.sort(sorter);
        var delegate = {
          sorter: sorter
        };

        this._list.setDelegate(delegate);

        this.flush();
        this.assertModelEqualsRowData(sortedModel, this._list);
        this.assertEquals(sortedModel.getLength(), this._list.getPane().getRowConfig().getItemCount(), "two");
        sortedModel.dispose();
      },
      testSorterWithFilter: function testSorterWithFilter() {
        var filteredModel = new qx.data.Array();

        for (var i = 0; i < this._model.getLength(); i++) {
          if (i % 2 == 0) {
            filteredModel.push("item " + (i + 1));
          }
        }

        var sortedModel = new qx.data.Array();

        var sorter = function sorter(a, b) {
          return a < b ? 1 : a > b ? -1 : 0;
        };

        for (var i = 0; i < filteredModel.getLength(); i++) {
          sortedModel.push(filteredModel.getItem(i));
        }

        sortedModel.sort(sorter);
        var delegate = {
          sorter: sorter,
          filter: function filter(data) {
            return (parseInt(data.slice(5, data.length), 10) - 1) % 2 == 0;
          }
        };

        this._list.setDelegate(delegate);

        this.flush();
        this.assertModelEqualsRowData(sortedModel, this._list);
        this.assertEquals(sortedModel.getLength(), this._list.getPane().getRowConfig().getItemCount(), "two");
        sortedModel.dispose();
        filteredModel.dispose();
      },
      testDisabledElements: function testDisabledElements() {
        var disabledItem = 3;
        var rawData = [];

        for (var i = 0; i < 10; i++) {
          rawData[i] = {
            label: "Item " + i,
            icon: "icon/16/places/folder.png",
            enabled: i != disabledItem
          };
        }

        var model = qx.data.marshal.Json.createModel(rawData);

        this._list.setDelegate({
          bindItem: function bindItem(controller, item, id) {
            controller.bindDefaultProperties(item, id);
            controller.bindProperty("enabled", "enabled", null, item, id);
          }
        });

        this._list.setLabelPath("label");

        this._list.setIconPath("icon");

        this._list.setModel(model);

        this.flush();

        for (var i = 0; i < 10; i++) {
          var widget = this._list._layer.getRenderedCellWidget(i, 0);

          if (widget == null) {
            // row is not rendered
            continue;
          }

          if (i != disabledItem) {
            this.assertTrue(widget.isEnabled());
          } else {
            this.assertFalse(widget.isEnabled());
          }
        }

        model.dispose();
      },
      testOnPool: function testOnPool() {
        var delegate = {
          onPool: function onPool(item) {}
        };
        var spy = this.spy(delegate, "onPool");

        this._list._provider.setDelegate(delegate);

        var widget = this._list._provider.getCellWidget(4, 0);

        this._list._provider.poolCellWidget(widget);

        this.assertCalledOnce(spy);
        this.assertCalledWith(spy, widget);
        widget.dispose();
      },
      testMultiSelectionMode: function testMultiSelectionMode() {
        var model = qx.data.marshal.Json.createModel(["a", "b", "c"]);

        this._list.setModel(model);

        this._list.setSelectionMode('multi');

        this._list.getSelection().push(model.getItem(0));

        this._list.getSelection().removeAll();

        this.assertNull(this._list._manager.getLeadItem());
        model.dispose();
      },
      testVariableItemHeight: function testVariableItemHeight() {
        this._list.setModel(null);

        this.flush();

        this._list.getPane().getRowConfig().resetItemSizes();

        var sizes = [16, 32, 48, 16, 32, 48, 16, 32, 48, 16, 32, 48];
        var rawData = [];

        for (var i = 0; i < sizes.length; i++) {
          rawData[i] = {
            label: "Item " + sizes[i] + "px",
            icon: "icon/" + sizes[i] + "/places/folder.png"
          };
        }

        var model = qx.data.marshal.Json.createModel(rawData);

        this._list.setVariableItemHeight(true);

        this._list.setDelegate({
          bindItem: function bindItem(controller, item, id) {
            controller.bindDefaultProperties(item, id);
          }
        });

        this._list.setLabelPath("label");

        this._list.setIconPath("icon");

        this._list.setModel(model);

        this.flush();
        qx.event.Timer.once(function () {
          this.resume(function () {
            var rowConfig = this._list.getPane().getRowConfig();

            var testedWidgets = 0;

            for (var i = 0; i < rawData.length; i++) {
              var widget = this._list._layer.getRenderedCellWidget(i, 0);

              if (widget == null) {
                // row is not rendered
                continue;
              }

              this.assertEquals(widget.getSizeHint().height, rowConfig.getItemSize(i));
              testedWidgets++;
            }

            this.assertTrue(testedWidgets >= 3);

            this._list.setVariableItemHeight(false);

            model.dispose();
          });
        }, this, 100);
        this.wait();
      },
      testChangeModelLengthListener: function testChangeModelLengthListener() {
        var model = new qx.data.Array(["a"]);

        this._list.setModel(model);

        this.assertEquals(1, model.getLength());
        this.assertEventFired(this._list, "changeModelLength", function () {
          model.push("b");
        }, function (ev) {
          this.assertInstance(ev, qx.event.type.Data);
          this.assertPositiveInteger(ev.getData());
          this.assertEquals(2, ev.getData());
          this.assertPositiveInteger(ev.getOldData());
          this.assertEquals(1, ev.getOldData());
        }.bind(this));

        this._list.setModel(null);

        model.dispose();
      }
    }
  });
  qx.test.ui.list.List.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.list.AbstractListTest": {
        "require": true
      },
      "qx.data.Array": {},
      "qx.test.ui.list.fixture.GroupMock": {},
      "qx.test.ui.list.fixture.ItemMock": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.list.ObjectGroup", {
    extend: qx.test.ui.list.AbstractListTest,
    members: {
      __names: ["Luise Siemer", "Trauhard Franke", "Sarina Wilde", "Florine Bähr", "Sigurd Adolph", "Sigmund Kurz", "Pankratius Hill", "Gerlinda Seel", "Trixi Clauß", "Cecilia Hemmer", "Rosely Fröhlich", "Annemargret Hunger", "Dietgar Münster", "Bertwin Joseph", "Edwina Schwarz", "Riana Dirks"],
      __groups: null,
      createModelData: function createModelData() {
        var model = new qx.data.Array();
        model.setAutoDisposeItems(true);
        var groups = this.__groups = {};

        for (var i = 0; i < this.__names.length; i++) {
          var name = this.__names[i];
          var groupName = name.charAt(0);
          var group = groups[groupName];

          if (group == null) {
            group = groups[groupName] = new qx.test.ui.list.fixture.GroupMock();
            group.setName(groupName);
          }

          var item = new qx.test.ui.list.fixture.ItemMock();
          item.setName(name);
          item.setGroup(group);
          model.push(item);
        }

        return model;
      },
      configureList: function configureList() {
        this._list.setLabelPath("name");

        this._list.setGroupLabelPath("name");
      },
      tearDown: function tearDown() {
        qx.test.ui.list.ObjectGroup.prototype.tearDown.base.call(this);

        for (var key in this.__groups) {
          if (this.__groups.hasOwnProperty(key)) {
            this.__groups[key].dispose();
          }
        }

        this.__groups = null;
      },
      testGroup: function testGroup() {
        // Expected result
        // "L", "Luise Siemer",
        // "T", "Trauhard Franke", "Trixi Clauß",
        // "S", "Sarina Wilde", "Sigurd Adolph", "Sigmund Kurz",
        // "F", "Florine Bähr",
        // "P", "Pankratius Hill",
        // "G", "Gerlinda Seel",
        // "C", "Cecilia Hemmer",
        // "R", "Rosely Fröhlich", "Riana Dirks",
        // "A", "Annemargret Hunger",
        // "D", "Dietgar Münster",
        // "B", "Bertwin Joseph",
        // "E", "Edwina Schwarz"
        var delegate = {
          group: function group(item) {
            return item.getGroup();
          }
        };

        this._list.setDelegate(delegate);

        this.flush();

        var groupedModel = this.__convertModel(this._model);

        this.assertModelEqualsRowData(groupedModel, this._list);
        this.assertEquals(groupedModel.getLength(), this._list.getPane().getRowConfig().getItemCount(), "On Layer");
        this.assertEquals(12, this._list.getGroups().getLength(), "On List");
        groupedModel.dispose();
      },
      testMixWithObjectsAndDefaultGroup: function testMixWithObjectsAndDefaultGroup() {
        var that = this;
        this.assertException(function () {
          var delegate = {
            group: function group(item) {
              var group = item.getGroup();

              if (group.getName() == "A") {
                return null;
              }

              return group;
            }
          };

          that._list.setDelegate(delegate);

          that.flush();
        }, Error, /GroupingTypeError:/);
      },
      testMixWithObjectsAndDefaultGroupAsFirstItem: function testMixWithObjectsAndDefaultGroupAsFirstItem() {
        var that = this;
        this.assertException(function () {
          var delegate = {
            group: function group(item) {
              if (that._model.indexOf(item) == 0) {
                return null;
              }

              return item.getGroup();
            }
          };

          that._list.setDelegate(delegate);

          that.flush();
        }, Error, /GroupingTypeError:/);
      },
      testMixWithObjectsAndStrings: function testMixWithObjectsAndStrings() {
        var that = this;
        this.assertException(function () {
          var delegate = {
            group: function group(item) {
              var group = item.getGroup();

              if (group.getName() == "A") {
                return group.getName();
              }

              return group;
            }
          };

          that._list.setDelegate(delegate);

          that.flush();
        }, Error, /GroupingTypeError:/);
      },
      testMixWithObjectsStringsAndDefaultGroup: function testMixWithObjectsStringsAndDefaultGroup() {
        var that = this;
        this.assertException(function () {
          var delegate = {
            group: function group(item) {
              var group = item.getGroup();

              if (that._model.indexOf(item) == 0) {
                return null;
              }

              if (group.getName() == "A") {
                return group.getName();
              }

              return group;
            }
          };

          that._list.setDelegate(delegate);

          that.flush();
        }, Error, /GroupingTypeError:/);
      },
      testGroupWithSorter: function testGroupWithSorter() {
        // Expected result
        // "T", "Trixi Clauß", "Trauhard Franke",
        // "S", "Sigurd Adolph", "Sigmund Kurz", "Sarina Wilde",
        // "R", "Rosely Fröhlich", "Riana Dirks",
        // "P", "Pankratius Hill",
        // "L", "Luise Siemer",
        // "G", "Gerlinda Seel",
        // "F", "Florine Bähr",
        // "E", "Edwina Schwarz",
        // "D", "Dietgar Münster",
        // "C", "Cecilia Hemmer",
        // "B", "Bertwin Joseph",
        // "A", "Annemargret Hunger"
        var sortedModel = new qx.data.Array();

        var sorter = function sorter(a, b) {
          a = a.getName();
          b = b.getName();
          return a < b ? 1 : a > b ? -1 : 0;
        };

        for (var i = 0; i < this._model.getLength(); i++) {
          sortedModel.push(this._model.getItem(i));
        }

        sortedModel.sort(sorter);
        var delegate = {
          sorter: sorter,
          group: function group(item) {
            return item.getGroup();
          }
        };

        this._list.setDelegate(delegate);

        this.flush();

        var groupedModel = this.__convertModel(sortedModel);

        this.assertModelEqualsRowData(groupedModel, this._list);
        this.assertEquals(groupedModel.getLength(), this._list.getPane().getRowConfig().getItemCount(), "On Layer");
        this.assertEquals(12, this._list.getGroups().getLength(), "On List");
        groupedModel.dispose();
        sortedModel.dispose();
      },
      __convertModel: function __convertModel(model) {
        var result = new qx.data.Array(); // get all groups

        var groups = [];

        for (var i = 0; i < model.getLength(); i++) {
          var group = model.getItem(i).getGroup();

          if (groups.indexOf(group) == -1) {
            groups.push(group);
          }
        } // build results


        for (var i = 0; i < groups.length; i++) {
          result.push(groups[i]);

          for (var k = 0; k < model.getLength(); k++) {
            var item = model.getItem(k);
            var group = item.getGroup();

            if (groups[i] === group) {
              result.push(item);
            }
          }
        }

        return result;
      }
    }
  });
  qx.test.ui.list.ObjectGroup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.list.fixture.GroupMock", {
    extend: qx.core.Object,
    properties: {
      name: {
        event: "changeName"
      }
    }
  });
  qx.test.ui.list.fixture.GroupMock.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.list.fixture.ItemMock", {
    extend: qx.core.Object,
    properties: {
      name: {
        event: "changeName"
      },
      group: {
        event: "changeGroup"
      }
    }
  });
  qx.test.ui.list.fixture.ItemMock.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.list.AbstractListTest": {
        "require": true
      },
      "qx.data.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.list.core.MultiSelection", {
    extend: qx.test.ui.list.AbstractListTest,
    members: {
      setUp: function setUp() {
        qx.test.ui.list.core.MultiSelection.prototype.setUp.base.call(this);

        this._list.setSelectionMode("multi");
      },
      createModelData: function createModelData() {
        var model = new qx.data.Array();

        for (var i = 0; i < 100; i++) {
          model.push("item " + (i + 1));
        }

        return model;
      },
      testSelection: function testSelection() {
        var selection = this._list.getSelection();

        selection.push(this._model.getItem(1));
        selection.push(this._model.getItem(2));
        selection.push(this._model.getItem(3));
        this.flush(); // check selection on list

        this.assertEquals(3, this._list.getSelection().getLength(), "On List");
        var expectedSelection = new qx.data.Array([this._model.getItem(1), this._model.getItem(2), this._model.getItem(3)]);
        this.assertDataArrayEquals(selection, expectedSelection, "On List");
        expectedSelection.dispose(); // check selection on manager

        var selectionFromManager = this._list._manager.getSelection();

        for (var i = 0; i < selectionFromManager.length; i++) {
          selectionFromManager[i] = this._list._getDataFromRow(selectionFromManager[i]);
        }

        this.assertEquals(3, selectionFromManager.length, "On selection manager");
        expectedSelection = new qx.data.Array(selectionFromManager);
        this.assertDataArrayEquals(selection, expectedSelection, "On selection manager");
        expectedSelection.dispose();
      },
      testSelectionByUserInteraction: function testSelectionByUserInteraction() {
        var selection = this._list.getSelection();

        this._list._manager.replaceSelection([2, 3, 4, 7, 8, 9]);

        this.flush(); // check selection on manager

        var selectionFromManager = this._list._manager.getSelection();

        for (var i = 0; i < selectionFromManager.length; i++) {
          selectionFromManager[i] = this._list._getDataFromRow(selectionFromManager[i]);
        }

        this.assertEquals(6, selectionFromManager.length, "On selection manager");
        var expectedSelection = new qx.data.Array(selectionFromManager);
        this.assertTrue(selection.equals(expectedSelection), "On selection manager");
        expectedSelection.dispose(); // check selection on list

        this.assertEquals(6, selection.getLength(), "On List");
        expectedSelection = new qx.data.Array([this._model.getItem(2), this._model.getItem(3), this._model.getItem(4), this._model.getItem(7), this._model.getItem(8), this._model.getItem(9)]);
        this.assertDataArrayEquals(selection, expectedSelection, "On List");
        expectedSelection.dispose();
      },
      testSelectionEventByUserInteraction: function testSelectionEventByUserInteraction() {
        var selection = this._list.getSelection();

        var self = this;
        this.assertEventFired(selection, "change", function () {
          self._list._manager.replaceSelection([2, 3, 4, 7, 8, 9]);

          self.flush();
        }, function (e) {
          // check selection on manager
          var selectionFromManager = self._list._manager.getSelection();

          for (var i = 0; i < selectionFromManager.length; i++) {
            selectionFromManager[i] = self._list._getDataFromRow(selectionFromManager[i]);
          }

          self.assertEquals(6, selectionFromManager.length, "On selection manager");
          var expectedSelection = new qx.data.Array(selectionFromManager);
          self.assertDataArrayEquals(selection, expectedSelection, "On selection manager");
          expectedSelection.dispose(); // check selection on list

          self.assertEquals(6, selection.getLength(), "On List");
          expectedSelection = new qx.data.Array([self._model.getItem(2), self._model.getItem(3), self._model.getItem(4), self._model.getItem(7), self._model.getItem(8), self._model.getItem(9)]);
          self.assertDataArrayEquals(selection, expectedSelection, "On List");
          expectedSelection.dispose();
        });
      },
      testSelectionWithSorter: function testSelectionWithSorter() {
        this._list.setDelegate({
          sorter: function sorter(a, b) {
            return a < b ? 1 : a > b ? -1 : 0;
          }
        });

        this.testSelection();
      },
      testOneSelection: function testOneSelection() {
        var selection = this._list.getSelection();

        this.assertEquals(0, selection.getLength());

        this._list.setSelectionMode("one");

        this.assertEquals(1, selection.getLength());
        this.assertEquals(this._model.getItem(0), selection.getItem(0));
      },
      testOneSelectionByChangingModel: function testOneSelectionByChangingModel() {
        var selection = this._list.getSelection();

        this.assertEquals(0, selection.getLength());

        var oldModel = this._model.copy();

        this._model.removeAll();

        this._list.setSelectionMode("one");

        this.assertEquals(0, selection.getLength());

        this._model.dispose();

        this._model = oldModel;

        this._list.setModel(this._model);

        this.assertEquals(1, selection.getLength());
        this.assertEquals(this._model.getItem(0), selection.getItem(0));
      },
      testOneSelectionWithEmptyModel: function testOneSelectionWithEmptyModel() {
        var selection = this._list.getSelection();

        var oldModel = this._model.copy();

        this._model.removeAll();

        this._list.setSelectionMode("one");

        this.assertEquals(0, selection.getLength());

        this._model.push(oldModel.getItem(2));

        this.assertEquals(1, selection.getLength());
        this.assertEquals(this._model.getItem(0), selection.getItem(0));
        oldModel.dispose();
      }
    }
  });
  qx.test.ui.list.core.MultiSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.list.AbstractListTest": {
        "require": true
      },
      "qx.data.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.list.core.SingleSelection", {
    extend: qx.test.ui.list.AbstractListTest,
    members: {
      createModelData: function createModelData() {
        var model = new qx.data.Array();

        for (var i = 0; i < 100; i++) {
          model.push("item " + i);
        }

        return model;
      },
      testSelection: function testSelection() {
        var selection = this._list.getSelection();

        selection.push(this._model.getItem(1));
        this.flush(); // check selection from list

        this.assertEquals(1, this._list.getSelection().getLength(), "On List");
        var expectedSelection = new qx.data.Array([this._model.getItem(1)]);
        this.assertDataArrayEquals(selection, expectedSelection, "On List");
        expectedSelection.dispose(); // check selection from manager

        var item = this._list._manager.getSelectedItem();

        item = this._list._getDataFromRow(item);
        this.assertEquals(this._model.getItem(1), item);
      },
      testInvalidSelection: function testInvalidSelection() {
        var selection = this._list.getSelection();

        selection.push(this._model.getItem(1));
        selection.push(this._model.getItem(2));
        this.flush(); // check selection from list

        this.assertEquals(1, this._list.getSelection().getLength(), "On List");
        var expectedSelection = new qx.data.Array([this._model.getItem(2)]);
        this.assertDataArrayEquals(selection, expectedSelection, "On List");
        expectedSelection.dispose(); // check selection from manager

        var selection = this._list._manager.getSelection();

        this.assertEquals(1, selection.length);
        this.assertEquals(2, selection[0]);
      },
      testSelectionByUserInteraction: function testSelectionByUserInteraction() {
        var selection = this._list.getSelection();

        this._list._manager.selectItem(2);

        this.flush();
        this.assertEquals(1, selection.getLength());
        this.assertEquals(this._model.getItem(2), selection.getItem(0));
        this.assertEquals(2, this._list._manager.getSelectedItem());
      },
      testSelectionEventByUserInteraction: function testSelectionEventByUserInteraction() {
        var selection = this._list.getSelection();

        var self = this;
        this.assertEventFired(selection, "change", function () {
          self._list._manager.selectItem(2);

          self.flush();
        }, function (e) {
          self.assertEquals(1, selection.getLength());
          self.assertEquals(self._model.getItem(2), selection.getItem(0));
          self.assertEquals(2, self._list._manager.getSelectedItem());
        });
      },
      testSelectionWithSorter: function testSelectionWithSorter() {
        this._list.setDelegate({
          sorter: function sorter(a, b) {
            return a < b ? 1 : a > b ? -1 : 0;
          }
        });

        this.testSelection();
      },
      testSelectionWithFilter: function testSelectionWithFilter() {
        this._list.setDelegate({
          filter: function filter(data) {
            // Filters all even items
            return parseInt(data.slice(5, data.length), 10) % 2 == 1;
          }
        });

        var selection = this._list.getSelection();

        selection.push(this._model.getItem(1));
        this.flush(); // check selection from list

        this.assertEquals(1, this._list.getSelection().getLength(), "On List");
        var expectedSelection = new qx.data.Array([this._model.getItem(1)]);
        this.assertDataArrayEquals(selection, expectedSelection, "On List");
        expectedSelection.dispose(); // check selection from manager

        var selection = this._list._manager.getSelection();

        this.assertEquals(1, selection.length);
        this.assertEquals(0, selection[0]);
      },
      testInvalidSelectionWithFilter: function testInvalidSelectionWithFilter() {
        this._list.setDelegate({
          filter: function filter(data) {
            // Filters all even items
            return parseInt(data.slice(5, data.length), 10) % 2 == 1;
          }
        });

        var selection = this._list.getSelection();

        selection.push(this._model.getItem(0));
        this.flush(); // check selection from list

        this.assertEquals(0, this._list.getSelection().getLength(), "On List"); // check selection from manager

        var selection = this._list._manager.getSelection();

        this.assertEquals(0, selection.length);
      },
      testApplyFilterAfterSelection: function testApplyFilterAfterSelection() {
        var selection = this._list.getSelection();

        selection.push(this._model.getItem(0));
        this.flush();

        this._list.setDelegate({
          filter: function filter(data) {
            // Filters all even items
            return parseInt(data.slice(5, data.length), 10) % 2 == 1;
          }
        });

        this.flush(); // check selection from list

        this.assertEquals(0, this._list.getSelection().getLength(), "On List"); // check selection from manager

        var selection = this._list._manager.getSelection();

        this.assertEquals(0, selection.length, "On Manager");
      },
      testApplySortingAfterSelection: function testApplySortingAfterSelection() {
        var selection = this._list.getSelection();

        selection.push(this._model.getItem(0));
        this.flush(); // check selection from list

        this.assertEquals(1, this._list.getSelection().getLength(), "On List"); // check selection from manager

        var selection = this._list._manager.getSelection();

        this.assertEquals(1, selection.length, "On Manager");

        this._list.setDelegate({
          sorter: function sorter(a, b) {
            return a < b ? 1 : a > b ? -1 : 0;
          }
        });

        this.flush(); // check selection from list

        var expectedSelection = new qx.data.Array([this._model.getItem(0)]);
        this.assertDataArrayEquals(expectedSelection, this._list.getSelection(), "On List");
        expectedSelection.dispose(); // check selection from manager

        var selection = this._list._manager.getSelection();

        this.assertEquals(1, selection.length, "On Manager"); // check row == last index

        this.assertEquals(this._model.getLength() - 1, this._list._manager.getSelection()[0], "Row is wrong on Manager");
      },
      testRemoveItem: function testRemoveItem() {
        var selection = this._list.getSelection();

        selection.push(this._model.getItem(0));
        this.flush();

        this._model.removeAt(0);

        this.flush(); // check selection from list

        this.assertEquals(0, this._list.getSelection().getLength(), "On List"); // check selection from manager

        var selection = this._list._manager.getSelection();

        this.assertEquals(0, selection.length, "On Manager");
      },
      testRemoveItemWithGrouping: function testRemoveItemWithGrouping() {
        this._list.setDelegate({
          group: function group(data) {
            return data;
          }
        });

        var lastIndex = this._model.getLength() - 1;

        var selection = this._list.getSelection();

        selection.push(this._model.getItem(lastIndex));
        this.flush();

        this._model.removeAt(lastIndex);

        this.flush(); // check selection from list

        this.assertEquals(0, this._list.getSelection().getLength(), "On List"); // check selection from manager

        var selection = this._list._manager.getSelection();

        this.assertEquals(0, selection.length, "On Manager");
      }
    }
  });
  qx.test.ui.list.core.SingleSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.element.Style": {},
      "qx.ui.root.Inline": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.root.Inline", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.__inlineIsleElement = qx.dom.Element.create("div");
        var inlineStyle = "position:absolute;top:50px;left:50px;width:200px;height:200px";
        qx.bom.element.Style.setCss(this.__inlineIsleElement, inlineStyle);
        qx.dom.Element.insertBegin(this.__inlineIsleElement, document.body);
      },
      tearDown: function tearDown() {
        qx.dom.Element.remove(this.__inlineIsleElement);
      },
      testAppearEvent: function testAppearEvent() {
        var inlineRoot = new qx.ui.root.Inline(this.__inlineIsleElement);
        inlineRoot.addListener("appear", function (e) {
          this.resume(function () {
            this.assertTrue(qx.dom.Element.isInDom(inlineRoot.getContentElement().getDomElement()));
          }, this);
        }, this);
        this.wait();
      }
    }
  });
  qx.test.ui.root.Inline.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.event.handler.ElementResize": {
        "defer": "runtime"
      },
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.root.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MLayoutHandling": {
        "defer": "runtime",
        "require": true
      },
      "qx.ui.layout.Basic": {
        "construct": true
      },
      "qx.ui.core.queue.Layout": {
        "construct": true
      },
      "qx.ui.core.FocusHandler": {
        "construct": true
      },
      "qx.bom.client.Engine": {
        "construct": true
      },
      "qx.dom.Node": {
        "construct": true
      },
      "qx.event.Registration": {
        "construct": true,
        "defer": "runtime"
      },
      "qx.bom.element.Dimension": {},
      "qx.bom.element.Style": {},
      "qx.html.Root": {},
      "qx.event.Timer": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "construct": true,
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Alexander Steitz (aback)
  
  ************************************************************************ */

  /**
   * This classes could be used to insert qooxdoo islands into existing
   * web pages. You can use the isles to place any qooxdoo powered widgets
   * inside a layout made using traditional HTML markup and CSS.
   *
   * The size of the widget in each dimension can either be determined by the
   * size hint of the inline's children or by the size of the root DOM element. If
   * <code>dynamicX</code>/<code>dynamicY</code> is true the width/height of the DOM
   * element is used.
   *
   * This class uses {@link qx.ui.layout.Basic} as default layout. The layout
   * can be changed using the {@link #setLayout} method.
   *
   * To position popups and tooltips please have a look at {@link qx.ui.root.Page}.
   *
   * @use(qx.event.handler.ElementResize)
   * @ignore(qx.ui.popup, qx.ui.popup.Manager.*)
   * @ignore(qx.ui.menu, qx.ui.menu.Manager.*)
   */
  qx.Class.define("qx.ui.root.Inline", {
    extend: qx.ui.root.Abstract,
    include: [qx.ui.core.MLayoutHandling],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param el {Element} DOM element to use as isle for qooxdoo content. Please
     *    note that existing content gets removed on the first layout flush.
     * @param dynamicX {Boolean} If <code>true</code> the widget's width is
     *    determined by the DOM element's width. Otherwise the children's size hint
     *    is used.
     * @param dynamicY {Boolean} If <code>true</code> the widget's height is
     *    determined by the DOM element's height. Otherwise the children's size hint
     *    is used.
     */
    construct: function construct(el, dynamicX, dynamicY) {
      // check the parameter
      {
        this.assertElement(el, "Please use a DOM element to create an inline root.");
      } // Temporary storage of element to use

      this.__elem = el; // Avoid any problems with dynamic resizing

      el.style.overflow = "hidden"; // Avoid any problems with broken layout

      el.style.textAlign = "left";
      this.__dynX = dynamicX || false;
      this.__dynY = dynamicY || false;

      this.__initDynamicMode();

      qx.ui.root.Abstract.constructor.call(this); // Use static layout

      this._setLayout(new qx.ui.layout.Basic()); // Directly schedule layout for root element


      qx.ui.core.queue.Layout.add(this); // Register as root

      qx.ui.core.FocusHandler.getInstance().connectTo(this); // Avoid the automatically scroll in to view.
      // See http://bugzilla.qooxdoo.org/show_bug.cgi?id=3236 for details.

      if (qx.core.Environment.get("engine.name") == "mshtml") {
        this.setKeepFocus(true);
      } // Resize handling for the window


      var window = qx.dom.Node.getWindow(el);
      qx.event.Registration.addListener(window, "resize", this._onWindowResize, this); // quick fix for [BUG #7680]

      this.getContentElement().setStyle("-webkit-backface-visibility", "hidden");
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __dynX: false,
      __dynY: false,
      __elem: null,

      /**
       * Performs several checks for dynamic mode and adds the "resize" listener
       */
      __initDynamicMode: function __initDynamicMode() {
        if (this.__dynX || this.__dynY) {
          // Check the DOM element for an usable width and height
          var elementDimensions = qx.bom.element.Dimension.getSize(this.__elem);

          if (this.__dynX && elementDimensions.width < 1) {
            throw new Error("The root element " + this.__elem + " of " + this + " needs a width when its width size should be used!");
          }

          if (this.__dynY) {
            if (elementDimensions.height < 1) {
              throw new Error("The root element " + this.__elem + " of " + this + " needs a height when its height size should be used!");
            } // check for implicit height. Set the height explicit to prevent that
            // the element grows indefinitely


            if (elementDimensions.height >= 1 && qx.bom.element.Style.get(this.__elem, "height", 3) == "") {
              qx.bom.element.Style.set(this.__elem, "height", elementDimensions.height + "px");
            }
          }

          qx.event.Registration.addListener(this.__elem, "resize", this._onResize, this);
        }
      },
      // overridden
      _createContentElement: function _createContentElement() {
        var el = this.__elem;

        if (this.__dynX || this.__dynY) {
          var rootEl = document.createElement("div");
          el.appendChild(rootEl);
        } else {
          rootEl = el;
        }

        var root = new qx.html.Root(rootEl); // Make relative

        rootEl.style.position = "relative"; // Store reference to the widget in the DOM element.

        root.connectWidget(this); // fire event asynchronously, otherwise the browser will fire the event
        // too early and no listener will be informed since they're not added
        // at this time

        qx.event.Timer.once(function (e) {
          this.fireEvent("appear");
        }, this, 0);
        return root;
      },

      /**
       * Listener for the element's resize event
       *
       * @param e {qx.event.type.Event} Event object
       */
      _onResize: function _onResize(e) {
        var data = e.getData();

        if (data.oldWidth !== data.width && this.__dynX || data.oldHeight !== data.height && this.__dynY) {
          qx.ui.core.queue.Layout.add(this);
        }
      },

      /**
       * Listener for the window's resize event.
       */
      _onWindowResize: function _onWindowResize() {
        // close all popups
        if (qx.ui.popup && qx.ui.popup.Manager) {
          qx.ui.popup.Manager.getInstance().hideAll();
        } // close all menus


        if (qx.ui.menu && qx.ui.menu.Manager) {
          qx.ui.menu.Manager.getInstance().hideAll();
        }
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var dynX = this.__dynX;
        var dynY = this.__dynY;

        if (!dynX || !dynY) {
          var hint = qx.ui.root.Inline.prototype._computeSizeHint.base.call(this);
        } else {
          hint = {};
        }

        var Dimension = qx.bom.element.Dimension;

        if (dynX) {
          var width = Dimension.getContentWidth(this.__elem);
          hint.width = width;
          hint.minWidth = width;
          hint.maxWidth = width;
        }

        if (dynY) {
          var height = Dimension.getContentHeight(this.__elem);
          hint.height = height;
          hint.minHeight = height;
          hint.maxHeight = height;
        }

        return hint;
      }
    },

    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer: function defer(statics, members) {
      qx.ui.core.MLayoutHandling.remap(members);
    },

    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct: function destruct() {
      qx.event.Registration.removeListener(this.__elem, "resize", this._onResize, this);
      this.__elem = null;
    }
  });
  qx.ui.root.Inline.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.selection.AbstractSingleSelectonTest", {
    extend: qx.test.ui.LayoutTestCase,
    type: "abstract",
    members: {
      _widget: null,
      _mode: null,
      _selection: null,
      _notInSelection: null,
      _getChildren: function _getChildren() {
        throw new Error("Abstract method call: _getChildren()");
      },
      _createTestElement: function _createTestElement(name) {
        throw new Error("Abstract method call: _createTestElement()");
      },
      _assertArrayEquals: function _assertArrayEquals(expected, found, message) {
        expected.sort();
        found.sort();
        this.assertArrayEquals(expected, found, message);
      },
      testGetSelection: function testGetSelection() {
        var result = this._widget.getSelection();

        this._assertArrayEquals(this._selection, result, "The result of the selection is wrong");
      },
      testSetSelection: function testSetSelection() {
        this._testSetSelection([this._notInSelection[0]]);
      },
      testDisabledSetSelection: function testDisabledSetSelection() {
        this._widget.setEnabled(false);

        this._testSetSelection([this._notInSelection[0]]);
      },
      _testSetSelection: function _testSetSelection(selection) {
        var that = this;
        var widget = this._widget;
        this._selection = selection; // Tests that the event is fired and the event contains the right widget

        this.assertEventFired(widget, "changeSelection", function () {
          widget.setSelection(that._selection);
          that.flush();
        }, function (event) {
          var data = event.getData();

          that._assertArrayEquals(that._selection, data, "The result of the 'changeSelection' event is wrong!");
        }, "'changeSelection' event not fired!"); // Tests the result from "getSelection"

        var result = this._widget.getSelection();

        this._assertArrayEquals(this._selection, result, "The result of 'getSelection' method is wrong!");
      },
      testSameSetSelection: function testSameSetSelection() {
        var that = this;
        var widget = this._widget;

        this._assertArrayEquals(this._selection, this._widget.getSelection(), "The test setup is wrong!");

        this.assertEventNotFired(widget, "changeSelection", function () {
          widget.setSelection(that._selection);
        }, function (event) {}, "'changeSelection' event fired!");
      },
      testSetSelectionWithNotChildElement: function testSetSelectionWithNotChildElement() {
        var testElement = this._createTestElement("Test Element");

        var that = this;
        this.assertException(function () {
          that._widget.setSelection([testElement]);
        }, Error, null, "No error occurs by trying to select an element which isn't a child element!");
        testElement.destroy();
      },
      testSetSelectionWithTooMuchElements: function testSetSelectionWithTooMuchElements() {
        var newSelection = [this._selection[0], this._notInSelection[0]];
        var that = this;
        this.assertException(function () {
          that._widget.setSelection(newSelection);
        }, Error, null, "It isn't possible to select more than one element!");

        this._assertArrayEquals(this._selection, this._widget.getSelection(), "The wrong setSelection call has changed the old seclection!");
      },
      testResetSelection: function testResetSelection() {
        var widget = this._widget;
        var that = this; //Tests that the event is fired and the event contains nothing

        this.assertEventFired(widget, "changeSelection", function () {
          widget.resetSelection();
          that.flush();
        }, function (event) {
          if (that._mode === "one") {
            that._assertArrayEquals([that._getChildren()[0]], event.getData(), "The first element isn't selected!");
          } else {
            that.assertIdentical(0, event.getData().length, "Event isn't empty!");
          }
        }, "'changeSelection' event not fired!"); // Tests that no item is selected

        var result = this._widget.getSelection();

        if (this._mode === "one") {
          this._assertArrayEquals([this._getChildren()[0]], result, "The first element isn't selected!");
        } else {
          this.assertIdentical(0, result.length, "The result isn't empty!");
        }
      },
      testDisabledResetSelection: function testDisabledResetSelection() {
        this._widget.setEnabled(false);

        this.testResetSelection();
      },
      testResetSelectionWithEmptySelection: function testResetSelectionWithEmptySelection() {
        var widget = this._widget;
        var that = this; //Tests that the event is fired and the event contains nothing

        this.assertEventFired(widget, "changeSelection", function () {
          widget.setSelection([]);
          that.flush();
        }, function (event) {
          if (that._mode === "one") {
            that._assertArrayEquals([that._getChildren()[0]], event.getData(), "The first element isn't selected!");
          } else {
            that.assertIdentical(0, event.getData().length, "Event isn't empty!");
          }
        }, "'changeSelection' event not fired!"); // Tests that no item is selected

        var result = this._widget.getSelection();

        if (this._mode === "one") {
          this._assertArrayEquals([this._getChildren()[0]], result, "The first element isn't selected!");
        } else {
          this.assertIdentical(0, result.length, "The result isn't empty!");
        }
      },
      testIsSelected: function testIsSelected() {
        var result = this._widget.isSelected(this._selection[0]);

        this.assertTrue(result, "The wrong item is selected!");
        var notSelected = this._notInSelection[0];
        result = this._widget.isSelected(notSelected);
        this.assertFalse(result, "The wrong item is selected!");
      },
      testIsSelectedWithNotChildElement: function testIsSelectedWithNotChildElement() {
        var testElement = this._createTestElement("Test Element");

        var that = this;
        this.assertException(function () {
          that._widget.isSelected(testElement);
        }, Error, null, "No error occurs by calling 'isSelected' with an element which isn't a child element!");
        testElement.destroy();
      },
      testIsSelectionEmpty: function testIsSelectionEmpty() {
        var result = this._widget.isSelectionEmpty();

        this.assertFalse(result, "The selection is empty!");

        this._widget.resetSelection();

        this.flush();
        result = this._widget.isSelectionEmpty();

        if (this._mode === "one") {
          this.assertFalse(result, "The selection is empty!");
        } else {
          this.assertTrue(result, "The selection isn't empty!");
        }
      },
      testGetSelectables: function testGetSelectables() {
        var items = this._getChildren();

        var found = this._widget.getSelectables(true);

        this._assertArrayEquals(items, found, "This list of the returned selectables are wrong!");
      },
      testDisabledGetSelectables: function testDisabledGetSelectables() {
        this._widget.setEnabled(false);

        this.testGetSelectables();
      },
      testGetUserSelectables: function testGetUserSelectables() {
        var selectables = [];

        var items = this._getChildren();

        for (var i = 0; i < items.length; i++) {
          if (i % 2 == 0) {
            selectables.push(items[i]);
          } else {
            items[i].setEnabled(false);
          }
        }

        var found = this._widget.getSelectables();

        this._assertArrayEquals(selectables, found, "This list of the returned selectables are wrong!");
      }
    }
  });
  qx.test.ui.selection.AbstractSingleSelectonTest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.selection.AbstractSingleSelectonTest": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.selection.AbstractMultiSelectonTest", {
    extend: qx.test.ui.selection.AbstractSingleSelectonTest,
    type: "abstract",
    members: {
      testSetSelectionWithTooMuchElements: function testSetSelectionWithTooMuchElements() {// Do nothing
      },
      // overridden
      testSetSelection: function testSetSelection() {
        qx.test.ui.selection.AbstractMultiSelectonTest.prototype.testSetSelection.base.call(this); // Sets up the new selection

        var selection = [];
        selection[0] = this._notInSelection[0];
        selection[1] = this._notInSelection[1];
        selection[2] = this._notInSelection[2];
        selection[3] = this._notInSelection[3];
        selection[4] = this._notInSelection[4];

        this._testSetSelection(selection);

        this.flush();
      },
      testSetSelectionOverrideWithLess: function testSetSelectionOverrideWithLess() {
        // Sets up the new selection
        this._selection = [];
        this._selection[0] = this._notInSelection[0];
        this._selection[1] = this._notInSelection[1];
        this._selection[2] = this._notInSelection[2];
        this._selection[3] = this._notInSelection[3];
        this._selection[4] = this._notInSelection[4];

        this._widget.setSelection(this._selection);

        this.flush(); // Test setSelection() with the same elements, but less

        var expected = [this._selection[0], this._selection[2], this._selection[4]];

        this._widget.setSelection(expected); // Tests the result from "getSelection"


        var result = this._widget.getSelection();

        this._assertArrayEquals(expected, result, "Selection is wrong"); // Test setSelection(), with one element from the selection before


        this._widget.setSelection(this._selection);

        this._widget.setSelection([this._selection[0]]);

        result = this._widget.getSelection();
        expected = [this._selection[0]];

        this._assertArrayEquals(expected, result, "Selection is wrong");

        this.flush();
      },
      testSelectAll: function testSelectAll() {
        // Resets the selection to compare the results.
        this._widget.resetSelection(); // Tests event and select all items


        var widget = this._widget;
        var that = this;
        this.assertEventFired(widget, "changeSelection", function () {
          widget.selectAll();
          that.flush();
        }, function (event) {
          // Tests the result from the event
          that._assertArrayEquals(that._getChildren(), event.getData(), "Selection is wrong!");
        }, "'changeSelection' event not fired!"); // A second selectAll() shouldn't fire an event

        this.assertEventNotFired(widget, "changeSelection", function () {
          widget.selectAll();
        }, function (event) {}, "'changeSelection' event fired!"); // Tests the result from "getSelection"

        this._selection = this._widget.getSelection();

        this._assertArrayEquals(this._getChildren(), this._selection, "Selection is wrong!");
      },
      testAddToSelection: function testAddToSelection() {
        // Sets up a new item for selection
        var newValue = this._notInSelection[0];
        this._selection[this._selection.length] = newValue; // Tests event and adds item to the selection

        var widget = this._widget;
        var that = this;
        this.assertEventFired(widget, "changeSelection", function () {
          widget.addToSelection(newValue);
          that.flush();
        }, function (event) {
          // Tests the result from the event
          that._assertArrayEquals(that._selection, event.getData(), "The result of the selection is wrong");
        }, "'changeSelection' event not fired!"); // A second selection shouldn't fire an event

        this.assertEventNotFired(widget, "changeSelection", function () {
          widget.addToSelection(newValue);
        }, function (event) {}, "'changeSelection' event fired!"); // Tests the result from "getSelection"

        this._assertArrayEquals(this._selection, this._widget.getSelection(), "Selection is wrong");
      },
      testAddToSelectionWithNotChildElement: function testAddToSelectionWithNotChildElement() {
        var that = this;

        var testElement = this._createTestElement("Test Element");

        this.assertException(function () {
          that._widget.addToSelection(testElement);
        }, Error, null, "No error occurs by trying to add an element to the selection which isn't a child element!");
        testElement.destroy();
      },
      testRemoveFromSelection: function testRemoveFromSelection() {
        // Sets up the item to remove and update the selection array
        var selection = this._selection;
        var itemToRemove = selection[selection.length - 1];
        delete selection[selection.length - 1];
        selection.length = selection.length - 1; // Tests event and removes the item

        var widget = this._widget;
        var that = this;
        this.assertEventFired(widget, "changeSelection", function () {
          widget.removeFromSelection(itemToRemove);
          that.flush();
        }, function (event) {
          // Tests the result from the event
          that._assertArrayEquals(that._selection, event.getData(), "The result of the selection is wrong");
        }, "'changeSelection' event not fired!"); // Tests the result from "getSelection"

        this._assertArrayEquals(this._selection, this._widget.getSelection(), "Selection is wrong");
      },
      testRemoveFromSelectionWithNotChildElement: function testRemoveFromSelectionWithNotChildElement() {
        var that = this;

        var testElement = this._createTestElement("Test Element");

        this.assertException(function () {
          that._widget.removeFromSelection(testElement);
        }, Error, null, "No error occurs by trying to remove an element which isn't a child element!");
        testElement.destroy();
      },
      testRemoveFromSelectionWithNotSelectedElement: function testRemoveFromSelectionWithNotSelectedElement() {
        var itemToRemove = this._notInSelection[0];
        var widget = this._widget;
        this.assertEventNotFired(widget, "changeSelection", function () {
          widget.removeFromSelection(itemToRemove);
        }, function (event) {}, "'changeSelection' event fired!");
      },
      testInvertSelection: function testInvertSelection() {
        var that = this;
        var widget = this._widget;
        this.assertEventFired(widget, "changeSelection", function () {
          widget.invertSelection();
          that.flush();
        }, function (event) {
          // Tests the result from the event
          that._assertArrayEquals(that._notInSelection, event.getData(), "The result of the selection is wrong");
        }, "'changeSelection' event not fired!"); // Tests the result from "getSelection"

        this._assertArrayEquals(this._notInSelection, this._widget.getSelection(), "Selection is wrong");
      },
      testInvertSelectionWithErrors: function testInvertSelectionWithErrors() {
        var widget = this._widget;
        widget.setSelectionMode("single");
        this.assertException(function () {
          widget.invertSelection();
        }, Error, null, "No error occurs by trying to invert elements in 'single' selection mode!");
      },
      testInvertSelectionWithDisabledChildElements: function testInvertSelectionWithDisabledChildElements() {
        // test setup
        var tempNotInSelection = [];

        for (var i = 0; i < this._notInSelection.length; i++) {
          tempNotInSelection.push(this._notInSelection[i]);
        }

        this._notInSelection = tempNotInSelection;
        var that = this;
        var widget = this._widget;
        this.assertEventFired(widget, "changeSelection", function () {
          widget.invertSelection();
          that.flush();
        }, function (event) {
          // Tests the result from the event
          that._assertArrayEquals(that._notInSelection, event.getData(), "The result of the selection is wrong");
        }, "'changeSelection' event not fired!"); // Tests the result from "getSelection"

        this._assertArrayEquals(this._notInSelection, this._widget.getSelection(), "Selection is wrong");
      }
    }
  });
  qx.test.ui.selection.AbstractMultiSelectonTest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.selection.AbstractMultiSelectonTest": {
        "require": true
      },
      "qx.ui.form.List": {},
      "qx.ui.form.ListItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.selection.ListMultiSelection", {
    extend: qx.test.ui.selection.AbstractMultiSelectonTest,
    members: {
      setUp: function setUp() {
        var length = 10;
        this._selection = [];
        this._notInSelection = [];
        this._mode = "multi";
        this._widget = new qx.ui.form.List().set({
          selectionMode: this._mode,
          width: 200,
          height: 400
        });
        this.getRoot().add(this._widget);

        var selection = this._widget.getSelection();

        this.assertIdentical(selection.length, 0, "Couldn't setup test, because selection isn't empty");

        for (var i = 0; i < length; i++) {
          var item = new qx.ui.form.ListItem("ListItem" + i);

          this._widget.add(item);

          if (i % 2 == 0) {
            this._widget.addToSelection(item);

            this._selection.push(item);
          } else {
            this._notInSelection.push(item);
          }
        }

        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.selection.ListMultiSelection.prototype.tearDown.base.call(this);

        this._widget.destroy();

        this._widget = null;
        this._selection = null;
        this._notInSelection = null;
        this.flush();
      },
      _getChildren: function _getChildren() {
        if (this._widget != null) {
          return this._widget.getChildren();
        } else {
          return [];
        }
      },
      _createTestElement: function _createTestElement(name) {
        return new qx.ui.form.ListItem(name);
      }
    }
  });
  qx.test.ui.selection.ListMultiSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.selection.AbstractSingleSelectonTest": {
        "require": true
      },
      "qx.ui.form.List": {},
      "qx.ui.form.ListItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.selection.ListSingleSelection", {
    extend: qx.test.ui.selection.AbstractSingleSelectonTest,
    members: {
      setUp: function setUp() {
        var length = 10;
        this._notInSelection = [];
        this._mode = "single";
        this._widget = new qx.ui.form.List().set({
          selectionMode: this._mode,
          width: 200,
          height: 400
        });
        this.getRoot().add(this._widget);

        for (var i = 0; i < length; i++) {
          var item = new qx.ui.form.ListItem("ListItem" + i);

          this._widget.add(item);

          if (i == 5) {
            this.assertIdentical(0, this._widget.getSelection().length, "Couldn't setup test, because selection isn't empty");

            this._widget.setSelection([item]);

            this._selection = [item];
          } else {
            this._notInSelection.push(item);
          }
        }

        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.selection.ListSingleSelection.prototype.tearDown.base.call(this);

        this._widget.destroy();

        this._widget = null;
        this._selection = null;
        this._notInSelection = null;
        this.flush();
      },
      _getChildren: function _getChildren() {
        if (this._widget != null) {
          return this._widget.getChildren();
        } else {
          return [];
        }
      },
      _createTestElement: function _createTestElement(name) {
        return new qx.ui.form.ListItem(name);
      }
    }
  });
  qx.test.ui.selection.ListSingleSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.selection.AbstractSingleSelectonTest": {
        "require": true
      },
      "qx.ui.form.RadioGroup": {},
      "qx.ui.form.RadioButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.selection.RadioGroup", {
    extend: qx.test.ui.selection.AbstractSingleSelectonTest,
    members: {
      __radioButtons: null,
      setUp: function setUp() {
        var length = 10;
        this._mode = "one";
        this.__radioButtons = [];
        this._notInSelection = [];
        this._widget = new qx.ui.form.RadioGroup();
        var root = this.getRoot();

        for (var i = 0; i < length; i++) {
          var item = new qx.ui.form.RadioButton("RadioButton" + i);
          root.add(item, {
            top: 20 * i
          });

          this._widget.add(item);

          this.__radioButtons.push(item);

          if (i == 5) {
            this._widget.setSelection([item]);

            this._selection = [item];
          } else {
            this._notInSelection.push(item);
          }
        }

        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.selection.RadioGroup.prototype.tearDown.base.call(this);

        for (var i = 0; i < this.__radioButtons.length; i++) {
          this.__radioButtons[i].destroy();
        }

        this.__radioButtons = null;

        this._widget.dispose();

        this._widget = null;
        this._selection = null;
        this._notInSelection = null;
        this.flush();
      },
      _getChildren: function _getChildren() {
        if (this._widget != null) {
          return this._widget.getItems();
        } else {
          return [];
        }
      },
      _createTestElement: function _createTestElement(name) {
        return new qx.ui.form.RadioButton(name);
      },
      testAllowEmptySelection: function testAllowEmptySelection() {
        this._mode = "";

        this._widget.setAllowEmptySelection(true);

        this.testResetSelection();

        this._widget.setAllowEmptySelection(false);

        var result = this._widget.getSelection();

        this._assertArrayEquals([this._widget.getSelectables()[0]], result, "The result of 'getSelection' method is wrong!");
      },
      testAdd: function testAdd() {
        var widget = new qx.ui.form.RadioGroup();
        var item = new qx.ui.form.RadioButton("RadioButton");
        widget.add(item);
        var result = widget.getSelection();

        this._assertArrayEquals([widget.getSelectables()[0]], result, "The result of 'getSelection' method is wrong!");

        widget.dispose();
        item.destroy();
      },
      testAddWithAllowEmptySelection: function testAddWithAllowEmptySelection() {
        var widget = new qx.ui.form.RadioGroup();
        widget.setAllowEmptySelection(true);
        var item = new qx.ui.form.RadioButton("RadioButton");
        widget.add(item);
        var result = widget.getSelection();
        this.assertEquals(0, result.length, "The result of 'getSelection' method is wrong!");
        widget.dispose();
        item.destroy();
      },
      testSetGroup: function testSetGroup() {
        var radioButton1 = new qx.ui.form.RadioButton();
        var radioButton2 = new qx.ui.form.RadioButton();
        var radioGroup = new qx.ui.form.RadioGroup();
        radioButton1.setGroup(radioGroup);
        radioButton2.setGroup(radioGroup);
        this.assertEquals(radioButton1, radioGroup.getItems()[0], "First button not in the group.");
        this.assertEquals(radioButton2, radioGroup.getItems()[1], "Second button not in the group.");
        radioGroup.dispose();
        radioButton2.dispose();
        radioButton1.dispose();
      }
    }
  });
  qx.test.ui.selection.RadioGroup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.selection.AbstractSingleSelectonTest": {
        "require": true
      },
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.ListItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.selection.SelectBox", {
    extend: qx.test.ui.selection.AbstractSingleSelectonTest,
    members: {
      setUp: function setUp() {
        var length = 10;
        this._notInSelection = [];
        this._mode = "one";
        this._widget = new qx.ui.form.SelectBox();
        this.getRoot().add(this._widget);

        for (var i = 0; i < length; i++) {
          var item = new qx.ui.form.ListItem("ListItem" + i);

          this._widget.add(item);

          if (i == 5) {
            this._widget.setSelection([item]);

            this._selection = [item];
          } else {
            this._notInSelection.push(item);
          }
        }

        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.selection.SelectBox.prototype.tearDown.base.call(this);

        this._widget.destroy();

        this._widget = null;
        this._selection = null;
        this._notInSelection = null;
        this.flush();
      },
      testResetSelectionAllowEmpty: function testResetSelectionAllowEmpty() {
        this._mode = "single";

        this._widget.getChildrenContainer().setSelectionMode(this._mode);

        this.testResetSelection();
      },
      _getChildren: function _getChildren() {
        if (this._widget != null) {
          return this._widget.getChildrenContainer().getChildren();
        } else {
          return [];
        }
      },
      _createTestElement: function _createTestElement(name) {
        return new qx.ui.form.ListItem(name);
      }
    }
  });
  qx.test.ui.selection.SelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.selection.AbstractSingleSelectonTest": {
        "require": true
      },
      "qx.ui.container.Stack": {},
      "qx.ui.tabview.Page": {},
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.selection.Stack", {
    extend: qx.test.ui.selection.AbstractSingleSelectonTest,
    members: {
      __radioButtons: null,
      setUp: function setUp() {
        var length = 10;
        this._notInSelection = [];
        this._mode = "";
        var colors = [{
          background: "blue",
          textColor: "white"
        }, {
          background: "red",
          textColor: "black"
        }, {
          background: "green",
          textColor: "black"
        }, {
          background: "yellow",
          textColor: "black"
        }, {
          background: "brown",
          textColor: "white"
        }, {
          background: "aqua",
          textColor: "black"
        }, {
          background: "fuchsia",
          textColor: "black"
        }, {
          background: "silver",
          textColor: "white"
        }, {
          background: "black",
          textColor: "white"
        }, {
          background: "white",
          textColor: "black"
        }];
        this._widget = new qx.ui.container.Stack();
        this.getRoot().add(this._widget);

        for (var i = 0; i < length; i++) {
          var item = this.__createItem("Page" + i, colors[i]);

          this._widget.add(item);

          if (i == 5) {
            this._widget.setSelection([item]);

            this._selection = [item];
          } else {
            this._notInSelection.push(item);
          }
        }

        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.selection.Stack.prototype.tearDown.base.call(this);

        this._widget.destroy();

        this._widget = null;
        this._selection = null;
        this._notInSelection = null;
        this.flush();
      },
      _getChildren: function _getChildren() {
        if (this._widget != null) {
          return this._widget.getChildren();
        } else {
          return [];
        }
      },
      _createTestElement: function _createTestElement(name) {
        return new qx.ui.tabview.Page(name);
      },
      __createItem: function __createItem(name, colors) {
        var item = new qx.ui.basic.Label(name).set({
          width: 300,
          height: 300,
          allowShrinkX: false,
          allowShrinkY: false,
          backgroundColor: colors.background,
          textColor: colors.textColor,
          padding: 10
        });
        return item;
      }
    }
  });
  qx.test.ui.selection.Stack.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.selection.AbstractSingleSelectonTest": {
        "require": true
      },
      "qx.ui.tabview.TabView": {},
      "qx.ui.tabview.Page": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.selection.TabView", {
    extend: qx.test.ui.selection.AbstractSingleSelectonTest,
    members: {
      __radioButtons: null,
      setUp: function setUp() {
        var length = 10;
        this._notInSelection = [];
        this._mode = "one";
        this._widget = new qx.ui.tabview.TabView();
        this.getRoot().add(this._widget);

        for (var i = 0; i < length; i++) {
          var item = new qx.ui.tabview.Page("Page" + i);

          this._widget.add(item);

          if (i == 5) {
            this._widget.setSelection([item]);

            this._selection = [item];
          } else {
            this._notInSelection.push(item);
          }
        }

        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.selection.TabView.prototype.tearDown.base.call(this);

        this._widget.destroy();

        this._widget = null;
        this._selection = null;
        this._notInSelection = null;
        this.flush();
      },
      _getChildren: function _getChildren() {
        if (this._widget != null) {
          return this._widget.getChildren();
        } else {
          return [];
        }
      },
      testAddAtIndex: function testAddAtIndex() {
        var index = parseInt(this._widget.getChildren().length / 2);
        var page = new qx.ui.tabview.Page("insertedPage_" + index);

        this._widget.addAt(page, index);

        this.assertEquals(page.getLabel(), this._widget.getChildren()[index].getLabel());
      },
      testAddPage: function testAddPage() {
        var page = new qx.ui.tabview.Page("insertedPage_Last");

        this._widget.add(page);

        this.assertEquals(page.getLabel(), this._widget.getChildren()[this._widget.getChildren().length - 1].getLabel());
      },
      testAddAtLastIndex: function testAddAtLastIndex() {
        var index = this._widget.getChildren().length;

        var page = new qx.ui.tabview.Page("insertedPage_" + index);

        this._widget.addAt(page, index);

        this.assertEquals(page.getLabel(), this._widget.getChildren()[index].getLabel());
        this.assertEquals(page.getLabel(), this._widget.getChildren()[this._widget.getChildren().length - 1].getLabel());
      },
      _createTestElement: function _createTestElement(name) {
        return new qx.ui.tabview.Page(name);
      }
    }
  });
  qx.test.ui.selection.TabView.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.selection.AbstractMultiSelectonTest": {
        "require": true
      },
      "qx.ui.tree.Tree": {},
      "qx.ui.tree.TreeFolder": {},
      "qx.ui.tree.TreeFile": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.selection.TreeMultiSelection", {
    extend: qx.test.ui.selection.AbstractMultiSelectonTest,
    members: {
      setUp: function setUp() {
        var length = 10;
        this._selection = [];
        this._notInSelection = [];
        this._mode = "multi";
        this._widget = new qx.ui.tree.Tree().set({
          selectionMode: this._mode,
          width: 200,
          height: 400
        });
        this.getRoot().add(this._widget);
        var root = new qx.ui.tree.TreeFolder("Root");
        root.setOpen(true);

        this._widget.setRoot(root);

        this._notInSelection.push(root);

        for (var i = 0; i < length; i++) {
          var folder = new qx.ui.tree.TreeFolder("Folder" + i);
          folder.setOpen(true);

          this._notInSelection.push(folder);

          var file = new qx.ui.tree.TreeFile("File" + i);
          folder.add(file);
          root.add(folder);

          if (i % 2 == 0) {
            this._widget.addToSelection(file);

            this._selection.push(file);
          } else {
            this._notInSelection.push(file);
          }
        }

        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.selection.TreeMultiSelection.prototype.tearDown.base.call(this);

        this._widget.destroy();

        this._widget = null;
        this._selection = null;
        this._notInSelection = null;
        this.flush();
      },
      _getChildren: function _getChildren() {
        if (this._widget != null) {
          return this._widget.getItems();
        } else {
          return [];
        }
      },
      _createTestElement: function _createTestElement(name) {
        return new qx.ui.tree.TreeFile(name);
      }
    }
  });
  qx.test.ui.selection.TreeMultiSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.selection.AbstractSingleSelectonTest": {
        "require": true
      },
      "qx.ui.tree.Tree": {},
      "qx.ui.tree.TreeFolder": {},
      "qx.ui.tree.TreeFile": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.selection.TreeSingleSelection", {
    extend: qx.test.ui.selection.AbstractSingleSelectonTest,
    members: {
      setUp: function setUp() {
        var length = 10;
        this._notInSelection = [];
        this._mode = "single";
        this._widget = new qx.ui.tree.Tree().set({
          selectionMode: this._mode,
          width: 200,
          height: 400
        });
        this.getRoot().add(this._widget);
        var root = new qx.ui.tree.TreeFolder("Root");
        root.setOpen(true);

        this._widget.setRoot(root);

        for (var i = 0; i < length; i++) {
          var folder = new qx.ui.tree.TreeFolder("Folder" + i);
          folder.setOpen(true);
          var file = new qx.ui.tree.TreeFile("File" + i);
          folder.add(file);
          root.add(folder);

          if (i == 5) {
            this.assertIdentical(0, this._widget.getSelection().length, "Couldn't setup test, because selection isn't empty");

            this._widget.setSelection([file]);

            this._selection = [file];
          } else {
            this._notInSelection.push(file);
          }
        }

        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.selection.TreeSingleSelection.prototype.tearDown.base.call(this);

        this._widget.destroy();

        this._widget = null;
        this._selection = null;
        this._notInSelection = null;
        this.flush();
      },
      _getChildren: function _getChildren() {
        if (this._widget != null) {
          return this._widget.getItems();
        } else {
          return [];
        }
      },
      _createTestElement: function _createTestElement(name) {
        return new qx.ui.tree.TreeFile(name);
      },
      testFolderOpen: function testFolderOpen() {
        var tree = new qx.ui.tree.Tree();
        this.getRoot().add(tree);
        var root = new qx.ui.tree.TreeFolder("root");
        tree.setRoot(root);
        var f1 = new qx.ui.tree.TreeFolder("f1");
        var f2 = new qx.ui.tree.TreeFolder("f2");
        root.add(f1);
        f1.add(f2); // select the first folder

        tree.setSelection([f1]); // check if the root is opened

        this.assertTrue(root.getOpen()); // close the root

        root.setOpen(false); // select the second folder

        tree.setSelection([f2]); // check if the root and f1 is open

        this.assertTrue(root.getOpen());
        this.assertTrue(f1.getOpen());
        f1.destroy();
        f2.destroy();
        root.destroy();
        tree.destroy();
      }
    }
  });
  qx.test.ui.selection.TreeSingleSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.table.model.Simple": {},
      "qx.ui.table.Table": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.table.Dispose", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      createModel: function createModel() {
        var tableModel = new qx.ui.table.model.Simple();
        tableModel.setColumns(["ID", "A number", "A date", "Boolean"]);
        tableModel.setData(this.createRandomRows(200));
        return tableModel;
      },
      createRandomRows: function createRandomRows(rowCount) {
        var rowData = [];
        var now = new Date().getTime();
        var dateRange = 34560000000; // 400 days

        var nextId = 0;

        for (var row = 0; row < rowCount; row++) {
          var date = new Date(now + Math.random() * dateRange - dateRange / 2);
          rowData.push([nextId++, Math.random() * 10000, date, Math.random() > 0.5]);
        }

        return rowData;
      },
      testSimple: function testSimple() {
        this.assertDestroy(function () {
          // table
          var model = this.createModel();
          var table = new qx.ui.table.Table(model);
          this.getRoot().add(table);
          this.flush();
          table.destroy();
          model.dispose();
        }, this, "Dispose simple table");
      },
      changeModel: function changeModel(table) {
        var model = table.getTableModel();
        table.setTableModel(this.createModel());
        model.dispose();
      },
      testChangeModel: function testChangeModel() {
        this.assertDestroy(function () {
          // table
          var table = new qx.ui.table.Table(this.createModel());
          this.changeModel(table);
          this.getRoot().add(table);
          this.flush();
          this.changeModel(table);
          var model = table.getTableModel();
          table.destroy();
          model.dispose();
        }, this, "Dispose table with changed model");
      }
    }
  });
  qx.test.ui.table.Dispose.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * The data model of a table.
   */
  qx.Interface.define("qx.ui.table.ITableModel", {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the table data changed (the stuff shown in the table body).
       * The data property of the event may be null or a map having the following attributes:
       * <ul>
       *   <li>firstRow: The index of the first row that has changed.</li>
       *   <li>lastRow: The index of the last row that has changed.</li>
       *   <li>firstColumn: The model index of the first column that has changed.</li>
       *   <li>lastColumn: The model index of the last column that has changed.</li>
       * </ul>
       */
      "dataChanged": "qx.event.type.Data",

      /**
       * Fired when the meta data changed (the stuff shown in the table header).
       */
      "metaDataChanged": "qx.event.type.Event",

      /**
       * Fired after the table is sorted (but before the metaDataChanged event)
       */
      "sorted": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the number of rows in the model.
       *
       * @abstract
       * @return {Integer} the number of rows.
       */
      getRowCount: function getRowCount() {},

      /**
       *
       * Returns the data of one row. This function may be overridden by models which hold
       * all data of a row in one object. By using this function, clients have a way of
       * quickly retrieving the entire row data.
       *
       * <b>Important:</b>Models which do not have their row data accessible in one object
       * may return null.
       *
       * @param rowIndex {Integer} the model index of the row.
       * @return {Object} the row data as an object or null if the model does not support row data
       *                    objects. The details on the object returned are determined by the model
       *                    implementation only.
       */
      getRowData: function getRowData(rowIndex) {},

      /**
       * Returns the number of columns in the model.
       *
       * @abstract
       * @return {Integer} the number of columns.
       */
      getColumnCount: function getColumnCount() {},

      /**
       * Returns the ID of column. The ID may be used to identify columns
       * independent from their index in the model. E.g. for being aware of added
       * columns when saving the width of a column.
       *
       * @abstract
       * @param columnIndex {Integer} the index of the column.
       * @return {String} the ID of the column.
       */
      getColumnId: function getColumnId(columnIndex) {},

      /**
       * Returns the index of a column.
       *
       * @abstract
       * @param columnId {String} the ID of the column.
       * @return {Integer} the index of the column.
       */
      getColumnIndexById: function getColumnIndexById(columnId) {},

      /**
       * Returns the name of a column. This name will be shown to the user in the
       * table header.
       *
       * @abstract
       * @param columnIndex {Integer} the index of the column.
       * @return {String} the name of the column.
       */
      getColumnName: function getColumnName(columnIndex) {},

      /**
       * Returns whether a column is editable.
       *
       * @param columnIndex {Integer} the column to check.
       * @return {Boolean} whether the column is editable.
       */
      isColumnEditable: function isColumnEditable(columnIndex) {},

      /**
       * Returns whether a column is sortable.
       *
       * @param columnIndex {Integer} the column to check.
       * @return {Boolean} whether the column is sortable.
       */
      isColumnSortable: function isColumnSortable(columnIndex) {},

      /**
       * Sorts the model by a column.
       *
       * @param columnIndex {Integer} the column to sort by.
       * @param ascending {Boolean} whether to sort ascending.
       */
      sortByColumn: function sortByColumn(columnIndex, ascending) {},

      /**
       * Returns the column index the model is sorted by. If the model is not sorted
       * -1 is returned.
       *
       * @return {Integer} the column index the model is sorted by.
       */
      getSortColumnIndex: function getSortColumnIndex() {},

      /**
       * Returns whether the model is sorted ascending.
       *
       * @return {Boolean} whether the model is sorted ascending.
       */
      isSortAscending: function isSortAscending() {},

      /**
       * Prefetches some rows. This is a hint to the model that the specified rows
       * will be read soon.
       *
       * @param firstRowIndex {Integer} the index of first row.
       * @param lastRowIndex {Integer} the index of last row.
       */
      prefetchRows: function prefetchRows(firstRowIndex, lastRowIndex) {},

      /**
       * Returns a cell value by column index.
       *
       * @abstract
       * @param columnIndex {Integer} the index of the column.
       * @param rowIndex {Integer} the index of the row.
       * @return {var} The value of the cell.
       * @see #getValueById
       */
      getValue: function getValue(columnIndex, rowIndex) {},

      /**
       * Returns a cell value by column ID.
       *
       * Whenever you have the choice, use {@link #getValue()} instead,
       * because this should be faster.
       *
       * @param columnId {String} the ID of the column.
       * @param rowIndex {Integer} the index of the row.
       * @return {var} the value of the cell.
       */
      getValueById: function getValueById(columnId, rowIndex) {},

      /**
       * Sets a cell value by column index.
       *
       * @abstract
       * @param columnIndex {Integer} The index of the column.
       * @param rowIndex {Integer} the index of the row.
       * @param value {var} The new value.
       * @see #setValueById
       */
      setValue: function setValue(columnIndex, rowIndex, value) {},

      /**
       * Sets a cell value by column ID.
       *
       * Whenever you have the choice, use {@link #setValue()} instead,
       * because this should be faster.
       *
       * @param columnId {String} The ID of the column.
       * @param rowIndex {Integer} The index of the row.
       * @param value {var} The new value.
       */
      setValueById: function setValueById(columnId, rowIndex, value) {}
    }
  });
  qx.ui.table.ITableModel.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.ITableModel": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * An abstract table model that performs the column handling, so subclasses only
   * need to care for row handling.
   */
  qx.Class.define("qx.ui.table.model.Abstract", {
    type: "abstract",
    extend: qx.core.Object,
    implement: qx.ui.table.ITableModel,
    events: {
      /**
       * Fired when the table data changed (the stuff shown in the table body).
       * The data property of the event will be a map having the following
       * attributes:
       * <ul>
       *   <li>firstRow: The index of the first row that has changed.</li>
       *   <li>lastRow: The index of the last row that has changed.</li>
       *   <li>firstColumn: The model index of the first column that has changed.</li>
       *   <li>lastColumn: The model index of the last column that has changed.</li>
       * </ul>
       *
       * Additionally, if the data changed as a result of rows being removed
       * from the data model, then these additional attributes will be in the
       * data:
       * <ul>
       *   <li>removeStart: The model index of the first row that was removed.</li>
       *   <li>removeCount: The number of rows that were removed.</li>
       * </ul>
       */
      "dataChanged": "qx.event.type.Data",

      /**
       * Fired when the meta data changed (the stuff shown in the table header).
       */
      "metaDataChanged": "qx.event.type.Event",

      /**
       * Fired after the table is sorted (but before the metaDataChanged event)
       */
      "sorted": "qx.event.type.Data"
    },
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__columnIdArr = [];
      this.__columnNameArr = [];
      this.__columnIndexMap = {};
    },
    members: {
      __columnIdArr: null,
      __columnNameArr: null,
      __columnIndexMap: null,
      __internalChange: null,

      /**
       * Initialize the table model <--> table interaction. The table model is
       * passed to the table constructor, but the table model doesn't otherwise
       * know anything about the table nor can it operate on table
       * properties. This function provides the capability for the table model
       * to specify characteristics of the table. It is called when the table
       * model is applied to the table.
       *
       * @param table {qx.ui.table.Table}
       *   The table to which this model is attached
       */
      init: function init(table) {// default implementation has nothing to do
      },

      /**
       * Abstract method
       * @throws {Error} An error if this method is called.
       */
      getRowCount: function getRowCount() {
        throw new Error("getRowCount is abstract");
      },
      getRowData: function getRowData(rowIndex) {
        return null;
      },
      isColumnEditable: function isColumnEditable(columnIndex) {
        return false;
      },
      isColumnSortable: function isColumnSortable(columnIndex) {
        return false;
      },
      sortByColumn: function sortByColumn(columnIndex, ascending) {},
      getSortColumnIndex: function getSortColumnIndex() {
        return -1;
      },
      isSortAscending: function isSortAscending() {
        return true;
      },
      prefetchRows: function prefetchRows(firstRowIndex, lastRowIndex) {},

      /**
       * Abstract method
       *
       * @param columnIndex {Integer} the index of the column
       * @param rowIndex {Integer} the index of the row
       *
       * @throws {Error} An error if this method is called.
       */
      getValue: function getValue(columnIndex, rowIndex) {
        throw new Error("getValue is abstract");
      },
      getValueById: function getValueById(columnId, rowIndex) {
        return this.getValue(this.getColumnIndexById(columnId), rowIndex);
      },

      /**
       * Abstract method
       *
       * @param columnIndex {Integer} index of the column
       * @param rowIndex {Integer} index of the row
       * @param value {var} Value to be set
       *
       * @throws {Error} An error if this method is called.
       */
      setValue: function setValue(columnIndex, rowIndex, value) {
        throw new Error("setValue is abstract");
      },
      setValueById: function setValueById(columnId, rowIndex, value) {
        this.setValue(this.getColumnIndexById(columnId), rowIndex, value);
      },
      // overridden
      getColumnCount: function getColumnCount() {
        return this.__columnIdArr.length;
      },
      // overridden
      getColumnIndexById: function getColumnIndexById(columnId) {
        return this.__columnIndexMap[columnId];
      },
      // overridden
      getColumnId: function getColumnId(columnIndex) {
        return this.__columnIdArr[columnIndex];
      },
      // overridden
      getColumnName: function getColumnName(columnIndex) {
        return this.__columnNameArr[columnIndex];
      },

      /**
       * Sets the column IDs. These IDs may be used internally to identify a
       * column.
       *
       * Note: This will clear previously set column names.
       *
       *
       * @param columnIdArr {String[]} the IDs of the columns.
       * @see #setColumns
       */
      setColumnIds: function setColumnIds(columnIdArr) {
        this.__columnIdArr = columnIdArr; // Create the reverse map

        this.__columnIndexMap = {};

        for (var i = 0; i < columnIdArr.length; i++) {
          this.__columnIndexMap[columnIdArr[i]] = i;
        }

        this.__columnNameArr = new Array(columnIdArr.length); // Inform the listeners

        if (!this.__internalChange) {
          this.fireEvent("metaDataChanged");
        }
      },

      /**
       * Sets the column names. These names will be shown to the user.
       *
       * Note: The column IDs have to be defined before.
       *
       *
       * @param columnNameArr {String[]} the names of the columns.
       * @throws {Error} If the amount of given columns is different from the table.
       * @see #setColumnIds
       */
      setColumnNamesByIndex: function setColumnNamesByIndex(columnNameArr) {
        if (this.__columnIdArr.length != columnNameArr.length) {
          throw new Error("this.__columnIdArr and columnNameArr have different length: " + this.__columnIdArr.length + " != " + columnNameArr.length);
        }

        this.__columnNameArr = columnNameArr; // Inform the listeners

        this.fireEvent("metaDataChanged");
      },

      /**
       * Sets the column names. These names will be shown to the user.
       *
       * Note: The column IDs have to be defined before.
       *
       *
       * @param columnNameMap {Map} a map containing the column IDs as keys and the
       *          column name as values.
       * @see #setColumnIds
       */
      setColumnNamesById: function setColumnNamesById(columnNameMap) {
        this.__columnNameArr = new Array(this.__columnIdArr.length);

        for (var i = 0; i < this.__columnIdArr.length; ++i) {
          this.__columnNameArr[i] = columnNameMap[this.__columnIdArr[i]];
        }
      },

      /**
       * Sets the column names (and optionally IDs)
       *
       * Note: You can not change the _number_ of columns this way.  The number
       *       of columns is highly intertwined in the entire table operation,
       *       and dynamically changing it would require as much work as just
       *       recreating your table.  If you must change the number of columns
       *       in a table then you should remove the table and add a new one.
       *
       * @param columnNameArr {String[]}
       *   The column names. These names will be shown to the user.
       *
       * @param columnIdArr {String[] ? null}
       *   The column IDs. These IDs may be used internally to identify a
       *   column. If null, the column names are used as IDs unless ID values
       *   have already been set. If ID values have already been set, they will
       *   continue to be used if no ID values are explicitly provided here.
       *
       * @throws {Error} If the amount of given columns is different from the table.
       *
       */
      setColumns: function setColumns(columnNameArr, columnIdArr) {
        var bSetIds = this.__columnIdArr.length == 0 || columnIdArr;

        if (columnIdArr == null) {
          if (this.__columnIdArr.length == 0) {
            columnIdArr = columnNameArr;
          } else {
            columnIdArr = this.__columnIdArr;
          }
        }

        if (columnIdArr.length != columnNameArr.length) {
          throw new Error("columnIdArr and columnNameArr have different length: " + columnIdArr.length + " != " + columnNameArr.length);
        }

        if (bSetIds) {
          this.__internalChange = true;
          this.setColumnIds(columnIdArr);
          this.__internalChange = false;
        }

        this.setColumnNamesByIndex(columnNameArr);
      }
    },
    destruct: function destruct() {
      this.__columnIdArr = this.__columnNameArr = this.__columnIndexMap = null;
    }
  });
  qx.ui.table.model.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.model.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A simple table model that provides an API for changing the model data.
   */
  qx.Class.define("qx.ui.table.model.Simple", {
    extend: qx.ui.table.model.Abstract,
    construct: function construct() {
      qx.ui.table.model.Abstract.constructor.call(this);
      this._rowArr = [];
      this.__sortColumnIndex = -1; // Array of objects, each with property "ascending" and "descending"

      this.__sortMethods = [];
      this.__editableColArr = null;
    },
    properties: {
      /**
       * Whether sorting should be case sensitive
       */
      caseSensitiveSorting: {
        check: "Boolean",
        init: true
      }
    },
    statics: {
      /**
       * Default ascending sort method to use if no custom method has been
       * provided.
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @param columnIndex {Integer} the column to be sorted
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorAscending: function _defaultSortComparatorAscending(row1, row2, columnIndex) {
        var obj1 = row1[columnIndex];
        var obj2 = row2[columnIndex];

        if (qx.lang.Type.isNumber(obj1) && qx.lang.Type.isNumber(obj2)) {
          var result = isNaN(obj1) ? isNaN(obj2) ? 0 : 1 : isNaN(obj2) ? -1 : null;

          if (result != null) {
            return result;
          }
        }

        return obj1 > obj2 ? 1 : obj1 == obj2 ? 0 : -1;
      },

      /**
       * Same as the Default ascending sort method but using case insensitivity
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @param columnIndex {Integer} the column to be sorted
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorInsensitiveAscending: function _defaultSortComparatorInsensitiveAscending(row1, row2, columnIndex) {
        var obj1 = row1[columnIndex].toLowerCase ? row1[columnIndex].toLowerCase() : row1[columnIndex];
        var obj2 = row2[columnIndex].toLowerCase ? row2[columnIndex].toLowerCase() : row2[columnIndex];

        if (qx.lang.Type.isNumber(obj1) && qx.lang.Type.isNumber(obj2)) {
          var result = isNaN(obj1) ? isNaN(obj2) ? 0 : 1 : isNaN(obj2) ? -1 : null;

          if (result != null) {
            return result;
          }
        }

        return obj1 > obj2 ? 1 : obj1 == obj2 ? 0 : -1;
      },

      /**
       * Default descending sort method to use if no custom method has been
       * provided.
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @param columnIndex {Integer} the column to be sorted
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorDescending: function _defaultSortComparatorDescending(row1, row2, columnIndex) {
        var obj1 = row1[columnIndex];
        var obj2 = row2[columnIndex];

        if (qx.lang.Type.isNumber(obj1) && qx.lang.Type.isNumber(obj2)) {
          var result = isNaN(obj1) ? isNaN(obj2) ? 0 : 1 : isNaN(obj2) ? -1 : null;

          if (result != null) {
            return result;
          }
        }

        return obj1 < obj2 ? 1 : obj1 == obj2 ? 0 : -1;
      },

      /**
       * Same as the Default descending sort method but using case insensitivity
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @param columnIndex {Integer} the column to be sorted
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorInsensitiveDescending: function _defaultSortComparatorInsensitiveDescending(row1, row2, columnIndex) {
        var obj1 = row1[columnIndex].toLowerCase ? row1[columnIndex].toLowerCase() : row1[columnIndex];
        var obj2 = row2[columnIndex].toLowerCase ? row2[columnIndex].toLowerCase() : row2[columnIndex];

        if (qx.lang.Type.isNumber(obj1) && qx.lang.Type.isNumber(obj2)) {
          var result = isNaN(obj1) ? isNaN(obj2) ? 0 : 1 : isNaN(obj2) ? -1 : null;

          if (result != null) {
            return result;
          }
        }

        return obj1 < obj2 ? 1 : obj1 == obj2 ? 0 : -1;
      }
    },
    members: {
      _rowArr: null,
      __editableColArr: null,
      __sortableColArr: null,
      __sortMethods: null,
      __sortColumnIndex: null,
      __sortAscending: null,
      // overridden
      getRowData: function getRowData(rowIndex) {
        var rowData = this._rowArr[rowIndex];

        if (rowData == null || rowData.originalData == null) {
          return rowData;
        } else {
          return rowData.originalData;
        }
      },

      /**
       * Returns the data of one row as map containing the column IDs as key and
       * the cell values as value. Also the meta data is included.
       *
       * @param rowIndex {Integer} the model index of the row.
       * @return {Map} a Map containing the column values.
       */
      getRowDataAsMap: function getRowDataAsMap(rowIndex) {
        var rowData = this._rowArr[rowIndex];

        if (rowData != null) {
          var map = {}; // get the current set data

          for (var col = 0; col < this.getColumnCount(); col++) {
            map[this.getColumnId(col)] = rowData[col];
          }

          if (rowData.originalData != null) {
            // merge in the meta data
            for (var key in rowData.originalData) {
              if (map[key] == undefined) {
                map[key] = rowData.originalData[key];
              }
            }
          }

          return map;
        } // may be null, which is ok


        return rowData && rowData.originalData ? rowData.originalData : null;
      },

      /**
       * Gets the whole data as an array of maps.
       *
       * Note: Individual items are retrieved by {@link #getRowDataAsMap}.
       * @return {Map[]} Array of row data maps
       */
      getDataAsMapArray: function getDataAsMapArray() {
        var len = this.getRowCount();
        var data = [];

        for (var i = 0; i < len; i++) {
          data.push(this.getRowDataAsMap(i));
        }

        return data;
      },

      /**
       * Sets all columns editable or not editable.
       *
       * @param editable {Boolean} whether all columns are editable.
       */
      setEditable: function setEditable(editable) {
        this.__editableColArr = [];

        for (var col = 0; col < this.getColumnCount(); col++) {
          this.__editableColArr[col] = editable;
        }

        this.fireEvent("metaDataChanged");
      },

      /**
       * Sets whether a column is editable.
       *
       * @param columnIndex {Integer} the column of which to set the editable state.
       * @param editable {Boolean} whether the column should be editable.
       */
      setColumnEditable: function setColumnEditable(columnIndex, editable) {
        if (editable != this.isColumnEditable(columnIndex)) {
          if (this.__editableColArr == null) {
            this.__editableColArr = [];
          }

          this.__editableColArr[columnIndex] = editable;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      isColumnEditable: function isColumnEditable(columnIndex) {
        return this.__editableColArr ? this.__editableColArr[columnIndex] == true : false;
      },

      /**
       * Sets whether a column is sortable.
       *
       * @param columnIndex {Integer} the column of which to set the sortable state.
       * @param sortable {Boolean} whether the column should be sortable.
       */
      setColumnSortable: function setColumnSortable(columnIndex, sortable) {
        if (sortable != this.isColumnSortable(columnIndex)) {
          if (this.__sortableColArr == null) {
            this.__sortableColArr = [];
          }

          this.__sortableColArr[columnIndex] = sortable;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      isColumnSortable: function isColumnSortable(columnIndex) {
        return this.__sortableColArr ? this.__sortableColArr[columnIndex] !== false : true;
      },
      // overridden
      sortByColumn: function sortByColumn(columnIndex, ascending) {
        // NOTE: We use different comparators for ascending and descending,
        //     because comparators should be really fast.
        var comparator;
        var sortMethods = this.__sortMethods[columnIndex];

        if (sortMethods) {
          comparator = ascending ? sortMethods.ascending : sortMethods.descending;
        } else {
          if (this.getCaseSensitiveSorting()) {
            comparator = ascending ? qx.ui.table.model.Simple._defaultSortComparatorAscending : qx.ui.table.model.Simple._defaultSortComparatorDescending;
          } else {
            comparator = ascending ? qx.ui.table.model.Simple._defaultSortComparatorInsensitiveAscending : qx.ui.table.model.Simple._defaultSortComparatorInsensitiveDescending;
          }
        }

        comparator.columnIndex = columnIndex;

        this._rowArr.sort(function (row1, row2) {
          return comparator(row1, row2, columnIndex);
        });

        this.__sortColumnIndex = columnIndex;
        this.__sortAscending = ascending;
        var data = {
          columnIndex: columnIndex,
          ascending: ascending
        };
        this.fireDataEvent("sorted", data);
        this.fireEvent("metaDataChanged");
      },

      /**
       * Specify the methods to use for ascending and descending sorts of a
       * particular column.
       *
       * @param columnIndex {Integer}
       *   The index of the column for which the sort methods are being
       *   provided.
       *
       * @param compare {Function|Map}
       *   If provided as a Function, this is the comparator function to sort in
       *   ascending order. It takes three parameters: the two arrays of row data,
       *   row1 and row2, being compared and the column index sorting was requested 
       *   for. 
       *
       *   For backwards compatability, user-supplied compare functions may still 
       *   take only two parameters, the two arrays of row data, row1 and row2, 
       *   being compared and obtain the column index as arguments.callee.columnIndex. 
       *   This is deprecated, however, as arguments.callee is disallowed in ES5 strict
       *   mode and ES6.
       *
       *   The comparator function must return 1, 0 or -1, when the column in row1
       *   is greater than, equal to, or less than, respectively, the column in
       *   row2.
       *
       *   If this parameter is a Map, it shall have two properties: "ascending"
       *   and "descending". The property value of each is a comparator
       *   function, as described above.
       *
       *   If only the "ascending" function is provided (i.e. this parameter is
       *   a Function, not a Map), then the "descending" function is built
       *   dynamically by passing the two parameters to the "ascending" function
       *   in reversed order. <i>Use of a dynamically-built "descending" function
       *   generates at least one extra function call for each row in the table,
       *   and possibly many more. If the table is expected to have more than
       *   about 1000 rows, you will likely want to provide a map with a custom
       *   "descending" sort function as well as the "ascending" one.</i>
       *
       */
      setSortMethods: function setSortMethods(columnIndex, compare) {
        var methods;

        if (qx.lang.Type.isFunction(compare)) {
          methods = {
            ascending: compare,
            descending: function descending(row1, row2, columnIndex) {
              /* assure backwards compatibility for sort functions using
               * arguments.callee.columnIndex and fix a bug where retreiveing
               * column index via this way did not work for the case where a 
               * single comparator function was used. 
               * Note that arguments.callee is not available in ES5 strict mode and ES6. 
               * See discussion in 
               * https://github.com/qooxdoo/qooxdoo/pull/9499#pullrequestreview-99655182
               */
              compare.columnIndex = columnIndex;
              return compare(row2, row1, columnIndex);
            }
          };
        } else {
          methods = compare;
        }

        this.__sortMethods[columnIndex] = methods;
      },

      /**
       * Returns the sortMethod(s) for a table column.
       *
       * @param columnIndex {Integer} The index of the column for which the sort
       *   methods are being  provided.
       *
       * @return {Map} a map with the two properties "ascending"
       *   and "descending" for the specified column.
       *   The property value of each is a comparator function, as described
       *   in {@link #setSortMethods}.
       */
      getSortMethods: function getSortMethods(columnIndex) {
        return this.__sortMethods[columnIndex];
      },

      /**
       * Clears the sorting.
       */
      clearSorting: function clearSorting() {
        if (this.__sortColumnIndex != -1) {
          this.__sortColumnIndex = -1;
          this.__sortAscending = true;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      getSortColumnIndex: function getSortColumnIndex() {
        return this.__sortColumnIndex;
      },

      /**
       * Set the sort column index
       *
       * WARNING: This should be called only by subclasses with intimate
       *          knowledge of what they are doing!
       *
       * @param columnIndex {Integer} index of the column
       */
      _setSortColumnIndex: function _setSortColumnIndex(columnIndex) {
        this.__sortColumnIndex = columnIndex;
      },
      // overridden
      isSortAscending: function isSortAscending() {
        return this.__sortAscending;
      },

      /**
       * Set whether to sort in ascending order or not.
       *
       * WARNING: This should be called only by subclasses with intimate
       *          knowledge of what they are doing!
       *
       * @param ascending {Boolean}
       *   <i>true</i> for an ascending sort;
       *   <i> false</i> for a descending sort.
       */
      _setSortAscending: function _setSortAscending(ascending) {
        this.__sortAscending = ascending;
      },
      // overridden
      getRowCount: function getRowCount() {
        return this._rowArr.length;
      },
      // overridden
      getValue: function getValue(columnIndex, rowIndex) {
        if (rowIndex < 0 || rowIndex >= this._rowArr.length) {
          throw new Error("this._rowArr out of bounds: " + rowIndex + " (0.." + this._rowArr.length + ")");
        }

        return this._rowArr[rowIndex][columnIndex];
      },
      // overridden
      setValue: function setValue(columnIndex, rowIndex, value) {
        if (this._rowArr[rowIndex][columnIndex] != value) {
          this._rowArr[rowIndex][columnIndex] = value; // Inform the listeners

          if (this.hasListener("dataChanged")) {
            var data = {
              firstRow: rowIndex,
              lastRow: rowIndex,
              firstColumn: columnIndex,
              lastColumn: columnIndex
            };
            this.fireDataEvent("dataChanged", data);
          }

          if (columnIndex == this.__sortColumnIndex) {
            this.clearSorting();
          }
        }
      },

      /**
       * Sets the whole data in a bulk.
       *
       * @param rowArr {var[][]} An array containing an array for each row. Each
       *          row-array contains the values in that row in the order of the columns
       *          in this model.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      setData: function setData(rowArr, clearSorting) {
        this._rowArr = rowArr; // Inform the listeners

        if (this.hasListener("dataChanged")) {
          var data = {
            firstRow: 0,
            lastRow: rowArr.length - 1,
            firstColumn: 0,
            lastColumn: this.getColumnCount() - 1
          };
          this.fireDataEvent("dataChanged", data);
        }

        if (clearSorting !== false) {
          this.clearSorting();
        }
      },

      /**
       * Returns the data of this model.
       *
       * Warning: Do not alter this array! If you want to change the data use
       * {@link #setData}, {@link #setDataAsMapArray} or {@link #setValue} instead.
       *
       * @return {var[][]} An array containing an array for each row. Each
       *           row-array contains the values in that row in the order of the columns
       *           in this model.
       */
      getData: function getData() {
        return this._rowArr;
      },

      /**
       * Sets the whole data in a bulk.
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *        row-map contains the column IDs as key and the cell values as value.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      setDataAsMapArray: function setDataAsMapArray(mapArr, rememberMaps, clearSorting) {
        this.setData(this._mapArray2RowArr(mapArr, rememberMaps), clearSorting);
      },

      /**
       * Adds some rows to the model.
       *
       * Warning: The given array will be altered!
       *
       * @param rowArr {var[][]} An array containing an array for each row. Each
       *          row-array contains the values in that row in the order of the columns
       *          in this model.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *          the rows are appended to the end.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      addRows: function addRows(rowArr, startIndex, clearSorting) {
        if (startIndex == null) {
          startIndex = this._rowArr.length;
        } // Prepare the rowArr so it can be used for apply


        rowArr.splice(0, 0, startIndex, 0); // Insert the new rows

        Array.prototype.splice.apply(this._rowArr, rowArr); // Inform the listeners

        var data = {
          firstRow: startIndex,
          lastRow: this._rowArr.length - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1
        };
        this.fireDataEvent("dataChanged", data);

        if (clearSorting !== false) {
          this.clearSorting();
        }
      },

      /**
       * Adds some rows to the model.
       *
       * Warning: The given array (mapArr) will be altered!
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *        row-map contains the column IDs as key and the cell values as value.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *        the rows are appended to the end.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      addRowsAsMapArray: function addRowsAsMapArray(mapArr, startIndex, rememberMaps, clearSorting) {
        this.addRows(this._mapArray2RowArr(mapArr, rememberMaps), startIndex, clearSorting);
      },

      /**
       * Sets rows in the model. The rows overwrite the old rows starting at
       * <code>startIndex</code> to <code>startIndex+rowArr.length</code>.
       *
       * Warning: The given array will be altered!
       *
       * @param rowArr {var[][]} An array containing an array for each row. Each
       *          row-array contains the values in that row in the order of the columns
       *          in this model.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *          the rows are set from the beginning (0).
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      setRows: function setRows(rowArr, startIndex, clearSorting) {
        if (startIndex == null) {
          startIndex = 0;
        } // Prepare the rowArr so it can be used for apply


        rowArr.splice(0, 0, startIndex, rowArr.length); // Replace rows

        Array.prototype.splice.apply(this._rowArr, rowArr); // Inform the listeners

        var data = {
          firstRow: startIndex,
          lastRow: this._rowArr.length - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1
        };
        this.fireDataEvent("dataChanged", data);

        if (clearSorting !== false) {
          this.clearSorting();
        }
      },

      /**
       * Set rows in the model. The rows overwrite the old rows starting at
       * <code>startIndex</code> to <code>startIndex+rowArr.length</code>.
       *
       * Warning: The given array (mapArr) will be altered!
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *        row-map contains the column IDs as key and the cell values as value.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *        the rows are appended to the end.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      setRowsAsMapArray: function setRowsAsMapArray(mapArr, startIndex, rememberMaps, clearSorting) {
        this.setRows(this._mapArray2RowArr(mapArr, rememberMaps), startIndex, clearSorting);
      },

      /**
       * Removes some rows from the model.
       *
       * @param startIndex {Integer} the index of the first row to remove.
       * @param howMany {Integer} the number of rows to remove.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      removeRows: function removeRows(startIndex, howMany, clearSorting) {
        this._rowArr.splice(startIndex, howMany); // Inform the listeners


        var data = {
          firstRow: startIndex,
          lastRow: this._rowArr.length - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1,
          removeStart: startIndex,
          removeCount: howMany
        };
        this.fireDataEvent("dataChanged", data);

        if (clearSorting !== false) {
          this.clearSorting();
        }
      },

      /**
       * Creates an array of maps to an array of arrays.
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *          row-map contains the column IDs as key and the cell values as value.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @return {var[][]} An array containing an array for each row. Each
       *           row-array contains the values in that row in the order of the columns
       *           in this model.
       */
      _mapArray2RowArr: function _mapArray2RowArr(mapArr, rememberMaps) {
        var rowCount = mapArr.length;
        var columnCount = this.getColumnCount();
        var dataArr = new Array(rowCount);
        var columnArr;

        for (var i = 0; i < rowCount; ++i) {
          columnArr = [];

          if (rememberMaps) {
            columnArr.originalData = mapArr[i];
          }

          for (var j = 0; j < columnCount; ++j) {
            columnArr[j] = mapArr[i][this.getColumnId(j)];
          }

          dataArr[i] = columnArr;
        }

        return dataArr;
      }
    },
    destruct: function destruct() {
      this._rowArr = this.__editableColArr = this.__sortMethods = this.__sortableColArr = null;
    }
  });
  qx.ui.table.model.Simple.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MDragDropScrolling": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.container.Composite": {
        "construct": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.table.rowrenderer.Default": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.ui.table.columnmenu.Button": {},
      "qx.ui.table.selection.Manager": {},
      "qx.ui.table.selection.Model": {},
      "qx.ui.table.columnmodel.Basic": {},
      "qx.ui.table.pane.Pane": {},
      "qx.ui.table.pane.Header": {},
      "qx.ui.table.pane.Scroller": {},
      "qx.ui.table.pane.Model": {},
      "qx.ui.basic.Label": {},
      "qx.ui.table.model.Simple": {},
      "qx.event.Registration": {},
      "qx.log.Logger": {},
      "qx.ui.table.pane.FocusIndicator": {},
      "qx.lang.Number": {},
      "qx.event.Timer": {},
      "qx.core.Assert": {},
      "qx.ui.table.IColumnMenuItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Table
   *
   * A detailed description can be found in the package description
   * {@link qx.ui.table}.
   *
   * @childControl statusbar {qx.ui.basic.Label} label to show the status of the table
   * @childControl column-button {qx.ui.table.columnmenu.Button} button to open the column menu
   */
  qx.Class.define("qx.ui.table.Table", {
    extend: qx.ui.core.Widget,
    include: qx.ui.core.MDragDropScrolling,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param tableModel {qx.ui.table.ITableModel ? null}
     *   The table model to read the data from.
     *
     * @param custom {Map ? null}
     *   A map provided to override the various supplemental classes allocated
     *   within this constructor.  Each property must be a function which
     *   returns an object instance, as indicated by shown the defaults listed
     *   here:
     *
     *   <dl>
     *     <dt>initiallyHiddenColumns</dt>
     *       <dd>
     *         {Array?}
     *         A list of column numbers that should be initially invisible. Any
     *         column not mentioned will be initially visible, and if no array
     *         is provided, all columns will be initially visible.
     *       </dd>
     *     <dt>selectionManager</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.selection.Manager(obj);
     *         }
     *       </pre></dd>
     *     <dt>selectionModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.selection.Model(obj);
     *         }
     *       </pre></dd>
     *     <dt>tableColumnModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.columnmodel.Basic(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Model(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePane</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Pane(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneHeader</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Header(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneScroller</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Scroller(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Model(obj);
     *         }
     *       </pre></dd>
     *     <dt>columnMenu</dt>
     *       <dd><pre class='javascript'>
     *         function()
     *         {
     *           return new qx.ui.table.columnmenu.Button();
     *         }
     *       </pre></dd>
     *   </dl>
     */
    construct: function construct(tableModel, custom) {
      qx.ui.core.Widget.constructor.call(this); //
      // Use default objects if custom objects are not specified
      //

      if (!custom) {
        custom = {};
      }

      if (custom.initiallyHiddenColumns) {
        this.setInitiallyHiddenColumns(custom.initiallyHiddenColumns);
      }

      if (custom.selectionManager) {
        this.setNewSelectionManager(custom.selectionManager);
      }

      if (custom.selectionModel) {
        this.setNewSelectionModel(custom.selectionModel);
      }

      if (custom.tableColumnModel) {
        this.setNewTableColumnModel(custom.tableColumnModel);
      }

      if (custom.tablePane) {
        this.setNewTablePane(custom.tablePane);
      }

      if (custom.tablePaneHeader) {
        this.setNewTablePaneHeader(custom.tablePaneHeader);
      }

      if (custom.tablePaneScroller) {
        this.setNewTablePaneScroller(custom.tablePaneScroller);
      }

      if (custom.tablePaneModel) {
        this.setNewTablePaneModel(custom.tablePaneModel);
      }

      if (custom.columnMenu) {
        this.setNewColumnMenu(custom.columnMenu);
      }

      this._setLayout(new qx.ui.layout.VBox()); // Create the child widgets


      this.__scrollerParent = new qx.ui.container.Composite(new qx.ui.layout.HBox());

      this._add(this.__scrollerParent, {
        flex: 1
      }); // Allocate a default data row renderer


      this.setDataRowRenderer(new qx.ui.table.rowrenderer.Default(this)); // Create the models

      this.__selectionManager = this.getNewSelectionManager()(this);
      this.setSelectionModel(this.getNewSelectionModel()(this));
      this.setTableModel(tableModel || this.getEmptyTableModel()); // create the main meta column

      this.setMetaColumnCounts([-1]); // Make focusable

      this.setTabIndex(1);
      this.addListener("keydown", this._onKeyDown);
      this.addListener("focus", this._onFocusChanged);
      this.addListener("blur", this._onFocusChanged); // attach the resize listener to the last child of the layout. This
      // ensures that all other children are laid out before

      var spacer = new qx.ui.core.Widget().set({
        height: 0
      });

      this._add(spacer);

      spacer.addListener("resize", this._onResize, this);
      this.__focusedCol = null;
      this.__focusedRow = null; // add an event listener which updates the table content on locale change

      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      }
      this.initStatusBarVisible(); // If the table model has an init() method...

      tableModel = this.getTableModel();

      if (tableModel.init && typeof tableModel.init == "function") {
        // ... then call it now to allow the table model to affect table
        // properties.
        tableModel.init(this);
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Dispatched before adding the column list to the column visibility menu.
       * The event data is a map with two properties: table and menu.  Listeners
       * may add additional items to the menu, which appear at the top of the
       * menu.
       */
      "columnVisibilityMenuCreateStart": "qx.event.type.Data",

      /**
       * Dispatched after adding the column list to the column visibility menu.
       * The event data is a map with two properties: table and menu.  Listeners
       * may add additional items to the menu, which appear at the bottom of the
       * menu.
       */
      "columnVisibilityMenuCreateEnd": "qx.event.type.Data",

      /**
       * Dispatched when the width of the table has changed.
       */
      "tableWidthChanged": "qx.event.type.Event",

      /**
       * Dispatched when updating scrollbars discovers that a vertical scrollbar
       * is needed when it previously was not, or vice versa.  The data is a
       * boolean indicating whether a vertical scrollbar is now being used.
       */
      "verticalScrollBarChanged": "qx.event.type.Data",

      /**
       * Dispatched when a data cell has been tapped.
       */
      "cellTap": "qx.ui.table.pane.CellEvent",

      /**
       * Dispatched when a data cell has been tapped.
       */
      "cellDbltap": "qx.ui.table.pane.CellEvent",

      /**
       * Dispatched when the context menu is needed in a data cell
       */
      "cellContextmenu": "qx.ui.table.pane.CellEvent",

      /**
       * Dispatched after a cell editor is flushed.
       *
       * The data is a map containing this properties:
       * <ul>
       *   <li>row</li>
       *   <li>col</li>
       *   <li>value</li>
       *   <li>oldValue</li>
       * </ul>
       */
      "dataEdited": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** Events that must be redirected to the scrollers. */
      __redirectEvents: {
        cellTap: 1,
        cellDbltap: 1,
        cellContextmenu: 1
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "table"
      },
      focusable: {
        refine: true,
        init: true
      },
      minWidth: {
        refine: true,
        init: 50
      },

      /**
       * The list of columns that are initially hidden. This property is set by
       * the constructor, from the value received in
       * custom.initiallyHiddenColumns, and is only used when a column model is
       * initialized. It can be of great benefit in tables with numerous columns
       * where most are not initially visible. The process of creating the
       * headers for all of the columns, only to have those columns discarded
       * shortly thereafter when setColumnVisibility(false) is called, is a
       * waste of (significant, in some browsers) time. Specifying the
       * non-visible columns at constructor time can therefore avoid the initial
       * creation of all of those superfluous widgets.
       */
      initiallyHiddenColumns: {
        init: null
      },

      /**
       * Whether the widget contains content which may be selected by the user.
       *
       * If the value set to <code>true</code> the native browser selection can
       * be used for text selection. But it is normally useful for
       * forms fields, longer texts/documents, editors, etc.
       *
       * Note: This has no effect on Table!
       */
      selectable: {
        refine: true,
        init: false
      },

      /** The selection model. */
      selectionModel: {
        check: "qx.ui.table.selection.Model",
        apply: "_applySelectionModel",
        event: "changeSelectionModel"
      },

      /** The table model. */
      tableModel: {
        check: "qx.ui.table.ITableModel",
        apply: "_applyTableModel",
        event: "changeTableModel"
      },

      /** The height of the table rows. */
      rowHeight: {
        check: "Number",
        init: 20,
        apply: "_applyRowHeight",
        event: "changeRowHeight",
        themeable: true
      },

      /**
       * Force line height to match row height.  May be disabled if cell
       * renderers being used wish to render multiple lines of data within a
       * cell.  (With the default setting, all but the first of multiple lines
       * of data will not be visible.)
       */
      forceLineHeight: {
        check: "Boolean",
        init: true
      },

      /**
       *  Whether the header cells are visible. When setting this to false,
       *  you'll likely also want to set the {#columnVisibilityButtonVisible}
       *  property to false as well, to entirely remove the header row.
       */
      headerCellsVisible: {
        check: "Boolean",
        init: true,
        apply: "_applyHeaderCellsVisible",
        themeable: true
      },

      /** The height of the header cells. */
      headerCellHeight: {
        check: "Integer",
        init: 16,
        apply: "_applyHeaderCellHeight",
        event: "changeHeaderCellHeight",
        nullable: true,
        themeable: true
      },

      /** Whether to show the status bar */
      statusBarVisible: {
        check: "Boolean",
        init: true,
        apply: "_applyStatusBarVisible"
      },

      /** The Statusbartext, set it, if you want some more Information */
      additionalStatusBarText: {
        nullable: true,
        init: null,
        apply: "_applyAdditionalStatusBarText"
      },

      /** Whether to show the column visibility button */
      columnVisibilityButtonVisible: {
        check: "Boolean",
        init: true,
        apply: "_applyColumnVisibilityButtonVisible",
        themeable: true
      },

      /**
       * @type {Integer[]} The number of columns per meta column. If the last array entry is -1,
       * this meta column will get the remaining columns.
       */
      metaColumnCounts: {
        check: "Object",
        apply: "_applyMetaColumnCounts"
      },

      /**
       * Whether the focus should moved when the pointer is moved over a cell. If false
       * the focus is only moved on pointer taps.
       */
      focusCellOnPointerMove: {
        check: "Boolean",
        init: false,
        apply: "_applyFocusCellOnPointerMove"
      },

      /**
       * Whether row focus change by keyboard also modifies selection
       */
      rowFocusChangeModifiesSelection: {
        check: "Boolean",
        init: true
      },

      /**
       * Whether the cell focus indicator should be shown
       */
      showCellFocusIndicator: {
        check: "Boolean",
        init: true,
        apply: "_applyShowCellFocusIndicator"
      },

      /**
       * By default, the "cellContextmenu" event is fired only when a data cell
       * is right-clicked. It is not fired when a right-click occurs in the
       * empty area of the table below the last data row. By turning on this
       * property, "cellContextMenu" events will also be generated when a
       * right-click occurs in that empty area. In such a case, row identifier
       * in the event data will be null, so event handlers can check (row ===
       * null) to handle this case.
       */
      contextMenuFromDataCellsOnly: {
        check: "Boolean",
        init: true,
        apply: "_applyContextMenuFromDataCellsOnly"
      },

      /**
       * Whether the table should keep the first visible row complete. If set to false,
       * the first row may be rendered partial, depending on the vertical scroll value.
       */
      keepFirstVisibleRowComplete: {
        check: "Boolean",
        init: true,
        apply: "_applyKeepFirstVisibleRowComplete"
      },

      /**
       * Whether the table cells should be updated when only the selection or the
       * focus changed. This slows down the table update but allows to react on a
       * changed selection or a changed focus in a cell renderer.
       */
      alwaysUpdateCells: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether to reset the selection when a header cell is tapped. Since
       * most data models do not have provisions to retain a selection after
       * sorting, the default is to reset the selection in this case. Some data
       * models, however, do have the capability to retain the selection, so
       * when using those, this property should be set to false.
       */
      resetSelectionOnHeaderTap: {
        check: "Boolean",
        init: true,
        apply: "_applyResetSelectionOnHeaderTap"
      },

      /** The renderer to use for styling the rows. */
      dataRowRenderer: {
        check: "qx.ui.table.IRowRenderer",
        init: null,
        nullable: true,
        event: "changeDataRowRenderer"
      },

      /**
       * A function to call when before modal cell editor is opened.
       *
       * @signature function(cellEditor, cellInfo)
       *
       * @param cellEditor {qx.ui.window.Window}
       *   The modal window which has been created for this cell editor
       *
       * @param cellInfo {Map}
       *   Information about the cell for which this cell editor was created.
       *   It contains the following properties:
       *       col, row, xPos, value
       *
       */
      modalCellEditorPreOpenFunction: {
        check: "Function",
        init: null,
        nullable: true
      },

      /**
       * By default, all Scrollers' (meta-columns') horizontal scrollbars are
       * shown if any one is required. Allow not showing any that are not
       * required.
       */
      excludeScrollerScrollbarsIfNotNeeded: {
        check: "Boolean",
        init: false,
        nullable: false
      },

      /**
       * A function to instantiate a new column menu button.
       */
      newColumnMenu: {
        check: "Function",
        init: function init() {
          return new qx.ui.table.columnmenu.Button();
        }
      },

      /**
       * A function to instantiate a selection manager.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property must
       * be set before calling the Table constructor.
       */
      newSelectionManager: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.table.selection.Manager(obj);
        }
      },

      /**
       * A function to instantiate a selection model.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property must
       * be set before calling the Table constructor.
       */
      newSelectionModel: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.table.selection.Model(obj);
        }
      },

      /**
       * A function to instantiate a table column model.  This allows subclasses
       * of Table to subclass this internal class.  To take effect, this
       * property must be set before calling the Table constructor.
       */
      newTableColumnModel: {
        check: "Function",
        init: function init(table) {
          return new qx.ui.table.columnmodel.Basic(table);
        }
      },

      /**
       * A function to instantiate a table pane.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property
       * must be set before calling the Table constructor.
       */
      newTablePane: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.table.pane.Pane(obj);
        }
      },

      /**
       * A function to instantiate a table pane.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property
       * must be set before calling the Table constructor.
       */
      newTablePaneHeader: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.table.pane.Header(obj);
        }
      },

      /**
       * A function to instantiate a table pane scroller.  this allows
       * subclasses of Table to subclass this internal class.  To take effect,
       * this property must be set before calling the Table constructor.
       */
      newTablePaneScroller: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.table.pane.Scroller(obj);
        }
      },

      /**
       * A function to instantiate a table pane model.  this allows subclasses
       * of Table to subclass this internal class.  To take effect, this
       * property must be set before calling the Table constructor.
       */
      newTablePaneModel: {
        check: "Function",
        init: function init(columnModel) {
          return new qx.ui.table.pane.Model(columnModel);
        }
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __focusedCol: null,
      __focusedRow: null,
      __scrollerParent: null,
      __selectionManager: null,
      __additionalStatusBarText: null,
      __lastRowCount: null,
      __internalChange: null,
      __columnMenuButtons: null,
      __columnModel: null,
      __emptyTableModel: null,
      __hadVerticalScrollBar: null,
      __timer: null,
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "statusbar":
            control = new qx.ui.basic.Label();
            control.set({
              allowGrowX: true
            });

            this._add(control);

            break;

          case "column-button":
            control = this.getNewColumnMenu()();
            control.set({
              focusable: false
            }); // Create the initial menu too

            var menu = control.factory("menu", {
              table: this
            }); // Add a listener to initialize the column menu when it becomes visible

            menu.addListener("appear", this._initColumnMenu, this);
            break;
        }

        return control || qx.ui.table.Table.prototype._createChildControlImpl.base.call(this, id);
      },
      // property modifier
      _applySelectionModel: function _applySelectionModel(value, old) {
        this.__selectionManager.setSelectionModel(value);

        if (old != null) {
          old.removeListener("changeSelection", this._onSelectionChanged, this);
        }

        value.addListener("changeSelection", this._onSelectionChanged, this);
      },
      // property modifier
      _applyRowHeight: function _applyRowHeight(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].updateVerScrollBarMaximum();
        }
      },
      // property modifier
      _applyHeaderCellsVisible: function _applyHeaderCellsVisible(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          if (value) {
            scrollerArr[i]._showChildControl("header");
          } else {
            scrollerArr[i]._excludeChildControl("header");
          }
        } // also hide the column visibility button


        if (this.getColumnVisibilityButtonVisible()) {
          this._applyColumnVisibilityButtonVisible(value);
        }
      },
      // property modifier
      _applyHeaderCellHeight: function _applyHeaderCellHeight(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].getHeader().setHeight(value);
        }
      },

      /**
       * Get an empty table model instance to use for this table. Use this table
       * to configure the table with no table model.
       *
       * @return {qx.ui.table.ITableModel} The empty table model
       */
      getEmptyTableModel: function getEmptyTableModel() {
        if (!this.__emptyTableModel) {
          this.__emptyTableModel = new qx.ui.table.model.Simple();

          this.__emptyTableModel.setColumns([]);

          this.__emptyTableModel.setData([]);
        }

        return this.__emptyTableModel;
      },
      // property modifier
      _applyTableModel: function _applyTableModel(value, old) {
        this.getTableColumnModel().init(value.getColumnCount(), this);

        if (old != null) {
          old.removeListener("metaDataChanged", this._onTableModelMetaDataChanged, this);
          old.removeListener("dataChanged", this._onTableModelDataChanged, this);
        }

        value.addListener("metaDataChanged", this._onTableModelMetaDataChanged, this);
        value.addListener("dataChanged", this._onTableModelDataChanged, this); // Update the status bar

        this._updateStatusBar();

        this._updateTableData(0, value.getRowCount(), 0, value.getColumnCount());

        this._onTableModelMetaDataChanged(); // If the table model has an init() method, call it. We don't, however,
        // call it if this is the initial setting of the table model, as the
        // scrollers are not yet initialized. In that case, the init method is
        // called explicitly by the Table constructor.


        if (old && value.init && typeof value.init == "function") {
          value.init(this);
        }
      },

      /**
       * Get the The table column model.
       *
       * @return {qx.ui.table.columnmodel.Basic} The table's column model
       */
      getTableColumnModel: function getTableColumnModel() {
        if (!this.__columnModel) {
          var columnModel = this.__columnModel = this.getNewTableColumnModel()(this);
          columnModel.addListener("visibilityChanged", this._onColVisibilityChanged, this);
          columnModel.addListener("widthChanged", this._onColWidthChanged, this);
          columnModel.addListener("orderChanged", this._onColOrderChanged, this); // Get the current table model

          var tableModel = this.getTableModel();
          columnModel.init(tableModel.getColumnCount(), this); // Reset the table column model in each table pane model

          var scrollerArr = this._getPaneScrollerArr();

          for (var i = 0; i < scrollerArr.length; i++) {
            var paneScroller = scrollerArr[i];
            var paneModel = paneScroller.getTablePaneModel();
            paneModel.setTableColumnModel(columnModel);
          }
        }

        return this.__columnModel;
      },
      // property modifier
      _applyStatusBarVisible: function _applyStatusBarVisible(value, old) {
        if (value) {
          this._showChildControl("statusbar");
        } else {
          this._excludeChildControl("statusbar");
        }

        if (value) {
          this._updateStatusBar();
        }
      },
      // property modifier
      _applyAdditionalStatusBarText: function _applyAdditionalStatusBarText(value, old) {
        this.__additionalStatusBarText = value;

        this._updateStatusBar();
      },
      // property modifier
      _applyColumnVisibilityButtonVisible: function _applyColumnVisibilityButtonVisible(value, old) {
        if (value) {
          this._showChildControl("column-button");
        } else {
          this._excludeChildControl("column-button");
        }
      },
      // property modifier
      _applyMetaColumnCounts: function _applyMetaColumnCounts(value, old) {
        var metaColumnCounts = value;

        var scrollerArr = this._getPaneScrollerArr();

        var handlers = {};

        if (value > old) {
          // Save event listeners on the redirected events so we can re-apply
          // them to new scrollers.
          var manager = qx.event.Registration.getManager(scrollerArr[0]);

          for (var evName in qx.ui.table.Table.__redirectEvents) {
            handlers[evName] = {};
            handlers[evName].capture = manager.getListeners(scrollerArr[0], evName, true);
            handlers[evName].bubble = manager.getListeners(scrollerArr[0], evName, false);
          }
        } // Remove the panes not needed any more


        this._cleanUpMetaColumns(metaColumnCounts.length); // Update the old panes


        var leftX = 0;

        for (var i = 0; i < scrollerArr.length; i++) {
          var paneScroller = scrollerArr[i];
          var paneModel = paneScroller.getTablePaneModel();
          paneModel.setFirstColumnX(leftX);
          paneModel.setMaxColumnCount(metaColumnCounts[i]);
          leftX += metaColumnCounts[i];
        } // Add the new panes


        if (metaColumnCounts.length > scrollerArr.length) {
          var columnModel = this.getTableColumnModel();

          for (var i = scrollerArr.length; i < metaColumnCounts.length; i++) {
            var paneModel = this.getNewTablePaneModel()(columnModel);
            paneModel.setFirstColumnX(leftX);
            paneModel.setMaxColumnCount(metaColumnCounts[i]);
            leftX += metaColumnCounts[i];
            var paneScroller = this.getNewTablePaneScroller()(this);
            paneScroller.setTablePaneModel(paneModel); // Register event listener for vertical scrolling

            paneScroller.addListener("changeScrollY", this._onScrollY, this); // Apply redirected events to this new scroller

            for (evName in qx.ui.table.Table.__redirectEvents) {
              // On first setting of meta columns (constructing phase), there
              // are no handlers to deal with yet.
              if (!handlers[evName]) {
                break;
              }

              if (handlers[evName].capture && handlers[evName].capture.length > 0) {
                var capture = handlers[evName].capture;

                for (var j = 0; j < capture.length; j++) {
                  // Determine what context to use.  If the context does not
                  // exist, we assume that the context is this table.  If it
                  // does exist and it equals the first pane scroller (from
                  // which we retrieved the listeners) then set the context
                  // to be this new pane scroller.  Otherwise leave the context
                  // as it was set.
                  var context = capture[j].context;

                  if (!context) {
                    context = this;
                  } else if (context == scrollerArr[0]) {
                    context = paneScroller;
                  }

                  paneScroller.addListener(evName, capture[j].handler, context, true);
                }
              }

              if (handlers[evName].bubble && handlers[evName].bubble.length > 0) {
                var bubble = handlers[evName].bubble;

                for (var j = 0; j < bubble.length; j++) {
                  // Determine what context to use.  If the context does not
                  // exist, we assume that the context is this table.  If it
                  // does exist and it equals the first pane scroller (from
                  // which we retrieved the listeners) then set the context
                  // to be this new pane scroller.  Otherwise leave the context
                  // as it was set.
                  var context = bubble[j].context;

                  if (!context) {
                    context = this;
                  } else if (context == scrollerArr[0]) {
                    context = paneScroller;
                  }

                  paneScroller.addListener(evName, bubble[j].handler, context, false);
                }
              }
            } // last meta column is flexible


            var flex = i == metaColumnCounts.length - 1 ? 1 : 0;

            this.__scrollerParent.add(paneScroller, {
              flex: flex
            });

            scrollerArr = this._getPaneScrollerArr();
          }
        } // Update all meta columns


        for (var i = 0; i < scrollerArr.length; i++) {
          var paneScroller = scrollerArr[i];
          var isLast = i == scrollerArr.length - 1; // Set the right header height

          paneScroller.getHeader().setHeight(this.getHeaderCellHeight()); // Put the column visibility button in the top right corner of the last meta column

          paneScroller.setTopRightWidget(isLast ? this.getChildControl("column-button") : null);
        }

        if (!this.isColumnVisibilityButtonVisible()) {
          this._excludeChildControl("column-button");
        }

        this._updateScrollerWidths();

        this._updateScrollBarVisibility();
      },
      // property modifier
      _applyFocusCellOnPointerMove: function _applyFocusCellOnPointerMove(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].setFocusCellOnPointerMove(value);
        }
      },
      // property modifier
      _applyShowCellFocusIndicator: function _applyShowCellFocusIndicator(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].setShowCellFocusIndicator(value);
        }
      },
      // property modifier
      _applyContextMenuFromDataCellsOnly: function _applyContextMenuFromDataCellsOnly(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].setContextMenuFromDataCellsOnly(value);
        }
      },
      // property modifier
      _applyKeepFirstVisibleRowComplete: function _applyKeepFirstVisibleRowComplete(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onKeepFirstVisibleRowCompleteChanged();
        }
      },
      // property modifier
      _applyResetSelectionOnHeaderTap: function _applyResetSelectionOnHeaderTap(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].setResetSelectionOnHeaderTap(value);
        }
      },

      /**
       * Returns the selection manager.
       *
       * @return {qx.ui.table.selection.Manager} the selection manager.
       */
      getSelectionManager: function getSelectionManager() {
        return this.__selectionManager;
      },

      /**
       * Returns an array containing all TablePaneScrollers in this table.
       *
       * @return {qx.ui.table.pane.Scroller[]} all TablePaneScrollers in this table.
       */
      _getPaneScrollerArr: function _getPaneScrollerArr() {
        return this.__scrollerParent.getChildren();
      },

      /**
       * Returns a TablePaneScroller of this table.
       *
       * @param metaColumn {Integer} the meta column to get the TablePaneScroller for.
       * @return {qx.ui.table.pane.Scroller} the qx.ui.table.pane.Scroller.
       */
      getPaneScroller: function getPaneScroller(metaColumn) {
        return this._getPaneScrollerArr()[metaColumn];
      },

      /**
       * Cleans up the meta columns.
       *
       * @param fromMetaColumn {Integer} the first meta column to clean up. All following
       *      meta columns will be cleaned up, too. All previous meta columns will
       *      stay unchanged. If 0 all meta columns will be cleaned up.
       */
      _cleanUpMetaColumns: function _cleanUpMetaColumns(fromMetaColumn) {
        var scrollerArr = this._getPaneScrollerArr();

        if (scrollerArr != null) {
          for (var i = scrollerArr.length - 1; i >= fromMetaColumn; i--) {
            scrollerArr[i].destroy();
          }
        }
      },

      /**
       * Event handler. Called when the locale has changed.
       *
       * @param evt {Event} the event.
       */
      _onChangeLocale: function _onChangeLocale(evt) {
        this.updateContent();

        this._updateStatusBar();
      },
      // overridden
      _onChangeTheme: function _onChangeTheme() {
        qx.ui.table.Table.prototype._onChangeTheme.base.call(this);

        this.getDataRowRenderer().initThemeValues();
        this.updateContent();

        this._updateStatusBar();
      },

      /**
       * Event handler. Called when the selection has changed.
       *
       * @param evt {Map} the event.
       */
      _onSelectionChanged: function _onSelectionChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onSelectionChanged();
        }

        this._updateStatusBar();
      },

      /**
       * Event handler. Called when the table model meta data has changed.
       *
       * @param evt {Map} the event.
       */
      _onTableModelMetaDataChanged: function _onTableModelMetaDataChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onTableModelMetaDataChanged();
        }

        this._updateStatusBar();
      },

      /**
       * Event handler. Called when the table model data has changed.
       *
       * @param evt {Map} the event.
       */
      _onTableModelDataChanged: function _onTableModelDataChanged(evt) {
        var data = evt.getData();

        this._updateTableData(data.firstRow, data.lastRow, data.firstColumn, data.lastColumn, data.removeStart, data.removeCount);
      },
      // overridden
      _onContextMenuOpen: function _onContextMenuOpen(e) {// This is Widget's context menu handler which typically retrieves
        // and displays the menu as soon as it receives a "contextmenu" event.
        // We want to allow the cellContextmenu handler to create the menu,
        // so we'll override this method with a null one, and do the menu
        // placement and display handling in our _onContextMenu method.
      },

      /**
       * To update the table if the table model has changed and remove selection.
       *
       * @param firstRow {Integer} The index of the first row that has changed.
       * @param lastRow {Integer} The index of the last row that has changed.
       * @param firstColumn {Integer} The model index of the first column that has changed.
       * @param lastColumn {Integer} The model index of the last column that has changed.
       * @param removeStart {Integer ? null} The first index of the interval (including), to remove selection.
       * @param removeCount {Integer ? null} The count of the interval, to remove selection.
       */
      _updateTableData: function _updateTableData(firstRow, lastRow, firstColumn, lastColumn, removeStart, removeCount) {
        var scrollerArr = this._getPaneScrollerArr(); // update selection if rows were removed


        if (removeCount) {
          this.getSelectionModel().removeSelectionInterval(removeStart, removeStart + removeCount - 1, true); // remove focus if the focused row has been removed

          if (this.__focusedRow >= removeStart && this.__focusedRow < removeStart + removeCount) {
            this.setFocusedCell();
          }
        }

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onTableModelDataChanged(firstRow, lastRow, firstColumn, lastColumn);
        }

        var rowCount = this.getTableModel().getRowCount();

        if (rowCount != this.__lastRowCount) {
          this.__lastRowCount = rowCount;

          this._updateScrollBarVisibility();

          this._updateStatusBar();
        }
      },

      /**
       * Event handler. Called when a TablePaneScroller has been scrolled vertically.
       *
       * @param evt {Map} the event.
       */
      _onScrollY: function _onScrollY(evt) {
        if (!this.__internalChange) {
          this.__internalChange = true; // Set the same scroll position to all meta columns

          var scrollerArr = this._getPaneScrollerArr();

          for (var i = 0; i < scrollerArr.length; i++) {
            scrollerArr[i].setScrollY(evt.getData());
          }

          this.__internalChange = false;
        }
      },

      /**
       * Event handler. Called when a key was pressed.
       *
       * @param evt {qx.event.type.KeySequence} the event.
       * @deprecated {6.0} please use _onKeyDown instead!
       */
      _onKeyPress: function _onKeyPress(evt) {
        qx.log.Logger.deprecatedMethodWarning(this._onKeyPress, "The method '_onKeyPress()' is deprecated. Please use '_onKeyDown()' instead.");
        qx.log.Logger.deprecateMethodOverriding(this, qx.ui.table.Table, "_onKeyPress", "The method '_onKeyPress()' is deprecated. Please use '_onKeyDown()' instead.");

        this._onKeyDown(evt);
      },

      /**
       * Event handler. Called when on key down event
       *
       * @param evt {qx.event.type.KeySequence} the event.
       */
      _onKeyDown: function _onKeyDown(evt) {
        if (!this.getEnabled()) {
          return;
        } // No editing mode


        var oldFocusedRow = this.__focusedRow;
        var consumed = false; // Handle keys that are independent from the modifiers

        var identifier = evt.getKeyIdentifier();

        if (this.isEditing()) {
          // Editing mode
          if (evt.getModifiers() == 0) {
            switch (identifier) {
              case "Enter":
                this.stopEditing();
                var oldFocusedRow = this.__focusedRow;
                this.moveFocusedCell(0, 1);

                if (this.__focusedRow != oldFocusedRow) {
                  consumed = this.startEditing();
                }

                break;

              case "Escape":
                this.cancelEditing();
                this.focus();
                break;

              default:
                consumed = false;
                break;
            }
          }
        } else {
          consumed = true; // No editing mode

          if (evt.isCtrlPressed()) {
            // Handle keys that depend on modifiers
            switch (identifier) {
              case "A":
                // Ctrl + A
                var rowCount = this.getTableModel().getRowCount();

                if (rowCount > 0) {
                  this.getSelectionModel().setSelectionInterval(0, rowCount - 1);
                }

                break;

              default:
                consumed = false;
                break;
            }
          } else {
            // Handle keys that are independent from the modifiers
            switch (identifier) {
              case "Space":
                this.__selectionManager.handleSelectKeyDown(this.__focusedRow, evt);

                break;

              case "F2":
              case "Enter":
                this.startEditing();
                consumed = true;
                break;

              case "Home":
                this.setFocusedCell(this.__focusedCol, 0, true);
                break;

              case "End":
                var rowCount = this.getTableModel().getRowCount();
                this.setFocusedCell(this.__focusedCol, rowCount - 1, true);
                break;

              case "Left":
                this.moveFocusedCell(-1, 0);
                break;

              case "Right":
                this.moveFocusedCell(1, 0);
                break;

              case "Up":
                this.moveFocusedCell(0, -1);
                break;

              case "Down":
                this.moveFocusedCell(0, 1);
                break;

              case "PageUp":
              case "PageDown":
                var scroller = this.getPaneScroller(0);
                var pane = scroller.getTablePane();
                var rowHeight = this.getRowHeight();
                var direction = identifier == "PageUp" ? -1 : 1;
                rowCount = pane.getVisibleRowCount() - 1;
                scroller.setScrollY(scroller.getScrollY() + direction * rowCount * rowHeight);
                this.moveFocusedCell(0, direction * rowCount);
                break;

              default:
                consumed = false;
            }
          }
        }

        if (oldFocusedRow != this.__focusedRow && this.getRowFocusChangeModifiesSelection()) {
          // The focus moved -> Let the selection manager handle this event
          this.__selectionManager.handleMoveKeyDown(this.__focusedRow, evt);
        }

        if (consumed) {
          evt.preventDefault();
          evt.stopPropagation();
        }
      },

      /**
       * Event handler. Called when the table gets the focus.
       *
       * @param evt {Map} the event.
       */
      _onFocusChanged: function _onFocusChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onFocusChanged();
        }
      },

      /**
       * Event handler. Called when the visibility of a column has changed.
       *
       * @param evt {Map} the event.
       */
      _onColVisibilityChanged: function _onColVisibilityChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onColVisibilityChanged();
        }

        var data = evt.getData();

        if (this.__columnMenuButtons != null && data.col != null && data.visible != null) {
          this.__columnMenuButtons[data.col].setColumnVisible(data.visible);
        }

        this._updateScrollerWidths();

        this._updateScrollBarVisibility();
      },

      /**
       * Event handler. Called when the width of a column has changed.
       *
       * @param evt {Map} the event.
       */
      _onColWidthChanged: function _onColWidthChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          var data = evt.getData();
          scrollerArr[i].setColumnWidth(data.col, data.newWidth);
        }

        this._updateScrollerWidths();

        this._updateScrollBarVisibility();
      },

      /**
       * Event handler. Called when the column order has changed.
       *
       * @param evt {Map} the event.
       */
      _onColOrderChanged: function _onColOrderChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onColOrderChanged();
        } // A column may have been moved between meta columns


        this._updateScrollerWidths();

        this._updateScrollBarVisibility();
      },

      /**
       * Gets the TablePaneScroller at a certain x position in the page. If there is
       * no TablePaneScroller at this position, null is returned.
       *
       * @param pageX {Integer} the position in the page to check (in pixels).
       * @return {qx.ui.table.pane.Scroller} the TablePaneScroller or null.
       */
      getTablePaneScrollerAtPageX: function getTablePaneScrollerAtPageX(pageX) {
        var metaCol = this._getMetaColumnAtPageX(pageX);

        return metaCol != -1 ? this.getPaneScroller(metaCol) : null;
      },

      /**
       * Sets the currently focused cell. A value of <code>null</code> hides the
       * focus cell.
       *
       * @param col {Integer?null} the model index of the focused cell's column.
       * @param row {Integer?null} the model index of the focused cell's row.
       * @param scrollVisible {Boolean ? false} whether to scroll the new focused cell
       *          visible.
       */
      setFocusedCell: function setFocusedCell(col, row, scrollVisible) {
        if (!this.isEditing() && (col != this.__focusedCol || row != this.__focusedRow)) {
          if (col === null) {
            col = 0;
          }

          this.__focusedCol = col;
          this.__focusedRow = row;

          var scrollerArr = this._getPaneScrollerArr();

          for (var i = 0; i < scrollerArr.length; i++) {
            scrollerArr[i].setFocusedCell(col, row);
          }

          if (col != null && scrollVisible) {
            this.scrollCellVisible(col, row);
          }
        }
      },

      /**
       * Resets (clears) the current selection
       */
      resetSelection: function resetSelection() {
        this.getSelectionModel().resetSelection();
      },

      /**
       * Resets the focused cell.
       */
      resetCellFocus: function resetCellFocus() {
        this.setFocusedCell(null, null, false);
      },

      /**
       * Returns the column of the currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedColumn: function getFocusedColumn() {
        return this.__focusedCol;
      },

      /**
       * Returns the row of the currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedRow: function getFocusedRow() {
        return this.__focusedRow;
      },

      /**
       * Select whether the focused row is highlighted
       *
       * @param bHighlight {Boolean}
       *   Flag indicating whether the focused row should be highlighted.
       *
       */
      highlightFocusedRow: function highlightFocusedRow(bHighlight) {
        this.getDataRowRenderer().setHighlightFocusRow(bHighlight);
      },

      /**
       * Remove the highlighting of the current focus row.
       *
       * This is used to temporarily remove the highlighting of the currently
       * focused row, and is expected to be used most typically by adding a
       * listener on the "pointerout" event, so that the focus highlighting is
       * suspended when the pointer leaves the table:
       *
       *     table.addListener("pointerout", table.clearFocusedRowHighlight);
       *
       * @param evt {qx.event.type.Pointer} Incoming pointer event
       */
      clearFocusedRowHighlight: function clearFocusedRowHighlight(evt) {
        if (evt) {
          var relatedTarget = evt.getRelatedTarget();

          if (relatedTarget instanceof qx.ui.table.pane.Pane || relatedTarget instanceof qx.ui.table.pane.FocusIndicator) {
            return;
          }
        } // Remove focus from any cell that has it


        this.resetCellFocus(); // Now, for each pane scroller...

        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          // ... repaint without focus.
          scrollerArr[i].onFocusChanged();
        }
      },

      /**
       * Moves the focus.
       *
       * @param deltaX {Integer} The delta by which the focus should be moved on the x axis.
       * @param deltaY {Integer} The delta by which the focus should be moved on the y axis.
       */
      moveFocusedCell: function moveFocusedCell(deltaX, deltaY) {
        var col = this.__focusedCol;
        var row = this.__focusedRow; // could also be undefined [BUG #4676]

        if (col == null || row == null) {
          return;
        }

        if (deltaX != 0) {
          var columnModel = this.getTableColumnModel();
          var x = columnModel.getVisibleX(col);
          var colCount = columnModel.getVisibleColumnCount();
          x = qx.lang.Number.limit(x + deltaX, 0, colCount - 1);
          col = columnModel.getVisibleColumnAtX(x);
        }

        if (deltaY != 0) {
          var tableModel = this.getTableModel();
          row = qx.lang.Number.limit(row + deltaY, 0, tableModel.getRowCount() - 1);
        }

        this.setFocusedCell(col, row, true);
      },

      /**
       * Scrolls a cell visible.
       *
       * @param col {Integer} the model index of the column the cell belongs to.
       * @param row {Integer} the model index of the row the cell belongs to.
       */
      scrollCellVisible: function scrollCellVisible(col, row) {
        // get the dom element
        var elem = this.getContentElement().getDomElement(); // if the dom element is not available, the table hasn't been rendered

        if (!elem) {
          // postpone the scroll until the table has appeared
          this.addListenerOnce("appear", function () {
            this.scrollCellVisible(col, row);
          }, this);
        }

        var columnModel = this.getTableColumnModel();
        var x = columnModel.getVisibleX(col);

        var metaColumn = this._getMetaColumnAtColumnX(x);

        if (metaColumn != -1) {
          this.getPaneScroller(metaColumn).scrollCellVisible(col, row);
        }
      },

      /**
       * Returns whether currently a cell is editing.
       *
       * @return {var} whether currently a cell is editing.
       */
      isEditing: function isEditing() {
        if (this.__focusedCol != null) {
          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol);

          var metaColumn = this._getMetaColumnAtColumnX(x);

          return this.getPaneScroller(metaColumn).isEditing();
        }

        return false;
      },

      /**
       * Starts editing the currently focused cell. Does nothing if already editing
       * or if the column is not editable.
       *
       * @return {Boolean} whether editing was started
       */
      startEditing: function startEditing() {
        if (this.__focusedCol != null) {
          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol);

          var metaColumn = this._getMetaColumnAtColumnX(x);

          var started = this.getPaneScroller(metaColumn).startEditing();
          return started;
        }

        return false;
      },

      /**
       * Stops editing and writes the editor's value to the model.
       */
      stopEditing: function stopEditing() {
        if (this.__focusedCol != null) {
          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol);

          var metaColumn = this._getMetaColumnAtColumnX(x);

          this.getPaneScroller(metaColumn).stopEditing();
        }
      },

      /**
       * Stops editing without writing the editor's value to the model.
       */
      cancelEditing: function cancelEditing() {
        if (this.__focusedCol != null) {
          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol);

          var metaColumn = this._getMetaColumnAtColumnX(x);

          this.getPaneScroller(metaColumn).cancelEditing();
        }
      },

      /**
       * Update the table content of every attached table pane.
       */
      updateContent: function updateContent() {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].getTablePane().updateContent(true);
        }
      },

      /**
       * Activates the blocker widgets on all column headers and the
       * column button
       */
      blockHeaderElements: function blockHeaderElements() {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].getHeader().getBlocker().blockContent(20);
        }

        this.getChildControl("column-button").getBlocker().blockContent(20);
      },

      /**
       * Deactivates the blocker widgets on all column headers and the
       * column button
       */
      unblockHeaderElements: function unblockHeaderElements() {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].getHeader().getBlocker().unblock();
        }

        this.getChildControl("column-button").getBlocker().unblock();
      },

      /**
       * Gets the meta column at a certain x position in the page. If there is no
       * meta column at this position, -1 is returned.
       *
       * @param pageX {Integer} the position in the page to check (in pixels).
       * @return {Integer} the index of the meta column or -1.
       */
      _getMetaColumnAtPageX: function _getMetaColumnAtPageX(pageX) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          var pos = scrollerArr[i].getContentLocation();

          if (pageX >= pos.left && pageX <= pos.right) {
            return i;
          }
        }

        return -1;
      },

      /**
       * Returns the meta column a column is shown in. If the column is not shown at
       * all, -1 is returned.
       *
       * @param visXPos {Integer} the visible x position of the column.
       * @return {Integer} the meta column the column is shown in.
       */
      _getMetaColumnAtColumnX: function _getMetaColumnAtColumnX(visXPos) {
        var metaColumnCounts = this.getMetaColumnCounts();
        var rightXPos = 0;

        for (var i = 0; i < metaColumnCounts.length; i++) {
          var counts = metaColumnCounts[i];
          rightXPos += counts;

          if (counts == -1 || visXPos < rightXPos) {
            return i;
          }
        }

        return -1;
      },

      /**
       * Updates the text shown in the status bar.
       */
      _updateStatusBar: function _updateStatusBar() {
        var tableModel = this.getTableModel();

        if (this.getStatusBarVisible()) {
          var selectedRowCount = this.getSelectionModel().getSelectedCount();
          var rowCount = tableModel.getRowCount();
          var text;

          if (rowCount >= 0) {
            if (selectedRowCount == 0) {
              text = this.trn("one row", "%1 rows", rowCount, rowCount);
            } else {
              text = this.trn("one of one row", "%1 of %2 rows", rowCount, selectedRowCount, rowCount);
            }
          }

          if (this.__additionalStatusBarText) {
            if (text) {
              text += this.__additionalStatusBarText;
            } else {
              text = this.__additionalStatusBarText;
            }
          }

          if (text) {
            this.getChildControl("statusbar").setValue(text);
          }
        }
      },

      /**
       * Updates the widths of all scrollers.
       */
      _updateScrollerWidths: function _updateScrollerWidths() {
        // Give all scrollers except for the last one the wanted width
        // (The last one has a flex with)
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          var isLast = i == scrollerArr.length - 1;
          var width = scrollerArr[i].getTablePaneModel().getTotalWidth();
          scrollerArr[i].setPaneWidth(width);
          var flex = isLast ? 1 : 0;
          scrollerArr[i].setLayoutProperties({
            flex: flex
          });
        }
      },

      /**
       * Updates the visibility of the scrollbars in the meta columns.
       */
      _updateScrollBarVisibility: function _updateScrollBarVisibility() {
        if (!this.getBounds()) {
          return;
        }

        var horBar = qx.ui.table.pane.Scroller.HORIZONTAL_SCROLLBAR;
        var verBar = qx.ui.table.pane.Scroller.VERTICAL_SCROLLBAR;

        var scrollerArr = this._getPaneScrollerArr(); // Check which scroll bars are needed


        var horNeeded = false;
        var verNeeded = false;
        var excludeScrollerScrollbarsIfNotNeeded; // Determine whether we need to render horizontal scrollbars for meta
        // columns that don't themselves actually require it

        excludeScrollerScrollbarsIfNotNeeded = this.getExcludeScrollerScrollbarsIfNotNeeded();

        if (!excludeScrollerScrollbarsIfNotNeeded) {
          for (var i = 0; i < scrollerArr.length; i++) {
            var isLast = i == scrollerArr.length - 1; // Only show the last vertical scrollbar

            var bars = scrollerArr[i].getNeededScrollBars(horNeeded, !isLast);

            if (bars & horBar) {
              horNeeded = true;
            }

            if (isLast && bars & verBar) {
              verNeeded = true;
            }
          }
        } // Set the needed scrollbars


        for (var i = 0; i < scrollerArr.length; i++) {
          isLast = i == scrollerArr.length - 1; // If we don't want to include scrollbars for meta columns that don't
          // require it, find out whether this meta column requires it.

          if (excludeScrollerScrollbarsIfNotNeeded) {
            horNeeded = !!(scrollerArr[i].getNeededScrollBars(false, !isLast) & horBar); // Show the horizontal scrollbar if needed. Specify null to indicate
            // that the scrollbar should be hidden rather than excluded.

            scrollerArr[i].setHorizontalScrollBarVisible(horNeeded || null);
          } else {
            // Show the horizontal scrollbar if needed.
            scrollerArr[i].setHorizontalScrollBarVisible(horNeeded);
          } // If this is the last meta-column...


          if (isLast) {
            // ... then get the current (old) use of vertical scroll bar
            verNeeded = !!(scrollerArr[i].getNeededScrollBars(false, false) & verBar);

            if (this.__hadVerticalScrollBar == null) {
              this.__hadVerticalScrollBar = scrollerArr[i].getVerticalScrollBarVisible();
              this.__timer = qx.event.Timer.once(function () {
                // reset the last visible state of the vertical scroll bar
                // in a timeout to prevent infinite loops.
                this.__hadVerticalScrollBar = null;
                this.__timer = null;
              }, this, 0);
            }
          }

          scrollerArr[i].setVerticalScrollBarVisible(isLast && verNeeded); // If this is the last meta-column and the use of a vertical scroll bar
          // has changed...

          if (isLast && verNeeded != this.__hadVerticalScrollBar) {
            // ... then dispatch an event to any awaiting listeners
            this.fireDataEvent("verticalScrollBarChanged", verNeeded);
          }
        }
      },

      /**
       * Initialize the column menu
       */
      _initColumnMenu: function _initColumnMenu() {
        var tableModel = this.getTableModel();
        var columnModel = this.getTableColumnModel();
        var columnButton = this.getChildControl("column-button"); // Remove all items from the menu. We'll rebuild it here.

        columnButton.empty(); // Inform listeners who may want to insert menu items at the beginning

        var menu = columnButton.getMenu();
        var data = {
          table: this,
          menu: menu,
          columnButton: columnButton
        };
        this.fireDataEvent("columnVisibilityMenuCreateStart", data);
        this.__columnMenuButtons = {};

        for (var col = 0, l = tableModel.getColumnCount(); col < l; col++) {
          var menuButton = columnButton.factory("menu-button", {
            text: tableModel.getColumnName(col),
            column: col,
            bVisible: columnModel.isColumnVisible(col)
          });
          qx.core.Assert.assertInterface(menuButton, qx.ui.table.IColumnMenuItem);
          menuButton.addListener("changeColumnVisible", this._createColumnVisibilityCheckBoxHandler(col), this);
          this.__columnMenuButtons[col] = menuButton;
        } // Inform listeners who may want to insert menu items at the end


        data = {
          table: this,
          menu: menu,
          columnButton: columnButton
        };
        this.fireDataEvent("columnVisibilityMenuCreateEnd", data);
      },

      /**
       * Creates a handler for a check box of the column visibility menu.
       *
       * @param col {Integer} the model index of column to create the handler for.
       * @return {Function} The created event handler.
       */
      _createColumnVisibilityCheckBoxHandler: function _createColumnVisibilityCheckBoxHandler(col) {
        return function (evt) {
          var columnModel = this.getTableColumnModel();
          columnModel.setColumnVisible(col, evt.getData());
        };
      },

      /**
       * Sets the width of a column.
       *
       * @param col {Integer} the model index of column.
       * @param width {Integer} the new width in pixels.
       */
      setColumnWidth: function setColumnWidth(col, width) {
        this.getTableColumnModel().setColumnWidth(col, width);
      },

      /**
       * Resize event handler
       */
      _onResize: function _onResize() {
        this.fireEvent("tableWidthChanged");

        this._updateScrollerWidths();

        this._updateScrollBarVisibility();
      },
      // overridden
      addListener: function addListener(type, listener, self, capture) {
        if (qx.ui.table.Table.__redirectEvents[type]) {
          // start the id with the type (needed for removing)
          var id = [type];

          for (var i = 0, arr = this._getPaneScrollerArr(); i < arr.length; i++) {
            id.push(arr[i].addListener.apply(arr[i], arguments));
          } // join the id's of every event with "


          return id.join('"');
        } else {
          return qx.ui.table.Table.prototype.addListener.base.call(this, type, listener, self, capture);
        }
      },
      // overridden
      removeListener: function removeListener(type, listener, self, capture) {
        if (qx.ui.table.Table.__redirectEvents[type]) {
          for (var i = 0, arr = this._getPaneScrollerArr(); i < arr.length; i++) {
            arr[i].removeListener.apply(arr[i], arguments);
          }
        } else {
          qx.ui.table.Table.prototype.removeListener.base.call(this, type, listener, self, capture);
        }
      },
      // overridden
      removeListenerById: function removeListenerById(id) {
        var ids = id.split('"'); // type is the first entry of the connected id

        var type = ids.shift();

        if (qx.ui.table.Table.__redirectEvents[type]) {
          var removed = true;

          for (var i = 0, arr = this._getPaneScrollerArr(); i < arr.length; i++) {
            removed = arr[i].removeListenerById.call(arr[i], ids[i]) && removed;
          }

          return removed;
        } else {
          return qx.ui.table.Table.prototype.removeListenerById.base.call(this, id);
        }
      },
      destroy: function destroy() {
        this.getChildControl("column-button").getMenu().destroy();
        qx.ui.table.Table.prototype.destroy.base.call(this);
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      // remove the event listener which handled the locale change
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      } // we allocated these objects on init so we have to clean them up.

      var selectionModel = this.getSelectionModel();

      if (selectionModel) {
        selectionModel.dispose();
      }

      var dataRowRenderer = this.getDataRowRenderer();

      if (dataRowRenderer) {
        dataRowRenderer.dispose();
      }

      this._cleanUpMetaColumns(0);

      this.getTableColumnModel().dispose();

      this._disposeObjects("__selectionManager", "__scrollerParent", "__emptyTableModel", "__emptyTableModel", "__columnModel", "__timer");

      this._disposeMap("__columnMenuButtons");
    }
  });
  qx.ui.table.Table.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * Interface for a row renderer.
   */
  qx.Interface.define("qx.ui.table.IRowRenderer", {
    members: {
      /**
       * Updates a data row.
       *
       * The rowInfo map contains the following properties:
       * <ul>
       * <li>rowData (var): contains the row data for the row.
       *   The kind of this object depends on the table model, see
       *   {@link ITableModel#getRowData()}</li>
       * <li>row (int): the model index of the row.</li>
       * <li>selected (boolean): whether a cell in this row is selected.</li>
       * <li>focusedRow (boolean): whether the focused cell is in this row.</li>
       * <li>table (qx.ui.table.Table): the table the row belongs to.</li>
       * </ul>
       *
       * @abstract
       * @param rowInfo {Map} A map containing the information about the row to
       *      update.
       * @param rowElement {Element} the DOM element that renders the data row.
       */
      updateDataRowElement: function updateDataRowElement(rowInfo, rowElement) {},

      /**
       * Get the row's height CSS style taking the box model into account
       *
       * @param height {Integer} The row's (border-box) height in pixel
       */
      getRowHeightStyle: function getRowHeightStyle(height) {},

      /**
       * Create a style string, which will be set as the style property of the row.
       *
       * @param rowInfo {Map} A map containing the information about the row to
       *      update. See {@link #updateDataRowElement} for more information.
       */
      createRowStyle: function createRowStyle(rowInfo) {},

      /**
       * Create a HTML class string, which will be set as the class property of the row.
       *
       * @param rowInfo {Map} A map containing the information about the row to
       *      update. See {@link #updateDataRowElement} for more information.
       */
      getRowClass: function getRowClass(rowInfo) {}
    }
  });
  qx.ui.table.IRowRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.IRowRenderer": {
        "require": true
      },
      "qx.theme.manager.Meta": {
        "construct": true
      },
      "qx.theme.manager.Font": {},
      "qx.theme.manager.Color": {},
      "qx.bom.element.Style": {},
      "qx.bom.Font": {},
      "qx.bom.client.Css": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxmodel": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2007 Visionet GmbH, http://www.visionet.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132) STZ-IDA
       * Dietrich Streifert (level420) Visionet
  
  ************************************************************************ */

  /**
   * The default data row renderer.
   */
  qx.Class.define("qx.ui.table.rowrenderer.Default", {
    extend: qx.core.Object,
    implement: qx.ui.table.IRowRenderer,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.initThemeValues(); // dynamic theme switch

      {
        qx.theme.manager.Meta.getInstance().addListener("changeTheme", this.initThemeValues, this);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Whether the focused row should be highlighted. */
      highlightFocusRow: {
        check: "Boolean",
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _colors: null,
      _fontStyle: null,
      _fontStyleString: null,

      /**
       * Initializes the colors from the color theme.
       * @internal
       */
      initThemeValues: function initThemeValues() {
        this._fontStyleString = "";
        this._fontStyle = {};
        this._colors = {}; // link to font theme

        this._renderFont(qx.theme.manager.Font.getInstance().resolve("default")); // link to color theme


        var colorMgr = qx.theme.manager.Color.getInstance();
        this._colors.bgcolFocusedSelected = colorMgr.resolve("table-row-background-focused-selected");
        this._colors.bgcolFocused = colorMgr.resolve("table-row-background-focused");
        this._colors.bgcolSelected = colorMgr.resolve("table-row-background-selected");
        this._colors.bgcolEven = colorMgr.resolve("table-row-background-even");
        this._colors.bgcolOdd = colorMgr.resolve("table-row-background-odd");
        this._colors.colSelected = colorMgr.resolve("table-row-selected");
        this._colors.colNormal = colorMgr.resolve("table-row");
        this._colors.horLine = colorMgr.resolve("table-row-line");
      },

      /**
       * the sum of the vertical insets. This is needed to compute the box model
       * independent size
       */
      _insetY: 1,
      // borderBottom

      /**
       * Render the new font and update the table pane content
       * to reflect the font change.
       *
       * @param font {qx.bom.Font} The font to use for the table row
       */
      _renderFont: function _renderFont(font) {
        if (font) {
          this._fontStyle = font.getStyles();
          this._fontStyleString = qx.bom.element.Style.compile(this._fontStyle);
          this._fontStyleString = this._fontStyleString.replace(/"/g, "'");
        } else {
          this._fontStyleString = "";
          this._fontStyle = qx.bom.Font.getDefaultStyles();
        }
      },
      // interface implementation
      updateDataRowElement: function updateDataRowElement(rowInfo, rowElem) {
        var fontStyle = this._fontStyle;
        var style = rowElem.style; // set font styles

        qx.bom.element.Style.setStyles(rowElem, fontStyle);

        if (rowInfo.focusedRow && this.getHighlightFocusRow()) {
          style.backgroundColor = rowInfo.selected ? this._colors.bgcolFocusedSelected : this._colors.bgcolFocused;
        } else {
          if (rowInfo.selected) {
            style.backgroundColor = this._colors.bgcolSelected;
          } else {
            style.backgroundColor = rowInfo.row % 2 == 0 ? this._colors.bgcolEven : this._colors.bgcolOdd;
          }
        }

        style.color = rowInfo.selected ? this._colors.colSelected : this._colors.colNormal;
        style.borderBottom = "1px solid " + this._colors.horLine;
      },

      /**
       * Get the row's height CSS style taking the box model into account
       *
       * @param height {Integer} The row's (border-box) height in pixel
       * @return {String} CSS rule for the row height
       */
      getRowHeightStyle: function getRowHeightStyle(height) {
        if (qx.core.Environment.get("css.boxmodel") == "content") {
          height -= this._insetY;
        }

        return "height:" + height + "px;";
      },
      // interface implementation
      createRowStyle: function createRowStyle(rowInfo) {
        var rowStyle = [];
        rowStyle.push(";");
        rowStyle.push(this._fontStyleString);
        rowStyle.push("background-color:");

        if (rowInfo.focusedRow && this.getHighlightFocusRow()) {
          rowStyle.push(rowInfo.selected ? this._colors.bgcolFocusedSelected : this._colors.bgcolFocused);
        } else {
          if (rowInfo.selected) {
            rowStyle.push(this._colors.bgcolSelected);
          } else {
            rowStyle.push(rowInfo.row % 2 == 0 ? this._colors.bgcolEven : this._colors.bgcolOdd);
          }
        }

        rowStyle.push(';color:');
        rowStyle.push(rowInfo.selected ? this._colors.colSelected : this._colors.colNormal);
        rowStyle.push(';border-bottom: 1px solid ', this._colors.horLine);
        return rowStyle.join("");
      },
      getRowClass: function getRowClass(rowInfo) {
        return "";
      },

      /**
       * Add extra attributes to each row.
       *
       * @param rowInfo {Object}
       *   The following members are available in rowInfo:
       *   <dl>
       *     <dt>table {qx.ui.table.Table}</dt>
       *     <dd>The table object</dd>
       *
       *     <dt>styleHeight {Integer}</dt>
       *     <dd>The height of this (and every) row</dd>
       *
       *     <dt>row {Integer}</dt>
       *     <dd>The number of the row being added</dd>
       *
       *     <dt>selected {Boolean}</dt>
       *     <dd>Whether the row being added is currently selected</dd>
       *
       *     <dt>focusedRow {Boolean}</dt>
       *     <dd>Whether the row being added is currently focused</dd>
       *
       *     <dt>rowData {Array}</dt>
       *     <dd>The array row from the data model of the row being added</dd>
       *   </dl>
       *
       * @return {String}
       *   Any additional attributes and their values that should be added to the
       *   div tag for the row.
       */
      getRowAttributes: function getRowAttributes(rowInfo) {
        return "";
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._colors = this._fontStyle = this._fontStyleString = null; // remove dynamic theme listener

      {
        qx.theme.manager.Meta.getInstance().removeListener("changeTheme", this.initThemeValues, this);
      }
    }
  });
  qx.ui.table.rowrenderer.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Interface for creating the column visibility menu
   */
  qx.Interface.define("qx.ui.table.IColumnMenuButton", {
    properties: {
      /**
       * The menu which is displayed when this button is pressed.
       */
      menu: {}
    },
    members: {
      /**
       * Instantiate a sub-widget.
       *
       * @param item {String}
       *   One of the following strings, indicating what type of
       *   column-menu-specific object to instantiate:
       *   <dl>
       *     <dt>menu</dt>
       *     <dd>
       *       Instantiate a menu which will appear when the column visibility
       *       button is pressed. No options are provided in this case.
       *     </dd>
       *     <dt>menu-button</dt>
       *     <dd>
       *       Instantiate a button to correspond to a column within the
       *       table. The options are a map containing <i>text</i>, the name of
       *       the column; <i>column</i>, the column number; and
       *       <i>bVisible</i>, a boolean indicating whether this column is
       *       currently visible. The instantiated return object must implement
       *       interface {@link qx.ui.table.IColumnMenuItem}
       *     </dd>
       *     <dt>user-button</dt>
       *     <dd>
       *       Instantiate a button for other than a column name. This is used,
       *       for example, to add the "Reset column widths" button when the
       *       Resize column model is requested. The options is a map containing
       *       <i>text</i>, the text to present in the button.
       *     </dd>
       *     <dt>separator</dt>
       *     <dd>
       *       Instantiate a separator object to added to the menu. This is
       *       used, for example, to separate the table column name list from
       *       the "Reset column widths" button when the Resize column model is
       *       requested. No options are provided in this case.
       *     </dd>
       *   </dl>
       *
       * @param options {Map}
       *   Options specific to the <i>item</i> being requested.
       *
       * @return {qx.ui.core.Widget}
       *   The instantiated object as specified by <i>item</i>.
       */
      factory: function factory(item, options) {
        return true;
      },

      /**
       * Empty the menu of all items, in preparation for building a new column
       * visibility menu.
       *
       */
      empty: function empty() {
        return true;
      }
    }
  });
  qx.ui.table.IColumnMenuButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.MenuButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.IColumnMenuButton": {
        "require": true
      },
      "qx.ui.core.Blocker": {
        "construct": true
      },
      "qx.ui.menu.Menu": {},
      "qx.ui.table.columnmenu.MenuItem": {},
      "qx.ui.menu.Button": {},
      "qx.ui.menu.Separator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The traditional qx.ui.menu.MenuButton to access the column visibility menu.
   */
  qx.Class.define("qx.ui.table.columnmenu.Button", {
    extend: qx.ui.form.MenuButton,
    implement: qx.ui.table.IColumnMenuButton,

    /**
     * Create a new instance of a column visibility menu button. This button
     * also contains the factory for creating each of the sub-widgets.
     */
    construct: function construct() {
      qx.ui.form.MenuButton.constructor.call(this); // add blocker

      this.__blocker = new qx.ui.core.Blocker(this);
    },
    members: {
      __columnMenuButtons: null,
      __blocker: null,
      // Documented in qx.ui.table.IColumnMenu
      factory: function factory(item, options) {
        switch (item) {
          case "menu":
            var menu = new qx.ui.menu.Menu();
            this.setMenu(menu);
            return menu;

          case "menu-button":
            var menuButton = new qx.ui.table.columnmenu.MenuItem(options.text);
            menuButton.setColumnVisible(options.bVisible);
            this.getMenu().add(menuButton);
            return menuButton;

          case "user-button":
            var button = new qx.ui.menu.Button(options.text);
            button.set({
              appearance: "table-column-reset-button"
            });
            return button;

          case "separator":
            return new qx.ui.menu.Separator();

          default:
            throw new Error("Unrecognized factory request: " + item);
        }
      },

      /**
       * Returns the blocker of the columnmenu button.
       *
       * @return {qx.ui.core.Blocker} the blocker.
       */
      getBlocker: function getBlocker() {
        return this.__blocker;
      },
      // Documented in qx.ui.table.IColumnMenu
      empty: function empty() {
        var menu = this.getMenu();
        var entries = menu.getChildren();

        for (var i = 0, l = entries.length; i < l; i++) {
          entries[0].destroy();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__blocker.dispose();
    }
  });
  qx.ui.table.columnmenu.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.event.type.Dom": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A selection manager. This is a helper class that handles all selection
   * related events and updates a SelectionModel.
   * <p>
   * Widgets that support selection should use this manager. This way the only
   * thing the widget has to do is mapping pointer or key events to indexes and
   * call the corresponding handler method.
   *
   * @see SelectionModel
   */
  qx.Class.define("qx.ui.table.selection.Manager", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The selection model where to set the selection changes.
       */
      selectionModel: {
        check: "qx.ui.table.selection.Model"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __lastPointerDownHandled: null,

      /**
       * Handles the tap event.
       *
       * @param index {Integer} the index the pointer is pointing at.
       * @param evt {qx.event.type.Tap} the pointer event.
       */
      handleTap: function handleTap(index, evt) {
        if (evt.isLeftPressed()) {
          var selectionModel = this.getSelectionModel();

          if (!selectionModel.isSelectedIndex(index)) {
            // This index is not selected -> We react when the pointer is pressed (because of drag and drop)
            this._handleSelectEvent(index, evt);

            this.__lastPointerDownHandled = true;
          } else {
            // This index is already selected -> We react when the pointer is released (because of drag and drop)
            this.__lastPointerDownHandled = false;
          }
        } else if (evt.isRightPressed() && evt.getModifiers() == 0) {
          var selectionModel = this.getSelectionModel();

          if (!selectionModel.isSelectedIndex(index)) {
            // This index is not selected -> Set the selection to this index
            selectionModel.setSelectionInterval(index, index);
          }
        }

        if (evt.isLeftPressed() && !this.__lastPointerDownHandled) {
          this._handleSelectEvent(index, evt);
        }
      },

      /**
       * Handles the key down event that is used as replacement for pointer taps
       * (Normally space).
       *
       * @param index {Integer} the index that is currently focused.
       * @param evt {Map} the key event.
       */
      handleSelectKeyDown: function handleSelectKeyDown(index, evt) {
        this._handleSelectEvent(index, evt);
      },

      /**
       * Handles a key down event that moved the focus (E.g. up, down, home, end, ...).
       *
       * @param index {Integer} the index that is currently focused.
       * @param evt {Map} the key event.
       */
      handleMoveKeyDown: function handleMoveKeyDown(index, evt) {
        var selectionModel = this.getSelectionModel();

        switch (evt.getModifiers()) {
          case 0:
            selectionModel.setSelectionInterval(index, index);
            break;

          case qx.event.type.Dom.SHIFT_MASK:
            var anchor = selectionModel.getAnchorSelectionIndex();

            if (anchor == -1) {
              selectionModel.setSelectionInterval(index, index);
            } else {
              selectionModel.setSelectionInterval(anchor, index);
            }

            break;
        }
      },

      /**
       * Handles a select event.
       *
       * @param index {Integer} the index the event is pointing at.
       * @param evt {Map} the pointer event.
       */
      _handleSelectEvent: function _handleSelectEvent(index, evt) {
        var selectionModel = this.getSelectionModel();
        var leadIndex = selectionModel.getLeadSelectionIndex();
        var anchorIndex = selectionModel.getAnchorSelectionIndex();

        if (evt.isShiftPressed()) {
          if (index != leadIndex || selectionModel.isSelectionEmpty()) {
            // The lead selection index was changed
            if (anchorIndex == -1) {
              anchorIndex = index;
            }

            if (evt.isCtrlOrCommandPressed()) {
              selectionModel.addSelectionInterval(anchorIndex, index);
            } else {
              selectionModel.setSelectionInterval(anchorIndex, index);
            }
          }
        } else if (evt.isCtrlOrCommandPressed()) {
          if (selectionModel.isSelectedIndex(index)) {
            selectionModel.removeSelectionInterval(index, index);
          } else {
            selectionModel.addSelectionInterval(index, index);
          }
        } else {
          // setSelectionInterval checks to see if the change is really necessary
          selectionModel.setSelectionInterval(index, index);
        }
      }
    }
  });
  qx.ui.table.selection.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * David Perez Carmona (david-perez)
  
  ************************************************************************ */

  /**
   * A selection model.
   */
  qx.Class.define("qx.ui.table.selection.Model", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__selectedRangeArr = [];
      this.__anchorSelectionIndex = -1;
      this.__leadSelectionIndex = -1;
      this.hasBatchModeRefCount = 0;
      this.__hadChangeEventInBatchMode = false;
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the selection has changed. */
      "changeSelection": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {int} The selection mode "none". Nothing can ever be selected. */
      NO_SELECTION: 1,

      /** @type {int} The selection mode "single". This mode only allows one selected item. */
      SINGLE_SELECTION: 2,

      /**
       * @type {int} The selection mode "single interval". This mode only allows one
       * continuous interval of selected items.
       */
      SINGLE_INTERVAL_SELECTION: 3,

      /**
       * @type {int} The selection mode "multiple interval". This mode only allows any
       * selection.
       */
      MULTIPLE_INTERVAL_SELECTION: 4,

      /**
       * @type {int} The selection mode "multiple interval". This mode only allows any
       * selection. The difference with the previous one, is that multiple
       * selection is eased. A tap on an item, toggles its selection state.
       * On the other hand, MULTIPLE_INTERVAL_SELECTION does this behavior only
       * when Ctrl-tapping an item.
       */
      MULTIPLE_INTERVAL_SELECTION_TOGGLE: 5
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Set the selection mode. Valid values are {@link #NO_SELECTION},
       * {@link #SINGLE_SELECTION}, {@link #SINGLE_INTERVAL_SELECTION},
       * {@link #MULTIPLE_INTERVAL_SELECTION} and
       * {@link #MULTIPLE_INTERVAL_SELECTION_TOGGLE}.
       */
      selectionMode: {
        init: 2,
        //SINGLE_SELECTION,
        check: [1, 2, 3, 4, 5],
        //[ NO_SELECTION, SINGLE_SELECTION, SINGLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION_TOGGLE ],
        apply: "_applySelectionMode"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __hadChangeEventInBatchMode: null,
      __anchorSelectionIndex: null,
      __leadSelectionIndex: null,
      __selectedRangeArr: null,
      // selectionMode property modifier
      _applySelectionMode: function _applySelectionMode(selectionMode) {
        this.resetSelection();
      },

      /**
       *
       * Activates / Deactivates batch mode. In batch mode, no change events will be thrown but
       * will be collected instead. When batch mode is turned off again and any events have
       * been collected, one event is thrown to inform the listeners.
       *
       * This method supports nested calling, i. e. batch mode can be turned more than once.
       * In this case, batch mode will not end until it has been turned off once for each
       * turning on.
       *
       * @param batchMode {Boolean} true to activate batch mode, false to deactivate
       * @return {Boolean} true if batch mode is active, false otherwise
       * @throws {Error} if batch mode is turned off once more than it has been turned on
       */
      setBatchMode: function setBatchMode(batchMode) {
        if (batchMode) {
          this.hasBatchModeRefCount += 1;
        } else {
          if (this.hasBatchModeRefCount == 0) {
            throw new Error("Try to turn off batch mode althoug it was not turned on.");
          }

          this.hasBatchModeRefCount -= 1;

          if (this.__hadChangeEventInBatchMode) {
            this.__hadChangeEventInBatchMode = false;

            this._fireChangeSelection();
          }
        }

        return this.hasBatchMode();
      },

      /**
       *
       * Returns whether batch mode is active. See setter for a description of batch mode.
       *
       * @return {Boolean} true if batch mode is active, false otherwise
       */
      hasBatchMode: function hasBatchMode() {
        return this.hasBatchModeRefCount > 0;
      },

      /**
       * Returns the first argument of the last call to {@link #setSelectionInterval()},
       * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.
       *
       * @return {Integer} the anchor selection index.
       */
      getAnchorSelectionIndex: function getAnchorSelectionIndex() {
        return this.__anchorSelectionIndex;
      },

      /**
       * Sets the anchor selection index. Only use this function, if you want manipulate
       * the selection manually.
       *
       * @param index {Integer} the index to set.
       */
      _setAnchorSelectionIndex: function _setAnchorSelectionIndex(index) {
        this.__anchorSelectionIndex = index;
      },

      /**
       * Returns the second argument of the last call to {@link #setSelectionInterval()},
       * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.
       *
       * @return {Integer} the lead selection index.
       */
      getLeadSelectionIndex: function getLeadSelectionIndex() {
        return this.__leadSelectionIndex;
      },

      /**
       * Sets the lead selection index. Only use this function, if you want manipulate
       * the selection manually.
       *
       * @param index {Integer} the index to set.
       */
      _setLeadSelectionIndex: function _setLeadSelectionIndex(index) {
        this.__leadSelectionIndex = index;
      },

      /**
       * Returns an array that holds all the selected ranges of the table. Each
       * entry is a map holding information about the "minIndex" and "maxIndex" of the
       * selection range.
       *
       * @return {Map[]} array with all the selected ranges.
       */
      _getSelectedRangeArr: function _getSelectedRangeArr() {
        return this.__selectedRangeArr;
      },

      /**
       * Resets (clears) the selection.
       */
      resetSelection: function resetSelection() {
        if (!this.isSelectionEmpty()) {
          this._resetSelection();

          this._fireChangeSelection();
        }
      },

      /**
       * Returns whether the selection is empty.
       *
       * @return {Boolean} whether the selection is empty.
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__selectedRangeArr.length == 0;
      },

      /**
       * Returns the number of selected items.
       *
       * @return {Integer} the number of selected items.
       */
      getSelectedCount: function getSelectedCount() {
        var selectedCount = 0;

        for (var i = 0; i < this.__selectedRangeArr.length; i++) {
          var range = this.__selectedRangeArr[i];
          selectedCount += range.maxIndex - range.minIndex + 1;
        }

        return selectedCount;
      },

      /**
       * Returns whether an index is selected.
       *
       * @param index {Integer} the index to check.
       * @return {Boolean} whether the index is selected.
       */
      isSelectedIndex: function isSelectedIndex(index) {
        for (var i = 0; i < this.__selectedRangeArr.length; i++) {
          var range = this.__selectedRangeArr[i];

          if (index >= range.minIndex && index <= range.maxIndex) {
            return true;
          }
        }

        return false;
      },

      /**
       * Returns the selected ranges as an array. Each array element has a
       * <code>minIndex</code> and a <code>maxIndex</code> property.
       *
       * @return {Map[]} the selected ranges.
       */
      getSelectedRanges: function getSelectedRanges() {
        // clone the selection array and the individual elements - this prevents the
        // caller from messing with the internal model
        var retVal = [];

        for (var i = 0; i < this.__selectedRangeArr.length; i++) {
          retVal.push({
            minIndex: this.__selectedRangeArr[i].minIndex,
            maxIndex: this.__selectedRangeArr[i].maxIndex
          });
        }

        return retVal;
      },

      /**
       * Calls an iterator function for each selected index.
       *
       * Usage Example:
       * <pre class='javascript'>
       * var selectedRowData = [];
       * mySelectionModel.iterateSelection(function(index) {
       *   selectedRowData.push(myTableModel.getRowData(index));
       * });
       * </pre>
       *
       * @param iterator {Function} the function to call for each selected index.
       *          Gets the current index as parameter.
       * @param object {var ? null} the object to use when calling the handler.
       *          (this object will be available via "this" in the iterator)
       */
      iterateSelection: function iterateSelection(iterator, object) {
        for (var i = 0; i < this.__selectedRangeArr.length; i++) {
          for (var j = this.__selectedRangeArr[i].minIndex; j <= this.__selectedRangeArr[i].maxIndex; j++) {
            iterator.call(object, j);
          }
        }
      },

      /**
       * Sets the selected interval. This will clear the former selection.
       *
       * @param fromIndex {Integer} the first index of the selection (including).
       * @param toIndex {Integer} the last index of the selection (including).
       */
      setSelectionInterval: function setSelectionInterval(fromIndex, toIndex) {
        var me = qx.ui.table.selection.Model;

        switch (this.getSelectionMode()) {
          case me.NO_SELECTION:
            return;

          case me.SINGLE_SELECTION:
            // Ensure there is actually a change of selection
            if (this.isSelectedIndex(toIndex)) {
              return;
            }

            fromIndex = toIndex;
            break;

          case me.MULTIPLE_INTERVAL_SELECTION_TOGGLE:
            this.setBatchMode(true);

            try {
              for (var i = fromIndex; i <= toIndex; i++) {
                if (!this.isSelectedIndex(i)) {
                  this._addSelectionInterval(i, i);
                } else {
                  this.removeSelectionInterval(i, i);
                }
              }
            } catch (e) {
              throw e;
            } finally {
              this.setBatchMode(false);
            }

            this._fireChangeSelection();

            return;
        }

        this._resetSelection();

        this._addSelectionInterval(fromIndex, toIndex);

        this._fireChangeSelection();
      },

      /**
       * Adds a selection interval to the current selection.
       *
       * @param fromIndex {Integer} the first index of the selection (including).
       * @param toIndex {Integer} the last index of the selection (including).
       */
      addSelectionInterval: function addSelectionInterval(fromIndex, toIndex) {
        var SelectionModel = qx.ui.table.selection.Model;

        switch (this.getSelectionMode()) {
          case SelectionModel.NO_SELECTION:
            return;

          case SelectionModel.MULTIPLE_INTERVAL_SELECTION:
          case SelectionModel.MULTIPLE_INTERVAL_SELECTION_TOGGLE:
            this._addSelectionInterval(fromIndex, toIndex);

            this._fireChangeSelection();

            break;

          default:
            this.setSelectionInterval(fromIndex, toIndex);
            break;
        }
      },

      /**
       * Removes an interval from the current selection.
       *
       * @param fromIndex {Integer} the first index of the interval (including).
       * @param toIndex {Integer} the last index of the interval (including).
       * @param rowsRemoved {Boolean?} rows were removed that caused this selection to change.
       *   If rows were removed, move the selections over so the same rows are selected as before.
       */
      removeSelectionInterval: function removeSelectionInterval(fromIndex, toIndex, rowsRemoved) {
        this.__anchorSelectionIndex = fromIndex;
        this.__leadSelectionIndex = toIndex;
        var minIndex = Math.min(fromIndex, toIndex);
        var maxIndex = Math.max(fromIndex, toIndex);
        var removeCount = maxIndex + 1 - minIndex; // Crop the affected ranges

        var newRanges = [];
        var extraRange = null;

        for (var i = 0; i < this.__selectedRangeArr.length; i++) {
          var range = this.__selectedRangeArr[i];

          if (range.minIndex > maxIndex) {
            if (rowsRemoved) {
              // Move whole selection up.
              range.minIndex -= removeCount;
              range.maxIndex -= removeCount;
            }
          } else if (range.maxIndex >= minIndex) {
            // This range is affected
            var minIsIn = range.minIndex >= minIndex;
            var maxIsIn = range.maxIndex >= minIndex && range.maxIndex <= maxIndex;

            if (minIsIn && maxIsIn) {
              // This range is removed completely
              range = null;
            } else if (minIsIn) {
              if (rowsRemoved) {
                range.minIndex = minIndex;
                range.maxIndex -= removeCount;
              } else {
                // The range is cropped from the left
                range.minIndex = maxIndex + 1;
              }
            } else if (maxIsIn) {
              // The range is cropped from the right
              range.maxIndex = minIndex - 1;
            } else {
              if (rowsRemoved) {
                range.maxIndex -= removeCount;
              } else {
                // The range is split
                extraRange = {
                  minIndex: maxIndex + 1,
                  maxIndex: range.maxIndex
                };
                range.maxIndex = minIndex - 1;
              }
            }
          }

          if (range) {
            newRanges.push(range);
            range = null;
          }

          if (extraRange) {
            newRanges.push(extraRange);
            extraRange = null;
          }
        }

        this.__selectedRangeArr = newRanges;

        this._fireChangeSelection();
      },

      /**
       * Resets (clears) the selection, but doesn't inform the listeners.
       */
      _resetSelection: function _resetSelection() {
        this.__selectedRangeArr = [];
        this.__anchorSelectionIndex = -1;
        this.__leadSelectionIndex = -1;
      },

      /**
       * Adds a selection interval to the current selection, but doesn't inform
       * the listeners.
       *
       * @param fromIndex {Integer} the first index of the selection (including).
       * @param toIndex {Integer} the last index of the selection (including).
       */
      _addSelectionInterval: function _addSelectionInterval(fromIndex, toIndex) {
        this.__anchorSelectionIndex = fromIndex;
        this.__leadSelectionIndex = toIndex;
        var minIndex = Math.min(fromIndex, toIndex);
        var maxIndex = Math.max(fromIndex, toIndex); // Find the index where the new range should be inserted

        var newRangeIndex = 0;

        for (; newRangeIndex < this.__selectedRangeArr.length; newRangeIndex++) {
          var range = this.__selectedRangeArr[newRangeIndex];

          if (range.minIndex > minIndex) {
            break;
          }
        } // Add the new range


        this.__selectedRangeArr.splice(newRangeIndex, 0, {
          minIndex: minIndex,
          maxIndex: maxIndex
        }); // Merge overlapping ranges


        var lastRange = this.__selectedRangeArr[0];

        for (var i = 1; i < this.__selectedRangeArr.length; i++) {
          var range = this.__selectedRangeArr[i];

          if (lastRange.maxIndex + 1 >= range.minIndex) {
            // The ranges are overlapping -> merge them
            lastRange.maxIndex = Math.max(lastRange.maxIndex, range.maxIndex); // Remove the current range

            this.__selectedRangeArr.splice(i, 1); // Check this index another time


            i--;
          } else {
            lastRange = range;
          }
        }
      },
      // this._dumpRanges();

      /**
       * Logs the current ranges for debug purposes.
       *
       */
      _dumpRanges: function _dumpRanges() {
        var text = "Ranges:";

        for (var i = 0; i < this.__selectedRangeArr.length; i++) {
          var range = this.__selectedRangeArr[i];
          text += " [" + range.minIndex + ".." + range.maxIndex + "]";
        }

        this.debug(text);
      },

      /**
       * Fires the "changeSelection" event to all registered listeners. If the selection model
       * currently is in batch mode, only one event will be thrown when batch mode is ended.
       *
       */
      _fireChangeSelection: function _fireChangeSelection() {
        if (this.hasBatchMode()) {
          // In batch mode, remember event but do not throw (yet)
          this.__hadChangeEventInBatchMode = true;
        } else {
          // If not in batch mode, throw event
          this.fireEvent("changeSelection");
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__selectedRangeArr = null;
    }
  });
  qx.ui.table.selection.Model.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A cell renderer for header cells.
   */
  qx.Interface.define("qx.ui.table.IHeaderRenderer", {
    members: {
      /**
       * Creates a header cell.
       *
       * The cellInfo map contains the following properties:
       * <ul>
       * <li>col (int): the model index of the column.</li>
       * <li>xPos (int): the x position of the column in the table pane.</li>
       * <li>name (string): the name of the column.</li>
       * <li>editable (boolean): whether the column is editable.</li>
       * <li>sorted (boolean): whether the column is sorted.</li>
       * <li>sortedAscending (boolean): whether sorting is ascending.</li>
       * </ul>
       *
       * @abstract
       * @param cellInfo {Map} A map containing the information about the cell to
       *      create.
       * @return {qx.ui.core.Widget} the widget that renders the header cell.
       */
      createHeaderCell: function createHeaderCell(cellInfo) {
        return true;
      },

      /**
       * Updates a header cell.
       *
       * @abstract
       * @param cellInfo {Map} A map containing the information about the cell to
       *      create. This map has the same structure as in {@link #createHeaderCell}.
       * @param cellWidget {qx.ui.core.Widget} the widget that renders the header cell. This is
       *      the same widget formally created by {@link #createHeaderCell}.
       */
      updateHeaderCell: function updateHeaderCell(cellInfo, cellWidget) {
        return true;
      }
    }
  });
  qx.ui.table.IHeaderRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.table.IHeaderRenderer": {
        "require": true
      },
      "qx.ui.table.headerrenderer.HeaderCell": {},
      "qx.ui.tooltip.ToolTip": {},
      "qx.util.DisposeUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * The default header cell renderer.
   */
  qx.Class.define("qx.ui.table.headerrenderer.Default", {
    extend: qx.core.Object,
    implement: qx.ui.table.IHeaderRenderer,

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * @type {String} The state which will be set for header cells of sorted columns.
       */
      STATE_SORTED: "sorted",

      /**
       * @type {String} The state which will be set when sorting is ascending.
       */
      STATE_SORTED_ASCENDING: "sortedAscending"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * ToolTip to show if the pointer hovers of the icon
       */
      toolTip: {
        check: "String",
        init: null,
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      createHeaderCell: function createHeaderCell(cellInfo) {
        var widget = new qx.ui.table.headerrenderer.HeaderCell();
        this.updateHeaderCell(cellInfo, widget);
        return widget;
      },
      // overridden
      updateHeaderCell: function updateHeaderCell(cellInfo, cellWidget) {
        var DefaultHeaderCellRenderer = qx.ui.table.headerrenderer.Default; // check for localization [BUG #2699]

        if (cellInfo.name && cellInfo.name.translate) {
          cellWidget.setLabel(cellInfo.name.translate());
        } else {
          cellWidget.setLabel(cellInfo.name);
        } // Set image tooltip if given


        var widgetToolTip = cellWidget.getToolTip();

        if (this.getToolTip() != null) {
          if (widgetToolTip == null) {
            // We have no tooltip yet -> Create one
            widgetToolTip = new qx.ui.tooltip.ToolTip(this.getToolTip());
            cellWidget.setToolTip(widgetToolTip); // Link disposer to cellwidget to prevent memory leak

            qx.util.DisposeUtil.disposeTriggeredBy(widgetToolTip, cellWidget);
          } else {
            // Update tooltip text
            widgetToolTip.setLabel(this.getToolTip());
          }
        }

        cellInfo.sorted ? cellWidget.addState(DefaultHeaderCellRenderer.STATE_SORTED) : cellWidget.removeState(DefaultHeaderCellRenderer.STATE_SORTED);
        cellInfo.sortedAscending ? cellWidget.addState(DefaultHeaderCellRenderer.STATE_SORTED_ASCENDING) : cellWidget.removeState(DefaultHeaderCellRenderer.STATE_SORTED_ASCENDING);
      }
    }
  });
  qx.ui.table.headerrenderer.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A cell renderer for data cells.
   */
  qx.Interface.define("qx.ui.table.ICellRenderer", {
    members: {
      /**
       * Creates the HTML for a data cell.
       *
       * The cellInfo map contains the following properties:
       * <ul>
       * <li>value (var): the cell's value.</li>
       * <li>rowData (var): contains the row data for the row, the cell belongs to.
       *   The kind of this object depends on the table model, see
       *   {@link qx.ui.table.ITableModel#getRowData}</li>
       * <li>row (int): the model index of the row the cell belongs to.</li>
       * <li>col (int): the model index of the column the cell belongs to.</li>
       * <li>table (qx.ui.table.Table): the table the cell belongs to.</li>
       * <li>xPos (int): the x position of the cell in the table pane.</li>
       * <li>selected (boolean): whether the cell is selected.</li>
       * <li>focusedRow (boolean): whether the cell is in the same row as the
       *   focused cell.</li>
       * <li>editable (boolean): whether the cell is editable.</li>
       * <li>style (string): The CSS styles that should be applied to the outer HTML
       *   element.</li>
       * <li>styleLeft (string): The left position of the cell.</li>
       * <li>styleWidth (string): The cell's width (pixel).</li>
       * <li>styleHeight (string): The cell's height (pixel).</li>
       * </ul>
       *
       * @param cellInfo {Map} A map containing the information about the cell to
       *     create.
       * @param htmlArr {String[]} Target string container. The HTML of the data
       *     cell should be appended to this array.
       *
       * @return {Boolean|undefined}
       *   A return value of <i>true</i> specifies that no additional cells in
       *   the row shall be rendered. This may be used, for example, for
       *   separator rows or for other special rendering purposes. Traditional
       *   cell renderers had no defined return value, so returned nothing
       *   (undefined). If this method returns either false or nothing, then
       *   rendering continues with the next cell in the row, which the normal
       *   mode of operation.
       */
      createDataCellHtml: function createDataCellHtml(cellInfo, htmlArr) {
        return true;
      }
    }
  });
  qx.ui.table.ICellRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.bom.Stylesheet": {
        "require": true
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.ICellRenderer": {
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.theme.manager.Meta": {
        "construct": true
      },
      "qx.theme.manager.Color": {},
      "qx.bom.element.Style": {},
      "qx.bom.client.Css": {},
      "qx.bom.element.BoxSizing": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxsizing": {
          "className": "qx.bom.client.Css"
        },
        "css.boxmodel": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * An abstract data cell renderer that does the basic coloring
   * (borders, selected look, ...).
   *
   * @require(qx.bom.Stylesheet)
   */
  qx.Class.define("qx.ui.table.cellrenderer.Abstract", {
    type: "abstract",
    implement: qx.ui.table.ICellRenderer,
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      var cr = qx.ui.table.cellrenderer.Abstract;

      if (!cr.__clazz) {
        cr.__clazz = qx.ui.table.cellrenderer.Abstract;

        this._createStyleSheet(); // add dynamic theme listener


        {
          qx.theme.manager.Meta.getInstance().addListener("changeTheme", this._onChangeTheme, this);
        }
      }
    },
    properties: {
      /**
       * The default cell style. The value of this property will be provided
       * to the cell renderer as cellInfo.style.
       */
      defaultCellStyle: {
        init: null,
        check: "String",
        nullable: true
      }
    },
    members: {
      /**
       * Handler for the theme change.
       * @signature function()
       */
      _onChangeTheme: function _onChangeTheme() {
        qx.bom.Stylesheet.removeAllRules(qx.ui.table.cellrenderer.Abstract.__clazz.stylesheet);

        this._createStyleSheet();
      },

      /**
       * the sum of the horizontal insets. This is needed to compute the box model
       * independent size
       */
      _insetX: 13,
      // paddingLeft + paddingRight + borderRight

      /**
       * the sum of the vertical insets. This is needed to compute the box model
       * independent size
       */
      _insetY: 0,

      /**
       * Creates the style sheet used for the table cells.
       */
      _createStyleSheet: function _createStyleSheet() {
        var colorMgr = qx.theme.manager.Color.getInstance();
        var stylesheet = ".qooxdoo-table-cell {" + qx.bom.element.Style.compile({
          position: "absolute",
          top: "0px",
          overflow: "hidden",
          whiteSpace: "nowrap",
          borderRight: "1px solid " + colorMgr.resolve("table-column-line"),
          padding: "0px 6px",
          cursor: "default",
          textOverflow: "ellipsis",
          userSelect: "none"
        }) + "} " + ".qooxdoo-table-cell-right { text-align:right } " + ".qooxdoo-table-cell-italic { font-style:italic} " + ".qooxdoo-table-cell-bold { font-weight:bold } ";

        if (qx.core.Environment.get("css.boxsizing")) {
          stylesheet += ".qooxdoo-table-cell {" + qx.bom.element.BoxSizing.compile("content-box") + "}";
        }

        qx.ui.table.cellrenderer.Abstract.__clazz.stylesheet = qx.bom.Stylesheet.createElement(stylesheet);
      },

      /**
       * Get a string of the cell element's HTML classes.
       *
       * This method may be overridden by sub classes.
       *
       * @param cellInfo {Map} cellInfo of the cell
       * @return {String} The table cell HTML classes as string.
       */
      _getCellClass: function _getCellClass(cellInfo) {
        return "qooxdoo-table-cell";
      },

      /**
       * Returns the CSS styles that should be applied to the main div of this
       * cell.
       *
       * This method may be overridden by sub classes.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {var} the CSS styles of the main div.
       */
      _getCellStyle: function _getCellStyle(cellInfo) {
        return cellInfo.style || "";
      },

      /**
        * Retrieve any extra attributes the cell renderer wants applied to this
        * cell.
        *
        * @param cellInfo {Map} The information about the cell.
        *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
        *
        * @return {String}
        *   The extra attributes to be applied to this cell.
        */
      _getCellAttributes: function _getCellAttributes(cellInfo) {
        return "";
      },

      /**
       * Returns the HTML that should be used inside the main div of this cell.
       *
       * This method may be overridden by sub classes.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {String} the inner HTML of the cell.
       */
      _getContentHtml: function _getContentHtml(cellInfo) {
        return cellInfo.value || "";
      },

      /**
       * Get the cell size taking the box model into account
       *
       * @param width {Integer} The cell's (border-box) width in pixel
       * @param height {Integer} The cell's (border-box) height in pixel
       * @param insetX {Integer} The cell's horizontal insets, i.e. the sum of
       *    horizontal paddings and borders
       * @param insetY {Integer} The cell's vertical insets, i.e. the sum of
       *    vertical paddings and borders
       * @return {String} The CSS style string for the cell size
       */
      _getCellSizeStyle: function _getCellSizeStyle(width, height, insetX, insetY) {
        var style = "";

        if (qx.core.Environment.get("css.boxmodel") == "content") {
          width -= insetX;
          height -= insetY;
        }

        style += "width:" + Math.max(width, 0) + "px;";
        style += "height:" + Math.max(height, 0) + "px;";
        return style;
      },
      // interface implementation
      createDataCellHtml: function createDataCellHtml(cellInfo, htmlArr) {
        htmlArr.push('<div class="', this._getCellClass(cellInfo), '" style="', 'left:', cellInfo.styleLeft, 'px;', this._getCellSizeStyle(cellInfo.styleWidth, cellInfo.styleHeight, this._insetX, this._insetY), this._getCellStyle(cellInfo), '" ', this._getCellAttributes(cellInfo), '>' + this._getContentHtml(cellInfo), '</div>');
      }
    },
    destruct: function destruct() {
      // remove dynamic theme listener
      {
        qx.theme.manager.Meta.getInstance().removeListener("changeTheme", this._onChangeTheme, this);
      }
    }
  });
  qx.ui.table.cellrenderer.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Abstract": {
        "require": true
      },
      "qx.bom.String": {},
      "qx.util.format.NumberFormat": {},
      "qx.util.format.DateFormat": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * The default data cell renderer.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Default", {
    extend: qx.ui.table.cellrenderer.Abstract,

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      STYLEFLAG_ALIGN_RIGHT: 1,
      STYLEFLAG_BOLD: 2,
      STYLEFLAG_ITALIC: 4,
      _numberFormat: null
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether the alignment should automatically be set according to the cell value.
       * If true numbers will be right-aligned.
       */
      useAutoAlign: {
        check: "Boolean",
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Determines the styles to apply to the cell
       *
       * @param cellInfo {Map} cellInfo of the cell
       *     See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {Integer} the sum of any of the STYLEFLAGS defined below
       */
      _getStyleFlags: function _getStyleFlags(cellInfo) {
        if (this.getUseAutoAlign()) {
          if (typeof cellInfo.value == "number") {
            return qx.ui.table.cellrenderer.Default.STYLEFLAG_ALIGN_RIGHT;
          }
        }

        return 0;
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        var cellClass = qx.ui.table.cellrenderer.Default.prototype._getCellClass.base.call(this, cellInfo);

        if (!cellClass) {
          return "";
        }

        var stylesToApply = this._getStyleFlags(cellInfo);

        if (stylesToApply & qx.ui.table.cellrenderer.Default.STYLEFLAG_ALIGN_RIGHT) {
          cellClass += " qooxdoo-table-cell-right";
        }

        if (stylesToApply & qx.ui.table.cellrenderer.Default.STYLEFLAG_BOLD) {
          cellClass += " qooxdoo-table-cell-bold";
        }

        if (stylesToApply & qx.ui.table.cellrenderer.Default.STYLEFLAG_ITALIC) {
          cellClass += " qooxdoo-table-cell-italic";
        }

        return cellClass;
      },
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        return qx.bom.String.escape(this._formatValue(cellInfo));
      },

      /**
       * Formats a value.
       *
       * @param cellInfo {Map} A map containing the information about the cell to
       *          create. This map has the same structure as in
       *          {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {String} the formatted value.
       */
      _formatValue: function _formatValue(cellInfo) {
        var value = cellInfo.value;
        var res;

        if (value == null) {
          return "";
        }

        if (typeof value == "string") {
          return value;
        } else if (typeof value == "number") {
          if (!qx.ui.table.cellrenderer.Default._numberFormat) {
            qx.ui.table.cellrenderer.Default._numberFormat = new qx.util.format.NumberFormat();

            qx.ui.table.cellrenderer.Default._numberFormat.setMaximumFractionDigits(2);
          }

          res = qx.ui.table.cellrenderer.Default._numberFormat.format(value);
        } else if (value instanceof Date) {
          res = qx.util.format.DateFormat.getDateInstance().format(value);
        } else {
          res = value.toString();
        }

        return res;
      }
    }
  });
  qx.ui.table.cellrenderer.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A factory creating widgets to use for editing table cells.
   */
  qx.Interface.define("qx.ui.table.ICellEditorFactory", {
    members: {
      /**
       * Creates a cell editor.
       *
       * The cellInfo map contains the following properties:
       * <ul>
       * <li>value (var): the cell's value.</li>
       * <li>row (int): the model index of the row the cell belongs to.</li>
       * <li>col (int): the model index of the column the cell belongs to.</li>
       * <li>xPos (int): the x position of the cell in the table pane.</li>
       * <li>table (qx.ui.table.Table) reference to the table, the cell belongs to. </li>
       * </ul>
       *
       * @abstract
       * @param cellInfo {Map} A map containing the information about the cell to
       *      create.
       * @return {qx.ui.core.Widget} the widget that should be used as cell editor.
       */
      createCellEditor: function createCellEditor(cellInfo) {
        return true;
      },

      /**
       * Returns the current value of a cell editor.
       *
       * @abstract
       * @param cellEditor {qx.ui.core.Widget} The cell editor formally created by
       *      {@link #createCellEditor}.
       * @return {var} the current value from the editor.
       */
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        return true;
      }
    }
  });
  qx.ui.table.ICellEditorFactory.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.table.ICellEditorFactory": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * An abstract cell editor factory creating text/password/spinner/... fields.
   */
  qx.Class.define("qx.ui.table.celleditor.AbstractField", {
    extend: qx.core.Object,
    implement: qx.ui.table.ICellEditorFactory,
    type: "abstract",
    properties: {
      /**
       * function that validates the result
       * the function will be called with the new value and the old value and is
       * supposed to return the value that is set as the table value.
       **/
      validationFunction: {
        check: "Function",
        nullable: true,
        init: null
      }
    },
    members: {
      /**
       * Factory to create the editor widget
       *
       * @return {qx.ui.core.Widget} The editor widget
       */
      _createEditor: function _createEditor() {
        throw new Error("Abstract method call!");
      },
      // interface implementation
      createCellEditor: function createCellEditor(cellInfo) {
        var cellEditor = this._createEditor();

        cellEditor.originalValue = cellInfo.value;

        if (cellInfo.value === null || cellInfo.value === undefined) {
          cellInfo.value = "";
        }

        cellEditor.setValue("" + cellInfo.value);
        cellEditor.addListener("appear", function () {
          cellEditor.selectAllText();
        });
        return cellEditor;
      },
      // interface implementation
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        var value = cellEditor.getValue(); // validation function will be called with new and old value

        var validationFunc = this.getValidationFunction();

        if (validationFunc) {
          value = validationFunc(value, cellEditor.originalValue);
        }

        if (typeof cellEditor.originalValue == "number") {
          value = parseFloat(value);
        }

        return value;
      }
    }
  });
  qx.ui.table.celleditor.AbstractField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.celleditor.AbstractField": {
        "require": true
      },
      "qx.ui.form.TextField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A cell editor factory creating text fields.
   */
  qx.Class.define("qx.ui.table.celleditor.TextField", {
    extend: qx.ui.table.celleditor.AbstractField,
    members: {
      // overridden
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        var value = cellEditor.getValue(); // validation function will be called with new and old value

        var validationFunc = this.getValidationFunction();

        if (validationFunc) {
          value = validationFunc(value, cellEditor.originalValue);
        }

        if (typeof cellEditor.originalValue == "number") {
          // Correct problem of NaN displaying when value is null string.
          //if (value != null) {
          if (value != null && value != '') {
            value = parseFloat(value);
          }
        }

        return value;
      },
      _createEditor: function _createEditor() {
        var cellEditor = new qx.ui.form.TextField();
        cellEditor.setAppearance("table-editor-textfield");
        return cellEditor;
      }
    }
  });
  qx.ui.table.celleditor.TextField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.headerrenderer.Default": {
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "require": true
      },
      "qx.ui.table.celleditor.TextField": {
        "require": true
      },
      "qx.ui.table.IHeaderRenderer": {},
      "qx.ui.table.ICellRenderer": {},
      "qx.ui.table.ICellEditorFactory": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A model that contains all meta data about columns, such as width, renderer,
   * visibility and order.
   *
   * @see qx.ui.table.ITableModel
   */
  qx.Class.define("qx.ui.table.columnmodel.Basic", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__overallColumnArr = [];
      this.__visibleColumnArr = [];
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the width of a column has changed. The data property of the event is
       * a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column the width of which has changed.</li>
       *   <li>newWidth: The new width of the column in pixels.</li>
       *   <li>oldWidth: The old width of the column in pixels.</li>
       * </ul>
       */
      "widthChanged": "qx.event.type.Data",

      /**
       * Fired when the visibility of a column has changed. This event is equal to
        * "visibilityChanged", but is fired right before.
       */
      "visibilityChangedPre": "qx.event.type.Data",

      /**
       * Fired when the visibility of a column has changed. The data property of the
       * event is a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column the visibility of which has changed.</li>
       *   <li>visible: Whether the column is now visible.</li>
       * </ul>
       */
      "visibilityChanged": "qx.event.type.Data",

      /**
       * Fired when the column order has changed. The data property of the
       * event is a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column that was moved.</li>
       *   <li>fromOverXPos: The old overall x position of the column.</li>
       *   <li>toOverXPos: The new overall x position of the column.</li>
       * </ul>
       */
      "orderChanged": "qx.event.type.Data",

      /**
       * Fired when the cell renderer of a column has changed.
       * The data property of the event is a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column that was moved.</li>
       * </ul>
       */
      "headerCellRendererChanged": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {Integer} the default width of a column in pixels. */
      DEFAULT_WIDTH: 100,

      /** @type {qx.ui.table.headerrenderer.Default} the default header cell renderer. */
      DEFAULT_HEADER_RENDERER: qx.ui.table.headerrenderer.Default,

      /** @type {qx.ui.table.cellrenderer.Default} the default data cell renderer. */
      DEFAULT_DATA_RENDERER: qx.ui.table.cellrenderer.Default,

      /** @type {qx.ui.table.celleditor.TextField} the default editor factory. */
      DEFAULT_EDITOR_FACTORY: qx.ui.table.celleditor.TextField
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __internalChange: null,
      __colToXPosMap: null,
      __visibleColumnArr: null,
      __overallColumnArr: null,
      __columnDataArr: null,
      __headerRenderer: null,
      __dataRenderer: null,
      __editorFactory: null,

      /**
       * Initializes the column model.
       *
       * @param colCount {Integer}
       *   The number of columns the model should have.
       *
       * @param table {qx.ui.table.Table}
       *   The table to which this column model is attached.
       */
      init: function init(colCount, table) {
        {
          this.assertInteger(colCount, "Invalid argument 'colCount'.");
        }
        this.__columnDataArr = [];
        var width = qx.ui.table.columnmodel.Basic.DEFAULT_WIDTH;
        var headerRenderer = this.__headerRenderer || (this.__headerRenderer = new qx.ui.table.columnmodel.Basic.DEFAULT_HEADER_RENDERER());
        var dataRenderer = this.__dataRenderer || (this.__dataRenderer = new qx.ui.table.columnmodel.Basic.DEFAULT_DATA_RENDERER());
        var editorFactory = this.__editorFactory || (this.__editorFactory = new qx.ui.table.columnmodel.Basic.DEFAULT_EDITOR_FACTORY());
        this.__overallColumnArr = [];
        this.__visibleColumnArr = []; // Get the initially hidden column array, if one was provided. Older
        // subclasses may not provide the 'table' argument, so we treat them
        // traditionally with no initially hidden columns.

        var initiallyHiddenColumns; // Was a table provided to us?

        if (table) {
          // Yup. Get its list of initially hidden columns, if the user provided
          // such a list.
          initiallyHiddenColumns = table.getInitiallyHiddenColumns();
        } // If no table was specified, or if the user didn't provide a list of
        // initially hidden columns, use an empty list.


        initiallyHiddenColumns = initiallyHiddenColumns || [];

        for (var col = 0; col < colCount; col++) {
          this.__columnDataArr[col] = {
            width: width,
            headerRenderer: headerRenderer,
            dataRenderer: dataRenderer,
            editorFactory: editorFactory
          };
          this.__overallColumnArr[col] = col;
          this.__visibleColumnArr[col] = col;
        }

        this.__colToXPosMap = null; // If any columns are initially hidden, hide them now. Make it an
        // internal change so that events are not generated.

        this.__internalChange = true;

        for (var hidden = 0; hidden < initiallyHiddenColumns.length; hidden++) {
          this.setColumnVisible(initiallyHiddenColumns[hidden], false);
        }

        this.__internalChange = false;

        for (col = 0; col < colCount; col++) {
          var data = {
            col: col,
            visible: this.isColumnVisible(col)
          };
          this.fireDataEvent("visibilityChangedPre", data);
          this.fireDataEvent("visibilityChanged", data);
        }
      },

      /**
       * Return the array of visible columns
       *
       * @return {Array} List of all visible columns
       */
      getVisibleColumns: function getVisibleColumns() {
        return this.__visibleColumnArr != null ? this.__visibleColumnArr : [];
      },

      /**
       * Sets the width of a column.
       *
       * @param col {Integer}
       *   The model index of the column.
       *
       * @param width {Integer}
       *   The new width the column should get in pixels.
       *
       * @param isPointerAction {Boolean}
       *   <i>true</i> if the column width is being changed as a result of a
       *   pointer drag in the header; false or undefined otherwise.
       *
       */
      setColumnWidth: function setColumnWidth(col, width, isPointerAction) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertInteger(width, "Invalid argument 'width'.");
          this.assertNotUndefined(this.__columnDataArr[col], "Column not found in table model");
        }
        var oldWidth = this.__columnDataArr[col].width;

        if (oldWidth != width) {
          this.__columnDataArr[col].width = width;
          var data = {
            col: col,
            newWidth: width,
            oldWidth: oldWidth,
            isPointerAction: isPointerAction || false
          };
          this.fireDataEvent("widthChanged", data);
        }
      },

      /**
       * Returns the width of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the width of the column in pixels.
       */
      getColumnWidth: function getColumnWidth(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertNotUndefined(this.__columnDataArr[col], "Column not found in table model");
        }
        return this.__columnDataArr[col].width;
      },

      /**
       * Sets the header renderer of a column. Use setHeaderCellRenderers
       * instead of this method if you want to set the header renderer of many
       * columns.
       *
       * @param col {Integer} the model index of the column.
       * @param renderer {qx.ui.table.IHeaderRenderer} the new header renderer the column
       *      should get.
       */
      setHeaderCellRenderer: function setHeaderCellRenderer(col, renderer) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertInterface(renderer, qx.ui.table.IHeaderRenderer, "Invalid argument 'renderer'.");
          this.assertNotUndefined(this.__columnDataArr[col], "Column not found in table model");
        }
        var oldRenderer = this.__columnDataArr[col].headerRenderer;

        if (oldRenderer !== this.__headerRenderer) {
          oldRenderer.dispose();
        }

        this.__columnDataArr[col].headerRenderer = renderer;

        if (!this.__internalChange) {
          this.fireDataEvent("headerCellRendererChanged", {
            col: col
          });
        }
      },

      /**
       * Sets the header renderer of one or more columns. Use this method, in
       * favor of setHeaderCellRenderer, if you want to set the header renderer
       * of many columns. This method fires the "headerCellRendererChanged"
       * event only once, after setting all renderers, whereas
       * setHeaderCellRenderer fires it for each changed renderer which can be
       * slow with many columns.
       *
       * @param renderers {Map}
       *   Map, where the keys are column numbers and values are the renderers,
       *   implementing qx.ui.table.IHeaderRenderer, of the the new header
       *   renderers for that column
       */
      setHeaderCellRenderers: function setHeaderCellRenderers(renderers) {
        var col; // Prevent firing "headerCellRendererChanged" for each column. Instead,
        // we'll fire it once at the end.

        this.__internalChange = true; // For each listed column...

        for (col in renderers) {
          // ... set that column's renderer
          this.setHeaderCellRenderer(+col, renderers[col]);
        } // Turn off the internal-change flag so operation returns to normal


        this.__internalChange = false; // Now we can fire the event once. The data indicates which columns
        // changed. Internally to qooxdoo, nothing cares about the event data.

        this.fireDataEvent("headerCellRendererChanged", {
          cols: Object.keys(renderers)
        });
      },

      /**
       * Returns the header renderer of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {qx.ui.table.IHeaderRenderer} the header renderer of the column.
       */
      getHeaderCellRenderer: function getHeaderCellRenderer(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertNotUndefined(this.__columnDataArr[col], "Column not found in table model");
        }
        return this.__columnDataArr[col].headerRenderer;
      },

      /**
       * Sets the data renderer of a column.
       *
       * @param col {Integer} the model index of the column.
       * @param renderer {qx.ui.table.ICellRenderer} the new data renderer
       *   the column should get.
       * @return {qx.ui.table.ICellRenderer?null} If an old renderer was set and
       *   it was not the default renderer, the old renderer is returned for
       *   pooling or disposing.
       */
      setDataCellRenderer: function setDataCellRenderer(col, renderer) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertInterface(renderer, qx.ui.table.ICellRenderer, "Invalid argument 'renderer'.");
          this.assertNotUndefined(this.__columnDataArr[col], "Column not found in table model");
        }
        var oldRenderer = this.__columnDataArr[col].dataRenderer;
        this.__columnDataArr[col].dataRenderer = renderer;

        if (oldRenderer !== this.__dataRenderer) {
          return oldRenderer;
        }

        return null;
      },

      /**
       * Returns the data renderer of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {qx.ui.table.ICellRenderer} the data renderer of the column.
       */
      getDataCellRenderer: function getDataCellRenderer(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertNotUndefined(this.__columnDataArr[col], "Column not found in table model");
        }
        return this.__columnDataArr[col].dataRenderer;
      },

      /**
       * Sets the cell editor factory of a column.
       *
       * @param col {Integer} the model index of the column.
       * @param factory {qx.ui.table.ICellEditorFactory} the new cell editor factory the column should get.
       */
      setCellEditorFactory: function setCellEditorFactory(col, factory) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertInterface(factory, qx.ui.table.ICellEditorFactory, "Invalid argument 'factory'.");
          this.assertNotUndefined(this.__columnDataArr[col], "Column not found in table model");
        }
        var oldFactory = this.__columnDataArr[col].editorFactory;

        if (oldFactory === factory) {
          return;
        }

        if (oldFactory !== this.__editorFactory) {
          oldFactory.dispose();
        }

        this.__columnDataArr[col].editorFactory = factory;
      },

      /**
       * Returns the cell editor factory of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {qx.ui.table.ICellEditorFactory} the cell editor factory of the column.
       */
      getCellEditorFactory: function getCellEditorFactory(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertNotUndefined(this.__columnDataArr[col], "Column not found in table model");
        }
        return this.__columnDataArr[col].editorFactory;
      },

      /**
       * Returns the map that translates model indexes to x positions.
       *
       * The returned map contains for a model index (int) a map having two
       * properties: overX (the overall x position of the column, int) and
       * visX (the visible x position of the column, int). visX is missing for
       * hidden columns.
       *
       * @return {Map} the "column to x position" map.
       */
      _getColToXPosMap: function _getColToXPosMap() {
        if (this.__colToXPosMap == null) {
          this.__colToXPosMap = {};

          for (var overX = 0; overX < this.__overallColumnArr.length; overX++) {
            var col = this.__overallColumnArr[overX];
            this.__colToXPosMap[col] = {
              overX: overX
            };
          }

          for (var visX = 0; visX < this.__visibleColumnArr.length; visX++) {
            var col = this.__visibleColumnArr[visX];
            this.__colToXPosMap[col].visX = visX;
          }
        }

        return this.__colToXPosMap;
      },

      /**
       * Returns the number of visible columns.
       *
       * @return {Integer} the number of visible columns.
       */
      getVisibleColumnCount: function getVisibleColumnCount() {
        return this.__visibleColumnArr != null ? this.__visibleColumnArr.length : 0;
      },

      /**
       * Returns the model index of a column at a certain visible x position.
       *
       * @param visXPos {Integer} the visible x position of the column.
       * @return {Integer} the model index of the column.
       */
      getVisibleColumnAtX: function getVisibleColumnAtX(visXPos) {
        {
          this.assertInteger(visXPos, "Invalid argument 'visXPos'.");
        }
        return this.__visibleColumnArr[visXPos];
      },

      /**
       * Returns the visible x position of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the visible x position of the column.
       */
      getVisibleX: function getVisibleX(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
        }
        return this._getColToXPosMap()[col].visX;
      },

      /**
       * Returns the overall number of columns (including hidden columns).
       *
       * @return {Integer} the overall number of columns.
       */
      getOverallColumnCount: function getOverallColumnCount() {
        return this.__overallColumnArr.length;
      },

      /**
       * Returns the model index of a column at a certain overall x position.
       *
       * @param overXPos {Integer} the overall x position of the column.
       * @return {Integer} the model index of the column.
       */
      getOverallColumnAtX: function getOverallColumnAtX(overXPos) {
        {
          this.assertInteger(overXPos, "Invalid argument 'overXPos'.");
        }
        return this.__overallColumnArr[overXPos];
      },

      /**
       * Returns the overall x position of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the overall x position of the column.
       */
      getOverallX: function getOverallX(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
        }
        return this._getColToXPosMap()[col].overX;
      },

      /**
       * Returns whether a certain column is visible.
       *
       * @param col {Integer} the model index of the column.
       * @return {Boolean} whether the column is visible.
       */
      isColumnVisible: function isColumnVisible(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
        }
        return this._getColToXPosMap()[col].visX != null;
      },

      /**
       * Sets whether a certain column is visible.
       *
       * @param col {Integer} the model index of the column.
       * @param visible {Boolean} whether the column should be visible.
       */
      setColumnVisible: function setColumnVisible(col, visible) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertBoolean(visible, "Invalid argument 'visible'.");
        }

        if (visible != this.isColumnVisible(col)) {
          if (visible) {
            var colToXPosMap = this._getColToXPosMap();

            var overX = colToXPosMap[col].overX;

            if (overX == null) {
              throw new Error("Showing column failed: " + col + ". The column is not added to this TablePaneModel.");
            } // get the visX of the next visible column after the column to show


            var nextVisX;

            for (var x = overX + 1; x < this.__overallColumnArr.length; x++) {
              var currCol = this.__overallColumnArr[x];
              var currVisX = colToXPosMap[currCol].visX;

              if (currVisX != null) {
                nextVisX = currVisX;
                break;
              }
            } // If there comes no visible column any more, then show the column
            // at the end


            if (nextVisX == null) {
              nextVisX = this.__visibleColumnArr.length;
            } // Add the column to the visible columns


            this.__visibleColumnArr.splice(nextVisX, 0, col);
          } else {
            var visX = this.getVisibleX(col);

            this.__visibleColumnArr.splice(visX, 1);
          } // Invalidate the __colToXPosMap


          this.__colToXPosMap = null; // Inform the listeners

          if (!this.__internalChange) {
            var data = {
              col: col,
              visible: visible
            };
            this.fireDataEvent("visibilityChangedPre", data);
            this.fireDataEvent("visibilityChanged", data);
          }
        }
      },

      /**
       * Moves a column.
       *
       * @param fromOverXPos {Integer} the overall x position of the column to move.
       * @param toOverXPos {Integer} the overall x position of where the column should be
       *      moved to.
       */
      moveColumn: function moveColumn(fromOverXPos, toOverXPos) {
        {
          this.assertInteger(fromOverXPos, "Invalid argument 'fromOverXPos'.");
          this.assertInteger(toOverXPos, "Invalid argument 'toOverXPos'.");
        }
        this.__internalChange = true;
        var col = this.__overallColumnArr[fromOverXPos];
        var visible = this.isColumnVisible(col);

        if (visible) {
          this.setColumnVisible(col, false);
        }

        this.__overallColumnArr.splice(fromOverXPos, 1);

        this.__overallColumnArr.splice(toOverXPos, 0, col); // Invalidate the __colToXPosMap


        this.__colToXPosMap = null;

        if (visible) {
          this.setColumnVisible(col, true);
        }

        this.__internalChange = false; // Inform the listeners

        var data = {
          col: col,
          fromOverXPos: fromOverXPos,
          toOverXPos: toOverXPos
        };
        this.fireDataEvent("orderChanged", data);
      },

      /**
       * Reorders all columns to new overall positions. Will fire one "orderChanged" event
       * without data afterwards
       *
       * @param newPositions {Integer[]} Array mapping the index of a column in table model to its wanted overall
       *                            position on screen (both zero based). If the table models holds
       *                            col0, col1, col2 and col3 and you give [1,3,2,0], the new column order
       *                            will be col3, col0, col2, col1
       */
      setColumnsOrder: function setColumnsOrder(newPositions) {
        {
          this.assertArray(newPositions, "Invalid argument 'newPositions'.");
        }

        if (newPositions.length == this.__overallColumnArr.length) {
          this.__internalChange = true; // Go through each column an switch visible ones to invisible. Reason is unknown,
          // this just mimicks the behaviour of moveColumn. Possibly useful because setting
          // a column visible later updates a map with its screen coords.

          var isVisible = new Array(newPositions.length);

          for (var colIdx = 0; colIdx < this.__overallColumnArr.length; colIdx++) {
            var visible = this.isColumnVisible(colIdx);
            isVisible[colIdx] = visible; //Remember, as this relies on this.__colToXPosMap which is cleared below

            if (visible) {
              this.setColumnVisible(colIdx, false);
            }
          } // Store new position values


          this.__overallColumnArr = qx.lang.Array.clone(newPositions); // Invalidate the __colToXPosMap

          this.__colToXPosMap = null; // Go through each column an switch invisible ones back to visible

          for (var colIdx = 0; colIdx < this.__overallColumnArr.length; colIdx++) {
            if (isVisible[colIdx]) {
              this.setColumnVisible(colIdx, true);
            }
          }

          this.__internalChange = false; // Inform the listeners. Do not add data as all known listeners in qooxdoo
          // only take this event to mean "total repaint necesscary". Fabian will look
          // after deprecating the data part of the orderChanged - event

          this.fireDataEvent("orderChanged");
        } else {
          throw new Error("setColumnsOrder: Invalid number of column positions given, expected " + this.__overallColumnArr.length + ", got " + newPositions.length);
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      for (var i = 0; i < this.__columnDataArr.length; i++) {
        this.__columnDataArr[i].headerRenderer.dispose();

        this.__columnDataArr[i].dataRenderer.dispose();

        this.__columnDataArr[i].editorFactory.dispose();
      }

      this.__overallColumnArr = this.__visibleColumnArr = this.__columnDataArr = this.__colToXPosMap = null;

      this._disposeObjects("__headerRenderer", "__dataRenderer", "__editorFactory");
    }
  });
  qx.ui.table.columnmodel.Basic.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The table pane that shows a certain section from a table. This class handles
   * the display of the data part of a table and is therefore the base for virtual
   * scrolling.
   */
  qx.Class.define("qx.ui.table.pane.Pane", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param paneScroller {qx.ui.table.pane.Scroller} the TablePaneScroller the header belongs to.
     */
    construct: function construct(paneScroller) {
      qx.ui.core.Widget.constructor.call(this);
      this.__paneScroller = paneScroller;
      this.__lastColCount = 0;
      this.__lastRowCount = 0;
      this.__rowCache = [];
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Whether the current view port of the pane has not loaded data.
       * The data object of the event indicates if the table pane has to reload
       * data or not. Can be used to give the user feedback of the loading state
       * of the rows.
       */
      "paneReloadsData": "qx.event.type.Data",

      /**
       * Whenever the content of the table pane has been updated (rendered)
       * trigger a paneUpdated event. This allows the canvas cellrenderer to act
       * once the new cells have been integrated in the dom.
       */
      "paneUpdated": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The index of the first row to show. */
      firstVisibleRow: {
        check: "Number",
        init: 0,
        apply: "_applyFirstVisibleRow"
      },

      /** The number of rows to show. */
      visibleRowCount: {
        check: "Number",
        init: 0,
        apply: "_applyVisibleRowCount"
      },

      /**
       * Maximum number of cached rows. If the value is <code>-1</code> the cache
       * size is unlimited
       */
      maxCacheLines: {
        check: "Number",
        init: 1000,
        apply: "_applyMaxCacheLines"
      },
      // overridden
      allowShrinkX: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __lastRowCount: null,
      __lastColCount: null,
      __paneScroller: null,
      __tableContainer: null,
      __focusedRow: null,
      __focusedCol: null,
      // sparse array to cache rendered rows
      __rowCache: null,
      __rowCacheCount: 0,
      // property modifier
      _applyFirstVisibleRow: function _applyFirstVisibleRow(value, old) {
        this.updateContent(false, value - old);
      },
      // property modifier
      _applyVisibleRowCount: function _applyVisibleRowCount(value, old) {
        this.updateContent(true);
      },
      // overridden
      _getContentHint: function _getContentHint() {
        // the preferred height is 400 pixel. We don't use rowCount * rowHeight
        // because this is typically too large.
        return {
          width: this.getPaneScroller().getTablePaneModel().getTotalWidth(),
          height: 400
        };
      },

      /**
       * Returns the TablePaneScroller this pane belongs to.
       *
       * @return {qx.ui.table.pane.Scroller} the TablePaneScroller.
       */
      getPaneScroller: function getPaneScroller() {
        return this.__paneScroller;
      },

      /**
       * Returns the table this pane belongs to.
       *
       * @return {qx.ui.table.Table} the table.
       */
      getTable: function getTable() {
        return this.__paneScroller.getTable();
      },

      /**
       * Sets the currently focused cell.
       *
       * @param col {Integer?null} the model index of the focused cell's column.
       * @param row {Integer?null} the model index of the focused cell's row.
       * @param massUpdate {Boolean ? false} Whether other updates are planned as well.
       *          If true, no repaint will be done.
       */
      setFocusedCell: function setFocusedCell(col, row, massUpdate) {
        if (col != this.__focusedCol || row != this.__focusedRow) {
          var oldRow = this.__focusedRow;
          this.__focusedCol = col;
          this.__focusedRow = row; // Update the focused row background

          if (row != oldRow && !massUpdate) {
            if (oldRow !== null) {
              this.updateContent(false, null, oldRow, true);
            }

            if (row !== null) {
              this.updateContent(false, null, row, true);
            }
          }
        }
      },

      /**
       * Event handler. Called when the selection has changed.
       */
      onSelectionChanged: function onSelectionChanged() {
        this.updateContent(false, null, null, true);
      },

      /**
       * Event handler. Called when the table gets or looses the focus.
       */
      onFocusChanged: function onFocusChanged() {
        this.updateContent(false, null, null, true);
      },

      /**
       * Sets the column width.
       *
       * @param col {Integer} the column to change the width for.
       * @param width {Integer} the new width.
       */
      setColumnWidth: function setColumnWidth(col, width) {
        this.updateContent(true);
      },

      /**
       * Event handler. Called the column order has changed.
       *
       */
      onColOrderChanged: function onColOrderChanged() {
        this.updateContent(true);
      },

      /**
       * Event handler. Called when the pane model has changed.
       */
      onPaneModelChanged: function onPaneModelChanged() {
        this.updateContent(true);
      },

      /**
       * Event handler. Called when the table model data has changed.
       *
       * @param firstRow {Integer} The index of the first row that has changed.
       * @param lastRow {Integer} The index of the last row that has changed.
       * @param firstColumn {Integer} The model index of the first column that has changed.
       * @param lastColumn {Integer} The model index of the last column that has changed.
       */
      onTableModelDataChanged: function onTableModelDataChanged(firstRow, lastRow, firstColumn, lastColumn) {
        this.__rowCacheClear();

        var paneFirstRow = this.getFirstVisibleRow();
        var rowCount = this.getVisibleRowCount();

        if (lastRow == -1 || lastRow >= paneFirstRow && firstRow < paneFirstRow + rowCount) {
          // The change intersects this pane
          this.updateContent();
        }
      },

      /**
       * Event handler. Called when the table model meta data has changed.
       *
       */
      onTableModelMetaDataChanged: function onTableModelMetaDataChanged() {
        this.updateContent(true);
      },
      // property apply method
      _applyMaxCacheLines: function _applyMaxCacheLines(value, old) {
        if (this.__rowCacheCount >= value && value !== -1) {
          this.__rowCacheClear();
        }
      },

      /**
       * Clear the row cache
       */
      __rowCacheClear: function __rowCacheClear() {
        this.__rowCache = [];
        this.__rowCacheCount = 0;
      },

      /**
       * Get a line from the row cache.
       *
       * @param row {Integer} Row index to get
       * @param selected {Boolean} Whether the row is currently selected
       * @param focused {Boolean} Whether the row is currently focused
       * @return {String|null} The cached row or null if a row with the given
       *     index is not cached.
       */
      __rowCacheGet: function __rowCacheGet(row, selected, focused) {
        if (!selected && !focused && this.__rowCache[row]) {
          return this.__rowCache[row];
        } else {
          return null;
        }
      },

      /**
       * Add a line to the row cache.
       *
       * @param row {Integer} Row index to set
       * @param rowString {String} computed row string to cache
       * @param selected {Boolean} Whether the row is currently selected
       * @param focused {Boolean} Whether the row is currently focused
       */
      __rowCacheSet: function __rowCacheSet(row, rowString, selected, focused) {
        var maxCacheLines = this.getMaxCacheLines();

        if (!selected && !focused && !this.__rowCache[row] && maxCacheLines > 0) {
          this._applyMaxCacheLines(maxCacheLines);

          this.__rowCache[row] = rowString;
          this.__rowCacheCount += 1;
        }
      },

      /**
       * Updates the content of the pane.
       *
       * @param completeUpdate {Boolean ? false} if true a complete update is performed.
       *      On a complete update all cell widgets are recreated.
       * @param scrollOffset {Integer ? null} If set specifies how many rows to scroll.
       * @param onlyRow {Integer ? null} if set only the specified row will be updated.
       * @param onlySelectionOrFocusChanged {Boolean ? false} if true, cell values won't
       *          be updated. Only the row background will.
       */
      updateContent: function updateContent(completeUpdate, scrollOffset, onlyRow, onlySelectionOrFocusChanged) {
        if (completeUpdate) {
          this.__rowCacheClear();
        }

        if (scrollOffset && Math.abs(scrollOffset) <= Math.min(10, this.getVisibleRowCount())) {
          this._scrollContent(scrollOffset);
        } else if (onlySelectionOrFocusChanged && !this.getTable().getAlwaysUpdateCells()) {
          this._updateRowStyles(onlyRow);
        } else {
          this._updateAllRows();
        }
      },

      /**
       * If only focus or selection changes it is sufficient to only update the
       * row styles. This method updates the row styles of all visible rows or
       * of just one row.
       *
       * @param onlyRow {Integer|null ? null} If this parameter is set only the row
       *     with this index is updated.
       */
      _updateRowStyles: function _updateRowStyles(onlyRow) {
        var elem = this.getContentElement().getDomElement();

        if (!elem || !elem.firstChild) {
          this._updateAllRows();

          return;
        }

        var table = this.getTable();
        var selectionModel = table.getSelectionModel();
        var tableModel = table.getTableModel();
        var rowRenderer = table.getDataRowRenderer();
        var rowNodes = elem.firstChild.childNodes;
        var cellInfo = {
          table: table
        }; // We don't want to execute the row loop below more than necessary. If
        // onlyRow is not null, we want to do the loop only for that row.
        // In that case, we start at (set the "row" variable to) that row, and
        // stop at (set the "end" variable to the offset of) the next row.

        var row = this.getFirstVisibleRow();
        var y = 0; // How many rows do we need to update?

        var end = rowNodes.length;

        if (onlyRow != null) {
          // How many rows are we skipping?
          var offset = onlyRow - row;

          if (offset >= 0 && offset < end) {
            row = onlyRow;
            y = offset;
            end = offset + 1;
          } else {
            return;
          }
        }

        for (; y < end; y++, row++) {
          cellInfo.row = row;
          cellInfo.selected = selectionModel.isSelectedIndex(row);
          cellInfo.focusedRow = this.__focusedRow == row;
          cellInfo.rowData = tableModel.getRowData(row);
          rowRenderer.updateDataRowElement(cellInfo, rowNodes[y]);
        }

        ;
      },

      /**
       * Get the HTML table fragment for the given row range.
       *
       * @param firstRow {Integer} Index of the first row
       * @param rowCount {Integer} Number of rows
       * @return {String} The HTML table fragment for the given row range.
       */
      _getRowsHtml: function _getRowsHtml(firstRow, rowCount) {
        var table = this.getTable();
        var selectionModel = table.getSelectionModel();
        var tableModel = table.getTableModel();
        var columnModel = table.getTableColumnModel();
        var paneModel = this.getPaneScroller().getTablePaneModel();
        var rowRenderer = table.getDataRowRenderer();
        tableModel.prefetchRows(firstRow, firstRow + rowCount - 1);
        var rowHeight = table.getRowHeight();
        var colCount = paneModel.getColumnCount();
        var left = 0;
        var cols = []; // precompute column properties

        for (var x = 0; x < colCount; x++) {
          var col = paneModel.getColumnAtX(x);
          var cellWidth = columnModel.getColumnWidth(col);
          cols.push({
            col: col,
            xPos: x,
            editable: tableModel.isColumnEditable(col),
            focusedCol: this.__focusedCol == col,
            styleLeft: left,
            styleWidth: cellWidth
          });
          left += cellWidth;
        }

        var rowsArr = [];
        var paneReloadsData = false;

        for (var row = firstRow; row < firstRow + rowCount; row++) {
          var selected = selectionModel.isSelectedIndex(row);
          var focusedRow = this.__focusedRow == row;

          var cachedRow = this.__rowCacheGet(row, selected, focusedRow);

          if (cachedRow) {
            rowsArr.push(cachedRow);
            continue;
          }

          var rowHtml = [];
          var cellInfo = {
            table: table
          };
          cellInfo.styleHeight = rowHeight;
          cellInfo.row = row;
          cellInfo.selected = selected;
          cellInfo.focusedRow = focusedRow;
          cellInfo.rowData = tableModel.getRowData(row);

          if (!cellInfo.rowData) {
            paneReloadsData = true;
          }

          rowHtml.push('<div ');
          var rowAttributes = rowRenderer.getRowAttributes(cellInfo);

          if (rowAttributes) {
            rowHtml.push(rowAttributes);
          }

          var rowClass = rowRenderer.getRowClass(cellInfo);

          if (rowClass) {
            rowHtml.push('class="', rowClass, '" ');
          }

          var rowStyle = rowRenderer.createRowStyle(cellInfo);
          rowStyle += ";position:relative;" + rowRenderer.getRowHeightStyle(rowHeight) + "width:100%;";

          if (rowStyle) {
            rowHtml.push('style="', rowStyle, '" ');
          }

          rowHtml.push('>');
          var stopLoop = false;

          for (x = 0; x < colCount && !stopLoop; x++) {
            var col_def = cols[x];

            for (var attr in col_def) {
              cellInfo[attr] = col_def[attr];
            }

            var col = cellInfo.col; // Use the "getValue" method of the tableModel to get the cell's
            // value working directly on the "rowData" object
            // (-> cellInfo.rowData[col];) is not a solution because you can't
            // work with the columnIndex -> you have to use the columnId of the
            // columnIndex This is exactly what the method "getValue" does

            cellInfo.value = tableModel.getValue(col, row);
            var cellRenderer = columnModel.getDataCellRenderer(col); // Retrieve the current default cell style for this column.

            cellInfo.style = cellRenderer.getDefaultCellStyle(); // Allow a cell renderer to tell us not to draw any further cells in
            // the row. Older, or traditional cell renderers don't return a
            // value, however, from createDataCellHtml, so assume those are
            // returning false.
            //
            // Tested with http://tinyurl.com/333hyhv

            stopLoop = cellRenderer.createDataCellHtml(cellInfo, rowHtml) || false;
          }

          rowHtml.push('</div>');
          var rowString = rowHtml.join("");

          this.__rowCacheSet(row, rowString, selected, focusedRow);

          rowsArr.push(rowString);
        }

        this.fireDataEvent("paneReloadsData", paneReloadsData);
        return rowsArr.join("");
      },

      /**
       * Scrolls the pane's contents by the given offset.
       *
       * @param rowOffset {Integer} Number of lines to scroll. Scrolling up is
       *     represented by a negative offset.
       */
      _scrollContent: function _scrollContent(rowOffset) {
        var el = this.getContentElement().getDomElement();

        if (!(el && el.firstChild)) {
          this._updateAllRows();

          return;
        }

        var tableBody = el.firstChild;
        var tableChildNodes = tableBody.childNodes;
        var rowCount = this.getVisibleRowCount();
        var firstRow = this.getFirstVisibleRow();
        var tabelModel = this.getTable().getTableModel();
        var modelRowCount = 0;
        modelRowCount = tabelModel.getRowCount(); // don't handle this special case here

        if (firstRow + rowCount > modelRowCount) {
          this._updateAllRows();

          return;
        } // remove old lines


        var removeRowBase = rowOffset < 0 ? rowCount + rowOffset : 0;
        var addRowBase = rowOffset < 0 ? 0 : rowCount - rowOffset;

        for (var i = Math.abs(rowOffset) - 1; i >= 0; i--) {
          var rowElem = tableChildNodes[removeRowBase];

          try {
            tableBody.removeChild(rowElem);
          } catch (exp) {
            break;
          }
        } // render new lines


        if (!this.__tableContainer) {
          this.__tableContainer = document.createElement("div");
        }

        var tableDummy = '<div>';
        tableDummy += this._getRowsHtml(firstRow + addRowBase, Math.abs(rowOffset));
        tableDummy += '</div>';
        this.__tableContainer.innerHTML = tableDummy;
        var newTableRows = this.__tableContainer.firstChild.childNodes; // append new lines

        if (rowOffset > 0) {
          for (var i = newTableRows.length - 1; i >= 0; i--) {
            var rowElem = newTableRows[0];
            tableBody.appendChild(rowElem);
          }
        } else {
          for (var i = newTableRows.length - 1; i >= 0; i--) {
            var rowElem = newTableRows[newTableRows.length - 1];
            tableBody.insertBefore(rowElem, tableBody.firstChild);
          }
        } // update focus indicator


        if (this.__focusedRow !== null) {
          this._updateRowStyles(this.__focusedRow - rowOffset);

          this._updateRowStyles(this.__focusedRow);
        }

        this.fireEvent("paneUpdated");
      },

      /**
       * Updates the content of the pane (implemented using array joins).
       */
      _updateAllRows: function _updateAllRows() {
        var elem = this.getContentElement().getDomElement();

        if (!elem) {
          // pane has not yet been rendered
          this.addListenerOnce("appear", this._updateAllRows, this);
          return;
        }

        var table = this.getTable();
        var tableModel = table.getTableModel();
        var paneModel = this.getPaneScroller().getTablePaneModel();
        var colCount = paneModel.getColumnCount();
        var rowHeight = table.getRowHeight();
        var firstRow = this.getFirstVisibleRow();
        var rowCount = this.getVisibleRowCount();
        var modelRowCount = tableModel.getRowCount();

        if (firstRow + rowCount > modelRowCount) {
          rowCount = Math.max(0, modelRowCount - firstRow);
        }

        var rowWidth = paneModel.getTotalWidth();
        var htmlArr; // If there are any rows...

        if (rowCount > 0) {
          // ... then create a div for them and add the rows to it.
          htmlArr = ["<div style='", "width: 100%;", table.getForceLineHeight() ? "line-height: " + rowHeight + "px;" : "", "overflow: hidden;", "'>", this._getRowsHtml(firstRow, rowCount), "</div>"];
        } else {
          // Otherwise, don't create the div, as even an empty div creates a
          // white row in IE.
          htmlArr = [];
        }

        var data = htmlArr.join("");
        elem.innerHTML = data;
        this.setWidth(rowWidth);
        this.__lastColCount = colCount;
        this.__lastRowCount = rowCount;
        this.fireEvent("paneUpdated");
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__tableContainer = this.__paneScroller = this.__rowCache = null;
      this.removeListener("track", this._onTrack, this);
    }
  });
  qx.ui.table.pane.Pane.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.core.Blocker": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * Shows the header of a table.
   */
  qx.Class.define("qx.ui.table.pane.Header", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param paneScroller {qx.ui.table.pane.Scroller} the TablePaneScroller the header belongs to.
     */
    construct: function construct(paneScroller) {
      qx.ui.core.Widget.constructor.call(this);

      this._setLayout(new qx.ui.layout.HBox()); // add blocker


      this.__blocker = new qx.ui.core.Blocker(this);
      this.__paneScroller = paneScroller;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __paneScroller: null,
      __moveFeedback: null,
      __lastPointerOverColumn: null,
      __blocker: null,

      /**
       * Returns the TablePaneScroller this header belongs to.
       *
       * @return {qx.ui.table.pane.Scroller} the TablePaneScroller.
       */
      getPaneScroller: function getPaneScroller() {
        return this.__paneScroller;
      },

      /**
       * Returns the table this header belongs to.
       *
       * @return {qx.ui.table.Table} the table.
       */
      getTable: function getTable() {
        return this.__paneScroller.getTable();
      },

      /**
       * Returns the blocker of the header.
       *
       * @return {qx.ui.core.Blocker} the blocker.
       */
      getBlocker: function getBlocker() {
        return this.__blocker;
      },

      /**
       * Event handler. Called the column order has changed.
       *
       */
      onColOrderChanged: function onColOrderChanged() {
        this._updateContent(true);
      },

      /**
       * Event handler. Called when the pane model has changed.
       */
      onPaneModelChanged: function onPaneModelChanged() {
        this._updateContent(true);
      },

      /**
       * Event handler. Called when the table model meta data has changed.
       *
       */
      onTableModelMetaDataChanged: function onTableModelMetaDataChanged() {
        this._updateContent();
      },

      /**
       * Sets the column width. This overrides the width from the column model.
       *
       * @param col {Integer}
       *   The column to change the width for.
       *
       * @param width {Integer}
       *   The new width.
       *
       * @param isPointerAction {Boolean}
       *   <i>true</i> if the column width is being changed as a result of a
       *   pointer drag in the header; false or undefined otherwise.
       *
       */
      setColumnWidth: function setColumnWidth(col, width, isPointerAction) {
        var child = this.getHeaderWidgetAtColumn(col);

        if (child != null) {
          child.setWidth(width);
        }
      },

      /**
       * Sets the column the pointer is currently over.
       *
       * @param col {Integer} the model index of the column the pointer is currently over or
       *      null if the pointer is over no column.
       */
      setPointerOverColumn: function setPointerOverColumn(col) {
        if (col != this.__lastPointerOverColumn) {
          if (this.__lastPointerOverColumn != null) {
            var widget = this.getHeaderWidgetAtColumn(this.__lastPointerOverColumn);

            if (widget != null) {
              widget.removeState("hovered");
            }
          }

          if (col != null) {
            this.getHeaderWidgetAtColumn(col).addState("hovered");
          }

          this.__lastPointerOverColumn = col;
        }
      },

      /**
       * Get the header widget for the given column
       *
       * @param col {Integer} The column number
       * @return {qx.ui.table.headerrenderer.HeaderCell} The header cell widget
       */
      getHeaderWidgetAtColumn: function getHeaderWidgetAtColumn(col) {
        var xPos = this.getPaneScroller().getTablePaneModel().getX(col);
        return this._getChildren()[xPos];
      },

      /**
       * Shows the feedback shown while a column is moved by the user.
       *
       * @param col {Integer} the model index of the column to show the move feedback for.
       * @param x {Integer} the x position the left side of the feedback should have
       *      (in pixels, relative to the left side of the header).
       */
      showColumnMoveFeedback: function showColumnMoveFeedback(col, x) {
        var pos = this.getContentLocation();

        if (this.__moveFeedback == null) {
          var table = this.getTable();
          var xPos = this.getPaneScroller().getTablePaneModel().getX(col);

          var cellWidget = this._getChildren()[xPos];

          var tableModel = table.getTableModel();
          var columnModel = table.getTableColumnModel();
          var cellInfo = {
            xPos: xPos,
            col: col,
            name: tableModel.getColumnName(col),
            table: table
          };
          var cellRenderer = columnModel.getHeaderCellRenderer(col);
          var feedback = cellRenderer.createHeaderCell(cellInfo);
          var size = cellWidget.getBounds(); // Configure the feedback

          feedback.setWidth(size.width);
          feedback.setHeight(size.height);
          feedback.setZIndex(1000000);
          feedback.setOpacity(0.8);
          feedback.setLayoutProperties({
            top: pos.top
          });
          this.getApplicationRoot().add(feedback);
          this.__moveFeedback = feedback;
        }

        this.__moveFeedback.setLayoutProperties({
          left: pos.left + x
        });

        this.__moveFeedback.show();
      },

      /**
       * Hides the feedback shown while a column is moved by the user.
       */
      hideColumnMoveFeedback: function hideColumnMoveFeedback() {
        if (this.__moveFeedback != null) {
          this.__moveFeedback.destroy();

          this.__moveFeedback = null;
        }
      },

      /**
       * Returns whether the column move feedback is currently shown.
       *
       * @return {Boolean} <code>true</code> whether the column move feedback is
       *    currently shown, <code>false</code> otherwise.
       */
      isShowingColumnMoveFeedback: function isShowingColumnMoveFeedback() {
        return this.__moveFeedback != null;
      },

      /**
       * Updates the content of the header.
       *
       * @param completeUpdate {Boolean} if true a complete update is performed. On a
       *      complete update all header widgets are recreated.
       */
      _updateContent: function _updateContent(completeUpdate) {
        var table = this.getTable();
        var tableModel = table.getTableModel();
        var columnModel = table.getTableColumnModel();
        var paneModel = this.getPaneScroller().getTablePaneModel();

        var children = this._getChildren();

        var colCount = paneModel.getColumnCount();
        var sortedColumn = tableModel.getSortColumnIndex(); // Remove all widgets on the complete update

        if (completeUpdate) {
          this._cleanUpCells();
        } // Update the header


        var cellInfo = {};
        cellInfo.sortedAscending = tableModel.isSortAscending();

        for (var x = 0; x < colCount; x++) {
          var col = paneModel.getColumnAtX(x);

          if (col === undefined) {
            continue;
          }

          var colWidth = columnModel.getColumnWidth(col);
          var cellRenderer = columnModel.getHeaderCellRenderer(col);
          cellInfo.xPos = x;
          cellInfo.col = col;
          cellInfo.name = tableModel.getColumnName(col);
          cellInfo.editable = tableModel.isColumnEditable(col);
          cellInfo.sorted = col == sortedColumn;
          cellInfo.table = table; // Get the cached widget

          var cachedWidget = children[x]; // Create or update the widget

          if (cachedWidget == null) {
            // We have no cached widget -> create it
            cachedWidget = cellRenderer.createHeaderCell(cellInfo);
            cachedWidget.set({
              width: colWidth
            });

            this._add(cachedWidget);
          } else {
            // This widget already created before -> recycle it
            cellRenderer.updateHeaderCell(cellInfo, cachedWidget);
          } // set the states


          if (x === 0) {
            cachedWidget.addState("first");
            cachedWidget.removeState("last");
          } else if (x === colCount - 1) {
            cachedWidget.removeState("first");
            cachedWidget.addState("last");
          } else {
            cachedWidget.removeState("first");
            cachedWidget.removeState("last");
          }
        }
      },

      /**
       * Cleans up all header cells.
       *
       */
      _cleanUpCells: function _cleanUpCells() {
        var children = this._getChildren();

        for (var x = children.length - 1; x >= 0; x--) {
          var cellWidget = children[x];
          cellWidget.destroy();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__blocker.dispose();

      this._disposeObjects("__paneScroller");
    }
  });
  qx.ui.table.pane.Header.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.scroll.MScrollBarFactory": {
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.container.Composite": {
        "construct": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.bom.client.Device": {
        "construct": true
      },
      "qx.bom.client.Scroll": {
        "construct": true
      },
      "qx.ui.layout.Canvas": {
        "construct": true
      },
      "qx.event.Timer": {
        "construct": true
      },
      "qx.ui.table.pane.FocusIndicator": {},
      "qx.ui.core.scroll.AbstractScrollArea": {},
      "qx.ui.table.pane.Clipper": {},
      "qx.ui.table.pane.CellEvent": {},
      "qx.lang.Number": {},
      "qx.ui.window.Window": {},
      "qx.event.GlobalError": {
        "usage": "dynamic",
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "device.type": {
          "construct": true,
          "className": "qx.bom.client.Device"
        },
        "os.scrollBarOverlayed": {
          "construct": true,
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Shows a whole meta column. This includes a {@link Header},
   * a {@link Pane} and the needed scroll bars. This class handles the
   * virtual scrolling and does all the pointer event handling.
   *
   * @childControl header {qx.ui.table.pane.Header} header pane
   * @childControl pane {qx.ui.table.pane.Pane} table pane to show the data
   * @childControl focus-indicator {qx.ui.table.pane.FocusIndicator} shows the current focused cell
   * @childControl resize-line {qx.ui.core.Widget} resize line widget
   * @childControl scrollbar-x {qx.ui.core.scroll.ScrollBar?qx.ui.core.scroll.NativeScrollBar}
   *               horizontal scrollbar widget (depends on the "qx.nativeScrollBars" setting which implementation is used)
   * @childControl scrollbar-y {qx.ui.core.scroll.ScrollBar?qx.ui.core.scroll.NativeScrollBar}
   *               vertical scrollbar widget (depends on the "qx.nativeScrollBars" setting which implementation is used)
   */
  qx.Class.define("qx.ui.table.pane.Scroller", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.scroll.MScrollBarFactory],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param table {qx.ui.table.Table} the table the scroller belongs to.
     */
    construct: function construct(table) {
      qx.ui.core.Widget.constructor.call(this);
      this.__table = table; // init layout

      var grid = new qx.ui.layout.Grid();
      grid.setColumnFlex(0, 1);
      grid.setRowFlex(1, 1);

      this._setLayout(grid); // init child controls


      this.__header = this._showChildControl("header");
      this.__tablePane = this._showChildControl("pane"); // the top line containing the header clipper and the top right widget

      this.__top = new qx.ui.container.Composite(new qx.ui.layout.HBox()).set({
        minWidth: 0
      });

      this._add(this.__top, {
        row: 0,
        column: 0,
        colSpan: 2
      }); // embed header into a scrollable container


      this._headerClipper = this._createHeaderClipper();

      this._headerClipper.add(this.__header);

      this._headerClipper.addListener("losecapture", this._onChangeCaptureHeader, this);

      this._headerClipper.addListener("pointermove", this._onPointermoveHeader, this);

      this._headerClipper.addListener("pointerdown", this._onPointerdownHeader, this);

      this._headerClipper.addListener("pointerup", this._onPointerupHeader, this);

      this._headerClipper.addListener("tap", this._onTapHeader, this);

      this.__top.add(this._headerClipper, {
        flex: 1
      }); // embed pane into a scrollable container


      this._paneClipper = this._createPaneClipper();

      this._paneClipper.add(this.__tablePane);

      this._paneClipper.addListener("roll", this._onRoll, this);

      this._paneClipper.addListener("pointermove", this._onPointermovePane, this);

      this._paneClipper.addListener("pointerdown", this._onPointerdownPane, this);

      this._paneClipper.addListener("tap", this._onTapPane, this);

      this._paneClipper.addListener("contextmenu", this._onTapPane, this);

      this._paneClipper.addListener("contextmenu", this._onContextMenu, this);

      if (qx.core.Environment.get("device.type") === "desktop") {
        this._paneClipper.addListener("dblclick", this._onDbltapPane, this);
      } else {
        this._paneClipper.addListener("dbltap", this._onDbltapPane, this);
      }

      this._paneClipper.addListener("resize", this._onResizePane, this); // if we have overlayed scroll bars, we should use a separate container


      if (qx.core.Environment.get("os.scrollBarOverlayed")) {
        this.__clipperContainer = new qx.ui.container.Composite();

        this.__clipperContainer.setLayout(new qx.ui.layout.Canvas());

        this.__clipperContainer.add(this._paneClipper, {
          edge: 0
        });

        this._add(this.__clipperContainer, {
          row: 1,
          column: 0
        });
      } else {
        this._add(this._paneClipper, {
          row: 1,
          column: 0
        });
      } // init scroll bars


      this.__horScrollBar = this._showChildControl("scrollbar-x");
      this.__verScrollBar = this._showChildControl("scrollbar-y"); // init focus indicator

      this.__focusIndicator = this.getChildControl("focus-indicator"); // need to run the apply method at least once [BUG #4057]

      this.initShowCellFocusIndicator(); // force creation of the resize line

      this.getChildControl("resize-line").hide();
      this.addListener("pointerout", this._onPointerout, this);
      this.addListener("appear", this._onAppear, this);
      this.addListener("disappear", this._onDisappear, this);
      this.__timer = new qx.event.Timer();

      this.__timer.addListener("interval", this._oninterval, this);

      this.initScrollTimeout();
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {int} The minimum width a column could get in pixels. */
      MIN_COLUMN_WIDTH: 10,

      /** @type {int} The radius of the resize region in pixels. */
      RESIZE_REGION_RADIUS: 5,

      /**
       * (int) The number of pixels the pointer may move between pointer down and pointer up
       * in order to count as a tap.
       */
      TAP_TOLERANCE: 5,

      /**
       * (int) The mask for the horizontal scroll bar.
       * May be combined with {@link #VERTICAL_SCROLLBAR}.
       *
       * @see #getNeededScrollBars
       */
      HORIZONTAL_SCROLLBAR: 1,

      /**
       * (int) The mask for the vertical scroll bar.
       * May be combined with {@link #HORIZONTAL_SCROLLBAR}.
       *
       * @see #getNeededScrollBars
       */
      VERTICAL_SCROLLBAR: 2
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    events: {
      /** Dispatched if the pane is scrolled horizontally */
      "changeScrollY": "qx.event.type.Data",

      /** Dispatched if the pane is scrolled vertically */
      "changeScrollX": "qx.event.type.Data",

      /**See {@link qx.ui.table.Table#cellTap}.*/
      "cellTap": "qx.ui.table.pane.CellEvent",

      /*** See {@link qx.ui.table.Table#cellDbltap}.*/
      "cellDbltap": "qx.ui.table.pane.CellEvent",

      /**See {@link qx.ui.table.Table#cellContextmenu}.*/
      "cellContextmenu": "qx.ui.table.pane.CellEvent",

      /** Dispatched when a sortable header was tapped */
      "beforeSort": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether to show the horizontal scroll bar. This is a tri-state
       * value. `true` means show the scroll bar; `false` means exclude it; null
       * means hide it so it retains its space but doesn't show a scroll bar.
       */
      horizontalScrollBarVisible: {
        check: "Boolean",
        init: false,
        apply: "_applyHorizontalScrollBarVisible",
        event: "changeHorizontalScrollBarVisible",
        nullable: true
      },

      /** Whether to show the vertical scroll bar */
      verticalScrollBarVisible: {
        check: "Boolean",
        init: false,
        apply: "_applyVerticalScrollBarVisible",
        event: "changeVerticalScrollBarVisible"
      },

      /** The table pane model. */
      tablePaneModel: {
        check: "qx.ui.table.pane.Model",
        apply: "_applyTablePaneModel",
        event: "changeTablePaneModel"
      },

      /**
       * Whether column resize should be live. If false, during resize only a line is
       * shown and the real resize happens when the user releases the pointer button.
       */
      liveResize: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether the focus should moved when the pointer is moved over a cell. If false
       * the focus is only moved on pointer taps.
       */
      focusCellOnPointerMove: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether to handle selections via the selection manager before setting the
       * focus.  The traditional behavior is to handle selections after setting the
       * focus, but setting the focus means redrawing portions of the table, and
       * some subclasses may want to modify the data to be displayed based on the
       * selection.
       */
      selectBeforeFocus: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether the cell focus indicator should be shown
       */
      showCellFocusIndicator: {
        check: "Boolean",
        init: true,
        apply: "_applyShowCellFocusIndicator"
      },

      /**
       * By default, the "cellContextmenu" event is fired only when a data cell
       * is right-clicked. It is not fired when a right-click occurs in the
       * empty area of the table below the last data row. By turning on this
       * property, "cellContextMenu" events will also be generated when a
       * right-click occurs in that empty area. In such a case, row identifier
       * in the event data will be null, so event handlers can check (row ===
       * null) to handle this case.
       */
      contextMenuFromDataCellsOnly: {
        check: "Boolean",
        init: true
      },

      /**
       * Whether to reset the selection when a header cell is tapped. Since
       * most data models do not have provisions to retain a selection after
       * sorting, the default is to reset the selection in this case. Some data
       * models, however, do have the capability to retain the selection, so
       * when using those, this property should be set to false.
       */
      resetSelectionOnHeaderTap: {
        check: "Boolean",
        init: true
      },

      /**
       * Interval time (in milliseconds) for the table update timer.
       * Setting this to 0 clears the timer.
       */
      scrollTimeout: {
        check: "Integer",
        init: 100,
        apply: "_applyScrollTimeout"
      },
      appearance: {
        refine: true,
        init: "table-scroller"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __lastRowCount: null,
      __table: null,
      __updateInterval: null,
      __updateContentPlanned: null,
      __onintervalWrapper: null,
      _moveColumn: null,
      __lastMoveColPos: null,
      _lastMoveTargetX: null,
      _lastMoveTargetScroller: null,
      __lastMovePointerPageX: null,
      __resizeColumn: null,
      __lastResizePointerPageX: null,
      __lastResizeWidth: null,
      __lastPointerDownCell: null,
      __firedTapEvent: false,
      __ignoreTap: null,
      __lastPointerPageX: null,
      __lastPointerPageY: null,
      __focusedCol: null,
      __focusedRow: null,
      _cellEditor: null,
      __cellEditorFactory: null,
      __topRightWidget: null,
      __horScrollBar: null,
      __verScrollBar: null,
      __header: null,
      _headerClipper: null,
      __tablePane: null,
      _paneClipper: null,
      __clipperContainer: null,
      __focusIndicator: null,
      __top: null,
      __timer: null,
      __focusIndicatorPointerDownListener: null,

      /**
       * The right inset of the pane. The right inset is the maximum of the
       * top right widget width and the scrollbar width (if visible).
       *
       * @return {Integer} The right inset of the pane
       */
      getPaneInsetRight: function getPaneInsetRight() {
        var topRight = this.getTopRightWidget();
        var topRightWidth = topRight && topRight.isVisible() && topRight.getBounds() ? topRight.getBounds().width + topRight.getMarginLeft() + topRight.getMarginRight() : 0;
        var scrollBar = this.__verScrollBar;
        var scrollBarWidth = this.getVerticalScrollBarVisible() ? this.getVerticalScrollBarWidth() + scrollBar.getMarginLeft() + scrollBar.getMarginRight() : 0;
        return Math.max(topRightWidth, scrollBarWidth);
      },

      /**
       * Set the pane's width
       *
       * @param width {Integer} The pane's width
       */
      setPaneWidth: function setPaneWidth(width) {
        if (this.isVerticalScrollBarVisible()) {
          width += this.getPaneInsetRight();
        }

        this.setWidth(width);
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "header":
            control = this.getTable().getNewTablePaneHeader()(this);
            break;

          case "pane":
            control = this.getTable().getNewTablePane()(this);
            break;

          case "focus-indicator":
            control = new qx.ui.table.pane.FocusIndicator(this);
            control.setUserBounds(0, 0, 0, 0);
            control.setZIndex(1000);
            control.addListener("pointerup", this._onPointerupFocusIndicator, this);

            this._paneClipper.add(control);

            control.show(); // must be active for editor to operate

            control.setDecorator(null); // it can be initially invisible, though.

            break;

          case "resize-line":
            control = new qx.ui.core.Widget();
            control.setUserBounds(0, 0, 0, 0);
            control.setZIndex(1000);

            this._paneClipper.add(control);

            break;

          case "scrollbar-x":
            control = this._createScrollBar("horizontal").set({
              alignY: "bottom"
            });
            control.addListener("scroll", this._onScrollX, this);

            if (this.__clipperContainer != null) {
              control.setMinHeight(qx.ui.core.scroll.AbstractScrollArea.DEFAULT_SCROLLBAR_WIDTH);

              this.__clipperContainer.add(control, {
                bottom: 0,
                right: 0,
                left: 0
              });
            } else {
              this._add(control, {
                row: 2,
                column: 0
              });
            }

            break;

          case "scrollbar-y":
            control = this._createScrollBar("vertical");
            control.addListener("scroll", this._onScrollY, this);

            if (this.__clipperContainer != null) {
              this.__clipperContainer.add(control, {
                right: 0,
                bottom: 0,
                top: 0
              });
            } else {
              this._add(control, {
                row: 1,
                column: 1
              });
            }

            break;
        }

        return control || qx.ui.table.pane.Scroller.prototype._createChildControlImpl.base.call(this, id);
      },
      // property modifier
      _applyHorizontalScrollBarVisible: function _applyHorizontalScrollBarVisible(value, old) {
        if (value === null) {
          this.__horScrollBar.setVisibility("hidden");
        } else {
          this.__horScrollBar.setVisibility(value ? "visible" : "excluded");
        }
      },
      // property modifier
      _applyVerticalScrollBarVisible: function _applyVerticalScrollBarVisible(value, old) {
        this.__verScrollBar.setVisibility(value ? "visible" : "excluded");
      },
      // property modifier
      _applyTablePaneModel: function _applyTablePaneModel(value, old) {
        if (old != null) {
          old.removeListener("modelChanged", this._onPaneModelChanged, this);
        }

        value.addListener("modelChanged", this._onPaneModelChanged, this);
      },
      // property modifier
      _applyShowCellFocusIndicator: function _applyShowCellFocusIndicator(value, old) {
        if (value) {
          this.__focusIndicator.setDecorator("table-scroller-focus-indicator");

          this._updateFocusIndicator();
        } else {
          if (this.__focusIndicator) {
            this.__focusIndicator.setDecorator(null);
          }
        }
      },

      /**
       * Get the current position of the vertical scroll bar.
       *
       * @return {Integer} The current scroll position.
       */
      getScrollY: function getScrollY() {
        return this.__verScrollBar.getPosition();
      },

      /**
       * Set the current position of the vertical scroll bar.
       *
       * @param scrollY {Integer} The new scroll position.
       * @param renderSync {Boolean?false} Whether the table update should be
       *     performed synchronously.
       */
      setScrollY: function setScrollY(scrollY, renderSync) {
        this.__verScrollBar.scrollTo(scrollY);

        if (renderSync) {
          this._updateContent();
        }
      },

      /**
       * Get the current position of the vertical scroll bar.
       *
       * @return {Integer} The current scroll position.
       */
      getScrollX: function getScrollX() {
        return this.__horScrollBar.getPosition();
      },

      /**
       * Set the current position of the vertical scroll bar.
       *
       * @param scrollX {Integer} The new scroll position.
       */
      setScrollX: function setScrollX(scrollX) {
        this.__horScrollBar.scrollTo(scrollX);
      },

      /**
       * Returns the table this scroller belongs to.
       *
       * @return {qx.ui.table.Table} the table.
       */
      getTable: function getTable() {
        return this.__table;
      },

      /**
       * Creates and returns an instance of pane clipper.
       *
       * @return {qx.ui.table.pane.Clipper} pane clipper.
       */
      _createPaneClipper: function _createPaneClipper() {
        return new qx.ui.table.pane.Clipper();
      },

      /**
       * Creates and returns an instance of header clipper.
       *
       * @return {qx.ui.table.pane.Clipper} pane clipper.
       */
      _createHeaderClipper: function _createHeaderClipper() {
        return new qx.ui.table.pane.Clipper();
      },

      /**
       * Event handler. Called when the visibility of a column has changed.
       */
      onColVisibilityChanged: function onColVisibilityChanged() {
        this.updateHorScrollBarMaximum();

        this._updateFocusIndicator();
      },

      /**
       * Sets the column width.
       *
       * @param col {Integer} the column to change the width for.
       * @param width {Integer} the new width.
       */
      setColumnWidth: function setColumnWidth(col, width) {
        this.__header.setColumnWidth(col, width);

        this.__tablePane.setColumnWidth(col, width);

        var paneModel = this.getTablePaneModel();
        var x = paneModel.getX(col);

        if (x != -1) {
          // The change was in this scroller
          this.updateHorScrollBarMaximum();

          this._updateFocusIndicator();
        }
      },

      /**
       * Event handler. Called when the column order has changed.
       *
       */
      onColOrderChanged: function onColOrderChanged() {
        this.__header.onColOrderChanged();

        this.__tablePane.onColOrderChanged();

        this.updateHorScrollBarMaximum();
      },

      /**
       * Event handler. Called when the table model has changed.
       *
       * @param firstRow {Integer} The index of the first row that has changed.
       * @param lastRow {Integer} The index of the last row that has changed.
       * @param firstColumn {Integer} The model index of the first column that has changed.
       * @param lastColumn {Integer} The model index of the last column that has changed.
       */
      onTableModelDataChanged: function onTableModelDataChanged(firstRow, lastRow, firstColumn, lastColumn) {
        this.__tablePane.onTableModelDataChanged(firstRow, lastRow, firstColumn, lastColumn);

        var rowCount = this.getTable().getTableModel().getRowCount();

        var colCount = this.__table.getTableColumnModel().getOverallColumnCount();

        if (rowCount != this.__lastRowCount) {
          this.updateVerScrollBarMaximum();

          if (this.getFocusedRow() === null && rowCount > 0 && colCount > 0) {
            this.setFocusedCell(this.getFocusedColumn() || 0, 0);
          } else if (this.getFocusedRow() >= rowCount) {
            if (rowCount == 0) {
              this.setFocusedCell(null, null);
            } else {
              this.setFocusedCell(this.getFocusedColumn(), rowCount - 1);
            }
          }

          this.__lastRowCount = rowCount;
        }
      },

      /**
       * Event handler. Called when the selection has changed.
       */
      onSelectionChanged: function onSelectionChanged() {
        this.__tablePane.onSelectionChanged();
      },

      /**
       * Event handler. Called when the table gets or looses the focus.
       */
      onFocusChanged: function onFocusChanged() {
        this.__tablePane.onFocusChanged();
      },

      /**
       * Event handler. Called when the table model meta data has changed.
       *
       */
      onTableModelMetaDataChanged: function onTableModelMetaDataChanged() {
        this.__header.onTableModelMetaDataChanged();

        this.__tablePane.onTableModelMetaDataChanged();
      },

      /**
       * Event handler. Called when the pane model has changed.
       */
      _onPaneModelChanged: function _onPaneModelChanged() {
        this.__header.onPaneModelChanged();

        this.__tablePane.onPaneModelChanged();
      },

      /**
       * Event listener for the pane clipper's resize event
       */
      _onResizePane: function _onResizePane() {
        this.updateHorScrollBarMaximum();
        this.updateVerScrollBarMaximum(); // The height has changed -> Update content

        this._updateContent();

        this.__header._updateContent();

        this.__table._updateScrollBarVisibility();
      },

      /**
       * Updates the maximum of the horizontal scroll bar, so it corresponds to the
       * total width of the columns in the table pane.
       */
      updateHorScrollBarMaximum: function updateHorScrollBarMaximum() {
        var paneSize = this._paneClipper.getInnerSize();

        if (!paneSize) {
          // will be called on the next resize event again
          return;
        }

        var scrollSize = this.getTablePaneModel().getTotalWidth();
        var scrollBar = this.__horScrollBar;

        if (paneSize.width < scrollSize) {
          var max = Math.max(0, scrollSize - paneSize.width);
          scrollBar.setMaximum(max);
          scrollBar.setKnobFactor(paneSize.width / scrollSize);
          var pos = scrollBar.getPosition();
          scrollBar.setPosition(Math.min(pos, max));
        } else {
          scrollBar.setMaximum(0);
          scrollBar.setKnobFactor(1);
          scrollBar.setPosition(0);
        }
      },

      /**
       * Updates the maximum of the vertical scroll bar, so it corresponds to the
       * number of rows in the table.
       */
      updateVerScrollBarMaximum: function updateVerScrollBarMaximum() {
        var paneSize = this._paneClipper.getInnerSize();

        if (!paneSize) {
          // will be called on the next resize event again
          return;
        }

        var tableModel = this.getTable().getTableModel();
        var rowCount = tableModel.getRowCount();

        if (this.getTable().getKeepFirstVisibleRowComplete()) {
          rowCount += 1;
        }

        var rowHeight = this.getTable().getRowHeight();
        var scrollSize = rowCount * rowHeight;
        var scrollBar = this.__verScrollBar;

        if (paneSize.height < scrollSize) {
          var max = Math.max(0, scrollSize - paneSize.height);
          scrollBar.setMaximum(max);
          scrollBar.setKnobFactor(paneSize.height / scrollSize);
          var pos = scrollBar.getPosition();
          scrollBar.setPosition(Math.min(pos, max));
        } else {
          scrollBar.setMaximum(0);
          scrollBar.setKnobFactor(1);
          scrollBar.setPosition(0);
        }
      },

      /**
       * Event handler. Called when the table property "keepFirstVisibleRowComplete"
       * changed.
       */
      onKeepFirstVisibleRowCompleteChanged: function onKeepFirstVisibleRowCompleteChanged() {
        this.updateVerScrollBarMaximum();

        this._updateContent();
      },

      /**
       * Event handler for the scroller's appear event
       */
      _onAppear: function _onAppear() {
        // after the Scroller appears we start the interval again
        this._startInterval(this.getScrollTimeout());
      },

      /**
       * Event handler for the disappear event
       */
      _onDisappear: function _onDisappear() {
        // before the scroller disappears we need to stop it
        this._stopInterval();
      },

      /**
       * Event handler. Called when the horizontal scroll bar moved.
       *
       * @param e {Map} the event.
       */
      _onScrollX: function _onScrollX(e) {
        var scrollLeft = e.getData();
        this.fireDataEvent("changeScrollX", scrollLeft, e.getOldData());

        this._headerClipper.scrollToX(scrollLeft);

        this._paneClipper.scrollToX(scrollLeft);
      },

      /**
       * Event handler. Called when the vertical scroll bar moved.
       *
       * @param e {Map} the event.
       */
      __inOnScrollY: false,
      _onScrollY: function _onScrollY(e) {
        if (this.__inOnScrollY) {
          return;
        }

        var scrollbar = this.__verScrollBar;
        this.__inOnScrollY = true; // calculate delta so that one row is scrolled at an minimum

        var rowHeight = this.getTable().getRowHeight();
        var delta = e.getData() - e.getOldData();

        if (Math.abs(delta) > 1 && Math.abs(delta) < rowHeight) {
          delta = delta < 0 ? e.getOldData() - rowHeight : e.getOldData() + rowHeight;

          if (delta >= 0 && delta <= scrollbar.getMaximum()) {
            scrollbar.setPosition(delta);
          }
        }

        this.__inOnScrollY = false;
        this.fireDataEvent("changeScrollY", scrollbar.getPosition(), e.getOldData());

        this._postponedUpdateContent();
      },

      /**
       * Event handler. Called when the user moved the mouse wheel.
       *
       * @param e {qx.event.type.Roll} the event.
       */
      _onRoll: function _onRoll(e) {
        var table = this.getTable();

        if (e.getPointerType() == "mouse" || !table.getEnabled()) {
          return;
        } // vertical scrolling


        var delta = e.getDelta(); // normalize that at least one step is scrolled at a time

        if (delta.y > 0 && delta.y < 1) {
          delta.y = 1;
        } else if (delta.y < 0 && delta.y > -1) {
          delta.y = -1;
        }

        this.__verScrollBar.scrollBy(parseInt(delta.y, 10));

        var scrolled = delta.y != 0 && !this.__isAtEdge(this.__verScrollBar, delta.y); // horizontal scrolling
        // normalize that at least one step is scrolled at a time

        if (delta.x > 0 && delta.x < 1) {
          delta.x = 1;
        } else if (delta.x < 0 && delta.x > -1) {
          delta.x = -1;
        }

        this.__horScrollBar.scrollBy(parseInt(delta.x, 10)); // Update the focus


        if (this.__lastPointerPageX && this.getFocusCellOnPointerMove()) {
          this._focusCellAtPagePos(this.__lastPointerPageX, this.__lastPointerPageY);
        }

        scrolled = scrolled || delta.x != 0 && !this.__isAtEdge(this.__horScrollBar, delta.x); // pass the event to the parent if the scrollbar is at an edge

        if (scrolled) {
          e.stop();
        } else {
          e.stopMomentum();
        }
      },

      /**
       * Checks if the table has been scrolled.
       * @param scrollBar {qx.ui.core.scroll.IScrollBar} The scrollbar to check
       * @param delta {Number} The scroll delta.
       * @return {Boolean} <code>true</code>, if the scrolling is a the edge
       */
      __isAtEdge: function __isAtEdge(scrollBar, delta) {
        var position = scrollBar.getPosition();
        return delta < 0 && position <= 0 || delta > 0 && position >= scrollBar.getMaximum();
      },

      /**
       * Common column resize logic.
       *
       * @param pageX {Integer} the current pointer x position.
       */
      __handleResizeColumn: function __handleResizeColumn(pageX) {
        var table = this.getTable(); // We are currently resizing -> Update the position

        var headerCell = this.__header.getHeaderWidgetAtColumn(this.__resizeColumn);

        var minColumnWidth = headerCell.getSizeHint().minWidth;
        var newWidth = Math.max(minColumnWidth, this.__lastResizeWidth + pageX - this.__lastResizePointerPageX);

        if (this.getLiveResize()) {
          var columnModel = table.getTableColumnModel();
          columnModel.setColumnWidth(this.__resizeColumn, newWidth, true);
        } else {
          var paneModel = this.getTablePaneModel();

          this._showResizeLine(paneModel.getColumnLeft(this.__resizeColumn) + newWidth);
        }

        this.__lastResizePointerPageX += newWidth - this.__lastResizeWidth;
        this.__lastResizeWidth = newWidth;
      },

      /**
       * Common column move logic.
       *
       * @param pageX {Integer} the current pointer x position.
       *
       */
      __handleMoveColumn: function __handleMoveColumn(pageX) {
        // We are moving a column
        // Check whether we moved outside the tap tolerance so we can start
        // showing the column move feedback
        // (showing the column move feedback prevents the ontap event)
        var tapTolerance = qx.ui.table.pane.Scroller.TAP_TOLERANCE;

        if (this.__header.isShowingColumnMoveFeedback() || pageX > this.__lastMovePointerPageX + tapTolerance || pageX < this.__lastMovePointerPageX - tapTolerance) {
          this.__lastMoveColPos += pageX - this.__lastMovePointerPageX;

          this.__header.showColumnMoveFeedback(this._moveColumn, this.__lastMoveColPos); // Get the responsible scroller


          var targetScroller = this.__table.getTablePaneScrollerAtPageX(pageX);

          if (this._lastMoveTargetScroller && this._lastMoveTargetScroller != targetScroller) {
            this._lastMoveTargetScroller.hideColumnMoveFeedback();
          }

          if (targetScroller != null) {
            this._lastMoveTargetX = targetScroller.showColumnMoveFeedback(pageX);
          } else {
            this._lastMoveTargetX = null;
          }

          this._lastMoveTargetScroller = targetScroller;
          this.__lastMovePointerPageX = pageX;
        }
      },

      /**
       * Event handler. Called when the user moved the pointer over the header.
       *
       * @param e {Map} the event.
       */
      _onPointermoveHeader: function _onPointermoveHeader(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        var useResizeCursor = false;
        var pointerOverColumn = null;
        var pageX = e.getDocumentLeft();
        var pageY = e.getDocumentTop(); // Workaround: In onmousewheel the event has wrong coordinates for pageX
        //       and pageY. So we remember the last move event.

        this.__lastPointerPageX = pageX;
        this.__lastPointerPageY = pageY;

        if (this.__resizeColumn != null) {
          // We are currently resizing -> Update the position
          this.__handleResizeColumn(pageX);

          useResizeCursor = true;
          e.stopPropagation();
        } else if (this._moveColumn != null) {
          // We are moving a column
          this.__handleMoveColumn(pageX);

          e.stopPropagation();
        } else {
          var resizeCol = this._getResizeColumnForPageX(pageX);

          if (resizeCol != -1) {
            // The pointer is over a resize region -> Show the right cursor
            useResizeCursor = true;
          } else {
            var tableModel = table.getTableModel();

            var col = this._getColumnForPageX(pageX);

            if (col != null && tableModel.isColumnSortable(col)) {
              pointerOverColumn = col;
            }
          }
        }

        var cursor = useResizeCursor ? "col-resize" : null;
        this.getApplicationRoot().setGlobalCursor(cursor);
        this.setCursor(cursor);

        this.__header.setPointerOverColumn(pointerOverColumn);
      },

      /**
       * Event handler. Called when the user moved the pointer over the pane.
       *
       * @param e {Map} the event.
       */
      _onPointermovePane: function _onPointermovePane(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        } //var useResizeCursor = false;


        var pageX = e.getDocumentLeft();
        var pageY = e.getDocumentTop(); // Workaround: In onpointerwheel the event has wrong coordinates for pageX
        //       and pageY. So we remember the last move event.

        this.__lastPointerPageX = pageX;
        this.__lastPointerPageY = pageY;
        var useResizeCursor = false;

        var resizeCol = this._getResizeColumnForPageX(pageX);

        if (resizeCol != -1) {
          // The pointer is over a resize region -> Show the right cursor
          useResizeCursor = true;
        }

        var cursor = useResizeCursor ? "col-resize" : null;
        this.getApplicationRoot().setGlobalCursor(cursor);
        this.setCursor(cursor);

        var row = this._getRowForPagePos(pageX, pageY);

        if (row != null && this._getColumnForPageX(pageX) != null) {
          // The pointer is over the data -> update the focus
          if (this.getFocusCellOnPointerMove()) {
            this._focusCellAtPagePos(pageX, pageY);
          }
        }

        this.__header.setPointerOverColumn(null);
      },

      /**
       * Event handler. Called when the user pressed a pointer button over the header.
       *
       * @param e {Map} the event.
       */
      _onPointerdownHeader: function _onPointerdownHeader(e) {
        if (!this.getTable().getEnabled()) {
          return;
        }

        var pageX = e.getDocumentLeft(); // pointer is in header

        var resizeCol = this._getResizeColumnForPageX(pageX);

        if (resizeCol != -1) {
          // The pointer is over a resize region -> Start resizing
          this._startResizeHeader(resizeCol, pageX);

          e.stop();
        } else {
          // The pointer is not in a resize region
          var moveCol = this._getColumnForPageX(pageX);

          if (moveCol != null) {
            this._startMoveHeader(moveCol, pageX);

            e.stop();
          }
        }
      },

      /**
       * Start a resize session of the header.
       *
       * @param resizeCol {Integer} the column index
       * @param pageX {Integer} x coordinate of the pointer event
       */
      _startResizeHeader: function _startResizeHeader(resizeCol, pageX) {
        var columnModel = this.getTable().getTableColumnModel(); // The pointer is over a resize region -> Start resizing

        this.__resizeColumn = resizeCol;
        this.__lastResizePointerPageX = pageX;
        this.__lastResizeWidth = columnModel.getColumnWidth(this.__resizeColumn);

        this._headerClipper.capture();
      },

      /**
       * Start a move session of the header.
       *
       * @param moveCol {Integer} the column index
       * @param pageX {Integer} x coordinate of the pointer event
       */
      _startMoveHeader: function _startMoveHeader(moveCol, pageX) {
        // Prepare column moving
        this._moveColumn = moveCol;
        this.__lastMovePointerPageX = pageX;
        this.__lastMoveColPos = this.getTablePaneModel().getColumnLeft(moveCol);

        this._headerClipper.capture();
      },

      /**
       * Event handler. Called when the user pressed a pointer button over the pane.
       *
       * @param e {Map} the event.
       */
      _onPointerdownPane: function _onPointerdownPane(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        if (table.isEditing()) {
          table.stopEditing();
        }

        var pageX = e.getDocumentLeft(); // pointer is in header

        var resizeCol = this._getResizeColumnForPageX(pageX);

        if (resizeCol != -1) {
          // The pointer is over a resize region -> Start resizing
          this._startResizeHeader(resizeCol, pageX);

          e.stop();
          return;
        }

        var pageY = e.getDocumentTop();

        var row = this._getRowForPagePos(pageX, pageY);

        var col = this._getColumnForPageX(pageX);

        if (row !== null) {
          // The focus indicator blocks the tap event on the scroller so we
          // store the current cell and listen for the pointerup event on the
          // focus indicator
          //
          // INVARIANT:
          //  The members of this object always contain the last position of
          //  the cell on which the pointerdown event occurred.
          //  *** These values are never cleared! ***.
          //  Different browsers/OS combinations issue events in different
          //  orders, and the context menu event, in particular, can be issued
          //  early or late (Firefox on Linux issues it early; Firefox on
          //  Windows issues it late) so no one may clear these values.
          //
          this.__lastPointerDownCell = {
            row: row,
            col: col
          }; // On the other hand, we need to know if we've issued the tap event
          // so we don't issue it twice, both from pointer-up on the focus
          // indicator, and from the tap even on the pane. Both possibilities
          // are necessary, however, to maintain the qooxdoo order of events.

          this.__firedTapEvent = false;
        }
      },

      /**
       * Event handler for the focus indicator's pointerup event
       *
       * @param e {qx.event.type.Pointer} The pointer event
       */
      _onPointerupFocusIndicator: function _onPointerupFocusIndicator(e) {
        if (this.__lastPointerDownCell && !this.__firedTapEvent && !this.isEditing() && this.__focusIndicator.getRow() == this.__lastPointerDownCell.row && this.__focusIndicator.getColumn() == this.__lastPointerDownCell.col) {
          this.fireEvent("cellTap", qx.ui.table.pane.CellEvent, [this, e, this.__lastPointerDownCell.row, this.__lastPointerDownCell.col], true);
          this.__firedTapEvent = true;
        } else if (!this.isEditing()) {
          // if no cellTap event should be fired, act like a pointerdown which
          // invokes the change of the selection e.g. [BUG #1632]
          this._onPointerdownPane(e);
        }
      },

      /**
       * Event handler. Called when the event capturing of the header changed.
       * Stops/finishes an active header resize/move session if it lost capturing
       * during the session to stay in a stable state.
       *
       * @param e {qx.event.type.Data} The data event
       */
      _onChangeCaptureHeader: function _onChangeCaptureHeader(e) {
        if (this.__resizeColumn != null) {
          this._stopResizeHeader();
        }

        if (this._moveColumn != null) {
          this._stopMoveHeader();
        }
      },

      /**
       * Stop a resize session of the header.
       *
       */
      _stopResizeHeader: function _stopResizeHeader() {
        var columnModel = this.getTable().getTableColumnModel(); // We are currently resizing -> Finish resizing

        if (!this.getLiveResize()) {
          this._hideResizeLine();

          columnModel.setColumnWidth(this.__resizeColumn, this.__lastResizeWidth, true);
        }

        this.__resizeColumn = null;

        this._headerClipper.releaseCapture();

        this.getApplicationRoot().setGlobalCursor(null);
        this.setCursor(null);
      },

      /**
       * Stop a move session of the header.
       *
       */
      _stopMoveHeader: function _stopMoveHeader() {
        var columnModel = this.getTable().getTableColumnModel();
        var paneModel = this.getTablePaneModel(); // We are moving a column -> Drop the column

        this.__header.hideColumnMoveFeedback();

        if (this._lastMoveTargetScroller) {
          this._lastMoveTargetScroller.hideColumnMoveFeedback();
        }

        if (this._lastMoveTargetX != null) {
          var fromVisXPos = paneModel.getFirstColumnX() + paneModel.getX(this._moveColumn);
          var toVisXPos = this._lastMoveTargetX;

          if (toVisXPos != fromVisXPos && toVisXPos != fromVisXPos + 1) {
            // The column was really moved to another position
            // (and not moved before or after itself, which is a noop)
            // Translate visible positions to overall positions
            var fromCol = columnModel.getVisibleColumnAtX(fromVisXPos);
            var toCol = columnModel.getVisibleColumnAtX(toVisXPos);
            var fromOverXPos = columnModel.getOverallX(fromCol);
            var toOverXPos = toCol != null ? columnModel.getOverallX(toCol) : columnModel.getOverallColumnCount();

            if (toOverXPos > fromOverXPos) {
              // Don't count the column itself
              toOverXPos--;
            } // Move the column


            columnModel.moveColumn(fromOverXPos, toOverXPos); // update the focus indicator including the editor

            this._updateFocusIndicator();
          }
        }

        this._moveColumn = null;
        this._lastMoveTargetX = null;

        this._headerClipper.releaseCapture();
      },

      /**
       * Event handler. Called when the user released a pointer button over the header.
       *
       * @param e {Map} the event.
       */
      _onPointerupHeader: function _onPointerupHeader(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        if (this.__resizeColumn != null) {
          this._stopResizeHeader();

          this.__ignoreTap = true;
          e.stop();
        } else if (this._moveColumn != null) {
          this._stopMoveHeader();

          e.stop();
        }
      },

      /**
       * Event handler. Called when the user tapped a pointer button over the header.
       *
       * @param e {Map} the event.
       */
      _onTapHeader: function _onTapHeader(e) {
        if (this.__ignoreTap) {
          this.__ignoreTap = false;
          return;
        }

        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        var tableModel = table.getTableModel();
        var pageX = e.getDocumentLeft();

        var resizeCol = this._getResizeColumnForPageX(pageX);

        if (resizeCol == -1) {
          // pointer is not in a resize region
          var col = this._getColumnForPageX(pageX);

          if (col != null && tableModel.isColumnSortable(col)) {
            // Sort that column
            var sortCol = tableModel.getSortColumnIndex();
            var ascending = col != sortCol ? true : !tableModel.isSortAscending();
            var data = {
              column: col,
              ascending: ascending,
              tapEvent: e
            };

            if (this.fireDataEvent("beforeSort", data, null, true)) {
              // Stop cell editing
              if (table.isEditing()) {
                table.stopEditing();
              }

              tableModel.sortByColumn(col, ascending);

              if (this.getResetSelectionOnHeaderTap()) {
                table.getSelectionModel().resetSelection();
              }
            }
          }
        }

        e.stop();
      },

      /**
       * Event handler. Called when the user tapped a pointer button over the pane.
       *
       * @param e {Map} the event.
       */
      _onTapPane: function _onTapPane(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        var pageX = e.getDocumentLeft();
        var pageY = e.getDocumentTop();

        var row = this._getRowForPagePos(pageX, pageY);

        var col = this._getColumnForPageX(pageX);

        if (row != null && col != null) {
          var selectBeforeFocus = this.getSelectBeforeFocus();

          if (selectBeforeFocus) {
            table.getSelectionManager().handleTap(row, e);
          } // The pointer is over the data -> update the focus


          if (!this.getFocusCellOnPointerMove()) {
            this._focusCellAtPagePos(pageX, pageY);
          }

          if (!selectBeforeFocus) {
            table.getSelectionManager().handleTap(row, e);
          }

          if (this.__focusIndicator.isHidden() || this.__lastPointerDownCell && !this.__firedTapEvent && !this.isEditing() && row == this.__lastPointerDownCell.row && col == this.__lastPointerDownCell.col) {
            this.fireEvent("cellTap", qx.ui.table.pane.CellEvent, [this, e, row, col], true);
            this.__firedTapEvent = true;
          }
        }
      },

      /**
       * Event handler. Called when a context menu is invoked in a cell.
       *
       * @param e {qx.event.type.Pointer} the event.
       */
      _onContextMenu: function _onContextMenu(e) {
        var pageX = e.getDocumentLeft();
        var pageY = e.getDocumentTop();

        var row = this._getRowForPagePos(pageX, pageY);

        var col = this._getColumnForPageX(pageX);
        /*
         * The 'row' value will be null if the right-click was in the blank
         * area below the last data row. Some applications desire to receive
         * the context menu event anyway, and can set the property value of
         * contextMenuFromDataCellsOnly to false to achieve that.
         */


        if (row === null && this.getContextMenuFromDataCellsOnly()) {
          return;
        }

        if (!this.getShowCellFocusIndicator() || row === null || this.__lastPointerDownCell && row == this.__lastPointerDownCell.row && col == this.__lastPointerDownCell.col) {
          this.fireEvent("cellContextmenu", qx.ui.table.pane.CellEvent, [this, e, row, col], true); // Now that the cellContextmenu handler has had a chance to build
          // the menu for this cell, display it (if there is one).

          var menu = this.getTable().getContextMenu();

          if (menu) {
            // A menu with no children means don't display any context menu
            // including the default context menu even if the default context
            // menu is allowed to be displayed normally. There's no need to
            // actually show an empty menu, though.
            if (menu.getChildren().length > 0) {
              menu.openAtPointer(e);
            } else {
              menu.exclude();
            } // Do not show native menu


            e.preventDefault();
          }
        }
      },
      // overridden
      _onContextMenuOpen: function _onContextMenuOpen(e) {// This is Widget's context menu handler which typically retrieves
        // and displays the menu as soon as it receives a "contextmenu" event.
        // We want to allow the cellContextmenu handler to create the menu,
        // so we'll override this method with a null one, and do the menu
        // placement and display handling in our _onContextMenu method.
      },

      /**
       * Event handler. Called when the user double tapped a pointer button over the pane.
       *
       * @param e {Map} the event.
       */
      _onDbltapPane: function _onDbltapPane(e) {
        var pageX = e.getDocumentLeft();
        var pageY = e.getDocumentTop();

        var col = this._getColumnForPageX(pageX);

        if (col !== null) {
          this._focusCellAtPagePos(pageX, pageY);

          this.startEditing();

          var row = this._getRowForPagePos(pageX, pageY);

          if (row != -1 && row != null) {
            this.fireEvent("cellDbltap", qx.ui.table.pane.CellEvent, [this, e, row], true);
          }
        }
      },

      /**
       * Event handler. Called when the pointer moved out.
       *
       * @param e {Map} the event.
       */
      _onPointerout: function _onPointerout(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        } // Reset the resize cursor when the pointer leaves the header
        // If currently a column is resized then do nothing
        // (the cursor will be reset on pointerup)


        if (this.__resizeColumn == null) {
          this.setCursor(null);
          this.getApplicationRoot().setGlobalCursor(null);
        }

        this.__header.setPointerOverColumn(null); // in case the focus follows the pointer, it should be remove on pointerout


        if (this.getFocusCellOnPointerMove()) {
          this.__table.setFocusedCell();
        }
      },

      /**
       * Shows the resize line.
       *
       * @param x {Integer} the position where to show the line (in pixels, relative to
       *      the left side of the pane).
       */
      _showResizeLine: function _showResizeLine(x) {
        var resizeLine = this._showChildControl("resize-line");

        var width = resizeLine.getWidth();

        var paneBounds = this._paneClipper.getBounds();

        resizeLine.setUserBounds(x - Math.round(width / 2), 0, width, paneBounds.height);
      },

      /**
       * Hides the resize line.
       */
      _hideResizeLine: function _hideResizeLine() {
        this._excludeChildControl("resize-line");
      },

      /**
       * Shows the feedback shown while a column is moved by the user.
       *
       * @param pageX {Integer} the x position of the pointer in the page (in pixels).
       * @return {Integer} the visible x position of the column in the whole table.
       */
      showColumnMoveFeedback: function showColumnMoveFeedback(pageX) {
        var paneModel = this.getTablePaneModel();
        var columnModel = this.getTable().getTableColumnModel();

        var paneLeft = this.__tablePane.getContentLocation().left;

        var colCount = paneModel.getColumnCount();
        var targetXPos = 0;
        var targetX = 0;
        var currX = paneLeft;

        for (var xPos = 0; xPos < colCount; xPos++) {
          var col = paneModel.getColumnAtX(xPos);
          var colWidth = columnModel.getColumnWidth(col);

          if (pageX < currX + colWidth / 2) {
            break;
          }

          currX += colWidth;
          targetXPos = xPos + 1;
          targetX = currX - paneLeft;
        } // Ensure targetX is visible


        var scrollerLeft = this._paneClipper.getContentLocation().left;

        var scrollerWidth = this._paneClipper.getBounds().width;

        var scrollX = scrollerLeft - paneLeft; // NOTE: +2/-1 because of feedback width

        targetX = qx.lang.Number.limit(targetX, scrollX + 2, scrollX + scrollerWidth - 1);

        this._showResizeLine(targetX); // Return the overall target x position


        return paneModel.getFirstColumnX() + targetXPos;
      },

      /**
       * Hides the feedback shown while a column is moved by the user.
       */
      hideColumnMoveFeedback: function hideColumnMoveFeedback() {
        this._hideResizeLine();
      },

      /**
       * Sets the focus to the cell that's located at the page position
       * <code>pageX</code>/<code>pageY</code>. If there is no cell at that position,
       * nothing happens.
       *
       * @param pageX {Integer} the x position in the page (in pixels).
       * @param pageY {Integer} the y position in the page (in pixels).
       */
      _focusCellAtPagePos: function _focusCellAtPagePos(pageX, pageY) {
        var row = this._getRowForPagePos(pageX, pageY);

        if (row != -1 && row != null) {
          // The pointer is over the data -> update the focus
          var col = this._getColumnForPageX(pageX);

          this.__table.setFocusedCell(col, row);
        }
      },

      /**
       * Sets the currently focused cell.
       *
       * @param col {Integer} the model index of the focused cell's column.
       * @param row {Integer} the model index of the focused cell's row.
       */
      setFocusedCell: function setFocusedCell(col, row) {
        if (!this.isEditing()) {
          this.__tablePane.setFocusedCell(col, row, this.__updateContentPlanned);

          this.__focusedCol = col;
          this.__focusedRow = row;

          this._updateFocusIndicator();
        }
      },

      /**
       * Returns the column of currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedColumn: function getFocusedColumn() {
        return this.__focusedCol;
      },

      /**
       * Returns the row of currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedRow: function getFocusedRow() {
        return this.__focusedRow;
      },

      /**
       * Scrolls a cell visible.
       *
       * @param col {Integer} the model index of the column the cell belongs to.
       * @param row {Integer} the model index of the row the cell belongs to.
       */
      scrollCellVisible: function scrollCellVisible(col, row) {
        var paneModel = this.getTablePaneModel();
        var xPos = paneModel.getX(col);

        if (xPos != -1) {
          var clipperSize = this._paneClipper.getInnerSize();

          if (!clipperSize) {
            return;
          }

          var columnModel = this.getTable().getTableColumnModel();
          var colLeft = paneModel.getColumnLeft(col);
          var colWidth = columnModel.getColumnWidth(col);
          var rowHeight = this.getTable().getRowHeight();
          var rowTop = row * rowHeight;
          var scrollX = this.getScrollX();
          var scrollY = this.getScrollY(); // NOTE: We don't use qx.lang.Number.limit, because min should win if max < min

          var minScrollX = Math.min(colLeft, colLeft + colWidth - clipperSize.width);
          var maxScrollX = colLeft;
          this.setScrollX(Math.max(minScrollX, Math.min(maxScrollX, scrollX)));
          var minScrollY = rowTop + rowHeight - clipperSize.height;

          if (this.getTable().getKeepFirstVisibleRowComplete()) {
            minScrollY += rowHeight;
          }

          var maxScrollY = rowTop;
          this.setScrollY(Math.max(minScrollY, Math.min(maxScrollY, scrollY)), true);
        }
      },

      /**
       * Returns whether currently a cell is editing.
       *
       * @return {var} whether currently a cell is editing.
       */
      isEditing: function isEditing() {
        return this._cellEditor != null;
      },

      /**
       * Starts editing the currently focused cell. Does nothing if already
       * editing, if the column is not editable, or if the cell editor for the
       * column ascertains that the particular cell is not editable.
       *
       * @return {Boolean} whether editing was started
       */
      startEditing: function startEditing() {
        var table = this.getTable();
        var tableModel = table.getTableModel();
        var col = this.__focusedCol;

        if (!this.isEditing() && col != null && tableModel.isColumnEditable(col)) {
          var row = this.__focusedRow;
          var xPos = this.getTablePaneModel().getX(col);
          var value = tableModel.getValue(col, row); // scroll cell into view

          this.scrollCellVisible(col, row);
          this.__cellEditorFactory = table.getTableColumnModel().getCellEditorFactory(col);
          var cellInfo = {
            col: col,
            row: row,
            xPos: xPos,
            value: value,
            table: table
          }; // Get a cell editor

          this._cellEditor = this.__cellEditorFactory.createCellEditor(cellInfo); // We handle two types of cell editors: the traditional in-place
          // editor, where the cell editor returned by the factory must fit in
          // the space of the table cell; and a modal window in which the
          // editing takes place.  Additionally, if the cell editor determines
          // that it does not want to edit the particular cell being requested,
          // it may return null to indicate that that cell is not editable.

          if (this._cellEditor === null) {
            // This cell is not editable even though its column is.
            return false;
          } else if (this._cellEditor instanceof qx.ui.window.Window) {
            // It's a window.  Ensure that it's modal.
            this._cellEditor.setModal(true); // At least for the time being, we disallow the close button.  It
            // acts differently than a cellEditor.close(), and invokes a bug
            // someplace.  Modal window cell editors should provide their own
            // buttons or means to activate a cellEditor.close() or equivalently
            // cellEditor.hide().


            this._cellEditor.setShowClose(false); // Arrange to be notified when it is closed.


            this._cellEditor.addListener("close", this._onCellEditorModalWindowClose, this); // If there's a pre-open function defined for the table...


            var f = table.getModalCellEditorPreOpenFunction();

            if (f != null) {
              f(this._cellEditor, cellInfo);
            } // Open it now.


            this._cellEditor.open();
          } else {
            // prevent tap event from bubbling up to the table
            this.__focusIndicatorPointerDownListener = this.__focusIndicator.addListener("pointerdown", function (e) {
              this.__lastPointerDownCell = {
                row: this.__focusedRow,
                col: this.__focusedCol
              };
              e.stopPropagation();
            }, this);

            this.__focusIndicator.add(this._cellEditor);

            this.__focusIndicator.addState("editing");

            this.__focusIndicator.setKeepActive(false); // Make the focus indicator visible during editing


            this.__focusIndicator.setDecorator("table-scroller-focus-indicator");

            this._cellEditor.focus();

            this._cellEditor.activate();
          }

          return true;
        }

        return false;
      },

      /**
       * Stops editing and writes the editor's value to the model.
       */
      stopEditing: function stopEditing() {
        // If the focus indicator is not being shown normally...
        if (!this.getShowCellFocusIndicator()) {
          // ... then hide it again
          this.__focusIndicator.setDecorator(null);
        }

        this.flushEditor(true);
      },

      /**
       * Writes the editor's value to the model
       * 
       * @param cancel {Boolean ? false} Whether to also cancel 
       *      editing before firing the 'dateEdited' event.
       */
      flushEditor: function flushEditor(cancel) {
        if (this.isEditing()) {
          var value = this.__cellEditorFactory.getCellEditorValue(this._cellEditor);

          var oldValue = this.getTable().getTableModel().getValue(this.__focusedCol, this.__focusedRow);
          this.getTable().getTableModel().setValue(this.__focusedCol, this.__focusedRow, value);

          this.__table.focus();

          if (cancel) {
            this.cancelEditing();
          } // Fire an event containing the value change.


          this.__table.fireDataEvent("dataEdited", {
            row: this.__focusedRow,
            col: this.__focusedCol,
            oldValue: oldValue,
            value: value
          });
        }
      },

      /**
       * Stops editing without writing the editor's value to the model.
       */
      cancelEditing: function cancelEditing() {
        if (this.isEditing()) {
          if (!(this._cellEditor instanceof qx.ui.window.Window)) {
            this.__focusIndicator.removeState("editing");

            this.__focusIndicator.setKeepActive(true);

            if (this.__focusIndicatorPointerDownListener !== null) {
              this.__focusIndicator.removeListenerById(this.__focusIndicatorPointerDownListener);

              this.__focusIndicatorPointerDownListener = null;
            }
          }

          this._cellEditor.destroy();

          this._cellEditor = null;
          this.__cellEditorFactory = null;
        }
      },

      /**
       * Event handler. Called when the modal window of the cell editor closes.
       *
       * @param e {Map} the event.
       */
      _onCellEditorModalWindowClose: function _onCellEditorModalWindowClose(e) {
        this.stopEditing();
      },

      /**
       * Returns the model index of the column the pointer is over or null if the pointer
       * is not over a column.
       *
       * @param pageX {Integer} the x position of the pointer in the page (in pixels).
       * @return {Integer} the model index of the column the pointer is over.
       */
      _getColumnForPageX: function _getColumnForPageX(pageX) {
        var columnModel = this.getTable().getTableColumnModel();
        var paneModel = this.getTablePaneModel();
        var colCount = paneModel.getColumnCount();

        var currX = this.__tablePane.getContentLocation().left;

        for (var x = 0; x < colCount; x++) {
          var col = paneModel.getColumnAtX(x);
          var colWidth = columnModel.getColumnWidth(col);
          currX += colWidth;

          if (pageX < currX) {
            return col;
          }
        }

        return null;
      },

      /**
       * Returns the model index of the column that should be resized when dragging
       * starts here. Returns -1 if the pointer is in no resize region of any column.
       *
       * @param pageX {Integer} the x position of the pointer in the page (in pixels).
       * @return {Integer} the column index.
       */
      _getResizeColumnForPageX: function _getResizeColumnForPageX(pageX) {
        var contentLocation = this.__header.getContentLocation() || this.__tablePane.getContentLocation();

        if (contentLocation) {
          var currX = contentLocation.left;
          var columnModel = this.getTable().getTableColumnModel();
          var paneModel = this.getTablePaneModel();
          var colCount = paneModel.getColumnCount();
          var regionRadius = qx.ui.table.pane.Scroller.RESIZE_REGION_RADIUS;

          for (var x = 0; x < colCount; x++) {
            var col = paneModel.getColumnAtX(x);
            var colWidth = columnModel.getColumnWidth(col);
            currX += colWidth;

            if (pageX >= currX - regionRadius && pageX <= currX + regionRadius) {
              return col;
            }
          }
        }

        return -1;
      },

      /**
       * Returns the model index of the row the pointer is currently over. Returns -1 if
       * the pointer is over the header. Returns null if the pointer is not over any
       * column.
       *
       * @param pageX {Integer} the pointer x position in the page.
       * @param pageY {Integer} the pointer y position in the page.
       * @return {Integer} the model index of the row the pointer is currently over.
       */
      _getRowForPagePos: function _getRowForPagePos(pageX, pageY) {
        var panePos = this.__tablePane.getContentLocation();

        if (pageX < panePos.left || pageX > panePos.right) {
          // There was no cell or header cell hit
          return null;
        }

        if (pageY >= panePos.top && pageY <= panePos.bottom) {
          // This event is in the pane -> Get the row
          var rowHeight = this.getTable().getRowHeight();

          var scrollY = this.__verScrollBar.getPosition();

          if (this.getTable().getKeepFirstVisibleRowComplete()) {
            scrollY = Math.floor(scrollY / rowHeight) * rowHeight;
          }

          var tableY = scrollY + pageY - panePos.top;
          var row = Math.floor(tableY / rowHeight);
          var tableModel = this.getTable().getTableModel();
          var rowCount = tableModel.getRowCount();
          return row < rowCount ? row : null;
        }

        var headerPos = this.__header.getContentLocation();

        if (pageY >= headerPos.top && pageY <= headerPos.bottom && pageX <= headerPos.right) {
          // This event is in the pane -> Return -1 for the header
          return -1;
        }

        return null;
      },

      /**
       * Sets the widget that should be shown in the top right corner.
       *
       * The widget will not be disposed, when this table scroller is disposed. So the
       * caller has to dispose it.
       *
       * @param widget {qx.ui.core.Widget} The widget to set. May be null.
       */
      setTopRightWidget: function setTopRightWidget(widget) {
        var oldWidget = this.__topRightWidget;

        if (oldWidget != null) {
          this.__top.remove(oldWidget);
        }

        if (widget != null) {
          this.__top.add(widget);
        }

        this.__topRightWidget = widget;
      },

      /**
       * Get the top right widget
       *
       * @return {qx.ui.core.Widget} The top right widget.
       */
      getTopRightWidget: function getTopRightWidget() {
        return this.__topRightWidget;
      },

      /**
       * Returns the header.
       *
       * @return {qx.ui.table.pane.Header} the header.
       */
      getHeader: function getHeader() {
        return this.__header;
      },

      /**
       * Returns the table pane.
       *
       * @return {qx.ui.table.pane.Pane} the table pane.
       */
      getTablePane: function getTablePane() {
        return this.__tablePane;
      },

      /**
       * Get the rendered width of the vertical scroll bar. The return value is
       * <code>0</code> if the scroll bar is invisible or not yet rendered.
       *
       * @internal
       * @return {Integer} The width of the vertical scroll bar
       */
      getVerticalScrollBarWidth: function getVerticalScrollBarWidth() {
        var scrollBar = this.__verScrollBar;
        return scrollBar.isVisible() ? scrollBar.getSizeHint().width || 0 : 0;
      },

      /**
       * Returns which scrollbars are needed.
       *
       * @param forceHorizontal {Boolean ? false} Whether to show the horizontal
       *      scrollbar always.
       * @param preventVertical {Boolean ? false} Whether to show the vertical scrollbar
       *      never.
       * @return {Integer} which scrollbars are needed. This may be any combination of
       *      {@link #HORIZONTAL_SCROLLBAR} or {@link #VERTICAL_SCROLLBAR}
       *      (combined by OR).
       */
      getNeededScrollBars: function getNeededScrollBars(forceHorizontal, preventVertical) {
        var verScrollBar = this.__verScrollBar;
        var verBarWidth = verScrollBar.getSizeHint().width + verScrollBar.getMarginLeft() + verScrollBar.getMarginRight();
        var horScrollBar = this.__horScrollBar;
        var horBarHeight = horScrollBar.getSizeHint().height + horScrollBar.getMarginTop() + horScrollBar.getMarginBottom(); // Get the width and height of the view (without scroll bars)

        var clipperSize = this._paneClipper.getInnerSize();

        var viewWidth = clipperSize ? clipperSize.width : 0;

        if (this.getVerticalScrollBarVisible()) {
          viewWidth += verBarWidth;
        }

        var viewHeight = clipperSize ? clipperSize.height : 0;

        if (this.getHorizontalScrollBarVisible()) {
          viewHeight += horBarHeight;
        }

        var tableModel = this.getTable().getTableModel();
        var rowCount = tableModel.getRowCount(); // Get the (virtual) width and height of the pane

        var paneWidth = this.getTablePaneModel().getTotalWidth();
        var paneHeight = this.getTable().getRowHeight() * rowCount; // Check which scrollbars are needed

        var horNeeded = false;
        var verNeeded = false;

        if (paneWidth > viewWidth) {
          horNeeded = true;

          if (paneHeight > viewHeight - horBarHeight) {
            verNeeded = true;
          }
        } else if (paneHeight > viewHeight) {
          verNeeded = true;

          if (!preventVertical && paneWidth > viewWidth - verBarWidth) {
            horNeeded = true;
          }
        } // Create the mask


        var horBar = qx.ui.table.pane.Scroller.HORIZONTAL_SCROLLBAR;
        var verBar = qx.ui.table.pane.Scroller.VERTICAL_SCROLLBAR;
        return (forceHorizontal || horNeeded ? horBar : 0) | (preventVertical || !verNeeded ? 0 : verBar);
      },

      /**
       * Return the pane clipper. It is sometimes required for special activities
       * such as tracking events for drag&drop.
       *
       * @return {qx.ui.table.pane.Clipper}
       *   The pane clipper for this scroller.
       */
      getPaneClipper: function getPaneClipper() {
        return this._paneClipper;
      },

      /**
       * Returns the scroll area container widget (which enables more precise
       * operations e.g. bounds retrieval for drag session scrolling).
       *
       * @see qx.ui.core.MDragDropScrolling#_getBounds
       * @return {qx.ui.table.pane.Clipper}
       *   The pane clipper for this scroller.
       */
      getScrollAreaContainer: function getScrollAreaContainer() {
        return this.getPaneClipper();
      },
      // property apply method
      _applyScrollTimeout: function _applyScrollTimeout(value, old) {
        this._startInterval(value);
      },

      /**
       * Starts the current running interval
       *
       * @param timeout {Integer} The timeout between two table updates
       */
      _startInterval: function _startInterval(timeout) {
        this.__timer.setInterval(timeout);

        this.__timer.start();
      },

      /**
       * stops the current running interval
       */
      _stopInterval: function _stopInterval() {
        this.__timer.stop();
      },

      /**
       * Does a postponed update of the content.
       *
       * @see #_updateContent
       */
      _postponedUpdateContent: function _postponedUpdateContent() {
        //this.__updateContentPlanned = true;
        this._updateContent();
      },

      /**
       * Timer event handler. Periodically checks whether a table update is
       * required. The update interval is controlled by the {@link #scrollTimeout}
       * property.
       *
       * @signature function()
       */
      _oninterval: qx.event.GlobalError.observeMethod(function () {
        if (this.__updateContentPlanned && !this.__tablePane._layoutPending) {
          this.__updateContentPlanned = false;

          this._updateContent();
        }
      }),

      /**
       * Updates the content. Sets the right section the table pane should show and
       * does the scrolling.
       */
      _updateContent: function _updateContent() {
        var paneSize = this._paneClipper.getInnerSize();

        if (!paneSize) {
          return;
        }

        var paneHeight = paneSize.height;

        var scrollX = this.__horScrollBar.getPosition();

        var scrollY = this.__verScrollBar.getPosition();

        var rowHeight = this.getTable().getRowHeight();
        var firstRow = Math.floor(scrollY / rowHeight);

        var oldFirstRow = this.__tablePane.getFirstVisibleRow();

        this.__tablePane.setFirstVisibleRow(firstRow);

        var visibleRowCount = Math.ceil(paneHeight / rowHeight);
        var paneOffset = 0;
        var firstVisibleRowComplete = this.getTable().getKeepFirstVisibleRowComplete();

        if (!firstVisibleRowComplete) {
          // NOTE: We don't consider paneOffset, because this may cause alternating
          //       adding and deleting of one row when scrolling. Instead we add one row
          //       in every case.
          visibleRowCount++;
          paneOffset = scrollY % rowHeight;
        }

        this.__tablePane.setVisibleRowCount(visibleRowCount);

        if (firstRow != oldFirstRow) {
          this._updateFocusIndicator();
        }

        this._paneClipper.scrollToX(scrollX); // Avoid expensive calls to setScrollTop if
        // scrolling is not needed


        if (!firstVisibleRowComplete) {
          this._paneClipper.scrollToY(paneOffset);
        }
      },

      /**
       * Updates the location and the visibility of the focus indicator.
       *
       */
      _updateFocusIndicator: function _updateFocusIndicator() {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        this.__focusIndicator.moveToCell(this.__focusedCol, this.__focusedRow);
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._stopInterval(); // this object was created by the table on init so we have to clean it up.


      var tablePaneModel = this.getTablePaneModel();

      if (tablePaneModel) {
        tablePaneModel.dispose();
      }

      this.__lastPointerDownCell = this.__topRightWidget = this.__table = null;

      this._disposeObjects("__horScrollBar", "__verScrollBar", "_headerClipper", "_paneClipper", "__focusIndicator", "__header", "__tablePane", "__top", "__timer", "__clipperContainer");
    }
  });
  qx.ui.table.pane.Scroller.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * The model of a table pane. This model works as proxy to a
   * {@link qx.ui.table.columnmodel.Basic} and manages the visual order of the columns shown in
   * a {@link Pane}.
   */
  qx.Class.define("qx.ui.table.pane.Model", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     *
     * @param tableColumnModel {qx.ui.table.columnmodel.Basic} The TableColumnModel of which this
     *    model is the proxy.
     */
    construct: function construct(tableColumnModel) {
      qx.core.Object.constructor.call(this);
      this.setTableColumnModel(tableColumnModel);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the model changed. */
      "modelChanged": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {string} The type of the event fired when the model changed. */
      EVENT_TYPE_MODEL_CHANGED: "modelChanged"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The visible x position of the first column this model should contain. */
      firstColumnX: {
        check: "Integer",
        init: 0,
        apply: "_applyFirstColumnX"
      },

      /**
       * The maximum number of columns this model should contain. If -1 this model will
       * contain all remaining columns.
       */
      maxColumnCount: {
        check: "Number",
        init: -1,
        apply: "_applyMaxColumnCount"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __columnCount: null,
      __tableColumnModel: null,
      // property modifier
      _applyFirstColumnX: function _applyFirstColumnX(value, old) {
        this.__columnCount = null;
        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },
      // property modifier
      _applyMaxColumnCount: function _applyMaxColumnCount(value, old) {
        this.__columnCount = null;
        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },

      /**
       * Connects the table model to the column model
       *
       * @param tableColumnModel {qx.ui.table.columnmodel.Basic} the column model
       */
      setTableColumnModel: function setTableColumnModel(tableColumnModel) {
        if (this.__tableColumnModel) {
          this.__tableColumnModel.removeListener("visibilityChangedPre", this._onColVisibilityChanged, this);

          this.__tableColumnModel.removeListener("headerCellRendererChanged", this._onHeaderCellRendererChanged, this);
        }

        this.__tableColumnModel = tableColumnModel;

        this.__tableColumnModel.addListener("visibilityChangedPre", this._onColVisibilityChanged, this);

        this.__tableColumnModel.addListener("headerCellRendererChanged", this._onHeaderCellRendererChanged, this);

        this.__columnCount = null;
      },

      /**
       * Event handler. Called when the visibility of a column has changed.
       *
       * @param evt {Map} the event.
       */
      _onColVisibilityChanged: function _onColVisibilityChanged(evt) {
        this.__columnCount = null;
        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },

      /**
       * Event handler. Called when the cell renderer of a column has changed.
       *
       * @param evt {Map} the event.
       */
      _onHeaderCellRendererChanged: function _onHeaderCellRendererChanged(evt) {
        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },

      /**
       * Returns the number of columns in this model.
       *
       * @return {Integer} the number of columns in this model.
       */
      getColumnCount: function getColumnCount() {
        if (this.__columnCount == null) {
          var firstX = this.getFirstColumnX();
          var maxColCount = this.getMaxColumnCount();

          var totalColCount = this.__tableColumnModel.getVisibleColumnCount();

          if (maxColCount == -1 || firstX + maxColCount > totalColCount) {
            this.__columnCount = totalColCount - firstX;
          } else {
            this.__columnCount = maxColCount;
          }
        }

        return this.__columnCount;
      },

      /**
       * Returns the model index of the column at the position <code>xPos</code>.
       *
       * @param xPos {Integer} the x position in the table pane of the column.
       * @return {Integer} the model index of the column.
       */
      getColumnAtX: function getColumnAtX(xPos) {
        var firstX = this.getFirstColumnX();
        return this.__tableColumnModel.getVisibleColumnAtX(firstX + xPos);
      },

      /**
       * Returns the x position of the column <code>col</code>.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the x position in the table pane of the column.
       */
      getX: function getX(col) {
        var firstX = this.getFirstColumnX();
        var maxColCount = this.getMaxColumnCount();
        var x = this.__tableColumnModel.getVisibleX(col) - firstX;

        if (x >= 0 && (maxColCount == -1 || x < maxColCount)) {
          return x;
        } else {
          return -1;
        }
      },

      /**
       * Gets the position of the left side of a column (in pixels, relative to the
       * left side of the table pane).
       *
       * This value corresponds to the sum of the widths of all columns left of the
       * column.
       *
       * @param col {Integer} the model index of the column.
       * @return {var} the position of the left side of the column.
       */
      getColumnLeft: function getColumnLeft(col) {
        var left = 0;
        var colCount = this.getColumnCount();

        for (var x = 0; x < colCount; x++) {
          var currCol = this.getColumnAtX(x);

          if (currCol == col) {
            return left;
          }

          left += this.__tableColumnModel.getColumnWidth(currCol);
        }

        return -1;
      },

      /**
       * Returns the total width of all columns in the model.
       *
       * @return {Integer} the total width of all columns in the model.
       */
      getTotalWidth: function getTotalWidth() {
        var totalWidth = 0;
        var colCount = this.getColumnCount();

        for (var x = 0; x < colCount; x++) {
          var col = this.getColumnAtX(x);
          totalWidth += this.__tableColumnModel.getColumnWidth(col);
        }

        return totalWidth;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this.__tableColumnModel) {
        this.__tableColumnModel.removeListener("visibilityChangedPre", this._onColVisibilityChanged, this);

        this.__tableColumnModel.removeListener("headerCellRendererChanged", this._onHeaderCellRendererChanged, this);
      }

      this.__tableColumnModel = null;
    }
  });
  qx.ui.table.pane.Model.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Grow": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The focus indicator widget
   */
  qx.Class.define("qx.ui.table.pane.FocusIndicator", {
    extend: qx.ui.container.Composite,

    /**
     * @param scroller {qx.ui.table.pane.Scroller} The scroller, which contains this focus indicator
     */
    construct: function construct(scroller) {
      // use the grow layout to make sure that the editing control
      // always fills the focus indicator box.
      qx.ui.container.Composite.constructor.call(this, new qx.ui.layout.Grow());
      this.__scroller = scroller;
      this.setKeepActive(true);
      this.addListener("keypress", this._onKeyPress, this);
    },
    properties: {
      // overridden
      visibility: {
        refine: true,
        init: "excluded"
      },

      /** Table row, where the indicator is placed. */
      row: {
        check: "Integer",
        nullable: true
      },

      /** Table column, where the indicator is placed. */
      column: {
        check: "Integer",
        nullable: true
      }
    },
    members: {
      __scroller: null,

      /**
       * Keypress handler. Suppress all key events but "Enter" and "Escape"
       *
       * @param e {qx.event.type.KeySequence} key event
       */
      _onKeyPress: function _onKeyPress(e) {
        var iden = e.getKeyIdentifier();

        if (iden !== "Escape" && iden !== "Enter") {
          e.stopPropagation();
        }
      },

      /**
       * Move the focus indicator to the given table cell.
       *
       * @param col {Integer?null} The table column
       * @param row {Integer?null} The table row
       */
      moveToCell: function moveToCell(col, row) {
        // check if the focus indicator is shown and if the new column is
        // editable. if not, just exclude the indicator because the pointer events
        // should go to the cell itself linked with HTML links [BUG #4250]
        if (!this.__scroller.getShowCellFocusIndicator() && !this.__scroller.getTable().getTableModel().isColumnEditable(col)) {
          this.exclude();
          return;
        } else {
          this.show();
        }

        if (col == null) {
          this.hide();
          this.setRow(null);
          this.setColumn(null);
        } else {
          var xPos = this.__scroller.getTablePaneModel().getX(col);

          if (xPos == -1) {
            this.hide();
            this.setRow(null);
            this.setColumn(null);
          } else {
            var table = this.__scroller.getTable();

            var columnModel = table.getTableColumnModel();

            var paneModel = this.__scroller.getTablePaneModel();

            var firstRow = this.__scroller.getTablePane().getFirstVisibleRow();

            var rowHeight = table.getRowHeight();
            this.setUserBounds(paneModel.getColumnLeft(col) - 2, (row - firstRow) * rowHeight - 2, columnModel.getColumnWidth(col) + 3, rowHeight + 3);
            this.show();
            this.setRow(row);
            this.setColumn(col);
          }
        }
      }
    },
    destruct: function destruct() {
      this.__scroller = null;
    }
  });
  qx.ui.table.pane.FocusIndicator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Interface for a column menu item corresponding to a table column.
   */
  qx.Interface.define("qx.ui.table.IColumnMenuItem", {
    properties: {
      /**
       * Whether the table column associated with this menu item is visible
       * Should be of type {Boolean}!
       */
      columnVisible: {}
    },
    events: {
      /**
       * Dispatched when a column changes visibility state. The event data is a
       * boolean indicating whether the table column associated with this menu
       * item is now visible.
       */
      changeColumnVisible: "qx.event.type.Data"
    }
  });
  qx.ui.table.IColumnMenuItem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menu.CheckBox": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.IColumnMenuItem": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A menu item.
   */
  qx.Class.define("qx.ui.table.columnmenu.MenuItem", {
    extend: qx.ui.menu.CheckBox,
    implement: qx.ui.table.IColumnMenuItem,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Create a new instance of an item for insertion into the table column
     * visibility menu.
     *
     * @param text {String}
     *   Text for the menu item, most typically the name of the column in the
     *   table.
     */
    construct: function construct(text) {
      qx.ui.menu.CheckBox.constructor.call(this, text); // Two way binding this.columnVisible <--> this.value

      this.bind("value", this, "columnVisible");
      this.bind("columnVisible", this, "value");
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      columnVisible: {
        check: "Boolean",
        init: true,
        event: "changeColumnVisible"
      }
    }
  });
  qx.ui.table.columnmenu.MenuItem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.basic.Label": {},
      "qx.ui.basic.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The default header cell widget
   *
   * @childControl label {qx.ui.basic.Label} label of the header cell
   * @childControl sort-icon {qx.ui.basic.Image} sort icon of the header cell
   * @childControl icon {qx.ui.basic.Image} icon of the header cell
   */
  qx.Class.define("qx.ui.table.headerrenderer.HeaderCell", {
    extend: qx.ui.container.Composite,
    construct: function construct() {
      qx.ui.container.Composite.constructor.call(this);
      var layout = new qx.ui.layout.Grid();
      layout.setRowFlex(0, 1);
      layout.setColumnFlex(1, 1);
      layout.setColumnFlex(2, 1);
      this.setLayout(layout);
    },
    properties: {
      appearance: {
        refine: true,
        init: "table-header-cell"
      },

      /** header cell label */
      label: {
        check: "String",
        init: null,
        nullable: true,
        apply: "_applyLabel"
      },

      /** The icon URL of the sorting indicator */
      sortIcon: {
        check: "String",
        init: null,
        nullable: true,
        apply: "_applySortIcon",
        themeable: true
      },

      /** Icon URL */
      icon: {
        check: "String",
        init: null,
        nullable: true,
        apply: "_applyIcon"
      }
    },
    members: {
      // property apply
      _applyLabel: function _applyLabel(value, old) {
        if (value) {
          this._showChildControl("label").setValue(value);
        } else {
          this._excludeChildControl("label");
        }
      },
      // property apply
      _applySortIcon: function _applySortIcon(value, old) {
        if (value) {
          this._showChildControl("sort-icon").setSource(value);
        } else {
          this._excludeChildControl("sort-icon");
        }
      },
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        if (value) {
          this._showChildControl("icon").setSource(value);
        } else {
          this._excludeChildControl("icon");
        }
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "label":
            control = new qx.ui.basic.Label(this.getLabel()).set({
              anonymous: true,
              allowShrinkX: true
            });

            this._add(control, {
              row: 0,
              column: 1
            });

            break;

          case "sort-icon":
            control = new qx.ui.basic.Image(this.getSortIcon());
            control.setAnonymous(true);

            this._add(control, {
              row: 0,
              column: 2
            });

            break;

          case "icon":
            control = new qx.ui.basic.Image(this.getIcon()).set({
              anonymous: true,
              allowShrinkX: true
            });

            this._add(control, {
              row: 0,
              column: 0
            });

            break;
        }

        return control || qx.ui.table.headerrenderer.HeaderCell.prototype._createChildControlImpl.base.call(this, id);
      }
    }
  });
  qx.ui.table.headerrenderer.HeaderCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Grow": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Clipping area for the table header and table pane.
   */
  qx.Class.define("qx.ui.table.pane.Clipper", {
    extend: qx.ui.container.Composite,
    construct: function construct() {
      qx.ui.container.Composite.constructor.call(this, new qx.ui.layout.Grow());
      this.setMinWidth(0);
    },
    members: {
      /**
       * Scrolls the element's content to the given left coordinate
       *
       * @param value {Integer} The vertical position to scroll to.
       */
      scrollToX: function scrollToX(value) {
        this.getContentElement().scrollToX(value, false);
      },

      /**
       * Scrolls the element's content to the given top coordinate
       *
       * @param value {Integer} The horizontal position to scroll to.
       */
      scrollToY: function scrollToY(value) {
        this.getContentElement().scrollToY(value, true);
      }
    }
  });
  qx.ui.table.pane.Clipper.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.type.Pointer": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * David Perez Carmona (david-perez)
  
  ************************************************************************ */

  /**
   * A cell event instance contains all data for pointer events related to cells in
   * a table.
   **/
  qx.Class.define("qx.ui.table.pane.CellEvent", {
    extend: qx.event.type.Pointer,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The table row of the event target */
      row: {
        check: "Integer",
        nullable: true
      },

      /** The table column of the event target */
      column: {
        check: "Integer",
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
       *****************************************************************************
          CONSTRUCTOR
       *****************************************************************************
       */

      /**
       * Initialize the event
       *
       * @param scroller {qx.ui.table.pane.Scroller} The tables pane scroller
       * @param me {qx.event.type.Pointer} The original pointer event
       * @param row {Integer?null} The cell's row index
       * @param column {Integer?null} The cell's column index
       */
      init: function init(scroller, me, row, column) {
        me.clone(this);
        this.setBubbles(false);

        if (row != null) {
          this.setRow(row);
        } else {
          this.setRow(scroller._getRowForPagePos(this.getDocumentLeft(), this.getDocumentTop()));
        }

        if (column != null) {
          this.setColumn(column);
        } else {
          this.setColumn(scroller._getColumnForPageX(this.getDocumentLeft()));
        }
      },
      // overridden
      clone: function clone(embryo) {
        var clone = qx.ui.table.pane.CellEvent.prototype.clone.base.call(this, embryo);
        clone.set({
          row: this.getRow(),
          column: this.getColumn()
        });
        return clone;
      }
    }
  });
  qx.ui.table.pane.CellEvent.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.table.model.Simple": {},
      "qx.ui.table.Table": {},
      "qx.event.type.Mouse": {},
      "qx.ui.table.pane.CellEvent": {},
      "qx.ui.core.queue.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.table.Table", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      createModel: function createModel() {
        var tableModel = new qx.ui.table.model.Simple();
        tableModel.setColumns(["ID", "A number", "String", "A date", "Boolean"]);
        tableModel.setData(this.createRandomRows(5));
        return tableModel;
      },
      createRandomRows: function createRandomRows(rowCount) {
        var rowData = [];
        var nextId = 0;
        var strings = ["a", "b", "c", "d"];

        for (var row = 0; row < rowCount; row++) {
          var date = new Date(row * row * row);
          var number = row % 2 == 0 ? row / 2 : NaN;
          rowData.push([nextId++, number, strings[row % 4], date, row % 2 == 1]);
        }

        return rowData;
      },
      testSortInteger: function testSortInteger() {
        // table
        var model = this.createModel();
        var table = new qx.ui.table.Table(model); // sort descending

        model.sortByColumn(0);
        var data = model.getData();

        for (var i = 0; i < data.length - 1; i++) {
          this.assertTrue(data[i][0] >= data[i + 1][0]);
        }

        ; // sort ascending

        model.sortByColumn(0, true);

        for (var i = 0; i < data.length - 1; i++) {
          this.assertTrue(data[i][0] <= data[i + 1][0]);
        }

        ;
        table.destroy();
        model.dispose();
      },
      testSortIntegerNaN: function testSortIntegerNaN() {
        // table
        var model = this.createModel();
        var table = new qx.ui.table.Table(model); // sort descending

        model.sortByColumn(1);
        var data = model.getData();

        for (var i = 0; i < data.length - 1; i++) {
          if (isNaN(data[i][1])) {
            // both should be NaN
            this.assertTrue(isNaN(data[i + 1][1]));
          } else if (isNaN(data[i + 1][1])) {
            // should be a number
            this.assertFalse(isNaN(data[i][1]));
          } else {
            this.assertTrue(data[i][1] >= data[i + 1][1]);
          }
        }

        ; // sort ascending

        model.sortByColumn(1, true);
        var data = model.getData();

        for (var i = 0; i < data.length - 1; i++) {
          if (isNaN(data[i][1])) {
            // both should be NaN
            this.assertTrue(isNaN(data[i + 1][1]));
          } else if (isNaN(data[i + 1][1])) {
            // should be a number
            this.assertFalse(isNaN(data[i][1]));
          } else {
            this.assertTrue(data[i][1] <= data[i + 1][1]);
          }
        }

        ;
        table.destroy();
        model.dispose();
      },
      testSortIntegerNaNInsensitive: function testSortIntegerNaNInsensitive() {
        // table
        var model = this.createModel();
        var table = new qx.ui.table.Table(model);
        model.setCaseSensitiveSorting(false); // sort descending

        model.sortByColumn(1);
        var data = model.getData();

        for (var i = 0; i < data.length - 1; i++) {
          if (isNaN(data[i][1])) {
            // both should be NaN
            this.assertTrue(isNaN(data[i + 1][1]));
          } else if (isNaN(data[i + 1][1])) {
            // should be a number
            this.assertFalse(isNaN(data[i][1]));
          } else {
            this.assertTrue(data[i][1] >= data[i + 1][1]);
          }
        }

        ; // sort ascending

        model.sortByColumn(1, true);
        var data = model.getData();

        for (var i = 0; i < data.length - 1; i++) {
          if (isNaN(data[i][1])) {
            // both should be NaN
            this.assertTrue(isNaN(data[i + 1][1]));
          } else if (isNaN(data[i + 1][1])) {
            // should be a number
            this.assertFalse(isNaN(data[i][1]));
          } else {
            this.assertTrue(data[i][1] <= data[i + 1][1]);
          }
        }

        ;
        table.destroy();
        model.dispose();
      },
      testSortStringInsensitive: function testSortStringInsensitive() {
        // table
        var model = this.createModel();
        var table = new qx.ui.table.Table(model);
        model.setCaseSensitiveSorting(false); // sort descending

        model.sortByColumn(2);
        var data = model.getData();

        for (var i = 0; i < data.length - 1; i++) {
          this.assertTrue(data[i][2] >= data[i + 1][2]);
        }

        ; // sort ascending

        model.sortByColumn(2, true);

        for (var i = 0; i < data.length - 1; i++) {
          this.assertTrue(data[i][2] <= data[i + 1][2]);
        }

        ;
        table.destroy();
        model.dispose();
      },
      testSortString: function testSortString() {
        // table
        var model = this.createModel();
        var table = new qx.ui.table.Table(model); // sort descending

        model.sortByColumn(2);
        var data = model.getData();

        for (var i = 0; i < data.length - 1; i++) {
          this.assertTrue(data[i][2] >= data[i + 1][2]);
        }

        ; // sort ascending

        model.sortByColumn(2, true);

        for (var i = 0; i < data.length - 1; i++) {
          this.assertTrue(data[i][2] <= data[i + 1][2]);
        }

        ;
        table.destroy();
        model.dispose();
      },
      testRegularListener: function testRegularListener() {
        var table = new qx.ui.table.Table();
        var executed = false;
        var id = table.addListener("changeRowHeight", function () {
          executed = true;
        }, this);
        this.assertNotNull(id);
        table.removeListenerById(id); // invoke event

        table.setRowHeight(111);
        this.assertFalse(executed);
        table.destroy();
      },
      testSpecialListener: function testSpecialListener() {
        var table = new qx.ui.table.Table(); // use a meta column to see if both events are handled properly

        table.setMetaColumnCounts([1, -1]);
        var executed = false;
        var id = table.addListener("cellClick", function () {
          executed = true;
        }, this);
        this.assertNotNull(id);
        table.removeListenerById(id); // invoke synthetic cellClick event

        var scroller = table._getPaneScrollerArr()[0];

        var mouse = new qx.event.type.Mouse();
        mouse.init({}, scroller, scroller, false, true);
        scroller.fireEvent("cellClick", qx.ui.table.pane.CellEvent, [scroller, mouse, 0, 0], true);
        this.assertFalse(executed, "Listener not removed");
        mouse.dispose();
        table.destroy();
      },
      testScrollAfterScrollbarVisibilityChange: function testScrollAfterScrollbarVisibilityChange() {
        var rowData = [];

        for (var row = 0; row < 15; row++) {
          rowData.push([row]);
        }

        var tableModel = new qx.ui.table.model.Simple();
        tableModel.setColumns(["ID"]);
        tableModel.setData(rowData);
        var table = new qx.ui.table.Table(tableModel).set({
          width: 200,
          height: 200
        });
        this.getRoot().add(table);
        qx.ui.core.queue.Manager.flush(); // scroll to the end

        table.getPaneScroller(0).setScrollY(100); // resize the first column to show a vertical scrollbar

        table.getTableColumnModel().setColumnWidth(0, 300); // resize back

        table.getTableColumnModel().setColumnWidth(0, 100); // check that the table is not scrolled back to the top

        this.assertEquals(100, table.getPaneScroller(0).getScrollY());
        table.destroy();
        tableModel.dispose();
      },
      testFocusAfterRemove: function testFocusAfterRemove() {
        var tableModelSimple = new qx.ui.table.model.Simple();
        tableModelSimple.setColumns(["Location", "Team"]);
        var tableSimple = new qx.ui.table.Table(tableModelSimple);
        var data = [[1, 'team1'], [2, 'team2'], [3, 'team3']];
        tableModelSimple.setData(data); // select and focus row 2

        tableSimple.getSelectionModel().addSelectionInterval(1, 1);
        tableSimple.setFocusedCell(1, 1); // remove this row

        tableModelSimple.removeRows(1, 1); // check if the selection and the focus is gone

        this.assertEquals(null, tableSimple.getFocusedRow()); // don't use assertNull because it can be undefined

        this.assertEquals(0, tableSimple.getSelectionModel().getSelectedCount());
        tableSimple.destroy();
        tableModelSimple.dispose();
      }
    }
  });
  qx.test.ui.table.Table.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.table.celleditor.AbstractField", {
    extend: qx.test.ui.LayoutTestCase,
    type: "abstract",
    members: {
      setUp: function setUp() {
        throw new Error("Abstract method call!");
      },
      tearDown: function tearDown() {
        this.flush();
      },
      _getCellInfo: function _getCellInfo(value) {
        return {
          value: value
        };
      },
      testCreateCellEditor: function testCreateCellEditor() {
        var editor = this.factory.createCellEditor(this._getCellInfo());
        this.assertInstance(editor, qx.ui.core.Widget);
        this.assertEquals("", editor.getValue());
        editor.destroy();
      },
      testCreateCellEditorWithValue: function testCreateCellEditorWithValue() {
        var editor = this.factory.createCellEditor(this._getCellInfo("juhu"));
        this.assertEquals("juhu", editor.getValue());
        editor.destroy();
      },
      testGetCellEditorValue: function testGetCellEditorValue() {
        var editor = this.factory.createCellEditor(this._getCellInfo());
        editor.setValue("Kinners");
        this.assertEquals("Kinners", this.factory.getCellEditorValue(editor));
        editor.destroy();
      },
      testValidationFunction: function testValidationFunction() {
        var called = false;
        this.factory.setValidationFunction(function (value) {
          called = true;
          return "_" + value + "_";
        });
        var editor = this.factory.createCellEditor(this._getCellInfo());
        editor.setValue("juhu");
        var value = this.factory.getCellEditorValue(editor);
        this.assert(called);
        this.assertEquals("_juhu_", value);
        editor.setValue("kinners");
        var value = this.factory.getCellEditorValue(editor);
        this.assert(called);
        this.assertEquals("_kinners_", value);
      },
      testAutoconvertToNumber: function testAutoconvertToNumber() {
        var editor = this.factory.createCellEditor(this._getCellInfo(10.0));
        editor.setValue("-12.5");
        this.assertEquals(-12.5, this.factory.getCellEditorValue(editor));
        this.assertNumber(this.factory.getCellEditorValue(editor));
        editor.destroy();
      }
    }
  });
  qx.test.ui.table.celleditor.AbstractField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.table.celleditor.AbstractField": {
        "require": true
      },
      "qx.ui.table.celleditor.ComboBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.table.celleditor.ComboBox", {
    extend: qx.test.ui.table.celleditor.AbstractField,
    members: {
      setUp: function setUp() {
        this.factory = new qx.ui.table.celleditor.ComboBox();
      },
      tearDown: function tearDown() {
        qx.test.ui.table.celleditor.ComboBox.prototype.tearDown.base.call(this);
        this.factory.dispose();
      },
      _getCellInfo: function _getCellInfo(value) {
        return {
          value: value,
          col: 0,
          table: {
            getTableColumnModel: function getTableColumnModel() {
              return {
                getDataCellRenderer: function getDataCellRenderer(col) {
                  return {
                    _getContentHtml: function _getContentHtml(cellInfo) {
                      return cellInfo.value;
                    }
                  };
                }
              };
            }
          }
        };
      },
      testChangeEditorSelection: function testChangeEditorSelection() {
        this.factory.setListData(["elefant", "affe", "banane"]);
        var editor = this.factory.createCellEditor(this._getCellInfo("affe"));
        var list = editor.getChildControl("list");
        this.assertEquals("affe", list.getSelection()[0].getLabel());
        list.setSelection([list.getChildren()[2]]);
        this.assertEquals("banane", this.factory.getCellEditorValue(editor));
        editor.destroy();
      }
    }
  });
  qx.test.ui.table.celleditor.ComboBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.table.ICellEditorFactory": {
        "require": true
      },
      "qx.ui.form.ComboBox": {},
      "qx.ui.form.ListItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */

  /**
   * A cell editor factory creating combo boxes.
   */
  qx.Class.define("qx.ui.table.celleditor.ComboBox", {
    extend: qx.core.Object,
    implement: qx.ui.table.ICellEditorFactory,
    properties: {
      /**
       * function that validates the result
       * the function will be called with the new value and the old value and is
       * supposed to return the value that is set as the table value.
       **/
      validationFunction: {
        check: "Function",
        nullable: true,
        init: null
      },

      /** array of data to construct ListItem widgets with */
      listData: {
        check: "Array",
        init: null,
        nullable: true
      }
    },
    members: {
      // interface implementation
      createCellEditor: function createCellEditor(cellInfo) {
        var cellEditor = new qx.ui.form.ComboBox().set({
          appearance: "table-editor-combobox"
        });
        var value = cellInfo.value;
        cellEditor.originalValue = value; // check if renderer does something with value

        var cellRenderer = cellInfo.table.getTableColumnModel().getDataCellRenderer(cellInfo.col);

        var label = cellRenderer._getContentHtml(cellInfo);

        if (value != label) {
          value = label;
        } // replace null values


        if (value === null || value === undefined) {
          value = "";
        }

        var list = this.getListData();

        if (list) {
          var item;

          for (var i = 0, l = list.length; i < l; i++) {
            var row = list[i];

            if (row instanceof Array) {
              item = new qx.ui.form.ListItem(row[0], row[1]);
            } else {
              item = new qx.ui.form.ListItem(row, null);
            }

            cellEditor.add(item);
          }

          ;
        }

        cellEditor.setValue("" + value);
        cellEditor.addListener("appear", function () {
          cellEditor.selectAllText();
        });
        return cellEditor;
      },
      // interface implementations
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        var value = cellEditor.getValue() || ""; // validation function will be called with new and old value

        var validationFunc = this.getValidationFunction();

        if (validationFunc) {
          value = validationFunc(value, cellEditor.originalValue);
        }

        if (typeof cellEditor.originalValue == "number") {
          value = parseFloat(value);
        }

        return value;
      }
    }
  });
  qx.ui.table.celleditor.ComboBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.table.celleditor.AbstractField": {
        "require": true
      },
      "qx.ui.table.celleditor.PasswordField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.table.celleditor.PasswordField", {
    extend: qx.test.ui.table.celleditor.AbstractField,
    members: {
      setUp: function setUp() {
        this.factory = new qx.ui.table.celleditor.PasswordField();
      },
      tearDown: function tearDown() {
        qx.test.ui.table.celleditor.PasswordField.prototype.tearDown.base.call(this);
        this.factory.dispose();
      }
    }
  });
  qx.test.ui.table.celleditor.PasswordField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.celleditor.AbstractField": {
        "require": true
      },
      "qx.ui.form.PasswordField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A cell editor factory creating password fields fields.
   */
  qx.Class.define("qx.ui.table.celleditor.PasswordField", {
    extend: qx.ui.table.celleditor.AbstractField,
    members: {
      _createEditor: function _createEditor() {
        var cellEditor = new qx.ui.form.PasswordField();
        cellEditor.setAppearance("table-editor-textfield");
        return cellEditor;
      }
    }
  });
  qx.ui.table.celleditor.PasswordField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.table.celleditor.SelectBox": {},
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.table.celleditor.SelectBox", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.factory = new qx.ui.table.celleditor.SelectBox();
      },
      tearDown: function tearDown() {
        qx.test.ui.table.celleditor.SelectBox.prototype.tearDown.base.call(this);
        this.factory.dispose();
      },
      _getCellInfo: function _getCellInfo(value) {
        return {
          value: value,
          col: 0,
          table: {
            getTableColumnModel: function getTableColumnModel() {
              return {
                getDataCellRenderer: function getDataCellRenderer(col) {
                  return {
                    _getContentHtml: function _getContentHtml(cellInfo) {
                      return cellInfo.value;
                    }
                  };
                }
              };
            }
          }
        };
      },
      testCreateCellEditor: function testCreateCellEditor() {
        var editor = this.factory.createCellEditor(this._getCellInfo());
        this.assertInstance(editor, qx.ui.core.Widget);
        this.assertEquals(0, editor.getSelection().length);
        editor.destroy();
      },
      testCreateCellEditorWithValue: function testCreateCellEditorWithValue() {
        this.factory.setListData(["juhu", "kinners"]);
        var editor = this.factory.createCellEditor(this._getCellInfo("juhu"));
        this.assertEquals("juhu", editor.getSelection()[0].getLabel());
        editor.destroy();
      },
      testGetCellEditorValue: function testGetCellEditorValue() {
        this.factory.setListData(["juhu", "kinners"]);
        var editor = this.factory.createCellEditor(this._getCellInfo());
        editor.setSelection([editor.getChildren()[1]]);
        this.assertEquals("kinners", this.factory.getCellEditorValue(editor));
        editor.destroy();
      },
      testValidationFunction: function testValidationFunction() {
        this.factory.setListData(["juhu", "kinners"]);
        var called = false;
        this.factory.setValidationFunction(function (value) {
          called = true;
          return "_" + value + "_";
        });
        var editor = this.factory.createCellEditor(this._getCellInfo());
        editor.setSelection([editor.getChildren()[0]]);
        var value = this.factory.getCellEditorValue(editor);
        this.assert(called);
        this.assertEquals("_juhu_", value);
        editor.setSelection([editor.getChildren()[1]]);
        var value = this.factory.getCellEditorValue(editor);
        this.assert(called);
        this.assertEquals("_kinners_", value);
      },
      testAutoconvertToNumber: function testAutoconvertToNumber() {
        this.factory.setListData(["10.0", "-12.5"]);
        var editor = this.factory.createCellEditor(this._getCellInfo(10.0));
        editor.setSelection([editor.getChildren()[1]]);
        this.assertEquals(-12.5, this.factory.getCellEditorValue(editor));
        this.assertNumber(this.factory.getCellEditorValue(editor));
        editor.destroy();
      }
    }
  });
  qx.test.ui.table.celleditor.SelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.table.ICellEditorFactory": {
        "require": true
      },
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.ListItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A cell editor factory creating select boxes.
   */
  qx.Class.define("qx.ui.table.celleditor.SelectBox", {
    extend: qx.core.Object,
    implement: qx.ui.table.ICellEditorFactory,
    properties: {
      /**
       * function that validates the result
       * the function will be called with the new value and the old value and is
       * supposed to return the value that is set as the table value.
       **/
      validationFunction: {
        check: "Function",
        nullable: true,
        init: null
      },

      /** array of data to construct ListItem widgets with */
      listData: {
        check: "Array",
        init: null,
        nullable: true
      }
    },
    members: {
      // interface implementation
      createCellEditor: function createCellEditor(cellInfo) {
        var cellEditor = new qx.ui.form.SelectBox().set({
          appearance: "table-editor-selectbox"
        });
        var value = cellInfo.value;
        cellEditor.originalValue = value; // check if renderer does something with value

        var cellRenderer = cellInfo.table.getTableColumnModel().getDataCellRenderer(cellInfo.col);

        var label = cellRenderer._getContentHtml(cellInfo);

        if (value != label) {
          value = label;
        } // replace null values


        if (value === null) {
          value = "";
        }

        var list = this.getListData();

        if (list) {
          var item;

          for (var i = 0, l = list.length; i < l; i++) {
            var row = list[i];

            if (row instanceof Array) {
              item = new qx.ui.form.ListItem(row[0], row[1]);
              item.setUserData("row", row[2]);

              if (value == row[2]) {
                label = row[0];
              }
            } else {
              item = new qx.ui.form.ListItem(row, null);
              item.setUserData("row", row);
            }

            cellEditor.add(item);
          }

          ;
        }

        if (label != null) {
          var itemToSelect = cellEditor.getChildrenContainer().findItem(label + "");
        }

        if (itemToSelect) {
          cellEditor.setSelection([itemToSelect]);
        } else {
          cellEditor.resetSelection();
        }

        cellEditor.addListener("appear", function () {
          cellEditor.open();
        });
        return cellEditor;
      },
      // interface implementation
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        var selection = cellEditor.getSelection();
        var value = "";

        if (selection && selection[0]) {
          var userValue = selection[0].getUserData("row");
          value = userValue === undefined ? selection[0].getLabel() : userValue;
        } // validation function will be called with new and old value


        var validationFunc = this.getValidationFunction();

        if (validationFunc) {
          value = validationFunc(value, cellEditor.originalValue);
        }

        if (typeof cellEditor.originalValue == "number") {
          value = parseFloat(value);
        }

        return value;
      }
    }
  });
  qx.ui.table.celleditor.SelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.table.celleditor.AbstractField": {
        "require": true
      },
      "qx.ui.table.celleditor.TextField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.table.celleditor.TextField", {
    extend: qx.test.ui.table.celleditor.AbstractField,
    members: {
      setUp: function setUp() {
        this.factory = new qx.ui.table.celleditor.TextField();
      },
      tearDown: function tearDown() {
        qx.test.ui.table.celleditor.TextField.prototype.tearDown.base.call(this);
        this.factory.dispose();
      }
    }
  });
  qx.test.ui.table.celleditor.TextField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.table.model.Simple": {},
      "qx.ui.table.Table": {},
      "qx.core.AssertionError": {},
      "qx.ui.table.headerrenderer.Default": {},
      "qx.ui.table.cellrenderer.Default": {},
      "qx.ui.table.celleditor.SelectBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.table.columnmodel.Basic", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      createModel: function createModel() {
        var tableModel = new qx.ui.table.model.Simple();
        tableModel.setColumns(["ID", "A number", "String", "A date", "Boolean"]);
        tableModel.setData(this.createRandomRows(5));
        return tableModel;
      },
      createRandomRows: function createRandomRows(rowCount) {
        var rowData = [];
        var nextId = 0;
        var strings = ["a", "b", "c", "d"];

        for (var row = 0; row < rowCount; row++) {
          var date = new Date(row * row * row);
          var number = row % 2 == 0 ? row / 2 : NaN;
          rowData.push([nextId++, number, strings[row % 4], date, row % 2 == 1]);
        }

        return rowData;
      },
      testSetColumnWidth: function testSetColumnWidth() {
        var model = this.createModel();
        var table = new qx.ui.table.Table(model);
        var tcm = table.getTableColumnModel();
        {
          this.assertException(function () {
            tcm.setColumnWidth(6, 10);
          }, qx.core.AssertionError, "Column not found in table model", "Invalid column width.");
        }
        table.destroy();
        model.dispose();
      },
      testGetColumnWidth: function testGetColumnWidth() {
        var model = this.createModel();
        var table = new qx.ui.table.Table(model);
        var tcm = table.getTableColumnModel();
        {
          this.assertException(function () {
            tcm.getColumnWidth(6, 10);
          }, qx.core.AssertionError, "Column not found in table model", "Invalid column width.");
        }
        table.destroy();
        model.dispose();
      },
      testSetHeaderCellRenderer: function testSetHeaderCellRenderer() {
        var model = this.createModel();
        var table = new qx.ui.table.Table(model);
        var tcm = table.getTableColumnModel();
        {
          this.assertException(function () {
            tcm.setHeaderCellRenderer(6, new qx.ui.table.headerrenderer.Default());
          }, qx.core.AssertionError, "Column not found in table model", "Invalid column width.");
        }
        table.destroy();
        model.dispose();
      },
      testGetHeaderCellRenderer: function testGetHeaderCellRenderer() {
        var model = this.createModel();
        var table = new qx.ui.table.Table(model);
        var tcm = table.getTableColumnModel();
        {
          this.assertException(function () {
            tcm.getHeaderCellRenderer(6);
          }, qx.core.AssertionError, "Column not found in table model", "Invalid column width.");
        }
        table.destroy();
        model.dispose();
      },
      testSetDataCellRenderer: function testSetDataCellRenderer() {
        var model = this.createModel();
        var table = new qx.ui.table.Table(model);
        var tcm = table.getTableColumnModel();
        {
          this.assertException(function () {
            tcm.setDataCellRenderer(6, qx.ui.table.cellrenderer.Default);
          }, qx.core.AssertionError, "Column not found in table model", "Invalid column width.");
        }
        table.destroy();
        model.dispose();
      },
      testGetDataCellRenderer: function testGetDataCellRenderer() {
        var model = this.createModel();
        var table = new qx.ui.table.Table(model);
        var tcm = table.getTableColumnModel();
        {
          this.assertException(function () {
            tcm.getDataCellRenderer(6);
          }, qx.core.AssertionError, "Column not found in table model", "Invalid column width.");
        }
        table.destroy();
        model.dispose();
      },
      testSetCellEditorFactory: function testSetCellEditorFactory() {
        var model = this.createModel();
        var table = new qx.ui.table.Table(model);
        var tcm = table.getTableColumnModel();
        {
          this.assertException(function () {
            tcm.setCellEditorFactory(6, qx.ui.table.celleditor.SelectBox);
          }, qx.core.AssertionError, "Column not found in table model", "Invalid column width.");
        }
        table.destroy();
        model.dispose();
      },
      testGetCellEditorFactory: function testGetCellEditorFactory() {
        var model = this.createModel();
        var table = new qx.ui.table.Table(model);
        var tcm = table.getTableColumnModel();
        {
          this.assertException(function () {
            tcm.getCellEditorFactory(6);
          }, qx.core.AssertionError, "Column not found in table model", "Invalid column width.");
        }
        table.destroy();
        model.dispose();
      }
    }
  });
  qx.test.ui.table.columnmodel.Basic.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.table.Table": {},
      "qx.ui.table.model.Filtered": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * William Oprandi (woprandi)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.table.model.Filtered", {
    extend: qx.dev.unit.TestCase,
    members: {
      createTable: function createTable() {
        var table = new qx.ui.table.Table(new qx.ui.table.model.Filtered());
        var data = [{
          a: 1
        }, {
          a: 2
        }, {
          a: 3
        }, {
          a: 4
        }, {
          a: 5
        }, {
          a: 6
        }, {
          a: 7
        }, {
          a: 8
        }, {
          a: 9
        }, {
          a: 10
        }];
        table.getTableModel().setColumns(["a"]);
        table.getTableModel().setDataAsMapArray(data);
        return table;
      },
      testBetween: function testBetween() {
        var table = this.createTable();
        var model = table.getTableModel();
        model.addBetweenFilter("!between", 4, 6, "a");
        model.applyFilters();
        this.assertIdentical(3, model.getRowCount());
        var data = model.getDataAsMapArray();
        var listA = [];
        data.forEach(function (obj) {
          listA.push(obj.a);
        });
        this.assertNotInArray(3, listA);
        this.assertInArray(4, listA);
        this.assertInArray(5, listA);
        this.assertInArray(6, listA);
        this.assertNotInArray(7, listA);
        table.destroy();
      },
      testNotBetween: function testNotBetween() {
        var table = this.createTable();
        var model = table.getTableModel();
        model.addBetweenFilter("between", 2, 8, "a");
        model.applyFilters();
        var data = table.getTableModel().getDataAsMapArray();
        var listA = [];
        data.forEach(function (obj) {
          listA.push(obj.a);
        });
        this.assertNotInArray(3, listA);
        this.assertNotInArray(7, listA);
        this.assertInArray(1, listA);
        this.assertInArray(9, listA);
        table.destroy();
      },
      testNumericFilter: function testNumericFilter() {
        var table = this.createTable();
        var model = table.getTableModel();
        model.addNumericFilter("==", 8, "a");
        model.applyFilters();
        this.assertIdentical(9, model.getRowCount());
        model.resetHiddenRows();
        model.addNumericFilter("<", 4, "a");
        model.applyFilters();
        this.assertIdentical(7, model.getRowCount());
        model.resetHiddenRows();
        model.addNumericFilter(">=", 9, "a");
        model.applyFilters();
        this.assertIdentical(8, model.getRowCount());
        model.resetHiddenRows();
        model.addNumericFilter("!=", 1, "a");
        model.applyFilters();
        this.assertIdentical(1, model.getRowCount());
        table.destroy();
      }
    }
  });
  qx.test.ui.table.model.Filtered.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.model.Simple": {
        "construct": true,
        "require": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Tartan Solutions, Inc, http://www.tartansolutions.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Dan Hummon
  
  ************************************************************************ */

  /**
   * A filtered table model to provide support for hiding and filtering table
   * rows. Any rows that match any applied filters will be hidden.
  
  <pre class='javascript'>
  var model = new qx.ui.table.model.Filtered();
  model.setColumns(["Login", "Name", "Email"], ["login", "name", "email"]);
  
  var table = new qx.ui.table.Table(model);
  
  var data = [{
    login : "darthvader",
    name : "Darth Vader",
    email : "darthvader@tatooine.org"
  }, {
    login : "anakin",
    name : "Anakin Skywalker",
    email : "anakin@skywalker.org"
  }, {
    login : "luke",
    name : "Luke Skywalker",
    email : "luke@tatooine.org"
  }, {
    login : "obi-wan",
    name : "Obi-Wan Kenobi",
    email : "obiwan@jedi.org"
  }, {
    login : "rey",
    name : "Rey",
    email : "rey@jakku.sw"
  }];
  
  model.setDataAsMapArray(data);
  
  this.getRoot().add(table);
  
  var search = new qx.ui.form.TextField();
  search.set({
    liveUpdate : true,
    placeholder : "Search login"
  });
  
  search.addListener("changeValue", function(e) {
    var value = e.getData();
  
    model.resetHiddenRows();
    model.addNotRegex(value, "login", true);
    model.applyFilters();
  });
  
  this.getRoot().add(search, {top : 500, left : 10});
  </pre>
   *
   * @deprecated {6.0} You should use
   * <a href='http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter' target='_blank'>Array.filter</a>
   * method to filter the table model
   */
  qx.Class.define("qx.ui.table.model.Filtered", {
    extend: qx.ui.table.model.Simple,
    construct: function construct() {
      qx.ui.table.model.Simple.constructor.call(this);
      this.__filterTypes = {
        "==": "numeric",
        "!=": "numeric",
        ">": "numeric",
        "<": "numeric",
        "<=": "numeric",
        ">=": "numeric",
        "between": "between",
        "!between": "between"
      };
      this.__applyingFilters = false;
      this.Filters = [];
    },
    members: {
      __fullArr: null,
      __applyingFilters: null,
      __filterTypes: null,

      /**
       * Function to get the full array of the filtered model
       * @return {Array} the full array of model (with no changes)
       */
      getFullArray: function getFullArray() {
        return this.__fullArr;
      },

      /**
       * Whether the given string (needle) is in the array (haystack)
       *
       * @param the_needle {String} String to search
       * @param the_haystack {Array} Array, which should be searched
       * @return {Boolean} whether the search string was found.
       * @deprecated {6.0}
       */
      _js_in_array: function _js_in_array(the_needle, the_haystack) {
        var the_hay = the_haystack.toString();

        if (the_hay == '') {
          return false;
        }

        var the_pattern = new RegExp(the_needle, 'g');
        var matched = the_pattern.test(the_haystack);
        return matched;
      },

      /**
       * The addBetweenFilter method is used to add a between filter to the
       * table model.
       *
       * @param filter {String}
       *    The type of filter. Accepted strings are "between" and "!between".
       *
       * @param value1 {Integer}
       *    The first value to compare against.
       *
       * @param value2 {Integer}
       *    The second value to compare against.
       *
       * @param target {String}
       *    The text value of the column to compare against.
       *
       *
       * @throws {Error} If the filter can not recognized or one of the values
       * is null.
       */
      addBetweenFilter: function addBetweenFilter(filter, value1, value2, target) {
        if (this.__filterTypes[filter] === "between" && target != null) {
          if (value1 != null && value2 != null) {
            var temp = new Array(filter, value1, value2, target);
          }
        }

        if (temp != null) {
          this.Filters.push(temp);
        } else {
          throw new Error("Filter not recognized or value1/value2 is null!");
        }
      },

      /**
       * The addNumericFilter method is used to add a basic numeric filter to
       * the table model.
       *
       * @param filter {String}
       *    The type of filter. Accepted strings are:
       *    "==", "!=", ">", "<", ">=", and "<=".
       *
       * @param value1 {Integer}
       *    The value to compare against.
       *
       * @param target {String}
       *    The text value of the column to compare against.
       *
       *
       * @throws {Error} If the filter can not recognized or the target is null.
       */
      addNumericFilter: function addNumericFilter(filter, value1, target) {
        var temp = null;

        if (this.__filterTypes[filter] === "numeric" && target != null) {
          if (value1 != null) {
            temp = [filter, value1, target];
          }
        }

        if (temp != null) {
          this.Filters.push(temp);
        } else {
          throw new Error("Filter not recognized: value or target is null!");
        }
      },

      /**
       * The addRegex method is used to add a regular expression filter to the
       * table model.
       *
       * @param regex {String}
       *    The regular expression to match against.
       *
       * @param target {String}
       *    The text value of the column to compare against.
       *
       * @param ignorecase {Boolean}
       *    If true, the regular expression will ignore case.
       *
       *
       * @throws {Error} If the regex is not valid.
       */
      addRegex: function addRegex(regex, target, ignorecase) {
        var regexarg;

        if (ignorecase) {
          regexarg = 'gi';
        } else {
          regexarg = 'g';
        }

        if (regex != null && target != null) {
          var temp = new Array("regex", regex, target, regexarg);
        }

        if (temp != null) {
          this.Filters.push(temp);
        } else {
          throw new Error("regex cannot be null!");
        }
      },

      /**
       * The addNotRegex method is used to add a regular expression filter to the
       * table model and filter cells that do not match.
       *
       * @param regex {String}
       *    The regular expression to match against.
       *
       * @param target {String}
       *    The text value of the column to compare against.
       *
       * @param ignorecase {Boolean}
       *    If true, the regular expression will ignore case.
       *
       *
       * @throws {Error} If the regex is null.
       */
      addNotRegex: function addNotRegex(regex, target, ignorecase) {
        var regexarg;

        if (ignorecase) {
          regexarg = 'gi';
        } else {
          regexarg = 'g';
        }

        if (regex != null && target != null) {
          var temp = new Array("notregex", regex, target, regexarg);
        }

        if (temp != null) {
          this.Filters.push(temp);
        } else {
          throw new Error("notregex cannot be null!");
        }
      },

      /**
      * The applyFilters method is called to apply filters to the table model.
      */
      applyFilters: function applyFilters() {
        var i;
        var filter_test;
        var compareValue;
        var rowArr = this.getData();
        var rowLength = rowArr.length;
        var rowsToHide = [];

        for (var row = 0; row < rowLength; row++) {
          filter_test = false;

          for (i in this.Filters) {
            if (this.__filterTypes[this.Filters[i][0]] === "numeric") {
              compareValue = this.getValueById(this.Filters[i][2], row);

              switch (this.Filters[i][0]) {
                case "==":
                  if (compareValue == this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;

                case "!=":
                  if (compareValue != this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;

                case ">":
                  if (compareValue > this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;

                case "<":
                  if (compareValue < this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;

                case ">=":
                  if (compareValue >= this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;

                case "<=":
                  if (compareValue <= this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;
              }
            } else if (this.__filterTypes[this.Filters[i][0]] === "between") {
              compareValue = this.getValueById(this.Filters[i][3], row);

              switch (this.Filters[i][0]) {
                case "between":
                  if (compareValue >= this.Filters[i][1] && compareValue <= this.Filters[i][2]) {
                    filter_test = true;
                  }

                  break;

                case "!between":
                  if (compareValue < this.Filters[i][1] || compareValue > this.Filters[i][2]) {
                    filter_test = true;
                  }

                  break;
              }
            } else if (this.Filters[i][0] === "regex") {
              compareValue = this.getValueById(this.Filters[i][2], row);
              var the_pattern = new RegExp(this.Filters[i][1], this.Filters[i][3]);
              filter_test = the_pattern.test(compareValue);
            } else if (this.Filters[i][0] === "notregex") {
              compareValue = this.getValueById(this.Filters[i][2], row);
              var the_pattern = new RegExp(this.Filters[i][1], this.Filters[i][3]);
              filter_test = !the_pattern.test(compareValue);
            }

            if (filter_test === true) {
              break;
            }
          } // instead of hiding a single row, push it into the hiding-store for later hiding.


          if (filter_test === true) {
            rowsToHide.push(row);
          }
        }

        if (!this.__applyingFilters) {
          this.__fullArr = rowArr.slice(0);
          this.__applyingFilters = true;
        }

        rowArr = rowArr.filter(function (row, index) {
          return !rowsToHide.includes(index);
        });
        this._rowArr = rowArr;
        var data = {
          firstRow: 0,
          lastRow: this._rowArr.length - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1
        }; // Inform the listeners

        this.fireDataEvent("dataChanged", data);
      },

      /**
       * Hides a specified number of rows.
       *
       * @param rowNum {Integer}
       *    Index of the first row to be hidden in the table.
       *
       * @param numOfRows {Integer}
       *    The number of rows to be hidden sequentially after rowNum.
       *
       * @param dispatchEvent {Boolean?true} Whether a model change event should
       *    be fired.
       *
       */
      hideRows: function hideRows(rowNum, numOfRows, dispatchEvent) {
        var rowArr = this.getData();
        dispatchEvent = dispatchEvent != null ? dispatchEvent : true;

        if (!this.__applyingFilters) {
          this.__fullArr = rowArr.slice(0);
          this.__applyingFilters = true;
        }

        if (numOfRows == null || numOfRows < 1) {
          numOfRows = 1;
        }

        for (var kludge = rowNum; kludge < rowArr.length - numOfRows; kludge++) {
          rowArr[kludge] = rowArr[kludge + numOfRows];
        }

        this.removeRows(kludge, numOfRows); // Inform the listeners

        if (dispatchEvent) {
          var data = {
            firstRow: 0,
            lastRow: rowArr.length - 1,
            firstColumn: 0,
            lastColumn: this.getColumnCount() - 1
          };
          this.fireDataEvent("dataChanged", data);
        }
      },

      /**
       * Return the table to the original state with all rows shown and clears
       * all filters.
       *
       */
      resetHiddenRows: function resetHiddenRows() {
        if (!this.__fullArr) {
          // nothing to reset
          return;
        }

        this.Filters = [];
        this.setData(qx.lang.Array.clone(this.__fullArr));
      },
      // overridden
      setData: function setData(rowArr, clearSorting) {
        this.__fullArr = qx.lang.Array.clone(rowArr);
        this.Filters = [];
        qx.ui.table.model.Filtered.prototype.setData.base.call(this, rowArr, clearSorting);
      }
    },
    destruct: function destruct() {
      this.__fullArr = this.__filterTypes = this.Filters = null;
    }
  });
  qx.ui.table.model.Filtered.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.table.model.Simple": {},
      "qx.ui.table.Table": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.table.model.Simple", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      testGetRowDataAsMap: function testGetRowDataAsMap() {
        var tableDataWithMeta = [{
          "id": 100,
          "col1": 'test',
          "col2": 'test2'
        }];
        var tableModel = new qx.ui.table.model.Simple();
        tableModel.setColumns(["Col1", "Col2"], ["col1", "col2"]);
        tableModel.setDataAsMapArray(tableDataWithMeta, true); // check the initial data

        var data = tableModel.getRowDataAsMap(0);
        this.assertEquals(100, data.id);
        this.assertEquals("test", data.col1);
        this.assertEquals("test2", data.col2); // change the data

        tableModel.setValue(0, 0, "affe");
        data = tableModel.getRowDataAsMap(0); // check the changed data

        this.assertEquals(100, data.id);
        this.assertEquals("affe", data.col1);
        this.assertEquals("test2", data.col2);
        tableModel.dispose();
      },
      getStringValues: function getStringValues() {
        return ["aaaa", "bbbb", "cccc", "dddd", "eeee", "ffff"];
      },
      createRandomRows: function createRandomRows(rowCount) {
        var rowData = [];
        var strings = this.getStringValues();

        for (var row = 0; row < rowCount; row++) {
          rowData.push([row + 1, strings[row % strings.length]]);
        }

        return rowData;
      },
      testCustomSortFunction: function testCustomSortFunction() {
        var stringValues = this.getStringValues();
        var rowCount = 20; // table

        var model = new qx.ui.table.model.Simple();
        model.setColumns(["ID", "String"]);
        model.setData(this.createRandomRows(rowCount)); // custom individual ascending descending integer sort function for column 0

        model.setSortMethods(0, {
          ascending: function ascending(row1, row2, columnIndex) {
            var int1 = row1[columnIndex];
            var int2 = row2[columnIndex];
            return int1 > int2 ? 1 : int1 == int2 ? 0 : -1;
          },
          descending: function descending(row2, row1, columnIndex) {
            var int1 = row1[columnIndex];
            var int2 = row2[columnIndex];
            return int1 > int2 ? 1 : int1 == int2 ? 0 : -1;
          }
        }); // custom single string sort function for column 1

        model.setSortMethods(1, function (row1, row2, columnIndex) {
          var string1 = row1[columnIndex];
          var string2 = row2[columnIndex];
          return string1.localeCompare(string2);
        });
        var table = new qx.ui.table.Table(model); // test sorting column 1
        // sort descending

        model.sortByColumn(1);
        var data = model.getData();
        this.assertTrue(data[0][1] == stringValues[stringValues.length - 1]);
        this.assertTrue(data[data.length - 1][1] == stringValues[0]); // sort ascending

        model.sortByColumn(1, true);
        this.assertTrue(data[0][1] == stringValues[0]);
        this.assertTrue(data[data.length - 1][1] == stringValues[stringValues.length - 1]); // test sorting column 0
        // sort descending

        model.sortByColumn(0);
        this.assertTrue(data[0][0] == rowCount);
        this.assertTrue(data[data.length - 1][0] == 1); // sort ascending

        model.sortByColumn(0, true);
        this.assertTrue(data[0][0] == 1);
        this.assertTrue(data[data.length - 1][0] == rowCount);
        table.destroy();
        model.dispose();
      },
      testCustomSortFunctionArgumentsCalleeColumnIndexDeprecated: function testCustomSortFunctionArgumentsCalleeColumnIndexDeprecated() {
        var stringValues = this.getStringValues();
        var rowCount = 20; // table

        var model = new qx.ui.table.model.Simple();
        model.setColumns(["ID", "String"]);
        model.setData(this.createRandomRows(rowCount)); // custom individual ascending descending integer sort function for column 0

        model.setSortMethods(0, {
          ascending: function ascending(row1, row2) {
            var columnIndex = arguments.callee.columnIndex;
            var int1 = row1[columnIndex];
            var int2 = row2[columnIndex];
            return int1 > int2 ? 1 : int1 == int2 ? 0 : -1;
          },
          descending: function descending(row2, row1) {
            var columnIndex = arguments.callee.columnIndex;
            var int1 = row1[columnIndex];
            var int2 = row2[columnIndex];
            return int1 > int2 ? 1 : int1 == int2 ? 0 : -1;
          }
        }); // custom single string sort function for column 1

        model.setSortMethods(1, function (row1, row2) {
          var columnIndex = arguments.callee.columnIndex;
          var string1 = row1[columnIndex];
          var string2 = row2[columnIndex];
          return string1.localeCompare(string2);
        });
        var table = new qx.ui.table.Table(model); // test sorting column 1
        // sort descending

        model.sortByColumn(1);
        var data = model.getData();
        this.assertTrue(data[0][1] == stringValues[stringValues.length - 1]);
        this.assertTrue(data[data.length - 1][1] == stringValues[0]); // sort ascending

        model.sortByColumn(1, true);
        this.assertTrue(data[0][1] == stringValues[0]);
        this.assertTrue(data[data.length - 1][1] == stringValues[stringValues.length - 1]); // test sorting column 0
        // sort descending

        model.sortByColumn(0);
        this.assertTrue(data[0][0] == rowCount);
        this.assertTrue(data[data.length - 1][0] == 1); // sort ascending

        model.sortByColumn(0, true);
        this.assertTrue(data[0][0] == 1);
        this.assertTrue(data[data.length - 1][0] == rowCount);
        table.destroy();
        model.dispose();
      }
    }
  });
  qx.test.ui.table.model.Simple.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.table.selection.Model": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2018 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Milan Damen (milandamen)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.table.selection.Model", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      testRemoveSelectionInterval: function testRemoveSelectionInterval() {
        var selectionModel = new qx.ui.table.selection.Model();
        selectionModel.setSelectionMode(4); // MULTIPLE_INTERVAL_SELECTION

        selectionModel.removeSelectionInterval(0, 0);
        this.assertIdentical(0, selectionModel._getSelectedRangeArr().length);
        selectionModel.removeSelectionInterval(0, 0, true);
        this.assertIdentical(0, selectionModel._getSelectedRangeArr().length);
        selectionModel.setSelectionInterval(0, 1);
        this.assertJsonEquals([{
          minIndex: 0,
          maxIndex: 1
        }], selectionModel._getSelectedRangeArr());
        selectionModel.removeSelectionInterval(0, 1);
        this.assertIdentical(0, selectionModel._getSelectedRangeArr().length);
        selectionModel.setSelectionInterval(0, 1);
        selectionModel.removeSelectionInterval(0, 2);
        this.assertIdentical(0, selectionModel._getSelectedRangeArr().length);
        selectionModel.setSelectionInterval(0, 1);
        selectionModel.removeSelectionInterval(0, 2, true);
        this.assertIdentical(0, selectionModel._getSelectedRangeArr().length);
        selectionModel.setSelectionInterval(1, 1);
        selectionModel.removeSelectionInterval(0, 2);
        this.assertIdentical(0, selectionModel._getSelectedRangeArr().length);
        selectionModel.setSelectionInterval(1, 1);
        selectionModel.removeSelectionInterval(0, 2, true);
        this.assertIdentical(0, selectionModel._getSelectedRangeArr().length);
        selectionModel.setSelectionInterval(0, 1);
        selectionModel.removeSelectionInterval(0, 0);
        this.assertJsonEquals([{
          minIndex: 1,
          maxIndex: 1
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(0, 1);
        selectionModel.removeSelectionInterval(0, 0, true);
        this.assertJsonEquals([{
          minIndex: 0,
          maxIndex: 0
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(0, 1);
        selectionModel.removeSelectionInterval(1, 1);
        this.assertJsonEquals([{
          minIndex: 0,
          maxIndex: 0
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(0, 1);
        selectionModel.removeSelectionInterval(1, 1, true);
        this.assertJsonEquals([{
          minIndex: 0,
          maxIndex: 0
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(1, 2);
        selectionModel.removeSelectionInterval(0, 0);
        this.assertJsonEquals([{
          minIndex: 1,
          maxIndex: 2
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(1, 2);
        selectionModel.removeSelectionInterval(0, 0, true);
        this.assertJsonEquals([{
          minIndex: 0,
          maxIndex: 1
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(0, 1);
        selectionModel.removeSelectionInterval(2, 2);
        this.assertJsonEquals([{
          minIndex: 0,
          maxIndex: 1
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(0, 1);
        selectionModel.removeSelectionInterval(2, 2, true);
        this.assertJsonEquals([{
          minIndex: 0,
          maxIndex: 1
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(1, 3);
        selectionModel.removeSelectionInterval(1, 1);
        this.assertJsonEquals([{
          minIndex: 2,
          maxIndex: 3
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(1, 3);
        selectionModel.removeSelectionInterval(1, 1, true);
        this.assertJsonEquals([{
          minIndex: 1,
          maxIndex: 2
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(0, 2);
        selectionModel.removeSelectionInterval(2, 3);
        this.assertJsonEquals([{
          minIndex: 0,
          maxIndex: 1
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(0, 2);
        selectionModel.removeSelectionInterval(2, 3, true);
        this.assertJsonEquals([{
          minIndex: 0,
          maxIndex: 1
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(0, 5);
        selectionModel.removeSelectionInterval(2, 3);
        this.assertJsonEquals([{
          minIndex: 0,
          maxIndex: 1
        }, {
          minIndex: 4,
          maxIndex: 5
        }], selectionModel._getSelectedRangeArr());
        selectionModel.setSelectionInterval(0, 5);
        selectionModel.removeSelectionInterval(2, 3, true);
        this.assertJsonEquals([{
          minIndex: 0,
          maxIndex: 3
        }], selectionModel._getSelectedRangeArr());
      }
    }
  });
  qx.test.ui.table.selection.Model.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.VBox": {},
      "qx.ui.toolbar.ToolBar": {},
      "qx.ui.toolbar.Button": {},
      "qx.ui.core.Spacer": {},
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.toolbar.OverflowHandling", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      __container: null,
      __toolbar: null,
      __b1: null,
      __b2: null,
      __b3: null,
      __indicator: null,
      setUp: function setUp() {
        qx.test.ui.toolbar.OverflowHandling.prototype.setUp.base.call(this);
        this.__container = new qx.ui.container.Composite();

        this.__container.setLayout(new qx.ui.layout.VBox());

        this.getRoot().add(this.__container);

        this.__container.setWidth(100);

        this.__toolbar = new qx.ui.toolbar.ToolBar();

        this.__container.add(this.__toolbar);

        this.__b1 = new qx.ui.toolbar.Button("B1");
        this.__b2 = new qx.ui.toolbar.Button("B2");
        this.__b3 = new qx.ui.toolbar.Button("B3");
      },
      tearDown: function tearDown() {
        qx.test.ui.toolbar.OverflowHandling.prototype.tearDown.base.call(this);
        var self = this;

        this.__b1.destroy();

        this.__b2.destroy();

        this.__b3.destroy();

        this.__toolbar.destroy();

        this.__container.destroy();

        if (self.__indicator) {
          this.__indicator.destroy();
        }
      },
      __addButtons: function __addButtons() {
        this.__toolbar.add(this.__b1);

        this.__toolbar.add(this.__b2);

        this.__toolbar.add(this.__b3);
      },
      testShow: function testShow() {
        this.__addButtons();

        this.__toolbar.setShow("label");

        this.assertEquals(this.__toolbar.getShow(), this.__b1.getShow());
        this.assertEquals(this.__toolbar.getShow(), this.__b2.getShow());
        this.assertEquals(this.__toolbar.getShow(), this.__b3.getShow());

        this.__toolbar.setShow("icon");

        this.assertEquals(this.__toolbar.getShow(), this.__b1.getShow());
        this.assertEquals(this.__toolbar.getShow(), this.__b2.getShow());
        this.assertEquals(this.__toolbar.getShow(), this.__b3.getShow());
      },
      testSpacing: function testSpacing() {
        this.__toolbar.setSpacing(123);

        this.assertEquals(this.__toolbar.getSpacing(), this.__toolbar._getLayout().getSpacing());
      },
      testSpacer: function testSpacer() {
        this.__toolbar.addSpacer();

        this.assertTrue(this.__toolbar.getChildren()[0] instanceof qx.ui.core.Spacer);
      },
      testHideItem: function testHideItem() {
        this.__addButtons();

        this.flush();

        this.__toolbar.setOverflowHandling(true);

        var self = this;
        this.assertEventFired(this.__toolbar, "hideItem", function () {
          self.__container.setWidth(60);

          self.flush();
        }, function (e) {
          self.assertEquals(self.__b3, e.getData());
          self.assertEquals("excluded", self.__b3.getVisibility());
        });
      },
      testShowItem: function testShowItem() {
        this.__addButtons();

        this.flush();

        this.__toolbar.setOverflowHandling(true);

        this.__container.setWidth(60);

        this.flush();
        var self = this;
        this.assertEventFired(this.__toolbar, "showItem", function () {
          self.__container.setWidth(100);

          self.flush();
        }, function (e) {
          self.assertEquals(self.__b3, e.getData());
          self.assertEquals("visible", self.__b3.getVisibility());
        });
      },
      testHideItemPriority: function testHideItemPriority() {
        this.__addButtons();

        this.flush();

        this.__toolbar.setOverflowHandling(true);

        this.__toolbar.setRemovePriority(this.__b2, 2);

        var self = this;
        this.assertEventFired(this.__toolbar, "hideItem", function () {
          self.__container.setWidth(60);

          self.flush();
        }, function (e) {
          self.assertEquals(self.__b2, e.getData());
          self.assertEquals("excluded", self.__b2.getVisibility());
        });
      },
      testShowItemPriority: function testShowItemPriority() {
        this.__addButtons();

        this.flush();

        this.__toolbar.setOverflowHandling(true);

        this.__toolbar.setRemovePriority(this.__b2, 2);

        this.__container.setWidth(60);

        this.flush();
        var self = this;
        this.assertEventFired(this.__toolbar, "showItem", function () {
          self.__container.setWidth(100);

          self.flush();
        }, function (e) {
          self.assertEquals(self.__b2, e.getData());
          self.assertEquals("visible", self.__b2.getVisibility());
        });
      },
      testShowIndicator: function testShowIndicator(attribute) {
        this.__addButtons();

        this.flush();

        this.__toolbar.setOverflowHandling(true);

        this.__indicator = new qx.ui.basic.Label(".");

        this.__toolbar.add(this.__indicator);

        this.__toolbar.setOverflowIndicator(this.__indicator);

        this.assertEquals("excluded", this.__indicator.getVisibility());

        this.__indicator.addListener("changeVisibility", function () {
          this.resume(function () {
            this.assertEquals("visible", this.__indicator.getVisibility());
          }, this);
        }, this);

        this.__container.setWidth(60);

        this.wait();
      },
      testHideIndicator: function testHideIndicator(attribute) {
        this.__addButtons();

        this.flush();

        this.__toolbar.setOverflowHandling(true);

        this.__indicator = new qx.ui.basic.Label(".");

        this.__toolbar.add(this.__indicator);

        this.__toolbar.setOverflowIndicator(this.__indicator);

        this.assertEquals("excluded", this.__indicator.getVisibility());

        this.__container.setWidth(60);

        this.flush();

        this.__indicator.addListener("changeVisibility", function () {
          this.resume(function () {
            this.assertEquals("excluded", this.__indicator.getVisibility());
          }, this);
        }, this);

        this.__container.setWidth(160);

        this.wait();
      },
      testShowIndicatorHuge: function testShowIndicatorHuge(attribute) {
        this.__addButtons();

        this.flush();

        this.__toolbar.setOverflowHandling(true);

        this.__indicator = new qx.ui.basic.Label(".....");

        this.__toolbar.add(this.__indicator);

        this.__toolbar.setOverflowIndicator(this.__indicator);

        this.assertEquals("excluded", this.__indicator.getVisibility());

        this.__b2.addListener("changeVisibility", function () {
          this.resume(function () {
            this.assertEquals("visible", this.__indicator.getVisibility()); // check if both buttons have been removed

            this.assertEquals("excluded", this.__b3.getVisibility(), "1");
            this.assertEquals("excluded", this.__b2.getVisibility(), "2");
          }, this);
        }, this);

        this.__container.setWidth(60);

        this.wait();
      },
      testHideItemRemoved: function testHideItemRemoved() {
        this.__addButtons();

        this.flush();

        this.__toolbar.setOverflowHandling(true);

        this.__toolbar.remove(this.__b3);

        var self = this;
        this.assertEventNotFired(this.__toolbar, "hideItem", function () {
          self.__container.setWidth(60);

          self.flush();
        });
      },
      testShowItemRemoved: function testShowItemRemoved() {
        this.__addButtons();

        this.flush();

        this.__toolbar.setOverflowHandling(true);

        this.__container.setWidth(60);

        this.flush();
        var self = this;
        this.assertEventFired(this.__toolbar, "showItem", function () {
          self.__toolbar.remove(self.__b3);

          self.flush();
        }, function (e) {
          self.assertEquals(self.__b3, e.getData());
          self.assertEquals("visible", self.__b3.getVisibility());
        });
      },
      testAddItem: function testAddItem() {
        this.__indicator = new qx.ui.basic.Label(".");

        this.__toolbar.add(this.__indicator);

        this.__toolbar.setOverflowIndicator(this.__indicator);

        this.__toolbar.setOverflowHandling(true);

        this.__container.setWidth(60);

        this.flush();
        var self = this;
        this.assertEventFired(this.__indicator, "changeVisibility", function () {
          self.__addButtons();

          self.flush();
        }, function (e) {
          self.assertEquals("visible", self.__indicator.getVisibility());
          self.assertEquals("excluded", self.__b3.getVisibility());
        });
      }
    }
  });
  qx.test.ui.toolbar.OverflowHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.toolbar.ToolBar": {},
      "qx.ui.toolbar.Button": {},
      "qx.ui.toolbar.Part": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.toolbar.ToolBar", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        qx.test.ui.toolbar.ToolBar.prototype.setUp.base.call(this);
        this.__toolbar = new qx.ui.toolbar.ToolBar();
        this.__b1 = new qx.ui.toolbar.Button("b1");
        this.__b2 = new qx.ui.toolbar.Button("b2");
        this.__b3 = new qx.ui.toolbar.Button("b3");
      },
      tearDown: function tearDown() {
        qx.test.ui.toolbar.ToolBar.prototype.tearDown.base.call(this);

        this.__b1.dispose();

        this.__b2.dispose();

        this.__b3.dispose();

        this.__toolbar.dispose();
      },
      testShowSyncing: function testShowSyncing() {
        // setup toolbar with two buttons
        this.__toolbar.add(this.__b1);

        this.__toolbar.add(this.__b2); // set a value and check if the buttons get synced


        this.__toolbar.setShow("label");

        this.assertEquals("label", this.__b1.getShow());
        this.assertEquals("label", this.__b2.getShow()); // add another button and check if the value has been applied

        this.__toolbar.add(this.__b3);

        this.assertEquals("label", this.__b3.getShow());
      },
      testPositionStates: function testPositionStates() {
        var part = new qx.ui.toolbar.Part();
        part.add(this.__b1);
        part.add(this.__b2);
        part.add(this.__b3);

        this.__toolbar.add(part);

        this.getRoot().add(this.__toolbar);
        this.flush();
        this.assertTrue(this.__b1.hasState("left"));
        this.assertTrue(this.__b2.hasState("middle"));
        this.assertTrue(this.__b3.hasState("right"));
        part.dispose();
      },
      testPositionStatesAdd: function testPositionStatesAdd() {
        var part = new qx.ui.toolbar.Part();
        part.add(this.__b1);
        part.add(this.__b3);

        this.__toolbar.add(part);

        this.getRoot().add(this.__toolbar);
        this.flush();
        this.assertTrue(this.__b1.hasState("left"));
        this.assertTrue(this.__b3.hasState("right"));
        part.addAt(this.__b2, 1);
        this.flush();
        this.assertTrue(this.__b1.hasState("left"));
        this.assertTrue(this.__b2.hasState("middle"));
        this.assertTrue(this.__b3.hasState("right"));
        part.dispose();
      },
      testPositionStatesRemove: function testPositionStatesRemove() {
        var part = new qx.ui.toolbar.Part();
        part.add(this.__b1);
        part.add(this.__b2);
        part.add(this.__b3);

        this.__toolbar.add(part);

        this.getRoot().add(this.__toolbar);
        this.flush();
        this.assertTrue(this.__b1.hasState("left"));
        this.assertTrue(this.__b2.hasState("middle"));
        this.assertTrue(this.__b3.hasState("right"));
        part.remove(this.__b1);
        this.flush();
        this.assertTrue(this.__b2.hasState("left"));
        this.assertTrue(this.__b3.hasState("right"));
        part.dispose();
      },
      testShowUserValueShouldTakePrecedence: function testShowUserValueShouldTakePrecedence() {
        // setup toolbar with two buttons
        this.__toolbar.add(this.__b1);

        this.__toolbar.add(this.__b2); // assert 'label' isn't default show val


        this.assertNotEquals("label", this.__b1.getShow());
        this.assertNotEquals("label", this.__b2.getShow()); // initialize toolbar with 'label'

        this.__toolbar.setShow("label");

        this.assertEquals("label", this.__b1.getShow());
        this.assertEquals("label", this.__b2.getShow()); // override it for button1

        this.__b1.setShow("icon");

        this.assertEquals("icon", this.__b1.getShow());
        this.assertEquals("label", this.__b2.getShow()); // change it afterwards

        this.__toolbar.setShow("both");

        this.__toolbar.add(this.__b3); // assert all 'both'


        this.assertEquals("both", this.__b1.getShow());
        this.assertEquals("both", this.__b2.getShow());
        this.assertEquals("both", this.__b3.getShow());
      },
      testRemoveChildByIndex: function testRemoveChildByIndex() {
        this.__toolbar.removeAll(); // setup toolbar with three buttons


        this.__toolbar.add(this.__b1);

        this.__toolbar.add(this.__b2);

        this.__toolbar.add(this.__b3); // assert finding child __b2 on index 1


        var indexB2 = this.__toolbar.indexOf(this.__b2);

        this.assertEquals(1, indexB2); // assert removing child at index 1

        var childB2 = this.__toolbar.removeAt(1);

        this.assertEquals(childB2, this.__b2); // assert length of remaining and removed children array being now 2

        var children = this.__toolbar.removeAll();

        this.assertEquals(2, children.length);
      },
      testRemoveAllChildren: function testRemoveAllChildren() {
        this.__toolbar.removeAll(); // setup toolbar with two buttons


        this.__toolbar.add(this.__b1);

        this.__toolbar.add(this.__b2); // assert length of removed children array


        var children = this.__toolbar.removeAll();

        this.assertEquals(2, children.length); // assert empty children array

        children = this.__toolbar.removeAll();
        this.assertEquals(0, children.length);
      }
    }
  });
  qx.test.ui.toolbar.ToolBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.tree.Tree": {},
      "qx.ui.tree.TreeFolder": {},
      "qx.ui.tree.TreeFile": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.tree.Tree", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      _tree: null,
      setUp: function setUp() {
        qx.test.ui.tree.Tree.prototype.setUp.base.call(this);
        this._tree = new qx.ui.tree.Tree();
        this.getRoot().add(this._tree);
        var tRoot = new qx.ui.tree.TreeFolder("root");

        this._tree.setRoot(tRoot);

        tRoot.setOpen(false);
        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.tree.Tree.prototype.tearDown.base.call(this);

        this._disposeObjects("_tree");
      },
      testGetPreviousSiblingOf: function testGetPreviousSiblingOf() {
        var tRoot = this._tree.getRoot();

        var item1 = new qx.ui.tree.TreeFile("1");
        tRoot.add(item1);
        var item1_1 = new qx.ui.tree.TreeFile("1_1");
        item1.add(item1_1);
        var item1_2 = new qx.ui.tree.TreeFile("1_2");
        item1.add(item1_2);
        var item2 = new qx.ui.tree.TreeFile("2");
        tRoot.add(item2);
        this.assertNull(this._tree.getPreviousSiblingOf(item1_1));
        this.assertIdentical(item1, this._tree.getPreviousSiblingOf(item2));
      },
      testGetNextSiblingOf: function testGetNextSiblingOf() {
        var tRoot = this._tree.getRoot();

        var item1 = new qx.ui.tree.TreeFile("1");
        tRoot.add(item1);
        var item1_1 = new qx.ui.tree.TreeFile("1_1");
        item1.add(item1_1);
        var item1_2 = new qx.ui.tree.TreeFile("1_2");
        item1.add(item1_2);
        var item2 = new qx.ui.tree.TreeFile("2");
        tRoot.add(item2);
        this.assertNull(this._tree.getNextSiblingOf(item1_2));
        this.assertIdentical(item2, this._tree.getNextSiblingOf(item1));
      },
      testGetNextNodeOf: function testGetNextNodeOf() {
        var tRoot = this._tree.getRoot();

        var item1 = new qx.ui.tree.TreeFile("1");
        tRoot.add(item1);
        var item1_1 = new qx.ui.tree.TreeFile("1_1");
        item1.add(item1_1);
        var item1_2 = new qx.ui.tree.TreeFile("1_2");
        item1.add(item1_2);
        var item2 = new qx.ui.tree.TreeFile("2");
        tRoot.add(item2);
        this.assertIdentical(item1_1, this._tree.getNextNodeOf(item1));
        this.assertIdentical(item1_2, this._tree.getNextNodeOf(item1_1));
        this.assertNull(this._tree.getNextNodeOf(item2));
      },
      testGetNextNodeOfInvisible: function testGetNextNodeOfInvisible() {
        var tRoot = this._tree.getRoot();

        tRoot.setOpen(true);
        var item1 = new qx.ui.tree.TreeFile("1");
        tRoot.add(item1);
        var item1_1 = new qx.ui.tree.TreeFile("1_1");
        item1.add(item1_1);
        var item1_2 = new qx.ui.tree.TreeFile("1_2");
        item1.add(item1_2);
        var item2 = new qx.ui.tree.TreeFile("2");
        tRoot.add(item2);
        this.assertIdentical(item2, this._tree.getNextNodeOf(item1, false));
        item1.setOpen(true);
        this.assertIdentical(item1_1, this._tree.getNextNodeOf(item1, false));
      },
      testGetPreviousNodeOf: function testGetPreviousNodeOf() {
        var tRoot = this._tree.getRoot();

        var item1 = new qx.ui.tree.TreeFile("1");
        tRoot.add(item1);
        var item1_1 = new qx.ui.tree.TreeFile("1_1");
        item1.add(item1_1);
        var item1_2 = new qx.ui.tree.TreeFile("1_2");
        item1.add(item1_2);
        var item2 = new qx.ui.tree.TreeFile("2");
        tRoot.add(item2);
        this.assertIdentical(item1_2, this._tree.getPreviousNodeOf(item2));
        this.assertIdentical(item1_1, this._tree.getPreviousNodeOf(item1_2));
        this.assertNull(this._tree.getPreviousNodeOf(tRoot));
      },
      testGetPreviousNodeOfInvisible: function testGetPreviousNodeOfInvisible() {
        var tRoot = this._tree.getRoot();

        tRoot.setOpen(true);
        var item1 = new qx.ui.tree.TreeFile("1");
        tRoot.add(item1);
        var item1_1 = new qx.ui.tree.TreeFile("1_1");
        item1.add(item1_1);
        var item1_2 = new qx.ui.tree.TreeFile("1_2");
        item1.add(item1_2);
        var item2 = new qx.ui.tree.TreeFile("2");
        tRoot.add(item2);
        this.assertIdentical(item1, this._tree.getPreviousNodeOf(item2, false));
        item1.setOpen(true);
        this.assertIdentical(item1_2, this._tree.getPreviousNodeOf(item2, false));
      },
      testAddBefore: function testAddBefore() {
        /*
         * root  => add 2 before 3 =>  root
         *  - 1                        - 1
         *  - 3                        - 2
         *  - 4                        - 3
         *                             - 4
         */
        var tRoot = this._tree.getRoot();

        tRoot.setOpen(true);
        var item1 = new qx.ui.tree.TreeFile("1");
        tRoot.add(item1);
        var item3 = new qx.ui.tree.TreeFile("3");
        tRoot.add(item3);
        var item4 = new qx.ui.tree.TreeFile("4");
        tRoot.add(item4); //this.info("before addBefore: " + this.__printChildren(tRoot.getChildren()));

        var item2 = new qx.ui.tree.TreeFile("2");
        tRoot.addBefore(item2, item3); //this.info("after addBefore: " + this.__printChildren(tRoot.getChildren()));

        this.assertIdentical(item1, this._tree.getPreviousNodeOf(item2), "check: 1 before 2");
        this.assertIdentical(item3, this._tree.getNextNodeOf(item2), "check: 3 after 2");
      },
      testAddAfter: function testAddAfter() {
        /*
         * root  => add 2 after 1 =>  root
         *  - 1                        - 1
         *  - 3                        - 2
         *  - 4                        - 3
         *                             - 4
         */
        var tRoot = this._tree.getRoot();

        tRoot.setOpen(true);
        var item1 = new qx.ui.tree.TreeFile("1");
        tRoot.add(item1);
        var item3 = new qx.ui.tree.TreeFile("3");
        tRoot.add(item3);
        var item4 = new qx.ui.tree.TreeFile("4");
        tRoot.add(item4); //this.info("before addAfter: " + this.__printChildren(tRoot.getChildren()));

        var item2 = new qx.ui.tree.TreeFile("2");
        tRoot.addAfter(item2, item1); //this.info("after addAfter: " + this.__printChildren(tRoot.getChildren()));

        this.assertIdentical(item1, this._tree.getPreviousNodeOf(item2), "check: 1 before 2");
        this.assertIdentical(item3, this._tree.getNextNodeOf(item2), "check: 3 after 2");
      },
      testChangeOrderWithAddBefore: function testChangeOrderWithAddBefore() {
        /*
         * root  => add 1 before 3 =>  root
         *  - 1                         - 2
         *  - 2                         - 1
         *  - 3                         - 3
         *  - 4                         - 4
         */
        var tRoot = this._tree.getRoot();

        tRoot.setOpen(true);
        var item1 = new qx.ui.tree.TreeFile("1");
        tRoot.add(item1);
        var item2 = new qx.ui.tree.TreeFile("2");
        tRoot.add(item2);
        var item3 = new qx.ui.tree.TreeFile("3");
        tRoot.add(item3);
        var item4 = new qx.ui.tree.TreeFile("4");
        tRoot.add(item4); //this.info("before addBefore: " + this.__printChildren(tRoot.getChildren()));

        tRoot.addBefore(item1, item3); //this.info("after addBefore: " + this.__printChildren(tRoot.getChildren()));

        this.assertIdentical(item1, this._tree.getPreviousNodeOf(item3), "check: 1 before 3");
        this.assertIdentical(item1, this._tree.getNextNodeOf(item2), "check: 1 after 2");
      },
      testChangeOrderWithAddAfter: function testChangeOrderWithAddAfter() {
        /*
         * root  => add 1 after 3 =>  root
         *  - 1                         - 2
         *  - 2                         - 3
         *  - 3                         - 1
         *  - 4                         - 4
         */
        var tRoot = this._tree.getRoot();

        tRoot.setOpen(true);
        var item1 = new qx.ui.tree.TreeFile("1");
        tRoot.add(item1);
        var item2 = new qx.ui.tree.TreeFile("2");
        tRoot.add(item2);
        var item3 = new qx.ui.tree.TreeFile("3");
        tRoot.add(item3);
        var item4 = new qx.ui.tree.TreeFile("4");
        tRoot.add(item4); //this.info("before addAfter: " + this.__printChildren(tRoot.getChildren()));

        tRoot.addAfter(item1, item3); //this.info("after addAfter: " + this.__printChildren(tRoot.getChildren()));

        this.assertIdentical(item1, this._tree.getPreviousNodeOf(item4), "check: 1 before 4");
        this.assertIdentical(item1, this._tree.getNextNodeOf(item3), "check: 1 after 3");
      },
      __printChildren: function __printChildren(children) {
        var result = "";

        for (var i = 0; i < children.length; i++) {
          result += children[i].getLabel();

          if (i < children.length - 1) {
            result += "->";
          }
        }

        return result;
      }
    }
  });
  qx.test.ui.tree.Tree.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.tree.Tree": {},
      "qx.ui.tree.TreeFolder": {},
      "qx.util.PropertyUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/icon/Oxygen/22/emotes/*)
   */
  qx.Class.define("qx.test.ui.tree.TreeFolder", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      icon_closed: "qx/icon/Oxygen/22/emotes/face-plain.png",
      icon_opened: "qx/icon/Oxygen/22/emotes/face-smile.png",
      __tree: null,
      __root: null,
      __aa: null,
      __ab: null,
      __item: null,
      setUp: function setUp() {
        // Build tree that looks like this:
        //
        // A ("root")
        // - AA ("item")
        // - BB
        var tree = this.__tree = new qx.ui.tree.Tree();
        var root = this.__root = new qx.ui.tree.TreeFolder("A");
        tree.setRoot(root);
        root.setOpen(true);
        var aa = this.__aa = new qx.ui.tree.TreeFolder("AA");
        var ab = this.__ab = new qx.ui.tree.TreeFolder("AB");
        root.add(aa, ab); // Reference to "aa" as "item"

        this.__item = this.__aa; // Render to set theme values

        this.getRoot().add(tree);
        this.flush();
      },
      //
      // Icon for when "closed" with all variations of "icon" and "iconClosed" property
      //
      testIconWhenClosed: function testIconWhenClosed() {
        var item = this.__item;
        this.flush();

        this.__assertIcon(item, this.__themeValueIcon(item));
      },
      testIconWhenClosedWithIcon: function testIconWhenClosedWithIcon() {
        var item = this.__item;
        item.setIcon(this.icon_closed);
        this.flush();

        this.__assertIcon(item, this.icon_closed);
      },
      testIconWhenClosedWithIconOpened: function testIconWhenClosedWithIconOpened() {
        var item = this.__item;
        item.setIconOpened(this.icon_opened);
        this.flush();

        this.__assertIcon(item, this.__themeValueIcon(item));
      },
      testIconWhenClosedWithIconAndIconOpened: function testIconWhenClosedWithIconAndIconOpened() {
        var item = this.__item;
        item.setIcon(this.icon_closed);
        item.setIconOpened(this.icon_opened);
        this.flush();

        this.__assertIcon(item, this.icon_closed);
      },
      //
      // Icon when "opened" with all variations of "icon" and "iconClosed" property
      //
      testIconWhenOpened: function testIconWhenOpened() {
        var item = this.__item;
        item.setOpen(true);
        this.flush();

        this.__assertIcon(item, this.__themeValueIconOpened(item));
      },
      testIconWhenOpenedWithIcon: function testIconWhenOpenedWithIcon() {
        var item = this.__item;
        item.setOpen(true);
        item.setIcon(this.icon_closed);
        this.flush(); // At first thought, you probably think this is correct...
        //
        // Expect theme value of iconOpened
        // this.__assertIcon(item, this.__themeValueIconOpened(item));
        // ... however, to ensure backwards-compatibility with the old behaviour
        //     before the property "openIcon" was introduced
        //
        // Expect user-defined value of property "icon"

        this.__assertIcon(item, this.icon_closed);
      },
      testIconWhenOpenedWithIconOpened: function testIconWhenOpenedWithIconOpened() {
        var item = this.__item;
        item.setOpen(true);
        item.setIconOpened(this.icon_opened);
        this.flush();

        this.__assertIcon(item, this.icon_opened);
      },
      testIconWhenOpenedWithIconAndIconOpened: function testIconWhenOpenedWithIconAndIconOpened() {
        var item = this.__item;
        item.setOpen(true);
        item.setIcon(this.icon_closed);
        item.setIconOpened(this.icon_opened);
        this.flush();

        this.__assertIcon(item, this.icon_opened);
      },
      //
      // Icon when "opened", then "closed" with all variations of "icon" and
      // "iconClosed" property
      //
      testIconWhenOpenedThenClosed: function testIconWhenOpenedThenClosed() {
        var item = this.__item;
        item.setOpen(true);
        item.setOpen(false);
        this.flush();

        this.__assertIcon(item, this.__themeValueIcon(item));
      },
      testIconWhenOpenedThenClosedWithIcon: function testIconWhenOpenedThenClosedWithIcon() {
        var item = this.__item;
        item.setIcon(this.icon_closed);
        item.setOpen(true);
        item.setOpen(false);
        this.flush();

        this.__assertIcon(item, this.icon_closed);
      },
      testIconWhenOpenedThenClosedWithIconOpened: function testIconWhenOpenedThenClosedWithIconOpened() {
        var item = this.__item;
        item.setIconOpened(this.icon_closed);
        item.setOpen(true);
        item.setOpen(false);
        this.flush();

        this.__assertIcon(item, this.__themeValueIcon(item));
      },
      testIconWhenOpenedThenClosedWithIconAndIconOpened: function testIconWhenOpenedThenClosedWithIconAndIconOpened() {
        var item = this.__item;
        item.setIcon(this.icon_closed);
        item.setIconOpened(this.icon_opened);
        item.setOpen(true);
        item.setOpen(false);
        this.flush();

        this.__assertIcon(item, this.icon_closed);
      },
      //
      // Icon when "closed", then "opened" with all variations of "icon" and
      // "iconClosed" property
      //
      testIconWhenClosedThenOpened: function testIconWhenClosedThenOpened() {
        var item = this.__item;
        item.setOpen(false);
        item.setOpen(true);
        this.flush();

        this.__assertIcon(item, this.__themeValueIconOpened(item));
      },
      testIconWhenClosedThenOpenedWithIcon: function testIconWhenClosedThenOpenedWithIcon() {
        var item = this.__item;
        item.setIcon(this.icon_closed);
        item.setOpen(false);
        item.setOpen(true);
        this.flush(); // At first thought, you probably think this is correct...
        //
        // Expect theme value of iconOpened
        // this.__assertIcon(item, this.__themeValueIconOpened(item));
        // ... however, to ensure backwards-compatibility with the old behaviour
        //     before the property "openIcon" was introduced
        //
        // Expect user-defined value of property "icon"

        this.__assertIcon(item, this.icon_closed);
      },
      testIconWhenClosedThenOpenedWithIconOpened: function testIconWhenClosedThenOpenedWithIconOpened() {
        var item = this.__item;
        item.setIconOpened(this.icon_opened);
        item.setOpen(false);
        item.setOpen(true);
        this.flush();

        this.__assertIcon(item, this.icon_opened);
      },
      testIconWhenClosedThenOpenedWithIconAndIconOpened: function testIconWhenClosedThenOpenedWithIconAndIconOpened() {
        var item = this.__item;
        item.setIcon(this.icon_closed);
        item.setIconOpened(this.icon_opened);
        item.setOpen(false);
        item.setOpen(true);
        this.flush();

        this.__assertIcon(item, this.icon_opened);
      },
      testRemoveAll: function testRemoveAll() {
        var removed = this.__root.removeAll();

        this.assertEquals(2, removed.length);
        this.assertEquals(this.__aa, removed[0]);
        this.assertEquals(this.__ab, removed[1]);
      },
      //
      // Helper methods
      //
      __themeValueIcon: function __themeValueIcon(item) {
        return qx.util.PropertyUtil.getThemeValue(item, "icon");
      },
      __themeValueIconOpened: function __themeValueIconOpened(item) {
        return qx.util.PropertyUtil.getThemeValue(item, "iconOpened");
      },
      __assertIcon: function __assertIcon(item, expected) {
        this.assertEquals(expected, item.getChildControl("icon").getSource(), "Unexpected source for icon child control");
      },
      tearDown: function tearDown() {
        qx.test.ui.tree.TreeFolder.prototype.tearDown.base.call(this);

        this.__tree.destroy();

        this.__root.destroy();

        this.__aa.destroy();

        this.__ab.destroy();
      }
    }
  });
  qx.test.ui.tree.TreeFolder.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "construct": true,
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.test.ui.list.MAssert": {
        "require": true
      },
      "qx.core.Object": {
        "construct": true
      },
      "qx.data.marshal.MEventBubbling": {},
      "qx.data.Array": {
        "construct": true
      },
      "qx.core.ObjectRegistry": {},
      "qx.ui.tree.VirtualTree": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.ui.tree.virtual.Leaf)
   * @ignore(qx.test.ui.tree.virtual.Node)
   */
  qx.Class.define("qx.test.ui.tree.virtual.AbstractTreeTest", {
    type: "abstract",
    extend: qx.test.ui.LayoutTestCase,
    include: [qx.dev.unit.MMock, qx.test.ui.list.MAssert],
    construct: function construct() {
      qx.test.ui.LayoutTestCase.constructor.call(this);
      qx.Class.define("qx.test.ui.tree.virtual.Leaf", {
        extend: qx.core.Object,
        include: qx.data.marshal.MEventBubbling,
        construct: function construct(name) {
          qx.core.Object.constructor.call(this);
          this.setName(name);
        },
        properties: {
          name: {
            check: "String",
            event: "changeName",
            apply: "_applyEventPropagation",
            nullable: true
          }
        },
        members: {
          toString: function toString() {
            return this.getName();
          },
          equals: function equals(item) {
            return this.getName() === item.getName();
          }
        }
      });
      qx.Class.define("qx.test.ui.tree.virtual.Node", {
        extend: qx.test.ui.tree.virtual.Leaf,
        construct: function construct(name, children) {
          qx.test.ui.tree.virtual.Leaf.constructor.call(this, name);

          if (children == null) {
            children = new qx.data.Array();
          }

          this.setChildren(children);
        },
        properties: {
          children: {
            check: "qx.data.Array",
            event: "changeChildren",
            apply: "_applyEventPropagation",
            nullable: true
          }
        },
        destruct: function destruct() {
          if (!qx.core.ObjectRegistry.inShutDown) {
            var children = this.getChildren();

            for (var i = 0; i < children.getLength(); i++) {
              children.getItem(i).dispose();
            }

            children.dispose();
            this.setChildren(null);
          }
        }
      });
    },
    members: {
      tree: null,
      setUp: function setUp() {
        qx.test.ui.tree.virtual.AbstractTreeTest.prototype.setUp.base.call(this);
        this.tree = new qx.ui.tree.VirtualTree();
        this.getRoot().add(this.tree);
      },
      tearDown: function tearDown() {
        qx.test.ui.tree.virtual.AbstractTreeTest.prototype.tearDown.base.call(this);
        this.tree.dispose();
        this.tree = null;

        if (this.model != null) {
          this.model.dispose();
          this.model = null;
        }
      },
      createModel: function createModel(level) {
        var root = new qx.test.ui.tree.virtual.Node("Root node");

        this._createNodes(root, level);

        return root;
      },
      createModelAndSetModel: function createModelAndSetModel(level) {
        this.model = this.createModel(level);
        this.tree.setLabelPath("name");
        this.tree.setChildProperty("children");
        this.tree.setModel(this.model);
        return this.model;
      },
      getVisibleItemsFrom: function getVisibleItemsFrom(parent, openNodes) {
        var expected = [];

        if (parent.getChildren() != null) {
          for (var i = 0; i < parent.getChildren().getLength(); i++) {
            var child = parent.getChildren().getItem(i);
            expected.push(child);

            if (openNodes.indexOf(child) > -1) {
              var otherExpected = this.getVisibleItemsFrom(child, openNodes);
              expected = expected.concat(otherExpected);
            }
          }
        }

        return expected;
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS TO CREATE A TREE STRUCTURE
      ---------------------------------------------------------------------------
      */
      _createNodes: function _createNodes(parent, level) {
        if (level > 0) {
          for (var i = 0; i < 5; i++) {
            var item = new qx.test.ui.tree.virtual.Node("Node " + this.__getPrefix(parent) + i);
            parent.getChildren().push(item);

            this._createNodes(item, level - 1);

            this._createLeafs(item);
          }
        }
      },
      _createLeafs: function _createLeafs(parent) {
        for (var i = 0; i < 5; i++) {
          var child = new qx.test.ui.tree.virtual.Leaf("Leaf " + this.__getPrefix(parent) + i);
          parent.getChildren().push(child);
        }
      },
      __getPrefix: function __getPrefix(item) {
        var name = item.getName();
        var prefix = "";

        if (name.startsWith("Node")) {
          prefix = name.substr(5, name.length - 5) + ".";
        }

        return prefix;
      }
    },
    destruct: function destruct() {
      if (qx.Class.isDefined("qx.test.ui.tree.virtual.Leaf")) {
        qx.Class.undefine("qx.test.ui.tree.virtual.Leaf");
      }

      if (qx.Class.isDefined("qx.test.ui.tree.virtual.Node")) {
        qx.Class.undefine("qx.test.ui.tree.virtual.Node");
      }
    }
  });
  qx.test.ui.tree.virtual.AbstractTreeTest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Interface describes the methods which the {@link qx.ui.tree.provider.WidgetProvider}
   * uses for communication.
   */
  qx.Interface.define("qx.ui.tree.core.IVirtualTree", {
    members: {
      /**
       * Return whether top level items should have an open/close button. The top
       * level item item is normally the root item, but when the root is hidden,
       * the root children are the top level items.
       *
       * @return {Boolean} Returns <code>true</code> when top level items should
       *   show open/close buttons, <code>false</code> otherwise.
       */
      isShowTopLevelOpenCloseIcons: function isShowTopLevelOpenCloseIcons() {},

      /**
       * Returns the internal data structure. The Array index is the row and the
       * value is the model item.
       *
       * @internal
       * @return {qx.data.Array} The internal data structure.
       */
      getLookupTable: function getLookupTable() {},

      /**
       * Returns if the passed item is a note or a leaf.
       *
       * @internal
       * @param item {qx.core.Object} Item to check.
       * @return {Boolean} <code>True</code> when item is a node,
       *   </code>false</code> when item is a leaf.
       */
      isNode: function isNode(item) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(item, qx.core.Object);
      },

      /**
       * Return whether the node is opened or closed.
       *
       * @param node {qx.core.Object} Node to check.
       * @return {Boolean} Returns <code>true</code> when the node is opened,
       *   <code>false</code> otherwise.
       */
      isNodeOpen: function isNodeOpen(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Returns the row's nesting level.
       *
       * @param row {Integer} The row to get the nesting level.
       * @return {Integer} The row's nesting level or <code>null</code>.
       */
      getLevel: function getLevel(row) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInteger(row);
      },

      /**
       * Return whether the node has visible children or not.
       *
       * @internal
       * @param node {qx.core.Object} Node to check.
       * @return {Boolean} <code>True</code> when the node has visible children,
       *   <code>false</code> otherwise.
       */
      hasChildren: function hasChildren(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Opens the passed node.
       *
       * @param node {qx.core.Object} Node to open.
       */
      openNode: function openNode(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Opens the passed node without scrolling selected item into view.
       *
       * @param node {qx.core.Object} Node to open.
       */
      openNodeWithoutScrolling: function openNodeWithoutScrolling(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Closes the passed node.
       *
       * @param node {qx.core.Object} Node to close.
       */
      closeNode: function closeNode(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Closes the passed node without scrolling selected item into view.
       *
       * @param node {qx.core.Object} Node to close.
       */
      closeNodeWithoutScrolling: function closeNodeWithoutScrolling(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Returns the current selection.
       *
       * @return {qx.data.Array} The current selected elements.
       */
      getSelection: function getSelection() {}
    }
  });
  qx.ui.tree.core.IVirtualTree.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.core.Scroller": {
        "construct": true,
        "require": true
      },
      "qx.ui.tree.core.IVirtualTree": {
        "require": true
      },
      "qx.data.controller.ISelection": {
        "require": true
      },
      "qx.ui.virtual.selection.MModel": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.lang.Array": {},
      "qx.ui.tree.core.OpenCloseController": {},
      "qx.data.Array": {},
      "qx.ui.tree.provider.WidgetProvider": {},
      "qx.ui.tree.core.Util": {},
      "qx.data.marshal.MEventBubbling": {},
      "qx.data.SingleValueBinding": {},
      "qx.util.DeferredCall": {},
      "qx.ui.core.queue.Widget": {},
      "qx.util.Delegate": {},
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /*
   * Virtual tree implementation.
   *
   * The virtual tree can be used to render node and leafs. Nodes and leafs are
   * both items for a tree. The difference between a node and a leaf is that a
   * node has child items, but a leaf not.
   *
   * With the {@link qx.ui.tree.core.IVirtualTreeDelegate} interface it is possible
   * to configure the tree's behavior (item renderer configuration, etc.).
   *
   * Here's an example of how to use the widget, including using a model
   * property to open/close branches. See the two timers at the end. The first
   * one opens all branches after two seconds; the second cleans up the tree
   * after five seconds.
   *
   * <pre class="javascript">
   *   var nodes = 
   *   [
   *     {
   *       name : "Root",
   *       open : false,
   *       children :
   *       [
   *         {
   *           name : "Branch 1",
   *           open : false,
   *           children :
   *           [
   *             {
   *               name : "Leaf 1.1"
   *             },
   *             {
   *               name : "Leaf 1.2"
   *             },
   *             {
   *               name : "Branch 1.3",
   *               open : false,
   *               children :
   *               [
   *                 {
   *                   name : "Branch 1.3.1",
   *                   open : false,
   *                   children :
   *                   [
   *                     {
   *                       name : "Leaf 1.3.1.1"
   *                     }
   *                   ]
   *                 }
   *               ]
   *             }
   *           ]
   *         }
   *       ]
   *     }
   *   ];
   *
   *   // convert the raw nodes to qooxdoo objects
   *   nodes = qx.data.marshal.Json.createModel(nodes, true);
   *
   *   // create the tree and synchronize the model property 'open'
   *   // to nodes being open
   *   var tree =
   *     new qx.ui.tree.VirtualTree(
   *       nodes.getItem(0), "name", "children", "open").set({
   *         width : 200,
   *         height : 400
   *       });
   *
   *   //log selection changes
   *   tree.getSelection().addListener("change", function(e) {
   *     this.debug("Selection: " + tree.getSelection().getItem(0).getName());
   *   }, this);
   *
   *   tree.set(
   *     {
   *       width : 200,
   *       height : 400,
   *       showTopLevelOpenCloseIcons : true
   *     });
   *
   *   var doc = this.getRoot();
   *   doc.add(tree,
   *   {
   *     left : 100,
   *     top  : 50
   *   });
   *
   *   // After two seconds, open up all branches by setting their open
   *   // property to true.
   *   qx.event.Timer.once(
   *     function()
   *     {
   *       ;(function allOpen(root)
   *         {
   *           if (root.setOpen)     root.setOpen(true);
   *           if (root.getChildren) root.getChildren().forEach(allOpen);
   *         })(nodes.getItem(0));
   *     },
   *     this,
   *     2000);
   *
   *   // After five seconds, remove and dispose the tree.
   *   qx.event.Timer.once(
   *     function()
   *     {
   *       doc.remove(tree);
   *       tree.dispose();
   *       console.warn("All cleaned up.");
   *     },
   *     this,
   *     5000);
   * </pre>
   */
  qx.Class.define("qx.ui.tree.VirtualTree", {
    extend: qx.ui.virtual.core.Scroller,
    implement: [qx.ui.tree.core.IVirtualTree, qx.data.controller.ISelection],
    include: [qx.ui.virtual.selection.MModel, qx.ui.core.MContentPadding],

    /**
     * @param rootModel {qx.core.Object?null} The model structure representing
     *   the root of the tree, for more details have a look at the 'model'
     *   property.
     * @param labelPath {String?null} The name of the label property, for more
     *   details have a look at the 'labelPath' property.
     * @param childProperty {String?null} The name of the child property, for
     *   more details have a look at the 'childProperty' property.
     * @param openProperty {String|null} the name of the model property which
     *   represents the open state of a branch. If this value is provided, so, 
     *   too, must be rootModel.
     */
    construct: function construct(rootModel, labelPath, childProperty, openProperty) {
      qx.ui.virtual.core.Scroller.constructor.call(this, 0, 1, 20, 100);

      this._init();

      if (labelPath != null) {
        this.setLabelPath(labelPath);
      }

      if (childProperty != null) {
        this.setChildProperty(childProperty);
      }

      if (rootModel != null) {
        this.initModel(rootModel);
      }

      this.initItemHeight();
      this.initOpenMode();
      this.addListener("keypress", this._onKeyPress, this); // If an open property and root model are provided, start up the open-close controller.

      if (openProperty && rootModel) {
        this.openViaModelChanges(openProperty);
      }
    },
    events: {
      /**
       * Fired when a node is opened.
       */
      open: "qx.event.type.Data",

      /**
       * Fired when a node is closed.
       */
      close: "qx.event.type.Data"
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "virtual-tree"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 100
      },
      // overridden
      height: {
        refine: true,
        init: 200
      },

      /** Default item height. */
      itemHeight: {
        check: "Integer",
        init: 25,
        apply: "_applyRowHeight",
        themeable: true
      },

      /**
      * Control whether tap or double tap should open or close the tapped
      * item.
      */
      openMode: {
        check: ["tap", "dbltap", "none"],
        init: "dbltap",
        apply: "_applyOpenMode",
        event: "changeOpenMode",
        themeable: true
      },

      /**
       * Hides *only* the root node, not the node's children when the property is
       * set to <code>true</code>.
       */
      hideRoot: {
        check: "Boolean",
        init: false,
        apply: "_applyHideRoot"
      },

      /**
       * Whether top level items should have an open/close button. The top level
       * item item is normally the root item, but when the root is hidden, the
       * root children are the top level items.
       */
      showTopLevelOpenCloseIcons: {
        check: "Boolean",
        init: false,
        apply: "_applyShowTopLevelOpenCloseIcons"
      },

      /**
       * Configures the tree to show also the leafs. When the property is set to
       * <code>false</code> *only* the nodes are shown.
       */
      showLeafs: {
        check: "Boolean",
        init: true,
        apply: "_applyShowLeafs"
      },

      /**
       * The name of the property, where the children are stored in the model.
       * Instead of the {@link #labelPath} must the child property a direct
       * property form the model instance.
       */
      childProperty: {
        check: "String",
        apply: "_applyChildProperty",
        nullable: true
      },

      /**
       * The name of the property, where the value for the tree folders label
       * is stored in the model classes.
       */
      labelPath: {
        check: "String",
        apply: "_applyLabelPath",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * shown as an icon.
       */
      iconPath: {
        check: "String",
        apply: "_applyIconPath",
        nullable: true
      },

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      labelOptions: {
        apply: "_applyLabelOptions",
        nullable: true
      },

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      iconOptions: {
        apply: "_applyIconOptions",
        nullable: true
      },

      /**
       * The model containing the data (nodes and/or leafs) which should be shown
       * in the tree.
       */
      model: {
        check: "qx.core.Object",
        apply: "_applyModel",
        event: "changeModel",
        nullable: true,
        deferredInit: true
      },

      /**
       * Delegation object, which can have one or more functions defined by the
       * {@link qx.ui.tree.core.IVirtualTreeDelegate} interface.
       */
      delegate: {
        event: "changeDelegate",
        apply: "_applyDelegate",
        init: null,
        nullable: true
      }
    },
    members: {
      /** @type {qx.ui.tree.provider.WidgetProvider} Provider for widget rendering. */
      _provider: null,

      /** @type {qx.ui.virtual.layer.Abstract} Layer which contains the items. */
      _layer: null,

      /**
       * @type {qx.data.Array} The internal lookup table data structure to get the model item
       * from a row.
       */
      __lookupTable: null,

      /** @type {Array} HashMap which contains all open nodes. */
      __openNodes: null,

      /**
       * @type {Array} The internal data structure to get the nesting level from a
       * row.
       */
      __nestingLevel: null,

      /**
       * @type {qx.util.DeferredCall} Adds this instance to the widget queue on a
       * deferred call.
       */
      __deferredCall: null,

      /** @type {Integer} Holds the max item width from a rendered widget. */
      _itemWidth: 0,

      /** @type {Array} internal parent chain form the last selected node */
      __parentChain: null,

      /** 
       * @type {String|null} the name of the model property which represents the
       *   open state of a branch.
       */
      __openProperty: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */
      // overridden
      syncWidget: function syncWidget(jobs) {
        var firstRow = this._layer.getFirstRow();

        var rowSize = this._layer.getRowSizes().length;

        for (var row = firstRow; row < firstRow + rowSize; row++) {
          var widget = this._layer.getRenderedCellWidget(row, 0);

          if (widget != null) {
            this._itemWidth = Math.max(this._itemWidth, widget.getSizeHint().width);
          }
        }

        var paneWidth = this.getPane().getInnerSize().width;
        this.getPane().getColumnConfig().setItemSize(0, Math.max(this._itemWidth, paneWidth));
      },
      // Interface implementation
      openNode: function openNode(node) {
        this.__openNode(node);

        this.buildLookupTable();
      },
      // Interface implementation
      openNodeWithoutScrolling: function openNodeWithoutScrolling(node) {
        var autoscroll = this.getAutoScrollIntoView(); // suspend automatically scrolling selection into view

        this.setAutoScrollIntoView(false);
        this.openNode(node); // re set to original value

        this.setAutoScrollIntoView(autoscroll);
      },

      /**
       * Trigger a rebuild from the internal data structure.
       */
      refresh: function refresh() {
        this.buildLookupTable();
      },

      /**
       * Opens the passed node and all his parents. *Note!* The algorithm
       * implements a depth-first search with a complexity: <code>O(n)</code> and
       * <code>n</code> are all model items.
       *
       * @param node {qx.core.Object} Node to open.
       */
      openNodeAndParents: function openNodeAndParents(node) {
        this.__openNodeAndAllParents(this.getModel(), node);

        this.buildLookupTable();
      },
      // Interface implementation
      closeNode: function closeNode(node) {
        if (this.__openNodes.includes(node)) {
          qx.lang.Array.remove(this.__openNodes, node);
          this.fireDataEvent("close", node);
          this.buildLookupTable();
        }
      },
      // Interface implementation
      closeNodeWithoutScrolling: function closeNodeWithoutScrolling(node) {
        var autoscroll = this.getAutoScrollIntoView(); // suspend automatically scrolling selection into view

        this.setAutoScrollIntoView(false);
        this.closeNode(node); // re set to original value

        this.setAutoScrollIntoView(autoscroll);
      },
      // Interface implementation
      isNodeOpen: function isNodeOpen(node) {
        return this.__openNodes.includes(node);
      },

      /**
       * Open and close branches via changes to a property in the model.
       * 
       * @param openProperty {String|null} 
       *   The name of the open property, which determines the open state of a
       *   branch in the tree. If null, turn off opening and closing branches
       *   via changes to the model.
       */
      openViaModelChanges: function openViaModelChanges(openProperty) {
        // Save the open property
        this.__openProperty = openProperty; // if no name is provided, just remove any prior open-close controller

        if (!openProperty) {
          if (this._openCloseController) {
            this._openCloseController.dispose();

            this._openCloseController = null;
          }

          return;
        } // we have a property name, so create controller


        this._openCloseController = new qx.ui.tree.core.OpenCloseController(this, this.getModel(), openProperty);
      },

      /**
       * Getter for the open property
       */
      getOpenProperty: function getOpenProperty() {
        return this.__openProperty;
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */

      /**
       * Initializes the virtual tree.
       */
      _init: function _init() {
        this.__lookupTable = new qx.data.Array();
        this.__openNodes = [];
        this.__nestingLevel = [];

        this._initLayer();
      },

      /**
       * Initializes the virtual tree layer.
       */
      _initLayer: function _initLayer() {
        this._provider = new qx.ui.tree.provider.WidgetProvider(this);
        this._layer = this._provider.createLayer();

        this._layer.addListener("updated", this._onUpdated, this);

        this.getPane().addLayer(this._layer);
        this.getPane().addListenerOnce("resize", function (e) {
          // apply width to pane on first rendering pass
          // to avoid visible flickering
          this.getPane().getColumnConfig().setItemSize(0, e.getData().width);
        }, this);
      },
      // Interface implementation
      getLookupTable: function getLookupTable() {
        return this.__lookupTable;
      },
      // Interface implementation
      isShowTopLevelOpenCloseIcons: function isShowTopLevelOpenCloseIcons() {
        return true;
      },

      /**
       * Performs a lookup from model index to row.
       *
       * @param index {Number} The index to look at.
       * @return {Number} The row or <code>-1</code>
       *  if the index is not a model index.
       */
      _reverseLookup: function _reverseLookup(index) {
        return index;
      },

      /**
       * Returns the model data for the given row.
       *
       * @param row {Integer} row to get data for.
       * @return {var|null} the row's model data.
       */
      _getDataFromRow: function _getDataFromRow(row) {
        return this.__lookupTable.getItem(row);
      },

      /**
       * Returns the selectable model items.
       *
       * @return {qx.data.Array} The selectable items.
       */
      _getSelectables: function _getSelectables() {
        return this.__lookupTable;
      },

      /**
       * Returns all open nodes.
       *
       * @internal
       * @return {Array} All open nodes.
       */
      getOpenNodes: function getOpenNodes() {
        return this.__openNodes;
      },
      // Interface implementation
      isNode: function isNode(item) {
        return qx.ui.tree.core.Util.isNode(item, this.getChildProperty());
      },
      // Interface implementation
      getLevel: function getLevel(row) {
        return this.__nestingLevel[row];
      },
      // Interface implementation
      hasChildren: function hasChildren(node) {
        return qx.ui.tree.core.Util.hasChildren(node, this.getChildProperty(), !this.isShowLeafs());
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getPane();
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY METHODS
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyRowHeight: function _applyRowHeight(value, old) {
        this.getPane().getRowConfig().setDefaultItemSize(value);
      },
      // property apply
      _applyOpenMode: function _applyOpenMode(value, old) {
        var pane = this.getPane(); //"tap", "dbltap", "none"

        if (value === "dbltap") {
          pane.addListener("cellDbltap", this._onOpen, this);
        } else if (value === "tap") {
          pane.addListener("cellTap", this._onOpen, this);
        }

        if (old === "dbltap") {
          pane.removeListener("cellDbltap", this._onOpen, this);
        } else if (old === "tap") {
          pane.removeListener("cellTap", this._onOpen, this);
        }
      },
      // property apply
      _applyHideRoot: function _applyHideRoot(value, old) {
        this.buildLookupTable();
      },
      // property apply
      _applyShowTopLevelOpenCloseIcons: function _applyShowTopLevelOpenCloseIcons(value, old) {
        // force rebuild of the lookup table
        // fixes https://github.com/qooxdoo/qooxdoo/issues/9128
        this.getLookupTable().removeAll();
        this.buildLookupTable();
      },
      // property apply
      _applyShowLeafs: function _applyShowLeafs(value, old) {
        // force rebuild of the lookup table
        // fixes https://github.com/qooxdoo/qooxdoo/issues/9128
        this.getLookupTable().removeAll();
        this.buildLookupTable();
      },
      // property apply
      _applyChildProperty: function _applyChildProperty(value, old) {
        this._provider.setChildProperty(value);
      },
      // property apply
      _applyLabelPath: function _applyLabelPath(value, old) {
        this._provider.setLabelPath(value);
      },
      // property apply
      _applyIconPath: function _applyIconPath(value, old) {
        this._provider.setIconPath(value);
      },
      // property apply
      _applyLabelOptions: function _applyLabelOptions(value, old) {
        this._provider.setLabelOptions(value);
      },
      // property apply
      _applyIconOptions: function _applyIconOptions(value, old) {
        this._provider.setIconOptions(value);
      },
      // property apply
      _applyModel: function _applyModel(value, old) {
        this.__openNodes = [];

        if (value != null) {
          {
            if (!qx.Class.hasMixin(value.constructor, qx.data.marshal.MEventBubbling)) {
              this.warn("The model item doesn't support the Mixin 'qx.data.marshal.MEventBubbling'. Therefore the tree can not update the view automatically on model changes.");
            }
          }
          value.addListener("changeBubble", this._onChangeBubble, this);

          this.__openNode(value);
        } // If the model changes, an existing OpenCloseController is no longer
        // valid, so dispose it. The user should call openViaModelChanges again.


        if (this._openCloseController) {
          this._openCloseController.dispose();

          this._openCloseController = null;
        }

        if (old != null) {
          old.removeListener("changeBubble", this._onChangeBubble, this);
        }

        this.__applyModelChanges();
      },
      // property apply
      _applyDelegate: function _applyDelegate(value, old) {
        this._provider.setDelegate(value);

        this.buildLookupTable();
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the changeBubble event. The handler rebuild the lookup
       * table when the child structure changed.
       *
       * @param event {qx.event.type.Data} The data event.
       */
      _onChangeBubble: function _onChangeBubble(event) {
        var data = event.getData();
        var propertyName = data.name;
        var index = propertyName.lastIndexOf(".");

        if (index != -1) {
          propertyName = propertyName.substr(index + 1, propertyName.length);
        } // only continue when the effected property is the child property


        if (propertyName.startsWith(this.getChildProperty())) {
          var item = data.item;

          if (qx.Class.isSubClassOf(item.constructor, qx.data.Array)) {
            if (index === -1) {
              item = this.getModel();
            } else {
              var propertyChain = data.name.substr(0, index);
              item = qx.data.SingleValueBinding.resolvePropertyChain(this.getModel(), propertyChain);
            }
          }

          if (this.__lookupTable.indexOf(item) != -1) {
            this.__applyModelChanges();
          }
        }
      },

      /**
       * Event handler for the update event.
       *
       * @param event {qx.event.type.Event} The event.
       */
      _onUpdated: function _onUpdated(event) {
        if (this.__deferredCall == null) {
          this.__deferredCall = new qx.util.DeferredCall(function () {
            qx.ui.core.queue.Widget.add(this);
          }, this);
        }

        this.__deferredCall.schedule();
      },

      /**
       * Event handler to open/close tapped nodes.
       *
       * @param event {qx.ui.virtual.core.CellEvent} The cell tap event.
       */
      _onOpen: function _onOpen(event) {
        var row = event.getRow();

        var item = this.__lookupTable.getItem(row);

        if (this.isNode(item)) {
          if (this.isNodeOpen(item)) {
            this.closeNode(item);
          } else {
            this.openNode(item);
          }
        }
      },

      /**
       * Event handler for key press events. Open and close the current selected
       * item on key left and right press. Jump to parent on key left if already
       * closed.
       *
       * @param e {qx.event.type.KeySequence} key event.
       */
      _onKeyPress: function _onKeyPress(e) {
        var selection = this.getSelection();

        if (selection.getLength() > 0) {
          var item = selection.getItem(0);
          var isNode = this.isNode(item);

          switch (e.getKeyIdentifier()) {
            case "Left":
              if (isNode && this.isNodeOpen(item)) {
                this.closeNode(item);
              } else {
                var parent = this.getParent(item);

                if (parent != null) {
                  selection.splice(0, 1, parent);
                }
              }

              break;

            case "Right":
              if (isNode && !this.isNodeOpen(item)) {
                this.openNode(item);
              } else {
                if (isNode) {
                  var children = item.get(this.getChildProperty());

                  if (children != null && children.getLength() > 0) {
                    selection.splice(0, 1, children.getItem(0));
                  }
                }
              }

              break;

            case "Enter":
            case "Space":
              if (!isNode) {
                return;
              }

              if (this.isNodeOpen(item)) {
                this.closeNode(item);
              } else {
                this.openNode(item);
              }

              break;
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION HOOK METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Hook method which is called from the {@link qx.ui.virtual.selection.MModel}.
       * The hook method sets the first visible parent not as new selection when
       * the current selection is empty and the selection mode is one selection.
       *
       * @param newSelection {Array} The newSelection which will be set to the selection manager.
       */
      _beforeApplySelection: function _beforeApplySelection(newSelection) {
        if (newSelection.length === 0 && this.getSelectionMode() === "one") {
          var visibleParent = this.__getVisibleParent();

          var row = this.getLookupTable().indexOf(visibleParent);

          if (row >= 0) {
            newSelection.push(row);
          }
        }
      },

      /**
       * Hook method which is called from the {@link qx.ui.virtual.selection.MModel}.
       * The hook method builds the parent chain form the current selected item.
       */
      _afterApplySelection: function _afterApplySelection() {
        var selection = this.getSelection();

        if (selection.getLength() > 0 && this.getSelectionMode() === "one") {
          this.__buildParentChain(selection.getItem(0));
        } else {
          this.__parentChain = [];
        }
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Helper method to apply model changes. Normally build the lookup table and
       * apply the default selection.
       */
      __applyModelChanges: function __applyModelChanges() {
        this.buildLookupTable();

        this._applyDefaultSelection();
      },

      /**
       * Helper method to build the internal data structure.
       *
       * @internal
       */
      buildLookupTable: function buildLookupTable() {
        if (this.getModel() != null && (this.getChildProperty() == null || this.getLabelPath() == null)) {
          throw new Error("Could not build tree, because 'childProperty' and/or 'labelPath' is 'null'!");
        }

        this._itemWidth = 0;
        var lookupTable = [];
        this.__nestingLevel = [];
        var nestedLevel = -1;
        var root = this.getModel();

        if (root != null) {
          if (!this.isHideRoot()) {
            nestedLevel++;
            lookupTable.push(root);

            this.__nestingLevel.push(nestedLevel);
          }

          if (this.isNodeOpen(root)) {
            var visibleChildren = this.__getVisibleChildrenFrom(root, nestedLevel);

            lookupTable = lookupTable.concat(visibleChildren);
          }
        }

        if (!qx.lang.Array.equals(this.__lookupTable.toArray(), lookupTable)) {
          this._provider.removeBindings();

          this.__lookupTable.removeAll();

          this.__lookupTable.append(lookupTable);

          this.__updateRowCount();

          this._updateSelection();
        }
      },

      /**
       * Helper method to get all visible children form the passed parent node.
       * The algorithm implements a depth-first search with a complexity:
       * <code>O(n)</code> and <code>n</code> are all visible items.
       *
       * @param node {qx.core.Object} The start node to start search.
       * @param nestedLevel {Integer} The nested level from the start node.
       * @return {Array} All visible children form the parent.
       */
      __getVisibleChildrenFrom: function __getVisibleChildrenFrom(node, nestedLevel) {
        var visible = [];
        nestedLevel++;

        if (!this.isNode(node)) {
          return visible;
        }

        var children = node.get(this.getChildProperty());

        if (children == null) {
          return visible;
        } // clone children to keep original model unmodified


        children = children.copy();
        var delegate = this.getDelegate();
        var filter = qx.util.Delegate.getMethod(delegate, "filter");
        var sorter = qx.util.Delegate.getMethod(delegate, "sorter");

        if (sorter != null) {
          children.sort(sorter);
        }

        for (var i = 0; i < children.getLength(); i++) {
          var child = children.getItem(i);

          if (filter && !filter(child)) {
            continue;
          }

          if (this.isNode(child)) {
            this.__nestingLevel.push(nestedLevel);

            visible.push(child);

            if (this.isNodeOpen(child)) {
              var visibleChildren = this.__getVisibleChildrenFrom(child, nestedLevel);

              visible = visible.concat(visibleChildren);
            }
          } else {
            if (this.isShowLeafs()) {
              this.__nestingLevel.push(nestedLevel);

              visible.push(child);
            }
          }
        } // dispose children clone


        children.dispose();
        return visible;
      },

      /**
       * Helper method to set the node to the open nodes data structure when it
       * is not included.
       *
       * @param node {qx.core.Object} Node to set to open nodes.
       */
      __openNode: function __openNode(node) {
        if (!this.__openNodes.includes(node)) {
          this.__openNodes.push(node);

          this.fireDataEvent("open", node);
        }
      },

      /**
       * Helper method to set the target node and all his parents to the open
       * nodes data structure. The algorithm implements a depth-first search with
       * a complexity: <code>O(n)</code> and <code>n</code> are all model items.
       *
       * @param startNode {qx.core.Object} Start (root) node to search.
       * @param targetNode {qx.core.Object} Target node to open (and his parents).
       * @return {Boolean} <code>True</code> when the targetNode and his
       *  parents could opened, <code>false</code> otherwise.
       */
      __openNodeAndAllParents: function __openNodeAndAllParents(startNode, targetNode) {
        if (startNode === targetNode) {
          this.__openNode(targetNode);

          return true;
        }

        if (!this.isNode(startNode)) {
          return false;
        }

        var children = startNode.get(this.getChildProperty());

        if (children == null) {
          return false;
        }

        for (var i = 0; i < children.getLength(); i++) {
          var child = children.getItem(i);

          var result = this.__openNodeAndAllParents(child, targetNode);

          if (result === true) {
            this.__openNode(child);

            return true;
          }
        }

        return false;
      },

      /**
       * Helper method to update the row count.
       */
      __updateRowCount: function __updateRowCount() {
        this.getPane().getRowConfig().setItemCount(this.__lookupTable.getLength());
        this.getPane().fullUpdate();
      },

      /**
       * Helper method to get the parent node. Node! This only works with leaf and
       * nodes which are in the internal lookup table.
       *
       * @param item {qx.core.Object} Node or leaf to get parent.
       * @return {qx.core.Object|null} The parent note or <code>null</code> when
       *   no parent found.
       *
       * @internal
       */
      getParent: function getParent(item) {
        var index = this.__lookupTable.indexOf(item);

        if (index < 0) {
          return null;
        }

        var level = this.__nestingLevel[index];

        while (index > 0) {
          index--;
          var levelBefore = this.__nestingLevel[index];

          if (levelBefore < level) {
            return this.__lookupTable.getItem(index);
          }
        }

        return null;
      },

      /**
       * Builds the parent chain form the passed item.
       *
       * @param item {var} Item to build parent chain.
       */
      __buildParentChain: function __buildParentChain(item) {
        this.__parentChain = [];
        var parent = this.getParent(item);

        while (parent != null) {
          this.__parentChain.unshift(parent);

          parent = this.getParent(parent);
        }
      },

      /**
       * Return the first visible parent node from the last selected node.
       *
       * @return {var} The first visible node.
       */
      __getVisibleParent: function __getVisibleParent() {
        if (this.__parentChain == null) {
          return this.getModel();
        }

        var lookupTable = this.getLookupTable();

        var parent = this.__parentChain.pop();

        while (parent != null) {
          if (lookupTable.contains(parent)) {
            return parent;
          }

          parent = this.__parentChain.pop();
        }

        return this.getModel();
      }
    },
    destruct: function destruct() {
      if (this._openCloseController) {
        this._openCloseController.dispose();
      }

      var pane = this.getPane();

      if (pane != null) {
        if (pane.hasListener("cellDbltap")) {
          pane.removeListener("cellDbltap", this._onOpen, this);
        }

        if (pane.hasListener("cellTap")) {
          pane.removeListener("cellTap", this._onOpen, this);
        }
      }

      if (!qx.core.ObjectRegistry.inShutDown && this.__deferredCall != null) {
        this.__deferredCall.cancel();

        this.__deferredCall.dispose();
      }

      var model = this.getModel();

      if (model != null) {
        model.removeListener("changeBubble", this._onChangeBubble, this);
      }

      this._layer.removeListener("updated", this._onUpdated, this);

      this._layer.destroy();

      this._provider.dispose();

      this.__lookupTable.dispose();

      this._layer = this._provider = this.__lookupTable = this.__openNodes = this.__deferredCall = null;
    }
  });
  qx.ui.tree.VirtualTree.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "construct": true,
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Cajus Pollmeier
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Cajus Pollmeier
       * Derrell Lipman
  
  ************************************************************************ */

  /**
   * Because of the virtual nature of the VirtualTree, and the fact that
   * rendering occurs asynchronously, it is not a simple matter to bind a
   * property in the model that will open or close branches in the
   * tree. Instead, this controller listens to both the model and the tree, and
   * synchronizes the openness of branches in the tree.
   * 
   * To use this controller, simply instantiate it with the requisite
   * constructor arguments.
   */
  qx.Class.define("qx.ui.tree.core.OpenCloseController", {
    extend: qx.core.Object,

    /**
     * @param tree {qx.ui.tree.VirtualTree}
     *   The tree whose branch open or closed state is to be synchronized to a
     *   model property.
     * 
     * @param rootModel {qx.data.Array}
     *   The tree root model wherein a property is to be synchronized to the
     *   tree branches' open or closed states
     */
    construct: function construct(tree, rootModel) {
      var openProperty = tree.getOpenProperty();
      qx.core.Object.constructor.call(this); // Save the tree and initialize storage of listener IDs

      this._tree = tree;
      this._lids = []; // Sync tree nodes

      var sync = function (node) {
        if (qx.Class.hasProperty(node.constructor, "children")) {
          node.getChildren().forEach(sync);
        }

        if (qx.Class.hasProperty(node.constructor, openProperty)) {
          if (node.get(openProperty)) {
            tree.openNode(node);
          } else {
            tree.closeNode(node);
          }
        }
      }.bind(this);

      sync(rootModel); // Wire change listeners

      var lid = tree.addListener("open", this._onOpen, this);

      this._lids.push([tree, lid]);

      lid = tree.addListener("close", this._onClose, this);

      this._lids.push([tree, lid]);

      lid = rootModel.addListener("changeBubble", this._onChangeBubble, this);

      this._lids.push([rootModel, lid]);
    },
    members: {
      /** The tree which is synced to the model */
      _tree: null,

      /** Listener IDs that we manage */
      _lids: null,
      // event listener for "open" on the tree
      _onOpen: function _onOpen(ev) {
        ev.getData().set(this._tree.getOpenProperty(), true);
      },
      // event listener for "close" on the tree
      _onClose: function _onClose(ev) {
        ev.getData().set(this._tree.getOpenProperty(), false);
      },
      // event listener for model changes
      _onChangeBubble: function _onChangeBubble(ev) {
        var index;
        var item;
        var isOpen;
        var bubble = ev.getData(); // Extract the index of the current item

        index = bubble.name.replace(/.*\[([0-9]+)\]$/, "$1"); // Retrieve that indexed array item if it's an array; otherwise the item itself

        item = bubble.item.getItem ? bubble.item.getItem(index) : bubble.item; // If this item isn't being deleted and has an open property...

        if (item && qx.Class.hasProperty(item.constructor, this._tree.getOpenProperty())) {
          // ... then find out if this branch is open
          isOpen = item.get(this._tree.getOpenProperty()); // Open or close the tree branch as necessary

          if (isOpen && !this._tree.isNodeOpen(item)) {
            this._tree.openNode(item);
          } else if (!isOpen && this._tree.isNodeOpen(item)) {
            this._tree.closeNode(item);
          }
        } // Rebuild the internal lookup table


        this._tree.refresh();
      }
    },
    destruct: function destruct() {
      this._tree = null;

      this._lids.forEach(function (data) {
        data[0].removeListenerById(data[1]);
      });
    }
  });
  qx.ui.tree.core.OpenCloseController.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * This interface needs to implemented from all {@link qx.ui.tree.VirtualTree}
   * providers.
   *
   * @internal
   */
  qx.Interface.define("qx.ui.tree.provider.IVirtualTreeProvider", {
    members: {
      /**
       * Creates a layer for node and leaf rendering.
       *
       * @return {qx.ui.virtual.layer.Abstract} new layer.
       */
      createLayer: function createLayer() {},

      /**
       * Creates a renderer for rendering.
       *
       * @return {var} new node renderer.
       */
      createRenderer: function createRenderer() {},

      /**
       * Sets the name of the property, where the children are stored in the model.
       *
       * @param value {String} The child property name.
       */
      setChildProperty: function setChildProperty(value) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertString(value);
      },

      /**
       * Sets the name of the property, where the value for the tree folders label
       * is stored in the model classes.
       *
       * @param value {String} The label path.
       */
      setLabelPath: function setLabelPath(value) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertString(value);
      },

      /**
       * Styles a selected item.
       *
       * @param row {Integer} row to style.
       */
      styleSelectabled: function styleSelectabled(row) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInteger(row);
      },

      /**
       * Styles a not selected item.
       *
       * @param row {Integer} row to style.
       */
      styleUnselectabled: function styleUnselectabled(row) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInteger(row);
      },

      /**
       * Returns if the passed row can be selected or not.
       *
       * @param row {Integer} row to select.
       * @return {Boolean} <code>true</code> when the row can be selected,
       *    <code>false</code> otherwise.
       */
      isSelectable: function isSelectable(row) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInteger(row);
      }
    }
  });
  qx.ui.tree.provider.IVirtualTreeProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.data.SingleValueBinding": {},
      "qx.util.OOUtil": {},
      "qx.util.Delegate": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The mixin controls the binding between model and item.
   *
   * @internal
   */
  qx.Mixin.define("qx.ui.tree.core.MWidgetController", {
    construct: function construct() {
      this.__boundItems = [];
    },
    properties: {
      /**
       * The name of the property, where the value for the tree node/leaf label
       * is stored in the model classes.
       */
      labelPath: {
        check: "String",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * shown as an icon.
       */
      iconPath: {
        check: "String",
        nullable: true
      },

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      labelOptions: {
        nullable: true
      },

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      iconOptions: {
        nullable: true
      },

      /**
       * The name of the property, where the children are stored in the model.
       * Instead of the {@link #labelPath} must the child property a direct
       * property form the model instance.
       */
      childProperty: {
        check: "String",
        nullable: true
      },

      /**
       * Delegation object, which can have one or more functions defined by the
       * {@link qx.ui.tree.core.IVirtualTreeDelegate} interface.
       */
      delegate: {
        event: "changeDelegate",
        init: null,
        nullable: true
      }
    },
    members: {
      /** @type {Array} which contains the bounded items */
      __boundItems: null,

      /**
       * Helper-Method for binding the default properties from the model to the
       * target widget. The used default properties  depends on the passed item.
       *
       * This method should only be called in the {@link IVirtualTreeDelegate#bindItem}
       * function implemented by the {@link #delegate} property.
       *
       * @param item {qx.ui.core.Widget} The internally created and used node or
       *   leaf.
       * @param index {Integer} The index of the item (node or leaf).
       */
      bindDefaultProperties: function bindDefaultProperties(item, index) {
        // bind model first
        this.bindProperty("", "model", null, item, index);
        this.bindProperty(this.getLabelPath(), "label", this.getLabelOptions(), item, index);

        var bindPath = this.__getBindPath(index);

        var bindTarget = this._tree.getLookupTable();

        bindTarget = qx.data.SingleValueBinding.resolvePropertyChain(bindTarget, bindPath);

        if (qx.util.OOUtil.hasProperty(bindTarget.constructor, this.getChildProperty())) {
          this.bindProperty(this.getChildProperty() + ".length", "appearance", {
            converter: function converter() {
              return "virtual-tree-folder";
            }
          }, item, index);
        } else {
          item.setAppearance("virtual-tree-file");
        }

        if (this.getIconPath() != null) {
          this.bindProperty(this.getIconPath(), "icon", this.getIconOptions(), item, index);
        }
      },

      /**
       * Helper-Method for binding a given property from the model to the target
       * widget.
       *
       * This method should only be called in the {@link IVirtualTreeDelegate#bindItem}
       * function implemented by the {@link #delegate} property.
       *
       * @param sourcePath {String | null} The path to the property in the model.
       *   If you use an empty string, the whole model item will be bound.
       * @param targetProperty {String} The name of the property in the target widget.
       * @param options {Map | null} The options to use for the binding.
       * @param targetWidget {qx.ui.core.Widget} The target widget.
       * @param index {Integer} The index of the current binding.
       */
      bindProperty: function bindProperty(sourcePath, targetProperty, options, targetWidget, index) {
        var bindPath = this.__getBindPath(index, sourcePath);

        var bindTarget = this._tree.getLookupTable();

        var id = bindTarget.bind(bindPath, targetWidget, targetProperty, options);

        this.__addBinding(targetWidget, id);
      },

      /**
       * Helper-Method for binding a given property from the target widget to
       * the model.
       * This method should only be called in the
       * {@link qx.ui.tree.core.IVirtualTreeDelegate#bindItem} function implemented by the
       * {@link #delegate} property.
       *
       * @param targetPath {String | null} The path to the property in the model.
       * @param sourceProperty {String} The name of the property in the target.
       * @param options {Map | null} The options to use for the binding.
       * @param sourceWidget {qx.ui.core.Widget} The source widget.
       * @param index {Integer} The index of the current binding.
       */
      bindPropertyReverse: function bindPropertyReverse(targetPath, sourceProperty, options, sourceWidget, index) {
        var bindPath = this.__getBindPath(index, targetPath);

        var bindTarget = this._tree.getLookupTable();

        var id = sourceWidget.bind(sourceProperty, bindTarget, bindPath, options);

        this.__addBinding(sourceWidget, id);
      },

      /**
       * Remove all bindings from all bounded items.
       */
      removeBindings: function removeBindings() {
        while (this.__boundItems.length > 0) {
          var item = this.__boundItems.pop();

          this._removeBindingsFrom(item);
        }
      },

      /**
       * Sets up the binding for the given item and index.
       *
       * @param item {qx.ui.core.Widget} The internally created and used item.
       * @param index {Integer} The index of the item.
       */
      _bindItem: function _bindItem(item, index) {
        var bindItem = qx.util.Delegate.getMethod(this.getDelegate(), "bindItem");

        if (bindItem != null) {
          bindItem(this, item, index);
        } else {
          this.bindDefaultProperties(item, index);
        }
      },

      /**
       * Removes the binding of the given item.
       *
       * @param item {qx.ui.core.Widget} The item which the binding should be
       *   removed.
       */
      _removeBindingsFrom: function _removeBindingsFrom(item) {
        var bindings = this.__getBindings(item);

        while (bindings.length > 0) {
          var id = bindings.pop();

          try {
            this._tree.getLookupTable().removeBinding(id);
          } catch (e) {
            item.removeBinding(id);
          }
        }

        if (this.__boundItems.includes(item)) {
          qx.lang.Array.remove(this.__boundItems, item);
        }
      },

      /**
       * Helper method to create the path for binding.
       *
       * @param index {Integer} The index of the item.
       * @param path {String|null} The path to the property.
       * @return {String} The binding path
       */
      __getBindPath: function __getBindPath(index, path) {
        var bindPath = "[" + index + "]";

        if (path != null && path != "") {
          bindPath += "." + path;
        }

        return bindPath;
      },

      /**
       * Helper method to save the binding for the widget.
       *
       * @param widget {qx.ui.core.Widget} widget to save binding.
       * @param id {var} the id from the binding.
       */
      __addBinding: function __addBinding(widget, id) {
        var bindings = this.__getBindings(widget);

        if (!bindings.includes(id)) {
          bindings.push(id);
        }

        if (!this.__boundItems.includes(widget)) {
          this.__boundItems.push(widget);
        }
      },

      /**
       * Helper method which returns all bound id from the widget.
       *
       * @param widget {qx.ui.core.Widget} widget to get all binding.
       * @return {Array} all bound id's.
       */
      __getBindings: function __getBindings(widget) {
        var bindings = widget.getUserData("BindingIds");

        if (bindings == null) {
          bindings = [];
          widget.setUserData("BindingIds", bindings);
        }

        return bindings;
      }
    },
    destruct: function destruct() {
      this.__boundItems = null;
    }
  });
  qx.ui.tree.core.MWidgetController.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.IWidgetCellProvider": {
        "require": true
      },
      "qx.ui.tree.provider.IVirtualTreeProvider": {
        "require": true
      },
      "qx.ui.tree.core.MWidgetController": {
        "require": true
      },
      "qx.ui.core.queue.Widget": {},
      "qx.ui.virtual.layer.WidgetCell": {},
      "qx.util.Delegate": {},
      "qx.ui.tree.VirtualTreeItem": {},
      "qx.ui.virtual.cell.WidgetCell": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The provider implements the {@link qx.ui.virtual.core.IWidgetCellProvider}
   * API, which can be used as delegate for the widget cell rendering and it
   * provides a API to bind the model with the rendered item.
   *
   * @internal
   */
  qx.Class.define("qx.ui.tree.provider.WidgetProvider", {
    extend: qx.core.Object,
    implement: [qx.ui.virtual.core.IWidgetCellProvider, qx.ui.tree.provider.IVirtualTreeProvider],
    include: [qx.ui.tree.core.MWidgetController],

    /**
     * @param tree {qx.ui.tree.VirtualTree} tree to provide.
     */
    construct: function construct(tree) {
      qx.core.Object.constructor.call(this);
      this._tree = tree;
      this.addListener("changeDelegate", this._onChangeDelegate, this);

      this._onChangeDelegate();
    },
    members: {
      /** @type {qx.ui.tree.VirtualTree} tree to provide. */
      _tree: null,

      /** @type {qx.ui.virtual.cell.WidgetCell} the used item renderer. */
      _renderer: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */
      // interface implementation
      getCellWidget: function getCellWidget(row, column) {
        var item = this._tree.getLookupTable().getItem(row);

        var hasChildren = false;

        if (this._tree.isNode(item)) {
          hasChildren = this._tree.hasChildren(item);
        }

        var widget = this._renderer.getCellWidget();

        widget.setOpen(hasChildren && this._tree.isNodeOpen(item));
        widget.addListener("changeOpen", this.__onOpenChanged, this);
        widget.setUserData("cell.childProperty", this.getChildProperty());
        widget.setUserData("cell.showLeafs", this._tree.isShowLeafs());

        if (this._tree.getSelection().contains(item)) {
          this._styleSelectabled(widget);
        } else {
          this._styleUnselectabled(widget);
        }

        var level = this._tree.getLevel(row);

        if (!this._tree.isShowTopLevelOpenCloseIcons()) {
          level -= 1;
        }

        widget.setUserData("cell.level", level);

        if (!this._tree.isShowTopLevelOpenCloseIcons() && level == -1) {
          widget.setOpenSymbolMode("never");
        } else {
          widget.setOpenSymbolMode("auto");
        }

        if (this._tree.getOpenProperty()) {
          widget.setModel(item);
        }

        this._bindItem(widget, row);

        qx.ui.core.queue.Widget.add(widget);
        return widget;
      },
      // interface implementation
      poolCellWidget: function poolCellWidget(widget) {
        widget.removeListener("changeOpen", this.__onOpenChanged, this);

        this._removeBindingsFrom(widget);

        this._renderer.pool(widget);

        this._onPool(widget);
      },
      // Interface implementation
      createLayer: function createLayer() {
        return new qx.ui.virtual.layer.WidgetCell(this);
      },
      // Interface implementation
      createRenderer: function createRenderer() {
        var createItem = qx.util.Delegate.getMethod(this.getDelegate(), "createItem");

        if (createItem == null) {
          createItem = function createItem() {
            return new qx.ui.tree.VirtualTreeItem();
          };
        }

        var renderer = new qx.ui.virtual.cell.WidgetCell();
        renderer.setDelegate({
          createWidget: createItem
        });
        return renderer;
      },
      // interface implementation
      styleSelectabled: function styleSelectabled(row) {
        var widget = this._tree._layer.getRenderedCellWidget(row, 0);

        this._styleSelectabled(widget);
      },
      // interface implementation
      styleUnselectabled: function styleUnselectabled(row) {
        var widget = this._tree._layer.getRenderedCellWidget(row, 0);

        this._styleUnselectabled(widget);
      },
      // interface implementation
      isSelectable: function isSelectable(row) {
        var widget = this._tree._layer.getRenderedCellWidget(row, 0);

        if (widget != null) {
          return widget.isEnabled();
        } else {
          return true;
        }
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */

      /**
       * Styles a selected item.
       *
       * @param widget {qx.ui.core.Widget} widget to style.
       */
      _styleSelectabled: function _styleSelectabled(widget) {
        if (widget == null) {
          return;
        }

        this._renderer.updateStates(widget, {
          selected: 1
        });
      },

      /**
       * Styles a not selected item.
       *
       * @param widget {qx.ui.core.Widget} widget to style.
       */
      _styleUnselectabled: function _styleUnselectabled(widget) {
        if (widget == null) {
          return;
        }

        this._renderer.updateStates(widget, {});
      },

      /**
       * Calls the delegate <code>onPool</code> method when it is used in the
       * {@link #delegate} property.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      _onPool: function _onPool(item) {
        var onPool = qx.util.Delegate.getMethod(this.getDelegate(), "onPool");

        if (onPool != null) {
          onPool(item);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the created item's.
       *
       * @param event {qx.event.type.Data} fired event.
       */
      _onItemCreated: function _onItemCreated(event) {
        var configureItem = qx.util.Delegate.getMethod(this.getDelegate(), "configureItem");

        if (configureItem != null) {
          var leaf = event.getData();
          configureItem(leaf);
        }
      },

      /**
       * Event handler for the change delegate event.
       *
       * @param event {qx.event.type.Data} fired event.
       */
      _onChangeDelegate: function _onChangeDelegate(event) {
        if (this._renderer != null) {
          this._renderer.dispose();

          this.removeBindings();
        }

        this._renderer = this.createRenderer();

        this._renderer.addListener("created", this._onItemCreated, this);
      },

      /**
       * Handler when a node changes opened or closed state.
       *
       * @param event {qx.event.type.Data} The data event.
       */
      __onOpenChanged: function __onOpenChanged(event) {
        var widget = event.getTarget();
        var row = widget.getUserData("cell.row");

        var item = this._tree.getLookupTable().getItem(row);

        if (event.getData()) {
          this._tree.openNodeWithoutScrolling(item);
        } else {
          this._tree.closeNodeWithoutScrolling(item);
        }
      }
    },
    destruct: function destruct() {
      this.removeBindings();

      this._renderer.dispose();

      this._tree = this._renderer = null;
    }
  });
  qx.ui.tree.provider.WidgetProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * This utility class implements some methods for the <code>VirtualTree</code>.
   */
  qx.Class.define("qx.ui.tree.core.Util", {
    statics: {
      /**
       * Returns if the passed item is a node or a leaf.
       *
       * @param node {qx.core.Object} Node to check.
       * @param childProperty {String} The property name to find the children.
       * @return {Boolean} <code>True</code> when the passed item is a node,
       *   </code>false</code> when it is a leaf.
       */
      isNode: function isNode(node, childProperty) {
        if (node == null || childProperty == null) {
          return false;
        }

        return qx.Class.hasProperty(node.constructor, childProperty);
      },

      /**
       * Returns whether the node has visible children or not.
       *
       * @param node {qx.core.Object} Node to check.
       * @param childProperty {String} The property name to find the children.
       * @param ignoreLeafs {Boolean?} Indicates whether leafs are ignored. This means when it is set to
       *    <code>true</code> a node which contains only leafs has no children. The default value is <code>false</code>.
       * @return {Boolean} <code>True</code> when the node has visible children,
       *   <code>false</code> otherwise.
       */
      hasChildren: function hasChildren(node, childProperty, ignoreLeafs) {
        if (node == null || childProperty == null || !this.isNode(node, childProperty)) {
          return false;
        }

        var children = node.get(childProperty);

        if (children == null) {
          return false;
        }

        if (!ignoreLeafs) {
          return children.length > 0;
        } else {
          for (var i = 0; i < children.getLength(); i++) {
            var child = children.getItem(i);

            if (this.isNode(child, childProperty)) {
              return true;
            }
          }
        }

        return false;
      }
    }
  });
  qx.ui.tree.core.Util.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.tree.core.AbstractItem": {
        "require": true
      },
      "qx.ui.tree.core.Util": {},
      "qx.lang.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The tree item is a tree element for the {@link VirtualTree}, which can have
   * nested tree elements.
   */
  qx.Class.define("qx.ui.tree.VirtualTreeItem", {
    extend: qx.ui.tree.core.AbstractItem,
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "virtual-tree-folder"
      }
    },
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        selected: true
      },
      // overridden
      _addWidgets: function _addWidgets() {
        this.addSpacer();
        this.addOpenButton();
        this.addIcon();
        this.addLabel();
      },
      // overridden
      _shouldShowOpenSymbol: function _shouldShowOpenSymbol() {
        var open = this.getChildControl("open", true);

        if (open == null) {
          return false;
        }

        return this.isOpenable();
      },
      // overridden
      getLevel: function getLevel() {
        return this.getUserData("cell.level");
      },
      // overridden
      hasChildren: function hasChildren() {
        var model = this.getModel();
        var childProperty = this.getUserData("cell.childProperty");
        var showLeafs = this.getUserData("cell.showLeafs");
        return qx.ui.tree.core.Util.hasChildren(model, childProperty, !showLeafs);
      },
      // apply method
      _applyModel: function _applyModel(value, old) {
        var childProperty = this.getUserData("cell.childProperty");
        var showLeafs = this.getUserData("cell.showLeafs");

        if (value != null && qx.ui.tree.core.Util.isNode(value, childProperty)) {
          var eventType = "change" + qx.lang.String.firstUp(childProperty); // listen to children property changes

          if (qx.Class.hasProperty(value.constructor, childProperty)) {
            value.addListener(eventType, this._onChangeChildProperty, this);
          } // children property has been set already, immediately add
          // listener for indent updating


          if (qx.ui.tree.core.Util.hasChildren(value, childProperty, !showLeafs)) {
            value.get(childProperty).addListener("changeLength", this._onChangeLength, this);

            this._updateIndent();
          }
        }

        if (old != null && qx.ui.tree.core.Util.isNode(old, childProperty)) {
          var eventType = "change" + qx.lang.String.firstUp(childProperty);
          old.removeListener(eventType, this._onChangeChildProperty, this);
          var oldChildren = old.get(childProperty);

          if (oldChildren) {
            oldChildren.removeListener("changeLength", this._onChangeLength, this);
          }
        }
      },

      /**
       * Handler to update open/close icon when model length changed.
       */
      _onChangeLength: function _onChangeLength() {
        this._updateIndent();
      },

      /**
       * Handler to add listener to array of children property.
       *
       * @param e {qx.event.type.Data} Data event; provides children array
       */
      _onChangeChildProperty: function _onChangeChildProperty(e) {
        var children = e.getData();
        var old = e.getOldData();

        if (children) {
          this._updateIndent();

          children.addListener("changeLength", this._onChangeLength, this);
        }

        if (old) {
          old.removeListener("changeLength", this._onChangeLength, this);
        }
      }
    }
  });
  qx.ui.tree.VirtualTreeItem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.tree.virtual.AbstractTreeTest": {
        "require": true
      },
      "qx.data.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.tree.virtual.MultiSelection", {
    extend: qx.test.ui.tree.virtual.AbstractTreeTest,
    members: {
      setUp: function setUp() {
        qx.test.ui.tree.virtual.MultiSelection.prototype.setUp.base.call(this);
        this.tree.setSelectionMode("multi");
      },
      testSelection: function testSelection() {
        var root = this.createModelAndSetModel(2);
        var selection = this.tree.getSelection();
        selection.push(root);
        selection.push(root.getChildren().getItem(0));
        selection.push(root.getChildren().getItem(1)); // check selection on tree

        this.assertEquals(3, this.tree.getSelection().getLength(), "On Tree");
        var expectedSelection = new qx.data.Array([root, root.getChildren().getItem(0), root.getChildren().getItem(1)]);
        this.assertDataArrayEquals(selection, expectedSelection, "On Tree");
        expectedSelection.dispose(); // check selection on manager

        var selectionFromManager = this.tree._manager.getSelection();

        for (var i = 0; i < selectionFromManager.length; i++) {
          selectionFromManager[i] = this.tree._getDataFromRow(selectionFromManager[i]);
        }

        this.assertEquals(3, selectionFromManager.length, "On selection manager");
        expectedSelection = new qx.data.Array(selectionFromManager);
        this.assertDataArrayEquals(selection, expectedSelection, "On selection manager");
        expectedSelection.dispose();
      },
      testSelectionByUserInteraction: function testSelectionByUserInteraction() {
        var root = this.createModelAndSetModel(2);
        var selection = this.tree.getSelection();

        this.tree._manager.replaceSelection([1, 3, 5]); // check selection on manager


        var selectionFromManager = this.tree._manager.getSelection();

        for (var i = 0; i < selectionFromManager.length; i++) {
          selectionFromManager[i] = this.tree._getDataFromRow(selectionFromManager[i]);
        }

        this.assertEquals(3, selectionFromManager.length, "On selection manager");
        var expectedSelection = new qx.data.Array(selectionFromManager);
        this.assertTrue(selection.equals(expectedSelection), "On selection manager");
        expectedSelection.dispose(); // check selection on tree

        expectedSelection = new qx.data.Array([root.getChildren().getItem(0), root.getChildren().getItem(2), root.getChildren().getItem(4)]);
        this.assertEquals(3, selection.getLength(), "On Tree");
        this.assertDataArrayEquals(selection, expectedSelection, "On Tree");
        expectedSelection.dispose();
      },
      testSelectionEventByUserInteraction: function testSelectionEventByUserInteraction() {
        var root = this.createModelAndSetModel(2);
        var selection = this.tree.getSelection();
        var self = this;
        this.assertEventFired(selection, "change", function () {
          self.tree._manager.replaceSelection([1, 3, 5]);
        }, function (e) {
          // check selection on manager
          var selectionFromManager = self.tree._manager.getSelection();

          for (var i = 0; i < selectionFromManager.length; i++) {
            selectionFromManager[i] = self.tree._getDataFromRow(selectionFromManager[i]);
          }

          self.assertEquals(3, selectionFromManager.length, "On selection manager");
          var expectedSelection = new qx.data.Array(selectionFromManager);
          self.assertDataArrayEquals(selection, expectedSelection, "On selection manager");
          expectedSelection.dispose(); // check selection on tree

          self.assertEquals(3, selection.getLength(), "On Tree");
          expectedSelection = new qx.data.Array([root.getChildren().getItem(0), root.getChildren().getItem(2), root.getChildren().getItem(4)]);
          self.assertDataArrayEquals(selection, expectedSelection, "On Tree");
          expectedSelection.dispose();
        });
      },
      testSelectionAfterCloseParentNode: function testSelectionAfterCloseParentNode() {
        var root = this.createModelAndSetModel(3);
        var parent = root.getChildren().getItem(1);
        this.tree.openNode(root.getChildren().getItem(1));
        var selection = this.tree.getSelection();
        selection.push(root);
        selection.push(root.getChildren().getItem(0));
        selection.push(parent.getChildren().getItem(1));
        selection.push(parent.getChildren().getItem(3));
        selection.push(parent.getChildren().getItem(5));
        selection.push(parent.getChildren().getItem(6));
        selection.push(root.getChildren().getItem(2)); // check selection before close parent

        this.assertEquals(7, this.tree.getSelection().getLength(), "On Tree");
        this.assertEquals(7, this.tree._manager.getSelection().length, "On selection manager");
        this.tree.closeNode(parent); // check selection on tree

        this.assertEquals(3, this.tree.getSelection().getLength(), "On Tree");
        var expectedSelection = new qx.data.Array([root, root.getChildren().getItem(0), root.getChildren().getItem(2)]);
        this.assertDataArrayEquals(selection, expectedSelection, "On Tree");
        expectedSelection.dispose(); // check selection on manager

        var selectionFromManager = this.tree._manager.getSelection();

        for (var i = 0; i < selectionFromManager.length; i++) {
          selectionFromManager[i] = this.tree._getDataFromRow(selectionFromManager[i]);
        }

        this.assertEquals(3, selectionFromManager.length, "On selection manager");
        expectedSelection = new qx.data.Array(selectionFromManager);
        this.assertDataArrayEquals(selection, expectedSelection, "On selection manager");
        expectedSelection.dispose();
      }
    }
  });
  qx.test.ui.tree.virtual.MultiSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.tree.virtual.AbstractTreeTest": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.tree.virtual.SingleSelection", {
    extend: qx.test.ui.tree.virtual.AbstractTreeTest,
    members: {
      testSelection: function testSelection() {
        var root = this.createModelAndSetModel(2);
        var selection = this.tree.getSelection();
        selection.push(root); // check selection from list

        this.assertEquals(1, this.tree.getSelection().getLength(), "On Tree");
        this.assertEquals(root, selection.getItem(0), "On Tree"); // check selection from manager

        var row = this.tree._manager.getSelectedItem();

        this.assertEquals(0, row);
      },
      testInvalidSelection: function testInvalidSelection() {
        var root = this.createModelAndSetModel(2);
        var selection = this.tree.getSelection();
        selection.push(root);
        selection.push(root.getChildren().getItem(0)); // check selection from list

        this.assertEquals(1, this.tree.getSelection().getLength(), "On Tree");
        this.assertEquals(root.getChildren().getItem(0), selection.getItem(0), "On Tree"); // check selection from manager

        var selection = this.tree._manager.getSelection();

        this.assertEquals(1, selection.length);
        this.assertEquals(1, selection[0]);
      },
      testSelectionByUserInteraction: function testSelectionByUserInteraction() {
        var root = this.createModelAndSetModel(2);
        var selection = this.tree.getSelection();

        this.tree._manager.selectItem(2);

        this.assertEquals(1, selection.getLength());
        this.assertEquals(root.getChildren().getItem(1), selection.getItem(0));
        this.assertEquals(2, this.tree._manager.getSelectedItem());
      },
      testSelectionEventByUserInteraction: function testSelectionEventByUserInteraction() {
        var root = this.createModelAndSetModel(2);
        var selection = this.tree.getSelection();
        var that = this;
        this.assertEventFired(selection, "change", function () {
          that.tree._manager.selectItem(2);
        }, function (e) {
          that.assertEquals(1, selection.getLength());
          that.assertEquals(root.getChildren().getItem(1), selection.getItem(0));
          that.assertEquals(2, that.tree._manager.getSelectedItem());
        });
      },
      testSelectionWithClosedNode: function testSelectionWithClosedNode() {
        var root = this.createModelAndSetModel(2);
        var selection = this.tree.getSelection();
        var parent = root.getChildren().getItem(0);
        var itemToSelect = parent.getChildren().getItem(2);
        this.tree.openNode(parent);
        selection.push(itemToSelect); // check selection from tree

        this.assertEquals(1, selection.getLength(), "On Tree");
        this.assertEquals(itemToSelect, selection.getItem(0), "On Tree"); // check selection from manager

        var selectionOnManager = this.tree._manager.getSelection();

        this.assertEquals(1, selectionOnManager.length);
        this.assertEquals(this.tree.getLookupTable().indexOf(itemToSelect), selectionOnManager[0]);
        this.tree.closeNode(parent);

        var selectionOnManager = this.tree._manager.getSelection();

        this.assertEquals(0, selection.getLength(), "Selection not reset on Tree");
        this.assertEquals(0, selectionOnManager.length, "Selection not reset on manager");
      },
      testRemoveItem: function testRemoveItem() {
        var root = this.createModelAndSetModel(2);
        var selection = this.tree.getSelection();
        var parent = root.getChildren().getItem(0);
        var itemToSelect = parent.getChildren().getItem(2);
        this.tree.openNode(parent);
        selection.push(itemToSelect); // check selection from tree before remove item

        this.assertEquals(1, selection.getLength(), "On Tree (setup)");
        this.assertEquals(itemToSelect, selection.getItem(0), "On Tree (setup)"); // remove selected item

        parent.getChildren().removeAt(2).dispose(); // check selection from list

        this.assertEquals(0, selection.getLength(), "On Tree"); // check selection from manager

        var selectionOnManager = this.tree._manager.getSelection();

        this.assertEquals(0, selectionOnManager.length, "On Manager");
      }
    }
  });
  qx.test.ui.tree.virtual.SingleSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.tree.virtual.SingleSelection": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.tree.virtual.OneSelection", {
    extend: qx.test.ui.tree.virtual.SingleSelection,
    members: {
      setUp: function setUp() {
        qx.test.ui.tree.virtual.OneSelection.prototype.setUp.base.call(this);
        this.tree.setSelectionMode("one");
      },
      testSelectionWithClosedNode: function testSelectionWithClosedNode() {
        var root = this.createModelAndSetModel(2);
        var selection = this.tree.getSelection();
        var parent = root.getChildren().getItem(0);
        var itemToSelect = parent.getChildren().getItem(2);
        this.tree.openNode(parent);
        selection.push(itemToSelect); // check selection from tree

        this.assertEquals(1, selection.getLength(), "On Tree");
        this.assertEquals(itemToSelect, selection.getItem(0), "On Tree"); // check selection from manager

        var selectionOnManager = this.tree._manager.getSelection();

        this.assertEquals(1, selectionOnManager.length);
        this.assertEquals(this.tree.getLookupTable().indexOf(itemToSelect), selectionOnManager[0]);
        var self = this;
        this.assertEventFired(selection, "change", function () {
          self.tree.closeNode(parent);
        }, function (e) {
          var selectionOnManager = self.tree._manager.getSelection();

          self.assertEquals(1, selection.getLength(), "Selection not reset on Tree");
          self.assertEquals(parent, selection.getItem(0), "Selection not reset on Tree");
          self.assertEquals(1, selectionOnManager.length, "Selection not reset on manager");
          self.assertEquals(self.tree.getLookupTable().indexOf(parent), selectionOnManager[0], "Selection not reset on manager");
        });
      },
      testSelectionWithClosedParentNode: function testSelectionWithClosedParentNode() {
        var root = this.createModelAndSetModel(3);
        var selection = this.tree.getSelection();
        var nodeToClose = root.getChildren().getItem(0);
        var parent = nodeToClose.getChildren().getItem(1);
        var itemToSelect = parent.getChildren().getItem(2);
        this.tree.openNodeAndParents(parent);
        selection.push(itemToSelect); // check selection from tree

        this.assertEquals(1, selection.getLength(), "On Tree");
        this.assertEquals(itemToSelect, selection.getItem(0), "On Tree"); // check selection from manager

        var selectionOnManager = this.tree._manager.getSelection();

        this.assertEquals(1, selectionOnManager.length);
        this.assertEquals(this.tree.getLookupTable().indexOf(itemToSelect), selectionOnManager[0]);
        var self = this;
        this.assertEventFired(selection, "change", function () {
          self.tree.closeNode(nodeToClose);
        }, function (e) {
          var selectionOnManager = self.tree._manager.getSelection();

          self.assertEquals(1, selection.getLength(), "Selection not reset on Tree");
          self.assertEquals(nodeToClose, selection.getItem(0), "Selection not reset on Tree");
          self.assertEquals(1, selectionOnManager.length, "Selection not reset on manager");
          self.assertEquals(self.tree.getLookupTable().indexOf(nodeToClose), selectionOnManager[0], "Selection not reset on manager");
        });
      },
      testRemoveItem: function testRemoveItem() {
        var root = this.createModelAndSetModel(2);
        var selection = this.tree.getSelection();
        var parent = root.getChildren().getItem(0);
        var itemToSelect = parent.getChildren().getItem(2);
        this.tree.openNode(parent);
        selection.push(itemToSelect); // check selection from tree before remove item

        this.assertEquals(1, selection.getLength(), "On Tree (setup)");
        this.assertEquals(itemToSelect, selection.getItem(0), "On Tree (setup)");
        var self = this;
        this.assertEventFired(selection, "change", function () {
          // remove selected item
          parent.getChildren().removeAt(2).dispose();
        }, function (e) {
          // check selection from list
          self.assertEquals(1, selection.getLength(), "On Tree");
          self.assertEquals(parent, selection.getItem(0), "On Tree"); // check selection from manager

          var selectionOnManager = self.tree._manager.getSelection();

          self.assertEquals(1, selectionOnManager.length, "On Manager");
          self.assertEquals(self.tree.getLookupTable().indexOf(parent), selectionOnManager[0], "On Manager");
        });
      }
    }
  });
  qx.test.ui.tree.virtual.OneSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.tree.core.IVirtualTree": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.data.marshal.Json": {},
      "qx.ui.tree.core.OpenCloseController": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.tree.virtual.OpenCloseController", {
    extend: qx.dev.unit.TestCase,
    implement: qx.ui.tree.core.IVirtualTree,
    include: qx.dev.unit.MMock,
    events: {
      open: "qx.event.type.Data",
      close: "qx.event.type.Data"
    },
    properties: {
      openProperty: {
        check: "String",
        init: null
      }
    },
    members: {
      model: null,
      controller: null,
      nodesOpen: null,
      setUp: function setUp() {
        if (!this.spyOpenNode) {
          this.spyOpenNode = this.spy(this, "openNode");
          this.spyCloseNode = this.spy(this, "closeNode");
        }

        var rawData = [{
          name: "Root",
          open: false,
          kids: [{
            name: "Branch 1",
            open: false,
            kids: [{
              name: "Leaf 1.1"
            }, {
              name: "Leaf 1.2"
            }, {
              name: "Branch 1.3",
              open: false,
              kids: [{
                name: "Branch 1.3.1",
                open: false,
                kids: [{
                  name: "Leaf 1.3.1.1"
                }]
              }]
            }]
          }]
        }];
        this.model = qx.data.marshal.Json.createModel(rawData, true); // Ensure that pushing onto the model works as well

        var parentItem = qx.data.marshal.Json.createModel({
          Name: "New parent",
          kids: [],
          open: true
        }, true);
        this.model.getItem(0).getKids().push(parentItem);
        var childItem = qx.data.marshal.Json.createModel({
          Name: "Child of new parent"
        }, true);
        parentItem.getKids().push(childItem);
        childItem = qx.data.marshal.Json.createModel({
          Name: "Child of Root"
        }, true);
        this.model.getItem(0).getKids().push(childItem);
        this.nodesOpen = {};
        this.setOpenProperty("open");
        this.controller = new qx.ui.tree.core.OpenCloseController(this, this.model.getItem(0));
      },
      tearDown: function tearDown() {
        this.controller.dispose();
        this.controller = null;
        this.model.dispose();
        this.model = null;
      },
      testModelToTree: function testModelToTree() {
        var node;
        var openNodeNames; // Reset the spies

        this.spyOpenNode.reset();
        this.spyCloseNode.reset(); // get the Branch 1 node

        node = this.model.getItem(0).getKids().getItem(0); // open Branch 1

        node.setOpen(true); // openNode should have been called exactly once

        this.assertCalledOnce(this.spyOpenNode); // there should be only one node open

        openNodeNames = Object.keys(this.nodesOpen);
        this.assertEquals(openNodeNames.length, 1); // the name of the open node should be "Branch 1"

        this.assertEquals(openNodeNames[0], "Branch 1"); // close Branch 1

        this.model.getItem(0).getKids().getItem(0).setOpen(false); // closeNode should have been called exactly once

        this.assertCalledOnce(this.spyCloseNode); // there should be no nodes open

        openNodeNames = Object.keys(this.nodesOpen);
        this.assertEquals(openNodeNames.length, 0);
      },
      testTreeToModel: function testTreeToModel() {
        var node;
        var openNodeNames; // Reset the spies

        this.spyOpenNode.reset();
        this.spyCloseNode.reset(); // get the Branch 1 node

        node = this.model.getItem(0).getKids().getItem(0); // send an open event to the controller as if the open button were clicked

        this.fireDataEvent("open", node); // openNode should have been called exactly once

        this.assertCalledOnce(this.spyOpenNode); // there should be only one node open

        openNodeNames = Object.keys(this.nodesOpen);
        this.assertEquals(openNodeNames.length, 1); // the name of the open node should be "Branch 1"

        this.assertEquals(openNodeNames[0], "Branch 1"); // the model value should now be true

        this.assertTrue(node.getOpen()); // send a close event to the controller as if the open button were clicked

        this.fireDataEvent("close", node); // closeNode should have been called exactly once

        this.assertCalledOnce(this.spyCloseNode); // there should be no nodes open

        openNodeNames = Object.keys(this.nodesOpen);
        this.assertEquals(openNodeNames.length, 0); // the model value should now be false

        this.assertFalse(node.getOpen());
      },

      /*
      ---------------------------------------------------------------------------
        MOCK API
      ---------------------------------------------------------------------------
      */
      isShowTopLevelOpenCloseIcons: function isShowTopLevelOpenCloseIcons() {
        return true;
      },
      isShowLeafs: function isShowLeafs() {
        return true;
      },
      getSelection: function getSelection() {
        throw new Error("getSelection called unexpectedly");
      },
      getLookupTable: function getLookupTable() {
        throw new Error("getLookupTable called unexpectedly");
      },
      isNode: function isNode(item) {
        throw new Error("isNode called unexpectedly");
      },
      isNodeOpen: function isNodeOpen(node) {
        return this.nodesOpen[node.getName()];
      },
      getLevel: function getLevel(row) {
        throw new Error("getLevel called unexpectedly");
      },
      hasChildren: function hasChildren(node) {
        throw new Error("hasChildren called unexpectedly");
      },
      openNode: function openNode(node) {
        this.nodesOpen[node.getName()] = true;
      },
      closeNode: function closeNode(node) {
        delete this.nodesOpen[node.getName()];
      },
      openNodeWithoutScrolling: function openNodeWithoutScrolling(node) {},
      closeNodeWithoutScrolling: function closeNodeWithoutScrolling(node) {},
      refresh: function refresh() {// nothing to do
      }
    }
  });
  qx.test.ui.tree.virtual.OpenCloseController.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.tree.virtual.AbstractTreeTest": {
        "require": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.ui.tree.virtual.Node)
   */
  qx.Class.define("qx.test.ui.tree.virtual.Sorting", {
    extend: qx.test.ui.tree.virtual.AbstractTreeTest,
    members: {
      testSorter: function testSorter() {
        var sorter = function sorter(a, b) {
          a = a.getName();
          b = b.getName();
          return a < b ? 1 : a > b ? -1 : 0;
        };

        var sortedModel = this.createModel(2);
        var root = this.createModelAndSetModel(2);
        this.tree.openNode(root.getChildren().getItem(2));
        this.tree.openNode(root.getChildren().getItem(2).getChildren().getItem(4));
        var openNodes = [sortedModel, sortedModel.getChildren().getItem(2), sortedModel.getChildren().getItem(2).getChildren().getItem(4)];

        this.__sortModel(sortedModel, sorter);

        var delegate = {
          sorter: sorter
        };
        this.tree.setDelegate(delegate);
        this.flush();
        var expected = this.getVisibleItemsFrom(sortedModel, openNodes);
        qx.lang.Array.insertAt(expected, sortedModel, 0);

        this.__testBuildLookupTable(expected); //this.__logModel(sortedModel);


        sortedModel.dispose();
      },
      testModelUnmodified: function testModelUnmodified() {
        var sorter = function sorter(a, b) {
          a = a.getName();
          b = b.getName();
          return a < b ? 1 : a > b ? -1 : 0;
        };

        var root = this.createModelAndSetModel(1);
        var rootChildrenClone = root.getChildren().concat([]);
        var delegate = {
          sorter: sorter
        };
        this.tree.setDelegate(delegate);
        this.flush();

        this.__testOrderNotChanged(rootChildrenClone.toArray(), root.getChildren().toArray());

        rootChildrenClone.dispose();
      },
      testSorterAndFilter: function testSorterAndFilter() {
        var sorter = function sorter(a, b) {
          a = a.getName();
          b = b.getName();
          return a < b ? 1 : a > b ? -1 : 0;
        };

        var sortedModel = this.createModel(1);
        var root = this.createModelAndSetModel(1); // remove filtered node "Node 2"

        sortedModel.getChildren().removeAt(2);

        this.__sortModel(sortedModel, sorter);

        var delegate = {
          sorter: sorter,
          filter: function filter(child) {
            return child.getName() == "Node 2" ? false : true;
          }
        };
        this.tree.setDelegate(delegate);
        this.flush();
        var expected = this.getVisibleItemsFrom(sortedModel, []);
        qx.lang.Array.insertAt(expected, sortedModel, 0);

        this.__testBuildLookupTable(expected); //this.__logModel(sortedModel);


        sortedModel.dispose();
      },
      __sortModel: function __sortModel(model, sorter) {
        var children = model.getChildren();
        children.sort(sorter);

        for (var i = 0; i < children.getLength(); i++) {
          var child = children.getItem(i);

          if (child instanceof qx.test.ui.tree.virtual.Node) {
            this.__sortModel(child, sorter);
          }
        }
      },
      __testBuildLookupTable: function __testBuildLookupTable(expected) {
        var found = this.tree.getLookupTable().toArray();
        var msg = "Expected [" + expected.join(", ") + "], but found [" + found.join(", ") + "]";
        this.assertEquals(expected.length, found.length, msg);

        for (var i = 0; i < expected.length; i++) {
          this.assertTrue(expected[i].equals(found[i]), msg);
        }

        this.assertEquals(expected.length, this.tree.getPane().getRowConfig().getItemCount());
      },
      __testOrderNotChanged: function __testOrderNotChanged(expected, found) {
        var msg = "Expected [" + expected.join(", ") + "], but found [" + found.join(", ") + "]";
        this.assertEquals(expected.length, found.length, msg);

        for (var i = 0; i < expected.length; i++) {
          this.assertTrue(expected[i].equals(found[i]), msg);
        }
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHOD TO LOG TREE MODEL
      ---------------------------------------------------------------------------
      */
      __logModel: function __logModel(model, level) {
        level = level != null ? level : 0;
        var prefix = "";

        for (var i = 0; i < level; i++) {
          prefix += "-";
        }

        console.log(prefix + ">", model.getName());

        if (model.getChildren == null) {
          return;
        }

        var children = model.getChildren();

        for (var i = 0; i < children.getLength(); i++) {
          this.__logModel(children.getItem(i), level + 1);
        }
      }
    }
  });
  qx.test.ui.tree.virtual.Sorting.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.tree.virtual.AbstractTreeTest": {
        "require": true
      },
      "qx.ui.tree.VirtualTree": {},
      "qx.lang.Array": {},
      "qx.data.Array": {},
      "qx.ui.core.queue.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.ui.tree.virtual.Leaf)
   * @ignore(qx.test.ui.tree.virtual.Node)
   */
  qx.Class.define("qx.test.ui.tree.virtual.Tree", {
    extend: qx.test.ui.tree.virtual.AbstractTreeTest,
    members: {
      testCreation: function testCreation() {
        this.assertEquals("virtual-tree", this.tree.getAppearance(), "Init value for 'appearance' is wrong!");
        this.assertTrue(this.tree.getFocusable(), "Init value for 'focusable' is wrong!");
        this.assertEquals(100, this.tree.getWidth(), "Init value for 'width' is wrong!");
        this.assertEquals(200, this.tree.getHeight(), "Init value for 'height' is wrong!");
        this.assertEquals(25, this.tree.getItemHeight(), "Init value for 'itemHeight' is wrong!");
        this.assertEquals(25, this.tree.getPane().getRowConfig().getDefaultItemSize(), "Init value for 'itemHeight' is wrong!");
        this.assertEquals("dbltap", this.tree.getOpenMode(), "Init value for 'openMode' is wrong!");
        this.assertFalse(this.tree.getHideRoot(), "Init value for 'hideRoot' is wrong!");
        this.assertNull(this.tree.getModel(), "Init value for 'model' is wrong!");
        this.assertNull(this.tree.getLabelPath(), "Init value for 'labelPath' is wrong!");
        this.assertNull(this.tree.getIconPath(), "Init value for 'iconPath' is wrong!");
        this.assertNull(this.tree.getLabelOptions(), "Init value for 'labelOptions' is wrong!");
        this.assertNull(this.tree.getIconOptions(), "Init value for 'iconOptions' is wrong!");
        this.assertNull(this.tree.getDelegate(), "Init value for 'delegate' is wrong!");
        this.assertNull(this.tree.getChildProperty(), "Init value for 'childProperty' is wrong!");
        this.assertTrue(this.tree.getPane().hasListener("cellDbltap"), "Init listener 'cellDbltap' is wrong!");
      },
      testCreationWithParams: function testCreationWithParams() {
        this.tree.destroy();
        var model = this.createModel(0);
        this.tree = new qx.ui.tree.VirtualTree(model, "name", "children");
        this.getRoot().add(this.tree);
        this.assertEquals(model, this.tree.getModel(), "Init value for 'model' is wrong!");
        this.assertEquals("name", this.tree.getLabelPath(), "Init value for 'labelPath' is wrong!");
        this.assertEquals("children", this.tree.getChildProperty(), "Init value for 'childProperty' is wrong!");
        model.dispose();
      },
      testSetItemHeight: function testSetItemHeight() {
        this.tree.setItemHeight(30);
        this.assertEquals(30, this.tree.getPane().getRowConfig().getDefaultItemSize());
      },
      testSetModel: function testSetModel() {
        var model = this.createModelAndSetModel(0);
        this.assertEquals(model, this.tree.getModel());
      },
      testResetModel: function testResetModel() {
        var oldModel = this.tree.getModel();
        this.createModelAndSetModel(0);
        this.tree.resetModel();
        this.assertEquals(oldModel, this.tree.getModel());
      },
      testExceptionOnSetModel: function testExceptionOnSetModel() {
        var model = this.createModel(0);
        var that = this;
        this.assertException(function () {
          that.tree.setModel(model);
        }, Error, "Could not build tree, because 'childProperty' and/or 'labelPath' is 'null'!");
        model.dispose();
      },
      testBuildLookupTable: function testBuildLookupTable() {
        var root = this.createModelAndSetModel(2);
        var expected = this.getVisibleItemsFrom(root, [root]);
        qx.lang.Array.insertAt(expected, root, 0);

        this.__testBuildLookupTable(expected);
      },
      testBuildLookupTableWithOpenNodes: function testBuildLookupTableWithOpenNodes() {
        var root = this.createModelAndSetModel(3);
        var nodesToOpen = [root, root.getChildren().getItem(4), root.getChildren().getItem(4).getChildren().getItem(2)];

        this.__openNodes(nodesToOpen);

        var expected = this.getVisibleItemsFrom(root, nodesToOpen);
        qx.lang.Array.insertAt(expected, root, 0);

        this.__testBuildLookupTable(expected);
      },
      testBuildLookupTableWithRemovedNodes: function testBuildLookupTableWithRemovedNodes() {
        var root = this.createModelAndSetModel(3);
        var nodesToOpen = [root, root.getChildren().getItem(4), root.getChildren().getItem(4).getChildren().getItem(2)];

        this.__openNodes(nodesToOpen);

        this.tree.closeNode(nodesToOpen[nodesToOpen.length - 1]);
        nodesToOpen.pop();
        var expected = this.getVisibleItemsFrom(root, nodesToOpen);
        qx.lang.Array.insertAt(expected, root, 0);

        this.__testBuildLookupTable(expected);
      },
      testBuildLookupTableWithClosedRoot: function testBuildLookupTableWithClosedRoot() {
        var root = this.createModelAndSetModel(1);
        this.tree.closeNode(root);

        this.__testBuildLookupTable([root]);
      },
      testBuildLookupTableWithNoModel: function testBuildLookupTableWithNoModel() {
        this.createModelAndSetModel(1);
        this.tree.setModel(null);

        this.__testBuildLookupTable([]);
      },
      testBuildLookupTableOnModelChange: function testBuildLookupTableOnModelChange() {
        var root = this.createModelAndSetModel(1);
        var nodesToOpen = [root, root.getChildren().getItem(2)];

        this.__openNodes(nodesToOpen);

        var newBranch = new qx.test.ui.tree.virtual.Node("New Branch");

        this._createNodes(newBranch, 2);

        root.getChildren().getItem(2).getChildren().push(newBranch);
        var expected = this.getVisibleItemsFrom(root, nodesToOpen);
        qx.lang.Array.insertAt(expected, root, 0);

        this.__testBuildLookupTable(expected);
      },
      testBuildLookupTableWithHiddenRoot: function testBuildLookupTableWithHiddenRoot() {
        var root = this.createModelAndSetModel(1);
        this.tree.setHideRoot(true);
        var expected = this.getVisibleItemsFrom(root, [root]);

        this.__testBuildLookupTable(expected);
      },
      testBuildLookupWithoutLeafs: function testBuildLookupWithoutLeafs() {
        var root = this.createModelAndSetModel(2);
        var nodesToOpen = [root, root.getChildren().getItem(2)];

        this.__openNodes(nodesToOpen);

        this.tree.setShowLeafs(false);
        var allVisibleItems = this.getVisibleItemsFrom(root, nodesToOpen);
        qx.lang.Array.insertAt(allVisibleItems, root, 0);
        var expected = [];

        for (var i = 0; i < allVisibleItems.length; i++) {
          var item = allVisibleItems[i];

          if (this.tree.isNode(item)) {
            expected.push(item);
          }
        }

        this.__testBuildLookupTable(expected);
      },
      __testBuildLookupTable: function __testBuildLookupTable(expected) {
        this.assertArrayEquals(expected, this.tree.getLookupTable().toArray());
        this.assertEquals(expected.length, this.tree.getPane().getRowConfig().getItemCount());
      },
      testChangeBubblesAddChild: function testChangeBubblesAddChild() {
        var root = this.createModelAndSetModel(2);
        var spy = this.spy(this.tree, "buildLookupTable");
        var leaf = new qx.test.ui.tree.virtual.Leaf("New Leaf");
        root.getChildren().push(leaf);
        this.assertCalledOnce(spy);
        leaf = new qx.test.ui.tree.virtual.Leaf("New Leaf");
        root.getChildren().getItem(2).getChildren().push(leaf);
        this.assertCalledTwice(spy);
      },
      testChangeBubblesReplaceChildren: function testChangeBubblesReplaceChildren() {
        var root = this.createModelAndSetModel(2);
        var spy = this.spy(this.tree, "buildLookupTable");
        var leaf = new qx.test.ui.tree.virtual.Leaf("New Leaf");
        var helper = root.getChildren().getItem(2).getChildren();
        root.getChildren().getItem(2).setChildren(new qx.data.Array([leaf]));
        this.assertCalledOnce(spy);
        helper.setAutoDisposeItems(true);
        helper.dispose();
        leaf = new qx.test.ui.tree.virtual.Leaf("New Leaf");
        helper = root.getChildren();
        root.setChildren(new qx.data.Array([leaf]));
        this.assertCalledTwice(spy);
        helper.setAutoDisposeItems(true);
        helper.dispose();
      },
      testChangeBubblesRemoveItems: function testChangeBubblesRemoveItems() {
        var root = this.createModelAndSetModel(2);
        var spy = this.spy(this.tree, "buildLookupTable");
        var removed = root.getChildren().getItem(2).getChildren().removeAll();

        this.__disposeChildren(removed);

        this.assertCalledOnce(spy);
        removed = root.getChildren().removeAll();

        this.__disposeChildren(removed);

        this.assertCalledTwice(spy);
      },
      testChangeBubblesChangeProperty: function testChangeBubblesChangeProperty() {
        var root = this.createModelAndSetModel(2);
        var spy = this.spy(this.tree, "buildLookupTable");
        root.setName("Gülleman");
        this.assertNotCalled(spy);
        root.getChildren().getItem(2).setName("Gülleman");
        this.assertNotCalled(spy);
      },
      testNoChangeBubblesAddChild: function testNoChangeBubblesAddChild() {
        var root = this.createModelAndSetModel(3);
        var spy = this.spy(this.tree, "buildLookupTable");
        var newItem = new qx.test.ui.tree.virtual.Node("test");
        root.getChildren().getItem(2).getChildren().getItem(0).getChildren().push(newItem);
        this.assertNotCalled(spy);
      },
      testGetOpenNodes: function testGetOpenNodes() {
        var root = this.createModelAndSetModel(1);
        this.assertArrayEquals([root], this.tree.getOpenNodes());
      },
      testIsNodeOpen: function testIsNodeOpen() {
        var root = this.createModelAndSetModel(2);
        var nodesToOpen = [root, root.getChildren().getItem(0)];

        this.__openNodes(nodesToOpen);

        this.assertTrue(this.tree.isNodeOpen(nodesToOpen[0]));
        this.assertTrue(this.tree.isNodeOpen(nodesToOpen[1]));
        this.assertFalse(this.tree.isNodeOpen(root.getChildren().getItem(1)));
      },
      testOpenNode: function testOpenNode() {
        var root = this.createModelAndSetModel(3);
        var nodesToOpen = [root, root.getChildren().getItem(0)];

        this.__openNodes(nodesToOpen);

        this.assertArrayEquals(nodesToOpen, this.tree.getOpenNodes());
        this.tree.openNode(nodesToOpen[1]);
        this.assertArrayEquals(nodesToOpen, this.tree.getOpenNodes());
      },
      testCloseNode: function testCloseNode() {
        var root = this.createModelAndSetModel(2);
        var nodesToOpen = [root, root.getChildren().getItem(0)];

        this.__openNodes(nodesToOpen);

        this.assertArrayEquals(nodesToOpen, this.tree.getOpenNodes());
        this.tree.closeNode(nodesToOpen[1]);
        nodesToOpen.pop();
        this.assertArrayEquals(nodesToOpen, this.tree.getOpenNodes());
      },
      testCloseNodeWithRoot: function testCloseNodeWithRoot() {
        var root = this.createModelAndSetModel(2);
        var nodesToOpen = [root, root.getChildren().getItem(0)];

        this.__openNodes(nodesToOpen);

        this.assertArrayEquals(nodesToOpen, this.tree.getOpenNodes());
        this.tree.closeNode(nodesToOpen[1]);
        this.tree.closeNode(nodesToOpen[0]);
        this.assertArrayEquals([], this.tree.getOpenNodes());
      },
      testOpenNodeWithParents: function testOpenNodeWithParents() {
        var root = this.createModelAndSetModel(3);
        var expectedOpen = [root, root.getChildren().getItem(4), root.getChildren().getItem(4).getChildren().getItem(4), root.getChildren().getItem(4).getChildren().getItem(4).getChildren().getItem(4)];
        this.tree.openNodeAndParents(expectedOpen[3]);
        var openNodes = this.tree.getOpenNodes();
        this.assertEquals(expectedOpen.length, openNodes.length);

        for (var i = 0; i < expectedOpen.length; i++) {
          this.assertTrue(openNodes.includes(expectedOpen[i]));
        }
      },
      testIsNode: function testIsNode() {
        var root = this.createModelAndSetModel(3);
        this.assertTrue(this.tree.isNode(root));
        this.assertTrue(this.tree.isNode(root.getChildren().getItem(4)));
        this.assertTrue(this.tree.isNode(root.getChildren().getItem(4).getChildren().getItem(4)));
        this.assertTrue(this.tree.isNode(root.getChildren().getItem(4).getChildren().getItem(4).getChildren().getItem(4)));
        this.assertFalse(this.tree.isNode(root.getChildren().getItem(4).getChildren().getItem(4).getChildren().getItem(4).getChildren().getItem(4)));
      },
      testGetLevel: function testGetLevel() {
        var root = this.createModelAndSetModel(3);
        var nodesToOpen = [root, root.getChildren().getItem(2), root.getChildren().getItem(2).getChildren().getItem(3), root.getChildren().getItem(2).getChildren().getItem(3).getChildren().getItem(1)];

        this.__openNodes(nodesToOpen);

        this.assertEquals(0, this.tree.getLevel(this.__getRowFrom(nodesToOpen[0])));
        this.assertEquals(1, this.tree.getLevel(this.__getRowFrom(nodesToOpen[1])));
        this.assertEquals(2, this.tree.getLevel(this.__getRowFrom(nodesToOpen[2])));
        this.assertEquals(3, this.tree.getLevel(this.__getRowFrom(nodesToOpen[3])));
        this.assertEquals(4, this.tree.getLevel(this.__getRowFrom(nodesToOpen[3].getChildren().getItem(4))));
      },
      testGetLevelWithHiddenRoot: function testGetLevelWithHiddenRoot() {
        var root = this.createModelAndSetModel(1);
        this.tree.openNode(root.getChildren().getItem(4));
        this.tree.setHideRoot(true);
        var excpected = [root.getChildren().getItem(4), root.getChildren().getItem(4).getChildren().getItem(2)];
        this.assertEquals(0, this.tree.getLevel(this.__getRowFrom(excpected[0])));
        this.assertEquals(1, this.tree.getLevel(this.__getRowFrom(excpected[1])));
      },
      testHasChildren: function testHasChildren() {
        var root = this.createModelAndSetModel(1);
        this.assertTrue(this.tree.hasChildren(root));
        var node = new qx.test.ui.tree.virtual.Node("Node");
        this.assertFalse(this.tree.hasChildren(node));
        node.dispose();
      },
      testHasChildrenHideLeafs: function testHasChildrenHideLeafs() {
        var root = this.createModelAndSetModel(2);
        this.tree.setShowLeafs(false);
        this.assertTrue(this.tree.hasChildren(root));
        this.tree.openNode(root.getChildren().getItem(0));
        this.assertTrue(this.tree.hasChildren(root.getChildren().getItem(0)));
        var node = new qx.test.ui.tree.virtual.Node("Node");

        this._createLeafs(node, 1);

        this.assertFalse(this.tree.hasChildren(node));
        node.dispose();
        var node = new qx.test.ui.tree.virtual.Node("Node");
        this.assertFalse(this.tree.hasChildren(node));
        node.dispose();
      },
      testSetOpenModeWithTap: function testSetOpenModeWithTap() {
        this.tree.setOpenMode("tap");

        this.__testOpenMode(false, true);

        this.tree.resetOpenMode();

        this.__testOpenMode(true, false);
      },
      testSetOpenModeWithNone: function testSetOpenModeWithNone() {
        this.tree.setOpenMode("none");

        this.__testOpenMode(false, false);

        this.tree.resetOpenMode();

        this.__testOpenMode(true, false);
      },
      __testOpenMode: function __testOpenMode(dbltap, tap) {
        var pane = this.tree.getPane();
        this.assertEquals(dbltap, pane.hasListener("cellDbltap"), "Expected " + (dbltap ? "" : "no ") + " listener for 'cellDbltap'!");
        this.assertEquals(tap, pane.hasListener("cellTap"), "Expected " + (tap ? "" : "no ") + " listener for 'cellTap'!");
      },
      testFilter: function testFilter() {
        var filterNode = "Node 2";
        var root = this.model = this.createModel(1);
        this.tree.setLabelPath("name");
        this.tree.setChildProperty("children");
        var delegate = {
          filter: function filter(child) {
            return child.getName() == filterNode ? false : true;
          }
        };
        this.tree.setDelegate(delegate);
        this.tree.setModel(root);
        this.flush(); // Get array of child elements of root expect the filtered one

        var expected = this.getVisibleItemsFrom(root, [root]);

        for (var i = 0; i < expected.length; i++) {
          if (expected[i].getName() == filterNode) {
            expected.splice(i, 1);
          }
        }

        ;
        qx.lang.Array.insertAt(expected, root, 0);
        this.assertArrayEquals(expected, this.tree.getLookupTable().toArray());
      },
      testOpenNodeWithoutScrolling: function testOpenNodeWithoutScrolling() {
        var root = this.createModelAndSetModel(1);
        qx.ui.core.queue.Manager.flush(); // open and select the fifth leaf of fifth branch

        var item4_4 = root.getChildren().getItem(4).getChildren().getItem(4);
        this.tree.openNodeAndParents(item4_4);
        this.tree.setSelection(new qx.data.Array([item4_4]));
        qx.ui.core.queue.Manager.flush(); // store y scroll position

        var scrollY = this.tree.getScrollY(); // open third node without auto scrolling

        this.tree.openNodeWithoutScrolling(root.getChildren().getItem(2));
        qx.ui.core.queue.Manager.flush(); // check scroll y position

        this.assertEquals(this.tree.getScrollY(), scrollY, "Y position of scroller must not be changed"); // close the third node, but use API to automatically scroll selected into view

        this.tree.closeNode(root.getChildren().getItem(2));
        qx.ui.core.queue.Manager.flush(); // check scroll y position

        this.assertNotEquals(this.tree.getScrollY(), scrollY, "Y position of scroller must be changed");
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHOD TO CALCULATE THE VISIBLE ITEMS
      ---------------------------------------------------------------------------
      */
      __getRowFrom: function __getRowFrom(item) {
        return this.tree.getLookupTable().indexOf(item);
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHOD TO OPEN NODES ON TREE
      ---------------------------------------------------------------------------
      */
      __openNodes: function __openNodes(nodes) {
        for (var i = 0; i < nodes.length; i++) {
          this.tree.openNodeWithoutScrolling(nodes[i]);
        }
      },
      __disposeChildren: function __disposeChildren(nativeArray) {
        for (var i = 0; i < nativeArray.length; i++) {
          nativeArray[i].dispose();
        }
      }
    }
  });
  qx.test.ui.tree.virtual.Tree.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.tree.virtual.AbstractTreeTest": {
        "construct": true,
        "require": true
      },
      "qx.core.ObjectRegistry": {},
      "qx.data.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Mustafa Sak (msak)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.ui.tree.virtual.Node)
   * @ignore(qx.test.ui.tree.virtual.NodeDefered)
   * @ignore(qx.test.ui.tree.virtual.Leaf)
   */
  qx.Class.define("qx.test.ui.tree.virtual.TreeItem", {
    extend: qx.test.ui.tree.virtual.AbstractTreeTest,
    construct: function construct() {
      qx.test.ui.tree.virtual.AbstractTreeTest.constructor.call(this);
      qx.Class.define("qx.test.ui.tree.virtual.NodeDefered", {
        extend: qx.test.ui.tree.virtual.Leaf,
        properties: {
          children: {
            check: "qx.data.Array",
            event: "changeChildren",
            apply: "_applyEventPropagation",
            nullable: true
          }
        },
        destruct: function destruct() {
          if (!qx.core.ObjectRegistry.inShutDown) {
            var children = this.getChildren();

            if (children) {
              for (var i = 0; i < children.getLength(); i++) {
                children.getItem(i).dispose();
              }

              children.dispose();
            }
          }
        }
      });
    },
    members: {
      testChildrenSetDeferred: function testChildrenSetDeferred() {
        var that = this;
        var root = new qx.test.ui.tree.virtual.Node("Root node");
        var node = new qx.test.ui.tree.virtual.NodeDefered("Node1");
        root.getChildren().push(node);
        this.tree.setLabelPath("name");
        this.tree.setChildProperty("children");
        this.tree.setModel(root);
        this.flush();
        window.setTimeout(that.resumeHandler(function () {
          // add new node
          node.setChildren(new qx.data.Array([new qx.test.ui.tree.virtual.NodeDefered("Node1.1")])); // check for event listener

          that.assertTrue(node.hasListener("changeChildren"), "There must be a 'changeChildren' event listener!");
          that.assertTrue(node.getChildren().hasListener("changeLength"), "There must be a 'changeLength' event listener on children array!"); // check for open indent

          var widget = that.__getWidgetForm(node);

          that.assertTrue(widget.isOpenable(), "Must be openable!"); // dispose and check if event listeners are removed

          root.dispose();
          that.assertFalse(node.hasListener("changeChildren"), "After disposing, there has not be a 'changeChildren' event listener!");
          that.assertFalse(node.getChildren().hasListener("changeLength"), "After disposing, there must not be a 'changeLength' event listener on children array!");
        }), 0); // children property not set yet

        this.assertNull(node.getChildren(), "Must be null");
        this.wait(50);
      },
      __getWidgetForm: function __getWidgetForm(modelItem) {
        var widget = null;
        var row = this.tree.getLookupTable().indexOf(modelItem);

        if (row > -1) {
          widget = this.tree._layer.getRenderedCellWidget(row, 0);
        }

        return widget;
      }
    }
  });
  qx.test.ui.tree.virtual.TreeItem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.data.marshal.Json": {},
      "qx.ui.tree.core.Util": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.tree.virtual.UtilTest", {
    extend: qx.dev.unit.TestCase,
    members: {
      model: null,
      setUp: function setUp() {
        var rawData = {
          name: "Root",
          kids: [{
            name: "Node1",
            kids: [{
              name: "Leaf1.1"
            }]
          }, {
            name: "Node2",
            kids: []
          }, {
            name: "Node3",
            kids: null
          }, {
            name: "Leaf1"
          }, {
            name: "Leaf2"
          }]
        };
        this.model = qx.data.marshal.Json.createModel(rawData);
      },
      tearDown: function tearDown() {
        this.model.dispose();
        this.model = null;
      },
      "test isNode with nodes and leafs": function testIsNodeWithNodesAndLeafs() {
        var model = this.model;
        this.assertTrue(qx.ui.tree.core.Util.isNode(model, "kids"));
        var children = model.getKids();

        for (var i = 0, l = children.getLength(); i < l; i++) {
          var item = children.getItem(i);
          var result = qx.ui.tree.core.Util.isNode(item, "kids");

          if (item.getKids !== undefined) {
            this.assertTrue(result);
          } else {
            this.assertFalse(result);
          }
        }
      },
      "test isNode with invalid child property": function testIsNodeWithInvalidChildProperty() {
        this.assertFalse(qx.ui.tree.core.Util.isNode(this.model, "noChildProperty"));
      },
      "test isNode with null calls": function testIsNodeWithNullCalls() {
        this.assertFalse(qx.ui.tree.core.Util.isNode(null, "kids"));
        this.assertFalse(qx.ui.tree.core.Util.isNode(this.model, null));
        this.assertFalse(qx.ui.tree.core.Util.isNode(null, null));
      },
      "test hasChildren with leafs": function testHasChildrenWithLeafs() {
        var model = this.model;
        var children = model.getKids();
        this.assertTrue(qx.ui.tree.core.Util.hasChildren(model, "kids"));
        this.assertTrue(qx.ui.tree.core.Util.hasChildren(children.getItem(0), "kids"));
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(children.getItem(1), "kids"));
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(children.getItem(2), "kids"));
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(children.getItem(3), "kids"));
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(children.getItem(4), "kids"));
      },
      "test hasChildren and ignore leafs": function testHasChildrenAndIgnoreLeafs() {
        var model = this.model;
        var children = model.getKids();
        this.assertTrue(qx.ui.tree.core.Util.hasChildren(model, "kids", true));
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(children.getItem(0), "kids", true));
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(children.getItem(1), "kids", true));
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(children.getItem(2), "kids", true));
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(children.getItem(3), "kids", true));
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(children.getItem(4), "kids", true));
      },
      "test hasChildren with invalid child property": function testHasChildrenWithInvalidChildProperty() {
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(this.model, "noChildProperty"));
      },
      "test hasChildren with null calls": function testHasChildrenWithNullCalls() {
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(null, "kids"));
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(this.model, null));
        this.assertFalse(qx.ui.tree.core.Util.hasChildren(null, null));
      }
    }
  });
  qx.test.ui.tree.virtual.UtilTest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.tree.core.IVirtualTree": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.data.marshal.Json": {},
      "qx.ui.tree.provider.WidgetProvider": {},
      "qx.ui.virtual.layer.WidgetCell": {},
      "qx.ui.tree.VirtualTreeItem": {},
      "qx.data.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.tree.virtual.WidgetProvider", {
    extend: qx.dev.unit.TestCase,
    implement: qx.ui.tree.core.IVirtualTree,
    include: qx.dev.unit.MMock,
    properties: {
      openProperty: {
        check: "String",
        init: null
      }
    },
    members: {
      model: null,
      provider: null,
      lookupTable: null,
      selection: null,
      setUp: function setUp() {
        var rawData = {
          name: "Root",
          icon: "Root",
          kids: [{
            name: "Node1",
            icon: "Node1",
            kids: []
          }, {
            name: "Node2",
            icon: "Node2",
            kids: []
          }, {
            name: "Leaf1",
            icon: "Leaf1"
          }, {
            name: "Leaf2",
            icon: "Leaf2"
          }]
        };
        this.model = qx.data.marshal.Json.createModel(rawData);
        this.provider = new qx.ui.tree.provider.WidgetProvider(this);
        this.provider.setLabelPath("name");
        this.provider.setIconPath("icon");
        this.provider.setChildProperty("kids");
      },
      tearDown: function tearDown() {
        this.provider.dispose();
        this.provider = null;

        for (var i = 0; i < this.model.getKids().getLength(); i++) {
          this.model.getKids().getItem(i).dispose();
        }

        this.model.dispose();
        this.model = null;

        if (this.lookupTable != null) {
          this.lookupTable.dispose();
          this.lookupTable = null;
        }

        if (this.selection != null) {
          this.selection.dispose();
          this.selection = null;
        }
      },
      testCreation: function testCreation() {
        this.provider.dispose();
        this.provider = new qx.ui.tree.provider.WidgetProvider(this);
        this.assertNull(this.provider.getChildProperty(), "Initial 'childProperty' property value is wrong!");
        this.assertNull(this.provider.getLabelPath(), "Initial 'labelPath' property value is wrong!");
        this.assertNull(this.provider.getIconPath(), "Initial 'iconPath' property value is wrong!");
      },
      testCreateLayer: function testCreateLayer() {
        var layer = this.provider.createLayer();
        this.assertInstance(layer, qx.ui.virtual.layer.WidgetCell);
        layer.dispose();
      },
      testGetRootNodeWidget: function testGetRootNodeWidget() {
        var spyBinding = this.spy(this.provider, "_bindItem");
        var spySelection = this.spy(this.provider, "_styleUnselectabled");
        var widget = this.provider.getCellWidget(0, 0);
        this.assertInstance(widget, qx.ui.tree.VirtualTreeItem);
        this.assertTrue(widget.hasChildren());
        this.assertTrue(widget.getUserData("cell.showLeafs"));
        this.assertTrue(widget.getUserData("cell.showLeafs"));
        this.assertEquals(0, widget.getUserData("cell.level"));
        this.assertTrue(widget.isOpen());
        this.assertTrue(widget.hasListener("changeOpen"));
        this.assertCalledOnce(spyBinding);
        this.assertCalledWith(spyBinding, widget, 0);
        this.assertCalledOnce(spySelection);
        this.assertCalledWith(spySelection, widget);
        widget.dispose();
      },
      testGetNodeWidget: function testGetNodeWidget() {
        var spyBinding = this.spy(this.provider, "_bindItem");
        var spySelection = this.spy(this.provider, "_styleUnselectabled");
        var widget = this.provider.getCellWidget(1, 0);
        this.assertInstance(widget, qx.ui.tree.VirtualTreeItem);
        this.assertFalse(widget.hasChildren());
        this.assertTrue(widget.getUserData("cell.showLeafs"));
        this.assertEquals(1, widget.getUserData("cell.level"));
        this.assertFalse(widget.isOpen());
        this.assertTrue(widget.hasListener("changeOpen"));
        this.assertCalledOnce(spyBinding);
        this.assertCalledWith(spyBinding, widget, 1);
        this.assertCalledOnce(spySelection);
        this.assertCalledWith(spySelection, widget);
        widget.dispose();
      },
      testGetLeafWidget: function testGetLeafWidget() {
        var spyBinding = this.spy(this.provider, "_bindItem");
        var spySelection = this.spy(this.provider, "_styleUnselectabled");
        var widget = this.provider.getCellWidget(3, 0);
        this.assertInstance(widget, qx.ui.tree.VirtualTreeItem);
        this.assertFalse(widget.hasChildren());
        this.assertTrue(widget.getUserData("cell.showLeafs"));
        this.assertEquals(1, widget.getUserData("cell.level"));
        this.assertFalse(widget.isOpen());
        this.assertTrue(widget.hasListener("changeOpen"));
        this.assertCalledOnce(spyBinding);
        this.assertCalledWith(spyBinding, widget, 3);
        this.assertCalledOnce(spySelection);
        this.assertCalledWith(spySelection, widget);
        widget.dispose();
      },
      testPoolWidget: function testPoolWidget() {
        var widget = this.provider.getCellWidget(3, 0);
        var spyPool = this.spy(this.provider._renderer, "pool");
        var spyBinding = this.spy(this.provider, "_removeBindingsFrom");
        this.provider.poolCellWidget(widget);
        this.assertCalledOnce(spyPool);
        this.assertCalledWith(spyPool, widget);
        this.assertCalledOnce(spyBinding);
        this.assertCalledWith(spyBinding, widget);
        widget.dispose();
      },
      testDefaultNodeBinding: function testDefaultNodeBinding() {
        var widget = new qx.ui.tree.VirtualTreeItem();

        this.provider._bindItem(widget, 0);

        this.assertEquals(4, this.getLookupTable().getBindings().length, "Bindings count not correct!");
        this.assertEquals("Root", widget.getLabel());
        this.assertEquals("Root", widget.getIcon());
        this.assertEquals("virtual-tree-folder", widget.getAppearance());
        this.assertEquals(this.model, widget.getModel());

        this.provider._bindItem(widget, 1);

        this.assertEquals(8, this.getLookupTable().getBindings().length, "Bindings count not correct!");
        this.assertEquals("Node1", widget.getLabel());
        this.assertEquals("Node1", widget.getIcon());
        this.assertEquals("virtual-tree-folder", widget.getAppearance());
        this.assertEquals(this.model.getKids().getItem(0), widget.getModel());
        widget.dispose();
      },
      testDefaultLeafBinding: function testDefaultLeafBinding() {
        var widget = new qx.ui.tree.VirtualTreeItem();

        this.provider._bindItem(widget, 3);

        this.assertEquals(3, this.getLookupTable().getBindings().length, "Bindings count not correct!");
        this.assertEquals("Leaf1", widget.getLabel());
        this.assertEquals("Leaf1", widget.getIcon());
        this.assertEquals("virtual-tree-file", widget.getAppearance());
        this.assertEquals(this.model.getKids().getItem(2), widget.getModel());
        widget.dispose();
      },
      testRemoveBindingsFromNode: function testRemoveBindingsFromNode() {
        var widget = new qx.ui.tree.VirtualTreeItem();
        var oldWidgetBindungs = widget.getBindings().length;
        var oldModelBindungs = this.getLookupTable().getBindings().length;

        this.provider._bindItem(widget, 0);

        this.provider._removeBindingsFrom(widget);

        var newWidgetBindungs = widget.getBindings().length;
        var newModelBindungs = this.getLookupTable().getBindings().length;
        this.assertEquals(oldWidgetBindungs, newWidgetBindungs, "Binding on widget is not removed!");
        this.assertEquals(oldModelBindungs, newModelBindungs, "Binding on model is not removed!");
        widget.dispose();
      },
      testReverseBinding: function testReverseBinding() {
        var widget = new qx.ui.tree.VirtualTreeItem();
        var oldWidgetBindungs = widget.getBindings().length;
        var oldModelBindungs = this.getLookupTable().getBindings().length;
        this.provider.bindPropertyReverse("name", "label", null, widget, 0);
        widget.setLabel("ort-zerreiber");
        this.assertEquals("ort-zerreiber", this.model.getName());

        this.provider._removeBindingsFrom(widget);

        var newWidgetBindungs = widget.getBindings().length;
        var newModelBindungs = this.getLookupTable().getBindings().length;
        this.assertEquals(oldWidgetBindungs, newWidgetBindungs, "Binding on widget is not removed!");
        this.assertEquals(oldModelBindungs, newModelBindungs, "Binding on model is not removed!");
        widget.dispose();
      },
      testRemoveAllBindings: function testRemoveAllBindings() {
        var widget1 = new qx.ui.tree.VirtualTreeItem();
        var widget2 = new qx.ui.tree.VirtualTreeItem();
        var oldWidget1Bindungs = widget1.getBindings().length;
        var oldWidget2Bindungs = widget2.getBindings().length;
        var oldModelBindungs = this.getLookupTable().getBindings().length;
        this.provider.bindProperty("name", "label", null, widget1, 0);
        this.provider.bindProperty("name", "label", null, widget2, 1);
        this.provider.bindPropertyReverse("name", "label", null, widget1, 0);
        this.provider.bindPropertyReverse("name", "label", null, widget2, 1);
        this.provider.removeBindings();
        var newWidget1Bindungs = widget1.getBindings().length;
        var newWidget2Bindungs = widget2.getBindings().length;
        var newModelBindungs = this.getLookupTable().getBindings().length;
        this.assertEquals(oldWidget1Bindungs, newWidget1Bindungs, "Binding on first widget is not removed!");
        this.assertEquals(oldWidget1Bindungs, newWidget1Bindungs, "Binding on second widget is not removed!");
        this.assertEquals(oldModelBindungs, newModelBindungs, "Binding on model is not removed!");
        widget1.dispose();
        widget2.dispose();
      },
      testRemoveAllBindingsOnDispose: function testRemoveAllBindingsOnDispose() {
        var provider = new qx.ui.tree.provider.WidgetProvider(this);
        var spy = this.spy(provider, "removeBindings");
        provider.dispose();
        this.assertCalledOnce(spy);
      },
      testCreateItem: function testCreateItem() {
        var delegate = {
          createItem: function createItem() {
            return new qx.ui.tree.VirtualTreeItem();
          }
        };
        var spy = this.spy(delegate, "createItem");
        this.provider.setDelegate(delegate);
        var widget = this.provider.getCellWidget(4, 0);
        this.assertCalledOnce(spy);
        widget.dispose();
      },
      testConfigureItem: function testConfigureItem() {
        var delegate = {
          configureItem: function configureItem(leaf) {}
        };
        var spy = this.spy(delegate, "configureItem");
        this.provider.setDelegate(delegate);
        var widget = this.provider.getCellWidget(4, 0);
        this.assertCalledOnce(spy);
        this.assertCalledWith(spy, widget);
        widget.dispose();
      },
      testBindItem: function testBindItem() {
        var delegate = {
          bindItem: function bindItem(controller, leaf, id) {}
        };
        var spy = this.spy(delegate, "bindItem");
        this.provider.setDelegate(delegate);
        var widget = this.provider.getCellWidget(4, 0);
        this.assertCalledOnce(spy);
        this.assertCalledWith(spy, this.provider, widget, 4);
        widget.dispose();
      },
      testOnPool: function testOnPool() {
        var delegate = {
          onPool: function onPool(item) {}
        };
        var spy = this.spy(delegate, "onPool");
        this.provider.setDelegate(delegate);
        var widget = this.provider.getCellWidget(4, 0);
        this.provider.poolCellWidget(widget);
        this.assertCalledOnce(spy);
        this.assertCalledWith(spy, widget);
        widget.dispose();
      },

      /*
      ---------------------------------------------------------------------------
        MOCK API
      ---------------------------------------------------------------------------
      */
      isShowTopLevelOpenCloseIcons: function isShowTopLevelOpenCloseIcons() {
        return true;
      },
      isShowLeafs: function isShowLeafs() {
        return true;
      },
      getSelection: function getSelection() {
        if (this.selection != null) {
          return this.selection;
        }

        this.selection = new qx.data.Array();
        return this.selection;
      },
      getLookupTable: function getLookupTable() {
        if (this.lookupTable != null) {
          return this.lookupTable;
        }

        var model = this.model;
        this.lookupTable = new qx.data.Array([model]);

        for (var i = 0; i < model.getKids().getLength(); i++) {
          this.lookupTable.push(model.getKids().getItem(i));
        }

        return this.lookupTable;
      },
      isNode: function isNode(item) {
        var index = this.getLookupTable().indexOf(item);

        if (index == -1) {
          throw new Error("Item is not part of the model!");
        }

        if (index == 0 || index == 1 || index == 2) {
          return true;
        }

        return false;
      },
      isNodeOpen: function isNodeOpen(node) {
        var index = this.getLookupTable().indexOf(node);

        if (index == -1) {
          throw new Error("Node is not part of the model!");
        }

        if (node == this.model) {
          return true;
        }

        return false;
      },
      getLevel: function getLevel(row) {
        if (row > this.getLookupTable().getLength() || row < 0) {
          throw new Error("Row is not in range of the model!");
        }

        if (row == 0) {
          return 0;
        }

        return 1;
      },
      hasChildren: function hasChildren(node) {
        if (this.isNode(node)) {
          return node.getKids().getLength() > 0;
        } else {
          return false;
        }
      },
      openNode: function openNode(node) {},
      openNodeWithoutScrolling: function openNodeWithoutScrolling(node) {},
      closeNode: function closeNode(node) {},
      closeNodeWithoutScrolling: function closeNodeWithoutScrolling(node) {}
    }
  });
  qx.test.ui.tree.virtual.WidgetProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.virtual.core.Axis": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.Axis", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.defaultSize = 10;
        this.count = 1000;
        this.axis = new qx.ui.virtual.core.Axis(this.defaultSize, this.count);
      },
      tearDown: function tearDown() {
        this.axis.dispose();
      },
      assertItem: function assertItem(expectedItemIndex, expectedOffset, cellData, msg) {
        this.assertEquals(expectedItemIndex, cellData.index, msg + ": invalid item index");
        this.assertEquals(expectedOffset, cellData.offset, msg + ": invalid item offset");
      },
      testDefaultItemSize: function testDefaultItemSize() {
        this.assertEquals(this.defaultSize, this.axis.getDefaultItemSize());
        this.axis.setDefaultItemSize(20);
        this.assertEquals(20, this.axis.getDefaultItemSize());
      },
      testItemCount: function testItemCount() {
        this.assertEquals(this.count, this.axis.getItemCount());
        this.axis.setItemCount(this.count * 2);
        this.assertEquals(this.count * 2, this.axis.getItemCount());
      },
      testItemSize: function testItemSize() {
        var sizes = {};
        sizes[100] = 2;
        sizes[200] = 30;
        sizes[600] = this.defaultSize;

        for (var key in sizes) {
          this.axis.setItemSize(parseInt(key, 10), sizes[key]);
        }

        for (var i = 0; i < this.count; i++) {
          this.assertEquals(sizes[i] || this.defaultSize, this.axis.getItemSize(i));
        }

        this.axis.setDefaultItemSize(this.defaultSize * 2);

        for (var i = 0; i < this.count; i++) {
          this.assertEquals(sizes[i] || this.defaultSize * 2, this.axis.getItemSize(i));
        }
      },
      testItemAtPosition: function testItemAtPosition() {
        this.axis.setItemCount(1000);
        this.axis.setDefaultItemSize(10); // in the middle

        this.assertItem(500, 5, this.axis.getItemAtPosition(5005)); // position at the edge

        this.assertItem(0, 0, this.axis.getItemAtPosition(0));
        this.assertItem(999, 9, this.axis.getItemAtPosition(9999)); // position outside of the range

        this.assertNull(this.axis.getItemAtPosition(-10));
        this.assertNull(this.axis.getItemAtPosition(10000));
        this.assertNull(this.axis.getItemAtPosition(10100)); // special case: no items in the axis

        this.axis.setItemCount(0);
        this.assertNull(this.axis.getItemAtPosition(0));
      },
      testEmptyAxis: function testEmptyAxis() {
        this.axis.setItemSize(1, 10);
        this.axis.setItemCount(0);
        this.assertEquals(0, this.axis.getTotalSize());
      },
      testGetItemAtPositionCustomSizes: function testGetItemAtPositionCustomSizes() {
        var d = this.defaultSize;
        var sizes = {};
        sizes[100] = d - 8;
        sizes[200] = d + 20;
        sizes[600] = d;

        for (var key in sizes) {
          this.axis.setItemSize(parseInt(key, 10), sizes[key]);
        } // exact start position


        this.assertItem(0, 0, this.axis.getItemAtPosition(0 * d));
        this.assertItem(10, 0, this.axis.getItemAtPosition(10 * d));
        this.assertItem(101, 0, this.axis.getItemAtPosition(101 * d - 8));
        this.assertItem(201, 0, this.axis.getItemAtPosition(201 * d - 8 + 20));
        this.assertItem(601, 0, this.axis.getItemAtPosition(601 * d - 8 + 20)); // in the middle

        this.assertItem(0, 4, this.axis.getItemAtPosition(0 * d + 4));
        this.assertItem(10, 4, this.axis.getItemAtPosition(10 * d + 4));
        this.assertItem(101, 4, this.axis.getItemAtPosition(101 * d - 8 + 4));
        this.assertItem(201, 4, this.axis.getItemAtPosition(201 * d - 8 + 20 + 4));
        this.assertItem(601, 4, this.axis.getItemAtPosition(601 * d - 8 + 20 + 4)); //before end

        this.assertItem(0, d - 1, this.axis.getItemAtPosition(0 * d + d - 1));
        this.assertItem(10, d - 1, this.axis.getItemAtPosition(10 * d + d - 1));
        this.assertItem(101, d - 1, this.axis.getItemAtPosition(101 * d - 8 + d - 1));
        this.assertItem(201, d - 1, this.axis.getItemAtPosition(201 * d - 8 + 20 + d - 1));
        this.assertItem(601, d - 1, this.axis.getItemAtPosition(601 * d - 8 + 20 + d - 1));
      },
      ITEM_POS_ITER: 5,
      ITEM_POS_COUNT: 10000,
      testGetItemAtPositionStress: function testGetItemAtPositionStress() {
        for (var j = 0; j < this.ITEM_POS_ITER; j++) {
          var total = 0;
          this.axis.setItemCount(this.ITEM_POS_COUNT);

          for (var i = 0; i < this.ITEM_POS_COUNT; i++) {
            if (i == this.ITEM_POS_COUNT - 10) {
              var pos = total + 20;
            }

            var itemSize = 50 + Math.round(Math.random() * 80);
            total += itemSize;
            this.axis.setItemSize(i, itemSize);
          }

          this.assertItem(this.ITEM_POS_COUNT - 10, 20, this.axis.getItemAtPosition(pos));
        }
      },
      testGetTotalSize: function testGetTotalSize() {
        var d = this.defaultSize;
        var count = this.count;
        this.assertEquals(d * count, this.axis.getTotalSize());
        var correction = 0;

        for (var i = 1; i <= 10; i++) {
          this.axis.setItemSize(i * 10, d + i * 2);
          correction += i * 2;
        }

        this.assertEquals(d * count + correction, this.axis.getTotalSize());
      },
      TOTAL_SIZE_ITER: 5,
      // was 50
      TOTAL_SIZE_ITEMS: 100,
      // was 1000
      testGetTotalSizeStress: function testGetTotalSizeStress() {
        for (var j = 0; j < this.TOTAL_SIZE_ITER; j++) {
          var total = 0;
          this.axis.setItemCount(this.TOTAL_SIZE_ITEMS);

          for (var i = 0; i < this.TOTAL_SIZE_ITEMS; i++) {
            var itemSize = 50 + Math.round(Math.random() * 80);
            total += itemSize;
            this.axis.setItemSize(i, itemSize);
          }

          this.assertEquals(total, this.axis.getTotalSize());
        }
      },
      testGetItemSizes: function testGetItemSizes() {
        this.axis.setDefaultItemSize(10);
        this.assertArrayEquals([10, 10, 10, 10], this.axis.getItemSizes(0, 40));
        this.assertArrayEquals([10, 10, 10, 10], this.axis.getItemSizes(20, 40));
        this.assertArrayEquals([10, 10, 10, 10], this.axis.getItemSizes(0, 31));
        this.axis.setItemSize(1, 5);
        this.axis.setItemSize(3, 25);
        this.assertArrayEquals([10, 5, 10, 25], this.axis.getItemSizes(0, 50));
        this.assertArrayEquals([10, 5, 10, 25], this.axis.getItemSizes(0, 26));
        this.assertArrayEquals([5, 10, 25, 10], this.axis.getItemSizes(1, 41)); // test at the end of the scale

        this.axis.setDefaultItemSize(10);
        this.axis.setItemCount(10);
        this.assertArrayEquals([10, 10], this.axis.getItemSizes(8, 25));
        this.assertArrayEquals([10], this.axis.getItemSizes(9, 30));
      },
      testGetItemPosition: function testGetItemPosition() {
        var d = this.defaultSize; // item in the middle

        this.assertEquals(d * 20, this.axis.getItemPosition(20)); // item at the edges

        this.assertEquals(0, this.axis.getItemPosition(0));
        this.assertEquals(d * (this.count - 1), this.axis.getItemPosition(this.count - 1)); // item outside the range

        this.assertEquals(null, this.axis.getItemPosition(-1));
        this.assertEquals(null, this.axis.getItemPosition(this.count));
        this.assertEquals(null, this.axis.getItemPosition(this.count + 100));
      },
      testGetItemPositionCustomSizes: function testGetItemPositionCustomSizes() {
        var d = this.defaultSize;
        var sizes = {};
        sizes[100] = d - 8;
        sizes[200] = d + 20;
        sizes[600] = d;

        for (var key in sizes) {
          this.axis.setItemSize(parseInt(key, 10), sizes[key]);
        }

        this.assertEquals(0 * d, this.axis.getItemPosition(0));
        this.assertEquals(10 * d, this.axis.getItemPosition(10));
        this.assertEquals(101 * d - 8, this.axis.getItemPosition(101));
        this.assertEquals(201 * d - 8 + 20, this.axis.getItemPosition(201));
        this.assertEquals(601 * d - 8 + 20, this.axis.getItemPosition(601));
      },
      testChangeEvents: function testChangeEvents() {
        var self = this;

        var listener = function listener() {};

        this.assertEventFired(this.axis, "change", function () {
          self.axis.setDefaultItemSize(23);
        }, listener);
        this.assertEventNotFired(this.axis, "change", function () {
          self.axis.setDefaultItemSize(23);
        }, listener);
        this.assertEventFired(this.axis, "change", function () {
          self.axis.setItemCount(123);
        }, listener);
        this.assertEventNotFired(this.axis, "change", function () {
          self.axis.setItemCount(123);
        }, listener);
        this.assertEventFired(this.axis, "change", function () {
          self.axis.setItemSize(10, 66);
        }, listener);
        this.assertEventNotFired(this.axis, "change", function () {
          self.axis.setItemSize(10, 66);
        }, listener);
        this.assertEventFired(this.axis, "change", function () {
          self.axis.setItemSize(10, null);
        }, listener);
        this.assertEventNotFired(this.axis, "change", function () {
          self.axis.setItemSize(11, null);
        }, listener);
        this.assertEventFired(this.axis, "change", function () {
          self.axis.resetItemSizes();
        }, listener);
      },
      SETUP_ITER: 10,
      // was 100
      testPerformanceSetupBestCase: function testPerformanceSetupBestCase() {
        //window.top.console.profile("setup (best case)");
        var start = new Date();

        for (var i = 0; i < this.SETUP_ITER; i++) {
          this.axis.__ranges = null;
          this.axis.getItemAtPosition(0);
        }

        var end = new Date(); //window.top.console.profileEnd();
        // this.warn("setup time (best case): " + ((end - start) / this.SETUP_ITER) + "ms");
      },
      testPerformanceSetupWorstCase: function testPerformanceSetupWorstCase() {
        // each cell has a custom size
        for (var i = 0; i < this.count; i++) {
          this.axis.setItemSize(i, this.defaultSize + i % 20 + 1);
        } //window.top.console.profile("setup (worst case)");


        var start = new Date();

        for (var i = 0; i < this.SETUP_ITER; i++) {
          this.axis.__ranges = null;
          this.axis.getItemAtPosition(0);
        }

        var end = new Date(); //window.top.console.profileEnd();
        // this.warn("setup time (worst case): " + ((end - start) / this.SETUP_ITER) + "ms");
      },
      FIND_ITER: 100,
      // was 10000
      testPerformanceFindBestCase: function testPerformanceFindBestCase() {
        var max = this.axis.getTotalSize(); //window.top.console.profile("find (best case)");

        var start = new Date();

        for (var i = 0; i < this.FIND_ITER; i++) {
          this.axis.getItemAtPosition(i * 17 % max);
        }

        var end = new Date(); //window.top.console.profileEnd();
        // this.warn("find time (best case): " + ((end - start) / this.FIND_ITER) + "ms");
      },
      testPerformanceFindWorstCase: function testPerformanceFindWorstCase() {
        // each cell has a custom size
        for (var i = 0; i < this.count; i++) {
          this.axis.setItemSize(i, this.defaultSize + i % 20 + 1);
        }

        var max = this.axis.getTotalSize(); //window.top.console.profile("find (worst case)");

        var start = new Date();

        for (var i = 0; i < this.FIND_ITER; i++) {
          this.axis.getItemAtPosition(i * 17 % max);
        }

        var end = new Date(); //window.top.console.profileEnd();
        // this.warn("find time (worst case): " + ((end - start) / this.FIND_ITER) + "ms");
      }
    },
    destruct: function destruct() {
      this.axis = null;
    }
  });
  qx.test.ui.virtual.Axis.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.virtual.core.Pane": {},
      "qx.test.ui.virtual.layer.LayerMock": {},
      "qx.test.ui.virtual.layer.LayerSimple": {},
      "qx.test.ui.virtual.PointerEventMock": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.Pane", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        qx.test.ui.virtual.Pane.prototype.setUp.base.call(this);
        this.defaultWidth = 30;
        this.defaultHeight = 10;
        this.rowCount = 1000;
        this.colCount = 200;
        var pane = new qx.ui.virtual.core.Pane(this.rowCount, this.colCount, this.defaultHeight, this.defaultWidth);
        this.getRoot().add(pane);
        this.pane = pane;
      },
      tearDown: function tearDown() {
        this.pane.destroy();
        qx.test.ui.virtual.Pane.prototype.tearDown.base.call(this);
        this.flush();
      },
      assertUpdateArgs: function assertUpdateArgs(rowIndex, colIndex, rowSizes, colSizes, args, msg) {
        this.assertEquals(rowIndex, args[0], msg);
        this.assertEquals(colIndex, args[1], msg);
        this.assertArrayEquals(rowSizes, args[2], msg);
        this.assertArrayEquals(colSizes, args[3], msg);
      },
      assertScrollArgs: function assertScrollArgs(rowIndex, colIndex, rowSizes, colSizes, args, msg) {
        this.assertEquals(rowIndex, args[0], msg);
        this.assertEquals(colIndex, args[1], msg);
        this.assertArrayEquals(rowSizes, args[2], msg);
        this.assertArrayEquals(colSizes, args[3], msg);
      },
      assertScroll: function assertScroll(scrollTop, scrollLeft, pane, msg) {
        var layerContainer = this.pane._getChildren()[0];

        this.assertEquals(-scrollTop, layerContainer.getBounds().top, msg);
        this.assertEquals(-scrollLeft, layerContainer.getBounds().left, msg);
      },
      testConstructor: function testConstructor() {
        this.assertNotUndefined(this.pane);
      },
      testScrollProperties: function testScrollProperties() {
        this.flush();
        this.pane.setScrollY(30);
        this.assertEquals(30, this.pane.getScrollY());
        this.pane.setScrollX(40);
        this.assertEquals(40, this.pane.getScrollX());
      },
      testGetScrollSize: function testGetScrollSize() {
        var size = this.pane.getScrollSize();
        this.assertEquals(this.defaultWidth * this.colCount, size.width);
        this.assertEquals(this.defaultHeight * this.rowCount, size.height);
        var rowConfig = this.pane.getRowConfig();
        rowConfig.setDefaultItemSize(50);
        rowConfig.setItemCount(123);
        rowConfig.setItemSize(10, 30);
        this.assertEquals(6130, this.pane.getScrollSize().height);
      },
      testLayerAdd: function testLayerAdd() {
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.assertEquals(layer, this.pane.getLayers()[0]);
      },
      testUpdateEvent: function testUpdateEvent() {
        var called = 0;
        var pane = new qx.ui.virtual.core.Pane(100, 20, 10, 50);
        pane.addListener("update", function () {
          called++;
        }, this);
        pane.set({
          width: 300,
          height: 200
        }); // no update after creation

        this.getRoot().add(pane);
        this.assertEquals(0, called, "Expect no update after creation"); // one update after appear

        this.flush();
        this.assertEquals(1, called, "Expect one update after appear"); // one update after pane resize

        called = 0;
        pane.setWidth(400);
        this.flush();
        this.assertEquals(1, called, "Expect one update after pane resize"); // one update after data resize

        called = 0;
        pane.getRowConfig().setItemCount(200);
        this.flush();
        this.assertEquals(1, called, "Expect one update after data resize"); // one update after data and pane resize

        called = 0;
        pane.getRowConfig().setItemCount(300);
        pane.setWidth(500);
        this.flush();
        this.assertEquals(2, called, "Expect two updates after data and pane resize");
        pane.destroy();
      },
      testFullUpdate: function testFullUpdate() {
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.set({
          width: 100,
          height: 50
        });
        this.flush();
        layer.calls = [];
        this.pane.fullUpdate();
        this.flush();
        this.assertEquals(2, layer.calls.length);
        this.assertEquals("fullUpdate", layer.calls[0][0]);
        var args = layer.calls[0][1];
        this.assertUpdateArgs(0, 0, [10, 10, 10, 10, 10], [30, 30, 30, 30], args);
        this.assertScroll(0, 0, this.pane);
        this.pane.setScrollY(4);
        layer.calls = [];
        this.pane.fullUpdate();
        this.flush();
        var args = layer.calls[0][1];
        this.assertUpdateArgs(0, 0, [10, 10, 10, 10, 10, 10], [30, 30, 30, 30], args);
        this.assertScroll(4, 0, this.pane);
        this.pane.setScrollY(10);
        layer.calls = [];
        this.pane.fullUpdate();
        this.flush();
        var args = layer.calls[0][1];
        this.assertUpdateArgs(1, 0, [10, 10, 10, 10, 10], [30, 30, 30, 30], args);
        this.assertScroll(0, 0, this.pane);
        this.pane.setScrollY(16);
        layer.calls = [];
        this.pane.fullUpdate();
        this.flush();
        var args = layer.calls[0][1];
        this.assertUpdateArgs(1, 0, [10, 10, 10, 10, 10, 10], [30, 30, 30, 30], args);
        this.assertScroll(6, 0, this.pane);
        this.pane.setScrollY(0);
        this.flush();
        this.pane.setScrollX(4);
        layer.calls = [];
        this.pane.fullUpdate();
        this.flush();
        var args = layer.calls[0][1];
        this.assertUpdateArgs(0, 0, [10, 10, 10, 10, 10], [30, 30, 30, 30], args);
        this.assertScroll(0, 4, this.pane);
        this.pane.setScrollX(30);
        layer.calls = [];
        this.pane.fullUpdate();
        this.flush();
        var args = layer.calls[0][1];
        this.assertUpdateArgs(0, 1, [10, 10, 10, 10, 10], [30, 30, 30, 30], args);
        this.assertScroll(0, 0, this.pane);
        this.pane.setScrollX(36);
        layer.calls = [];
        this.pane.fullUpdate();
        this.flush();
        var args = layer.calls[0][1];
        this.assertUpdateArgs(0, 1, [10, 10, 10, 10, 10], [30, 30, 30, 30], args);
        this.assertScroll(0, 6, this.pane);
      },
      testNoRows: function testNoRows() {
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        layer.calls = [];
        this.pane.setWidth(100);
        this.pane.getColumnConfig().setDefaultItemSize(100);
        this.pane.getColumnConfig().setItemCount(1);
        this.pane.getRowConfig().setItemCount(0);
        this.flush();
        var args = layer.calls[0][1];
        this.assertUpdateArgs(0, 0, [], [100], args);
        this.assertScroll(0, 0, this.pane); // resize

        layer.calls = [];
        this.pane.setWidth(30);
        this.pane.getColumnConfig().setDefaultItemSize(30);
        this.flush();
        var args = layer.calls[0][1];
        this.assertUpdateArgs(0, 0, [], [30], args);
        this.assertScroll(0, 0, this.pane);
      },
      testNoColumns: function testNoColumns() {
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        layer.calls = [];
        this.pane.setHeight(100);
        this.pane.getRowConfig().setDefaultItemSize(100);
        this.pane.getRowConfig().setItemCount(1);
        this.pane.getColumnConfig().setItemCount(0);
        this.flush();
        var args = layer.calls[0][1];
        this.assertUpdateArgs(0, 0, [100], [], args);
        this.assertScroll(0, 0, this.pane); // resize

        layer.calls = [];
        this.pane.setHeight(30);
        this.pane.getRowConfig().setDefaultItemSize(30);
        this.flush();
        var args = layer.calls[0][1];
        this.assertUpdateArgs(0, 0, [30], [], args);
        this.assertScroll(0, 0, this.pane);
      },
      testPrefetchYAtTop: function testPrefetchYAtTop() {
        var layerHeight = 400;
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.set({
          width: 300,
          height: layerHeight
        });
        this.flush(); // scroll top is 0 and prefetch above

        this.pane.prefetchY(100, 200, 0, 0);
        this.flush();
        this.assertEquals(layerHeight, layer.getBounds().height);
        this.assertScroll(0, 0, this.pane);
      },
      testPrefetchYLimitedAtTop: function testPrefetchYLimitedAtTop() {
        var layerHeight = 400;
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.set({
          width: 300,
          height: layerHeight
        });
        this.flush(); // scroll top is 100 and prefetch above 200

        this.pane.setScrollY(100);
        this.pane.prefetchY(100, 200, 0, 0);
        this.flush();
        this.assertEquals(layerHeight + 100, layer.getBounds().height);
        this.assertScroll(100, 0, this.pane);
      },
      testPrefetchYAtBottom: function testPrefetchYAtBottom() {
        var layerHeight = 400;
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.set({
          width: 300,
          height: layerHeight
        });
        this.flush(); // scroll top to bottom and prefetch below 200

        this.pane.setScrollY(this.pane.getScrollMaxY());
        this.pane.prefetchY(0, 0, 100, 200);
        this.flush();
        this.assertEquals(layerHeight, layer.getBounds().height);
        this.assertScroll(0, 0, this.pane);
      },
      testPrefetchYLimitedAtBottom: function testPrefetchYLimitedAtBottom() {
        var layerHeight = 400;
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.set({
          width: 300,
          height: layerHeight
        });
        this.flush(); // scroll top to bottom and prefetch below 200

        this.pane.setScrollY(this.pane.getScrollMaxY() - 100);
        this.pane.prefetchY(0, 0, 100, 200);
        this.flush();
        this.assertEquals(layerHeight + 100, layer.getBounds().height);
        this.assertScroll(0, 0, this.pane);
      },
      testPrefetchYInMiddle: function testPrefetchYInMiddle() {
        var layerHeight = 400;
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.set({
          width: 300,
          height: layerHeight
        });
        this.flush(); // scroll top is 500 and prefetch above 200

        this.pane.setScrollY(500);
        this.pane.prefetchY(100, 200, 100, 200);
        this.flush();
        this.assertEquals(layerHeight + 400, layer.getBounds().height);
        this.assertScroll(200, 0, this.pane); // already prefetched 200 pixel above. Scrolling up 20px and prefetching
        // again should not change the layers

        this.pane.setScrollY(480);
        this.pane.prefetchY(100, 200, 100, 200);
        this.flush();
        this.assertEquals(layerHeight + 400, layer.getBounds().height);
        this.assertScroll(180, 0, this.pane); // scroll more than minAbove up. Prefetching should update the layers

        this.pane.setScrollY(390);
        this.pane.prefetchY(100, 200, 100, 200);
        this.flush();
        this.assertEquals(layerHeight + 400, layer.getBounds().height);
        this.assertScroll(200, 0, this.pane); // already prefetched 200 pixel below. Scrolling down 20px and prefetching
        // again should not change the layers

        this.pane.setScrollY(410);
        this.pane.prefetchY(100, 200, 100, 200);
        this.flush();
        this.assertEquals(layerHeight + 400, layer.getBounds().height);
        this.assertScroll(220, 0, this.pane); // scroll more than minBelow down. Prefetching should update the layers

        this.pane.setScrollY(520);
        this.pane.prefetchY(100, 200, 100, 200);
        this.flush();
        this.assertEquals(layerHeight + 400, layer.getBounds().height);
        this.assertScroll(200, 0, this.pane);
      },
      testPrefetchXAtLeft: function testPrefetchXAtLeft() {
        var layerWidth = 300;
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.set({
          width: layerWidth,
          height: 400
        });
        this.flush(); // scroll left is 0 and prefetch left

        this.pane.prefetchX(100, 200, 0, 0);
        this.flush();
        this.assertEquals(layerWidth, layer.getBounds().width);
        this.assertScroll(0, 0, this.pane);
      },
      testPrefetchXLimitedAtLeft: function testPrefetchXLimitedAtLeft() {
        var layerWidth = 300;
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.getColumnConfig().setDefaultItemSize(10);
        this.pane.set({
          width: layerWidth,
          height: 400
        });
        this.flush(); // scroll top is 100 and prefetch above 200

        this.pane.setScrollX(100);
        this.pane.prefetchX(100, 200, 0, 0);
        this.flush();
        this.assertEquals(layerWidth + 100, layer.getBounds().width);
        this.assertScroll(0, 100, this.pane);
      },
      testPrefetchXAtBottom: function testPrefetchXAtBottom() {
        var layerWidth = 300;
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.getColumnConfig().setDefaultItemSize(10);
        this.pane.set({
          width: layerWidth,
          height: 400
        });
        this.flush(); // scroll left to right and prefetch right 200

        this.pane.setScrollX(this.pane.getScrollMaxX());
        this.pane.prefetchX(0, 0, 100, 200);
        this.flush();
        this.assertEquals(layerWidth, layer.getBounds().width);
        this.assertScroll(0, 0, this.pane);
      },
      testPrefetchXLimitedAtBottom: function testPrefetchXLimitedAtBottom() {
        var layerWidth = 300;
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.getColumnConfig().setDefaultItemSize(10);
        this.pane.set({
          width: layerWidth,
          height: 400
        });
        this.flush(); // scroll left to right-100 and prefetch right 200

        this.pane.setScrollX(this.pane.getScrollMaxX() - 100);
        this.pane.prefetchX(0, 0, 100, 200);
        this.flush();
        this.assertEquals(layerWidth + 100, layer.getBounds().width);
        this.assertScroll(0, 0, this.pane);
      },
      testPrefetchXInMiddle: function testPrefetchXInMiddle() {
        var layerWidth = 300;
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.set({
          width: layerWidth,
          height: 400
        });
        this.pane.getColumnConfig().setDefaultItemSize(10);
        this.flush(); // scroll left is 500 and prefetch left 200

        this.pane.setScrollX(500);
        this.pane.prefetchX(100, 200, 100, 200);
        this.flush();
        this.assertEquals(layerWidth + 400, layer.getBounds().width);
        this.assertScroll(0, 200, this.pane); // already prefetched 200 pixel at the left. Scrolling left 20px and prefetching
        // again should not change the layers

        this.pane.setScrollX(480);
        this.pane.prefetchX(100, 200, 100, 200);
        this.flush();
        this.assertEquals(layerWidth + 400, layer.getBounds().width);
        this.assertScroll(0, 180, this.pane); // scroll more than minLeft left. Prefetching should update the layers

        this.pane.setScrollX(390);
        this.pane.prefetchX(100, 200, 100, 200);
        this.flush();
        this.assertEquals(layerWidth + 400, layer.getBounds().width);
        this.assertScroll(0, 200, this.pane); // already prefetched 200 pixel right. Scrolling right 20px and prefetching
        // again should not change the layers

        this.pane.setScrollX(410);
        this.pane.prefetchX(100, 200, 100, 200);
        this.flush();
        this.assertEquals(layerWidth + 400, layer.getBounds().width);
        this.assertScroll(0, 220, this.pane); // scroll more than minRight right. Prefetching should update the layers

        this.pane.setScrollX(520);
        this.pane.prefetchX(100, 200, 100, 200);
        this.flush();
        this.assertEquals(layerWidth + 400, layer.getBounds().width);
        this.assertScroll(0, 200, this.pane);
      },
      testUpdateLayerWindow: function testUpdateLayerWindow() {
        var layer = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(layer);
        this.pane.set({
          width: 100,
          height: 50
        });
        this.flush();
        layer.calls = [];
        this.pane.setScrollY(4);
        this.flush();
        this.assertEquals("updateLayerWindow", layer.calls[0][0]);
        var args = layer.calls[0][1];
        this.assertScrollArgs(0, 0, [10, 10, 10, 10, 10, 10], [30, 30, 30, 30], args);
        this.assertScroll(4, 0, this.pane);
        layer.calls = [];
        this.pane.setScrollY(5);
        this.flush();
        this.assertEquals(0, layer.calls.length);
        this.assertScroll(5, 0, this.pane);
        layer.calls = [];
        this.pane.setScrollY(10);
        this.flush();
        this.assertEquals(0, layer.calls.length);
        this.assertScroll(10, 0, this.pane);
        layer.calls = [];
        this.pane.setScrollY(16);
        this.flush();
        this.assertEquals("updateLayerWindow", layer.calls[0][0]);
        var args = layer.calls[0][1];
        this.assertScrollArgs(1, 0, [10, 10, 10, 10, 10, 10], [30, 30, 30, 30], args);
        this.assertScroll(6, 0, this.pane);
        this.pane.setScrollY(0);
        this.flush();
        layer.calls = [];
        this.pane.setScrollX(4);
        this.flush();
        this.assertEquals(0, layer.calls.length);
        this.assertScroll(0, 4, this.pane);
        layer.calls = [];
        this.pane.setScrollX(30);
        this.flush();
        this.assertEquals("updateLayerWindow", layer.calls[0][0]);
        var args = layer.calls[0][1];
        this.assertScrollArgs(0, 1, [10, 10, 10, 10, 10], [30, 30, 30, 30], args);
        this.assertScroll(0, 0, this.pane);
        layer.calls = [];
        this.pane.setScrollX(36);
        this.flush();
        this.assertEquals(0, layer.calls.length);
        this.assertScroll(0, 6, this.pane);
      },
      testSrollRowIntoView: function testSrollRowIntoView() {
        this.pane.set({
          width: 400,
          height: 305
        });
        this.pane.getColumnConfig().setItemCount(1);
        var layer = new qx.test.ui.virtual.layer.LayerSimple();
        this.pane.addLayer(layer);
        this.flush();
        this.pane.scrollRowIntoView(100);
        this.flush();
        var children = layer.getContentElement().getDomElement().childNodes;
        this.assertScroll(5, 0, this.pane);
        this.assertEquals("70 / 0", children[0].innerHTML);
        this.assertEquals("100 / 0", children[children.length - 1].innerHTML);
      },
      testSrollColumnIntoView: function testSrollColumnIntoView() {
        this.pane.set({
          width: 405,
          height: 305
        });
        this.pane.getRowConfig().setItemCount(1);
        var layer = new qx.test.ui.virtual.layer.LayerSimple();
        this.pane.addLayer(layer);
        this.flush();
        this.pane.scrollColumnIntoView(100);
        this.flush();
        var children = layer.getContentElement().getDomElement().childNodes;
        this.assertScroll(0, 15, this.pane);
        this.assertEquals("0 / 87", children[0].innerHTML);
        this.assertEquals("0 / 100", children[children.length - 1].innerHTML);
      },
      _testSrollRowIntoViewEdgeCase: function _testSrollRowIntoViewEdgeCase() {
        this.pane.set({
          width: 400,
          height: 305
        });
        this.pane.getColumnConfig().setItemCount(1);
        var layer = new qx.test.ui.virtual.layer.LayerSimple();
        this.pane.addLayer(layer);
        this.flush();
        this.pane.scrollRowIntoView(2000);
        this.flush();
        var children = layer.getContentElement().getDomElement().childNodes;
        this.assertScroll(5, 0, this.pane);
        this.assertEquals("0 / 969", children[0].innerHTML);
        this.assertEquals("0 / 999", children[children.length - 1].innerHTML);
      },
      _testSrollColumnIntoViewEdgeCase: function _testSrollColumnIntoViewEdgeCase() {
        this.pane.set({
          width: 405,
          height: 305
        });
        this.pane.getRowConfig().setItemCount(1);
        var layer = new qx.test.ui.virtual.layer.LayerSimple();
        this.pane.addLayer(layer);
        this.flush();
        this.pane.scrollColumnIntoView(400);
        this.flush();
        var children = layer.getContentElement().getDomElement().childNodes;
        this.assertScroll(0, 15, this.pane);
        this.assertEquals("186 / 0", children[0].innerHTML);
        this.assertEquals("199 / 0", children[children.length - 1].innerHTML);
      },
      testGetCellAtPosition: function testGetCellAtPosition() {
        this.pane.getRowConfig().setItemCount(3);
        this.pane.getColumnConfig().setItemCount(3);
        var layer = new qx.test.ui.virtual.layer.LayerSimple();
        this.pane.addLayer(layer);
        this.flush();
        this.assertJsonEquals({
          row: 0,
          column: 0
        }, this.pane.getCellAtPosition(0, 0));
        this.assertEquals(null, this.pane.getCellAtPosition(400, 0));
        this.assertEquals(null, this.pane.getCellAtPosition(0, 300));
        this.assertEquals(null, this.pane.getCellAtPosition(400, 300));
        this.assertJsonEquals({
          row: 2,
          column: 2
        }, this.pane.getCellAtPosition(89, 29));
      },
      testGetItemAtPositionEmptySpace: function testGetItemAtPositionEmptySpace() {
        var pane = this.pane;
        pane.setHeight(100);
        pane.setWidth(50);
        this.pane.getRowConfig().setItemCount(1);
        this.pane.getRowConfig().setDefaultItemSize(50);
        this.flush();
        this.assertJsonEquals({
          row: 0,
          column: 0
        }, this.pane.getCellAtPosition(1, 49));
        this.assertEquals(null, this.pane.getCellAtPosition(1, 50));
        this.assertEquals(null, this.pane.getCellAtPosition(1, 70));
      },
      testMouseCellEvents: function testMouseCellEvents() {
        var rowCount = 2;
        var colCount = 2;
        var defaultHeight = 10;
        var defaultWidth = 50;
        var pane = new qx.ui.virtual.core.Pane(rowCount, colCount, defaultHeight, defaultWidth).set({
          width: 150,
          height: 30
        });
        this.getRoot().add(pane, {
          left: 100,
          top: 100
        });
        this.flush();
        var calls = [];

        var listener = function listener(e) {
          calls.push(e);
        };

        pane.addListener("cellTap", listener);
        pane.addListener("cellDbltap", listener);
        pane.addListener("cellContextmenu", listener);
        var PointerEventMock = qx.test.ui.virtual.PointerEventMock;
        var eventPointerToCellEvents = {
          "tap": "cellTap",
          "dbltap": "cellDbltap",
          "contextmenu": "cellContextmenu"
        };

        for (var pointerEvent in eventPointerToCellEvents) {
          var cellEvent = eventPointerToCellEvents[pointerEvent];
          calls = [];
          pane.dispatchEvent(new PointerEventMock("pointerdown", {
            documentLeft: 99,
            documentTop: 99
          }));
          pane.dispatchEvent(new PointerEventMock(pointerEvent, {
            documentLeft: 99,
            documentTop: 99
          }));
          this.assertEquals(0, calls.length);
          calls = [];
          pane.dispatchEvent(new PointerEventMock("pointerdown", {
            documentLeft: 100,
            documentTop: 100
          }));
          pane.dispatchEvent(new PointerEventMock(pointerEvent, {
            documentLeft: 100,
            documentTop: 100
          }));
          this.assertEquals(1, calls.length, cellEvent);
          this.assertEquals(0, calls[0].getRow(), cellEvent);
          this.assertEquals(0, calls[0].getColumn(), cellEvent);
          this.assertEquals(cellEvent, calls[0].getType(), cellEvent);
          calls = [];
          pane.dispatchEvent(new PointerEventMock("pointerdown", {
            documentLeft: 160,
            documentTop: 103
          }));
          pane.dispatchEvent(new PointerEventMock(pointerEvent, {
            documentLeft: 160,
            documentTop: 103
          }));
          this.assertEquals(1, calls.length, cellEvent);
          this.assertEquals(0, calls[0].getRow(), cellEvent);
          this.assertEquals(1, calls[0].getColumn(), cellEvent);
          this.assertEquals(cellEvent, calls[0].getType(), cellEvent);
          calls = [];
          pane.dispatchEvent(new PointerEventMock("pointerdown", {
            documentLeft: 105,
            documentTop: 110
          }));
          pane.dispatchEvent(new PointerEventMock(pointerEvent, {
            documentLeft: 105,
            documentTop: 110
          }));
          this.assertEquals(1, calls.length, cellEvent);
          this.assertEquals(1, calls[0].getRow(), cellEvent);
          this.assertEquals(0, calls[0].getColumn(), cellEvent);
          this.assertEquals(cellEvent, calls[0].getType(), cellEvent);
          calls = [];
          pane.dispatchEvent(new PointerEventMock("pointerdown", {
            documentLeft: 105,
            documentTop: 125
          }));
          pane.dispatchEvent(new PointerEventMock(pointerEvent, {
            documentLeft: 105,
            documentTop: 125
          }));
          this.assertEquals(0, calls.length);
          calls = [];
          pane.dispatchEvent(new PointerEventMock("pointerdown", {
            documentLeft: 275,
            documentTop: 105
          }));
          pane.dispatchEvent(new PointerEventMock(pointerEvent, {
            documentLeft: 275,
            documentTop: 105
          }));
          this.assertEquals(0, calls.length);
          calls = [];
          pane.dispatchEvent(new PointerEventMock("pointerdown", {
            documentLeft: 275,
            documentTop: 105
          }));
          pane.dispatchEvent(new PointerEventMock(pointerEvent, {
            documentLeft: 275,
            documentTop: 105
          }));
          this.assertEquals(0, calls.length);
        }

        pane.destroy();
        this.flush();
      },
      "test mouse click bug #6695": function testMouseClickBug6695() {
        var rowCount = 2;
        var colCount = 2;
        var defaultHeight = 10;
        var defaultWidth = 50;
        var pane = new qx.ui.virtual.core.Pane(rowCount, colCount, defaultHeight, defaultWidth).set({
          width: 150,
          height: 30
        });
        this.getRoot().add(pane, {
          left: 100,
          top: 100
        });
        this.flush();
        var calls = [];

        var listener = function listener(e) {
          calls.push(e);
        };

        pane.addListener("cellTap", listener);
        var PointerEventMock = qx.test.ui.virtual.PointerEventMock;
        calls = [];
        pane.dispatchEvent(new PointerEventMock("pointerdown", {
          documentLeft: 100,
          documentTop: 100
        }));
        pane.dispatchEvent(new PointerEventMock("tap", {
          documentLeft: 100,
          documentTop: 100
        }));
        this.assertEquals(1, calls.length);
        this.assertEquals(0, calls[0].getRow());
        this.assertEquals(0, calls[0].getColumn());
        this.assertEquals("cellTap", calls[0].getType());
        calls = [];
        pane.dispatchEvent(new PointerEventMock("pointerdown", {
          documentLeft: 100,
          documentTop: 100
        }));
        pane.dispatchEvent(new PointerEventMock("tap", {
          documentLeft: 160,
          documentTop: 103
        }));
        this.assertEquals(0, calls.length);
        pane.destroy();
        this.flush();
      },
      testDestroy: function testDestroy() {
        this.pane.destroy();
        this.flush();
        this.assertDestroy(function () {
          var pane = new qx.ui.virtual.core.Pane(this.rowCount, this.colCount, this.defaultHeight, this.defaultWidth);
          this.getRoot().add(pane);
          pane.destroy();
        }, this);
      }
    },
    destruct: function destruct() {
      this.pane = null;
    }
  });
  qx.test.ui.virtual.Pane.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.LayerMock", {
    extend: qx.ui.virtual.layer.Abstract,
    construct: function construct() {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this.calls = [];
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      updateLayerData: function updateLayerData() {
        this.calls.push(["updateLayerData", qx.lang.Array.fromArguments(arguments)]);
        qx.test.ui.virtual.layer.LayerMock.prototype.updateLayerData.base.call(this);
      },
      _updateLayerData: function _updateLayerData() {
        this.calls.push(["_updateLayerData", qx.lang.Array.fromArguments(arguments)]);
      },
      fullUpdate: function fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        this.calls.push(["fullUpdate", qx.lang.Array.fromArguments(arguments)]);
        qx.test.ui.virtual.layer.LayerMock.prototype.fullUpdate.base.call(this, firstRow, firstColumn, rowSizes, columnSizes);
      },
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        this.calls.push(["_fullUpdate", qx.lang.Array.fromArguments(arguments)]);
      },
      updateLayerWindow: function updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        this.calls.push(["updateLayerWindow", qx.lang.Array.fromArguments(arguments)]);
        qx.test.ui.virtual.layer.LayerMock.prototype.updateLayerWindow.base.call(this, firstRow, firstColumn, rowSizes, columnSizes);
      },
      _updateLayerWindow: function _updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        this.calls.push(["_updateLayerWindow", qx.lang.Array.fromArguments(arguments)]);
      }
    }
  });
  qx.test.ui.virtual.layer.LayerMock.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fabian Jakobs (fjakobs)
     * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.LayerSimple", {
    extend: qx.ui.virtual.layer.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      getCellHtml: function getCellHtml(row, column, left, top, width, height) {
        var content = row + " / " + column;
        return ["<div style='position:absolute;", "left:", left, "px;", "top:", top, "px;", "width:", width, "px;", "height:", height, "px;", "'>", content, "</div>"].join("");
      },
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];
        var left = 0;
        var top = 0;
        var row = firstRow;
        var col = firstColumn;

        for (var x = 0; x < rowSizes.length; x++) {
          var left = 0;
          var col = firstColumn;
          var height = rowSizes[x];

          for (var y = 0; y < columnSizes.length; y++) {
            var width = columnSizes[y];
            html[html.length] = this.getCellHtml(row, col, left, top, width, height);
            col++;
            left += width;
          }

          top += height;
          row++;
        }

        this.getContentElement().setAttribute("html", html.join(""));
      }
    }
  });
  qx.test.ui.virtual.layer.LayerSimple.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.type.Pointer": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.PointerEventMock", {
    extend: qx.event.type.Pointer,
    construct: function construct(type, config) {
      qx.event.type.Pointer.constructor.call(this);
      this.setType(type);
      this.__config = config;
    },
    members: {
      clone: function clone() {
        return this;
      },
      getDocumentLeft: function getDocumentLeft() {
        return this.__config.documentLeft || 0;
      },
      getDocumentTop: function getDocumentTop() {
        return this.__config.documentTop || 0;
      }
    },
    destruct: function destruct() {
      this.__config = null;
    }
  });
  qx.test.ui.virtual.PointerEventMock.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.virtual.core.Pane": {},
      "qx.test.ui.virtual.layer.LayerMock": {},
      "qx.ui.core.queue.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This class tests all combinations of events, which could trigger pane and
   * layer updates
   *
   * <pre>
   *   Initial   Axis    Window   Data
   * |X        |       |        |        |fullUpdate|
   * |X        |       |        |X       |fullUpdate|
   * |X        |       |X       |        |fullUpdate|
   * |X        |       |X       |X       |fullUpdate|
   * |X        |X      |        |        |fullUpdate|
   * |X        |X      |        |X       |fullUpdate|
   * |X        |X      |X       |        |fullUpdate|
   * |X        |X      |X       |X       |fullUpdate|
   * |         |X      |        |        |fullUpdate|
   * |         |X      |        |X       |fullUpdate|
   * |         |X      |X       |        |fullUpdate|
   * |         |X      |X       |X       |fullUpdate|
   * |         |       |X       |        |updateLayerWindow|
   * |         |       |X       |X       |fullUpdate|
   * |         |       |        |X       |updateData|
   * </pre>
   */
  qx.Class.define("qx.test.ui.virtual.PaneUpdate", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.pane = new qx.ui.virtual.core.Pane(100, 30, 20, 60);
        this.layer1 = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(this.layer1);
        this.layer2 = new qx.test.ui.virtual.layer.LayerMock();
        this.pane.addLayer(this.layer2);
        this.getRoot().add(this.pane);
      },
      tearDown: function tearDown() {
        qx.test.ui.virtual.PaneUpdate.prototype.tearDown.base.call(this);
        this.pane.destroy();
      },
      assertCalls: function assertCalls(methodNames, calls, msg) {
        this.assertEquals(methodNames.length, calls.length);

        for (var i = 0; i < methodNames.length; i++) {
          this.assertEquals(methodNames[i], calls[i][0]);
        }
      },
      resetCalls: function resetCalls() {
        this.layer1.calls = [];
        this.layer2.calls = [];
      },
      testNoUpdateBeforeAppear: function testNoUpdateBeforeAppear() {
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls); // full update

        this.pane.fullUpdate();
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls); // be nasty and only flush the widget queue

        this.resetCalls();
        qx.ui.core.queue.Widget.flush();
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls); // scroll

        this.pane.setScrollX(20);
        this.pane.setScrollY(100);
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls); // be nasty and only flush the widget queue

        this.resetCalls();
        qx.ui.core.queue.Widget.flush();
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls); // full flush

        this.resetCalls();
        this.flush();
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testInitial: function testInitial() {
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.flush();
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testInitialData: function testInitialData() {
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.pane.getRowConfig().setItemCount(123);
        this.layer1.updateLayerData();
        this.layer2.updateLayerData();
        this.flush();
        this.assertCalls(["updateLayerData", "fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["updateLayerData", "fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testInitialWindow: function testInitialWindow() {
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.pane.getRowConfig().setItemCount(123);
        this.pane.setScrollX(20);
        this.pane.setScrollY(30);
        this.flush();
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testInitialWindowData: function testInitialWindowData() {
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.pane.getRowConfig().setItemCount(123);
        this.layer1.updateLayerData();
        this.layer2.updateLayerData();
        this.pane.setScrollX(20);
        this.pane.setScrollY(30);
        this.flush();
        this.assertCalls(["updateLayerData", "fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["updateLayerData", "fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testInitialAxis: function testInitialAxis() {
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.pane.getRowConfig().setItemCount(123);
        this.flush();
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testInitialAxisData: function testInitialAxisData() {
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.pane.getRowConfig().setItemCount(123);
        this.layer1.updateLayerData();
        this.layer2.updateLayerData();
        this.flush();
        this.assertCalls(["updateLayerData", "fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["updateLayerData", "fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testInitialAxisWindow: function testInitialAxisWindow() {
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.pane.getRowConfig().setItemCount(123);
        this.pane.setScrollX(20);
        this.pane.setScrollY(30);
        this.flush();
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testInitialAxisWindowData: function testInitialAxisWindowData() {
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.pane.getRowConfig().setItemCount(123);
        this.pane.setScrollX(20);
        this.pane.setScrollY(30);
        this.layer1.updateLayerData();
        this.layer2.updateLayerData();
        this.flush();
        this.assertCalls(["updateLayerData", "fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["updateLayerData", "fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testAxis: function testAxis() {
        this.flush();
        this.resetCalls();
        this.pane.getRowConfig().setItemCount(123);
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.resetCalls();
        this.flush();
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testAxisData: function testAxisData() {
        this.flush();
        this.resetCalls();
        this.pane.getRowConfig().setItemCount(123);
        this.layer1.updateLayerData();
        this.layer2.updateLayerData();
        this.assertCalls(["updateLayerData"], this.layer1.calls);
        this.assertCalls(["updateLayerData"], this.layer2.calls);
        this.resetCalls();
        this.flush();
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testAxisWindow: function testAxisWindow() {
        this.flush();
        this.resetCalls();
        this.pane.getRowConfig().setItemCount(123);
        this.pane.setScrollX(20);
        this.pane.setScrollY(30);
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.resetCalls();
        this.flush();
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testAxisWindowData: function testAxisWindowData() {
        this.flush();
        this.resetCalls();
        this.pane.getRowConfig().setItemCount(123);
        this.pane.setScrollX(20);
        this.pane.setScrollY(30);
        this.layer1.updateLayerData();
        this.layer2.updateLayerData();
        this.assertCalls(["updateLayerData"], this.layer1.calls);
        this.assertCalls(["updateLayerData"], this.layer2.calls);
        this.resetCalls();
        this.flush();
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["fullUpdate", "_fullUpdate"], this.layer2.calls);
      },
      testWindow: function testWindow() {
        this.flush();
        this.resetCalls();
        this.pane.setScrollX(20);
        this.pane.setScrollY(30);
        this.assertCalls([], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.resetCalls();
        this.flush();
        this.assertCalls(["updateLayerWindow", "_updateLayerWindow"], this.layer1.calls);
        this.assertCalls(["updateLayerWindow", "_updateLayerWindow"], this.layer2.calls);
      },
      testWindowData: function testWindowData() {
        this.flush();
        this.resetCalls();
        this.pane.setScrollX(20);
        this.pane.setScrollY(30);
        this.layer1.updateLayerData();
        this.layer2.updateLayerData();
        this.assertCalls(["updateLayerData"], this.layer1.calls);
        this.assertCalls(["updateLayerData"], this.layer2.calls);
        this.resetCalls();
        this.flush();
        this.assertCalls(["updateLayerWindow", "_fullUpdate"], this.layer1.calls);
        this.assertCalls(["updateLayerWindow", "_fullUpdate"], this.layer2.calls);
      },
      testData: function testData() {
        this.flush();
        this.resetCalls();
        this.layer1.updateLayerData();
        this.assertCalls(["updateLayerData"], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
        this.resetCalls();
        this.flush();
        this.assertCalls(["_updateLayerData"], this.layer1.calls);
        this.assertCalls([], this.layer2.calls);
      }
    }
  });
  qx.test.ui.virtual.PaneUpdate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.virtual.core.Scroller": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.Scroller", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        qx.test.ui.virtual.Scroller.prototype.setUp.base.call(this);
        var scroller = new qx.ui.virtual.core.Scroller(1, 1, 10, 10);
        this.getRoot().add(scroller);
        this.scroller = scroller;
        this.flush();
      },
      tearDown: function tearDown() {
        this.scroller.destroy();
        qx.test.ui.virtual.Scroller.prototype.tearDown.base.call(this);
        this.flush();
      },
      assertScrollbars: function assertScrollbars(hasScrollX, hasScrollY, msg) {
        this.assertEquals(hasScrollX, this.scroller.getChildControl("scrollbar-x").isVisible(), msg);
        this.assertEquals(hasScrollY, this.scroller.getChildControl("scrollbar-y").isVisible(), msg);
      },
      configureScroller: function configureScroller(scrollWidth, scrollHeight, width, height) {
        this.scroller.set({
          width: width,
          height: height
        });
        this.scroller.getPane().getRowConfig().setItemSize(0, scrollHeight);
        this.scroller.getPane().getColumnConfig().setItemSize(0, scrollWidth); // trigger update manually

        this.scroller.getPane().fullUpdate();
        this.flush();
      },
      testConstructor: function testConstructor() {
        this.assertNotUndefined(this.scroller);
      },
      testScrollX: function testScrollX() {
        this.scroller.setScrollbarY("off");
        this.configureScroller(3000, 2000, 300, 200);
        this.assertScrollbars(true, false);
        this.assertEquals(0, this.scroller.getScrollX());
        this.assertEquals(0, this.scroller.getPane().getScrollX());
        this.scroller.scrollToX(100);
        this.assertEquals(100, this.scroller.getScrollX());
        this.assertEquals(100, this.scroller.getPane().getScrollX());
        this.scroller.scrollToX(3000);
        this.assertEquals(2700, this.scroller.getScrollX());
        this.assertEquals(2700, this.scroller.getPane().getScrollX());
        this.configureScroller(3000, 2000, 3000, 2000);
        this.assertScrollbars(false, false);
        this.assertEquals(0, this.scroller.getScrollX());
        this.assertEquals(0, this.scroller.getPane().getScrollX());
      },
      testScrollY: function testScrollY() {
        this.scroller.setScrollbarX("off");
        this.configureScroller(3000, 2000, 300, 200);
        this.assertScrollbars(false, true);
        this.assertEquals(0, this.scroller.getScrollX());
        this.assertEquals(0, this.scroller.getPane().getScrollX());
        this.scroller.scrollToY(100);
        this.assertEquals(100, this.scroller.getScrollY());
        this.assertEquals(100, this.scroller.getPane().getScrollY());
        this.scroller.scrollToY(2000);
        this.assertEquals(1800, this.scroller.getScrollY());
        this.assertEquals(1800, this.scroller.getPane().getScrollY());
        this.configureScroller(3000, 2000, 3000, 2000);
        this.assertScrollbars(false, false);
        this.assertEquals(0, this.scroller.getScrollY());
        this.assertEquals(0, this.scroller.getPane().getScrollY());
      },
      testMaxScrollPosition: function testMaxScrollPosition() {
        this.scroller.setScrollbarX("off");
        this.configureScroller(3000, 2000, 300, 200);
        this.assertScrollbars(false, true); // scroll to end

        this.scroller.scrollToY(10000);
        this.assertEquals(1800, this.scroller.getScrollY()); // increase scroller size

        this.configureScroller(3000, 2000, 300, 400);
        this.assertEquals(1600, this.scroller.getScrollY(), "the scroll position must be limited to the max scroll position");
        this.assertEquals(1600, this.scroller.getPane().getScrollY(), "the scroll position must be limited to the max scroll position");
      },
      testScrollbarYAuto: function testScrollbarYAuto() {
        this.scroller.setScrollbarX("off");
        this.scroller.setScrollbarY("auto"); // pane and widget have equal size

        this.configureScroller(300, 200, 300, 200);
        this.assertScrollbars(false, false); // pane larger than widget

        this.configureScroller(300, 201, 300, 200);
        this.assertScrollbars(false, true); // widget larger than pane

        this.configureScroller(300, 201, 300, 202);
        this.assertScrollbars(false, false); // scroll y must be hidden all the time

        this.configureScroller(301, 200, 300, 200);
        this.assertScrollbars(false, false);
      },
      testScrollbarXAuto: function testScrollbarXAuto() {
        this.scroller.setScrollbarX("auto");
        this.scroller.setScrollbarY("off"); // pane and widget have equal size

        this.configureScroller(300, 200, 300, 200);
        this.assertScrollbars(false, false); // pane larger than widget

        this.configureScroller(301, 200, 300, 200);
        this.assertScrollbars(true, false); // widget larger than pane

        this.configureScroller(301, 200, 302, 200);
        this.assertScrollbars(false, false); // scroll x must be hidden all the time

        this.configureScroller(300, 201, 300, 200);
        this.assertScrollbars(false, false);
      },
      testScrollbarXYAuto: function testScrollbarXYAuto() {
        // pane and widget have equal size
        this.configureScroller(300, 200, 300, 200);
        this.assertScrollbars(false, false); // increase the pane a bit -> both scrollbars are needed

        this.configureScroller(301, 200, 300, 200);
        this.assertScrollbars(true, true); // reset

        this.configureScroller(300, 200, 300, 200);
        this.assertScrollbars(false, false);
        this.configureScroller(300, 201, 300, 200);
        this.assertScrollbars(true, true); // increase scroller height

        this.configureScroller(300, 201, 300, 250);
        this.assertScrollbars(false, false); // increase scroller width

        this.configureScroller(300, 201, 350, 250);
        this.assertScrollbars(false, false);
      }
    },
    destruct: function destruct() {
      this.scroller = null;
    }
  });
  qx.test.ui.virtual.Scroller.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.virtual.cell.WidgetCell": {},
      "qx.ui.form.ListItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/icon/${qx.icontheme}/22/emotes/face-angel.png)
   */
  qx.Class.define("qx.test.ui.virtual.cell.WidgetCell", {
    extend: qx.dev.unit.TestCase,
    members: {
      __cell: null,
      setUp: function setUp() {
        this.__cell = new qx.ui.virtual.cell.WidgetCell();
      },
      tearDown: function tearDown() {
        this.__cell.dispose();

        this.__cell = null;
      },
      testCreateWidget: function testCreateWidget() {
        var item = this.__cell.getCellWidget();

        this.assertQxWidget(item);
        item.dispose();
      },
      testCreateWidgetWithDelegate: function testCreateWidgetWithDelegate() {
        this.__setUpDelegate();

        var item = this.__cell.getCellWidget();

        this.assertInterface(item, qx.ui.form.ListItem);
        item.dispose();
      },
      testPoolOnDelegateChange: function testPoolOnDelegateChange() {
        var item1 = this.__cell.getCellWidget();

        this.assertQxWidget(item1);

        var item2 = this.__cell.getCellWidget();

        this.assertQxWidget(item2);

        this.__cell.pool(item1);

        this.__cell.pool(item2);

        this.__setUpDelegate();

        var item = this.__cell.getCellWidget();

        this.assertInterface(item, qx.ui.form.ListItem);
        item.dispose();
        item1.dispose();
        item2.dispose();
      },
      testEvent: function testEvent() {
        var that = this;
        var widget = null;
        this.assertEventFired(this.__cell, "created", function () {
          widget = that.__cell.getCellWidget();
        }, function (e) {
          that.assertQxWidget(e.getData());
        });

        this.__cell.pool(widget);

        this.assertEventNotFired(this.__cell, "created", function () {
          that.__cell.getCellWidget();
        }, function (e) {
          that.assertQxWidget(e.getData());
        });
        widget.dispose();
      },
      testUpdateData: function testUpdateData() {
        this.__setUpDelegate();

        var item = this.__cell.getCellWidget();

        var data = {
          label: "label 1",
          icon: "icon/22/emotes/face-angel.png"
        };

        this.__cell.updateData(item, data);

        this.assertEquals(data.label, item.getLabel());
        this.assertEquals(data.icon, item.getIcon());
        item.dispose();
      },
      testUpdateEmptyData: function testUpdateEmptyData() {
        this.__setUpDelegate();

        var item = this.__cell.getCellWidget();

        this.__cell.updateData(item);

        this.assertNull(item.getLabel());
        this.assertNull(item.getIcon());
        item.dispose();
      },
      testUpdateWrongData: function testUpdateWrongData() {
        var item = this.__cell.getCellWidget();

        var data = {
          banana: "joe"
        };
        var that = this;
        this.assertException(function () {
          that.__cell.updateData(item, data);
        });
        item.dispose();
      },
      __setUpDelegate: function __setUpDelegate() {
        this.__cell.setDelegate({
          createWidget: function createWidget() {
            return new qx.ui.form.ListItem();
          }
        });
      }
    }
  });
  qx.test.ui.virtual.cell.WidgetCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.virtual.core.Axis": {},
      "qx.ui.virtual.layer.CellSpanManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Jonathan Weiß (jonathan_rass)
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.CellSpanManager", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.rowConfig = new qx.ui.virtual.core.Axis(10, 100);
        this.columnConfig = new qx.ui.virtual.core.Axis(20, 100);
        this.cellSpan = new qx.ui.virtual.layer.CellSpanManager(this.rowConfig, this.columnConfig);
      },
      tearDown: function tearDown() {
        qx.test.ui.virtual.layer.CellSpanManager.prototype.tearDown.base.call(this);
        this.cellSpan.dispose();
        this.rowConfig.dispose();
        this.columnConfig.dispose();
      },
      assertSorted: function assertSorted(cells, key) {
        var last = -1;

        for (var i = 0, l = cells.length; i < l; i++) {
          var cell = cells[i];
          var start = cell[key];
          this.assert(last <= start);
          last = start;
        }
      },
      testGetSortedCells: function testGetSortedCells() {
        var cellSpan = this.cellSpan;
        cellSpan.addCell("c1", 6, 4, 5, 3);
        cellSpan.addCell("c2", 2, 6, 3, 4);
        cellSpan.addCell("c3", 7, 7, 6, 3);
        cellSpan.addCell("c4", 2, 8, 6, 13);
        cellSpan.addCell("c5", 0, 9, 1, 13);
        cellSpan.addCell("c6", 10, 10, 1, 3);

        var cells = cellSpan._getSortedCells("firstRow");

        this.assertEquals(6, cells.length);
        this.assertSorted(cells, "firstRow");

        var cells = cellSpan._getSortedCells("lastRow");

        this.assertEquals(6, cells.length);
        this.assertSorted(cells, "lastRow");

        var cells = cellSpan._getSortedCells("firstColumn");

        this.assertEquals(6, cells.length);
        this.assertSorted(cells, "firstColumn");

        var cells = cellSpan._getSortedCells("lastColumn");

        this.assertEquals(6, cells.length);
        this.assertSorted(cells, "lastColumn");
        cellSpan.addCell("c7", 6, 5, 2, 5);
        cellSpan.addCell("c8", 1, 12, 7, 4);

        var cells = cellSpan._getSortedCells("firstRow");

        this.assertEquals(8, cells.length);
        this.assertSorted(cells, "firstRow");

        var cells = cellSpan._getSortedCells("lastRow");

        this.assertEquals(8, cells.length);
        this.assertSorted(cells, "lastRow");

        var cells = cellSpan._getSortedCells("firstColumn");

        this.assertEquals(8, cells.length);
        this.assertSorted(cells, "firstColumn");

        var cells = cellSpan._getSortedCells("lastColumn");

        this.assertEquals(8, cells.length);
        this.assertSorted(cells, "lastColumn");
      },
      testFindCellsInRange: function testFindCellsInRange() {
        var cellSpan = this.cellSpan;
        cellSpan.addCell("c1", 6, 4, 5, 3);
        cellSpan.addCell("c2", 2, 6, 3, 4);
        cellSpan.addCell("c3", 7, 7, 6, 3);
        cellSpan.addCell("c4", 2, 8, 6, 13);
        cellSpan.addCell("c5", 1, 9, 1, 13);
        cellSpan.addCell("c6", 10, 10, 1, 3);

        var result = cellSpan._findCellsInRange("firstRow", 2, 6);

        this.assertArrayEquals(["c1", "c2", "c4"], Object.keys(result).sort());

        var result = cellSpan._findCellsInRange("firstRow", 11, 20);

        this.assertArrayEquals([], Object.keys(result));

        var result = cellSpan._findCellsInRange("firstRow", 0, 0);

        this.assertArrayEquals([], Object.keys(result));

        var result = cellSpan._findCellsInRange("firstRow", 0, 5);

        this.assertArrayEquals(["c2", "c4", "c5"], Object.keys(result).sort());

        var result = cellSpan._findCellsInRange("lastRow", 3, 8);

        this.assertArrayEquals(["c2", "c4"], Object.keys(result).sort());

        var result = cellSpan._findCellsInRange("firstColumn", 3, 7);

        this.assertArrayEquals(["c1", "c2", "c3"], Object.keys(result).sort());

        var result = cellSpan._findCellsInRange("lastColumn", 0, 22);

        this.assertArrayEquals(["c1", "c2", "c3", "c4", "c5", "c6"], Object.keys(result).sort());
      },
      testFindCellsInWindow: function testFindCellsInWindow() {
        var cellSpan = this.cellSpan;
        cellSpan.addCell("c1", 6, 4, 5, 3);
        cellSpan.addCell("c2", 2, 6, 3, 4);
        cellSpan.addCell("c3", 7, 7, 6, 3);
        cellSpan.addCell("c4", 2, 8, 6, 13);
        cellSpan.addCell("c5", 1, 9, 1, 13);
        cellSpan.addCell("c6", 10, 10, 1, 3);
        var cells = cellSpan.findCellsInWindow(1, 7, 5, 14);
        var ids = [];
        cells.forEach(function (cell) {
          ids.push(cell.id);
        });
        this.assertArrayEquals(["c2", "c4", "c5"], ids.sort());
      },
      testGetCellOffsets: function testGetCellOffsets() {
        var cellSpan = this.cellSpan;
        var bounds = cellSpan.getCellBounds([{
          firstRow: 1,
          lastRow: 3,
          firstColumn: 2,
          lastColumn: 5
        }], 3, 3);
        this.assertJsonEquals({
          left: -20,
          top: -20,
          width: 80,
          height: 30
        }, bounds[0]);
        var bounds = cellSpan.getCellBounds([{
          firstRow: 1,
          lastRow: 3,
          firstColumn: 2,
          lastColumn: 5
        }], 1, 2);
        this.assertJsonEquals({
          left: 0,
          top: 0,
          width: 80,
          height: 30
        }, bounds[0]);
        var bounds = cellSpan.getCellBounds([{
          firstRow: 1,
          lastRow: 3,
          firstColumn: 2,
          lastColumn: 5
        }], 0, 1);
        this.assertJsonEquals({
          left: 20,
          top: 10,
          width: 80,
          height: 30
        }, bounds[0]);
      },
      testAxisChange: function testAxisChange() {
        var bounds = this.cellSpan.getCellBounds([{
          firstRow: 1,
          lastRow: 3,
          firstColumn: 2,
          lastColumn: 5
        }], 3, 3);
        this.assertJsonEquals({
          left: -20,
          top: -20,
          width: 80,
          height: 30
        }, bounds[0]);
        this.rowConfig.setDefaultItemSize(15);
        var bounds = this.cellSpan.getCellBounds([{
          firstRow: 1,
          lastRow: 3,
          firstColumn: 2,
          lastColumn: 5
        }], 3, 3);
        this.assertJsonEquals({
          left: -20,
          top: -30,
          width: 80,
          height: 45
        }, bounds[0]);
      },
      testComputeCellSpanMap: function testComputeCellSpanMap() {
        var cellSpan = this.cellSpan;
        cellSpan.addCell("c1", 0, 0, 2, 2);
        cellSpan.addCell("c2", 0, 4, 2, 2);
        cellSpan.addCell("c3", 2, 2, 2, 2);
        cellSpan.addCell("c4", 4, 0, 2, 2);
        cellSpan.addCell("c5", 4, 4, 2, 2);
        var cells = cellSpan.findCellsInWindow(1, 1, 4, 4);
        var ids = [];
        cells.forEach(function (cell) {
          ids.push(cell.id);
        });
        this.assertJsonEquals(["c1", "c2", "c3", "c4", "c5"], ids.sort());
        var map = cellSpan.computeCellSpanMap(cells, 1, 1, 4, 4);
        this.assertJsonEquals([undefined, [undefined, 1, undefined, undefined, 1], [undefined, undefined, 1, 1], [undefined, undefined, 1, 1], [undefined, 1, undefined, undefined, 1]], map);
      },
      testDispose: function testDispose() {
        var rowConfig = new qx.ui.virtual.core.Axis(10, 100);
        var columnConfig = new qx.ui.virtual.core.Axis(20, 100);
        this.assertDestroy(function () {
          var cellSpan = new qx.ui.virtual.layer.CellSpanManager(rowConfig, columnConfig);
          cellSpan.dispose();
        }, this);
        rowConfig.dispose();
        columnConfig.dispose();
      }
    },
    destruct: function destruct() {
      this.cellSpan = this.rowConfig = this.columnConfig = null;
    }
  });
  qx.test.ui.virtual.layer.CellSpanManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.Axis": {
        "construct": true
      },
      "qx.lang.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The CellSpanManager manages cells, which span several rows or columns.
   *
   * It provides functionality to compute, which spanning cells are visible
   * in a given view port and how they have to be placed.
   */
  qx.Class.define("qx.ui.virtual.layer.CellSpanManager", {
    extend: qx.core.Object,

    /**
     * @param rowConfig {qx.ui.virtual.core.Axis} The row configuration of the pane
     *    in which the cells will be rendered
     * @param columnConfig {qx.ui.virtual.core.Axis} The column configuration of the pane
     *    in which the cells will be rendered
     */
    construct: function construct(rowConfig, columnConfig) {
      qx.core.Object.constructor.call(this);
      {
        this.assertInstance(rowConfig, qx.ui.virtual.core.Axis);
        this.assertInstance(columnConfig, qx.ui.virtual.core.Axis);
      }
      this._cells = {};

      this._invalidateSortCache();

      this._invalidatePositionCache();

      rowConfig.addListener("change", this._onRowConfigChange, this);
      columnConfig.addListener("change", this._onColumnConfigChange, this);
      this._rowConfig = rowConfig;
      this._columnConfig = columnConfig;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Add a spanning cell to the manager.
       *
       * @param id {String} Unique id for the cell definition. This id is required
       *    for removing the cell from the manager
       * @param row {PositiveInteger} The cell's row
       * @param column {PositiveInteger} The cell's column
       * @param rowSpan {PositiveInteger} The number of rows the cells spans
       * @param columnSpan {PositiveInteger} The number of columns the cells spans
       */
      addCell: function addCell(id, row, column, rowSpan, columnSpan) {
        this._cells[id] = {
          firstRow: row,
          lastRow: row + rowSpan - 1,
          firstColumn: column,
          lastColumn: column + columnSpan - 1,
          id: id
        };

        this._invalidateSortCache();
      },

      /**
       * Remove a cell from the manager
       *
       * @param id {String} The id of the cell to remove
       */
      removeCell: function removeCell(id) {
        delete this._cells[id];

        this._invalidateSortCache();
      },

      /**
       * Invalidate the sort cache
       */
      _invalidateSortCache: function _invalidateSortCache() {
        this._sorted = {};
      },

      /**
       * Get the cell array sorted by the given key (ascending)
       *
       * @param key {String} The sort key. One of <code>firstRow</code>,
       *     <code>lastRow</code>, <code>firstColumn</code> or <code>lastColumn</code>
       * @return {Map[]} sorted array of cell descriptions
       */
      _getSortedCells: function _getSortedCells(key) {
        if (this._sorted[key]) {
          return this._sorted[key];
        }

        var sorted = this._sorted[key] = Object.values(this._cells);
        sorted.sort(function (a, b) {
          return a[key] < b[key] ? -1 : 1;
        });
        return sorted;
      },

      /**
       * Finds all cells with a sort key within the given range.
       *
       * Complexity: O(log n)
       *
       * @param key {String} The key to search for
       * @param min {Integer} minimum value
       * @param max {Integer} maximum value (inclusive)
       * @return {Map} Map, which will contain the search results
       */
      _findCellsInRange: function _findCellsInRange(key, min, max) {
        var cells = this._getSortedCells(key);

        if (cells.length == 0) {
          return {};
        }

        var start = 0;
        var end = cells.length - 1; // find first cell, which is >= "min"

        while (true) {
          var pivot = start + (end - start >> 1);
          var cell = cells[pivot];

          if (cell[key] >= min && (pivot == 0 || cells[pivot - 1][key] < min)) {
            // the start cell was found
            break;
          }

          if (cell[key] >= min) {
            end = pivot - 1;
          } else {
            start = pivot + 1;
          }

          if (start > end) {
            // nothing found
            return {};
          }
        }

        var result = {};
        var cell = cells[pivot];

        while (cell && cell[key] >= min && cell[key] <= max) {
          result[cell.id] = cell;
          cell = cells[pivot++];
        }

        return result;
      },

      /**
       * Find all cells, which are visible in the given grid window.
       *
       * @param firstRow {PositiveInteger} first visible row
       * @param firstColumn {PositiveInteger} first visible column
       * @param rowCount {PositiveInteger} number of rows in the window
       * @param columnCount {PositiveInteger} number of columns in the window
       * @return {Map[]} The array of found cell descriptions. A cell description
       *    contains the keys <code>firstRow</code>, <code>lastRow</code>,
       *    <code>firstColumn</code> or <code>lastColumn</code>
       */
      findCellsInWindow: function findCellsInWindow(firstRow, firstColumn, rowCount, columnCount) {
        var verticalInWindow = {};

        if (rowCount > 0) {
          var lastRow = firstRow + rowCount - 1;
          qx.lang.Object.mergeWith(verticalInWindow, this._findCellsInRange("firstRow", firstRow, lastRow));
          qx.lang.Object.mergeWith(verticalInWindow, this._findCellsInRange("lastRow", firstRow, lastRow));
        }

        var horizontalInWindow = {};

        if (columnCount > 0) {
          var lastColumn = firstColumn + columnCount - 1;
          qx.lang.Object.mergeWith(horizontalInWindow, this._findCellsInRange("firstColumn", firstColumn, lastColumn));
          qx.lang.Object.mergeWith(horizontalInWindow, this._findCellsInRange("lastColumn", firstColumn, lastColumn));
        }

        return this.__intersectionAsArray(horizontalInWindow, verticalInWindow);
      },

      /**
       * Return the intersection of two maps as an array. The objects intersect if
       * they have the same keys.
       *
       * @param setA {Object} The first map
       * @param setB {Object} The second map
       * @return {String[]} An array keys found in both maps
       */
      __intersectionAsArray: function __intersectionAsArray(setA, setB) {
        var intersection = [];

        for (var key in setA) {
          if (setB[key]) {
            intersection.push(setB[key]);
          }
        }

        return intersection;
      },

      /**
       * Event handler for row configuration changes
       *
       * @param e {qx.event.type.Event} the event object
       */
      _onRowConfigChange: function _onRowConfigChange(e) {
        this._rowPos = [];
      },

      /**
       * Event handler for column configuration changes
       *
       * @param e {qx.event.type.Event} the event object
       */
      _onColumnConfigChange: function _onColumnConfigChange(e) {
        this._columnPos = [];
      },

      /**
       * Invalidates the row/column position cache
       */
      _invalidatePositionCache: function _invalidatePositionCache() {
        this._rowPos = [];
        this._columnPos = [];
      },

      /**
       * Get the pixel start position of the given row
       *
       * @param row {Integer} The row index
       * @return {Integer} The pixel start position of the given row
       */
      _getRowPosition: function _getRowPosition(row) {
        var pos = this._rowPos[row];

        if (pos !== undefined) {
          return pos;
        }

        pos = this._rowPos[row] = this._rowConfig.getItemPosition(row);
        return pos;
      },

      /**
       * Get the pixel start position of the given column
       *
       * @param column {Integer} The column index
       * @return {Integer} The pixel start position of the given column
       */
      _getColumnPosition: function _getColumnPosition(column) {
        var pos = this._columnPos[column];

        if (pos !== undefined) {
          return pos;
        }

        pos = this._columnPos[column] = this._columnConfig.getItemPosition(column);
        return pos;
      },

      /**
       * Get the bounds of a single cell
       *
       * @param cell {Map} the cell description as returned by
       *    {@link #findCellsInWindow} to get the bounds for
       * @param firstVisibleRow {Map} The pane's first visible row
       * @param firstVisibleColumn {Map} The pane's first visible column
       * @return {Map} Boundaries map with the keys <code>left</code>,
       * <code>top</code>, <code>width</code> and <code>height</code>
       */
      _getSingleCellBounds: function _getSingleCellBounds(cell, firstVisibleRow, firstVisibleColumn) {
        var bounds = {
          left: 0,
          top: 0,
          width: 0,
          height: 0
        };
        bounds.height = this._getRowPosition(cell.lastRow) + this._rowConfig.getItemSize(cell.lastRow) - this._getRowPosition(cell.firstRow);
        bounds.top = this._getRowPosition(cell.firstRow) - this._getRowPosition(firstVisibleRow);
        bounds.width = this._getColumnPosition(cell.lastColumn) + this._columnConfig.getItemSize(cell.lastColumn) - this._getColumnPosition(cell.firstColumn);
        bounds.left = this._getColumnPosition(cell.firstColumn) - this._getColumnPosition(firstVisibleColumn);
        return bounds;
      },

      /**
       * Get the bounds of a list of cells as returned by {@link #findCellsInWindow}
       *
       * @param cells {Map[]} Array of cell descriptions
       * @param firstVisibleRow {Map} The pane's first visible row
       * @param firstVisibleColumn {Map} The pane's first visible column
       * @return {Map[]} Array, which contains a bounds map for each cell.
       */
      getCellBounds: function getCellBounds(cells, firstVisibleRow, firstVisibleColumn) {
        var bounds = [];

        for (var i = 0, l = cells.length; i < l; i++) {
          bounds.push(this._getSingleCellBounds(cells[i], firstVisibleRow, firstVisibleColumn));
        }

        return bounds;
      },

      /**
       * Compute a bitmap, which marks for each visible cell, whether the cell
       * is covered by a spanning cell.
       *
       * @param cells {Map[]} Array of cell descriptions as returned by
       *     {@link #findCellsInWindow}.
       * @param firstRow {PositiveInteger} first visible row
       * @param firstColumn {PositiveInteger} first visible column
       * @param rowCount {PositiveInteger} number of rows in the window
       * @param columnCount {PositiveInteger} number of columns in the window
       * @return {Map[][]} Two dimensional array, which contains a <code>1</code>
       *    for each visible cell, which is covered by a spanned cell.
       */
      computeCellSpanMap: function computeCellSpanMap(cells, firstRow, firstColumn, rowCount, columnCount) {
        var map = [];

        if (rowCount <= 0) {
          return map;
        }

        var lastRow = firstRow + rowCount - 1;

        for (var i = firstRow; i <= lastRow; i++) {
          map[i] = [];
        }

        if (columnCount <= 0) {
          return map;
        }

        var lastColumn = firstColumn + columnCount - 1;

        for (var i = 0, l = cells.length; i < l; i++) {
          var cell = cells[i];
          var rowStartIndex = Math.max(firstRow, cell.firstRow);
          var rowEndIndex = Math.min(lastRow, cell.lastRow);
          var row;

          for (var rowIndex = rowStartIndex; rowIndex <= rowEndIndex; rowIndex++) {
            row = map[rowIndex];
            var columnStartIndex = Math.max(firstColumn, cell.firstColumn);
            var columnEndIndex = Math.min(lastColumn, cell.lastColumn);

            for (var columnIndex = columnStartIndex; columnIndex <= columnEndIndex; columnIndex++) {
              row[columnIndex] = 1;
            }
          }
        }

        return map;
      }
    },
    destruct: function destruct() {
      this._rowConfig.removeListener("change", this._onRowConfigChange, this);

      this._columnConfig.removeListener("change", this._onColumnConfigChange, this);

      this._cells = this._sorted = this._rowPos = this._columnPos = this._rowConfig = this._columnConfig = null;
    }
  });
  qx.ui.virtual.layer.CellSpanManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.test.ui.virtual.layer.LayerMock": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Jonathan Weiß (jonathan_rass)
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.LayerTestCase", {
    extend: qx.test.ui.LayoutTestCase,
    type: "abstract",
    members: {
      setUp: function setUp() {
        this.colWidth = 20;
        this.rowHeight = 10;
        this.layer = this._createLayer();
        var rowSizes = [];

        for (var i = 10; i <= 20; i++) {
          rowSizes.push(this.rowHeight);
        }

        var columnSizes = [];

        for (var i = 15; i <= 18; i++) {
          columnSizes.push(this.colWidth);
        }

        this.getRoot().add(this.layer);
        this.flush();
        this.layer.updateLayerWindow(10, 15, rowSizes, columnSizes);
        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.ui.virtual.layer.LayerTestCase.prototype.tearDown.base.call(this);
        this.layer.destroy();
      },
      _createLayer: function _createLayer() {
        return new qx.test.ui.virtual.layer.LayerMock();
      },
      _assertCells: function _assertCells(firstRow, lastRow, firstColumn, lastColumn, msg) {
        return;
      },
      _updateLayerWindow: function _updateLayerWindow(firstRow, lastRow, firstColumn, lastColumn, doFullUpdate) {
        var rowSizes = [];

        for (var i = firstRow; i <= lastRow; i++) {
          rowSizes.push(this.rowHeight);
        }

        var columnSizes = [];

        for (var i = firstColumn; i <= lastColumn; i++) {
          columnSizes.push(this.colWidth);
        }

        if (doFullUpdate) {
          this.layer.fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
        } else {
          this.layer.updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes);
        }

        this.flush();

        this._assertCells(firstRow, firstColumn, rowSizes.length, columnSizes.length);
      },
      testInit: function testInit() {
        this._assertCells(10, 15, 11, 4);
      },
      testFullUpdate: function testFullUpdate() {
        this._assertCells(10, 15, 11, 4, true);
      },
      testNoOverlap: function testNoOverlap() {
        this._updateLayerWindow(20, 25, 19, 21);
      },
      testScrollDown: function testScrollDown() {
        this._updateLayerWindow(12, 22, 15, 18);
      },
      testScrollUp: function testScrollUp() {
        this._updateLayerWindow(8, 18, 15, 18);
      },
      testScrollLeft: function testScrollLeft() {
        this._updateLayerWindow(10, 20, 12, 15);
      },
      testScrollRight: function testScrollRight() {
        this._updateLayerWindow(10, 20, 17, 20);
      },
      testOverlapLeftTop: function testOverlapLeftTop() {
        this._updateLayerWindow(7, 11, 12, 16);
      },
      testOverlapTop: function testOverlapTop() {
        this._updateLayerWindow(8, 11, 14, 17);
      },
      testOverlapTopRight: function testOverlapTopRight() {
        this._updateLayerWindow(8, 11, 17, 20);
      },
      testOverlapLeft: function testOverlapLeft() {
        this._updateLayerWindow(11, 18, 13, 16);
      },
      testOverlapInner: function testOverlapInner() {
        this._updateLayerWindow(11, 18, 16, 17);
      },
      testOverlapOuter: function testOverlapOuter() {
        this._updateLayerWindow(8, 21, 14, 20);
      },
      testOverlapRight: function testOverlapRight() {
        this._updateLayerWindow(11, 18, 17, 20);
      },
      testOverlapBottomLeft: function testOverlapBottomLeft() {
        this._updateLayerWindow(18, 22, 14, 17);
      },
      testOverlapBottom: function testOverlapBottom() {
        this._updateLayerWindow(18, 22, 16, 17);
      },
      testOverlapBottomRight: function testOverlapBottomRight() {
        this._updateLayerWindow(18, 22, 17, 20);
      }
    },
    destruct: function destruct() {
      this.layer = null;
    }
  });
  qx.test.ui.virtual.layer.LayerTestCase.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.layer.LayerTestCase": {
        "require": true
      },
      "qx.ui.virtual.layer.Column": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Jonathan Weiß (jonathan_rass)
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.Column", {
    extend: qx.test.ui.virtual.layer.LayerTestCase,
    members: {
      _createLayer: function _createLayer() {
        return new qx.ui.virtual.layer.Column("red", "green");
      },
      _assertCells: function _assertCells(firstRow, firstColumn, rowCount, columnCount, msg) {
        var children = this.layer.getContentElement().getDomElement().childNodes;
        this.assertEquals(columnCount, children.length);

        for (var i = 0; i < columnCount; i++) {
          var column = firstColumn + i;

          if (column % 2 == 0) {
            this.assertCssColor("red", children[i].style.backgroundColor);
          } else {
            this.assertCssColor("green", children[i].style.backgroundColor);
          }
        }
      }
    }
  });
  qx.test.ui.virtual.layer.Column.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.AbstractBackground": {
        "require": true
      },
      "qx.lang.Array": {},
      "qx.bom.element.Style": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The Row layer renders row background colors.
   */
  qx.Class.define("qx.ui.virtual.layer.Column", {
    extend: qx.ui.virtual.layer.AbstractBackground,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "column-layer"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];
        var height = qx.lang.Array.sum(rowSizes);
        var left = 0;
        var column = firstColumn;
        var childIndex = 0;

        for (var x = 0; x < columnSizes.length; x++) {
          var color = this.getColor(column);
          var backgroundColor = color ? "background-color:" + color + ";" : "";
          var decorator = this.getBackground(column);
          var styles = decorator ? qx.bom.element.Style.compile(decorator.getStyles()) : "";
          html.push("<div style='", "position: absolute;", "top: 0;", "left:", left, "px;", "width:", columnSizes[x], "px;", "height:", height, "px;", backgroundColor, styles, "'>", "</div>");
          childIndex++;
          left += columnSizes[x];
          column += 1;
        }

        var el = this.getContentElement().getDomElement(); // hide element before changing the child nodes to avoid
        // premature reflow calculations

        el.style.display = "none";
        el.innerHTML = html.join("");
        el.style.display = "block";
        this._height = height;
      },
      updateLayerWindow: function updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        if (firstColumn !== this.getFirstColumn() || columnSizes.length !== this.getColumnSizes().length || this._height < qx.lang.Array.sum(rowSizes)) {
          this._fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
        }
      },
      // overridden
      setColor: function setColor(index, color) {
        qx.ui.virtual.layer.Column.prototype.setColor.base.call(this, index, color);
        var firstColumn = this.getFirstColumn();
        var lastColumn = firstColumn + this.getColumnSizes().length - 1;

        if (index >= firstColumn && index <= lastColumn) {
          this.updateLayerData();
        }
      }
    }
  });
  qx.ui.virtual.layer.Column.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.virtual.layer.GridLines": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Jonathan Weiß (jonathan_rass)
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.GridLines", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      _assertGridLines: function _assertGridLines(linesLayer, isHorizontal, color, lineSize, msg) {
        this.assertEquals(isHorizontal, linesLayer.isHorizontal(), msg);
        this.assertEquals(color, linesLayer.getDefaultLineColor(), msg);
        this.assertEquals(lineSize, linesLayer.getDefaultLineSize(), msg);
      },
      testCreate: function testCreate() {
        var lines = new qx.ui.virtual.layer.GridLines();

        this._assertGridLines(lines, true, "gray", 1);

        lines.destroy();
        var lines = new qx.ui.virtual.layer.GridLines("horizontal");

        this._assertGridLines(lines, true, "gray", 1);

        lines.destroy();
        var lines = new qx.ui.virtual.layer.GridLines("vertical", "red");

        this._assertGridLines(lines, false, "red", 1);

        lines.destroy();
        var lines = new qx.ui.virtual.layer.GridLines("vertical", "red", 5);

        this._assertGridLines(lines, false, "red", 5);

        lines.destroy();
      }
    }
  });
  qx.test.ui.virtual.layer.GridLines.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Represents horizontal or vertical lines.
   */
  qx.Class.define("qx.ui.virtual.layer.GridLines", {
    extend: qx.ui.virtual.layer.Abstract,

    /**
     * @param orientation {String?"horizontal"} The grid line orientation.
     * @param lineColor {Color?null} The default color for grid lines
     * @param lineSize {PositiveInteger|null} The default width/height for grid
     *    lines.
     */
    construct: function construct(orientation, lineColor, lineSize) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this.setZIndex(11);

      if (lineColor) {
        this.setDefaultLineColor(lineColor);
      }

      if (lineSize !== undefined) {
        this.setDefaultLineSize(lineSize);
      }

      this.__lineColors = [];
      this.__lineSizes = [];
      this._isHorizontal = (orientation || "horizontal") == "horizontal";
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The default color for grid lines.*/
      defaultLineColor: {
        init: "gray",
        check: "Color",
        themeable: true
      },

      /** The default width/height for grid lines.*/
      defaultLineSize: {
        init: 1,
        check: "PositiveInteger",
        themeable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** Stores the colors for deviant grid lines. */
      __lineColors: null,

      /** Stores the width/height for deviant grid lines. */
      __lineSizes: null,

      /**
       * Whether horizontal lines are rendered
       *
       * @return {Boolean} Whether horizontal lines are rendered
       */
      isHorizontal: function isHorizontal() {
        return this._isHorizontal;
      },

      /**
       * Sets the color for the grid line with the given index.
       *
       * @param index {PositiveNumber} The index of the line.
       * @param color {Color} The color.
       */
      setLineColor: function setLineColor(index, color) {
        {
          qx.core.Assert.assertPositiveNumber(index);
          qx.core.Assert.assertString(color);
        }
        this.__lineColors[index] = color;

        if (this.__isLineRendered(index)) {
          this.updateLayerData();
        }
      },

      /**
       * Sets the width/height for the grid line with the given index.
       *
       * @param index {PositiveNumber} The index of the line.
       * @param size {PositiveInteger} The size.
       */
      setLineSize: function setLineSize(index, size) {
        {
          qx.core.Assert.assertPositiveInteger(index);
          qx.core.Assert.assertPositiveInteger(size);
        }
        this.__lineSizes[index] = size;

        if (this.__isLineRendered(index)) {
          this.updateLayerData();
        }
      },

      /**
       * Whether the line with the given index is currently rendered (i.e. in the
       * layer's view port).
       *
       * @param index {Integer} The line's index
       * @return {Boolean} Whether the line is rendered
       */
      __isLineRendered: function __isLineRendered(index) {
        if (this._isHorizontal) {
          var firstColumn = this.getFirstColumn();
          var lastColumn = firstColumn + this.getColumnSizes().length - 1;
          return index >= firstColumn && index <= lastColumn;
        } else {
          var firstRow = this.getFirstRow();
          var lastRow = firstRow + this.getRowSizes().length - 1;
          return index >= firstRow && index <= lastRow;
        }
      },

      /**
       * Returns the size of the grid line with the given index.
       *
       * @param index {PositiveNumber} The index of the line.
       * @return {PositiveInteger} The size.
       */
      getLineSize: function getLineSize(index) {
        return this.__lineSizes[index] || this.getDefaultLineSize();
      },

      /**
       * Returns the color of the grid line with the given index.
       *
       * @param index {PositiveNumber} The index of the line.
       * @return {String} The color.
       */
      getLineColor: function getLineColor(index) {
        return this.__lineColors[index] || this.getDefaultLineColor();
      },

      /**
       * Helper function to render horizontal lines.
       *
       * @param htmlArr {Array} An array to store the generated HTML in.
       * @param firstRow {Integer} The first visible row
       * @param rowSizes {Array} An array containing the row sizes.
       */
      __renderHorizontalLines: function __renderHorizontalLines(htmlArr, firstRow, rowSizes) {
        var top = 0;
        var color, height;

        for (var y = 0; y < rowSizes.length - 1; y++) {
          color = this.getLineColor(firstRow + y);
          height = this.getLineSize(firstRow + y);
          top += rowSizes[y];
          htmlArr.push("<div style='", "position: absolute;", "height: " + height + "px;", "width: 100%;", "top:", top - (height > 1 ? Math.floor(height / 2) : 1), "px;", "background-color:", color, "'>", "</div>");
        }
      },

      /**
       * Helper function to render vertical lines.
       *
       * @param htmlArr {Array} The array to store the generated HTML in.
       * @param firstColumn {Integer} The first visible column
       * @param columnSizes {Array} An array containing the column sizes.
       */
      __renderVerticalLines: function __renderVerticalLines(htmlArr, firstColumn, columnSizes) {
        var left = 0;
        var color, width;

        for (var x = 0; x < columnSizes.length - 1; x++) {
          color = this.getLineColor(firstColumn + x);
          width = this.getLineSize(firstColumn + x);
          left += columnSizes[x];
          htmlArr.push("<div style='", "position: absolute;", "width: " + width + "px;", "height: 100%;", "top: 0px;", "left:", left - (width > 1 ? Math.floor(width / 2) : 1), "px;", "background-color:", color, "'>", "</div>");
        }
      },
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];

        if (this._isHorizontal) {
          this.__renderHorizontalLines(html, firstRow, rowSizes);
        } else {
          this.__renderVerticalLines(html, firstColumn, columnSizes);
        }

        this.getContentElement().setAttribute("html", html.join(""));
      },
      // overridden
      _updateLayerWindow: function _updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        var rowChanged = firstRow !== this.getFirstRow() || rowSizes.length !== this.getRowSizes().length;
        var columnChanged = firstColumn !== this.getFirstColumn() || columnSizes.length !== this.getColumnSizes().length;

        if (this._isHorizontal && rowChanged || !this._isHorizontal && columnChanged) {
          this._fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
        }
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this.__lineColors = this.__lineSizes = null;
    }
  });
  qx.ui.virtual.layer.GridLines.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.layer.LayerTestCase": {
        "require": true
      },
      "qx.ui.virtual.layer.GridLines": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Jonathan Weiß (jonathan_rass)
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.GridLinesHorizontal", {
    extend: qx.test.ui.virtual.layer.LayerTestCase,
    members: {
      _createLayer: function _createLayer() {
        return new qx.ui.virtual.layer.GridLines("horizontal");
      },
      _assertCells: function _assertCells(firstRow, firstColumn, rowCount, columnCount, msg) {
        var children = this.layer.getContentElement().getDomElement().childNodes;
        this.assertEquals(rowCount - 1, children.length);
      }
    }
  });
  qx.test.ui.virtual.layer.GridLinesHorizontal.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.layer.LayerTestCase": {
        "require": true
      },
      "qx.ui.virtual.layer.GridLines": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Jonathan Weiß (jonathan_rass)
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.GridLinesVertical", {
    extend: qx.test.ui.virtual.layer.LayerTestCase,
    members: {
      _createLayer: function _createLayer() {
        return new qx.ui.virtual.layer.GridLines("vertical");
      },
      _assertCells: function _assertCells(firstRow, firstColumn, rowCount, columnCount, msg) {
        var children = this.layer.getContentElement().getDomElement().childNodes;
        this.assertEquals(columnCount - 1, children.length);
      }
    }
  });
  qx.test.ui.virtual.layer.GridLinesVertical.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.layer.LayerTestCase": {
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {},
      "qx.ui.virtual.layer.HtmlCell": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Jonathan Weiß (jonathan_rass)
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.HtmlCell", {
    extend: qx.test.ui.virtual.layer.LayerTestCase,
    members: {
      tearDown: function tearDown() {
        qx.test.ui.virtual.layer.HtmlCell.prototype.tearDown.base.call(this);

        this.__cellRenderer.dispose();
      },
      _createLayer: function _createLayer() {
        this.__cellRenderer = new qx.ui.virtual.cell.Cell();
        return new qx.ui.virtual.layer.HtmlCell(this);
      },
      getCellProperties: function getCellProperties(row, column) {
        return this.__cellRenderer.getCellProperties(row + " / " + column, {});
      },
      _assertCells: function _assertCells(firstRow, firstColumn, rowCount, columnCount, msg) {
        var children = this.layer.getContentElement().getDomElement().childNodes;
        this.assertEquals(rowCount * columnCount, children.length);

        for (var y = 0; y < rowCount; y++) {
          for (var x = 0; x < columnCount; x++) {
            var row = firstRow + y;
            var column = firstColumn + x;
            var cellEl = children[y * columnCount + x];
            this.assertEquals(row + " / " + column, cellEl.innerHTML);
          }
        }
      }
    },
    destruct: function destruct() {
      this.__cellRenderer = null;
    }
  });
  qx.test.ui.virtual.layer.HtmlCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A HTML cell provider provides the {@link qx.ui.virtual.layer.HtmlCell}
   * with HTML fragments to render the cells.
   */
  qx.Interface.define("qx.ui.virtual.cell.ICell", {
    members: {
      /**
       * Returns all relevant properties of the cell:
       * <ul>
       * <li>classes (String): Space separated class names</li>
       * <li>style (String): CSS styles</li>
       * <li>attributes (String): Space separated attributes</li>
       * <li>content (String): HTML fragment of the innerHTML of the cell</li>
       * <li>insets (Array): insets (padding + border) of the cell as
       * two-dimensional array.</li>
       * </ul>
       *
       * @param data {var} Data needed for the cell to render.
       * @param states {Map} The states set on the cell (e.g. <i>selected</i>,
       * <i>focused</i>, <i>editable</i>).
       *
       * @return {Map} Cell properties (see above.)
       */
      getCellProperties: function getCellProperties(data, states) {}
    }
  });
  qx.ui.virtual.cell.ICell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.bom.Stylesheet": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.cell.ICell": {
        "require": true
      },
      "qx.ui.virtual.cell.CellStylesheet": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Abstract base class for HTML based cell renderer.
   *
   * HTML cell renderer are used to construct an HTML string, which is used to
   * render the cell.
   *
   * @require(qx.bom.Stylesheet)
   *
   */
  qx.Class.define("qx.ui.virtual.cell.Abstract", {
    type: "abstract",
    extend: qx.core.Object,
    implement: qx.ui.virtual.cell.ICell,
    construct: function construct() {
      qx.core.Object.constructor.call(this); // initialize stylesheet

      qx.ui.virtual.cell.CellStylesheet.getInstance();
    },
    members: {
      /**
       * Get the css classes for the cell
       *
       * @param value {var} The cell's data value
       * @param states {Object} A map containing the cell's state names as map keys.
       * @return {String} Space separated list of CSS classes
       */
      getCssClasses: function getCssClasses(value, states) {
        return "qx-cell";
      },

      /**
       * Get the element attributes for the cell
       *
       * @param value {var} The cell's data value
       * @param states {Object} A map containing the cell's state names as map keys.
       * @return {String} Compiled string of cell attributes. e.g.
       *   <code>'tabIndex="1" readonly="false"'</code>
       */
      getAttributes: function getAttributes(value, states) {
        return "";
      },

      /**
       * Get the CSS styles for the cell
       *
       * @param value {var} The cell's data value
       * @param states {Object} A map containing the cell's state names as map keys.
       * @return {String} Compiled string of CSS styles. e.g.
       *   <code>'color="red; padding: 10px'</code>
       */
      getStyles: function getStyles(value, states) {
        return "";
      },

      /**
       * Get the cell's insets. Insets are the sum of the cell's padding and
       * border width.
       *
       * @param value {var} The cell's data value
       * @param states {Object} A map containing the cell's state names as map keys.
       * @return {Integer[]} An array containing the sum of horizontal insets at index
       *   <code>0</code> and the sum of vertical insets at index <code>1</code>.
       */
      getInsets: function getInsets(value, states) {
        return [0, 0];
      },

      /**
       * Get cell'S HTML content
       *
       * @param value {var} The cell's data value
       * @param states {Object} A map containing the cell's state names as map keys.
       * @return {String} The cell's content as HTML fragment.
       */
      getContent: function getContent(value, states) {
        return value;
      },
      getCellProperties: function getCellProperties(value, states) {
        return {
          classes: this.getCssClasses(value, states),
          style: this.getStyles(value, states),
          attributes: this.getAttributes(value, states),
          content: this.getContent(value, states),
          insets: this.getInsets(value, states)
        };
      }
    }
  });
  qx.ui.virtual.cell.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.bom.element.Style": {
        "construct": true
      },
      "qx.bom.client.Css": {
        "construct": true
      },
      "qx.bom.element.BoxSizing": {
        "construct": true
      },
      "qx.bom.Stylesheet": {
        "construct": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxsizing": {
          "construct": true,
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Singleton wrapper for the stylesheet containing the CSS rules for HTML cells.
   *
   */
  qx.Class.define("qx.ui.virtual.cell.CellStylesheet", {
    extend: qx.core.Object,
    type: "singleton",
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      var stylesheet = ".qx-cell {" + qx.bom.element.Style.compile({
        position: "absolute",
        overflow: "hidden",
        cursor: "default",
        textOverflow: "ellipsis",
        userSelect: "none"
      }) + "} ";

      if (qx.core.Environment.get("css.boxsizing")) {
        stylesheet += ".qx-cell {" + qx.bom.element.BoxSizing.compile("content-box") + "}";
      }

      this.__stylesheet = qx.bom.Stylesheet.createElement(stylesheet);
      this.__classes = {};
      this.__styles = {};
    },
    members: {
      __stylesheet: null,
      __classes: null,
      __styles: null,

      /**
       * Get the DOM stylesheet element
       *
       * @return {StyleSheet} The DOM stylesheet element
       */
      getStylesheet: function getStylesheet() {
        return this.__stylesheet;
      },

      /**
       * Get the CSS class stored under the given key
       *
       * @param key {String} The key under which the class name is stored
       * @return {String|null} The CSS class stored under the given key or
       *   <code>null</code>.
       */
      getCssClass: function getCssClass(key) {
        return this.__classes[key] || null;
      },

      /**
       * Dynamically create a CSS rule for the given style string. The selector is
       * an unique class name, which is returned. The class is stored under the
       * given key name and can be queried using {@link #getCssClass}.
       *
       * @param key {String} The key under which the class name should be stored
       * @param styleString {String} A compiled string of CSS rules.
       * @return {String} The CSS class name.
       */
      computeClassForStyles: function computeClassForStyles(key, styleString) {
        var cssClass = this.__styles[styleString];

        if (!cssClass) {
          // generate stylesheet rule
          var cssClass = this.__getNextClassname();

          qx.bom.Stylesheet.addRule(this.__stylesheet, "." + cssClass, styleString);
          this.__styles[styleString] = cssClass;
        }

        this.__classes[key] = cssClass;
        return cssClass;
      },

      /**
       * Get the next unique CSS class name
       *
       * @return {String} The next unique CSS class name
       */
      __getNextClassname: function __getNextClassname() {
        return "qx-cell-" + this.toHashCode() + "-" + this.__classCounter++;
      },
      __classCounter: 0
    },
    destruct: function destruct() {
      this.__stylesheet = this.__classes = this.__styles = null;
    }
  });
  qx.ui.virtual.cell.CellStylesheet.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.cell.CellStylesheet": {
        "construct": true
      },
      "qx.util.PropertyUtil": {},
      "qx.lang.Object": {},
      "qx.theme.manager.Color": {},
      "qx.theme.manager.Font": {},
      "qx.bom.element.Style": {},
      "qx.bom.Style": {},
      "qx.theme.manager.Appearance": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Themeable Cell renderer.
   *
   * This cell renderer can be styled by an appearance theme.
   */
  qx.Class.define("qx.ui.virtual.cell.Cell", {
    extend: qx.ui.virtual.cell.Abstract,
    construct: function construct() {
      qx.ui.virtual.cell.Abstract.constructor.call(this);
      this.__stylesheet = qx.ui.virtual.cell.CellStylesheet.getInstance();
      this.__userStyles = {};
      this.__themeStyles = {};
      this.__userPaddings = {};
      this.__themePaddings = {};
      this.__states = {};
      this.__themeValues = {};
      this.initAppearance();

      this.__initializeThemableProperties();
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The appearance ID. This ID is used to identify the appearance theme
       * entry to use for this cell.
       */
      appearance: {
        check: "String",
        init: "cell",
        apply: "_applyAppearance"
      },

      /** The cell's background color */
      backgroundColor: {
        nullable: true,
        check: "Color",
        apply: "_applyBackgroundColor",
        themeable: true
      },

      /** The cell's text color */
      textColor: {
        nullable: true,
        check: "Color",
        apply: "_applyTextColor",
        themeable: true
      },

      /** The text alignment of the cell's content */
      textAlign: {
        check: ["left", "center", "right", "justify"],
        nullable: true,
        themeable: true,
        apply: "_applyTextAlign"
      },

      /**
       * The cell's font. The value is either a font name defined in the font
       * theme or an instance of {@link qx.bom.Font}.
       */
      font: {
        nullable: true,
        apply: "_applyFont",
        check: "Font",
        themeable: true
      },

      /*
      ---------------------------------------------------------------------------
        PADDING
      ---------------------------------------------------------------------------
      */

      /** Padding of the widget (top) */
      paddingTop: {
        check: "Integer",
        init: 0,
        apply: "_applyPadding",
        themeable: true
      },

      /** Padding of the widget (right) */
      paddingRight: {
        check: "Integer",
        nullable: true,
        apply: "_applyPadding",
        themeable: true
      },

      /** Padding of the widget (bottom) */
      paddingBottom: {
        check: "Integer",
        nullable: true,
        apply: "_applyPadding",
        themeable: true
      },

      /** Padding of the widget (left) */
      paddingLeft: {
        check: "Integer",
        nullable: true,
        apply: "_applyPadding",
        themeable: true
      },

      /**
       * The 'padding' property is a shorthand property for setting 'paddingTop',
       * 'paddingRight', 'paddingBottom' and 'paddingLeft' at the same time.
       *
       * If four values are specified they apply to top, right, bottom and left
       * respectively. If there is only one value, it applies to all sides, if
       * there are two or three, the missing values are taken from the opposite
       * side.
       */
      padding: {
        group: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
        mode: "shorthand",
        themeable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {Array} List of all non CSS themable properties */
      __themableProperties: null,

      /** @type {String} Unique key over the current set of states */
      __statesKey: null,
      __states: null,
      __themeValues: null,
      __themeStyles: null,
      __userStyles: null,
      __userPaddings: null,
      __themePaddings: null,
      __isThemed: false,
      __stylesheet: null,

      /**
       * Collect all themable properties, which are not CSS properties
       */
      __initializeThemableProperties: function __initializeThemableProperties() {
        var PropertyUtil = qx.util.PropertyUtil;
        var cssProperties = qx.lang.Object.fromArray(this._getCssProperties());
        this.__themableProperties = [];
        var clazz = this.constructor;

        while (clazz) {
          var properties = PropertyUtil.getProperties(clazz);

          for (var prop in properties) {
            if (!cssProperties[prop]) {
              this.__themableProperties.push(prop);
            }
          }

          clazz = clazz.superclass;
        }
      },

      /**
       * Get a list of all properties, which should be applied as CSS styles.
       *
       * @return {Array} List of property names
       */
      _getCssProperties: function _getCssProperties() {
        return ["backgroundColor", "textColor", "font", "textAlign", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"];
      },
      // property apply
      _applyAppearance: function _applyAppearance(value, old) {
        if (old) {
          this.__themeStyles = {};
        }
      },

      /**
       * Compute the value of the given property
       *
       * @param propertyName {String} Name of the property
       * @return {var} The Property value
       */
      _getValue: function _getValue(propertyName) {
        if (this.__isThemed) {
          return qx.util.PropertyUtil.getThemeValue(this, propertyName);
        } else {
          return qx.util.PropertyUtil.getUserValue(this, propertyName);
        }
      },

      /**
       * Store a properties computed style string either in the user or in the
       * theme values. User values will be applied as inline styles, while theme
       * values are stored in a stylesheet.
       *
       * @param propertyName {String} The property name
       * @param styles {String} String with computed CSS styles
       */
      _storeStyle: function _storeStyle(propertyName, styles) {
        var store;

        if (this.__isThemed) {
          store = this.__themeStyles;
        } else {
          store = this.__userStyles;
        }

        if (styles === null) {
          delete store[propertyName];
        } else {
          store[propertyName] = styles;
        }
      },
      // property apply
      _applyBackgroundColor: function _applyBackgroundColor(value, old, name) {
        var value = this._getValue(name);

        if (!value) {
          this._storeStyle(name, null);
        } else {
          this._storeStyle(name, "background-color:" + qx.theme.manager.Color.getInstance().resolve(value));
        }
      },
      // property apply
      _applyTextColor: function _applyTextColor(value, old, name) {
        var value = this._getValue(name);

        if (!value) {
          this._storeStyle(name, null);
        } else {
          this._storeStyle(name, "color:" + qx.theme.manager.Color.getInstance().resolve(value));
        }
      },
      // property apply
      _applyTextAlign: function _applyTextAlign(value, old, name) {
        var value = this._getValue(name);

        if (!value) {
          this._storeStyle(name, null);
        } else {
          this._storeStyle(name, "text-align:" + value);
        }
      },
      // property apply
      _applyFont: function _applyFont(value, old, name) {
        var value = this._getValue(name);

        if (!value) {
          this._storeStyle(name, null);
        } else {
          var font = qx.theme.manager.Font.getInstance().resolve(value);

          this._storeStyle(name, qx.bom.element.Style.compile(font.getStyles()));
        }
      },
      // property apply
      _applyPadding: function _applyPadding(value, old, name) {
        var value = this._getValue(name);

        if (this.__isThemed) {
          var paddingStore = this.__themePaddings;
        } else {
          paddingStore = this.__userPaddings;
        }

        if (value === null) {
          delete paddingStore[name];
        } else {
          paddingStore[name] = value;
        }

        if (value === null) {
          this._storeStyle(name, null);
        } else {
          var cssKey = qx.bom.Style.getCssName(name);

          this._storeStyle(name, cssKey + ":" + value + "px");
        }
      },

      /*
      ---------------------------------------------------------------------------
        IMPLEMENT CELL API
      ---------------------------------------------------------------------------
      */
      // overridden
      getCellProperties: function getCellProperties(value, states) {
        this.__setStates(states);

        return {
          classes: this.getCssClasses(value, states),
          style: this.getStyles(value, states),
          attributes: this.getAttributes(value, states),
          content: this.getContent(value, states),
          insets: this.getInsets(value, states)
        };
      },
      // overridden
      getAttributes: function getAttributes(value, states) {
        return "";
      },
      // overridden
      getContent: function getContent(value, states) {
        return value;
      },
      // overridden
      getCssClasses: function getCssClasses(value, states) {
        var cssClass = this.__stylesheet.getCssClass(this.__statesKey) || "";
        return "qx-cell " + cssClass;
      },

      /**
       * Set the cell states and set the correct CSS class for the given state
       * combination
       *
       * @param states {Object} A map containing the cell's state names as map keys.
       */
      __setStates: function __setStates(states) {
        // Avoid errors if no states are set
        if (!states) {
          states = {};
        }

        var appearance = this.getAppearance();
        var statesKey = appearance + "-" + Object.keys(states).sort().join(" ");

        if (this.__statesKey == statesKey) {
          return;
        }

        this.__statesKey = statesKey;
        var themeStyles = this.__states[this.__statesKey];

        if (!themeStyles) {
          this.__clearThemedPropertyValues();

          this.__updateThemeableProperties(states);

          this.__computeCssClassForStates(states);

          this.__cacheThemedValues();

          this.__states[this.__statesKey] = 1;
        }

        this.__applyThemeValues();
      },

      /**
       * Remove the themed value from all CSS properties
       */
      __clearThemedPropertyValues: function __clearThemedPropertyValues() {
        var PropertyUtil = qx.util.PropertyUtil;

        var themableProperties = this._getCssProperties();

        for (var i = 0; i < themableProperties.length; i++) {
          PropertyUtil.deleteThemeValue(this, themableProperties[i]);
        }
      },

      /**
       * Set the new themed value for all CSS properties given the set of states
       *
       * @param states {Object} A map containing the cell's state names as map keys.
       */
      __updateThemeableProperties: function __updateThemeableProperties(states) {
        this.__themeStyles = {};
        this.__isThemed = true;
        var appearance = this.getAppearance();
        var PropertyUtil = qx.util.PropertyUtil;
        var styles = qx.theme.manager.Appearance.getInstance().styleFrom(appearance, states);

        for (var prop in styles) {
          if (styles[prop] !== undefined) {
            PropertyUtil.setThemed(this, prop, styles[prop]);
          }
        }

        this.__isThemed = false;
      },

      /**
       * Compute a CSS class for the current values of all CSS properties
       */
      __computeCssClassForStates: function __computeCssClassForStates() {
        var styleString = Object.values(this.__themeStyles).join(";");

        this.__stylesheet.computeClassForStyles(this.__statesKey, styleString);
      },

      /**
       * Cache the themed values for the current state combination
       */
      __cacheThemedValues: function __cacheThemedValues() {
        var properties = this.__themableProperties;
        var PropertyUtil = qx.util.PropertyUtil;
        var themeValues = {};

        for (var i = 0; i < properties.length; i++) {
          var key = properties[i];
          var value = PropertyUtil.getThemeValue(this, key);

          if (value !== undefined) {
            themeValues[key] = value;
          }
        }

        this.__themeValues[this.__statesKey] = themeValues;
      },

      /**
       * Apply the themed values to the properties
       */
      __applyThemeValues: function __applyThemeValues() {
        var PropertyUtil = qx.util.PropertyUtil;
        var themeValues = this.__themeValues[this.__statesKey] || {};

        for (var key in themeValues) {
          PropertyUtil.setThemed(this, key, themeValues[key]);
        }
      },
      // overridden
      getStyles: function getStyles(value, states) {
        return Object.values(this.__userStyles).join(";");
      },
      // overridden
      getInsets: function getInsets(value, states) {
        var user = this.__userPaddings;
        var theme = this.__themePaddings;
        var top = (user.paddingTop !== undefined ? user.paddingTop : theme.paddingTop) || 0;
        var right = (user.paddingRight !== undefined ? user.paddingRight : theme.paddingRight) || 0;
        var bottom = (user.paddingBottom !== undefined ? user.paddingBottom : theme.paddingBottom) || 0;
        var left = (user.paddingLeft !== undefined ? user.paddingLeft : theme.paddingLeft) || 0;
        return [left + right, top + bottom];
      }
    },
    destruct: function destruct() {
      this.__stylesheet = this.__userStyles = this.__themeStyles = this.__userPaddings = this.__themePaddings = this.__states = this.__themeValues = this.__themableProperties = null;
    }
  });
  qx.ui.virtual.cell.Cell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.IHtmlCellProvider": {
        "construct": true
      },
      "qx.bom.client.Css": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxmodel": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The HtmlCell layer renders each cell with custom HTML markup. The concrete
   * markup for each cell is provided by a cell provider.
   */
  qx.Class.define("qx.ui.virtual.layer.HtmlCell", {
    extend: qx.ui.virtual.layer.Abstract,

    /**
     * @param htmlCellProvider {qx.ui.virtual.core.IHtmlCellProvider} This class
     *    provides the HTML markup for each cell.
     */
    construct: function construct(htmlCellProvider) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this.setZIndex(12);
      {
        this.assertInterface(htmlCellProvider, qx.ui.virtual.core.IHtmlCellProvider);
      }
      this._cellProvider = htmlCellProvider;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Get the cell size taking the box model into account
       *
       * @param width {Integer} The cell's (border-box) width in pixel
       * @param height {Integer} The cell's (border-box) height in pixel
       * @param insetX {Integer} The cell's horizontal insets, i.e. the sum of
       *    horizontal paddings and borders
       * @param insetY {Integer} The cell's vertical insets, i.e. the sum of
       *    vertical paddings and borders
       * @return {String} The CSS style string for the cell size
       */
      _getCellSizeStyle: function _getCellSizeStyle(width, height, insetX, insetY) {
        var style = "";

        if (qx.core.Environment.get("css.boxmodel") == "content") {
          width -= insetX;
          height -= insetY;
        }

        style += "width:" + width + "px;";
        style += "height:" + height + "px;";
        return style;
      },
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];
        var left = 0;
        var top = 0;
        var row = firstRow;
        var column = firstColumn;

        for (var y = 0; y < rowSizes.length; y++) {
          var left = 0;
          var column = firstColumn;
          var height = rowSizes[y];

          for (var x = 0; x < columnSizes.length; x++) {
            var width = columnSizes[x];

            var cellProperties = this._cellProvider.getCellProperties(row, column);

            var insets = cellProperties.insets || [0, 0];
            html.push("<div ", "style='", "left:", left, "px;", "top:", top, "px;", this._getCellSizeStyle(width, height, insets[0], insets[1]), cellProperties.style || "", "' ", "class='", cellProperties.classes || "", "' ", cellProperties.attributes || "", ">", cellProperties.content || "", "</div>");
            column++;
            left += width;
          }

          top += height;
          row++;
        }

        this.getContentElement().setAttribute("html", html.join(""));
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._cellProvider = null;
    }
  });
  qx.ui.virtual.layer.HtmlCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A HTML cell provider provides the {@link qx.ui.virtual.layer.HtmlCell}
   * with HTML fragments to render the cells.
   */
  qx.Interface.define("qx.ui.virtual.core.IHtmlCellProvider", {
    members: {
      /**
       * Returns all relevant properties of the cell:
       * <ul>
       * <li>classes (String): Space separated class names</li>
       * <li>style (String): CSS styles</li>
       * <li>attributes (String): Space separated attributes</li>
       * <li>content (String): HTML fragment of the innerHTML of the cell</li>
       * <li>insets (Array): insets (padding + border) of the cell as
       * two-dimensional array.</li>
       * </ul>
       *
       * @param row {Integer} The cell's row index.
       * @param column {Integer} The cell's column index.
       *
       * @return {Map} Cell properties (see above.)
       */
      getCellProperties: function getCellProperties(row, column) {}
    }
  });
  qx.ui.virtual.core.IHtmlCellProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.layer.LayerTestCase": {
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {},
      "qx.ui.virtual.core.Axis": {},
      "qx.ui.virtual.layer.HtmlCellSpan": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Jonathan Weiß (jonathan_rass)
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.HtmlCellSpan", {
    extend: qx.test.ui.virtual.layer.LayerTestCase,
    members: {
      tearDown: function tearDown() {
        qx.test.ui.virtual.layer.HtmlCellSpan.prototype.tearDown.base.call(this);

        this.__cellRenderer.dispose();

        this.__rowConfig.dispose();

        this.__columnConfig.dispose();
      },
      _createLayer: function _createLayer() {
        this.__cellRenderer = new qx.ui.virtual.cell.Cell();
        this.__rowConfig = new qx.ui.virtual.core.Axis(10, 100);
        this.__columnConfig = new qx.ui.virtual.core.Axis(20, 100);
        return new qx.ui.virtual.layer.HtmlCellSpan(this, this.__rowConfig, this.__columnConfig);
      },
      getCellProperties: function getCellProperties(row, column) {
        return this.__cellRenderer.getCellProperties(row + " / " + column, {});
      },
      _assertCells: function _assertCells(firstRow, firstColumn, rowCount, columnCount, msg) {
        var children = this.layer.getContentElement().getDomElement().childNodes;
        this.assertEquals(rowCount * columnCount, children.length);

        for (var y = 0; y < rowCount; y++) {
          for (var x = 0; x < columnCount; x++) {
            var row = firstRow + y;
            var column = firstColumn + x;
            var cellEl = children[y * columnCount + x];
            this.assertEquals(row + " / " + column, cellEl.innerHTML);
          }
        }
      }
    },
    destruct: function destruct() {
      this.__cellRenderer = null;
    }
  });
  qx.test.ui.virtual.layer.HtmlCellSpan.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.HtmlCell": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.layer.CellSpanManager": {
        "construct": true
      },
      "qx.ui.core.queue.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * An extended HtmlCell layer, which adds the possibility to specify row and
   * column spans for specific cells.
   */
  qx.Class.define("qx.ui.virtual.layer.HtmlCellSpan", {
    extend: qx.ui.virtual.layer.HtmlCell,

    /**
     * @param htmlCellProvider {qx.ui.virtual.core.IHtmlCellProvider} This class
     *    provides the HTML markup for each cell.
     * @param rowConfig {qx.ui.virtual.core.Axis} The row configuration of the pane
     *    in which the cells will be rendered
     * @param columnConfig {qx.ui.virtual.core.Axis} The column configuration of
     *    the pane in which the cells will be rendered
     */
    construct: function construct(htmlCellProvider, rowConfig, columnConfig) {
      qx.ui.virtual.layer.HtmlCell.constructor.call(this, htmlCellProvider);
      this._spanManager = new qx.ui.virtual.layer.CellSpanManager(rowConfig, columnConfig);
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Set the row and column span for a specific cell
       *
       * @param row {PositiveInteger} The cell's row
       * @param column {PositiveInteger} The cell's column
       * @param rowSpan {PositiveInteger} The number of rows the cells spans
       * @param columnSpan {PositiveInteger} The number of columns the cells spans
       */
      setCellSpan: function setCellSpan(row, column, rowSpan, columnSpan) {
        var id = row + "x" + column;

        this._spanManager.removeCell(id);

        if (rowSpan > 1 || columnSpan > 1) {
          this._spanManager.addCell(id, row, column, rowSpan, columnSpan);
        }

        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * Renders a cell
       *
       * @param htmlArr {String[]} the output array
       * @param row {Integer} The cell's row index
       * @param column {Integer} The cell's column index
       * @param left {Integer} The cell's CSS left position (in pixel)
       * @param top {Integer} The cell's CSS top position (in pixel)
       * @param width {Integer} The cell's width
       * @param height {Integer} The cell's height
       */
      __renderCell: function __renderCell(htmlArr, row, column, left, top, width, height) {
        var cellProperties = this._cellProvider.getCellProperties(row, column);

        var insets = cellProperties.insets || [0, 0];
        htmlArr.push("<div ", "style='", "left:", left, "px;", "top:", top, "px;", this._getCellSizeStyle(width, height, insets[0], insets[1]), cellProperties.style || "", "' ", "class='", cellProperties.classes || "", "' ", cellProperties.attributes || "", ">", cellProperties.content || "", "</div>");
      },
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];

        var cells = this._spanManager.findCellsInWindow(firstRow, firstColumn, rowSizes.length, columnSizes.length);

        if (cells.length > 0) {
          var bounds = this._spanManager.getCellBounds(cells, firstRow, firstColumn);

          var spanMap = this._spanManager.computeCellSpanMap(cells, firstRow, firstColumn, rowSizes.length, columnSizes.length); // render spanning cells


          for (var i = 0, l = cells.length; i < l; i++) {
            var cell = cells[i];
            var cellBounds = bounds[i];

            this.__renderCell(html, cell.firstRow, cell.firstColumn, cellBounds.left, cellBounds.top, cellBounds.width, cellBounds.height);
          }
        } else {
          // create empty dummy map
          spanMap = [];

          for (var i = 0; i < rowSizes.length; i++) {
            spanMap[firstRow + i] = [];
          }
        } // render non spanning cells


        var left = 0;
        var top = 0;
        var row = firstRow;
        var column = firstColumn;

        for (var x = 0; x < rowSizes.length; x++) {
          var left = 0;
          var column = firstColumn;
          var height = rowSizes[x];

          for (var y = 0; y < columnSizes.length; y++) {
            var width = columnSizes[y];

            if (!spanMap[row][column]) {
              this.__renderCell(html, row, column, left, top, width, height);
            }

            column++;
            left += width;
          }

          top += height;
          row++;
        }

        this.getContentElement().setAttribute("html", html.join(""));
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("_spanManager");
    }
  });
  qx.ui.virtual.layer.HtmlCellSpan.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.layer.LayerTestCase": {
        "require": true
      },
      "qx.ui.virtual.layer.Row": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Jonathan Weiß (jonathan_rass)
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.Row", {
    extend: qx.test.ui.virtual.layer.LayerTestCase,
    members: {
      _createLayer: function _createLayer() {
        return new qx.ui.virtual.layer.Row("red", "green");
      },
      _assertCells: function _assertCells(firstRow, firstColumn, rowCount, columnCount, msg) {
        var children = this.layer.getContentElement().getDomElement().childNodes;
        this.assertEquals(rowCount, children.length);

        for (var i = 0; i < rowCount; i++) {
          var row = firstRow + i;

          if (row % 2 == 0) {
            this.assertCssColor("red", children[i].style.backgroundColor);
          } else {
            this.assertCssColor("green", children[i].style.backgroundColor);
          }
        }
      }
    }
  });
  qx.test.ui.virtual.layer.Row.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.layer.LayerTestCase": {
        "require": true
      },
      "qx.ui.virtual.layer.WidgetCell": {},
      "qx.ui.core.Widget": {},
      "qx.data.Array": {},
      "qx.ui.core.Spacer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Jonathan Weiß (jonathan_rass)
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.WidgetCell", {
    extend: qx.test.ui.virtual.layer.LayerTestCase,
    members: {
      setUp: function setUp() {
        this._pool = [];
        qx.test.ui.virtual.layer.WidgetCell.prototype.setUp.base.call(this);
      },
      tearDown: function tearDown() {
        for (var i = 0; i < this._pool.length; i++) {
          this._pool[i].destroy();
        }

        this.flush();
        this._pool = null;
        qx.test.ui.virtual.layer.WidgetCell.prototype.tearDown.base.call(this);
      },
      _createLayer: function _createLayer() {
        return new qx.ui.virtual.layer.WidgetCell(this);
      },
      getCellWidget: function getCellWidget(row, column) {
        var widget = this._pool.pop() || new qx.ui.core.Widget();
        widget.setBackgroundColor((row + column) % 2 == 0 ? "red" : "green");
        return widget;
      },
      poolCellWidget: function poolCellWidget(widget) {
        widget.setUserData("row", -1);
        widget.setUserData("column", -1);

        this._pool.push(widget);
      },
      _assertCells: function _assertCells(firstRow, firstColumn, rowCount, columnCount, msg) {
        var children = this.layer._getChildren();

        this.assertEquals(rowCount * columnCount, children.length);

        for (var y = 0; y < rowCount; y++) {
          for (var x = 0; x < columnCount; x++) {
            var row = firstRow + y;
            var column = firstColumn + x;
            var widget = children[y * columnCount + x];
            this.assertEquals(row, widget.getUserData("cell.row"));
            this.assertEquals(column, widget.getUserData("cell.column"));
          }
        }
      },
      testGetRenderedCellWidget: function testGetRenderedCellWidget() {
        var pool = new qx.data.Array();
        pool.setAutoDisposeItems(true);
        var layer = new qx.ui.virtual.layer.WidgetCell({
          getCellWidget: function getCellWidget(row, column) {
            var widget = new qx.ui.core.Widget();
            widget.setUserData("test", row + "/" + column);
            pool.push(widget);
            return row == 2 && column == 2 ? null : widget;
          },
          poolCellWidget: function poolCellWidget(widget) {}
        });
        this.getRoot().add(layer);
        this.flush();
        layer.fullUpdate(1, 1, [10, 10, 10], [50, 50, 50]);
        this.flush();
        this.assertEquals(null, layer.getRenderedCellWidget(0, 0));
        this.assertEquals(null, layer.getRenderedCellWidget(0, 1));
        this.assertEquals(null, layer.getRenderedCellWidget(1, 0));
        this.assertEquals(null, layer.getRenderedCellWidget(2, 2));
        this.assertEquals(null, layer.getRenderedCellWidget(4, 1));
        this.assertEquals(null, layer.getRenderedCellWidget(1, 4));
        this.assertEquals(null, layer.getRenderedCellWidget(4, 4));
        this.assertEquals("1/1", layer.getRenderedCellWidget(1, 1).getUserData("test"));
        this.assertEquals("1/3", layer.getRenderedCellWidget(1, 3).getUserData("test"));
        this.assertEquals("3/1", layer.getRenderedCellWidget(3, 1).getUserData("test"));
        this.assertEquals("3/3", layer.getRenderedCellWidget(3, 3).getUserData("test"));
        layer.destroy();
        pool.dispose();
      },
      testEmptyCells: function testEmptyCells() {
        var layer = new qx.ui.virtual.layer.WidgetCell({
          getCellWidget: function getCellWidget(row, column) {
            return column === 0 ? new qx.ui.core.Widget() : null;
          },
          poolCellWidget: function poolCellWidget(widget) {
            widget.destroy();
          }
        });
        this.getRoot().add(layer);
        this.flush();
        layer.fullUpdate(0, 0, [10, 10, 10, 10, 10, 10], [30, 30, 30]);
        this.flush();
        var children = layer.getChildren();

        for (var y = 0; y <= 5; y++) {
          for (var x = 0; x <= 2; x++) {
            var child = children[y * 3 + x];

            if (x === 0) {
              this.assertInstance(child, qx.ui.core.Widget);
            } else {
              this.assertInstance(child, qx.ui.core.Spacer);
            }
          }
        }

        layer.destroy();
      }
    }
  });
  qx.test.ui.virtual.layer.WidgetCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.layer.LayerTestCase": {
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {},
      "qx.ui.virtual.core.Axis": {},
      "qx.ui.virtual.layer.WidgetCellSpan": {},
      "qx.ui.core.Widget": {},
      "qx.data.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Jonathan Weiß (jonathan_rass)
     * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.layer.WidgetCellSpan", {
    extend: qx.test.ui.virtual.layer.LayerTestCase,
    members: {
      setUp: function setUp() {
        this._pool = [];
        qx.test.ui.virtual.layer.WidgetCellSpan.prototype.setUp.base.call(this);
      },
      tearDown: function tearDown() {
        qx.test.ui.virtual.layer.WidgetCellSpan.prototype.tearDown.base.call(this);

        this._disposeArray("_pool");

        this.__cellRenderer.dispose();

        this.__rowConfig.dispose();

        this.__columnConfig.dispose();
      },
      _createLayer: function _createLayer() {
        this.__cellRenderer = new qx.ui.virtual.cell.Cell();
        this.__rowConfig = new qx.ui.virtual.core.Axis(10, 100);
        this.__columnConfig = new qx.ui.virtual.core.Axis(20, 100);
        return new qx.ui.virtual.layer.WidgetCellSpan(this, this.__rowConfig, this.__columnConfig);
      },
      getCellWidget: function getCellWidget(row, column) {
        var widget = this._pool.pop() || new qx.ui.core.Widget();
        widget.setBackgroundColor((row + column) % 2 == 0 ? "red" : "green");
        return widget;
      },
      poolCellWidget: function poolCellWidget(widget) {
        this._pool.push(widget);
      },
      _assertCells: function _assertCells(firstRow, firstColumn, rowCount, columnCount, msg) {
        var children = this.layer._cellLayer._getChildren();

        this.assertEquals(rowCount * columnCount, children.length);

        for (var y = 0; y < rowCount; y++) {
          for (var x = 0; x < columnCount; x++) {
            var row = firstRow + y;
            var column = firstColumn + x;
            var widget = children[y * columnCount + x];
            this.assertEquals(row, widget.getUserData("cell.row"));
            this.assertEquals(column, widget.getUserData("cell.column"));
          }
        }
      },
      testGetRenderedCellWidget: function testGetRenderedCellWidget() {
        var rowConfig = new qx.ui.virtual.core.Axis(10, 100);
        var columnConfig = new qx.ui.virtual.core.Axis(20, 100);
        var pool = new qx.data.Array();
        pool.setAutoDisposeItems(true);
        var layer = new qx.ui.virtual.layer.WidgetCellSpan({
          getCellWidget: function getCellWidget(row, column) {
            var widget = new qx.ui.core.Widget();
            widget.setUserData("test", row + "/" + column);
            pool.push(widget);
            return row == 1 && column == 2 ? null : widget;
          },
          poolCellWidget: function poolCellWidget(widget) {}
        }, rowConfig, columnConfig);
        layer.setCellSpan(2, 0, 1, 2);
        layer.setCellSpan(2, 3, 1, 2);
        layer.setCellSpan(2, 2, 2, 1);
        this.getRoot().add(layer);
        this.flush();
        layer.fullUpdate(1, 1, [10, 10, 10], [50, 50, 50]);
        this.flush();
        this.assertEquals(null, layer.getRenderedCellWidget(0, 0));
        this.assertEquals(null, layer.getRenderedCellWidget(0, 1));
        this.assertEquals(null, layer.getRenderedCellWidget(1, 0));
        this.assertEquals(null, layer.getRenderedCellWidget(1, 2));
        this.assertEquals(null, layer.getRenderedCellWidget(4, 1));
        this.assertEquals(null, layer.getRenderedCellWidget(1, 4));
        this.assertEquals(null, layer.getRenderedCellWidget(4, 4)); // non spanning cells

        this.assertEquals("1/1", layer.getRenderedCellWidget(1, 1).getUserData("test"));
        this.assertEquals("1/3", layer.getRenderedCellWidget(1, 3).getUserData("test"));
        this.assertEquals("3/1", layer.getRenderedCellWidget(3, 1).getUserData("test"));
        this.assertEquals("3/3", layer.getRenderedCellWidget(3, 3).getUserData("test")); // spanning cells

        this.assertEquals("2/0", layer.getRenderedCellWidget(2, 0).getUserData("test"));
        this.assertEquals("2/0", layer.getRenderedCellWidget(2, 1).getUserData("test"));
        this.assertEquals("2/3", layer.getRenderedCellWidget(2, 3).getUserData("test"));
        this.assertEquals("2/3", layer.getRenderedCellWidget(2, 4).getUserData("test"));
        this.assertEquals("2/2", layer.getRenderedCellWidget(2, 2).getUserData("test"));
        this.assertEquals("2/2", layer.getRenderedCellWidget(3, 2).getUserData("test"));
        layer.destroy();
        rowConfig.dispose();
        columnConfig.dispose();
        pool.dispose();
      }
    },
    destruct: function destruct() {
      this.__cellRenderer = null;
    }
  });
  qx.test.ui.virtual.layer.WidgetCellSpan.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MChildrenHandling": {
        "require": true
      },
      "qx.ui.virtual.layer.CellSpanManager": {
        "construct": true
      },
      "qx.ui.virtual.layer.WidgetCell": {
        "construct": true
      },
      "qx.ui.layout.Grow": {
        "construct": true
      },
      "qx.ui.core.queue.Widget": {},
      "qx.ui.core.Spacer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * An extended WidgetCell layer, which adds the possibility to specify row and
   * column spans for specific cells.
   */
  qx.Class.define("qx.ui.virtual.layer.WidgetCellSpan", {
    extend: qx.ui.virtual.layer.Abstract,
    include: [qx.ui.core.MChildrenHandling],

    /**
    * @param widgetCellProvider {qx.ui.virtual.core.IWidgetCellProvider} This
     *    class manages the life cycle of the cell widgets.
     * @param rowConfig {qx.ui.virtual.core.Axis} The row configuration of the pane
     *    in which the cells will be rendered
     * @param columnConfig {qx.ui.virtual.core.Axis} The column configuration of the pane
     *    in which the cells will be rendered
     */
    construct: function construct(widgetCellProvider, rowConfig, columnConfig) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this.setZIndex(12);
      this._spanManager = new qx.ui.virtual.layer.CellSpanManager(rowConfig, columnConfig);
      this._cellProvider = widgetCellProvider;
      this.__spacerPool = [];
      this._cellLayer = new qx.ui.virtual.layer.WidgetCell(this.__getCellProviderForNonSpanningCells());

      this._cellLayer.setZIndex(0);

      this._setLayout(new qx.ui.layout.Grow());

      this._add(this._cellLayer);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      anonymous: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the widget used to render the given cell. May return null if the
       * cell isn’t rendered currently rendered.
       *
       * @param row {Integer} The cell's row index
       * @param column {Integer} The cell's column index
       * @return {qx.ui.core.LayoutItem|null} the widget used to render the given
       *    cell or <code>null</code>
       */
      getRenderedCellWidget: function getRenderedCellWidget(row, column) {
        var widget = this._cellLayer.getRenderedCellWidget(row, column);

        if (!widget || widget.getUserData("cell.spanning")) {
          var children = this._getChildren();

          for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];

            if (child == this._cellLayer) {
              continue;
            }

            var cell = {
              row: child.getUserData("cell.row"),
              column: child.getUserData("cell.column"),
              rowSpan: child.getUserData("cell.rowspan"),
              colSpan: child.getUserData("cell.colspan")
            };

            if (cell.row <= row && row < cell.row + cell.rowSpan && cell.column <= column && column < cell.column + cell.colSpan) {
              return child;
            }
          }

          return null;
        }

        return widget;
      },
      __spacerPool: null,

      /**
       * Set the row and column span for a specific cell
       *
       * @param row {PositiveInteger} The cell's row
       * @param column {PositiveInteger} The cell's column
       * @param rowSpan {PositiveInteger} The number of rows the cells spans
       * @param columnSpan {PositiveInteger} The number of columns the cells spans
       */
      setCellSpan: function setCellSpan(row, column, rowSpan, columnSpan) {
        var id = row + "x" + column;

        this._spanManager.removeCell(id);

        if (rowSpan > 1 || columnSpan > 1) {
          this._spanManager.addCell(id, row, column, rowSpan, columnSpan);
        }

        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * Get the spacer widget, for span cells
       *
       * @return {qx.ui.core.Spacer} The spacer widget.
       */
      _getSpacer: function _getSpacer() {
        var spacer = this.__spacerPool.pop();

        if (!spacer) {
          spacer = new qx.ui.core.Spacer();
          spacer.setUserData("cell.empty", 1);
          spacer.setUserData("cell.spanning", 1);
        }

        return spacer;
      },

      /**
       * Get the cell provider for the non spanning cells
       *
       * @return {qx.ui.virtual.core.IWidgetCellProvider} the cell provider
       */
      __getCellProviderForNonSpanningCells: function __getCellProviderForNonSpanningCells() {
        var self = this;
        var cellProvider = this._cellProvider;
        var spacerPool = this.__spacerPool;
        var nonSpanningCellProvider = {
          getCellWidget: function getCellWidget(row, column) {
            if (!self._spanMap[row][column]) {
              var widget = cellProvider.getCellWidget(row, column);
            } else {
              var widget = self._getSpacer();
            }

            return widget;
          },
          poolCellWidget: function poolCellWidget(widget) {
            if (widget.getUserData("cell.spanning")) {
              spacerPool.push(widget);
            } else {
              cellProvider.poolCellWidget(widget);
            }
          }
        };
        return nonSpanningCellProvider;
      },

      /**
       * Updates the fields <code>_cells</code>, <code>_bounds</code> and
       * <code>_spanMap</code> according to the given grid window.
       *
       * @param firstRow {PositiveInteger} first visible row
       * @param firstColumn {PositiveInteger} first visible column
       * @param rowCount {PositiveInteger} number of rows to update
       * @param columnCount {PositiveInteger} number columns to update
       */
      __updateCellSpanData: function __updateCellSpanData(firstRow, firstColumn, rowCount, columnCount) {
        this._cells = this._spanManager.findCellsInWindow(firstRow, firstColumn, rowCount, columnCount);

        if (this._cells.length > 0) {
          this._bounds = this._spanManager.getCellBounds(this._cells, firstRow, firstColumn);
          this._spanMap = this._spanManager.computeCellSpanMap(this._cells, firstRow, firstColumn, rowCount, columnCount);
        } else {
          this._bounds = []; // create empty dummy map

          this._spanMap = [];

          for (var i = 0; i < rowCount; i++) {
            this._spanMap[firstRow + i] = [];
          }
        }
      },

      /**
       * Updates the widget in spanned cells.
       *
       * Note: The method {@link #__updateCellSpanData} must be called before
       * this method is called:
       */
      __updateCellSpanWidgets: function __updateCellSpanWidgets() {
        // remove and pool existing cells
        var children = this.getChildren();

        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];

          if (child !== this._cellLayer) {
            this._cellProvider.poolCellWidget(child);

            this._remove(child);
          }
        }

        for (var i = 0, l = this._cells.length; i < l; i++) {
          var cell = this._cells[i];
          var cellBounds = this._bounds[i];

          var cellWidget = this._cellProvider.getCellWidget(cell.firstRow, cell.firstColumn);

          if (cellWidget) {
            cellWidget.setUserBounds(cellBounds.left, cellBounds.top, cellBounds.width, cellBounds.height);
            cellWidget.setUserData("cell.row", cell.firstRow);
            cellWidget.setUserData("cell.column", cell.firstColumn);
            cellWidget.setUserData("cell.rowspan", cell.lastRow - cell.firstRow + 1);
            cellWidget.setUserData("cell.colspan", cell.lastColumn - cell.firstColumn + 1);

            this._add(cellWidget);
          }
        }
      },
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        this.__updateCellSpanData(firstRow, firstColumn, rowSizes.length, columnSizes.length);

        this.__updateCellSpanWidgets();

        this._cellLayer.fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
      },
      // overridden
      _updateLayerWindow: function _updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        this.__updateCellSpanData(firstRow, firstColumn, rowSizes.length, columnSizes.length);

        this.__updateCellSpanWidgets();

        this._cellLayer.updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes);
      }
    },
    destruct: function destruct() {
      var children = this._getChildren();

      for (var i = 0; i < children.length; i++) {
        children[i].dispose();
      }

      this._disposeObjects("_spanManager", "_cellLayer");

      this._cellProvider = this.__spacerPool = this._cells = this._bounds = this._spanMap = null;
    }
  });
  qx.ui.virtual.layer.WidgetCellSpan.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "construct": true,
        "require": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.AbstractLayerTest", {
    extend: qx.test.ui.LayoutTestCase,
    type: "abstract",
    construct: function construct() {
      qx.test.ui.LayoutTestCase.constructor.call(this);
      this.rowCount = 30;
      this.rowHeight = 20;
      this.colCount = 20;
      this.colWidth = 40;
    },
    members: {
      ITERATIONS: 2,
      // was 24
      setUp: function setUp() {
        this.layer = this.getLayer().set({
          width: 1000,
          height: 1000
        });
        this.getRoot().add(this.layer);
        this.flush();
        this.rowSizes = [];

        for (var i = 0; i < this.rowCount; i++) {
          this.rowSizes.push(this.rowHeight);
        }

        this.colSizes = [];

        for (var i = 0; i < this.colCount; i++) {
          this.colSizes.push(this.colWidth);
        }
      },
      tearDown: function tearDown() {
        this.layer.destroy();
      },
      getLayer: function getLayer() {
        // throw an exception if the method is called on the abstract class
        throw new Error("Abstract method call (getLayer) in 'AbstractLayerTest'!");
      },
      testFullUpdateSameWindow: function testFullUpdateSameWindow() {
        this.profile("fullUpdate (same window)", function () {
          this.layer.fullUpdate(0, 0, this.rowSizes, this.colSizes);
        }, this, this.ITERATIONS);
      },
      testFullUpdateScrollDown: function testFullUpdateScrollDown() {
        var startRow = 0;
        this.profile("fullUpdate (scroll)", function () {
          this.layer.fullUpdate(startRow, 0, this.rowSizes, this.colSizes);
          startRow++;
        }, this, this.ITERATIONS);
      },
      testUpdateLayerWindowScrollDown: function testUpdateLayerWindowScrollDown() {
        var startRow = 0;
        this.profile("scroll down 10 lines", function () {
          this.layer.updateLayerWindow(startRow, 0, this.rowSizes, this.colSizes);
          startRow += 10;
        }, this, this.ITERATIONS);
      },
      testUpdateLayerWindowScrollRight: function testUpdateLayerWindowScrollRight() {
        var startCol = 0;
        this.profile("scroll right 10 columns", function () {
          this.layer.updateLayerWindow(0, startCol, this.rowSizes, this.colSizes);
          startCol += 10;
        }, this, this.ITERATIONS);
      },
      testUpdateLayerData: function testUpdateLayerData() {
        this.layer.fullUpdate(0, 0, this.rowSizes, this.colSizes);
        this.flush();
        this.profile("update layer data", function () {
          this.layer.updateLayerData();
        }, this, this.ITERATIONS);
      },
      profile: function profile(name, fcn, context, count) {
        if (window.console && window.console.profile) console.profile(name + "; " + this.classname);
        var times = [];

        for (var i = 0, l = count; i < l; i++) {
          var start = new Date();
          fcn.call(context);
          this.flush();
          var duration = new Date() - start;
          times.push(duration);
        }

        times.sort(function (a, b) {
          return a < b ? -1 : 1;
        });
        var avg = Math.round(qx.lang.Array.sum(times.slice(1, -1)) / (times.length - 2)); //this.warn(";" + name + "; avg(" + avg + "ms); " + times.join("ms; ") + "ms;");

        this.warn(";" + name + ";avg:" + avg + ";" + times.join(";"));
        if (window.console && window.console.profile) console.profileEnd(name + " " + this.classname);
      }
    }
  });
  qx.test.ui.virtual.performance.AbstractLayerTest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.performance.AbstractLayerTest": {
        "require": true
      },
      "qx.test.ui.virtual.performance.layer.DomCell": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.DomCell", {
    extend: qx.test.ui.virtual.performance.AbstractLayerTest,
    type: "abstract",
    // disabled
    members: {
      getLayer: function getLayer() {
        return new qx.test.ui.virtual.performance.layer.DomCell();
      }
    }
  });
  qx.test.ui.virtual.performance.DomCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "require": true
      },
      "qx.bom.element.Style": {},
      "qx.bom.element.Attribute": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.layer.DomCell", {
    extend: qx.ui.virtual.layer.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var el = this.getContentElement().getDomElement();
        el.innerHTML = "";
        var Style = qx.bom.element.Style;
        var Attribute = qx.bom.element.Attribute;
        var left = 0;
        var top = 0;
        var row = firstRow;
        var col = firstColumn;
        var fragment = document.createDocumentFragment();

        for (var x = 0; x < rowSizes.length; x++) {
          var left = 0;
          var col = firstColumn;

          for (var y = 0; y < columnSizes.length; y++) {
            var content = col + " / " + row;
            var cell = document.createElement("div");
            Style.setCss(cell, ["position:absolute;", "left:", left, "px;", "top:", top, "px;", "width:", columnSizes[y], "px;", "height:", rowSizes[x], "px;"].join(""));
            Attribute.set(cell, "text", content);
            left += columnSizes[y];
            fragment.appendChild(cell);
          }

          top += rowSizes[x];
          row++;
        }

        el.appendChild(fragment);
      }
    }
  });
  qx.test.ui.virtual.performance.layer.DomCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.performance.AbstractLayerTest": {
        "require": true
      },
      "qx.test.ui.virtual.performance.layer.DomPoolCell": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.DomPoolCell", {
    extend: qx.test.ui.virtual.performance.AbstractLayerTest,
    type: "abstract",
    // disabled
    members: {
      getLayer: function getLayer() {
        return new qx.test.ui.virtual.performance.layer.DomPoolCell();
      }
    }
  });
  qx.test.ui.virtual.performance.DomPoolCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.queue.Manager": {},
      "qx.bom.element.Style": {},
      "qx.bom.element.Attribute": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.layer.DomPoolCell", {
    extend: qx.ui.virtual.layer.Abstract,
    construct: function construct() {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this._nodePool = [];
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _nodePool: null,
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        qx.ui.core.queue.Manager.flush();
        var start = new Date();
        var el = this.getContentElement().getDomElement();

        if (!el) {
          return;
        }

        var childNodes = el.childNodes;
        var i = 0;
        el.innerHTML = "";
        var Style = qx.bom.element.Style;
        var Attribute = qx.bom.element.Attribute;
        var left = 0;
        var top = 0;
        var row = firstRow;
        var col = firstColumn;

        for (var x = 0; x < rowSizes.length; x++) {
          var left = 0;
          var col = firstColumn;

          for (var y = 0; y < columnSizes.length; y++) {
            var content = col + " / " + row;
            var cell = childNodes[i++];

            if (!cell) {
              var cell = document.createElement("div");
              var doAppend = true;
            }

            Style.setCss(cell, ["position:absolute;", "left:", left, "px;", "top:", top, "px;", "width:", columnSizes[y], "px;", "height:", rowSizes[x], "px;"].join(""));
            Attribute.set(cell, "text", content);
            left += columnSizes[y];

            if (doAppend) {
              el.appendChild(cell);
            }
          }

          top += rowSizes[x];
          row++;
        }

        for (var j = i; j < childNodes.length; i++) {
          el.removeChild(childNodes[i]);
        }
      }
    }
  });
  qx.test.ui.virtual.performance.layer.DomPoolCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.performance.AbstractLayerTest": {
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {},
      "qx.ui.virtual.layer.HtmlCell": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.HtmlDivCell", {
    extend: qx.test.ui.virtual.performance.AbstractLayerTest,
    type: "abstract",
    // disabled
    members: {
      getLayer: function getLayer() {
        this.__cellRenderer = new qx.ui.virtual.cell.Cell();
        return new qx.ui.virtual.layer.HtmlCell(this);
      },
      getCellProperties: function getCellProperties(row, column) {
        return this.__cellRenderer.getCellProperties(row + " / " + column, {});
      }
    }
  });
  qx.test.ui.virtual.performance.HtmlDivCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.performance.AbstractLayerTest": {
        "require": true
      },
      "qx.test.ui.virtual.performance.layer.HtmlDivRelative": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.HtmlDivRelative", {
    extend: qx.test.ui.virtual.performance.AbstractLayerTest,
    type: "abstract",
    // disabled
    members: {
      getLayer: function getLayer() {
        return new qx.test.ui.virtual.performance.layer.HtmlDivRelative();
      }
    }
  });
  qx.test.ui.virtual.performance.HtmlDivRelative.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.layer.HtmlDivRelative", {
    extend: qx.ui.virtual.layer.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];
        var left = 0;
        var top = 0;
        var row = firstRow;
        var col = firstColumn;

        for (var x = 0; x < rowSizes.length; x++) {
          var left = 0;
          var col = firstColumn;

          for (var y = 0; y < columnSizes.length; y++) {
            var content = col + " / " + row;
            html.push("<div style='", "float: left;", "width:", columnSizes[y], "px;", "height:", rowSizes[x], "px;", "'>", content, "</div>");
            col++;
            left += columnSizes[y];
          }

          top += rowSizes[x];
          row++;
        }

        this.getContentElement().setAttribute("html", html.join(""));
      }
    }
  });
  qx.test.ui.virtual.performance.layer.HtmlDivRelative.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.performance.AbstractLayerTest": {
        "require": true
      },
      "qx.test.ui.virtual.performance.layer.HtmlTableCell": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.HtmlTableCell", {
    extend: qx.test.ui.virtual.performance.AbstractLayerTest,
    type: "abstract",
    // disabled
    members: {
      getLayer: function getLayer() {
        return new qx.test.ui.virtual.performance.layer.HtmlTableCell(this);
      },
      getCellHtml: function getCellHtml(row, column, left, top, width, height) {
        var html = ["<td ", "style='", "border-collapse: collapse;", "margin: 0px;", "padding: 0px;", "'>", row, " / ", column, "</td>"];
        return html.join("");
      }
    }
  });
  qx.test.ui.virtual.performance.HtmlTableCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.layer.HtmlTableCell", {
    extend: qx.ui.virtual.layer.Abstract,
    construct: function construct(htmlCellProvider) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this._cellProvider = htmlCellProvider;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];
        var left = 0;
        var top = 0;
        var row = firstRow;
        var column = firstColumn;
        html.push('<table style="table-layout:fixed; border-collapse: collapse; margin: 0px; padding: 0px;">');
        html.push('<colgroup>');

        for (var y = 0; y < columnSizes.length; y++) {
          html.push('<col width="' + columnSizes[y] + '">');
        }

        html.push('</colgroup>');

        for (var x = 0; x < rowSizes.length; x++) {
          var left = 0;
          var column = firstColumn;
          var height = rowSizes[x];
          html.push('<tr height="' + height + '" style="border-collapse: collapse; margin: 0px; padding: 0px;">');

          for (var y = 0; y < columnSizes.length; y++) {
            var width = columnSizes[y];
            html.push(this._cellProvider.getCellHtml(row, column, left, top, width, height));
            column++;
            left += width;
          }

          html.push("</tr>");
          top += height;
          row++;
        }

        html.push("</table>");
        this.getContentElement().setAttribute("html", html.join(""));
      }
    }
  });
  qx.test.ui.virtual.performance.layer.HtmlTableCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.performance.AbstractLayerTest": {
        "require": true
      },
      "qx.test.ui.virtual.performance.layer.HtmlTableCellNaive": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.HtmlTableCellNaive", {
    extend: qx.test.ui.virtual.performance.AbstractLayerTest,
    type: "abstract",
    // disabled
    members: {
      getLayer: function getLayer() {
        return new qx.test.ui.virtual.performance.layer.HtmlTableCellNaive(this);
      },
      getCellHtml: function getCellHtml(row, column, left, top, width, height) {
        var html = ["<td ", "width: " + width + " ", "height: " + height + " ", "style='", "border-collapse: collapse;", "margin: 0px;", "padding: 0px;", "'>", row, " / ", column, "</td>"];
        return html.join("");
      }
    }
  });
  qx.test.ui.virtual.performance.HtmlTableCellNaive.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.layer.HtmlTableCellNaive", {
    extend: qx.ui.virtual.layer.Abstract,
    construct: function construct(htmlCellProvider) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this._cellProvider = htmlCellProvider;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];
        var left = 0;
        var top = 0;
        var row = firstRow;
        var column = firstColumn;
        html.push('<table style="border-collapse: collapse; margin: 0px; padding: 0px;">');

        for (var x = 0; x < rowSizes.length; x++) {
          var left = 0;
          var column = firstColumn;
          var height = rowSizes[x];
          html.push('<tr style="border-collapse: collapse; margin: 0px; padding: 0px;">');

          for (var y = 0; y < columnSizes.length; y++) {
            var width = columnSizes[y];
            html.push(this._cellProvider.getCellHtml(row, column, left, top, width, height));
            column++;
            left += width;
          }

          html.push("</tr>");
          top += height;
          row++;
        }

        html.push("</table>");
        this.getContentElement().setAttribute("html", html.join(""));
      }
    }
  });
  qx.test.ui.virtual.performance.layer.HtmlTableCellNaive.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.performance.AbstractLayerTest": {
        "require": true
      },
      "qx.test.ui.virtual.performance.layer.HtmlTableCssCell": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.HtmlTableCssCell", {
    extend: qx.test.ui.virtual.performance.AbstractLayerTest,
    type: "abstract",
    // disabled
    members: {
      getLayer: function getLayer() {
        return new qx.test.ui.virtual.performance.layer.HtmlTableCssCell(this);
      },
      getCellHtml: function getCellHtml(row, column, left, top, width, height) {
        var html = ["<td>", row, " / ", column, "</td>"];
        return html.join("");
      }
    }
  });
  qx.test.ui.virtual.performance.HtmlTableCssCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.bom.element.Style": {
        "construct": true
      },
      "qx.bom.Stylesheet": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.layer.HtmlTableCssCell", {
    extend: qx.ui.virtual.layer.Abstract,
    construct: function construct(htmlCellProvider) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this._cellProvider = htmlCellProvider;
      var clazz = qx.test.ui.virtual.performance.layer.HtmlTableCssCell;

      if (!clazz.__style) {
        var stylesheet = "table.qooxdoo-table {" + qx.bom.element.Style.compile({
          "tableLayout": "fixed",
          "borderCollapse": "collapse",
          "margin": "0px",
          "padding": "0px"
        }) + "} " + "table.qooxdoo-table tr {" + qx.bom.element.Style.compile({
          "margin": "0px",
          "padding": "0px"
        }) + "} " + "table.qooxdoo-table tr td {" + qx.bom.element.Style.compile({
          "margin": "0px",
          "padding": "0px"
        }) + "} ";
        clazz.__style = qx.bom.Stylesheet.createElement(stylesheet);
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];
        var left = 0;
        var top = 0;
        var row = firstRow;
        var column = firstColumn;
        html.push('<table class="qooxdoo-table">');
        html.push('<colgroup>');

        for (var y = 0; y < columnSizes.length; y++) {
          html.push('<col width=' + columnSizes[y] + '>');
        }

        html.push('</colgroup>');

        for (var x = 0; x < rowSizes.length; x++) {
          var left = 0;
          var column = firstColumn;
          var height = rowSizes[x];
          html.push('<tr height=' + height + '>');

          for (var y = 0; y < columnSizes.length; y++) {
            var width = columnSizes[y];
            html.push(this._cellProvider.getCellHtml(row, column, left, top, width, height));
            column++;
            left += width;
          }

          html.push("</tr>");
          top += height;
          row++;
        }

        html.push("</table>");
        this.getContentElement().setAttribute("html", html.join(""));
      }
    }
  });
  qx.test.ui.virtual.performance.layer.HtmlTableCssCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.virtual.performance.AbstractLayerTest": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.layer.WidgetCell": {},
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.ui.virtual.performance.WidgetCell", {
    extend: qx.test.ui.virtual.performance.AbstractLayerTest,
    type: "abstract",
    // disabled
    construct: function construct() {
      qx.test.ui.virtual.performance.AbstractLayerTest.constructor.call(this);
      this._pool = [];
    },
    members: {
      ITERATIONS: 3,
      getLayer: function getLayer() {
        return new qx.ui.virtual.layer.WidgetCell(this);
      },
      getCellWidget: function getCellWidget(row, column) {
        var widget = this._pool.pop() || new qx.ui.basic.Label();
        widget.setContent(row + " / " + column);
        return widget;
      },
      poolCellWidget: function poolCellWidget(widget) {
        this._pool.push(widget);
      }
    }
  });
  qx.test.ui.virtual.performance.WidgetCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.window.Manager": {},
      "qx.ui.window.Desktop": {},
      "qx.ui.window.Window": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
   qooxdoo - the new era of web development
  
   http://qooxdoo.org
  
   Copyright:
   2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
   License:
       MIT: https://opensource.org/licenses/MIT
   See the LICENSE file in the project's top-level directory for details.
  
   Authors:
   * Fabian Jakobs (fjakobs)
  
   ************************************************************************ */
  qx.Class.define("qx.test.ui.window.Desktop", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        qx.test.ui.window.Desktop.prototype.setUp.base.call(this);
        var windowManager = new qx.ui.window.Manager();
        var desktop = new qx.ui.window.Desktop(windowManager);
        this.getRoot().add(desktop);
        this.desktop = desktop;
      },
      tearDown: function tearDown() {
        this.desktop.destroy();
        qx.test.ui.window.Desktop.prototype.tearDown.base.call(this);
        this.flush();
      },
      testEvents: function testEvents() {
        var window = new qx.ui.window.Window("Window");
        window.set({
          width: 300,
          height: 200,
          showClose: false,
          showMinimize: false
        });
        this.assertEventFired(this.desktop, "windowAdded", function () {
          this.desktop.add(window);
        }.bind(this));
        this.assertEventFired(this.desktop, "windowRemoved", function () {
          this.desktop.remove(window);
        }.bind(this));
      },
      destruct: function destruct() {
        this.desktop = null;
      }
    }
  });
  qx.test.ui.window.Desktop.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MChildrenHandling": {
        "require": true
      },
      "qx.ui.window.MDesktop": {
        "require": true
      },
      "qx.ui.core.MBlocker": {
        "require": true
      },
      "qx.ui.window.IDesktop": {
        "require": true
      },
      "qx.ui.window.Window": {
        "construct": true
      },
      "qx.ui.layout.Canvas": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The desktop is a widget, which can act as container for windows. It can be
   * used to define a clipping region for internal windows e.g. to create
   * an MDI like application.
   */
  qx.Class.define("qx.ui.window.Desktop", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MChildrenHandling, qx.ui.window.MDesktop, qx.ui.core.MBlocker],
    implement: qx.ui.window.IDesktop,

    /**
     * @param windowManager {qx.ui.window.IWindowManager} The window manager to use for the desktop.
     *    If not provided, an instance of {@link qx.ui.window.Window#DEFAULT_MANAGER_CLASS} is used.
     */
    construct: function construct(windowManager) {
      qx.ui.core.Widget.constructor.call(this);
      windowManager = windowManager || new qx.ui.window.Window.DEFAULT_MANAGER_CLASS();
      this.getContentElement().disableScrolling();

      this._setLayout(new qx.ui.layout.Canvas().set({
        desktop: true
      }));

      this.setWindowManager(windowManager);
    }
  });
  qx.ui.window.Desktop.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.Base64": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.Base64", {
    extend: qx.dev.unit.TestCase,
    members: {
      testEncodeDecode: function testEncodeDecode() {
        var str = "Luke, I'm your father! Nooooooooooo!";
        var encodedStr = qx.util.Base64.encode(str);
        this.assertEquals(str, qx.util.Base64.decode(encodedStr));
      },
      testChineseChars: function testChineseChars() {
        var str = "Abecedariab语言工具";
        var encodedStr = qx.util.Base64.encode(str);
        this.assertEquals(str, qx.util.Base64.decode(encodedStr));
      },
      testChineseCharsExplicitNot8bit: function testChineseCharsExplicitNot8bit() {
        var str = "Abecedariab语言工具";
        var encodedStr = qx.util.Base64.encode(str, false);
        this.assertEquals(str, qx.util.Base64.decode(encodedStr, false));
      },
      testChineseCharsExplicit8bit: function testChineseCharsExplicit8bit() {
        var str = "Abecedariab语言工具";
        var encodedStr = qx.util.Base64.encode(str, false);
        this.assertNotEquals(str, qx.util.Base64.decode(encodedStr, true));
      },
      testGermanChars: function testGermanChars() {
        var str = "Am Donnerstag diskutieren die Abgeordneten dann ab 9 Uhr zweieinhalb Stunden lang in erster Lesung über drei fraktionsübergreifende Gesetzentwürfe zur Präimplantationsdiagnostik (PID). Weitere Themen sind am Donnerstag unter anderem der Schutz vor Straßen- und Schienenlärm und die Einführung eines Mindestlohns";
        var encodedStr = qx.util.Base64.encode(str);
        this.assertEquals(str, qx.util.Base64.decode(encodedStr));
      },
      testKnownEncoding: function testKnownEncoding() {
        var str = "Hello\nThis\nIs\nA\nText\nFile";
        var expected = "SGVsbG8KVGhpcwpJcwpBClRleHQKRmlsZQ==";
        var encodedStr = qx.util.Base64.encode(str);
        this.assertEquals(encodedStr, expected);
        this.assertEquals(str, qx.util.Base64.decode(encodedStr));
      }
    }
  });
  qx.test.util.Base64.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.ColorUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
       * Christian Hagendorn (cs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.ColorUtil", {
    extend: qx.dev.unit.TestCase,
    members: {
      testRgbToRgbString: function testRgbToRgbString() {
        this.assertEquals("rgba(255,0,0,1)", qx.util.ColorUtil.rgbToRgbString([255, 0, 0, 1]));
        this.assertEquals("rgba(255,0,0,0.5)", qx.util.ColorUtil.rgbToRgbString([255, 0, 0, 0.5]));
        this.assertEquals("rgba(255,0,0,0)", qx.util.ColorUtil.rgbToRgbString([255, 0, 0, 0]));
        this.assertEquals("rgb(255,0,0)", qx.util.ColorUtil.rgbToRgbString([255, 0, 0]));
      },
      testCssStringToRgb: function testCssStringToRgb() {
        this.assertEquals("255,0,0", qx.util.ColorUtil.cssStringToRgb("rgba(255,0,0,1)"));
        this.assertEquals("201,23,120", qx.util.ColorUtil.cssStringToRgb("rgba(201,23,120,0.3)"));
        this.assertEquals("255,0,0", qx.util.ColorUtil.cssStringToRgb("rgb(255,0,0)"));
        this.assertEquals("201,23,120", qx.util.ColorUtil.cssStringToRgb("rgb(201,23,120)"));
      },
      testHex3StringToHex6String: function testHex3StringToHex6String() {
        this.assertEquals("#FFFFFF", qx.util.ColorUtil.hex3StringToHex6String("#fff"));
        this.assertEquals("#ffffff", qx.util.ColorUtil.hex3StringToHex6String("#ffffff"));
      },
      testRgbToHexString: function testRgbToHexString() {
        this.assertEquals("#FFFFFF", qx.util.ColorUtil.rgbToHexString([255, 255, 255]));
        this.assertEquals("#000000", qx.util.ColorUtil.rgbToHexString([0, 0, 0]));
      },
      testStringToRgbString: function testStringToRgbString() {
        this.assertEquals("rgb(0,0,0)", qx.util.ColorUtil.stringToRgbString("rgba(0,0,0,0.5)"));
        this.assertEquals("rgb(-1,-1,-1)", qx.util.ColorUtil.stringToRgbString("rgba(0,0,0,0)"));
      }
    }
  });
  qx.test.util.ColorUtil.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.locale.Manager": {},
      "qx.util.format.DateFormat": {},
      "qx.test.util.DateMock": {},
      "qx.locale.Date": {},
      "qx.bom.client.Browser": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "browser.name": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.DateFormat", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MRequirements,
    members: {
      // result contain an object with what should be expected, the result to test the date against
      __dates: [{
        'date': new Date(2000, 2, 14),
        'result': {}
      }, {
        'date': new Date(2006, 2, 14),
        'result': {}
      }, {
        'date': new Date(2007, 3, 14),
        'result': {}
      }, {
        'date': new Date(2009, 10, 30),
        'result': {}
      }, {
        'date': new Date(2009, 8, 30),
        'result': {}
      }, {
        'date': new Date(2011, 3, 15),
        'result': {}
      }, {
        'date': new Date(2011, 3, 16),
        'result': {}
      }, {
        'date': new Date(2011, 3, 17),
        'result': {}
      }, {
        'date': new Date(2011, 0, 26),
        'result': {
          'weekOfYear': 4
        }
      }, {
        'date': new Date(2011, 0, 1),
        'result': {
          'weekOfYear': 52
        }
      }, {
        'date': new Date(2011, 0, 3),
        'result': {
          'weekOfYear': 1
        }
      }, {
        'date': new Date(2011, 0, 10),
        'result': {
          'weekOfYear': 2
        }
      }, {
        'date': new Date(2011, 9, 3),
        'result': {
          'dayOfYear': 276,
          'era': {
            'abbrev': 'AD',
            'fullName': 'Anno Domini',
            'narrow': 'A'
          }
        }
      }, {
        'date': new Date(2011, 0, 4),
        'result': {
          'dayOfYear': 4,
          'dayOfWeek': 2
        }
      }, {
        'date': new Date(2011, 0, 4),
        'result': {
          'dayOfYear': 4,
          'dayOfWeek': 2
        }
      }, {
        'date': new Date(2011, 0, 4, 9, 9, 9),
        'result': {
          'h_hour': 9,
          'K_hour': 9,
          'H_hour': 9,
          'k_hour': 9
        }
      }, {
        'date': new Date(2011, 0, 4, 14, 9, 9),
        'result': {
          'h_hour': 2,
          'K_hour': 2,
          'H_hour': 14,
          'k_hour': 14
        }
      }, {
        'date': new Date(2011, 0, 4, 0, 9, 9),
        'result': {
          'h_hour': 12,
          'K_hour': 0,
          'H_hour': 0,
          'k_hour': 24
        }
      }, {
        'date': new Date(2011, 0, 4, 12, 9, 9),
        'result': {
          'h_hour': 12,
          'K_hour': 0,
          'H_hour': 12,
          'k_hour': 12
        }
      }, {
        'date': new Date(2010, 12, 4, 0, 0, 0),
        'result': {
          'h_hour': 12,
          'K_hour': 0,
          'H_hour': 0,
          'k_hour': 24
        }
      }, {
        'date': new Date(-20, 10, 14),
        'result': {
          'era': {
            'abbrev': 'BC',
            'fullName': 'Before Christ',
            'narrow': 'B'
          }
        }
      }, {
        'date': new Date(2012, 4, 24, 11, 49, 57, 1),
        'result': {}
      }, {
        'date': new Date(2012, 4, 24, 11, 49, 57, 12),
        'result': {}
      }, {
        'date': new Date(2012, 4, 24, 11, 49, 57, 123),
        'result': {}
      }],
      tearDown: function tearDown() {
        qx.locale.Manager.getInstance().resetLocale();
      },
      __fillNumber: function __fillNumber(number, minSize) {
        var str = "" + number;

        while (str.length < minSize) {
          str = "0" + str;
        }

        return str;
      },
      __getExpectedYear: function __getExpectedYear(absYear, formattedSize, yearsign) {
        var expectedYear = absYear + "";

        if (expectedYear.length < formattedSize) {
          for (var j = expectedYear.length; j < formattedSize; j++) {
            expectedYear = "0" + expectedYear;
          }
        }

        return yearsign === "-" ? yearsign + expectedYear : expectedYear;
      },
      _testDateParse: function _testDateParse(date, formatString, locale) {
        var dateFmt = new qx.util.format.DateFormat(formatString, locale);
        var dateStr = dateFmt.format(date);
        var parsedDate = dateFmt.parse(dateStr);
        this.assertEquals(date.getFullYear(), parsedDate.getFullYear());
        this.assertEquals(date.getMonth(), parsedDate.getMonth());
        this.assertEquals(date.getDate(), parsedDate.getDate());
        this.assertEquals(date.getDay(), parsedDate.getDay());

        if (formatString.indexOf(":") > 0) {
          this.assertEquals(date.getHours(), parsedDate.getHours());
          this.assertEquals(date.getMinutes(), parsedDate.getMinutes());
        }

        dateFmt.dispose();
      },
      testDateParse: function testDateParse() {
        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;

          this._testDateParse(date, "EEEE dd. MMM yyyy", "de_DE");

          this._testDateParse(date, "yyyyMMdd", "en_US");

          this._testDateParse(date, "ddMMyyyyy", "en_US");

          this._testDateParse(date, "yyyyyyyyyddMM", "de_DE");

          this._testDateParse(date, "yyMMdd", "en_US");

          this._testDateParse(date, "yMMdd", "de_DE");

          this._testDateParse(date, "yyyMMdd", "en_US");

          this._testDateParse(date, "EEE dd. MM yyyy", "de_DE");

          this._testDateParse(date, "EE dd. M yyyy", "de_DE");

          this._testDateParse(date, "EEEE dd. MMM yyyy", "fr_FR");

          this._testDateParse(date, "MMM d, y h:mm a", "en_US");

          this._testDateParse(date, "MMM d, y KK:mm a", "en_US");

          this._testDateParse(date, "YYYY/MM/dd", "en_US");
        }
      },
      testInvalidDate: function testInvalidDate() {
        // Note:
        //   * Edge parses even invalid dates and calculates
        //     from the "overflowing" days and months the
        //     next "logical" date. In the example below
        //     the date parsed is "2011-12-02".
        this.require(["noEdge"]);

        var invalidDate = new Date("2011-11-32");
        var dateFmt = new qx.util.format.DateFormat();
        this.assertNull(dateFmt.format(invalidDate));
        dateFmt.dispose();
      },
      testWeeksInDateParsing: function testWeeksInDateParsing() {
        var dateFormat, testDate, parsedDate;
        dateFormat = new qx.util.format.DateFormat("EEEE d MMMM yyyy ww");
        qx.locale.Manager.getInstance().setLocale("en_US");
        testDate = new Date(2014, 0, 1).getTime();
        parsedDate = dateFormat.parse("Wednesday 1 January 2014 01");
        this.assertIdentical(testDate, parsedDate.getTime(), "ww - 01, should have been parsed");

        try {
          parsedDate = dateFormat.parse("Wednesday 1 January 2014 1");
        } catch (e) {
          parsedDate = new Date();
        }

        this.assertNotIdentical(testDate, parsedDate.getTime(), "ww - 1, should not have been parsed");

        try {
          parsedDate = dateFormat.parse("Wednesday 1 January 2014 ");
        } catch (e) {
          parsedDate = new Date();
        }

        this.assertNotIdentical(testDate, parsedDate.getTime(), "ww - '', should not have been parsed");
        testDate = new Date(2014, 4, 6).getTime();
        parsedDate = dateFormat.parse("Tuesday 6 May 2014 19");
        this.assertIdentical(testDate, parsedDate.getTime(), "ww - 19, should have been parsed");
        dateFormat = new qx.util.format.DateFormat("EEEE d MMMM yyyy w");
        parsedDate = dateFormat.parse("Tuesday 6 May 2014 19");
        this.assertIdentical(testDate, parsedDate.getTime(), "w - 19, should have been parsed");
        testDate = new Date(2014, 0, 1).getTime();
        parsedDate = dateFormat.parse("Wednesday 1 January 2014 01");
        this.assertIdentical(testDate, parsedDate.getTime(), "w - 01, should have been parsed");
        parsedDate = dateFormat.parse("Wednesday 1 January 2014 1");
        this.assertIdentical(testDate, parsedDate.getTime(), "w - 1, should have been parsed");

        try {
          parsedDate = dateFormat.parse("Wednesday 1 January 2014 ");
        } catch (e) {
          parsedDate = new Date();
        }

        this.assertNotIdentical(testDate, parsedDate.getTime(), "w - '', should not have been parsed");
      },
      testTimeZone: function testTimeZone() {
        var date = new qx.test.util.DateMock({
          timezoneOffset: -60,
          time: 1316000836451
        });
        var formatStr = "z";
        var dateFmt = new qx.util.format.DateFormat(formatStr, "de_DE");
        this.assertEquals("GMT+01:00", dateFmt.format(date));
        date.dispose();
        date = new qx.test.util.DateMock({
          timezoneOffset: 60,
          time: 1316000836451
        });
        this.assertEquals("GMT-01:00", dateFmt.format(date));
        date.dispose();
        date = new qx.test.util.DateMock({
          timezoneOffset: -90,
          time: 1316000836451
        });
        this.assertEquals("GMT+01:30", dateFmt.format(date));
        date.dispose();
        date = new qx.test.util.DateMock({
          timezoneOffset: 90,
          time: 1316000836451
        });
        this.assertEquals("GMT-01:30", dateFmt.format(date));
        date.dispose();
        dateFmt.dispose();
      },
      testLocalizedDates: function testLocalizedDates() {
        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;
          var formatStr = qx.locale.Date.getDateFormat("short", "fr_FR");

          this._testDateParse(date, formatStr, "fr_FR");

          formatStr = qx.locale.Date.getDateFormat("medium", "fr_FR");

          this._testDateParse(date, formatStr, "fr_FR");

          formatStr = qx.locale.Date.getDateFormat("long", "fr_FR");

          this._testDateParse(date, formatStr, "fr_FR");

          formatStr = qx.locale.Date.getDateFormat("full", "fr_FR");

          this._testDateParse(date, formatStr, "fr_FR");

          formatStr = qx.locale.Date.getDateFormat("short", "de_DE");

          this._testDateParse(date, formatStr, "de_DE");

          var formatStr = qx.locale.Date.getDateFormat("medium", "de_DE");

          this._testDateParse(date, formatStr, "de_DE");

          var formatStr = qx.locale.Date.getDateFormat("long", "de_DE");

          this._testDateParse(date, formatStr, "de_DE");

          var formatStr = qx.locale.Date.getDateFormat("full", "de_DE");

          this._testDateParse(date, formatStr, "de_DE");
        }
      },
      testPattern_y_: function testPattern_y_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;
          var yearsign = date.getFullYear() > 0 ? '+' : '-';
          var absYear = "" + Math.abs(date.getFullYear());
          var fullYear = date.getFullYear() + '';
          var lastTwoDigitsYear = fullYear.substring(absYear.length - 2);
          df = new qx.util.format.DateFormat("yyyy");

          var expectedYear = this.__getExpectedYear(absYear, 4, yearsign);

          this.assertEquals(expectedYear, df.format(date));
          var parsedDate = df.parse(df.format(date));
          this.assertEquals(date.getFullYear(), parsedDate.getFullYear());
          df.dispose(); // case y

          df = new qx.util.format.DateFormat("y");
          this.assertEquals(fullYear, df.format(date));
          df.dispose(); // case yy

          df = new qx.util.format.DateFormat("yy");
          this.assertEquals(lastTwoDigitsYear, df.format(date));
          df.dispose(); // case yyy

          df = new qx.util.format.DateFormat("yyy");

          var expectedYear = this.__getExpectedYear(absYear, 3, yearsign);

          this.assertEquals(expectedYear, df.format(date));
          df.dispose(); // case yyyy

          df = new qx.util.format.DateFormat("yyyy");

          var expectedYear = this.__getExpectedYear(absYear, 4, yearsign);

          this.assertEquals(expectedYear, df.format(date));
          df.dispose(); // case yyyyy

          df = new qx.util.format.DateFormat("yyyyy");

          var expectedYear = this.__getExpectedYear(absYear, 5, yearsign);

          this.assertEquals(expectedYear, df.format(date));
          df.dispose(); // case yyyyy

          df = new qx.util.format.DateFormat("yyyyyyyyyyy");

          var expectedYear = this.__getExpectedYear(absYear, 11, yearsign);

          this.assertEquals(expectedYear, df.format(date));
          df.dispose();
        }
      },
      testPattern_M_: function testPattern_M_() {
        var df;
        var locale = qx.locale.Manager.getInstance().getLocale();

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;
          var absYear = "" + Math.abs(date.getFullYear());
          var yearsign = date.getFullYear() > 0 ? '+' : '-';

          var expectedYear = this.__getExpectedYear(absYear, 4, yearsign);

          var month = date.getMonth();
          var realMonth = month + 1 + "";
          df = new qx.util.format.DateFormat("yyyy/MM");
          this.assertEquals(expectedYear + "/" + this.__fillNumber(realMonth, 2), df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("yyyy/M");
          this.assertEquals(expectedYear + "/" + realMonth, df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("yyyy/MMM");
          this.assertEquals(expectedYear + "/" + qx.locale.Date.getMonthName("abbreviated", month, locale, "format", true), df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("yyyy/MMMM");
          this.assertEquals(expectedYear + "/" + qx.locale.Date.getMonthName("wide", month, locale, "format", true), df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("yyyy/MMMMM");
          this.assertEquals(expectedYear + "/" + qx.locale.Date.getMonthName("narrow", month, locale, "format", true), df.format(date));
          df.dispose();
        }
      },
      testPattern_L_: function testPattern_L_() {
        var df;
        var locale = qx.locale.Manager.getInstance().getLocale();

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;
          var month = date.getMonth();
          var realMonth = month + 1 + "";
          df = new qx.util.format.DateFormat("LL");
          this.assertEquals(this.__fillNumber(realMonth, 2), df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("L");
          this.assertEquals(realMonth, df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("LLL");
          this.assertEquals(qx.locale.Date.getMonthName("abbreviated", month, locale, "stand-alone", true), df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("LLLL");
          this.assertEquals(qx.locale.Date.getMonthName("wide", month, locale, "stand-alone", true), df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("LLLLL");
          this.assertEquals(qx.locale.Date.getMonthName("narrow", month, locale, "stand-alone", true), df.format(date));
          df.dispose();
        }
      },
      testPattern_w_: function testPattern_w_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          if (this.__dates[i].result.weekOfYear) {
            var date = this.__dates[i].date;
            var weekOfYear = this.__dates[i].result.weekOfYear + "";
            df = new qx.util.format.DateFormat("w");
            this.assertEquals(weekOfYear, df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("ww");
            this.assertEquals(this.__fillNumber(weekOfYear, 2), df.format(date));
            df.dispose();
          }
        }
      },
      testPattern_d_: function testPattern_d_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;
          var dayOfMonth = date.getDate();
          df = new qx.util.format.DateFormat("d");
          this.assertEquals(dayOfMonth + "", df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("dd");
          this.assertEquals(this.__fillNumber(dayOfMonth, 2), df.format(date));
          df.dispose();
        }
      },
      testPattern_D_: function testPattern_D_() {
        var df, dateStr;

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;

          if (this.__dates[i].result.dayOfYear) {
            var dayOfYear = this.__dates[i].result.dayOfYear + "";
            df = new qx.util.format.DateFormat("D");
            this.assertEquals(dayOfYear, df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("DD");
            this.assertEquals(this.__fillNumber(dayOfYear, 2), df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("DDD");
            this.assertEquals(this.__fillNumber(dayOfYear, 3), df.format(date));
            df.dispose();
          }

          var dateFmt = new qx.util.format.DateFormat("MM / yyy / DDD");
          dateStr = dateFmt.format(date);
          var parsedDate = dateFmt.parse(dateStr);
          this.assertEquals(date.getFullYear(), parsedDate.getFullYear());
          this.assertEquals(date.getMonth(), parsedDate.getMonth());
          this.assertEquals(date.getDate(), parsedDate.getDate());
          this.assertEquals(date.getDay(), parsedDate.getDay());
          dateFmt.dispose();
        }
      },
      testPattern_E_: function testPattern_E_() {
        var df;
        var locale = qx.locale.Manager.getInstance().getLocale();

        for (var i = 0; i < this.__dates.length; i++) {
          if (this.__dates[i].result.dayOfWeek) {
            var date = this.__dates[i].date;
            var fullYear = "" + date.getFullYear();
            var dayOfWeek = this.__dates[i].result.dayOfWeek;
            df = new qx.util.format.DateFormat("yyyy/E");
            this.assertEquals(fullYear + "/" + qx.locale.Date.getDayName("abbreviated", dayOfWeek, locale, "format", true), df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("yyyy/EE");
            this.assertEquals(fullYear + "/" + qx.locale.Date.getDayName("abbreviated", dayOfWeek, locale, "format", true), df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("yyyy/EEE");
            this.assertEquals(fullYear + "/" + qx.locale.Date.getDayName("abbreviated", dayOfWeek, locale, "format", true), df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("yyyy/EEEE");
            this.assertEquals(fullYear + "/" + qx.locale.Date.getDayName("wide", dayOfWeek, locale, "format", true), df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("yyyy/EEEEE");
            this.assertEquals(fullYear + "/" + qx.locale.Date.getDayName("narrow", dayOfWeek, locale, "format", true), df.format(date));
            df.dispose();
          }
        }
      },
      testPattern_c_: function testPattern_c_() {
        var df;
        var locale = qx.locale.Manager.getInstance().getLocale();
        var locales = [locale, "en_US", "ro_RO", "de_DE", "fr_FR"];

        for (var k = 0; k < locales.length; k++) {
          qx.locale.Manager.getInstance().setLocale(locales[k]);

          for (var i = 0; i < this.__dates.length; i++) {
            var date = this.__dates[i].date;
            var dayOfWeek = date.getDay();
            var startOfWeek = qx.locale.Date.getWeekStart(locales[k]);
            var expectedDayOfWeek = 1 + (dayOfWeek - startOfWeek >= 0 ? dayOfWeek - startOfWeek : 7 + (dayOfWeek - startOfWeek));
            df = new qx.util.format.DateFormat("c", locales[k]);
            this.assertEquals(expectedDayOfWeek + "", df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("ccc", locales[k]);
            this.assertEquals(qx.locale.Date.getDayName("abbreviated", dayOfWeek, locales[k], "stand-alone", true), df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("cccc", locales[k]);
            this.assertEquals(qx.locale.Date.getDayName("wide", dayOfWeek, locales[k], "stand-alone", true), df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("ccccc", locales[k]);
            this.assertEquals(qx.locale.Date.getDayName("narrow", dayOfWeek, locales[k], "stand-alone", true), df.format(date));
            df.dispose();
          }
        }

        qx.locale.Manager.getInstance().setLocale(locale);
      },
      testPattern_e_: function testPattern_e_() {
        var df;
        var locale = qx.locale.Manager.getInstance().getLocale();

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;
          var dayOfWeek = date.getDay();
          var startOfWeek = qx.locale.Date.getWeekStart(locale);
          var expectedDayOfWeek = 1 + (dayOfWeek - startOfWeek >= 0 ? dayOfWeek - startOfWeek : 7 + (dayOfWeek - startOfWeek));
          df = new qx.util.format.DateFormat("e");
          this.assertEquals(expectedDayOfWeek + "", df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("ee");
          this.assertEquals("0" + expectedDayOfWeek, df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("eee");
          this.assertEquals(qx.locale.Date.getDayName("abbreviated", dayOfWeek, locale, "format", true), df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("eeee");
          this.assertEquals(qx.locale.Date.getDayName("wide", dayOfWeek, locale, "format", true), df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("eeeee");
          this.assertEquals(qx.locale.Date.getDayName("narrow", dayOfWeek, locale, "format", true), df.format(date));
          df.dispose();
        }
      },
      testPattern_e_parse: function testPattern_e_parse() {
        var df, parsedDate;
        var locale = qx.locale.Manager.getInstance().getLocale();

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;
          var dayOfWeek = date.getDay();
          df = new qx.util.format.DateFormat("e-yyyy-MM-dd");
          parsedDate = df.parse(df.format(date));
          this.assertEquals(dayOfWeek, parsedDate.getDay());
          df.dispose();
          df = new qx.util.format.DateFormat("ee-yyyy-MM-dd");
          parsedDate = df.parse(df.format(date));
          this.assertEquals(dayOfWeek, parsedDate.getDay());
          df.dispose();
          df = new qx.util.format.DateFormat("eee-yyyy-MM-dd");
          parsedDate = df.parse(df.format(date));
          this.assertEquals(dayOfWeek, parsedDate.getDay());
          df.dispose();
          df = new qx.util.format.DateFormat("eeee-yyyy-MM-dd");
          parsedDate = df.parse(df.format(date));
          this.assertEquals(dayOfWeek, parsedDate.getDay());
          df.dispose();
          df = new qx.util.format.DateFormat("eeeee-yyyy-MM-dd");
          parsedDate = df.parse(df.format(date));
          this.assertEquals(dayOfWeek, parsedDate.getDay());
          df.dispose();
        }
      },
      testPattern_a_: function testPattern_a_() {
        var df;
        var locale = qx.locale.Manager.getInstance().getLocale();

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;
          var hour = date.getHours();
          df = new qx.util.format.DateFormat("a", locale);
          this.assertEquals(hour < 12 ? qx.locale.Date.getAmMarker(locale).toString() : qx.locale.Date.getPmMarker(locale).toString(), df.format(date));
          df.dispose();
        }
      },
      testPattern_h_: function testPattern_h_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          if (this.__dates[i].result.h_hour) {
            var date = this.__dates[i].date;
            var hour = this.__dates[i].result.h_hour;
            df = new qx.util.format.DateFormat("h");
            this.assertEquals(hour + "", df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("hh");
            this.assertEquals(this.__fillNumber(hour, 2), df.format(date));
            df.dispose();
          }
        }
      },
      testPattern_H_: function testPattern_H_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          if (this.__dates[i].result.H_hour) {
            var date = this.__dates[i].date;
            var hour = this.__dates[i].result.H_hour;
            df = new qx.util.format.DateFormat("H");
            this.assertEquals(hour + "", df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("HH");
            this.assertEquals(this.__fillNumber(hour, 2), df.format(date));
            df.dispose();
          }
        }
      },
      testPattern_k_: function testPattern_k_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          if (this.__dates[i].result.k_hour) {
            var date = this.__dates[i].date;
            var hour = this.__dates[i].result.k_hour;
            df = new qx.util.format.DateFormat("k");
            this.assertEquals(hour + "", df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("kk");
            this.assertEquals(this.__fillNumber(hour, 2), df.format(date));
            df.dispose();
          }
        }
      },
      testPattern_K_: function testPattern_K_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          if (this.__dates[i].result.K_hour) {
            var date = this.__dates[i].date;
            var hour = this.__dates[i].result.K_hour;
            df = new qx.util.format.DateFormat("K");
            this.assertEquals(hour + "", df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("KK");
            this.assertEquals(this.__fillNumber(hour, 2), df.format(date));
            df.dispose();
          }
        }
      },
      testPattern_m_: function testPattern_m_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;
          var min = date.getMinutes();
          df = new qx.util.format.DateFormat("m");
          this.assertEquals(min + "", df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("mm");
          this.assertEquals(this.__fillNumber(min, 2), df.format(date));
          df.dispose();
        }
      },
      testPattern_s_: function testPattern_s_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;
          var sec = date.getSeconds();
          df = new qx.util.format.DateFormat("s");
          this.assertEquals(sec + "", df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("ss");
          this.assertEquals(this.__fillNumber(sec, 2), df.format(date));
          df.dispose();
        }
      },
      testPattern_S_: function testPattern_S_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date; // pad milliseconds to become a fraction of second

          var msec = this.__fillNumber(date.getMilliseconds(), 3);

          df = new qx.util.format.DateFormat("S");
          this.assertEquals(msec.substring(0, 1), df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("SS");
          this.assertEquals(msec.substring(0, 2), df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("SSS");
          this.assertEquals(msec.substring(0, 3), df.format(date));
          df.dispose(); // check that remaining format specification is padded with zeros

          df = new qx.util.format.DateFormat("SSSS");
          this.assertEquals(msec.substring(0, 3) + "0", df.format(date));
          df.dispose();
        }
      },
      // z and Z can be tested when knowing the timezoneoffset of the machines the test will run on
      // here it is EET
      testPattern_z_: function testPattern_z_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;
          var timezoneOffset = date.getTimezoneOffset();
          var timezoneSign = timezoneOffset > 0 ? 1 : -1;
          var timezoneHours = Math.floor(Math.abs(timezoneOffset) / 60);
          var timezoneMinutes = Math.abs(timezoneOffset) % 60;

          var localTimeZone = "GMT" + (timezoneSign > 0 ? "-" : "+") + this.__fillNumber(Math.abs(timezoneHours), 2) + ":" + this.__fillNumber(timezoneMinutes, 2);

          df = new qx.util.format.DateFormat("z");
          this.assertEquals(localTimeZone, df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("zz");
          this.assertEquals(localTimeZone, df.format(date));
          df.dispose();
          df = new qx.util.format.DateFormat("zzz");
          this.assertEquals(localTimeZone, df.format(date));
          df.dispose();
        }
      },
      testPattern_G_: function testPattern_G_() {
        var df;

        for (var i = 0; i < this.__dates.length; i++) {
          if (this.__dates[i].result.era) {
            var date = this.__dates[i].date;
            var era = this.__dates[i].result.era;
            df = new qx.util.format.DateFormat("G");
            this.assertEquals(era.abbrev, df.format(date));
            df.dispose();
            df = new qx.util.format.DateFormat("yyyy MM dd G");
            var dateFormatted = df.format(date);
            var parsedDate = df.parse(dateFormatted);
            this.assertEquals(date.getFullYear(), parsedDate.getFullYear());
            this.assertEquals(date.getMonth(), parsedDate.getMonth());
            this.assertEquals(date.getDate(), parsedDate.getDate());
            this.assertEquals(date.getDay(), parsedDate.getDay());
            df.dispose();
          }
        }
      },
      _testIsoMasks: function _testIsoMasks(date, isoFormat, dateFormat) {
        var isodf = new qx.util.format.DateFormat(isoFormat);
        var df = new qx.util.format.DateFormat(dateFormat);
        var isoDateFormatted = isodf.format(date);
        var dateFormatted = df.format(date);
        this.assertEquals(isoDateFormatted, dateFormatted);
        this.assertEquals(isodf.parse(isoDateFormatted).getTime(), df.parse(dateFormatted).getTime());
        isodf.dispose();
        df.dispose();
      },
      testIsoMasks: function testIsoMasks() {
        for (var i = 0; i < this.__dates.length; i++) {
          var date = this.__dates[i].date;

          this._testIsoMasks(date, 'isoDate', 'yyyy-MM-dd');

          this._testIsoMasks(date, 'isoTime', 'HH:mm:ss');

          this._testIsoMasks(date, 'isoDateTime', "yyyy-MM-dd'T'HH:mm:ss"); //        var isodf = new qx.util.format.DateFormat('isoUtcDateTime');
          //        var df = new qx.util.format.DateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
          //        var isoDateFormatted = isodf.format(date);
          //        var dateFormatted = df.format(date);
          //        this.assertEquals(isodf.parse(isoDateFormatted).getTime(),df.parse(dateFormatted).getTime());

        }
      },
      testChangingLocales: function testChangingLocales() {
        var manager = qx.locale.Manager.getInstance();
        manager.resetLocale();
        var initialLocale = manager.getLocale();
        manager.setLocale('en_US');
        var df = new qx.util.format.DateFormat("EEEE yyyy-mm-dd");
        var dfinitial = new qx.util.format.DateFormat("EEEE yyyy-mm-dd", initialLocale);
        var dfFR = new qx.util.format.DateFormat("EEEE yyyy-mm-dd", "fr_FR");
        var dfDE = new qx.util.format.DateFormat("EEEE yyyy-mm-dd", "de_DE");
        var dfUS = new qx.util.format.DateFormat("EEEE yyyy-mm-dd", "en_US");
        var d = new Date();
        var frenchFormatteddateString = dfFR.format(d);
        this.assertEquals(df.format(d), dfUS.format(d));
        manager.setLocale('fr_FR');
        this.assertEquals(df.format(d), dfFR.format(d));
        manager.setLocale('de_DE');
        this.assertEquals(df.format(d), dfDE.format(d));
        manager.resetLocale();
        this.assertEquals(df.format(d), dfinitial.format(d));
        manager.setLocale('fr_FR');
        this.assertEquals(df.format(d), dfFR.format(d));
        df.resetLocale();
        this.assertEquals(df.format(d), dfUS.format(d));
        dfFR.setLocale('de_DE');
        this.assertEquals(dfFR.format(d), dfDE.format(d));
        dfFR.resetLocale();
        df.dispose();
        dfinitial.dispose();
        dfFR.dispose();
        dfDE.dispose();
        dfUS.dispose();
      },
      hasNoEdge: function hasNoEdge() {
        return !(qx.core.Environment.get("browser.name") == "edge");
      }
    }
  });
  qx.test.util.DateFormat.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.DateMock", {
    extend: qx.core.Object,
    construct: function construct(dateMap) {
      qx.core.Object.constructor.call(this);
      this.__date = dateMap;
    },
    members: {
      getFullYear: function getFullYear() {
        return this.__date.fullYear;
      },
      getMonth: function getMonth() {
        return this.__date.month;
      },
      getDate: function getDate() {
        return this.__date.date;
      },
      getDay: function getDay() {
        return this.__date.day;
      },
      getHours: function getHours() {
        return this.__date.hours;
      },
      getSeconds: function getSeconds() {
        return this.__date.seconds;
      },
      getMinutes: function getMinutes() {
        return this.__date.minutes;
      },
      getMilliseconds: function getMilliseconds() {
        return this.__date.milliseconds;
      },
      getTimezoneOffset: function getTimezoneOffset() {
        return this.__date.timezoneOffset;
      },
      getTime: function getTime() {
        return this.__date.time;
      }
    }
  });
  qx.test.util.DateMock.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.event.GlobalError": {},
      "qx.util.DeferredCall": {},
      "qx.core.AssertionError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.DeferredCall", {
    extend: qx.dev.unit.TestCase,
    members: {
      testGlobalErrorHandling: function testGlobalErrorHandling() {
        var fail = function fail() {
          throw new Error("fail");
        };

        var onError = function onError() {
          this.resume(function () {
            qx.event.GlobalError.setErrorHandler(null, null);
          });
        };

        var deferredCall = new qx.util.DeferredCall(fail, this);
        qx.event.GlobalError.setErrorHandler(onError, this);
        deferredCall.schedule();
        this.wait(1000, function () {
          qx.event.GlobalError.setErrorHandler(null, null);
          throw new qx.core.AssertionError("Asynchronous Test Error", "Timeout reached before resume() was called.");
        });
      }
    }
  });
  qx.test.util.DeferredCall.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.util.Delegate": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.Delegate", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      __delegate: null,
      setUp: function setUp() {
        this.__delegate = {
          STATIC: true,
          myMethod: function myMethod() {}
        };
      },
      tearDown: function tearDown() {
        this.__delegate = null;
      },
      testGetMethod: function testGetMethod() {
        this.assertNotNull(qx.util.Delegate.getMethod(this.__delegate, "myMethod"));
        this.assertFunction(qx.util.Delegate.getMethod(this.__delegate, "myMethod"));
        this.assertNull(qx.util.Delegate.getMethod(this.__delegate, "STATIC"));
        this.assertNull(qx.util.Delegate.getMethod(this.__delegate, "banana"));
      },
      testContainsMethod: function testContainsMethod() {
        this.assertTrue(qx.util.Delegate.containsMethod(this.__delegate, "myMethod"));
        this.assertFalse(qx.util.Delegate.containsMethod(this.__delegate, "STATIC"));
        this.assertFalse(qx.util.Delegate.containsMethod(this.__delegate, "banana"));
      },
      testMethodCall: function testMethodCall() {
        var spy = this.spy(this.__delegate, "myMethod");
        var myMethod = qx.util.Delegate.getMethod(this.__delegate, "myMethod");
        myMethod(99, 89, 99);
        this.assertCalled(spy);
        this.assertCalledWith(spy, 99, 89, 99);
        this.assertCalledOn(spy, this.__delegate);
      }
    }
  });
  qx.test.util.Delegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.VBox": {},
      "qx.ui.layout.Canvas": {},
      "qx.ui.container.Stack": {},
      "qx.ui.basic.Atom": {},
      "qx.util.DisposeUtil": {},
      "qx.ui.core.queue.Dispose": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Mustafa Sak (msak)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.DisposeUtil", {
    extend: qx.dev.unit.TestCase,
    members: {
      testDestroyContainer: function testDestroyContainer() {
        var self = this;
        var container = new qx.ui.container.Composite(new qx.ui.layout.VBox());
        var childContainer1 = new qx.ui.container.Composite(new qx.ui.layout.Canvas());
        var childContainer2 = new qx.ui.container.Composite(new qx.ui.layout.Canvas());
        var childContainer3 = new qx.ui.container.Stack();
        var childContainer4 = new qx.ui.container.Stack();
        var child1 = new qx.ui.basic.Atom();
        var child2 = new qx.ui.basic.Atom();
        var child3 = new qx.ui.basic.Atom();
        var child4 = new qx.ui.basic.Atom();
        var child5 = new qx.ui.basic.Atom();
        childContainer1.add(child1);
        childContainer2.add(child2);
        childContainer3.add(child3);
        container.add(childContainer1);
        container.add(childContainer2);
        container.add(childContainer3);
        container.add(child4);
        container.add(child5);
        container.add(childContainer4);
        qx.util.DisposeUtil.destroyContainer(container); // flush the dispose queue

        qx.ui.core.queue.Dispose.flush();
        this.assertTrue(container.isDisposed(), "container not disposed!");
        this.assertTrue(childContainer1.isDisposed(), "childContainer1 not disposed!");
        this.assertTrue(childContainer2.isDisposed(), "childContainer2 not disposed!");
        this.assertTrue(childContainer3.isDisposed(), "childContainer3 not disposed!");
        this.assertTrue(child1.isDisposed(), "child1 not disposed!");
        this.assertTrue(child2.isDisposed(), "child2 not disposed!");
        this.assertTrue(child3.isDisposed(), "child3 not disposed!");
        this.assertTrue(child4.isDisposed(), "child4 not disposed!");
        this.assertTrue(child5.isDisposed(), "child5 not disposed!");
        this.assertTrue(childContainer4.isDisposed(), "childContainer4 not disposed!");
      }
    }
  });
  qx.test.util.DisposeUtil.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.DynamicScriptLoader": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 Visionet GmbH, http://www.visionet.de
       2016 OETIKER+PARTNER AG, https://www.oetiker.ch
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Dietrich Streifert (level420)
       * Tobias Oetiker (oetiker)
  
  ************************************************************************ */

  /* ************************************************************************
   ************************************************************************ */

  /**
   *
   * @asset(qx/test/dynamicscriptloader/*)
   *
   * @ignore(qx.test.DYNAMICSCRIPTTEST.*)
   * @ignore(qx.dynamicScriptLoadTest.*)
   */
  qx.Class.define("qx.test.util.DynamicScriptLoader", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        if (qx.test.DYNAMICSCRIPTTEST) {
          delete qx.test.DYNAMICSCRIPTTEST;
        }
      },
      tearDown: function tearDown() {
        if (qx.test.DYNAMICSCRIPTTEST) {
          delete qx.test.DYNAMICSCRIPTTEST;
        }
      },
      "test 1: dynamic parallel loading": function test1DynamicParallelLoading() {
        var l1 = new qx.util.DynamicScriptLoader(["qx/test/dynamicscriptloader/first.js", "qx/test/dynamicscriptloader/second.js", "qx/test/dynamicscriptloader/third.js"]);
        var l2 = new qx.util.DynamicScriptLoader(["qx/test/dynamicscriptloader/first.js", "qx/test/dynamicscriptloader/second.js"]);
        var l1Ready = false;
        var l2Ready = false;
        l1.addListenerOnce('ready', function () {
          l1Ready = true;
          this.resume(function () {
            this.assertTrue(l1Ready && l2Ready);
            this.assertEquals(qx.test.DYNAMICSCRIPTTEST.second.third, "dynamically loaded");
          }, this);
        }, this);
        l2.addListenerOnce('ready', function () {
          l2Ready = true;
          this.assertTrue(!l1Ready && l2Ready);
        }, this);
        l1.start();
        l2.start();
        this.wait();
      },
      "test 2: do not load again": function test2DoNotLoadAgain() {
        var loader = new qx.util.DynamicScriptLoader(["qx/test/dynamicscriptloader/first.js", "qx/test/dynamicscriptloader/second.js", "qx/test/dynamicscriptloader/third.js"]);
        var noEvent = true;
        var checkId = loader.addListener('loaded', function (e) {
          if (e.getData().status !== "preloaded") {
            noEvent = false;
          }
        });
        loader.addListenerOnce('ready', function () {
          this.assertTrue(noEvent);
        }, this);
        loader.start();
      },
      "test 3: fail to load": function test3FailToLoad() {
        var loader = new qx.util.DynamicScriptLoader(["qx/test/dynamicscriptloader/xyc.js"]);
        loader.addListenerOnce('failed', function (e) {
          var data = e.getData();
          this.resume(function () {
            this.assertEquals(data.script, "qx/test/dynamicscriptloader/xyc.js");
          }, this);
        }, this);
        loader.start();
        this.wait();
      },
      "test 4: double start": function test4DoubleStart() {
        var loader = new qx.util.DynamicScriptLoader("qx/test/dynamicscriptloader/first.js");
        loader.start();

        try {
          loader.start();
        } catch (e) {
          this.assertEquals(e.message, 'you can only call start once per instance');
        }
      }
    }
  });
  qx.test.util.DynamicScriptLoader.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.lang.Type": {
        "construct": true
      },
      "qx.lang.Array": {
        "construct": true
      },
      "qx.Promise": {},
      "qx.util.ResourceManager": {},
      "qx.bom.request.Script": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 Visionet GmbH, http://www.visionet.de
       2016 OETIKER+PARTNER AG, https://www.oetiker.ch
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Dietrich Streifert (level420)
       * Tobias Oetiker (oetiker)
  
  ************************************************************************ */

  /**
   * Dynamically load non qx scripts. This class is aware of all scripts that have
   * been loaded using its instances, so if two instances load jquery, it will only
   * be loaded once, and the second instance will wait for the jquery to be loaded
   * before continuing to load additional scripts.
   *
   * Usage example:
   *
   * <pre>
   *  ... assets ...
   * /**
   *  * @asset(myapp/jquery/*)
   *  * @asset(myapp/highcharts/*)
   *  *
   *  * @ignore(jQuery.*)
   *  * @ignore(Highcharts.*)
   *  ...
   *
   *
   *    // in debug mode load the uncompressed unobfuscated scripts
   *    var src = '';
   *    var min = '.min';
   *    if (qx.core.Environment.get("qx.debug")) {
   *      src = '.src';
   *      min = '';
   *    }
   *
   *    // initialize the script loading
   *    var dynLoader = new qx.util.DynamicScriptLoader([
   *        "myapp/jquery/jquery"+min+".js",
   *        "myapp/highcharts/highcharts"+src+".js",
   *        "myapp/highcharts/highcharts-more"+src+".js",
   *        "myapp/highcharts/highcharts-modifications.js"
   *    ]);
   *
   *
   *    dynLoader.addListenerOnce('ready',function(e){
   *      console.log("all scripts have been loaded!");
   *    });
   *
   *    dynLoader.addListener('failed',function(e){
   *      var data = e.getData();
   *      console.log("failed to load "+data.script);
   *    });
   *
   *    dynLoader.start();
   *    
   * </pre>
   */
  qx.Class.define("qx.util.DynamicScriptLoader", {
    extend: qx.core.Object,

    /**
     * Create a loader for the given scripts.
     *
     * @param scriptArr {Array|String} the uri name(s) of the script(s) to load 
     */
    construct: function construct(scriptArr) {
      qx.core.Object.constructor.call(this);
      this.__started = false;
      this.__QUEUE = qx.lang.Type.isString(scriptArr) ? [scriptArr] : qx.lang.Array.clone(scriptArr);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * fired when a script is loaded successfully. The data contains 'script' and 'status' keys.
       */
      loaded: 'qx.event.type.Data',

      /**
       * fired when a specific script fails loading.  The data contains 'script' and 'status' keys.
       */
      failed: 'qx.event.type.Data',

      /**
       * fired when all given scripts are loaded, each time loadScriptsDynamic is called.
       */
      ready: 'qx.event.type.Event'
    },
    statics: {
      /**
       * Map of scripts being added at the present time. Key is script name; value is instance of this class which
       * is loading it.
       */
      __IN_PROGRESS: {},

      /**
       * Map of scripts that have fully loaded. Key is script name; value is true
       */
      __LOADED: {}
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Array of the scripts to be loaded
       */
      __QUEUE: null,

      /**
       * True if start has been called.
       */
      __started: null,

      /**
       * Start loading scripts. This may only be called once!
       * @return {Promise?} a promise which will be resolved after load of all scripts if promise support is enabled; nothing (undefined) if promises are not enabled.
       */
      start: function start() {
        return new qx.Promise(function (resolve, reject) {
          this.addListenerOnce("ready", resolve, this);
          this.addListenerOnce("failed", function (e) {
            reject(new Error(e.getData()));
          }, this);

          if (this.isDisposed()) {
            reject(new Error('disposed'));
          }

          if (this.__started) {
            reject(new Error('you can only call start once per instance'));
          }

          this.__started = true;

          this.__loadScripts();
        }, this);
      },

      /**
       * Chain loading scripts.
       *
       * Recursively called until the array of scripts is consumed
       *
       */
      __loadScripts: function __loadScripts() {
        var DynamicScriptLoader = qx.util.DynamicScriptLoader;
        var script;
        var dynLoader;
        var id1, id2;
        var uri;
        var loader;
        script = this.__QUEUE.shift();

        if (!script) {
          this.fireEvent("ready");
          return;
        }

        if (DynamicScriptLoader.__LOADED[script]) {
          this.fireDataEvent('loaded', {
            script: script,
            status: 'preloaded'
          });

          this.__loadScripts();

          return;
        }

        dynLoader = DynamicScriptLoader.__IN_PROGRESS[script];

        if (dynLoader) {
          id1 = dynLoader.addListener('loaded', function (e) {
            if (this.isDisposed()) {
              return;
            }

            var data = e.getData();

            if (data.script === script) {
              dynLoader.removeListenerById(id2);
              dynLoader.removeListenerById(id1);
              this.fireDataEvent('loaded', data);

              this.__loadScripts();
            }
          }, this);
          id2 = dynLoader.addListener('failed', function (e) {
            if (this.isDisposed()) {
              return;
            }

            var data = e.getData();
            dynLoader.removeListenerById(id1);
            dynLoader.removeListenerById(id2);
            this.fireDataEvent('failed', {
              script: script,
              status: 'loading of ' + data.script + ' failed while waiting for ' + script
            });
          }, this);
          return;
        }

        uri = qx.util.ResourceManager.getInstance().toUri(script);
        loader = new qx.bom.request.Script();
        loader.on("load", function (request) {
          if (this.isDisposed()) {
            return;
          }

          DynamicScriptLoader.__LOADED[script] = true;
          delete DynamicScriptLoader.__IN_PROGRESS[script];
          this.fireDataEvent('loaded', {
            script: script,
            status: request.status
          });

          this.__loadScripts();
        }, this);

        var onError = function onError(request) {
          if (this.isDisposed()) {
            return;
          }

          delete DynamicScriptLoader.__IN_PROGRESS[script];
          this.fireDataEvent('failed', {
            script: script,
            status: request.status
          });
        };

        loader.on("error", onError, this);
        loader.on("timeout", onError, this); // this.debug("Loading " + script + " started");

        loader.open("GET", uri);
        DynamicScriptLoader.__IN_PROGRESS[script] = this;
        loader.send();
      }
    },
    destruct: function destruct() {
      var DynamicScriptLoader = qx.util.DynamicScriptLoader;

      for (var key in DynamicScriptLoader.__IN_PROGRESS) {
        if (DynamicScriptLoader.__IN_PROGRESS[key] === this) {
          delete DynamicScriptLoader.__IN_PROGRESS[key];
        }
      }

      this.__QUEUE = undefined;
    }
  });
  qx.util.DynamicScriptLoader.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.fsm.FiniteStateMachine": {},
      "qx.core.Object": {},
      "qx.lang.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.Fsm", {
    extend: qx.dev.unit.TestCase,
    members: {
      /**
       * Ensure that objects added with fsm.addObject() get cleaned up properly
       * by fsm.removeObject()
       */
      testAddRemoveObject: function testAddRemoveObject() {
        var before;
        var intermediate;
        var after;
        var fsm;
        var obj;
        var obj2; //
        // Simple test: object with no groups
        //
        // Instantiate a new machine and an object

        fsm = new qx.util.fsm.FiniteStateMachine("testMachine");
        obj = new qx.core.Object(); // Retrieve the internal data of the finite state machine.
        // Convert it to JSON for easy comparison later.

        before = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Add an object

        fsm.addObject("obj", obj); // Retrieve the internal data of the finite state machine.
        // Convert it to JSON for display later, in case of error

        intermediate = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Remove the object

        fsm.removeObject("obj"); // Retrieve the internal data of the finite state machine
        // Convert it to JSON for easy comparison with the before state

        after = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Ensure that there are no differences in internal state

        this.assertEquals(before, after, "simple add/remove (" + intermediate + ")"); //
        // Single group
        //
        // Instantiate a new machine and an object

        fsm = new qx.util.fsm.FiniteStateMachine("testMachine");
        obj = new qx.core.Object(); // Retrieve the internal data of the finite state machine.
        // Convert it to JSON for easy comparison later.

        before = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Add an object

        fsm.addObject("obj", obj, "group1"); // Retrieve the internal data of the finite state machine.
        // Convert it to JSON for display later, in case of error

        intermediate = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Remove the object

        fsm.removeObject("obj"); // Retrieve the internal data of the finite state machine
        // Convert it to JSON for easy comparison with the before state

        after = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Ensure that there are no differences in internal state

        this.assertEquals(before, after, "single group (" + intermediate + ")"); //
        // Multiple groups
        //
        // Instantiate a new machine and an object

        fsm = new qx.util.fsm.FiniteStateMachine("testMachine");
        obj = new qx.core.Object(); // Retrieve the internal data of the finite state machine.
        // Convert it to JSON for easy comparison later.

        before = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Add an object

        fsm.addObject("obj", obj, ["group1", "group2"]); // Retrieve the internal data of the finite state machine.
        // Convert it to JSON for display later, in case of error

        intermediate = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Remove the object

        fsm.removeObject("obj"); // Retrieve the internal data of the finite state machine
        // Convert it to JSON for easy comparison with the before state

        after = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Ensure that there are no differences in internal state

        this.assertEquals(before, after, "single group (" + intermediate + ")"); //
        // Multiple objects in a single group
        //
        // Instantiate a new machine and an object

        fsm = new qx.util.fsm.FiniteStateMachine("testMachine");
        obj = new qx.core.Object();
        obj2 = new qx.core.Object(); // Retrieve the internal data of the finite state machine.
        // Convert it to JSON for easy comparison later.

        before = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Add an object

        fsm.addObject("obj", obj, "group1"); // Add another object

        fsm.addObject("obj2", obj2, "group1"); // Retrieve the internal data of the finite state machine.
        // Convert it to JSON for display later, in case of error

        intermediate = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Remove the second object

        fsm.removeObject("obj2"); // Remove the object

        fsm.removeObject("obj"); // Retrieve the internal data of the finite state machine
        // Convert it to JSON for easy comparison with the before state

        after = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Ensure that there are no differences in internal state

        this.assertEquals(before, after, "single group (" + intermediate + ")"); //
        // Multiple objects in a single group, ensuring that state is correct
        // after only one object is removed
        //
        // Instantiate a new machine and an object

        fsm = new qx.util.fsm.FiniteStateMachine("testMachine");
        obj = new qx.core.Object();
        obj2 = new qx.core.Object(); // Add an object

        fsm.addObject("obj", obj, "group1"); // Retrieve the internal data of the finite state machine.
        // Convert it to JSON for easy comparison later.

        before = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Add another object

        fsm.addObject("obj2", obj2, "group1"); // Retrieve the internal data of the finite state machine.
        // Convert it to JSON for display later, in case of error

        intermediate = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Remove the second object

        fsm.removeObject("obj2"); // Retrieve the internal data of the finite state machine
        // Convert it to JSON for easy comparison with the before state

        after = qx.lang.Json.stringify(fsm._getInternalData(), null, 2); // Remove the object

        fsm.removeObject("obj"); // Ensure that there are no differences in internal state

        this.assertEquals(before, after, "single group (" + intermediate + ")");
      }
    }
  });
  qx.test.util.Fsm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.util.fsm.State": {},
      "qx.core.ObjectRegistry": {},
      "qx.event.Registration": {},
      "qx.event.type.Data": {},
      "qx.event.type.Event": {},
      "qx.event.Timer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006, 2007, 2011 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A finite state machine.
   *
   * See {@link qx.util.fsm.State} for details on creating States,
   * and {@link qx.util.fsm.Transition} for details on creating
   * transitions between states.
   */
  qx.Class.define("qx.util.fsm.FiniteStateMachine", {
    extend: qx.core.Object,

    /**
     * @param machineName {String} The name of this finite state machine
     */
    construct: function construct(machineName) {
      // Call our superclass' constructor
      qx.core.Object.constructor.call(this); // Save the machine name

      this.setName(machineName); // Initialize the states object

      this.__states = {}; // The first state added will become the start state

      this.__startState = null; // Initialize the saved-states stack

      this.__savedStates = []; // Initialize the pending event queue

      this.__eventQueue = []; // Initialize the blocked events queue

      this.__blockedEvents = []; // Create the friendlyToObject" object.  Each object has as its property
      // name, the friendly name of the object; and as its property value, the
      // object itself.

      this.__friendlyToObject = {}; // Create the "friendlyToHash" object.  Each object has as its property
      // name, the friendly name of the object; and as its property value, the
      // hash code of the object.

      this.__friendlyToHash = {}; // Create the "hashToFriendly" object.  Each object has as its property
      // name, the hash code of the object; and as its property value, the
      // friendly name of the object.

      this.__hashToFriendly = {}; // Friendly names can be added to groups, for easy manipulation of
      // enabling and disabling groups of widgets.  Track which friendly names
      // are in which group.

      this.__groupToFriendly = {}; // We also need to be able to map back from friendly name to the groups it
      // is in.

      this.__friendlyToGroups = {};
    },
    statics: {
      /**
       * Constants which may be values of the nextState member in the
       * transitionInfo parameter of the Transition constructor.
       */
      StateChange: {
        /** When used as a nextState value, means remain in current state */
        CURRENT_STATE: 1,

        /**
         * When used as a nextState value, means go to most-recently pushed state
         */
        POP_STATE_STACK: 2,

        /** When used as a nextState value, means terminate this state machine */
        TERMINATE: 3
      },

      /**
       * Constants for use in the events member of the transitionInfo parameter
       * of the Transition constructor.
       */
      EventHandling: {
        /**
         * This event is handled by this state, but the predicate of a transition
         * will determine whether to use that transition.
         */
        PREDICATE: 1,

        /** Enqueue this event for possible use by the next state */
        BLOCKED: 2
      },

      /**
       * Debug bitmask values.
       */
      DebugFlags: {
        /** Show events */
        EVENTS: 1,

        /** Show transitions */
        TRANSITIONS: 2,

        /** Show individual function invocations during transitions */
        FUNCTION_DETAIL: 4,

        /**
         * When object friendly names are referenced but not found, show message
         */
        OBJECT_NOT_FOUND: 8
      }
    },
    events: {
      /**
       * Fired when the finite state machine terminates. Data is the last state
       * before termination.
       */
      "terminated": "qx.event.type.Data"
    },
    properties: {
      /**
       * The name of this finite state machine (for debug messages)
       */
      name: {
        check: "String",
        nullable: true
      },

      /**
       * The current state of the finite state machine.
       */
      state: {
        check: "String",
        nullable: true
      },

      /**
       * The previous state of the finite state machine, i.e. the state from
       * which we most recently transitioned.  Note that this could be the same
       * as the current state if a successful transition brought us back to the
       * same state.
       */
      previousState: {
        check: "String",
        nullable: true
      },

      /**
       * The state to which we will be transitioning.  This property is valid
       * only during a Transition's ontransition function and a State's onexit
       * function.  At all other times, it is null.
       */
      nextState: {
        check: "String",
        nullable: true
      },

      /**
       * The maximum number of states which may pushed onto the state-stack.  It
       * is generally a poor idea to have very many states saved on a stack.
       * Following program logic becomes very difficult, and the code can be
       * highly unmaintainable.  The default should be more than adequate.
       * You've been warned.
       */
      maxSavedStates: {
        check: "Number",
        init: 2
      },

      /**
       * Debug flags, composed of the bitmask values in the DebugFlags constant.
       *
       * Set the debug flags from the application by or-ing together bits, akin
       * to this:
       *
       * <pre class='javascript'>
       * var FSM = qx.util.fsm.FiniteStateMachine;
       * fsm.setDebugFlags(FSM.DebugFlags.EVENTS |
       *                   FSM.DebugFlags.TRANSITIONS |
       *                   FSM.DebugFlags.FUNCTION_DETAIL |
       *                   FSM.DebugFlags.OBJECT_NOT_FOUND);
       * </pre>
       */
      debugFlags: {
        check: "Number",
        // Default:
        // (qx.util.fsm.FiniteStateMachine.DebugFlags.EVENTS |
        //  qx.util.fsm.FiniteStateMachine.DebugFlags.TRANSITIONS |
        //  qx.util.fsm.FiniteStateMachine.DebugFlags.OBJECT_NOT_FOUND)
        init: 7
      }
    },
    members: {
      __states: null,
      __startState: null,
      __eventQueue: null,
      __blockedEvents: null,
      __savedStates: null,
      __friendlyToObject: null,
      __friendlyToHash: null,
      __hashToFriendly: null,
      __groupToFriendly: null,
      __friendlyToGroups: null,
      __bEventProcessingInProgress: false,
      __bTerminated: true,

      /**
       * Checks whether the finite state machine is terminated or not.
       *
       * @return {Boolean} If the finite state machine is terminated.
       */
      isTerminated: function isTerminated() {
        return this.__bTerminated;
      },

      /**
       * Add a state to the finite state machine.
       *
       *
       * @param state {qx.util.fsm.State}
       *   An object of class qx.util.fsm.State representing a state which is to
       *   be a part of this finite state machine.
       *
       *
       * @throws {Error} If the given state is not an instanceof of qx.util.fsm.State.
       * @throws {Error} If the given state already exists.
       */
      addState: function addState(state) {
        // Ensure that we got valid state info
        if (!state instanceof qx.util.fsm.State) {
          throw new Error("Invalid state: not an instance of qx.util.fsm.State");
        } // Retrieve the name of this state


        var stateName = state.getName(); // Ensure that the state name doesn't already exist

        if (stateName in this.__states) {
          throw new Error("State " + stateName + " already exists");
        } // Is this the first state being added?


        if (this.__startState == null) {
          // Yup.  Save this state as the start state.
          this.__startState = stateName;
        } // Add the new state object to the finite state machine


        this.__states[stateName] = state;
      },

      /**
       * Replace a state in the finite state machine.  This is useful if
       * initially "dummy" states are created which load the real state table
       * for a series of operations (and possibly also load the gui associated
       * with the new states at the same time).  Having portions of the finite
       * state machine and their associated gui pages loaded at run time can
       * help prevent long delays at application start-up time.
       *
       *
       * @param state {qx.util.fsm.State}
       *   An object of class qx.util.fsm.State representing a state which is to
       *   be a part of this finite state machine.
       *
       * @param bDispose {Boolean}
       *   If <i>true</i>, then dispose the old state object.  If <i>false</i>,
       *   the old state object is returned for disposing by the caller.
       *
       * @return {Object}
       *   The old state object if it was not disposed; otherwise null.
       *
       * @throws {Error} If the given state is not an instanceof of qx.util.fsm.State.
       */
      replaceState: function replaceState(state, bDispose) {
        // Ensure that we got valid state info
        if (!state instanceof qx.util.fsm.State) {
          throw new Error("Invalid state: not an instance of qx.util.fsm.State");
        } // Retrieve the name of this state


        var stateName = state.getName(); // Save the old state object, so we can return it to be disposed

        var oldState = this.__states[stateName]; // Replace the old state with the new state object.

        this.__states[stateName] = state; // Did they request that the old state be disposed?

        if (bDispose) {
          // Yup.  Mark it to be disposed.
          oldState._bNeedDispose = true;
        }

        return oldState;
      },

      /**
       * Add an object (typically a widget) that is to be accessed during state
       * transitions, to the finite state machine.
       *
       *
       * @param friendlyName {String}
       *   The friendly name to used for access to the object being added.
       *
       * @param obj {Object}
       *   The object to associate with the specified friendly name
       *
       * @param groupNames {Array}
       *   An optional list of group names of which this object is a member.
       *
       */
      addObject: function addObject(friendlyName, obj, groupNames) {
        var hash = qx.core.ObjectRegistry.toHashCode(obj);
        this.__friendlyToHash[friendlyName] = hash;
        this.__hashToFriendly[hash] = friendlyName;
        this.__friendlyToObject[friendlyName] = obj; // If no groupNames are specified, we're done.

        if (!groupNames) {
          return;
        } // Allow either a single group name or an array of group names.  If the
        // former, we convert it to the latter to make the subsequent code
        // simpler.


        if (typeof groupNames == "string") {
          groupNames = [groupNames];
        } // For each group that this friendly name is to be a member of...


        for (var i = 0; i < groupNames.length; i++) {
          var groupName = groupNames[i]; // If the group name doesn't yet exist...

          if (!this.__groupToFriendly[groupName]) {
            // ... then create it.
            this.__groupToFriendly[groupName] = {};
          } // Add the friendly name to the list of names in this group


          this.__groupToFriendly[groupName][friendlyName] = true; // If the friendly name group mapping doesn't yet exist...

          if (!this.__friendlyToGroups[friendlyName]) {
            // ... then create it.
            this.__friendlyToGroups[friendlyName] = [];
          } // Append this group name to the list of groups this friendly name is
          // in


          this.__friendlyToGroups[friendlyName].push(groupName);
        }
      },

      /**
       * Remove an object which had previously been added by {@link #addObject}.
       *
       *
       * @param friendlyName {String}
       *   The friendly name associated with an object, specifying which object
       *   is to be removed.
       *
       */
      removeObject: function removeObject(friendlyName) {
        var hash;
        var groupName;
        var objName;
        var bGroupEmpty;
        hash = this.__friendlyToHash[friendlyName]; // Delete references to any groups this friendly name was in

        if (this.__friendlyToGroups[friendlyName]) {
          for (var i = 0; i < this.__friendlyToGroups[friendlyName].length; i++) {
            groupName = this.__friendlyToGroups[friendlyName][i];
            delete this.__groupToFriendly[groupName][friendlyName]; // Is the group empty now?

            bGroupEmpty = true;

            for (objName in this.__groupToFriendly[groupName]) {
              // The group is not empty. That's all we wanted to know.
              bGroupEmpty = false;
              break;
            } // If the group is empty...


            if (bGroupEmpty) {
              // ... then we can delete the entire entry
              delete this.__groupToFriendly[groupName];
            }
          }

          delete this.__friendlyToGroups[friendlyName];
        } // Delete the friendly name


        delete this.__hashToFriendly[hash];
        delete this.__friendlyToHash[friendlyName];
        delete this.__friendlyToObject[friendlyName];
      },

      /**
       * Retrieve an object previously saved via {@link #addObject}, using its
       * Friendly Name.
       *
       *
       * @param friendlyName {String}
       *   The friendly name of the object to be retrieved.
       *
       * @return {Object}
       *   The object which has the specified friendly name, or undefined if no
       *   object has been associated with that name.
       */
      getObject: function getObject(friendlyName) {
        return this.__friendlyToObject[friendlyName];
      },

      /**
       * Get the friendly name of an object.
       *
       *
       * @param obj {Object}
       *   The object for which the friendly name is desired
       *
       * @return {String}
       *   If the object has been previously registered via {@link #addObject},
       *   then the friendly name of the object is returned; otherwise, null.
       */
      getFriendlyName: function getFriendlyName(obj) {
        var hash = obj ? qx.core.ObjectRegistry.toHashCode(obj) : null;
        return hash ? this.__hashToFriendly[hash] : null;
      },

      /**
       * Retrieve the list of objects which have registered, via {@link #addObject}
       * as being members of the specified group.
       *
       *
       * @param groupName {String}
       *   The name of the group for which the member list is desired.
       *
       * @return {Array}
       *   An array containing the friendly names of any objects which are
       *   members of the specified group.  The resultant array may be empty.
       */
      getGroupObjects: function getGroupObjects(groupName) {
        var a = [];

        for (var name in this.__groupToFriendly[groupName]) {
          a.push(name);
        }

        return a;
      },

      /**
       * Display all of the saved objects and their reverse mappings.
       *
       */
      displayAllObjects: function displayAllObjects() {
        for (var friendlyName in this.__friendlyToHash) {
          var hash = this.__friendlyToHash[friendlyName];
          var obj = this.getObject(friendlyName);
          this.debug(friendlyName + " => " + hash);
          this.debug("  " + hash + " => " + this.__hashToFriendly[hash]);
          this.debug("  " + friendlyName + " => " + this.getObject(friendlyName));
          this.debug("  " + this.getObject(friendlyName) + " => " + this.getFriendlyName(obj));
        }
      },

      /**
       * Get internal data for debugging
       *
       * @return {Map}
       *   A map containing the following:
       *     __states
       *     __startState
       *     __eventQueue
       *     __blockedEvents
       *     __savedStates
       *     __friendlyToObject
       *     __friendlyToHash
       *     __hashToFriendly
       *     __groupToFriendly
       *     __friendlyToGroups
       *     __bEventProcessingInProgress
       */
      _getInternalData: function _getInternalData() {
        return {
          "states": this.__states,
          "startState": this.__startState,
          "eventQueue": this.__eventQueue,
          "blockedEvents": this.__blockedEvents,
          "savedStates": this.__savedStates,
          "friendlyToObject": this.__friendlyToObject,
          "friendlyToHash": this.__friendlyToHash,
          "hashToFriendly": this.__hashToFriendly,
          "groupToFriendly": this.__groupToFriendly,
          "friendlyToGroups": this.__friendlyToGroups
        };
      },

      /**
       * Start (or restart, after it has terminated) the finite state machine
       * from the starting state.  The starting state is defined as the first
       * state added to the finite state machine.
       *
       * @throws {Error} If the machine stared with not available state.
       */
      start: function start() {
        this.__bTerminated = false;
        var stateName = this.__startState;

        if (stateName == null) {
          throw new Error("Machine started with no available states");
        } // Set the start state to be the first state which was added to the
        // machine


        this.setState(stateName);
        this.setPreviousState(null);
        this.setNextState(null);
        var debugFunctions = this.getDebugFlags() & qx.util.fsm.FiniteStateMachine.DebugFlags.FUNCTION_DETAIL; // Run the actionsBeforeOnentry actions for the initial state

        if (debugFunctions) {
          this.debug(this.getName() + "#" + stateName + "#actionsBeforeOnentry");
        }

        this.__states[stateName].getAutoActionsBeforeOnentry()(this); // Run the entry function for the new state, if one is specified


        if (debugFunctions) {
          this.debug(this.getName() + "#" + stateName + "#entry");
        }

        this.__states[stateName].getOnentry()(this, null); // Run the actionsAfterOnentry actions for the initial state


        if (debugFunctions) {
          this.debug(this.getName() + "#" + stateName + "#actionsAfterOnentry");
        }

        this.__states[stateName].getAutoActionsAfterOnentry()(this);
      },

      /**
       * Save the current or previous state on the saved-state stack.  A future
       * transition can then provide, as its nextState value, the class
       * constant:
       *
       *   <code>
       *   qx.util.fsm.FiniteStateMachine.StateChange.POP_STATE_STACK
       *   </code>
       *
       * which will cause the next state to be whatever is at the top of the
       * saved-state stack, and remove that top element from the saved-state
       * stack.
       *
       *
       * @param state {Boolean|String}
       *   When <i>true</i>, then push the current state onto the stack.  This
       *   might be used in a transition, before the state has changed.  When
       *   <i>false</i>, then push the previous state onto the stack.  This
       *   might be used in an on entry function to save the previous state to
       *   return to.  If this parameter is a string, it is taken to be the
       *   name of the state to transition to.
       *
       *
       * @throws {Error} If the saved-state stack is full.
       */
      pushState: function pushState(state) {
        // See if there's room on the state stack for a new state
        if (this.__savedStates.length >= this.getMaxSavedStates()) {
          // Nope.  Programmer error.
          throw new Error("Saved-state stack is full");
        }

        if (state === true) {
          // Push the current state onto the saved-state stack
          this.__savedStates.push(this.getState());
        } else if (state) {
          this.__savedStates.push(state);
        } else {
          // Push the previous state onto the saved-state stack
          this.__savedStates.push(this.getPreviousState());
        }
      },

      /**
       * Pop the saved state stack.
       *
       * @return {String|Boolean}
       *   The name of a state or a boolean flag that had most recently been
       *   pushed onto the saved-state stack.
       */
      popState: function popState() {
        // Is there anything on the saved-state stack?
        if (this.__savedStates.length == 0) {
          // Nope. Programmer error.
          throw new Error("Saved-state stack is empty");
        }

        return this.__savedStates.pop();
      },

      /**
       * Add the specified event to a list of events to be passed to the next
       * state following state transition.
       *
       *
       * @param event {qx.event.type.Event}
       *   The event to add to the event queue for processing after state change.
       *
       */
      postponeEvent: function postponeEvent(event) {
        // Add this event to the blocked event queue, so it will be passed to the
        // next state upon transition.
        this.__blockedEvents.unshift(event);
      },

      /**
       * Enqueue an event for processing
       *
       *
       * @param event {qx.event.type.Event}
       *   The event to be enqueued
       *
       * @param bAddAtHead {Boolean}
       *   If <i>true</i>, put the event at the head of the queue for immediate
       *   processing.  If <i>false</i>, place the event at the tail of the
       *   queue so that it receives in-order processing.
       *
       */
      enqueueEvent: function enqueueEvent(event, bAddAtHead) {
        // Add the event to the event queue
        if (bAddAtHead) {
          // Put event at the head of the queue
          this.__eventQueue.push(event);
        } else {
          // Put event at the tail of the queue
          this.__eventQueue.unshift(event);
        }

        if (this.getDebugFlags() & qx.util.fsm.FiniteStateMachine.DebugFlags.EVENTS) {
          // Individual objects are listed.  Ensure target is a saved object
          var friendly = this.getFriendlyName(event.getTarget());

          if (bAddAtHead) {
            this.debug(this.getName() + ": Pushed event: " + event.getType() + (friendly ? " on " + friendly : ""));
          } else {
            this.debug(this.getName() + ": Queued event: " + event.getType() + (friendly ? " on " + friendly : ""));
          }
        }
      },

      /**
       * Event listener for all event types in the finite state machine
       *
       * @param event {qx.event.type.Event} The event that was dispatched.
       */
      eventListener: function eventListener(event) {
        if (this.__bTerminated) {
          this.debug(this.getName() + ": Cannot listen to event '" + event.getType() + "', because the finite state machine is not running.");
          return;
        } // Events are enqueued upon receipt.  Some events are then processed
        // immediately; other events get processed later.  We need to allow the
        // event dispatcher to free the source event upon our return, so we'll
        // clone it and enqueue our clone.  The source event can then be
        // disposed upon our return.


        var e = event.clone(); // Enqueue the new event on the tail of the queue

        this.enqueueEvent(e, false); // Process events

        this.__processEvents();
      },

      /**
       * Create an event and send it immediately to the finite state machine.
       *
       * @param type {String}
       *   The type of event, e.g. "execute"
       *
       * @param target {qx.core.Object}
       *   The target of the event
       *
       * @param data {Object|null}
       *   The data, if any, to issue in the event.  If this parameter is null
       *   then a qx.event.type.Event is instantiated.  Otherwise, an event of
       *   type qx.event.type.Data is instantiated and this data is applied to
       *   it.
       *
       */
      fireImmediateEvent: function fireImmediateEvent(type, target, data) {
        if (this.__bTerminated) {
          this.debug(this.getName() + ": Cannot listen to event '" + type + "', because the finite state machine is not running.");
          return;
        }

        if (data) {
          var event = qx.event.Registration.createEvent(type, qx.event.type.Data, [data, null, false]);
        } else {
          var event = qx.event.Registration.createEvent(type, qx.event.type.Event, [false, false]);
        }

        event.setTarget(target);
        this.eventListener(event);
      },

      /**
       * Create and schedule an event to be sent to the finite state machine
       * "shortly".  This allows such things as letting a progress cursor
       * display prior to handling the event.
       *
       * @param type {String}
       *   The type of event, e.g. "execute"
       *
       * @param target {qx.core.Object}
       *   The target of the event
       *
       * @param data {Object|null}
       *   See {@link #fireImmediateEvent} for details.
       *
       * @param timeout {Integer|null}
       *   If provided, this is the number of milliseconds to wait before firing
       *   the event.  If not provided, a default short interval (on the order
       *   of 20 milliseconds) is used.
       *
       */
      scheduleEvent: function scheduleEvent(type, target, data, timeout) {
        qx.event.Timer.once(function () {
          this.fireImmediateEvent(type, target, data);
        }, this, timeout || 20);
      },

      /**
       * Process all of the events on the event queue.
       *
       */
      __processEvents: function __processEvents() {
        // eventListener() can potentially be called while we're processing
        // events
        if (this.__bEventProcessingInProgress) {
          // We were processing already, so don't process concurrently.
          return;
        } // Track that we're processing events


        this.__bEventProcessingInProgress = true; // Process each of the events on the event queue

        while (this.__eventQueue.length > 0) {
          // Pull the next event from the pending event queue
          var event = this.__eventQueue.pop(); // Run the finite state machine with this event


          var bDispose = this.__run(event); // If we didn't block (and re-queue) the event, dispose it.


          if (bDispose) {
            event.dispose();
          }
        } // We're no longer processing events


        this.__bEventProcessingInProgress = false;
      },

      /**
       * Run the finite state machine to process a single event.
       *
       *
       * @param event {qx.event.type.Event}
       *   An event that has been dispatched.  The event may be handled (if the
       *   current state handles this event type), queued (if the current state
       *   blocks this event type), or discarded (if the current state neither
       *   handles nor blocks this event type).
       *
       * @return {Boolean}
       *   Whether the event should be disposed.  If it was blocked, we've
       *   pushed it back onto the event queue, and it should not be disposed.
       *
       * @throws {Error} If the explicit transitions does not exist.
       * @throws {Error} If the transition returns an invalid value.
       * @throws {Error} If the next step will transit to an nonexistent state.
       * @throws {Error} If the state stack is empty and the next state is POP_STATE_STACK
       * @throws {Error} If the next state is invalid.
       */
      __run: function __run(event) {
        // For use in generated functions...
        // State name variables
        var thisState;
        var nextState;
        var prevState; // The current State object

        var currentState; // The transitions available in the current State

        var transitions; // Events handled by the current State

        var e; // The action to take place upon receipt of a particular event

        var action; // Get the debug flags

        var debugFlags = this.getDebugFlags(); // Allow slightly faster access to determine if debug is enabled

        var debugEvents = debugFlags & qx.util.fsm.FiniteStateMachine.DebugFlags.EVENTS;
        var debugTransitions = debugFlags & qx.util.fsm.FiniteStateMachine.DebugFlags.TRANSITIONS;
        var debugFunctions = debugFlags & qx.util.fsm.FiniteStateMachine.DebugFlags.FUNCTION_DETAIL;
        var debugObjectNotFound = debugFlags & qx.util.fsm.FiniteStateMachine.DebugFlags.OBJECT_NOT_FOUND; // Individual objects are listed.  Ensure target is a saved object

        var friendly = this.getFriendlyName(event.getTarget());

        if (debugEvents) {
          this.debug(this.getName() + ": Process event: " + event.getType() + (friendly ? " on " + friendly : ""));
        } // Get the current state name


        thisState = this.getState(); // Get the current State object

        currentState = this.__states[thisState]; // Get a list of the transitions available from this state

        transitions = currentState.transitions; // Determine how to handle this event

        e = currentState.getEvents()[event.getType()]; // See if we actually found this event type

        if (!e) {
          if (debugEvents) {
            this.debug(this.getName() + ": Event '" + event.getType() + "'" + " not handled.  Ignoring.");
          }

          return true;
        } // We might have found a constant (PREDICATE or BLOCKED) or an object
        // with each property name being the friendly name of a saved object,
        // and the property value being one of the constants (PREDICATE or
        // BLOCKED).


        if (typeof e == "object") {
          if (!friendly) {
            // Nope, it doesn't seem so.  Just discard it.
            if (debugObjectNotFound) {
              this.debug(this.getName() + ": Could not find friendly name for '" + event.getType() + "' on '" + event.getTarget() + "'");
            }

            return true;
          }

          action = e[friendly]; // Do we handle this event type for the widget from which it
          // originated?

          if (!action) {
            // Nope.
            if (debugEvents) {
              this.debug(this.getName() + ": Event '" + event.getType() + "'" + " not handled for target " + friendly + ".  Ignoring.");
            }

            return true;
          }
        } else {
          action = e;
        }

        switch (action) {
          case qx.util.fsm.FiniteStateMachine.EventHandling.PREDICATE:
            // Process this event.  One of the transitions should handle it.
            break;

          case qx.util.fsm.FiniteStateMachine.EventHandling.BLOCKED:
            // This event is blocked.  Enqueue it for later, and get outta here.
            if (debugEvents) {
              this.debug(this.getName() + ": Event '" + event.getType() + "'" + " blocked.  Re-queuing.");
            }

            this.__blockedEvents.unshift(event);

            return false;

          default:
            // See if we've been given an explicit transition name
            if (typeof action == "string") {
              // Yup!  Ensure that it exists
              if (transitions[action]) {
                // Yup.  Create a transitions object containing only this
                // transition.
                var trans = transitions[action];
                transitions = {};
                transitions[action] = trans;
              } else {
                throw new Error("Explicit transition " + action + " does not exist");
              }

              break;
            }

        } // We handle the event.  Try each transition in turn until we find one
        // that is acceptable.


        for (var t in transitions) {
          var trans = transitions[t]; // Does the predicate allow use of this transition?

          switch (trans.getPredicate()(this, event)) {
            case true:
              // Transition is allowed.  Proceed.
              break;

            case false:
              // Transition is not allowed.  Try next transition.
              continue;

            case null:
              // Transition indicates not to try further transitions
              return true;

            default:
              throw new Error("Transition " + thisState + ":" + t + " returned a value other than " + "true, false, or null.");
          } // We think we can transition to the next state.  Set next state.


          nextState = trans.getNextState();

          if (typeof nextState == "string") {
            // We found a literal state name.  Ensure it exists.
            if (!nextState in this.__states) {
              throw new Error("Attempt to transition to nonexistent state " + nextState);
            } // It exists.  Track it being the next state.


            this.setNextState(nextState);
          } else {
            // If it's not a string, nextState must be a StateChange constant
            switch (nextState) {
              case qx.util.fsm.FiniteStateMachine.StateChange.CURRENT_STATE:
                // They want to remain in the same state.
                nextState = thisState;
                this.setNextState(nextState);
                break;

              case qx.util.fsm.FiniteStateMachine.StateChange.POP_STATE_STACK:
                // Switch to the state at the top of the state stack.
                if (this.__savedStates.length == 0) {
                  throw new Error("Attempt to transition to POP_STATE_STACK while state stack is empty.");
                } // Pop the state stack to retrieve the state to transition to


                nextState = this.__savedStates.pop();
                this.setNextState(nextState);
                break;

              case qx.util.fsm.FiniteStateMachine.StateChange.TERMINATE:
                // Terminate fsm
                this.__bTerminated = true;
                this.setNextState(null);
                break;

              default:
                throw new Error("Internal error: invalid nextState");
            }
          } // Run the actionsBeforeOntransition actions for this transition


          if (debugFunctions) {
            this.debug(this.getName() + "#" + thisState + "#" + t + "#autoActionsBeforeOntransition");
          }

          trans.getAutoActionsBeforeOntransition()(this); // Run the 'ontransition' function

          if (debugFunctions) {
            this.debug(this.getName() + "#" + thisState + "#" + t + "#ontransition");
          }

          trans.getOntransition()(this, event); // Run the autoActionsAfterOntransition actions for this transition

          if (debugFunctions) {
            this.debug(this.getName() + "#" + thisState + "#" + t + "#autoActionsAfterOntransition");
          }

          trans.getAutoActionsAfterOntransition()(this); // Run the autoActionsBeforeOnexit actions for the old state

          if (debugFunctions) {
            this.debug(this.getName() + "#" + thisState + "#autoActionsBeforeOnexit");
          }

          currentState.getAutoActionsBeforeOnexit()(this); // Run the exit function for the old state

          if (debugFunctions) {
            this.debug(this.getName() + "#" + thisState + "#exit");
          }

          currentState.getOnexit()(this, event); // Run the autoActionsAfterOnexit actions for the old state

          if (debugFunctions) {
            this.debug(this.getName() + "#" + thisState + "#autoActionsAfterOnexit");
          }

          currentState.getAutoActionsAfterOnexit()(this); // If this state has been replaced and we're supposed to dispose it...

          if (currentState._bNeedDispose) {
            // ... then dispose it now that it's no longer in use
            currentState.dispose();
          } // It the fsm has terminated, stop right here


          if (this.__bTerminated) {
            if (debugFunctions) {
              this.debug(this.getName() + "#" + "TERMINATED");
            }

            this.fireDataEvent("terminated", thisState);
            return true;
          } // Reset currentState to the new state object


          currentState = this.__states[this.getNextState()]; // set previousState and state, and clear nextState, for transition

          this.setPreviousState(thisState);
          this.setState(this.getNextState());
          this.setNextState(null);
          prevState = thisState;
          thisState = nextState;
          nextState = undefined; // Run the autoActionsBeforeOnentry actions for the new state

          if (debugFunctions) {
            this.debug(this.getName() + "#" + thisState + "#autoActionsBeforeOnentry");
          }

          currentState.getAutoActionsBeforeOnentry()(this); // Run the entry function for the new state, if one is specified

          if (debugFunctions) {
            this.debug(this.getName() + "#" + thisState + "#entry");
          }

          currentState.getOnentry()(this, event); // Run the autoActionsAfterOnentry actions for the new state

          if (debugFunctions) {
            this.debug(this.getName() + "#" + thisState + "#autoActionsAfterOnentry");
          }

          currentState.getAutoActionsAfterOnentry()(this); // Add any blocked events back onto the pending event queue

          for (var i = 0; i < this.__blockedEvents.length; i++) {
            e = this.__blockedEvents.pop();

            this.__eventQueue.unshift(e);
          }

          if (debugTransitions) {
            this.debug(this.getName() + "#" + prevState + " => " + this.getName() + "#" + thisState);
          } // See ya!


          return true;
        }

        if (debugTransitions) {
          this.debug(this.getName() + "#" + thisState + ": event '" + event.getType() + "'" + ": no transition found.  No state change.");
        }

        return true;
      }
    },
    destruct: function destruct() {
      this._disposeArray("__eventQueue");

      this._disposeArray("__blockedEvents");

      this.__savedStates = this.__states = null;
    }
  });
  qx.util.fsm.FiniteStateMachine.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.lang.Function": {},
      "qx.util.fsm.FiniteStateMachine": {},
      "qx.util.fsm.Transition": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006, 2007, 2011 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Create a new state which may be added to a finite state machine.
   */
  qx.Class.define("qx.util.fsm.State", {
    extend: qx.core.Object,

    /**
     * @param stateName {String}
     *   The name of this state.  This is the name which may be referenced in
     *   objects of class qx.util.fsm.Transition, when passing of
     *   the transition's predicate means transition to this state.
     *
     * @param stateInfo {Map}
     *   <pre>
     *   An object containing any of the following properties:
     *
     *     context -
     *       A context in which all of the following functions should be run.
     *
     *     onentry -
     *       A function which is called upon entry to the state.  Its signature
     *       is function(fsm, event) and it is saved in the onentry property of
     *       the state object.  (This function is called after the Transition's
     *       action function and after the previous state's onexit function.)
     *
     *       In the onentry function:
     *
     *         fsm -
     *           The finite state machine object to which this state is attached.
     *
     *         event -
     *           The event that caused the finite state machine to run
     *
     *     onexit -
     *       A function which is called upon exit from the state.  Its signature
     *       is function(fsm, event) and it is saved in the onexit property of
     *       the state object.  (This function is called after the Transition's
     *       action function and before the next state's onentry function.)
     *
     *       In the onexit function:
     *
     *         fsm -
     *           The finite state machine object to which this state is attached.
     *
     *         event -
     *           The event that caused the finite state machine to run
     *
     *     autoActionsBeforeOnentry -
     *     autoActionsAfterOnentry -
     *     autoActionsBeforeOnexit -
     *     autoActionsAfterOnexit -
     *       Automatic actions which take place at the time specified by the
     *       property name.  In all cases, the action takes place immediately
     *       before or after the specified function.
     *
     *       The property value for each of these properties is an object which
     *       describes some number of functions to invoke on a set of specified
     *       objects (typically widgets).
     *
     *       An example, using autoActionsBeforeOnentry, might look like this:
     *
     *       "autoActionsBeforeOnentry" :
     *       {
     *         // The name of a function.
     *         "setEnabled" :
     *         [
     *           {
     *             // The parameter value, thus "setEnabled(true);"
     *             "parameters" : [ true ],
     *
     *             // The function would be called on each object:
     *             //  this.getObject("obj1").setEnabled(true);
     *             //  this.getObject("obj2").setEnabled(true);
     *             "objects" : [ "obj1", "obj2" ],
     *
     *             // And similarly for each object in each specified group.
     *             "groups"  : [ "group1", "group2" ]
     *           }
     *         ],
     *
     *         // The name of another function.
     *         "setVisible" :
     *         [
     *           {
     *             // The parameter value, thus "setVisible(false);"
     *             "parameters" : [ false ],
     *
     *             // The function would be called on each object and group, as
     *             // described above.
     *             "objects" : [ "obj3", "obj4" ],
     *             "groups"  : [ "group3", "group4" ]
     *           }
     *         ]
     *       };
     *
     *     events (required) -
     *       A description to the finite state machine of how to handle a
     *       particular event, optionally associated with a specific target
     *       object on which the event was dispatched.  This should be an object
     *       containing one property for each event which is either handled or
     *       blocked.  The property name should be the event name.  The property
     *       value should be one of:
     *
     *         (a) qx.util.fsm.FiniteStateMachine.EventHandling.PREDICATE
     *
     *         (b) qx.util.fsm.FiniteStateMachine.EventHandling.BLOCKED
     *
     *         (c) a string containing the name of an explicit Transition to use
     *
     *         (d) an object where each property name is the Friendly Name of an
     *             object (meaning that this rule applies if both the event and
     *             the event's target object's Friendly Name match), and its
     *             property value is one of (a), (b) or (c), above.
     *
     *       This object is saved in the events property of the state object.
     *
     *     Additional properties may be provided in stateInfo.  They will not be
     *     used by the finite state machine, but will be available via
     *     this.getUserData("<propertyName>") during the state's onentry and
     *     onexit functions.
     *   </pre>
     *
     * @throws {Error} If the state info is not a valid object.
     * @throws {Error} If the events object is not provided in new state info.
     *
     */
    construct: function construct(stateName, stateInfo) {
      var context; // Call our superclass' constructor

      qx.core.Object.constructor.call(this); // Save the state name

      this.setName(stateName); // Ensure they passed in an object

      if (typeof stateInfo != "object") {
        throw new Error("State info must be an object");
      } // If a context was specified, retrieve it.


      context = stateInfo.context || window; // Save it for future use

      this.setUserData("context", context); // Save data from the stateInfo object

      for (var field in stateInfo) {
        // If we find one of our properties, call its setter.
        switch (field) {
          case "onentry":
            this.setOnentry(this.__bindIfFunction(stateInfo[field], context));
            break;

          case "onexit":
            this.setOnexit(this.__bindIfFunction(stateInfo[field], context));
            break;

          case "autoActionsBeforeOnentry":
            this.setAutoActionsBeforeOnentry(stateInfo[field]);
            break;

          case "autoActionsAfterOnentry":
            this.setAutoActionsAfterOnentry(stateInfo[field]);
            break;

          case "autoActionsBeforeOnexit":
            this.setAutoActionsBeforeOnexit(stateInfo[field]);
            break;

          case "autoActionsAfterOnexit":
            this.setAutoActionsAfterOnexit(stateInfo[field]);
            break;

          case "events":
            this.setEvents(stateInfo[field]);
            break;

          case "context":
            // already handled
            break;

          default:
            // Anything else is user-provided data for their own use.  Save it.
            this.setUserData(field, stateInfo[field]); // Log it in case it was a typo and they intended a built-in field

            this.debug("State " + stateName + ": " + "Adding user-provided field to state: " + field);
            break;
        }
      } // Check for required but missing properties


      if (!this.getEvents()) {
        throw new Error("The events object must be provided in new state info");
      } // Initialize the transition list


      this.transitions = {};
    },
    statics: {
      /**
       * Common function for checking the value provided for
       * auto actions.
       *
       * Auto-action property values passed to us look akin to:
       *
       *     <pre class='javascript'>
       *     {
       *       // The name of a function.
       *       "setEnabled" :
       *       [
       *         {
       *           // The parameter value(s), thus "setEnabled(true);"
       *           "parameters"   : [ true ],
       *
       *           // The function would be called on each object:
       *           //  this.getObject("obj1").setEnabled(true);
       *           //  this.getObject("obj2").setEnabled(true);
       *           "objects" : [ "obj1", "obj2" ]
       *
       *           // And similarly for each object in each specified group.
       *           "groups"  : [ "group1", "group2" ],
       *         }
       *       ];
       *
       *       "setTextColor" :
       *       [
       *         {
       *           "parameters" : [ "blue" ]
       *           "groups"     : [ "group3", "group4" ],
       *           "objects"    : [ "obj3", "obj4" ]
       *         }
       *       ];
       *     };
       *     </pre>
       *
       *
       * @param actionType {String}
       *   The name of the action being validated (for debug messages)
       *
       * @param value {Object}
       *   The property value which is being validated
       *
       * @param context {Object}
       *   The object to which the created function should be bound.
       *
       * @return {Function}
       *   Function that implements calls to each of the requested automatic
       *   actions
       *
       * @throws {Error} If the value has an invalid type.
       * @throws {Error} If the function type is not an array.
       * @throws {Error} If the function request parameter type is not valid.
       * @throws {Error} If the function parameters are not valid.
       * @throws {Error} If 'objects' list is invalid.
       * @throws {Error} If a name in the 'objects' list is not valid.
       * @throws {Error} If the 'groups' list is not valid.
       */
      _commonTransformAutoActions: function _commonTransformAutoActions(actionType, value, context) {
        // Validate that we received an object property value
        if (typeof value != "object") {
          throw new Error("Invalid " + actionType + " value: " + typeof value);
        } // We'll create a function to do the requested actions.  Initialize the
        // string into which we'll generate the common fragment added to the
        // function for each object.


        var funcFragment; // Here, we'll keep the function body.  Initialize a try block.

        var func = "try{";
        var param;
        var objectAndGroupList; // Retrieve the function request, e.g.
        // "enabled" :

        for (var f in value) {
          // Get the function request value object, e.g.
          // "setEnabled" :
          // [
          //   {
          //     "parameters"   : [ true ],
          //     "objects" : [ "obj1", "obj2" ]
          //     "groups"  : [ "group1", "group2" ],
          //   }
          // ];
          var functionRequest = value[f]; // The function request value should be an object

          if (!functionRequest instanceof Array) {
            throw new Error("Invalid function request type: expected array, found " + typeof functionRequest);
          } // For each function request...


          for (var i = 0; i < functionRequest.length; i++) {
            // Retrieve the object and group list object
            objectAndGroupList = functionRequest[i]; // The object and group list should be an object, e.g.
            // {
            //   "parameters"   : [ true ],
            //   "objects" : [ "obj1", "obj2" ]
            //   "groups"  : [ "group1", "group2" ],
            // }

            if (typeof objectAndGroupList != "object") {
              throw new Error("Invalid function request parameter type: expected object, found " + typeof functionRequest[param]);
            } // Retrieve the parameter list


            var params = objectAndGroupList["parameters"]; // If it didn't exist, ...

            if (!params) {
              // ... use an empty array.
              params = [];
            } else {
              // otherwise, ensure we got an array
              if (!params instanceof Array) {
                throw new Error("Invalid function parameters: expected array, found " + typeof params);
              }
            } // Create the function to call on each object.  The object on which
            // the function is called will be prepended later.


            funcFragment = f + "("; // For each parameter...

            for (var j = 0; j < params.length; j++) {
              // If this isn't the first parameter, add a separator
              if (j != 0) {
                funcFragment += ",";
              }

              if (typeof params[j] == "function") {
                // If the parameter is a function, arrange for it to be called
                // at run time.
                funcFragment += "(" + params[j] + ")(fsm)";
              } else if (typeof params[j] == "string") {
                // If the parameter is a string, quote it.
                funcFragment += '"' + params[j] + '"';
              } else {
                // Otherwise, just add the parameter's literal value
                funcFragment += params[j];
              }
            } // Complete the function call


            funcFragment += ")"; // Get the "objects" list, e.g.
            //   "objects" : [ "obj1", "obj2" ]

            var a = objectAndGroupList["objects"]; // Was there an "objects" list?

            if (!a) {
              // Nope.  Simplify code by creating an empty array.
              a = [];
            } else if (!a instanceof Array) {
              throw new Error("Invalid 'objects' list: expected array, got " + typeof a);
            }

            for (var j = 0; j < a.length; j++) {
              // Ensure we got a string
              if (typeof a[j] != "string") {
                throw new Error("Invalid friendly name in 'objects' list: " + a[j]);
              }

              func += " fsm.getObject('" + a[j] + "')." + funcFragment + ";";
            } // Get the "groups" list, e.g.
            //   "groups" : [ "group1, "group2" ]


            var g = objectAndGroupList["groups"]; // Was a "groups" list found?

            if (g) {
              // Yup.  Ensure it's an array.
              if (!g instanceof Array) {
                throw new Error("Invalid 'groups' list: expected array, got " + typeof g);
              }

              for (j = 0; j < g.length; j++) {
                // Arrange to call the function on each object in each group
                func += "  var groupObjects =     fsm.getGroupObjects('" + g[j] + "');" + "  for (var i = 0; i < groupObjects.length; i++)" + "  {" + "    var objName = groupObjects[i];" + "    fsm.getObject(objName)." + funcFragment + ";" + "  }";
              }
            }
          }
        } // Terminate the try block for function invocations


        func += "}catch(ex){  fsm.debug(ex);}"; // We've now built the entire body of a function that implements calls
        // to each of the requested automatic actions.  Create and return the
        // function, which will become the property value.

        return qx.lang.Function.bind(new Function("fsm", func), context);
      }
    },
    properties: {
      /**
       * The name of this state.  This name may be used as a Transition's
       * nextState value, or an explicit next state in the 'events' handling
       * list in a State.
       */
      name: {
        transform: "__transformName",
        nullable: true
      },

      /**
       * The onentry function for this state.  This is documented in the
       * constructor, and is typically provided through the constructor's
       * stateInfo object, but it is also possible (but highly NOT recommended)
       * to change this dynamically.
       */
      onentry: {
        transform: "__transformOnentry",
        nullable: true,
        init: function init(fsm, event) {}
      },

      /**
       * The onexit function for this state.  This is documented in the
       * constructor, and is typically provided through the constructor's
       * stateInfo object, but it is also possible (but highly NOT recommended)
       * to change this dynamically.
       */
      onexit: {
        transform: "__transformOnexit",
        nullable: true,
        init: function init(fsm, event) {}
      },

      /**
       * Automatic actions to take prior to calling the state's onentry function.
       *
       * The value passed to setAutoActionsBeforeOnentry() should like something
       * akin to:
       *
       *     <pre class='javascript'>
       *     "autoActionsBeforeOnentry" :
       *     {
       *       // The name of a function.  This would become "setEnabled("
       *       "enabled" :
       *       [
       *         {
       *           // The parameter value, thus "setEnabled(true);"
       *           "parameters" : [ true ],
       *
       *           // The function would be called on each object:
       *           //  this.getObject("obj1").setEnabled(true);
       *           //  this.getObject("obj2").setEnabled(true);
       *           "objects" : [ "obj1", "obj2" ]
       *
       *           // And similarly for each object in each specified group.
       *           "groups"  : [ "group1", "group2" ],
       *         }
       *       ];
       *     };
       *     </pre>
       */
      autoActionsBeforeOnentry: {
        transform: "__transformAutoActionsBeforeOnentry",
        nullable: true,
        init: function init(fsm, event) {}
      },

      /**
       * Automatic actions to take after return from the state's onentry
       * function.
       *
       * The value passed to setAutoActionsAfterOnentry() should like something
       * akin to:
       *
       *     <pre class='javascript'>
       *     "autoActionsAfterOnentry" :
       *     {
       *       // The name of a function.  This would become "setEnabled("
       *       "enabled" :
       *       [
       *         {
       *           // The parameter value, thus "setEnabled(true);"
       *           "parameters" : [ true ],
       *
       *           // The function would be called on each object:
       *           //  this.getObject("obj1").setEnabled(true);
       *           //  this.getObject("obj2").setEnabled(true);
       *           "objects" : [ "obj1", "obj2" ]
       *
       *           // And similarly for each object in each specified group.
       *           "groups"  : [ "group1", "group2" ],
       *         }
       *       ];
       *     };
       *     </pre>
       */
      autoActionsAfterOnentry: {
        transform: "__transformAutoActionsAfterOnentry",
        nullable: true,
        init: function init(fsm, event) {}
      },

      /**
       * Automatic actions to take prior to calling the state's onexit function.
       *
       * The value passed to setAutoActionsBeforeOnexit() should like something
       * akin to:
       *
       *     <pre class='javascript'>
       *     "autoActionsBeforeOnexit" :
       *     {
       *       // The name of a function.  This would become "setEnabled("
       *       "enabled" :
       *       [
       *         {
       *           // The parameter value, thus "setEnabled(true);"
       *           "parameters" : [ true ],
       *
       *           // The function would be called on each object:
       *           //  this.getObject("obj1").setEnabled(true);
       *           //  this.getObject("obj2").setEnabled(true);
       *           "objects" : [ "obj1", "obj2" ]
       *
       *           // And similarly for each object in each specified group.
       *           "groups"  : [ "group1", "group2" ],
       *         }
       *       ];
       *     };
       *     </pre>
       */
      autoActionsBeforeOnexit: {
        transform: "__transformAutoActionsBeforeOnexit",
        nullable: true,
        init: function init(fsm, event) {}
      },

      /**
       * Automatic actions to take after returning from the state's onexit
       * function.
       *
       * The value passed to setAutoActionsAfterOnexit() should like something
       * akin to:
       *
       *     <pre class='javascript'>
       *     "autoActionsBeforeOnexit" :
       *     {
       *       // The name of a function.  This would become "setEnabled("
       *       "enabled" :
       *       [
       *         {
       *           // The parameter value, thus "setEnabled(true);"
       *           "parameters" : [ true ],
       *
       *           // The function would be called on each object:
       *           //  this.getObject("obj1").setEnabled(true);
       *           //  this.getObject("obj2").setEnabled(true);
       *           "objects" : [ "obj1", "obj2" ]
       *
       *           // And similarly for each object in each specified group.
       *           "groups"  : [ "group1", "group2" ],
       *         }
       *       ];
       *     };
       *     </pre>
       */
      autoActionsAfterOnexit: {
        transform: "__transformAutoActionsAfterOnexit",
        nullable: true,
        init: function init(fsm, event) {}
      },

      /**
       * The object representing handled and blocked events for this state.
       * This is documented in the constructor, and is typically provided
       * through the constructor's stateInfo object, but it is also possible
       * (but highly NOT recommended) to change this dynamically.
       */
      events: {
        transform: "__transformEvents",
        nullable: true
      }
    },
    members: {
      /**
       * Internal transform method
       *
       * @param value {var} Value passed to setter
       * @return {var} the final value
       * @throws {Error} when an invalid value is detected
       */
      __transformName: function __transformName(value) {
        // Ensure that we got a valid state name
        if (typeof value != "string" || value.length < 1) {
          throw new Error("Invalid state name");
        }

        return value;
      },

      /**
       * Internal transform method
       *
       * @param value {var} Current value
       * @return {var} the final value
       * @throws {Error} when an invalid value is detected
       */
      __transformOnentry: function __transformOnentry(value) {
        // Validate the onentry function
        switch (typeof value) {
          case "undefined":
            // None provided.  Convert it to a null function
            return function (fsm, event) {};

          case "function":
            // We're cool.  No changes required
            return qx.lang.Function.bind(value, this.getUserData("context"));

          default:
            throw new Error("Invalid onentry type: " + typeof value);
        }
      },

      /**
       * Internal transform method
       *
       * @param value {var} Current value
       * @return {var} the final value
       * @throws {Error} when an invalid value is detected
       */
      __transformOnexit: function __transformOnexit(value) {
        // Validate the onexit function
        switch (typeof value) {
          case "undefined":
            // None provided.  Convert it to a null function
            return function (fsm, event) {};

          case "function":
            // We're cool.  No changes required
            return qx.lang.Function.bind(value, this.getUserData("context"));

          default:
            throw new Error("Invalid onexit type: " + typeof value);
        }
      },

      /**
       * Internal transform method
       *
       * @param value {var} Current value
       * @return {var} the final value
       * @throws {Error} when an invalid value is detected
       */
      __transformEvents: function __transformEvents(value) {
        // Validate that events is an object
        if (typeof value != "object") {
          throw new Error("events must be an object");
        } // Confirm that each property is a valid value
        // The property value should be one of:
        //
        // (a) qx.util.fsm.FiniteStateMachine.EventHandling.PREDICATE
        //
        // (b) qx.util.fsm.FiniteStateMachine.EventHandling.BLOCKED
        //
        // (c) a string containing the name of an explicit Transition to use
        //
        // (d) an object where each property name is the Friendly Name of an
        //     object (meaning that this rule applies if both the event and
        //     the event's target object's Friendly Name match), and its
        //     property value is one of (a), (b) or (c), above.


        for (var e in value) {
          var action = value[e];

          if (typeof action == "number" && action != qx.util.fsm.FiniteStateMachine.EventHandling.PREDICATE && action != qx.util.fsm.FiniteStateMachine.EventHandling.BLOCKED) {
            throw new Error("Invalid numeric value in events object: " + e + ": " + action);
          } else if (typeof action == "object") {
            for (var action_e in action) {
              if (typeof action[action_e] == "number" && action[action_e] != qx.util.fsm.FiniteStateMachine.EventHandling.PREDICATE && action[action_e] != qx.util.fsm.FiniteStateMachine.EventHandling.BLOCKED) {
                throw new Error("Invalid numeric value in events object (" + e + "): " + action_e + ": " + action[action_e]);
              } else if (typeof action[action_e] != "string" && typeof action[action_e] != "number") {
                throw new Error("Invalid value in events object (" + e + "): " + action_e + ": " + action[action_e]);
              }
            }
          } else if (typeof action != "string" && typeof action != "number") {
            throw new Error("Invalid value in events object: " + e + ": " + value[e]);
          }
        } // We're cool.  No changes required.


        return value;
      },

      /**
       * Internal transform method
       *
       * @param value {var} Current value
       * @return {var} the final value
       */
      __transformAutoActionsBeforeOnentry: function __transformAutoActionsBeforeOnentry(value) {
        return qx.util.fsm.State._commonTransformAutoActions("autoActionsBeforeOnentry", value, this.getUserData("context"));
      },

      /**
       * Internal transform method
       *
       * @param value {var} Current value
       * @return {var} the final value
       */
      __transformAutoActionsAfterOnentry: function __transformAutoActionsAfterOnentry(value) {
        return qx.util.fsm.State._commonTransformAutoActions("autoActionsAfterOnentry", value, this.getUserData("context"));
      },

      /**
       * Internal transform method
       *
       * @param value {var} Current value
       * @return {var} the final value
       */
      __transformAutoActionsBeforeOnexit: function __transformAutoActionsBeforeOnexit(value) {
        return qx.util.fsm.State._commonTransformAutoActions("autoActionsBeforeOnexit", value, this.getUserData("context"));
      },

      /**
       * Internal transform method
       *
       * @param value {var} Current value
       * @return {var} the final value
       */
      __transformAutoActionsAfterOnexit: function __transformAutoActionsAfterOnexit(value) {
        return qx.util.fsm.State._commonTransformAutoActions("autoActionsAfterOnexit", value, this.getUserData("context"));
      },

      /**
       * If given a function, bind it to a specified context.
       *
       * @param f {Function|var}
       *   The (possibly) function to be bound to the specified context.
       *
       * @param context {Object}
       *   The context to bind the function to.
       *
       * @return {Function}
       *   If f was a function, the return value is f wrapped such that it will
       *   be called in the specified context. Otherwise, f is returned
       *   unaltered.
       */
      __bindIfFunction: function __bindIfFunction(f, context) {
        // Is the first parameter a function?
        if (typeof f == "function") {
          // Yup. Bind it to the specified context.
          f = qx.lang.Function.bind(f, context);
        }

        return f;
      },

      /**
       * Add a transition to a state
       *
       *
       * @param trans {qx.util.fsm.Transition}
       *   An object of class qx.util.fsm.Transition representing a transition
       *   which is to be a part of this state.
       *
       */
      addTransition: function addTransition(trans) {
        // Ensure that we got valid transition info
        if (!trans instanceof qx.util.fsm.Transition) {
          throw new Error("Invalid transition: not an instance of qx.util.fsm.Transition");
        } // Add the new transition object to the state


        this.transitions[trans.getName()] = trans;
      }
    }
  });
  qx.util.fsm.State.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.util.fsm.FiniteStateMachine": {
        "require": true
      },
      "qx.lang.Function": {},
      "qx.util.fsm.State": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006, 2007, 2011 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Create a new possible transition from one state to another.
   */
  qx.Class.define("qx.util.fsm.Transition", {
    extend: qx.core.Object,

    /**
     * @param transitionName {String}
     *   The name of this transition, used in debug messages.
     *
     * @param transitionInfo {Object}
     *   <pre>
     *   An object optionally containing any of the following properties:
     *
     *     context -
     *       A context in which all of the following functions should be run.
     *
     *     predicate -
     *       A function which is called to determine whether this transition is
     *       acceptable.  An acceptable transition will cause the transition's
     *       "ontransition" function to be run, the current state's "onexit"
     *       function to be run, and the new state's "onentry" function to be
     *       run.
     *
     *       The predicate function's signature is function(fsm, event) and it
     *       is saved in the predicate property of the transition object.  In
     *       the predicate function:
     *
     *         fsm -
     *           The finite state machine object to which this state is
     *           attached.
     *
     *         event -
     *           The event that caused a run of the finite state machine
     *
     *       The predicate function should return one of the following three
     *       values:
     *
     *         - true means the transition is acceptable
     *
     *         - false means the transition is not acceptable, and the next
     *           transition (if one exists) should be tried to determine if it
     *           is acceptable
     *
     *         - null means that the transition determined that no further
     *           transitions should be tried.  This might be used when the
     *           transition ascertained that the event is for a target that is
     *           not available in the current state, and the event has called
     *           fsm.queueEvent() to have the event delivered upon state
     *           transition.
     *
     *       It is possible to create a default predicate -- one that will cause
     *       a transition to be acceptable always -- by either not providing a
     *       predicate property, or by explicitly either setting the predicate
     *       property to 'true' or setting it to a function that unconditionally
     *       returns 'true'.  This default transition should, of course, always
     *       be the last transition added to a state, since no transition added
     *       after it will ever be tried.
     *
     *     nextState -
     *       The state to which we transition, if the predicate returns true
     *       (meaning the transition is acceptable).  The value of nextState may
     *       be:
     *
     *         - a string, the state name of the state to transition to
     *
     *         - One of the constants:
     *           - qx.util.fsm.FiniteStateMachine.StateChange.CURRENT_STATE:
     *               Remain in whatever is the current state
     *           - qx.util.fsm.FiniteStateMachine.StateChange.POP_STATE_STACK:
     *               Transition to the state at the top of the saved-state
     *               stack, and remove the top element from the saved-state
     *               stack.  Elements are added to the saved-state stack using
     *               fsm.pushState().  It is an error if no state exists on the
     *               saved-state stack.
     *           - qx.util.fsm.FiniteStateMachine.StateChange.TERMINATE:
     *               TBD
     *
     *     autoActionsBeforeOntransition -
     *     autoActionsAfterOntransition -
     *       Automatic actions which take place at the time specified by the
     *       property name.  In all cases, the action takes place immediately
     *       before or after the specified function.
     *
     *       The property value for each of these properties is an object which
     *       describes some number of functions to invoke on a set of specified
     *       objects (typically widgets).
     *
     *       See {@link qx.util.fsm.State} for an example of autoActions.
     *
     *     ontransition -
     *       A function which is called if the predicate function for this
     *       transition returns true.  Its signature is function(fsm, event) and
     *       it is saved in the ontransition property of the transition object.
     *       In the ontransition function:
     *
     *         fsm -
     *           The finite state machine object to which this state is
     *           attached.
     *
     *         event -
     *           The event that caused a run of the finite state machine
     *
     *     Additional properties may be provided in transInfo.  They will not be
     *     used by the finite state machine, but will be available via
     *     this.getUserData("<propertyName>") during the transition's predicate
     *     and ontransition functions.
     *   </pre>
     */
    construct: function construct(transitionName, transitionInfo) {
      var context; // Call our superclass' constructor

      qx.core.Object.constructor.call(this); // Save the state name

      this.setName(transitionName); // If a context was specified, retrieve it.

      context = transitionInfo.context || window; // Save it for future use

      this.setUserData("context", context); // Save data from the transitionInfo object

      for (var field in transitionInfo) {
        // If we find one of our properties, call its setter.
        switch (field) {
          case "predicate":
            this.setPredicate(this.__bindIfFunction(transitionInfo[field], context));
            break;

          case "nextState":
            this.setNextState(transitionInfo[field]);
            break;

          case "autoActionsBeforeOntransition":
            this.setAutoActionsBeforeOntransition(this.__bindIfFunction(transitionInfo[field], context));
            break;

          case "autoActionsAfterOntransition":
            this.setAutoActionsAfterOntransition(this.__bindIfFunction(transitionInfo[field], context));
            break;

          case "ontransition":
            this.setOntransition(this.__bindIfFunction(transitionInfo[field], context));
            break;

          case "context":
            // already handled
            break;

          default:
            // Anything else is user-provided data for their own use.  Save it.
            this.setUserData(field, transitionInfo[field]); // Log it in case it was a typo and they intended a built-in field

            this.debug("Transition " + transitionName + ": " + "Adding user-provided field to transition: " + field);
            break;
        }
      }
    },
    properties: {
      /**
       * The name of this transition
       */
      name: {
        check: "String",
        nullable: true
      },

      /**
       * The predicate function for this transition.  This is documented in the
       * constructor, and is typically provided through the constructor's
       * transitionInfo object, but it is also possible (but highly NOT
       * recommended) to change this dynamically.
       */
      predicate: {
        init: function init(fsm, event) {
          return true;
        },
        transform: "__transformPredicate"
      },

      /**
       * The state to transition to, if the predicate determines that this
       * transition is acceptable.  This is documented in the constructor, and
       * is typically provided through the constructor's transitionInfo object,
       * but it is also possible (but highly NOT recommended) to change this
       * dynamically.
       */
      nextState: {
        init: qx.util.fsm.FiniteStateMachine.StateChange.CURRENT_STATE,
        transform: "__transformNextState"
      },

      /**
       * Automatic actions to take prior to calling the transition's
       * ontransition function.  This is documented in the constructor, and is
       * typically provided through the constructor's transitionInfo object, but
       * it is also possible (but highly NOT recommended) to change this
       * dynamically.
       */
      autoActionsBeforeOntransition: {
        init: function init(fsm, event) {},
        transform: "__transformAutoActionsBeforeOntransition"
      },

      /**
       * Automatic actions to take immediately after calling the transition's
       * ontransition function.  This is documented in the constructor, and is
       * typically provided through the constructor's transitionInfo object, but
       * it is also possible (but highly NOT recommended) to change this
       * dynamically.
       */
      autoActionsAfterOntransition: {
        init: function init(fsm, event) {},
        transform: "__transformAutoActionsAfterOntransition"
      },

      /**
       * The function run when the transition is accepted.  This is documented
       * in the constructor, and is typically provided through the constructor's
       * transitionInfo object, but it is also possible (but highly NOT
       * recommended) to change this dynamically.
       */
      ontransition: {
        init: function init(fsm, event) {},
        transform: "__transformOntransition"
      }
    },
    members: {
      /**
       * Validate the predicate. Converts all incoming values to functions.
       *
       * @param value {var} incoming value
       * @return {Function} predicate function
       */
      __transformPredicate: function __transformPredicate(value) {
        // Validate the predicate.  Convert all valid types to function.
        switch (typeof value) {
          case "undefined":
            // No predicate means predicate passes
            return function (fsm, event) {
              return true;
            };

          case "boolean":
            // Convert boolean predicate to a function which returns that value
            return function (fsm, event) {
              return value;
            };

          case "function":
            // Use user-provided function.
            return qx.lang.Function.bind(value, this.getUserData("context"));

          default:
            throw new Error("Invalid transition predicate type: " + typeof value);
        }
      },

      /**
       * Internal transform method
       *
       * @param value {var} Current value
       * @return {Function} the final value
       */
      __transformNextState: function __transformNextState(value) {
        // Validate nextState.  It must be a string or a number.
        switch (typeof value) {
          case "string":
            return value;

          case "number":
            // Ensure that it's one of the possible state-change constants
            switch (value) {
              case qx.util.fsm.FiniteStateMachine.StateChange.CURRENT_STATE:
              case qx.util.fsm.FiniteStateMachine.StateChange.POP_STATE_STACK:
              case qx.util.fsm.FiniteStateMachine.StateChange.TERMINATE:
                return value;

              default:
                throw new Error("Invalid transition nextState value: " + value + ": " + "nextState must be an explicit state name, " + "or one of the Fsm.StateChange constants");
            }

            break;

          default:
            throw new Error("Invalid transition nextState type: " + typeof value);
        }
      },

      /**
       * Internal transform method
       *
       * @param value {var} Current value
       * @return {Function} the final value
       */
      __transformAutoActionsBeforeOntransition: function __transformAutoActionsBeforeOntransition(value) {
        return qx.util.fsm.State._commonTransformAutoActions("autoActionsBeforeOntransition", value, this.getUserData("context"));
      },

      /**
       * Internal transform method
       *
       * @param value {var} Current value
       * @return {Function} the final value
       */
      __transformAutoActionsAfterOntransition: function __transformAutoActionsAfterOntransition(value) {
        return qx.util.fsm.State._commonTransformAutoActions("autoActionsAfterOntransition", value, this.getUserData("context"));
      },

      /**
       * Internal transform method
       *
       * @param value {var} Current value
       * @return {Function} the final value
       */
      __transformOntransition: function __transformOntransition(value) {
        // Validate the ontransition function.  Convert undefined to function.
        switch (typeof value) {
          case "undefined":
            // No provided function just means do nothing.  Use a null
            // function.
            return function (fsm, event) {};

          case "function":
            // Use user-provided function.
            return qx.lang.Function.bind(value, this.getUserData("context"));

          default:
            throw new Error("Invalid ontransition type: " + typeof value);
        }
      },

      /**
       * If given a function, bind it to a specified context.
       *
       * @param f {Function|var}
       *   The (possibly) function to be bound to the specified context.
       *
       * @param context {Object}
       *   The context to bind the function to.
       *
       * @return {Function}
       *   If f was a function, the return value is f wrapped such that it will
       *   be called in the specified context. Otherwise, f is returned
       *   unaltered.
       */
      __bindIfFunction: function __bindIfFunction(f, context) {
        // Is the first parameter a function?
        if (typeof f == "function") {
          // Yup. Bind it to the specified context.
          f = qx.lang.Function.bind(f, context);
        }

        return f;
      }
    }
  });
  qx.util.fsm.Transition.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.util.Function": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.Function", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      testDebounce: function testDebounce() {
        var test = this.stub();
        var debouncedTest = qx.util.Function.debounce(test, 10);
        debouncedTest(true);
        this.assertNotCalled(test);
        debouncedTest(false);
        this.wait(50, function () {
          this.assertCalledOnce(test);
          this.assertCalledWith(test, false);
        }, this);
      },
      testImmediateDebounce: function testImmediateDebounce() {
        var test = this.stub();
        var debouncedTest = qx.util.Function.debounce(test, 10, true);
        debouncedTest(true);
        this.assertCalled(test);
        this.assertCalledWith(test, true);
        debouncedTest(false);
        debouncedTest(true);
        debouncedTest(false);
        this.wait(50, function () {
          this.assertCalledTwice(test);
          this.assertCalledWith(test, false);
        }, this);
      }
    }
  });
  qx.test.util.Function.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "construct": true,
        "require": true
      },
      "qx.util.LibraryManager": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.LibraryManager", {
    extend: qx.dev.unit.TestCase,
    construct: function construct() {
      qx.dev.unit.TestCase.constructor.call(this);
      this.__mgr = qx.util.LibraryManager.getInstance();
      this.libKeys = ["sourceUri", "resourceUri"];
      this.__qxBackup = {};

      for (var key in qx.$$libraries.qx) {
        if (qx.$$libraries.qx.hasOwnProperty(key)) {
          this.__qxBackup[key] = qx.$$libraries.qx[key];
        }
      }
    },
    members: {
      __mgr: null,
      __qxBackup: null,
      libKeys: null,
      testHas: function testHas() {
        this.assert(this.__mgr.has("qx"));
        this.assertFalse(this.__mgr.has("foo"));
      },
      testGet: function testGet() {
        for (var i = 0, l = this.libKeys.length; i < l; i++) {
          var key = this.libKeys[i];
          this.assertEquals(qx.$$libraries.qx[key], this.__mgr.get("qx", key));
        }
      },
      testSet: function testSet() {
        for (var i = 0, l = this.libKeys.length; i < l; i++) {
          var key = this.libKeys[i];

          this.__mgr.set("qx", key, "foo");

          this.assertEquals("foo", qx.$$libraries.qx[key]);
        }
      },
      tearDownTestSet: function tearDownTestSet() {
        for (var key in this.__qxBackup) {
          qx.$$libraries.qx[key] = this.__qxBackup[key];
        }
      }
    }
  });
  qx.test.util.LibraryManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.format.NumberFormat": {},
      "qx.locale.Manager": {},
      "qx.ui.form.Spinner": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.NumberFormat", {
    extend: qx.dev.unit.TestCase,
    members: {
      __nf: null,
      __oldLocale: null,
      setUp: function setUp() {
        this.assertNotUndefined(qx.util.format.NumberFormat);
        this.__oldLocale = qx.locale.Manager.getInstance().getLocale();
        qx.locale.Manager.getInstance().setLocale("de_DE");
        this.__nf = new qx.util.format.NumberFormat();
      },
      tearDown: function tearDown() {
        this.__nf.dispose();

        qx.locale.Manager.getInstance().setLocale(this.__oldLocale);
      },
      testNumberFormatConstructor: function testNumberFormatConstructor() {
        var wrongArgs = [null, undefined, NaN, Infinity, 1, {}, [], true],
            correctArgs = ["de_DE"],
            nf,
            i,
            len;

        try {
          nf = new qx.util.format.NumberFormat();
        } catch (e) {
          this.fail("Failed on an empty arguments list");
        }

        try {
          nf.dispose();
        } catch (e) {}

        try {
          nf = new qx.util.format.NumberFormat("de_DE", true);
          this.fail("Did not fail on wrong arguments number");
        } catch (e) {}

        try {
          nf.dispose();
        } catch (e) {}

        for (i = 0, len = wrongArgs.length; i < len; i += 1) {
          try {
            nf = new qx.util.format.NumberFormat(wrongArgs[i]);
            this.fail("A wrong argument did not raise an error: " + wrongArgs[i]);
          } catch (e) {}

          try {
            nf.dispose();
          } catch (e) {}
        }

        for (i = 0, len = correctArgs.length; i < len; i += 1) {
          try {
            nf = new qx.util.format.NumberFormat(correctArgs[i]);
          } catch (e) {
            this.fail("A correct argument did raise an error: " + correctArgs[i]);
          }

          try {
            nf.dispose();
          } catch (e) {}
        }
      },
      testNumberFormat: function testNumberFormat() {
        var nf = this.__nf; // this failed due to a rounding error

        this.assertEquals("1.000.000", nf.format(1000000));
        this.assertEquals("-1.000.000", nf.format(-1000000));
        this.assertEquals("-1.000.000", nf.format(-1000000));
        this.assertEquals("0", nf.format(0));
        this.assertEquals("0", nf.format(-0));
        this.assertEquals("12,12", nf.format(12.12));
        var ninfinity = -1 / 0;
        this.assertEquals("-Infinity", nf.format(ninfinity));
        var infinity = Infinity;
        this.assertEquals("Infinity", nf.format(infinity));
        var nan = Math.sqrt(-1);
        this.assertEquals("NaN", nf.format(nan));
      },
      testNumberParse: function testNumberParse() {
        var nf = this.__nf;
        var goodNumbers = {
          "1000": 1000,
          "-0,02": -0.02,
          "0,02": 0.02,
          ",02": 0.02,
          "-,02": -0.02,
          "+,02": 0.02,
          "-1.111.111,2": -1111111.2,
          "-1.000.000": -1000000,
          "+1.000,12": 1000.12
        };

        for (var number in goodNumbers) {
          this.assertEquals(nf.parse(number), goodNumbers[number]);
        }

        var badNumberStrings = ["2hastalavista", "2.3.4.5.6", "12.10,10", "10,1,12"];
        var badNumberStr;

        for (var i = 0; i < badNumberStrings.length; i++) {
          badNumberStr = badNumberStrings[i];
          this.assertException(function () {
            nf.format(nf.parse(badNumberStr));
          }, Error, "does not match the number format", "testing if parsing fails on string '" + badNumberStr + "'");
        }
      },
      testLocaleSwitch: function testLocaleSwitch() {
        var nf = this.__nf;
        nf.setMinimumFractionDigits(0);
        nf.setMaximumFractionDigits(2);
        var numberStr = "0.5";
        this.assertException(function () {
          nf.parse(numberStr);
        }, Error, "does not match the number format", "testing if parsing fails on string '" + numberStr + "'");
        qx.locale.Manager.getInstance().setLocale("en_US");
        this.assertEquals(0.5, nf.parse("0.5"), "parsing failed after locale change");
      },
      testNumberFormatChange: function testNumberFormatChange() {
        var nf = this.__nf;
        nf.setPostfix(" %");
        var numberStr = "5 Percent";
        this.assertException(function () {
          nf.parse(numberStr);
        }, Error, "does not match the number format", "testing if parsing fails on string '" + numberStr + "'");
        nf.setPostfix(" Percent");
        this.assertEquals(5, nf.parse(numberStr), "parsing failed after number format change");
      },
      testParseWithPrefixOrPostfix: function testParseWithPrefixOrPostfix() {
        var spinner = new qx.ui.form.Spinner();
        var prefix = "$ ";
        var postfix = " €";
        var numberFormat = new qx.util.format.NumberFormat("de").set({
          maximumFractionDigits: 2,
          minimumFractionDigits: 2,
          prefix: prefix,
          postfix: postfix
        });
        spinner.setNumberFormat(numberFormat);
        spinner.getChildControl("textfield").setValue("$ 1,23 €");
        this.assertEquals(prefix + "1,23" + postfix, spinner.getChildControl("textfield").getValue());
        spinner.destroy();
        numberFormat.dispose();
      }
    }
  });
  qx.test.util.NumberFormat.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.ui.form.Button": {},
      "qx.util.PropertyUtil": {},
      "qx.core.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.propA, qx.test.propB)
   */
  qx.Class.define("qx.test.util.PropertyUtil", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      setUp: function setUp() {
        this.button = new qx.ui.form.Button();
        this.getRoot().add(this.button);
        this.flush();
      },
      tearDown: function tearDown() {
        qx.test.util.PropertyUtil.prototype.tearDown.base.call(this);
        this.button.destroy();
      },
      testGetUserValue: function testGetUserValue() {
        var Prop = qx.util.PropertyUtil;
        this.assertUndefined(Prop.getUserValue(this.button, "label"));
        this.button.setLabel("juhu");
        this.assertEquals("juhu", Prop.getUserValue(this.button, "label")); // center has a themed value

        this.assertUndefined(Prop.getUserValue(this.button, "center"));
      },
      testGetThemeValue: function testGetThemeValue() {
        var Prop = qx.util.PropertyUtil;
        this.assertUndefined(Prop.getThemeValue(this.button, "content"));
        this.assertEquals(true, Prop.getThemeValue(this.button, "center"));
      },
      testGetInitValue: function testGetInitValue() {
        var Prop = qx.util.PropertyUtil;
        this.assertUndefined(Prop.getInitValue(this.button, "content"));
        this.assertEquals(false, Prop.getInitValue(this.button, "rich"));
      },
      testSetThemed: function testSetThemed() {
        var Prop = qx.util.PropertyUtil;
        this.assertNull(this.button.getIcon());
        Prop.setThemed(this.button, "icon", "right.png");
        this.assertEquals("right.png", this.button.getIcon());
        this.assertEquals("right.png", Prop.getThemeValue(this.button, "icon"));
        Prop.resetThemed(this.button, "icon");
        this.assertNull(this.button.getIcon());
        this.assertUndefined(Prop.getThemeValue(this.button, "icon"));
      },
      testGetProperties: function testGetProperties() {
        qx.Class.define("qx.test.propA", {
          extend: qx.core.Object,
          properties: {
            a: {}
          }
        });
        qx.Class.define("qx.test.propB", {
          extend: qx.test.propA,
          properties: {
            b: {}
          }
        }); // check getProperties

        this.assertKeyInMap("a", qx.util.PropertyUtil.getProperties(qx.test.propA));
        this.assertKeyInMap("b", qx.util.PropertyUtil.getProperties(qx.test.propB)); // check getAllProperties

        this.assertKeyInMap("a", qx.util.PropertyUtil.getAllProperties(qx.test.propB));
        this.assertKeyInMap("b", qx.util.PropertyUtil.getAllProperties(qx.test.propB));
        delete qx.test.propB;
        delete qx.test.propA;
      }
    }
  });
  qx.test.util.PropertyUtil.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.Request": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.Request", {
    extend: qx.dev.unit.TestCase,
    members: {
      "test: isCrossDomain() returns true with cross-domain URL": function testIsCrossDomainReturnsTrueWithCrossDomainURL() {
        var location = window.location,
            origin = location.protocol + "//" + location.host,
            isCrossDomain = qx.util.Request.isCrossDomain;
        this.assertTrue(isCrossDomain("http://cross.domain"), "cross");
        this.assertTrue(isCrossDomain(location.protocol + "//" + location.hostname + ":123456"), "port");
        this.assertTrue(isCrossDomain("foobar://" + location.host), "protocol");
      },
      "test: isCrossDomain() returns false with same-origin URL": function testIsCrossDomainReturnsFalseWithSameOriginURL() {
        var location = window.location,
            origin = location.protocol + "//" + location.host,
            isCrossDomain = qx.util.Request.isCrossDomain;
        this.assertFalse(isCrossDomain(origin));
        this.assertFalse(isCrossDomain("data.json"), "simple url");
        this.assertFalse(isCrossDomain("/data.json"), "absolute url");
        this.assertFalse(isCrossDomain("../data.json"), "relative url");
        this.assertFalse(isCrossDomain("../foo-bar/meep.in/data.json"), "strange url");
      },
      "test: isSuccessful() returns true with successful HTTP status": function testIsSuccessfulReturnsTrueWithSuccessfulHTTPStatus() {
        var isSuccessful = qx.util.Request.isSuccessful;
        this.assertTrue(isSuccessful(200));
        this.assertTrue(isSuccessful(304));
        this.assertFalse(isSuccessful(404));
        this.assertFalse(isSuccessful(500));
      },
      "test: isMethod() returns true if HTTP method is known": function testIsMethodReturnsTrueIfHTTPMethodIsKnown() {
        var isMethod = qx.util.Request.isMethod;
        this.assertTrue(isMethod("GET"));
        this.assertTrue(isMethod("POST"));
        this.assertFalse(isMethod(1));
        this.assertFalse(isMethod(null));
        this.assertFalse(isMethod(undefined));
        this.assertFalse(isMethod([]));
        this.assertFalse(isMethod({}));
      },
      "test: methodAllowsRequestBody() returns false when GET": function testMethodAllowsRequestBodyReturnsFalseWhenGET() {
        this.assertFalse(qx.util.Request.methodAllowsRequestBody("GET"));
      },
      "test: methodAllowsRequestBody() returns true when POST": function testMethodAllowsRequestBodyReturnsTrueWhenPOST() {
        this.assertTrue(qx.util.Request.methodAllowsRequestBody("POST"));
      }
    }
  });
  qx.test.util.Request.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.ResourceManager": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Transport": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "io.ssl": {
          "className": "qx.bom.client.Transport"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.ResourceManager", {
    extend: qx.dev.unit.TestCase,
    members: {
      testHasResource: function testHasResource() {
        var ResourceManager = qx.util.ResourceManager.getInstance();
        this.assertTrue(ResourceManager.has("qx/static/blank.gif"));
      },
      testGetData: function testGetData() {
        var resourceData = [1, 1, "gif", "qx"];
        var ResourceManager = qx.util.ResourceManager.getInstance();
        this.assertArrayEquals(ResourceManager.getData("qx/static/blank.gif"), resourceData, "Resource data not identical");
      },
      testGetImageWidth: function testGetImageWidth() {
        var ResourceManager = qx.util.ResourceManager.getInstance();
        this.assertEquals(ResourceManager.getImageWidth("qx/static/blank.gif"), 1);
      },
      testGetImageHeight: function testGetImageHeight() {
        var ResourceManager = qx.util.ResourceManager.getInstance();
        this.assertEquals(ResourceManager.getImageWidth("qx/static/blank.gif"), 1);
      },
      testGetImageFormat: function testGetImageFormat() {
        var ResourceManager = qx.util.ResourceManager.getInstance();
        this.assertEquals(ResourceManager.getImageFormat("qx/static/blank.gif"), "gif");
        this.assertEquals(ResourceManager.getImageFormat("@FontAwesome/heart"), "font");
      },
      testIsFontUri: function testIsFontUri() {
        var ResourceManager = qx.util.ResourceManager.getInstance();
        this.assertTrue(ResourceManager.isFontUri("@FontAwesome/heart"));
        this.assertFalse(ResourceManager.isFontUri("qx/static/blank.gif"));
        this.assertFalse(ResourceManager.isFontUri(undefined));
      },
      testIsClippedImage: function testIsClippedImage() {
        var ResourceManager = qx.util.ResourceManager.getInstance();
        this.assertFalse(ResourceManager.getCombinedFormat("qx/static/blank.gif") != "");
      },
      testToUri: function testToUri() {
        var ResourceManager = qx.util.ResourceManager.getInstance();
        var resourceUri = qx.$$libraries["qx"].resourceUri + "/" + "qx/static/blank.gif";

        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("io.ssl")) {
          var href = window.location.href;
          resourceUri = href.substring(0, href.lastIndexOf("/") + 1) + resourceUri;
        }

        this.assertEquals(resourceUri, ResourceManager.toUri("qx/static/blank.gif"));
      }
    }
  });
  qx.test.util.ResourceManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.ResponseParser": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.ResponseParser", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.responseParser = new qx.util.ResponseParser();
      },
      tearDown: function tearDown() {
        this.responseParser = null;
      },
      __assertParser: function __assertParser(contentType, parser) {
        var msg = "Content type '" + contentType + "' handled incorrectly";
        this.assertEquals(parser, this.responseParser._getParser(contentType), msg);
      },
      "test: getParser() returns undefined for unknown": function testGetParserReturnsUndefinedForUnknown() {
        this.__assertParser("text/html", undefined);

        this.__assertParser("application/pdf", undefined);
      },
      "test: getParser() returns undefined for malformed": function testGetParserReturnsUndefinedForMalformed() {
        this.__assertParser("", undefined);

        this.__assertParser("json", undefined);

        this.__assertParser("text/foo+json", undefined);

        this.__assertParser("application/foo+jsonish", undefined);

        this.__assertParser("application/foo+xmlish", undefined);
      },
      "test: getParser() detects json": function testGetParserDetectsJson() {
        var json = qx.util.ResponseParser.PARSER.json;

        this.__assertParser("application/json", json);

        this.__assertParser("application/vnd.affe+json", json);

        this.__assertParser("application/prs.affe+json", json);

        this.__assertParser("application/vnd.oneandone.onlineoffice.email+json", json);
      },
      "test: getParser() detects xml": function testGetParserDetectsXml() {
        var xml = qx.util.ResponseParser.PARSER.xml;

        this.__assertParser("application/xml", xml);

        this.__assertParser("application/vnd.oneandone.domains.domain+xml", xml);

        this.__assertParser("text/xml"); // Deprecated

      },
      "test: getParser() detects deprecated xml": function testGetParserDetectsDeprecatedXml() {
        var xml = qx.util.ResponseParser.PARSER.xml;

        this.__assertParser("text/xml");
      },
      "test: getParser() handles character set": function testGetParserHandlesCharacterSet() {
        var json = qx.util.ResponseParser.PARSER.json;

        this.__assertParser("application/json; charset=utf-8", json);
      },
      "test: setParser() function": function testSetParserFunction() {
        var customParser = function customParser() {};

        this.responseParser.setParser(customParser);
        this.assertEquals(customParser, this.responseParser._getParser());
      },
      "test: setParser() symbolically": function testSetParserSymbolically() {
        this.responseParser.setParser("json");
        this.assertFunction(this.responseParser._getParser());
      },
      "test: parse() not parse empty response": function testParseNotParseEmptyResponse() {
        var expectedResponse = "",
            parsedResponse = this.responseParser.parse("", "application/json");
        this.assertEquals(expectedResponse, parsedResponse);
      },
      "test: parse() not parse unknown response": function testParseNotParseUnknownResponse() {
        this.assertNull(this.responseParser._getParser("application/idontexist"));
      },
      // JSON
      "test: parse() json response": function testParseJsonResponse() {
        var json = '{"animals": ["monkey", "mouse"]}',
            expectedResponse = qx.util.ResponseParser.PARSER.json.call(this, json),
            parsedResponse = this.responseParser.parse(json, "application/json");
        this.assertEquals(expectedResponse.animals[0], parsedResponse.animals[0]);
      },
      // XML
      "test: parse() xml response": function testParseXmlResponse() {
        var xml = "<animals><monkey/><mouse/></animals>",
            expectedResponse = qx.util.ResponseParser.PARSER.xml.call(this, xml),
            parsedResponse = this.responseParser.parse(xml, "application/xml");
        this.assertEquals(expectedResponse.documentElement.nodeName, parsedResponse.documentElement.nodeName);
      },
      "test: parse() arbitrary xml response": function testParseArbitraryXmlResponse() {
        var xml = "<animals><monkey/><mouse/></animals>",
            expectedResponse = qx.util.ResponseParser.PARSER.xml.call(this, xml),
            parsedResponse = this.responseParser.parse(xml, "animal/affe+xml");
        this.assertEquals(expectedResponse.documentElement.nodeName, parsedResponse.documentElement.nodeName);
      }
    }
  });
  qx.test.util.ResponseParser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.RingBuffer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Carsten Lergenmueller (carstenl)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.RingBuffer", {
    extend: qx.dev.unit.TestCase,
    members: {
      testAdd: function testAdd() {
        var max = 3;
        var buf = new qx.util.RingBuffer(max);
        buf.addEntry(1);
        this.assertEquals(1, buf.getAllEntries().length);
        buf.addEntry(2);
        this.assertEquals(2, buf.getAllEntries().length);
        buf.addEntry(3);
        this.assertEquals(3, buf.getAllEntries().length);
        buf.addEntry(4);
        var allEntries = buf.getAllEntries();
        this.assertEquals(3, allEntries.length);
        this.assertEquals(allEntries[0], 2);
        this.assertEquals(allEntries[1], 3);
        this.assertEquals(allEntries[2], 4);
      },
      testAddMany: function testAddMany() {
        var max = 3;
        var buf = new qx.util.RingBuffer(max);

        for (var i = 0; i <= 1003; i++) {
          buf.addEntry(i);
        }

        var allEntries = buf.getAllEntries();
        this.assertEquals(3, allEntries.length);
        this.assertEquals(allEntries[0], 1001);
        this.assertEquals(allEntries[1], 1002);
        this.assertEquals(allEntries[2], 1003);
      },
      testGet: function testGet() {
        var max = 7;
        var buf = new qx.util.RingBuffer(max);
        buf.addEntry(1);
        buf.addEntry(2);
        buf.addEntry(3);
        buf.addEntry(5);
        buf.addEntry(6);
        buf.addEntry(7);
        buf.addEntry(8);
        buf.addEntry(9);
        buf.addEntry(10);
        var entries = buf.getEntries(4);
        this.assertEquals(4, entries.length);
        this.assertEquals(entries[0], 7);
        this.assertEquals(entries[1], 8);
        this.assertEquals(entries[2], 9);
        this.assertEquals(entries[3], 10);
      },
      testMark: function testMark() {
        var max = 3;
        var buf = new qx.util.RingBuffer(max);
        buf.addEntry(1);
        buf.addEntry(2);
        buf.mark();
        buf.addEntry(3);
        buf.addEntry(4);
        var entriesSinceMark = buf.getEntries(9999, true);
        this.assertEquals(2, entriesSinceMark.length);
        this.assertEquals(entriesSinceMark[0], 3);
        this.assertEquals(entriesSinceMark[1], 4);
      },
      testClear: function testClear() {
        var max = 3;
        var buf = new qx.util.RingBuffer(max);
        buf.addEntry(1);
        buf.addEntry(2);
        buf.addEntry(3);
        buf.addEntry(4);
        this.assertEquals(3, buf.getAllEntries().length);
        buf.clear();
        this.assertEquals(0, buf.getAllEntries().length);
      },
      testDataTypes: function testDataTypes() {
        var max = 6;
        var buf = new qx.util.RingBuffer(max);
        buf.addEntry(1);
        buf.addEntry(2);
        buf.addEntry(3);
        buf.addEntry(null);
        buf.addEntry(buf);
        buf.addEntry("Some string");
        buf.addEntry({
          "some": "map"
        });
        buf.addEntry(["Some array"]);
        buf.addEntry(function () {});
        var allEntries = buf.getAllEntries();
        this.assertEquals(6, allEntries.length);
        this.assertEquals(allEntries[0], null);
        this.assertEquals(allEntries[1], buf);
        this.assertEquals(allEntries[2], "Some string");
        this.assertEquals(allEntries[3].some, "map");
        this.assertEquals(allEntries[4][0], "Some array");
        this.assertEquals(typeof allEntries[5], "function");
      }
    }
  });
  qx.test.util.RingBuffer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.Serializer": {
        "construct": true
      },
      "qx.core.Object": {},
      "qx.ui.form.ListItem": {},
      "qx.data.Array": {},
      "qx.ui.core.Widget": {},
      "qx.data.IListData": {},
      "qx.data.MBinding": {},
      "qx.data.marshal.Json": {},
      "qx.lang.Json": {},
      "qx.util.format.DateFormat": {},
      "qx.locale.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.SerializerModel)
   * @ignore(qx.test.SerializerModelEnc)
   */
  qx.Class.define("qx.test.util.Serializer", {
    extend: qx.dev.unit.TestCase,
    construct: function construct() {
      this.__s = qx.util.Serializer;
      qx.Class.define("qx.test.SerializerModel", {
        extend: qx.core.Object,
        properties: {
          data1: {
            nullable: true
          },
          data2: {
            nullable: true
          },
          data3: {
            nullable: true
          }
        }
      });
    },
    members: {
      __model: null,
      __s: null,
      setUp: function setUp() {
        this.__model = new qx.test.SerializerModel();
      },
      tearDown: function tearDown() {
        this.__model.dispose();
      },
      testUrlString: function testUrlString() {
        this.__model.setData1("a");

        this.__model.setData2("b");

        this.__model.setData3("c");

        this.assertEquals("data1=a&data2=b&data3=c", this.__s.toUriParameter(this.__model));

        this.__model.setData1("A");

        this.__model.setData2("B");

        this.__model.setData3("C");

        this.assertEquals("data1=A&data2=B&data3=C", this.__s.toUriParameter(this.__model));

        this.__model.setData1("1");

        this.__model.setData2("11");

        this.__model.setData3("111");

        this.assertEquals("data1=1&data2=11&data3=111", this.__s.toUriParameter(this.__model));
      },
      testUrlStringEncoded: function testUrlStringEncoded() {
        this.__model.setData1("ä");

        this.__model.setData2("ö");

        this.__model.setData3("ü");

        this.assertEquals("data1=%C3%A4&data2=%C3%B6&data3=%C3%BC", this.__s.toUriParameter(this.__model));

        this.__model.setData1("–");

        this.__model.setData2(" ");

        this.__model.setData3("ß");

        this.assertEquals("data1=%E2%80%93&data2=%20&data3=%C3%9F", this.__s.toUriParameter(this.__model));
      },
      testUrlBoolean: function testUrlBoolean() {
        this.__model.setData1(true);

        this.__model.setData2(false);

        this.__model.setData3(null);

        this.assertEquals("data1=true&data2=false&data3=null", this.__s.toUriParameter(this.__model));
      },
      testUrlNumber: function testUrlNumber() {
        this.__model.setData1(10);

        this.__model.setData2(-15.3443);

        this.__model.setData3(Number.NaN);

        this.assertEquals("data1=10&data2=-15.3443&data3=NaN", this.__s.toUriParameter(this.__model));
      },
      testUrlKeyEncoded: function testUrlKeyEncoded() {
        qx.Class.define("qx.test.SerializerModelEnc", {
          extend: qx.core.Object,
          properties: {
            "äüö": {
              init: "ÄÜÖ"
            }
          }
        });
        var model = new qx.test.SerializerModelEnc();
        this.assertEquals("%C3%A4%C3%BC%C3%B6=%C3%84%C3%9C%C3%96", this.__s.toUriParameter(model));
        model.dispose();
      },
      testUrlQxSerializer: function testUrlQxSerializer() {
        var qxSerializer = function qxSerializer(object) {
          return object.getLabel();
        };

        var item = new qx.ui.form.ListItem("a");

        this.__model.setData1(item);

        this.__model.setData2("b");

        this.__model.setData3("c");

        this.assertEquals("data1=a&data2=b&data3=c", this.__s.toUriParameter(this.__model, qxSerializer));
        item.dispose();
      },
      testUrlDataArray: function testUrlDataArray() {
        var a1 = new qx.data.Array(["a"]);
        var a2 = new qx.data.Array(["a", "b"]);
        var a3 = new qx.data.Array(["a", "b", "c"]);

        this.__model.setData1(a1);

        this.__model.setData2(a2);

        this.__model.setData3(a3);

        this.assertEquals("data1=a&data2=a&data2=b&data3=a&data3=b&data3=c", this.__s.toUriParameter(this.__model)); // get rid of the objects

        a1.dispose();
        a2.dispose();
        a3.dispose();
      },
      testUrlDataArrayNative: function testUrlDataArrayNative() {
        var a1 = ["a"];
        var a2 = ["a", "b"];
        var a3 = ["a", "b", "c"];

        this.__model.setData1(a1);

        this.__model.setData2(a2);

        this.__model.setData3(a3);

        this.assertEquals("data1=a&data2=a&data2=b&data3=a&data3=b&data3=c", this.__s.toUriParameter(this.__model));
      },
      testUrlInherited: function testUrlInherited() {
        var model = new qx.ui.core.Widget();

        var data = this.__s.toUriParameter(model); // property included in widget


        this.assertTrue(data.indexOf("appearance") != -1); // property included in LayoutItem (Superclass)

        this.assertTrue(data.indexOf("alignY") != -1);
        model.dispose();
      },
      testUrlQxClass: function testUrlQxClass() {
        this.__model.setData1(qx.core.Object);

        this.__model.setData2(qx.data.IListData);

        this.__model.setData3(qx.data.MBinding);

        this.assertEquals("data1=qx.core.Object&data2=qx.data.IListData&data3=qx.data.MBinding", this.__s.toUriParameter(this.__model));
      },
      testJsonFlat: function testJsonFlat() {
        this.__model.setData1("a");

        this.__model.setData2(10.456);

        this.__model.setData3(true);

        this.assertEquals('{"data1":"a","data2":10.456,"data3":true}', this.__s.toJson(this.__model));
      },
      testJsonExp: function testJsonExp() {
        var date = new Date(1000);

        this.__model.setData1(date);

        this.__model.setData2(/[0]/);

        this.__model.setData3(45e12);

        this.assertEquals('{"data1":"' + date + '","data2":"/[0]/","data3":45000000000000}', this.__s.toJson(this.__model));
      },
      testJsonDeep2: function testJsonDeep2() {
        var model = new qx.test.SerializerModel();
        model.setData1("a");
        model.setData2(11);
        model.setData3(false);

        this.__model.setData1(model);

        this.__model.setData3(null);

        this.assertEquals('{"data1":{"data1":"a","data2":11,"data3":false},"data2":null,"data3":null}', this.__s.toJson(this.__model));
        model.dispose();
      },
      testJsonArray: function testJsonArray() {
        this.__model.setData1([12, 1]);

        this.__model.setData2(["a", "b"]);

        this.__model.setData3([true, false]);

        this.assertEquals('{"data1":[12,1],"data2":["a","b"],"data3":[true,false]}', this.__s.toJson(this.__model));
      },
      testJsonDataArray: function testJsonDataArray() {
        this.__model.setData1(new qx.data.Array([12, 1]));

        this.__model.setData2(new qx.data.Array(["a", "b"]));

        this.__model.setData3(new qx.data.Array([true, false]));

        this.assertEquals('{"data1":[12,1],"data2":["a","b"],"data3":[true,false]}', this.__s.toJson(this.__model));

        this.__model.getData1().dispose();

        this.__model.getData2().dispose();

        this.__model.getData3().dispose();
      },
      testJsonBig: function testJsonBig() {
        var model = new qx.ui.core.Widget();

        this.__s.toJson(model);

        model.dispose();
      },
      testJsonInherited: function testJsonInherited() {
        var model = new qx.ui.core.Widget();

        var data = this.__s.toJson(model); // property included in widget


        this.assertTrue(data.indexOf("appearance") != -1); // property included in LayoutItem (Superclass)

        this.assertTrue(data.indexOf("alignY") != -1);
        model.dispose();
      },
      testJsonEmpty: function testJsonEmpty() {
        this.__model.setData1(new qx.data.Array());

        this.__model.setData2([]);

        this.__model.setData3({});

        this.assertEquals('{"data1":[],"data2":[],"data3":{}}', this.__s.toJson(this.__model));

        this.__model.getData1().dispose();
      },
      testJsonEscape: function testJsonEscape() {
        this.__model.setData1("''");

        this.__model.setData2('""');

        this.__model.setData3("\b\t\n\f\r\\");

        this.assertEquals('{"data1":"\'\'","data2":"\\"\\"","data3":"\\b\\t\\n\\f\\r\\\\"}', this.__s.toJson(this.__model));
      },
      testJsonQxSerializer: function testJsonQxSerializer() {
        var qxSerializer = function qxSerializer(object) {
          if (object instanceof qx.ui.form.ListItem) {
            return object.getLabel();
          }
        };

        var item = new qx.ui.form.ListItem("a");

        this.__model.setData1(item);

        this.__model.setData2(10.456);

        this.__model.setData3(true);

        this.assertEquals('{"data1":"a","data2":10.456,"data3":true}', this.__s.toJson(this.__model, qxSerializer));
        item.dispose();
      },
      testJsonWithMarshaler: function testJsonWithMarshaler() {
        this.__model.setData1("a");

        this.__model.setData2(["b"]);

        this.__model.setData3("c");

        var json = this.__s.toJson(this.__model);

        var model = qx.data.marshal.Json.createModel(qx.lang.Json.parse(json));
        this.assertEquals(this.__model.getData1(), model.getData1());
        this.assertEquals(this.__model.getData2()[0], model.getData2().getItem(0));
        this.assertEquals(this.__model.getData3(), model.getData3());
        model.dispose();
      },
      testJsonLateObjectSet: function testJsonLateObjectSet() {
        var data = {
          foo: "foo",
          bar: "bar",
          goo: {}
        };
        var model = qx.data.marshal.Json.createModel(data);
        model.setGoo({
          mi: "moo",
          la: "lili"
        });
        this.assertEquals('{"foo":"foo","bar":"bar","goo":{"mi":"moo","la":"lili"}}', qx.util.Serializer.toJson(model));
        model.dispose();
      },
      testJsonQxClass: function testJsonQxClass() {
        this.__model.setData1(qx.core.Object);

        this.__model.setData2(qx.data.IListData);

        this.__model.setData3(qx.data.MBinding);

        this.assertEquals('{"data1":"qx.core.Object","data2":"qx.data.IListData","data3":"qx.data.MBinding"}', this.__s.toJson(this.__model));
      },
      //
      // toNativeObject tests
      //
      testNativeObjectFlat: function testNativeObjectFlat() {
        this.__model.setData1("a");

        this.__model.setData2(10.456);

        this.__model.setData3(true);

        this.assertJsonEquals({
          "data1": "a",
          "data2": 10.456,
          "data3": true
        }, this.__s.toNativeObject(this.__model));
      },
      testNativeObjectExp: function testNativeObjectExp() {
        var date = new Date();

        this.__model.setData1(date);

        this.__model.setData2(/[0]/);

        this.__model.setData3(45e12);

        this.assertJsonEquals({
          "data1": date,
          "data2": /[0]/,
          "data3": 45e12
        }, this.__s.toNativeObject(this.__model));
      },
      testNativeObjectDeep2: function testNativeObjectDeep2() {
        var model = new qx.test.SerializerModel();
        model.setData1("a");
        model.setData2(11);
        model.setData3(false);

        this.__model.setData1(model);

        this.__model.setData3(null);

        this.assertJsonEquals({
          "data1": {
            "data1": "a",
            "data2": 11,
            "data3": false
          },
          "data2": null,
          "data3": null
        }, this.__s.toNativeObject(this.__model));
        model.dispose();
      },
      testNativeObjectArray: function testNativeObjectArray() {
        this.__model.setData1([12, 1]);

        this.__model.setData2(["a", "b"]);

        this.__model.setData3([true, false]);

        this.assertJsonEquals({
          "data1": [12, 1],
          "data2": ["a", "b"],
          "data3": [true, false]
        }, this.__s.toNativeObject(this.__model));
      },
      testNativeObjectDataArray: function testNativeObjectDataArray() {
        this.__model.setData1(new qx.data.Array([12, 1]));

        this.__model.setData2(new qx.data.Array(["a", "b"]));

        this.__model.setData3(new qx.data.Array([true, false]));

        this.assertJsonEquals({
          "data1": [12, 1],
          "data2": ["a", "b"],
          "data3": [true, false]
        }, this.__s.toNativeObject(this.__model));

        this.__model.getData1().dispose();

        this.__model.getData2().dispose();

        this.__model.getData3().dispose();
      },
      testNativeObjectBig: function testNativeObjectBig() {
        var model = new qx.ui.core.Widget();

        this.__s.toNativeObject(model);

        model.dispose();
      },
      testNativeObjectEmpty: function testNativeObjectEmpty() {
        this.__model.setData1(new qx.data.Array());

        this.__model.setData2([]);

        this.__model.setData3(new qx.core.Object());

        this.assertJsonEquals({
          "data1": [],
          "data2": [],
          "data3": {}
        }, this.__s.toNativeObject(this.__model));

        this.__model.getData1().dispose();

        this.__model.getData3().dispose();
      },
      testNativeObjectEscape: function testNativeObjectEscape() {
        this.__model.setData1("''");

        this.__model.setData2('""');

        this.__model.setData3("\b\t\n\f\r\\");

        this.assertJsonEquals({
          "data1": "''",
          "data2": '""',
          "data3": "\b\t\n\f\r\\"
        }, this.__s.toNativeObject(this.__model));
      },
      testNativeObjectQxSerializer: function testNativeObjectQxSerializer() {
        var qxSerializer = function qxSerializer(object) {
          if (object instanceof qx.ui.form.ListItem) {
            return object.getLabel();
          }
        };

        var item = new qx.ui.form.ListItem("a");

        this.__model.setData1(item);

        this.__model.setData2(10.456);

        this.__model.setData3(true);

        this.assertJsonEquals({
          "data1": "a",
          "data2": 10.456,
          "data3": true
        }, this.__s.toNativeObject(this.__model, qxSerializer));
        item.dispose();
      },
      testNativeObjectQxClass: function testNativeObjectQxClass() {
        this.__model.setData1(qx.core.Object);

        this.__model.setData2(qx.data.IListData);

        this.__model.setData3(qx.data.MBinding);

        this.assertJsonEquals({
          "data1": "qx.core.Object",
          "data2": "qx.data.IListData",
          "data3": "qx.data.MBinding"
        }, this.__s.toNativeObject(this.__model));
      },

      /* ******************************
       * DATE FORMATER
       * **************************** */
      __setUpDateModel: function __setUpDateModel() {
        var formater = new qx.util.format.DateFormat("yyyy-mm-dd", "en");
        var date1 = new Date(0);
        var date2 = new Date(100000);
        var date3 = new Date(25168418651);

        this.__model.setData1(date1);

        this.__model.setData2(date2);

        this.__model.setData3(date3);

        return formater;
      },
      testDateFormaterNative: function testDateFormaterNative() {
        var formater = this.__setUpDateModel();

        this.assertJsonEquals({
          "data1": "1970-00-01",
          "data2": "1970-01-01",
          "data3": "1970-13-19"
        }, this.__s.toNativeObject(this.__model, null, formater));
        formater.dispose();
      },
      testDateFormaterJson: function testDateFormaterJson() {
        var formater = this.__setUpDateModel();

        this.assertEquals('{"data1":"1970-00-01","data2":"1970-01-01","data3":"1970-13-19"}', this.__s.toJson(this.__model, null, formater));
        formater.dispose();
      },
      testDateFormaterUrl: function testDateFormaterUrl() {
        var formater = this.__setUpDateModel();

        this.assertEquals("data1=1970-00-01&data2=1970-01-01&data3=1970-13-19", this.__s.toUriParameter(this.__model, null, formater));
        formater.dispose();
      },

      /* ******************************
       * Localized strings
       * **************************** */
      testJsonLocalizedStrings: function testJsonLocalizedStrings() {
        this.assertEquals('"test affe"', qx.util.Serializer.toJson(qx.locale.Manager.tr("test affe")));
      },
      testNativeLocalizedStrings: function testNativeLocalizedStrings() {
        var ser = qx.util.Serializer.toNativeObject(qx.locale.Manager.tr("test affe"));
        this.assertEquals("test affe", ser); // regular strings should not have a translate method

        this.assertUndefined(ser.translate);
      },
      testUrlLocalizedStrings: function testUrlLocalizedStrings() {
        this.__model.setData1(qx.locale.Manager.tr("test affe"));

        this.assertEquals("data1=test%20affe&data2=null&data3=null", qx.util.Serializer.toUriParameter(this.__model));
      }
    }
  });
  qx.test.util.Serializer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.StringBuilder": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.StringBuilder", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.__sb = new qx.util.StringBuilder();
      },
      testAddGet: function testAddGet() {
        this.__sb.add("1");

        this.__sb.add("2");

        this.assertEquals("12", this.__sb.get());

        this.__sb.add("3");

        this.assertEquals("123", this.__sb.get());
      },
      testSize: function testSize() {
        this.__sb.add("123");

        this.assertEquals(3, this.__sb.size());

        this.__sb.add("4567");

        this.assertEquals(7, this.__sb.size());
      },
      testEmptyClear: function testEmptyClear() {
        this.assertTrue(this.__sb.isEmpty());

        this.__sb.add("123");

        this.assertFalse(this.__sb.isEmpty());

        this.__sb.clear();

        this.assertTrue(this.__sb.isEmpty());
      }
    }
  });
  qx.test.util.StringBuilder.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.StringSplit": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Cross-Browser Split
       http://stevenlevithan.com/demo/split.cfm
  
       Copyright:
         (c) 2006-2007, Steven Levithan <http://stevenlevithan.com>
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         * Steven Levithan
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.StringSplit", {
    extend: qx.dev.unit.TestCase,
    members: {
      /**
       * @lint ignoreDeprecated(eval)
       */
      testSplit: function testSplit() {
        var testCode = [["qx.util.StringSplit.split('')", [""]], ["qx.util.StringSplit.split('', /./)", [""]], ["qx.util.StringSplit.split('', /.?/)", []], ["qx.util.StringSplit.split('', /.??/)", []], ["qx.util.StringSplit.split('ab', /a*/)", ["", "b"]], ["qx.util.StringSplit.split('ab', /a*?/)", ["a", "b"]], ["qx.util.StringSplit.split('ab', /(?:ab)/)", ["", ""]], ["qx.util.StringSplit.split('ab', /(?:ab)*/)", ["", ""]], ["qx.util.StringSplit.split('ab', /(?:ab)*?/)", ["a", "b"]], ["qx.util.StringSplit.split('test', '')", ["t", "e", "s", "t"]], ["qx.util.StringSplit.split('test')", ["test"]], ["qx.util.StringSplit.split('111', 1)", ["", "", "", ""]], ["qx.util.StringSplit.split('test', /(?:)/, 2)", ["t", "e"]], ["qx.util.StringSplit.split('test', /(?:)/, -1)", ["t", "e", "s", "t"]], ["qx.util.StringSplit.split('test', /(?:)/, undefined)", ["t", "e", "s", "t"]], ["qx.util.StringSplit.split('test', /(?:)/, null)", []], ["qx.util.StringSplit.split('test', /(?:)/, NaN)", []], ["qx.util.StringSplit.split('test', /(?:)/, true)", ["t"]], ["qx.util.StringSplit.split('test', /(?:)/, '2')", ["t", "e"]], ["qx.util.StringSplit.split('test', /(?:)/, 'two')", []], ["qx.util.StringSplit.split('a', /-/)", ["a"]], ["qx.util.StringSplit.split('a', /-?/)", ["a"]], ["qx.util.StringSplit.split('a', /-??/)", ["a"]], ["qx.util.StringSplit.split('a', /a/)", ["", ""]], ["qx.util.StringSplit.split('a', /a?/)", ["", ""]], ["qx.util.StringSplit.split('a', /a??/)", ["a"]], ["qx.util.StringSplit.split('ab', /-/)", ["ab"]], ["qx.util.StringSplit.split('ab', /-?/)", ["a", "b"]], ["qx.util.StringSplit.split('ab', /-??/)", ["a", "b"]], ["qx.util.StringSplit.split('a-b', /-/)", ["a", "b"]], ["qx.util.StringSplit.split('a-b', /-?/)", ["a", "b"]], ["qx.util.StringSplit.split('a-b', /-??/)", ["a", "-", "b"]], ["qx.util.StringSplit.split('a--b', /-/)", ["a", "", "b"]], ["qx.util.StringSplit.split('a--b', /-?/)", ["a", "", "b"]], ["qx.util.StringSplit.split('a--b', /-??/)", ["a", "-", "-", "b"]], ["qx.util.StringSplit.split('', /()()/)", []], ["qx.util.StringSplit.split('.', /()()/)", ["."]], ["qx.util.StringSplit.split('.', /(.?)(.?)/)", ["", ".", "", ""]], ["qx.util.StringSplit.split('.', /(.??)(.??)/)", ["."]], ["qx.util.StringSplit.split('.', /(.)?(.)?/)", ["", ".", undefined, ""]], ["qx.util.StringSplit.split('tesst', /(s)*/)", ["t", undefined, "e", "s", "t"]], ["qx.util.StringSplit.split('tesst', /(s)*?/)", ["t", undefined, "e", undefined, "s", undefined, "s", undefined, "t"]], ["qx.util.StringSplit.split('tesst', /(s*)/)", ["t", "", "e", "ss", "t"]], ["qx.util.StringSplit.split('tesst', /(s*?)/)", ["t", "", "e", "", "s", "", "s", "", "t"]], ["qx.util.StringSplit.split('tesst', /(?:s)*/)", ["t", "e", "t"]], ["qx.util.StringSplit.split('tesst', /(?=s+)/)", ["te", "s", "st"]], ["qx.util.StringSplit.split('test', 't')", ["", "es", ""]], ["qx.util.StringSplit.split('test', 'es')", ["t", "t"]], ["qx.util.StringSplit.split('test', /t/)", ["", "es", ""]], ["qx.util.StringSplit.split('test', /es/)", ["t", "t"]], ["qx.util.StringSplit.split('test', /(t)/)", ["", "t", "es", "t", ""]], ["qx.util.StringSplit.split('test', /(es)/)", ["t", "es", "t"]], ["qx.util.StringSplit.split('test', /(t)(e)(s)(t)/)", ["", "t", "e", "s", "t", ""]], ["qx.util.StringSplit.split('.', /(((.((.??)))))/)", ["", ".", ".", ".", "", "", ""]], ["qx.util.StringSplit.split('.', /(((((.??)))))/)", ["."]]];

        for (var i = 0; i < testCode.length; i++) {
          var result = eval(testCode[i][0]);
          this.assertArrayEquals(testCode[i][1], result);
        }

        var ecmaSampleRe = /<(\/)?([^<>]+)>/;
        this.assertArrayEquals(["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""], qx.util.StringSplit.split('A<B>bold</B>and<CODE>coded</CODE>', ecmaSampleRe));
      }
    }
  });
  qx.test.util.StringSplit.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.Uri": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.Uri", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.Uri = qx.util.Uri;
      },
      "test: appendParamsToUrl() with string": function testAppendParamsToUrlWithString() {
        var url = "http://example.com/path",
            params = "affe=true&maus=false",
            expected = "http://example.com/path?affe=true&maus=false",
            result = this.Uri.appendParamsToUrl(url, params);
        this.assertEquals(expected, result);
      },
      testToParameter: function testToParameter() {
        var obj = {
          affe: true,
          maus: false
        };
        var str = qx.util.Uri.toParameter(obj);
        this.assertEquals("affe=true&maus=false", str);
      },
      testToParameterUmlauts: function testToParameterUmlauts() {
        var obj = {
          "äffe": "jøah",
          "maüs": "nö"
        };
        var str = qx.util.Uri.toParameter(obj);
        this.assertEquals("%C3%A4ffe=j%C3%B8ah&ma%C3%BCs=n%C3%B6", str);
      },
      testToParameterSpaces: function testToParameterSpaces() {
        var obj = {
          "a f f e": true
        };
        var str = qx.util.Uri.toParameter(obj);
        this.assertEquals("a%20f%20f%20e=true", str);
      },
      testToParameterSpacesPost: function testToParameterSpacesPost() {
        var obj = {
          "a f  f e": "j a"
        };
        var str = qx.util.Uri.toParameter(obj, true);
        this.assertEquals("a+f++f+e=j+a", str);
      },
      testToParameterArray: function testToParameterArray() {
        var obj = {
          id: [1, 2, 3]
        };
        var str = qx.util.Uri.toParameter(obj);
        this.assertEquals("id=1&id=2&id=3", str);
      },
      "test: appendParamsToUrl() with string when existing query": function testAppendParamsToUrlWithStringWhenExistingQuery() {
        var url = "http://example.com/path?giraffe=true",
            params = "affe=true&maus=false",
            expected = "http://example.com/path?giraffe=true&affe=true&maus=false",
            result = this.Uri.appendParamsToUrl(url, params);
        this.assertEquals(expected, result);
      },
      "test: appendParamsToUrl() with map": function testAppendParamsToUrlWithMap() {
        var url = "http://example.com/path",
            params = {
          affe: true,
          maus: false
        },
            result = this.Uri.appendParamsToUrl(url, params);
        this.assertTrue(/^http.*example.com\/path/.test(result));
        this.assertTrue(/affe=true/.test(result));
        this.assertTrue(/maus=false/.test(result));
      },
      "test: appendParamsToUrl() with undefined": function testAppendParamsToUrlWithUndefined() {
        var url = "http://example.com/path",
            params = undefined,
            result = this.Uri.appendParamsToUrl(url, params);
        this.assertEquals(url, result);
      },
      "test: appendParamsToUrl() with empty map": function testAppendParamsToUrlWithEmptyMap() {
        var url = "http://example.com/path",
            params = {},
            result = this.Uri.appendParamsToUrl(url, params);
        this.assertEquals(url, result);
      },
      "test: parseUri()": function testParseUri() {
        var url = "http://www.example.com:80/foo/bar?affe=true#here",
            result = this.Uri.parseUri(url); // Some integration tests, parseUri is better covered here
        // http://stevenlevithan.com/demo/parseuri/js/

        this.assertEquals("http", result.protocol);
        this.assertEquals("www.example.com", result.host);
        this.assertEquals("80", result.port);
        this.assertEquals("/foo/bar?affe=true#here", result.relative);
        this.assertEquals("here", result.anchor);
      },
      "test: parseUri() with ipv6 loopback address": function testParseUriWithIpv6LoopbackAddress() {
        var url = "http://[::1]:80/foo/bar?affe=true#here",
            result = this.Uri.parseUri(url); // Some integration tests, parseUri is better covered here
        // http://stevenlevithan.com/demo/parseuri/js/

        this.assertEquals("http", result.protocol);
        this.assertEquals("[::1]", result.host);
        this.assertEquals("80", result.port);
        this.assertEquals("/foo/bar?affe=true#here", result.relative);
        this.assertEquals("here", result.anchor);
      },
      "test: parseUri() with ipv6 address": function testParseUriWithIpv6Address() {
        var url = "http://[FE80:0000:0000:0000:0202:B3FF:FE1E:8329]:80/foo/bar?affe=true#here",
            result = this.Uri.parseUri(url); // Some integration tests, parseUri is better covered here
        // http://stevenlevithan.com/demo/parseuri/js/

        this.assertEquals("http", result.protocol);
        this.assertEquals("[FE80:0000:0000:0000:0202:B3FF:FE1E:8329]", result.host);
        this.assertEquals("80", result.port);
        this.assertEquals("/foo/bar?affe=true#here", result.relative);
        this.assertEquals("here", result.anchor);
      },
      "test: parseUri() with at-sign in query": function testParseUriWithAtSignInQuery() {
        var url = "http://www.example.com/foo/bar?separator=@",
            result = this.Uri.parseUri(url);
        this.assertEquals("http", result.protocol);
        this.assertEquals("www.example.com", result.host);
        this.assertEquals("/foo/bar?separator=@", result.relative);
        this.assertEquals("separator=@", result.query);
      },
      "test: parseUri() with user name in domain": function testParseUriWithUserNameInDomain() {
        var url = "http://userid@www.example.com/foo/bar",
            result = this.Uri.parseUri(url);
        this.assertEquals("http", result.protocol);
        this.assertEquals("www.example.com", result.host);
        this.assertEquals("/foo/bar", result.relative);
        this.assertEquals("userid", result.user);
      }
    }
  });
  qx.test.util.Uri.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.Validate": {},
      "qx.core.ValidationError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.Validate", {
    extend: qx.dev.unit.TestCase,
    members: {
      testNumber: function testNumber() {
        //The number is valid if an error isn't raised
        qx.util.Validate.number()(2); //ValidationError raised if not a number

        this.assertException(function () {
          qx.util.Validate.number()("not a number");
        }, qx.core.ValidationError); // ValidationError raised with a custom message

        this.assertException(function () {
          qx.util.Validate.number("Custom Error Message")("not a number");
        }, qx.core.ValidationError, "Custom Error Message");
      },
      testEmail: function testEmail() {
        //The email is valid if an error isn't raised
        qx.util.Validate.email()("an@email.ro"); //ValidationError raised if not an email

        this.assertException(function () {
          qx.util.Validate.email()("not an email");
        }, qx.core.ValidationError); // ValidationError raised with a custom message

        this.assertException(function () {
          qx.util.Validate.email("Custom Error Message")("not an email");
        }, qx.core.ValidationError, "Custom Error Message"); //Valid since new domain extensions

        qx.util.Validate.email()("foo@bar.qooxdoo"); //'+' allowed (gmail aliases)

        qx.util.Validate.email()("foobar+alias@qooxdoo.org");
      },
      testString: function testString() {
        //The string is valid if an error isn't raised
        qx.util.Validate.string()("I'm a string"); //ValidationError raised if not a string

        this.assertException(function () {
          qx.util.Validate.string()(1);
        }, qx.core.ValidationError); // ValidationError raised with a custom message

        this.assertException(function () {
          qx.util.Validate.string("Custom Error Message")(1);
        }, qx.core.ValidationError, "Custom Error Message");
      },
      testUrl: function testUrl() {
        //The url is valid if an error isn't raised
        qx.util.Validate.url()("http://anurl.ro"); //ValidationError raised if not an url

        this.assertException(function () {
          qx.util.Validate.url()("not an url");
        }, qx.core.ValidationError); // ValidationError raised with a custom message

        this.assertException(function () {
          qx.util.Validate.url("Custom Error Message")("not an url");
        }, qx.core.ValidationError, "Custom Error Message");
      },
      testColor: function testColor() {
        //The color value is valid if an error isn't raised
        qx.util.Validate.color()("#667788"); //ValidationError raised if not a color value

        this.assertException(function () {
          qx.util.Validate.color()("not a color value");
        }, qx.core.ValidationError); // ValidationError raised with a custom message

        this.assertException(function () {
          qx.util.Validate.color("Custom Error Message")("not a color value");
        }, qx.core.ValidationError, "Custom Error Message");
      },
      testRange: function testRange() {
        //The value is valid if it's in the range
        qx.util.Validate.range(2, 4)(3); //ValidationError raised if the value isn't in the range

        this.assertException(function () {
          qx.util.Validate.range(2, 4)(5);
        }, qx.core.ValidationError); // ValidationError raised with a custom message

        this.assertException(function () {
          qx.util.Validate.range(2, 4, "Custom Error Message")(5);
        }, qx.core.ValidationError, "Custom Error Message");
      },
      testInArray: function testInArray() {
        //The value is valid if it's in the range
        qx.util.Validate.inArray([2, 3])(3); //ValidationError raised if the value isn't in array

        this.assertException(function () {
          qx.util.Validate.inArray([2, 3])(4);
        }, qx.core.ValidationError); // ValidationError raised with a custom message

        this.assertException(function () {
          qx.util.Validate.inArray([2, 3], "Custom Error Message")(4);
        }, qx.core.ValidationError, "Custom Error Message");
      },
      testRegex: function testRegex() {
        var validator = qx.util.Validate.regExp(/^\dand\d$/);
        validator("1and1"); //ValidationError raised if the value isn't in array

        this.assertException(function () {
          validator("oneandone");
        }, qx.core.ValidationError, /oneandone/g); //ValidationError raised if the value isn't in array

        this.assertException(function () {
          validator("xyz");
        }, qx.core.ValidationError, /xyz/g); // ValidationError raised with a custom message

        this.assertException(function () {
          qx.util.Validate.regExp(/^\dand\d$/, "Custom Error Message")("oneandone");
        }, qx.core.ValidationError, "Custom Error Message");
      }
    }
  });
  qx.test.util.Validate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.placement.BestFitAxis": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.placement.BestFitAxis", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.axis = qx.util.placement.BestFitAxis;
      },
      tearDown: function tearDown() {
        delete this.axis;
      },
      testEnoughSpace: function testEnoughSpace() {
        var size = 50;
        var target = {
          start: 500,
          end: 600
        };
        var offsets = {
          start: 10,
          end: 20
        };
        var areaSize = 1000;
        this.assertEquals(430, this.axis.computeStart(size, target, offsets, areaSize, "edge-start"));
        this.assertEquals(610, this.axis.computeStart(size, target, offsets, areaSize, "edge-end"));
        this.assertEquals(510, this.axis.computeStart(size, target, offsets, areaSize, "align-start"));
        this.assertEquals(535, this.axis.computeStart(size, target, offsets, areaSize, "align-center"));
        this.assertEquals(530, this.axis.computeStart(size, target, offsets, areaSize, "align-end"));
      },
      testNotEnoughSpaceStart: function testNotEnoughSpaceStart() {
        var size = 250;
        var target = {
          start: 30,
          end: 200
        };
        var offsets = {
          start: 10,
          end: 20
        };
        var areaSize = 1000;
        this.assertEquals(0, this.axis.computeStart(size, target, offsets, areaSize, "edge-start"));
        this.assertEquals(210, this.axis.computeStart(size, target, offsets, areaSize, "edge-end"));
        this.assertEquals(40, this.axis.computeStart(size, target, offsets, areaSize, "align-start"));
        this.assertEquals(0, this.axis.computeStart(260, target, offsets, areaSize, "align-center"));
        this.assertEquals(0, this.axis.computeStart(size, target, offsets, areaSize, "align-end"));
      },
      testNotEnoughSpaceEnd: function testNotEnoughSpaceEnd() {
        var size = 250;
        var target = {
          start: 300,
          end: 400
        };
        var offsets = {
          start: 10,
          end: 20
        };
        var areaSize = 500;
        this.assertEquals(30, this.axis.computeStart(size, target, offsets, areaSize, "edge-start"));
        this.assertEquals(250, this.axis.computeStart(size, target, offsets, areaSize, "edge-end"));
        this.assertEquals(250, this.axis.computeStart(size, target, offsets, areaSize, "align-start"));
        this.assertEquals(210, this.axis.computeStart(290, target, offsets, areaSize, "align-center"));
        this.assertEquals(130, this.axis.computeStart(size, target, offsets, areaSize, "align-end"));
      },
      testNotEnoughSpaceBothSides: function testNotEnoughSpaceBothSides() {
        var size = 250;
        var target = {
          start: 50,
          end: 100
        };
        var offsets = {
          start: 10,
          end: 20
        };
        var areaSize = 150;
        this.assertEquals(-100, this.axis.computeStart(size, target, offsets, areaSize, "edge-start"));
        this.assertEquals(0, this.axis.computeStart(size, target, offsets, areaSize, "edge-end"));
        this.assertEquals(0, this.axis.computeStart(size, target, offsets, areaSize, "align-start"));
        this.assertEquals(-100, this.axis.computeStart(size, target, offsets, areaSize, "align-center"));
        this.assertEquals(-100, this.axis.computeStart(size, target, offsets, areaSize, "align-end"));
      }
    }
  });
  qx.test.util.placement.BestFitAxis.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.placement.DirectAxis": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.placement.DirectAxis", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.axis = qx.util.placement.DirectAxis;
      },
      tearDown: function tearDown() {
        delete this.axis;
      },
      testEnoughSpace: function testEnoughSpace() {
        var size = 50;
        var target = {
          start: 500,
          end: 600
        };
        var offsets = {
          start: 10,
          end: 20
        };
        var areaSize = 1000;
        this.assertEquals(430, this.axis.computeStart(size, target, offsets, areaSize, "edge-start"));
        this.assertEquals(610, this.axis.computeStart(size, target, offsets, areaSize, "edge-end"));
        this.assertEquals(510, this.axis.computeStart(size, target, offsets, areaSize, "align-start"));
        this.assertEquals(535, this.axis.computeStart(size, target, offsets, areaSize, "align-center"));
        this.assertEquals(530, this.axis.computeStart(size, target, offsets, areaSize, "align-end"));
      }
    }
  });
  qx.test.util.placement.DirectAxis.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.placement.KeepAlignAxis": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.placement.KeepAlignAxis", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.axis = qx.util.placement.KeepAlignAxis;
      },
      tearDown: function tearDown() {
        delete this.axis;
      },
      testEnoughSpace: function testEnoughSpace() {
        var size = 50;
        var target = {
          start: 500,
          end: 600
        };
        var offsets = {
          start: 10,
          end: 20
        };
        var areaSize = 1000;
        this.assertEquals(430, this.axis.computeStart(size, target, offsets, areaSize, "edge-start"));
        this.assertEquals(610, this.axis.computeStart(size, target, offsets, areaSize, "edge-end"));
        this.assertEquals(510, this.axis.computeStart(size, target, offsets, areaSize, "align-start"));
        this.assertEquals(535, this.axis.computeStart(size, target, offsets, areaSize, "align-center"));
        this.assertEquals(530, this.axis.computeStart(size, target, offsets, areaSize, "align-end"));
      },
      testNotEnoughSpaceStart: function testNotEnoughSpaceStart() {
        var size = 260;
        var target = {
          start: 30,
          end: 200
        };
        var offsets = {
          start: 10,
          end: 20
        };
        var areaSize = 1000;
        this.assertEquals(210, this.axis.computeStart(size, target, offsets, areaSize, "edge-start"));
        this.assertEquals(210, this.axis.computeStart(size, target, offsets, areaSize, "edge-end"));
        this.assertEquals(40, this.axis.computeStart(size, target, offsets, areaSize, "align-start"));
        this.assertEquals(40, this.axis.computeStart(size, target, offsets, areaSize, "align-center"));
        this.assertEquals(40, this.axis.computeStart(size, target, offsets, areaSize, "align-end"));
      },
      testNotEnoughSpaceEnd: function testNotEnoughSpaceEnd() {
        var size = 290;
        var target = {
          start: 300,
          end: 400
        };
        var offsets = {
          start: 10,
          end: 20
        };
        var areaSize = 500;
        this.assertEquals(0, this.axis.computeStart(size, target, offsets, areaSize, "edge-start"));
        this.assertEquals(0, this.axis.computeStart(size, target, offsets, areaSize, "edge-end"));
        this.assertEquals(90, this.axis.computeStart(size, target, offsets, areaSize, "align-start"));
        this.assertEquals(90, this.axis.computeStart(size, target, offsets, areaSize, "align-center"));
        this.assertEquals(90, this.axis.computeStart(size, target, offsets, areaSize, "align-end"));
      },
      testNotEnoughSpaceBothSides: function testNotEnoughSpaceBothSides() {
        var size = 250;
        var target = {
          start: 50,
          end: 100
        };
        var offsets = {
          start: 10,
          end: 20
        };
        var areaSize = 200;
        this.assertEquals(110, this.axis.computeStart(size, target, offsets, areaSize, "edge-start"));
        this.assertEquals(110, this.axis.computeStart(size, target, offsets, areaSize, "edge-end"));
        this.assertEquals(60, this.axis.computeStart(size, target, offsets, areaSize, "align-start"));
        this.assertEquals(60, this.axis.computeStart(size, target, offsets, areaSize, "align-center"));
        this.assertEquals(60, this.axis.computeStart(size, target, offsets, areaSize, "align-end"));
      }
    }
  });
  qx.test.util.placement.KeepAlignAxis.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.util.placement.Placement": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.util.placement.Placement", {
    extend: qx.dev.unit.TestCase,
    members: {
      testEnoughSpace: function testEnoughSpace() {
        var size = {
          width: 200,
          height: 300
        };
        var area = {
          width: 1000,
          height: 1000
        };
        var target = {
          left: 500,
          top: 500,
          right: 600,
          bottom: 550
        };
        var offsets = {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        };
        var modes = ["direct", "keep-align", "best-fit"];

        for (var i = 0; i < modes.length; i++) {
          var mode = modes[i];
          this.assertJsonEquals({
            left: 500,
            top: 200
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "top-left", mode, mode), mode);
          this.assertJsonEquals({
            left: 450,
            top: 200
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "top-center", mode, mode), mode);
          this.assertJsonEquals({
            left: 400,
            top: 200
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "top-right", mode, mode), mode);
          this.assertJsonEquals({
            left: 500,
            top: 550
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "bottom-left", mode, mode), mode);
          this.assertJsonEquals({
            left: 450,
            top: 550
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "bottom-center", mode, mode), mode);
          this.assertJsonEquals({
            left: 400,
            top: 550
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "bottom-right", mode, mode), mode);
          this.assertJsonEquals({
            left: 300,
            top: 500
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-top", mode, mode), mode);
          this.assertJsonEquals({
            left: 300,
            top: 375
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-middle", mode, mode), mode);
          this.assertJsonEquals({
            left: 300,
            top: 250
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-bottom", mode, mode), mode);
          this.assertJsonEquals({
            left: 600,
            top: 500
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-top", mode, mode), mode);
          this.assertJsonEquals({
            left: 600,
            top: 375
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-middle", mode, mode), mode);
          this.assertJsonEquals({
            left: 600,
            top: 250
          }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-bottom", mode, mode), mode);
        }
      },
      testRestrictedBottomKeepAlign: function testRestrictedBottomKeepAlign() {
        var size = {
          width: 200,
          height: 300
        };
        var area = {
          width: 1000,
          height: 600
        };
        var target = {
          left: 500,
          top: 500,
          right: 600,
          bottom: 550
        };
        var offsets = {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        };
        this.assertJsonEquals({
          left: 500,
          top: 200
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "bottom-left", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 450,
          top: 200
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "bottom-center", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 400,
          top: 200
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "bottom-right", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 300,
          top: 250
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-top", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 300,
          top: 250
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-middle", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 600,
          top: 250
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-top", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 600,
          top: 250
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-middle", "keep-align", "keep-align"));
      },
      testRestrictedTopKeepAlign: function testRestrictedTopKeepAlign() {
        var size = {
          width: 200,
          height: 300
        };
        var area = {
          width: 1000,
          height: 1000
        };
        var target = {
          left: 500,
          top: 100,
          right: 600,
          bottom: 150
        };
        var offsets = {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        };
        this.assertJsonEquals({
          left: 500,
          top: 150
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "top-left", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 450,
          top: 150
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "top-center", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 400,
          top: 150
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "top-right", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 300,
          top: 100
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-middle", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 300,
          top: 100
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-bottom", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 600,
          top: 100
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-middle", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 600,
          top: 100
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-bottom", "keep-align", "keep-align"));
      },
      testRestrictedRightKeepAlign: function testRestrictedRightKeepAlign() {
        var size = {
          width: 200,
          height: 300
        };
        var area = {
          width: 700,
          height: 1000
        };
        var target = {
          left: 500,
          top: 500,
          right: 600,
          bottom: 550
        };
        var offsets = {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        };
        this.assertJsonEquals({
          left: 300,
          top: 500
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-top", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 300,
          top: 375
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-middle", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 300,
          top: 250
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-bottom", "keep-align", "keep-align"));
      },
      testRestrictedLeftKeepAlign: function testRestrictedLeftKeepAlign() {
        var size = {
          width: 200,
          height: 300
        };
        var area = {
          width: 1000,
          height: 1000
        };
        var target = {
          left: 100,
          top: 500,
          right: 200,
          bottom: 550
        };
        var offsets = {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        };
        this.assertJsonEquals({
          left: 200,
          top: 500
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-top", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 200,
          top: 375
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-middle", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 200,
          top: 250
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-bottom", "keep-align", "keep-align"));
      },
      testRestrictedBottomAndTopWithBetterBottomKeepAlign: function testRestrictedBottomAndTopWithBetterBottomKeepAlign() {
        var size = {
          width: 200,
          height: 300
        };
        var area = {
          width: 1000,
          height: 440
        };
        var target = {
          left: 500,
          top: 100,
          right: 600,
          bottom: 150
        };
        var offsets = {
          top: 10,
          bottom: 20,
          left: 0,
          right: 0
        };
        this.assertJsonEquals({
          left: 500,
          top: 160
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "bottom-left", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 450,
          top: 160
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "bottom-center", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 500,
          top: 160
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "top-left", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 450,
          top: 160
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "top-center", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 600,
          top: 110
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-top", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 600,
          top: 110
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-middle", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 600,
          top: 110
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-bottom", "keep-align", "keep-align"));
      },
      testRestrictedLeftAndRightWithBetterLeftKeepAlign: function testRestrictedLeftAndRightWithBetterLeftKeepAlign() {
        var size = {
          width: 200,
          height: 300
        };
        var area = {
          width: 650,
          height: 1000
        };
        var target = {
          left: 500,
          top: 500,
          right: 600,
          bottom: 550
        };
        var offsets = {
          top: 0,
          bottom: 0,
          left: 10,
          right: 20
        };
        this.assertJsonEquals({
          left: 280,
          top: 500
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-top", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 280,
          top: 375
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "left-middle", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 280,
          top: 500
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-top", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 280,
          top: 375
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "right-middle", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 380,
          top: 550
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "bottom-left", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 380,
          top: 550
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "bottom-center", "keep-align", "keep-align"));
        this.assertJsonEquals({
          left: 380,
          top: 550
        }, qx.util.placement.Placement.compute(size, area, target, offsets, "bottom-right", "keep-align", "keep-align"));
      }
    }
  });
  qx.test.util.placement.Placement.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /**
   * The simple qooxdoo decoration theme.
   */
  qx.Theme.define("qx.theme.simple.Decoration", {
    aliases: {
      decoration: "qx/decoration/Simple"
    },
    decorations: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "border-blue": {
        style: {
          width: 4,
          color: "background-selected"
        }
      },
      "main": {
        style: {
          width: 1,
          color: "border-main"
        }
      },
      "main-dark": {
        style: {
          width: 1,
          color: "button-border"
        }
      },
      "popup": {
        style: {
          width: 1,
          color: "window-border",
          shadowLength: 2,
          shadowBlurRadius: 5,
          shadowColor: "shadow"
        }
      },
      "dragover": {
        style: {
          bottom: [2, "solid", "dark-blue"]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button-box": {
        style: {
          radius: 3,
          width: 1,
          color: "button-border",
          gradientStart: ["button-box-bright", 40],
          gradientEnd: ["button-box-dark", 70],
          backgroundColor: "button-box-bright"
        }
      },
      "button-box-pressed": {
        include: "button-box",
        style: {
          gradientStart: ["button-box-bright-pressed", 40],
          gradientEnd: ["button-box-dark-pressed", 70],
          backgroundColor: "button-box-bright-pressed"
        }
      },
      "button-box-pressed-hovered": {
        include: "button-box-pressed",
        style: {
          color: "button-border-hovered"
        }
      },
      "button-box-hovered": {
        include: "button-box",
        style: {
          color: "button-border-hovered"
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON INVALID
      ---------------------------------------------------------------------------
      */
      "button-box-invalid": {
        include: "button-box",
        style: {
          color: "invalid"
        }
      },
      "button-box-pressed-invalid": {
        include: "button-box-pressed",
        style: {
          color: "invalid"
        }
      },
      "button-box-hovered-invalid": {
        include: "button-box-invalid"
      },
      "button-box-pressed-hovered-invalid": {
        include: "button-box-pressed-invalid"
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON FOCUSED
      ---------------------------------------------------------------------------
      */
      "button-box-focused": {
        include: "button-box",
        style: {
          color: "background-selected"
        }
      },
      "button-box-pressed-focused": {
        include: "button-box-pressed",
        style: {
          color: "background-selected"
        }
      },
      "button-box-hovered-focused": {
        include: "button-box-focused"
      },
      "button-box-pressed-hovered-focused": {
        include: "button-box-pressed-focused"
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-right": {
        include: "button-box",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-hovered-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-hovered-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-focused-right": {
        include: "button-box-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-hovered-focused-right": {
        include: "button-box-hovered-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-focused-right": {
        include: "button-box-pressed-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-hovered-focused-right": {
        include: "button-box-pressed-hovered-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON BORDERLESS RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-right-borderless": {
        include: "button-box",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-right-borderless": {
        include: "button-box-pressed",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-right-borderless": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-hovered-right-borderless": {
        include: "button-box-hovered",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON TOP RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-top-right": {
        include: "button-box",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-top-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-top-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-hovered-top-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON BOTOM RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-bottom-right": {
        include: "button-box",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-bottom-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-bottom-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-hovered-bottom-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON BOTOM LEFT
      ---------------------------------------------------------------------------
      */
      "button-box-bottom-left": {
        include: "button-box",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-pressed-bottom-left": {
        include: "button-box-pressed",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-bottom-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-hovered-bottom-left": {
        include: "button-box-hovered",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON TOP LEFT
      ---------------------------------------------------------------------------
      */
      "button-box-top-left": {
        include: "button-box",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-pressed-top-left": {
        include: "button-box-pressed",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-pressed-hovered-top-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-hovered-top-left": {
        include: "button-box-hovered",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON MIDDLE
      ---------------------------------------------------------------------------
      */
      "button-box-middle": {
        include: "button-box",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-middle": {
        include: "button-box-pressed",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-middle": {
        include: "button-box-pressed-hovered",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-middle": {
        include: "button-box-hovered",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON LEFT
      ---------------------------------------------------------------------------
      */
      "button-box-left": {
        include: "button-box",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-left": {
        include: "button-box-pressed",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-left": {
        include: "button-box-hovered",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-focused-left": {
        include: "button-box-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-focused-left": {
        include: "button-box-hovered-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-focused-left": {
        include: "button-box-pressed-hovered-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-focused-left": {
        include: "button-box-pressed-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        SEPARATOR
      ---------------------------------------------------------------------------
      */
      "separator-horizontal": {
        style: {
          widthLeft: 1,
          colorLeft: "border-separator"
        }
      },
      "separator-vertical": {
        style: {
          widthTop: 1,
          colorTop: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL KNOB
      ---------------------------------------------------------------------------
      */
      "scroll-knob": {
        style: {
          radius: 3,
          width: 1,
          color: "button-border",
          backgroundColor: "scrollbar-bright"
        }
      },
      "scroll-knob-pressed": {
        include: "scroll-knob",
        style: {
          backgroundColor: "scrollbar-dark"
        }
      },
      "scroll-knob-hovered": {
        include: "scroll-knob",
        style: {
          color: "button-border-hovered"
        }
      },
      "scroll-knob-pressed-hovered": {
        include: "scroll-knob-pressed",
        style: {
          color: "button-border-hovered"
        }
      },

      /*
      ---------------------------------------------------------------------------
        HOVER BUTTON
      ---------------------------------------------------------------------------
      */
      "button-hover": {
        style: {
          backgroundColor: "button",
          radius: 3
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: {
          width: 1,
          color: "window-border",
          innerWidth: 4,
          innerColor: "window-border-inner",
          shadowLength: 1,
          shadowBlurRadius: 3,
          shadowColor: "shadow",
          backgroundColor: "background"
        }
      },
      "window-active": {
        include: "window",
        style: {
          shadowLength: 2,
          shadowBlurRadius: 5
        }
      },
      "window-caption": {
        style: {
          width: [0, 0, 2, 0],
          color: "window-border-inner"
        }
      },

      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "white-box": {
        style: {
          width: 1,
          color: "white-box-border",
          shadowBlurRadius: 2,
          shadowColor: "#999999",
          radius: 7,
          backgroundColor: "white",
          shadowLength: 0
        }
      },

      /*
      ---------------------------------------------------------------------------
        TEXT FIELD
      ---------------------------------------------------------------------------
      */
      "inset": {
        style: {
          width: 1,
          color: ["border-light-shadow", "border-light", "border-light", "border-light"]
        }
      },
      "focused-inset": {
        style: {
          width: 2,
          color: "background-selected"
        }
      },
      "border-invalid": {
        style: {
          width: 2,
          color: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        LIST ITEM
      ---------------------------------------------------------------------------
      */
      "lead-item": {
        style: {
          width: 1,
          style: "dotted",
          color: "border-lead"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOL TIP
      ---------------------------------------------------------------------------
      */
      "tooltip": {
        style: {
          width: 1,
          color: "tooltip-text",
          shadowLength: 1,
          shadowBlurRadius: 2,
          shadowColor: "shadow"
        }
      },
      "tooltip-error": {
        style: {
          radius: 5,
          backgroundColor: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar-separator": {
        style: {
          widthLeft: 1,
          colorLeft: "button-border"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu-separator": {
        style: {
          widthTop: 1,
          colorTop: "background-selected"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar-button-hovered": {
        style: {
          width: 1,
          color: "border-main",
          radius: 3,
          backgroundColor: "white"
        }
      },
      "menubar-button-pressed": {
        include: "menubar-button-hovered",
        style: {
          radius: [3, 3, 0, 0],
          width: [1, 1, 0, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser-date-pane": {
        style: {
          widthTop: 1,
          colorTop: "gray",
          style: "solid"
        }
      },
      "datechooser-weekday": {
        style: {
          widthBottom: 1,
          colorBottom: "gray",
          style: "solid"
        }
      },
      "datechooser-week": {
        style: {
          widthRight: 1,
          colorRight: "gray",
          style: "solid"
        }
      },
      "datechooser-week-header": {
        style: {
          widthBottom: 1,
          colorBottom: "gray",
          widthRight: 1,
          colorRight: "gray",
          style: "solid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TAB VIEW
      ---------------------------------------------------------------------------
      */
      "tabview-page-button-top": {
        style: {
          width: [1, 1, 0, 1],
          backgroundColor: "background",
          color: "border-main",
          radius: [3, 3, 0, 0]
        }
      },
      "tabview-page-button-bottom": {
        include: "tabview-page-button-top",
        style: {
          radius: [0, 0, 3, 3],
          width: [0, 1, 1, 1]
        }
      },
      "tabview-page-button-left": {
        include: "tabview-page-button-top",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "tabview-page-button-right": {
        include: "tabview-page-button-top",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "statusbar": {
        style: {
          widthTop: 1,
          colorTop: "background-selected",
          styleTop: "solid"
        }
      },
      "table-scroller-focus-indicator": {
        style: {
          width: 2,
          color: "table-focus-indicator",
          style: "solid"
        }
      },
      "table-header": {
        include: "button-box",
        style: {
          radius: 0,
          width: [1, 0, 1, 0]
        }
      },
      "table-header-column-button": {
        include: "table-header",
        style: {
          width: 1,
          color: "button-border"
        }
      },
      "table-header-cell": {
        style: {
          widthRight: 1,
          color: "button-border"
        }
      },
      "table-header-cell-first": {
        include: "table-header-cell",
        style: {
          widthLeft: 1
        }
      },
      "progressive-table-header": {
        include: "button-box",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "progressive-table-header-cell": {
        style: {
          widthRight: 1,
          color: "button-border"
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: {
          backgroundColor: "#FFF",
          width: 1,
          color: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        RADIO BUTTON
      ---------------------------------------------------------------------------
      */
      "radiobutton": {
        style: {
          radius: 10,
          width: 1,
          color: "button-border",
          innerColor: "background",
          innerWidth: 2
        }
      },
      "radiobutton-focused": {
        include: "radiobutton",
        style: {
          color: "background-selected"
        }
      },
      "radiobutton-invalid": {
        include: "radiobutton",
        style: {
          color: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        CHECK BOX
      ---------------------------------------------------------------------------
      */
      "checkbox": {
        style: {
          width: 1,
          color: "button-border"
        }
      },
      "checkbox-focused": {
        include: "checkbox",
        style: {
          color: "background-selected"
        }
      },
      "checkbox-invalid": {
        include: "checkbox",
        style: {
          color: "invalid"
        }
      }
    }
  });
  qx.theme.simple.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.simple.Decoration": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /**
   * The indigo qooxdoo decoration theme.
   */
  qx.Theme.define("qx.theme.indigo.Decoration", {
    extend: qx.theme.simple.Decoration,
    aliases: {
      decoration: "qx/decoration/Simple"
    },
    decorations: {
      "window": {
        style: {
          width: 1,
          color: "window-border",
          shadowLength: 1,
          shadowBlurRadius: 3,
          shadowColor: "shadow",
          backgroundColor: "background",
          radius: 3
        }
      },
      "window-caption": {
        style: {
          radius: [3, 3, 0, 0],
          color: "window-border",
          widthBottom: 1
        }
      },
      "window-caption-active": {
        style: {
          radius: [3, 3, 0, 0],
          color: "highlight",
          widthBottom: 3
        }
      },
      "white-box": {
        style: {
          width: 1,
          color: "white-box-border",
          backgroundColor: "white"
        }
      },
      "statusbar": {
        style: {
          widthTop: 1,
          colorTop: "border-main",
          styleTop: "solid"
        }
      },
      "app-header": {
        style: {
          innerWidthBottom: 1,
          innerColorBottom: "highlight-shade",
          widthBottom: 9,
          colorBottom: "highlight",
          gradientStart: ["#505154", 0],
          gradientEnd: ["#323335", 100],
          backgroundColor: "#323335"
        }
      }
    }
  });
  qx.theme.indigo.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The simple qooxdoo font theme.
   *
   * @asset(qx/decoration/Indigo/font/JosefinSlab-SemiBold.woff)
   * @asset(qx/decoration/Indigo/font/JosefinSlab-SemiBold.ttf)
   */
  qx.Theme.define("qx.theme.indigo.Font", {
    fonts: {
      "default": {
        size: 12,
        family: ["Lucida Grande", "DejaVu Sans", "Verdana", "sans-serif"],
        color: "font",
        lineHeight: 1.8
      },
      "bold": {
        size: 12,
        family: ["Lucida Grande", "DejaVu Sans", "Verdana", "sans-serif"],
        bold: true,
        color: "font",
        lineHeight: 1.8
      },
      "headline": {
        size: 22,
        family: ["serif"],
        sources: [{
          family: "JosefinSlab",
          source: ["qx/decoration/Indigo/font/JosefinSlab-SemiBold.woff", "qx/decoration/Indigo/font/JosefinSlab-SemiBold.ttf"]
        }]
      },
      "small": {
        size: 11,
        family: ["Lucida Grande", "DejaVu Sans", "Verdana", "sans-serif"],
        color: "font",
        lineHeight: 1.8
      },
      "monospace": {
        size: 11,
        family: ["DejaVu Sans Mono", "Courier New", "monospace"],
        color: "font",
        lineHeight: 1.8
      }
    }
  });
  qx.theme.indigo.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.simple.Appearance": {
        "require": true
      },
      "qx.theme.simple.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The simple qooxdoo appearance theme.
   *
   * @asset(qx/icon/${qx.icontheme}/16/apps/office-calendar.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder-open.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder.png)
   * @asset(qx/icon/${qx.icontheme}/16/mimetypes/text-plain.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/view-refresh.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/window-close.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-cancel.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-ok.png)
   */
  qx.Theme.define("qx.theme.indigo.Appearance", {
    extend: qx.theme.simple.Appearance,
    appearances: {
      "colorselector/input-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 0
          };
        }
      },
      "colorselector/preview-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 0
          };
        }
      },
      "toolbar": {
        style: function style(states) {
          return {
            backgroundColor: "light-background",
            padding: [4, 0]
          };
        }
      },
      "splitpane/splitter/knob": {
        style: function style(states) {
          return {
            source: qx.theme.simple.Image.URLS["knob-" + (states.horizontal ? "horizontal" : "vertical")],
            padding: 3
          };
        }
      },
      "window": {
        style: function style(states) {
          return {
            contentPadding: [10, 10, 10, 10],
            backgroundColor: states.maximized ? "background" : undefined,
            decorator: states.maximized ? undefined : states.active ? "window-active" : "window"
          };
        }
      },
      "window/captionbar": {
        style: function style(states) {
          var active = states.active && !states.disabled;
          return {
            padding: [3, 8, active ? 1 : 3, 8],
            textColor: active ? "highlight" : "font",
            decorator: active ? "window-caption-active" : "window-caption"
          };
        }
      },
      "window/title": {
        style: function style(states) {
          return {
            cursor: "default",
            font: "default",
            marginRight: 20,
            alignY: "middle"
          };
        }
      },
      "virtual-tree": {
        include: "tree",
        alias: "tree",
        style: function style(states) {
          return {
            itemHeight: 27
          };
        }
      },
      "app-header": {
        style: function style(states) {
          return {
            font: "headline",
            textColor: "text-selected",
            decorator: "app-header",
            padding: 10
          };
        }
      },
      "app-header-label": {
        style: function style(states) {
          return {
            paddingTop: 5
          };
        }
      },
      "app-splitpane": {
        alias: "splitpane",
        style: function style(states) {
          return {
            padding: [0, 10, 10, 10],
            backgroundColor: "light-background"
          };
        }
      }
    }
  });
  qx.theme.indigo.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.indigo.Color": {
        "require": true
      },
      "qx.theme.indigo.Decoration": {
        "require": true
      },
      "qx.theme.indigo.Font": {
        "require": true
      },
      "qx.theme.indigo.Appearance": {
        "require": true
      },
      "qx.theme.icon.Tango": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Tristan Koch (trkoch)
  
  ************************************************************************ */

  /**
   * Simple Theme
   */
  qx.Theme.define("qx.theme.Indigo", {
    title: "Indigo",
    meta: {
      color: qx.theme.indigo.Color,
      decoration: qx.theme.indigo.Decoration,
      font: qx.theme.indigo.Font,
      appearance: qx.theme.indigo.Appearance,
      icon: qx.theme.icon.Tango
    }
  });
  qx.theme.Indigo.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.modern.Color": {
        "require": true
      },
      "qx.theme.modern.Decoration": {
        "require": true
      },
      "qx.theme.modern.Font": {
        "require": true
      },
      "qx.theme.modern.Appearance": {
        "require": true
      },
      "qx.theme.icon.Tango": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Contemporary Theme
   */
  qx.Theme.define("qx.theme.Modern", {
    title: "Modern",
    meta: {
      color: qx.theme.modern.Color,
      decoration: qx.theme.modern.Decoration,
      font: qx.theme.modern.Font,
      appearance: qx.theme.modern.Appearance,
      icon: qx.theme.icon.Tango
    }
  });
  qx.theme.Modern.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Css": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "css.rgba": {
          "load": true,
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Simple color theme
   */
  qx.Theme.define("qx.theme.simple.Color", {
    colors: {
      // main
      "background": "white",
      "dark-blue": "#5685D6",
      "light-background": "#E0ECFF",
      // backgrounds
      "background-selected": "#6694E3",
      "background-selected-disabled": "#CDCDCD",
      "background-selected-dark": "#5685D6",
      "background-disabled": "#F7F7F7",
      "background-disabled-checked": "#BBBBBB",
      "background-pane": "#FAFBFE",
      // tabview
      "tabview-unselected": "#1866B5",
      "tabview-button-border": "#134983",
      "tabview-label-active-disabled": "#D9D9D9",
      // text colors
      "link": "#24B",
      // scrollbar
      "scrollbar-bright": "#F1F1F1",
      "scrollbar-dark": "#EBEBEB",
      // form
      "button": "#E8F0E3",
      "button-border": "#BBB",
      "button-border-hovered": "#939393",
      "invalid": "#FF0000",
      "button-box-bright": "#F9F9F9",
      "button-box-dark": "#E3E3E3",
      "button-box-bright-pressed": "#DDDDDD",
      "button-box-dark-pressed": "#F5F5F5",
      "border-lead": "#888888",
      // window
      "window-border": "#2E3A46",
      "window-border-inner": "#9DCBFE",
      // group box
      "white-box-border": "#BCBCBC",
      // shadows
      "shadow": qx.core.Environment.get("css.rgba") ? "rgba(0, 0, 0, 0.4)" : "#666666",
      // borders
      // 'border-main' is an alias of 'background-selected' (compatibility reasons)
      "border-main": "#6694E3",
      "border-light": "#B7B7B7",
      "border-light-shadow": "#686868",
      // separator
      "border-separator": "#808080",
      // text
      "text": "black",
      "text-disabled": "#A7A6AA",
      "text-selected": "white",
      "text-placeholder": "#CBC8CD",
      // tooltip
      "tooltip": "#FFFFE1",
      "tooltip-text": "black",
      // table
      "table-header": [242, 242, 242],
      "table-focus-indicator": [179, 217, 255],
      // used in table code
      "table-header-cell": [235, 234, 219],
      "table-row-background-focused-selected": [90, 138, 211],
      "table-row-background-focused": [221, 238, 255],
      "table-row-background-selected": [51, 94, 168],
      "table-row-background-even": "white",
      "table-row-background-odd": "white",
      "table-row-selected": [255, 255, 255],
      "table-row": [0, 0, 0],
      "table-row-line": "#EEE",
      "table-column-line": "#EEE",
      // used in progressive code
      "progressive-table-header": "#AAAAAA",
      "progressive-table-row-background-even": [250, 248, 243],
      "progressive-table-row-background-odd": [255, 255, 255],
      "progressive-progressbar-background": "gray",
      "progressive-progressbar-indicator-done": "#CCCCCC",
      "progressive-progressbar-indicator-undone": "white",
      "progressive-progressbar-percent-background": "gray",
      "progressive-progressbar-percent-text": "white"
    }
  });
  qx.theme.simple.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /**
   * The simple qooxdoo font theme.
   */
  qx.Theme.define("qx.theme.simple.Font", {
    fonts: {
      "default": {
        size: 13,
        family: ["arial", "sans-serif"]
      },
      "bold": {
        size: 13,
        family: ["arial", "sans-serif"],
        bold: true
      },
      "headline": {
        size: 24,
        family: ["sans-serif", "arial"]
      },
      "small": {
        size: 11,
        family: ["arial", "sans-serif"]
      },
      "monospace": {
        size: 11,
        family: ["DejaVu Sans Mono", "Courier New", "monospace"]
      }
    }
  });
  qx.theme.simple.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.simple.Color": {
        "require": true
      },
      "qx.theme.simple.Decoration": {
        "require": true
      },
      "qx.theme.simple.Font": {
        "require": true
      },
      "qx.theme.simple.Appearance": {
        "require": true
      },
      "qx.theme.icon.Tango": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Simple Theme
   */
  qx.Theme.define("qx.theme.Simple", {
    title: "Simple",
    meta: {
      color: qx.theme.simple.Color,
      decoration: qx.theme.simple.Decoration,
      font: qx.theme.simple.Font,
      appearance: qx.theme.simple.Appearance,
      icon: qx.theme.icon.Tango
    }
  });
  qx.theme.Simple.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.LayoutItem": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * All of the resizing information about a column.
   *
   *  This is used internally by qx.ui.table and qx.ui.progressive's table and
   *  may be used for other widgets as well.
   */
  qx.Class.define("qx.ui.core.ColumnData", {
    extend: qx.ui.core.LayoutItem,
    construct: function construct() {
      qx.ui.core.LayoutItem.constructor.call(this);
      this.setColumnWidth("auto");
    },
    members: {
      __computedWidth: null,
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        this.__computedWidth = width;
      },

      /**
       * Get the computed width of the column.
       * @return {Integer} Computed column width
       */
      getComputedWidth: function getComputedWidth() {
        return this.__computedWidth;
      },

      /**
       * Get the column's flex value
       *
       * @return {Integer} The column's flex value
       */
      getFlex: function getFlex() {
        return this.getLayoutProperties().flex || 0;
      },

      /**
       * Set the column width. The column width can be one of the following
       * values:
       *
       * * Pixels: e.g. <code>23</code>
       * * Autosized: <code>"auto"</code>
       * * Flex: e.g. <code>"1*"</code>
       * * Percent: e.g. <code>"33%"</code>
       *
       * @param width {Integer|String} The column width
       * @param flex {Integer?0} Optional flex value of the column
       */
      setColumnWidth: function setColumnWidth(width, flex) {
        var flex = flex || 0;
        var percent = null;

        if (typeof width == "number") {
          this.setWidth(width);
        } else if (typeof width == "string") {
          if (width == "auto") {
            flex = 1;
          } else {
            var match = width.match(/^[0-9]+(?:\.[0-9]+)?([%\*])$/);

            if (match) {
              if (match[1] == "*") {
                flex = parseFloat(width);
              } else {
                percent = width;
              }
            }
          }
        }

        this.setLayoutProperties({
          flex: flex,
          width: percent
        });
      }
    },
    environment: {
      "qx.tableResizeDebug": false
    }
  });
  qx.ui.core.ColumnData.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Mixin holding the handler for the two axis mouse wheel scrolling. Please
   * keep in mind that the including widget has to have the scroll bars
   * implemented as child controls named <code>scrollbar-x</code> and
   * <code>scrollbar-y</code> to get the handler working. Also, you have to
   * attach the listener yourself.
   */
  qx.Mixin.define("qx.ui.core.scroll.MWheelHandling", {
    members: {
      /**
       * Mouse wheel event handler
       *
       * @param e {qx.event.type.Mouse} Mouse event
       */
      _onMouseWheel: function _onMouseWheel(e) {
        var showX = this._isChildControlVisible("scrollbar-x");

        var showY = this._isChildControlVisible("scrollbar-y");

        var scrollbarY = showY ? this.getChildControl("scrollbar-y", true) : null;
        var scrollbarX = showX ? this.getChildControl("scrollbar-x", true) : null;
        var deltaY = e.getWheelDelta("y");
        var deltaX = e.getWheelDelta("x");
        var endY = !showY;
        var endX = !showX; // y case

        if (scrollbarY) {
          var steps = parseInt(deltaY);

          if (steps !== 0) {
            scrollbarY.scrollBySteps(steps);
          }

          var position = scrollbarY.getPosition();
          var max = scrollbarY.getMaximum(); // pass the event to the parent if the scrollbar is at an edge

          if (steps < 0 && position <= 0 || steps > 0 && position >= max) {
            endY = true;
          }
        } // x case


        if (scrollbarX) {
          var steps = parseInt(deltaX);

          if (steps !== 0) {
            scrollbarX.scrollBySteps(steps);
          }

          var position = scrollbarX.getPosition();
          var max = scrollbarX.getMaximum(); // pass the event to the parent if the scrollbar is at an edge

          if (steps < 0 && position <= 0 || steps > 0 && position >= max) {
            endX = true;
          }
        } // pass the event to the parent if both scrollbars are at the end


        if (!endY && deltaX === 0 || !endX && deltaY === 0 || (!endX || !endY) && deltaX !== 0 && deltaY !== 0) {
          // Stop bubbling and native event only if a scrollbar is visible
          e.stop();
        }
      }
    }
  });
  qx.ui.core.scroll.MWheelHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.embed.AbstractIframe": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.scroll.MRoll": {
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.embed.Iframe": {},
      "qx.ui.core.scroll.ScrollBar": {},
      "qx.ui.core.Widget": {},
      "qx.bom.Element": {},
      "qx.event.Idle": {},
      "qx.bom.Document": {},
      "qx.bom.Viewport": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Container widget for internal frames (iframes) with qooxdoo scroll bar and
   * size hint support.
   *
   * An iframe can display any HTML page inside the widget. Note that custom
   * scroll bars do only work if the iframe's source points to the same domain
   * as the application.
   *
   * @childControl iframe {qx.ui.embed.Iframe} embedded iframe component
   * @childControl scrollbar-x {qx.ui.core.scroll.ScrollBar} horizontal scrollbar
   * @childControl scrollbar-y {qx.ui.core.scroll.ScrollBar} vertical scrollbar
   * @childControl corner {qx.ui.core.Widget} corner widget where no scrollbar is shown
   *
   * *Example*
   *
   * Here is a little example of how to use the widget:
   *
   * <pre class='javascript'>
   * var document = this.getRoot();
   * var iframe = new qx.ui.embed.ThemedIframe("frame.html");
   * document.add(iframe);
   * </pre>
   *
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/themediframe.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.embed.ThemedIframe", {
    extend: qx.ui.embed.AbstractIframe,
    include: qx.ui.core.scroll.MRoll,
    construct: function construct(source) {
      qx.ui.embed.AbstractIframe.constructor.call(this, source); // Create 'fixed' grid layout

      var grid = new qx.ui.layout.Grid();
      grid.setColumnFlex(0, 1);
      grid.setRowFlex(0, 1);

      this._setLayout(grid);

      this._showChildControl("iframe");
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "scrollarea"
      },

      /**
       * The policy, when the horizontal scrollbar should be shown.
       * <ul>
       *   <li><b>auto</b>: Show scrollbar on demand</li>
       *   <li><b>on</b>: Always show the scrollbar</li>
       *   <li><b>off</b>: Never show the scrollbar</li>
       * </ul>
       */
      scrollbarX: {
        check: ["auto", "on", "off"],
        init: "auto",
        themeable: true,
        apply: "_updateScrollbars"
      },

      /**
       * The policy, when the horizontal scrollbar should be shown.
       * <ul>
       *   <li><b>auto</b>: Show scrollbar on demand</li>
       *   <li><b>on</b>: Always show the scrollbar</li>
       *   <li><b>off</b>: Never show the scrollbar</li>
       * </ul>
       */
      scrollbarY: {
        check: ["auto", "on", "off"],
        init: "auto",
        themeable: true,
        apply: "_updateScrollbars"
      },

      /**
       * Group property, to set the overflow of both scroll bars.
       */
      scrollbar: {
        group: ["scrollbarX", "scrollbarY"]
      }
    },
    members: {
      __iframeSize: null,
      __iframeObserverId: null,
      // overridden
      _getIframeElement: function _getIframeElement() {
        return this.getChildControl("iframe").getContentElement();
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "iframe":
            control = new qx.ui.embed.Iframe(this.getSource());
            control.addListener("load", this._onIframeLoad, this);
            control.addListener("resize", this._onIframeResize, this);

            this._add(control, {
              row: 0,
              column: 0
            });

            break;

          case "scrollbar-x":
            control = new qx.ui.core.scroll.ScrollBar("horizontal");
            control.setMinWidth(0);
            control.exclude();
            control.addListener("scroll", this._onScrollBarX, this);

            this._add(control, {
              row: 1,
              column: 0
            });

            break;

          case "scrollbar-y":
            control = new qx.ui.core.scroll.ScrollBar("vertical");
            control.setMinHeight(0);
            control.exclude();
            control.addListener("scroll", this._onScrollBarY, this);

            this._add(control, {
              row: 0,
              column: 1
            });

            break;

          case "corner":
            control = new qx.ui.core.Widget();
            control.setWidth(0);
            control.setHeight(0);
            control.exclude();

            this._add(control, {
              row: 1,
              column: 1
            });

            break;
        }

        return control || qx.ui.embed.ThemedIframe.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the iframe's load event
       */
      _onIframeLoad: function _onIframeLoad() {
        this._disableScollbars();

        var body = this._getIframeElement().getBody();

        if (body) {
          this._startIframeObserver();

          this._addRollListener();
        }

        this.fireEvent("load");
      },

      /**
       * Event handler for resize event of the iframe widget.
       */
      _onIframeResize: function _onIframeResize() {
        this._updateScrollbars();
      },

      /**
       * Hide all scrollbars and stop observing the iframe document
       */
      _disableScollbars: function _disableScollbars() {
        this._excludeChildControl("scrollbar-x");

        this._excludeChildControl("scrollbar-y");

        this._excludeChildControl("corner");

        this._stopIframeObserver();
      },

      /**
       * Attach roll listener to the iframe
       */
      _addRollListener: function _addRollListener() {
        try {
          var body = this._getIframeElement().getBody();

          qx.bom.Element.addListener(body, "roll", this._onRoll, this);
          qx.bom.Element.addListener(body, "pointerdown", this._onPointerDownForRoll, this);
        } catch (e) {
          this._disableScollbars();
        }
      },

      /**
       * Start observing size changes of the iframe document
       */
      _startIframeObserver: function _startIframeObserver() {
        if (this.__iframeObserverId) {
          this._stopIframeObserver();
        }

        var idle = qx.event.Idle.getInstance();
        this.__iframeObserverId = idle.addListener("interval", this._onIframeObserverInterval, this);
      },

      /**
       * Stop observing size changes of the iframe document
       */
      _stopIframeObserver: function _stopIframeObserver() {
        this.__iframeSize = null;

        if (!this.__iframeObserverId) {
          return;
        }

        var idle = qx.event.Idle.getInstance();
        idle.removeListenerById(this.__iframeObserverId);
      },

      /**
       * Event handler, which is called periodically to update the scroll bars
       */
      _onIframeObserverInterval: function _onIframeObserverInterval() {
        var iframeSize = this._getIframeSize();

        if (!iframeSize) {
          this._disableScollbars();

          return;
        }

        if (this.__iframeSize && iframeSize.width == this.__iframeSize.width && iframeSize.height == this.__iframeSize.height) {
          return;
        }

        this.__iframeSize = iframeSize;

        this._preventIframeScrolling();

        this._updateScrollbars();
      },

      /**
       * Try to hide native scrollbars in the iframe
       */
      _preventIframeScrolling: function _preventIframeScrolling() {
        try {
          var win = this._getIframeElement().getWindow();

          var doc = this._getIframeElement().getDocument();

          if (qx.bom.Document.isStandardMode(win)) {
            doc.documentElement.style.overflow = "hidden";
          } else {
            doc.body.style.overflow = "hidden";
          }
        } catch (e) {
          this._disableScollbars();
        }
      },

      /**
       * Recompute scrollbar visibility and positions based on the iframe's
       * document size
       */
      _updateScrollbars: function _updateScrollbars() {
        var iframeSize = this.__iframeSize;
        var paneSize = this.getChildControl("iframe").getBounds();
        var innerSize = this.getChildControl("iframe").getInnerSize();

        if (!iframeSize || !innerSize || !innerSize) {
          return;
        }

        var showX = false;
        var showY = false;
        var scrollbarX = this.getScrollbarX();
        var scrollbarY = this.getScrollbarY();

        if (scrollbarX === "auto" && scrollbarY === "auto") {
          // Check if the container is big enough to show
          // the full content.
          var showX = iframeSize.width > innerSize.width;
          var showY = iframeSize.height > innerSize.height; // Dependency check
          // We need a special intelligence here when only one
          // of the autosized axis requires a scrollbar
          // This scrollbar may then influence the need
          // for the other one as well.

          if ((showX || showY) && !(showX && showY)) {
            if (showX) {
              showY = iframeSize.height > paneSize.height;
            } else if (showY) {
              showX = iframeSize.width > paneSize.width;
            }
          }
        } else {
          var showX = scrollbarX === "on";
          var showY = scrollbarY === "on"; // Check auto values afterwards with already
          // corrected client dimensions

          if (iframeSize.width > (showX ? paneSize.width : innerSize.width) && scrollbarX === "auto") {
            showX = true;
          }

          if (iframeSize.height > (showX ? paneSize.height : innerSize.height) && scrollbarY === "auto") {
            showY = true;
          }
        }

        this._configureScrollbar("scrollbar-x", showX, innerSize.width, iframeSize.width);

        this._configureScrollbar("scrollbar-y", showY, innerSize.height, iframeSize.height);

        this._updateCornerWidget();
      },

      /**
       * Compute the size of the iframe body
       *
       * @return {Object|null} A map with the body size or <code>null</code>.
       */
      _getIframeSize: function _getIframeSize() {
        try {
          var win = this._getIframeElement().getWindow();

          var frameSize = {
            width: qx.bom.Document.getWidth(win),
            height: qx.bom.Document.getHeight(win)
          };
          return frameSize;
        } catch (e) {
          return null;
        }
      },

      /**
       * Update visibility of the corner widget based on the visibility of the
       * scrollbars
       */
      _updateCornerWidget: function _updateCornerWidget() {
        if (this._isChildControlVisible("scrollbar-x") && this._isChildControlVisible("scrollbar-y")) {
          this._showChildControl("corner");
        } else {
          this._excludeChildControl("corner");
        }
      },

      /**
       * Configures the given scrollbar
       *
       * @param scrollbarId {String} child control id of the scrollbar to
       *   configure
       * @param show {Boolean} whether the scrollbar should be visible
       * @param containerSize {Integer} size of the container widget
       * @param contentSize {Integer} size of the iframe's document
       */
      _configureScrollbar: function _configureScrollbar(scrollbarId, show, containerSize, contentSize) {
        if (!show) {
          this._excludeChildControl(scrollbarId);

          return;
        }

        var bar = this._showChildControl(scrollbarId);

        if (containerSize >= contentSize) {
          bar.set({
            position: 0,
            maximum: contentSize,
            knobFactor: 1,
            enabled: false
          });
        } else {
          bar.setMaximum(1000000);
          bar.set({
            position: Math.min(bar.getPosition(), contentSize),
            maximum: contentSize - containerSize,
            knobFactor: containerSize / contentSize,
            enabled: true
          });
        }
      },

      /**
       * Event handler for the scroll event of the horizontal scrollbar
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollBarX: function _onScrollBarX(e) {
        this.scrollToX(e.getData());
      },

      /**
       * Event handler for the scroll event of the vertical scrollbar
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollBarY: function _onScrollBarY(e) {
        this.scrollToY(e.getData());
      },

      /**
       * Scrolls the iframe's content to the given left coordinate
       *
       * @param x {Integer} The vertical position to scroll to.
       */
      scrollToX: function scrollToX(x) {
        try {
          var win = this._getIframeElement().getWindow();

          win.scroll(x, qx.bom.Viewport.getScrollTop(win));
        } catch (e) {
          this._disableScollbars();
        }
      },

      /**
       * Scrolls the iframe's content to the given top coordinate
       *
       * @param y {Integer} The horizontal position to scroll to.
       */
      scrollToY: function scrollToY(y) {
        try {
          var win = this._getIframeElement().getWindow();

          win.scroll(qx.bom.Viewport.getScrollLeft(win), y);
        } catch (e) {
          this._disableScollbars();
        }
      }
    },
    destruct: function destruct() {
      this._stopIframeObserver();

      this.__iframeSize = null;
    }
  });
  qx.ui.embed.ThemedIframe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 Martijn Evers, The Netherlands
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martijn Evers (mever)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which have an
   * model object (i.e. {qx.core.Object}) as their primary data type.
   */
  qx.Interface.define("qx.ui.form.IModelForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {qx.core.Object|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {qx.core.Object|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.IModelForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Objects which are used as delegates for the <code>qx.ui.list.List</code> may
   * implement any of the methods described in this interface. The delegate does
   * not need to implement all the methods of this interface. If a method is not
   * implemented the <code>qx.ui.list.List</code> provides a default
   * implementation.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * actually implemented.
   */
  qx.Interface.define("qx.ui.list.core.IListDelegate", {
    members: {
      /**
       * Gives the user the opportunity to set individual styles and properties
       * on the item widget cells created by the controller.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      configureItem: function configureItem(item) {},

      /**
       * Gives the user the opportunity to set individual styles and properties
       * on the group widget cells created by the controller.
       *
       * @param item {qx.ui.core.Widget} Group to modify.
       */
      configureGroupItem: function configureGroupItem(item) {},

      /**
       * Creates an item cell which will be used for rendering. Be sure to
       * implement the {@link #bindItem} function as well to get the needed
       * properties bound.
       *
       * @return {qx.ui.core.Widget} A new created item cell.
       */
      createItem: function createItem() {},

      /**
       * Creates a group cell which will be used for rendering. Be sure to
       * implement the {@link #bindGroupItem} function as well to get the needed
       * properties bound.
       *
       * @return {qx.ui.core.Widget} A new created item cell.
       */
      createGroupItem: function createGroupItem() {},

      /**
       * Sets up the binding for the given item and index.
       *
       * For every property you want to bind, use
       * {@link MWidgetController#bindProperty} like this:
       * <code>
       * controller.bindProperty("path.in.the.model", "label", options, item, id);
       * </code>
       *
       * @param controller {qx.ui.list.core.MWidgetController} The currently used controller.
       * @param item {qx.ui.core.Widget} The created and used item.
       * @param id {Integer} The id for the binding.
       */
      bindItem: function bindItem(controller, item, id) {},

      /**
       * Sets up the binding for the given group item and index.
       *
       * For every property you want to bind, use
       * {@link MWidgetController#bindProperty} like this:
       * <code>
       * controller.bindProperty(null, "value", options, item, id);
       * </code>
       *
       * @param controller {qx.ui.list.core.MWidgetController} The currently used controller.
       * @param item {qx.ui.core.Widget} The created and used group item.
       * @param id {Integer} The id for the binding.
       */
      bindGroupItem: function bindGroupItem(controller, item, id) {},

      /**
       * Gives the user the opportunity to filter the model. The filter
       * method has to return <code>true</code> if the given data should be
       * shown and <code>false</code> if the given data should be ignored.
       *
       * @param data {var} The data to be checked.
       * @return {Boolean} <code>true</code> if the data passes the filter,
       *   <code>false</code> otherwise.
       */
      filter: function filter(data) {},

      /**
       * Gives the user the opportunity to sort the model. The sorting method
       * should return a negative value if a < b, zero if a = b, or a positive
       * value if a > b.
       *
       * @param a {var} value to compare.
       * @param b {var} value to compare.
       * @return {Integer} should return a negative value if a < b, zero
       *   if a = b, or a positive value if a > b.
       */
      sorter: function sorter(a, b) {},

      /**
       * Gives the user the opportunity to group the model. The group method
       * should return unique identifier for the passed data.
       *
       * Note: When you returning <code>null</code> the passed data will added
       * to the default group, which is <code>???</code> from the type
       * <code>String</code>. But keep in mind that you can only use the default
       * group feature when each other group identifier is also a <code>String</code>.
       * Otherwise an exception occurs, because you can't mix <code>Object</code>
       * and <code>String</code> group identifiers.
       *
       * @param data {var} The data to be checked.
       * @return {String|Object|null} The group identifier for the data.
       */
      group: function group(data) {},

      /**
       * Gives the user the opportunity to reset properties or states.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      onPool: function onPool(item) {}
    }
  });
  qx.ui.list.core.IListDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.toolbar.ToolBar": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Container for menubar buttons to display a classic application menu.
   */
  qx.Class.define("qx.ui.menubar.MenuBar", {
    extend: qx.ui.toolbar.ToolBar,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Appearance of the widget */
      appearance: {
        refine: true,
        init: "menubar"
      }
    }
  });
  qx.ui.menubar.MenuBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Creates a Collapsible widget.
   * It contains a {@link qx.ui.mobile.basic.Label Label} for the header and a {@link qx.ui.mobile.container.Composite Composite}
   * for the content.
   *
   * The visibility of the content composite toggles when user taps on header.
   *
   * *Example*
   *
   * Here is an example of how to use the widget.
   *
   * <pre class='javascript'>
   *  var collapsible = new qx.ui.mobile.container.Collapsible("Collapsible Header");
   *  collapsible.setCombined(false);
   *  collapsible.setCollapsed(false);
   *
   *  var label = new qx.ui.mobile.basic.Label("This is the content of the Collapsible.");
   *  collapsible.add(label);
   *
   * </pre>
   *
   */
  qx.Class.define("qx.ui.mobile.container.Collapsible", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
    * @param title {String?} the text which should be displayed in the Collapsible's header label.
    */
    construct: function construct(title) {
      qx.ui.mobile.core.Widget.constructor.call(this);
      this._header = this._createHeader();

      this._header.addCssClass("collapsible-header");

      this._header.addListener("tap", this.toggleCollapsed, this);

      this.setTitle(title);
      this._content = this._createContent();

      this._content.addCssClass("collapsible-content");

      this._add(this._header);

      this._add(this._content);

      this.initCollapsed();
      this.initCombined();
      this.addCssClass("gap");
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "collapsible"
      },

      /** The collapsed state of this widget. */
      collapsed: {
        check: "Boolean",
        init: true,
        nullable: false,
        apply: "_applyCollapsed",
        event: "changeCollapsed"
      },

      /** Controls whether the Collapsible's content
          should be visually associated with its headers. */
      combined: {
        check: "Boolean",
        init: true,
        apply: "_applyCombined"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _header: null,
      _content: null,

      /**
      * Adds a new child widget to the Collapsible's content composite.
      * @param child {qx.ui.mobile.core.Widget} the widget to add.
      * @param layoutProperties {Map?} (default:null) Optional layout data for widget.
      */
      add: function add(child, layoutProperties) {
        if (child && this._content instanceof qx.ui.mobile.container.Composite) {
          this._content.add(child, layoutProperties);
        }
      },

      /**
      * Setter for the Collapsible's header title.
      * @param title {String} the Collapsible's title.
      */
      setTitle: function setTitle(title) {
        if (title && this._header instanceof qx.ui.mobile.basic.Label) {
          this._header.setValue(title);
        }
      },

      /**
      * Getter for the Collapsible's header label.
      * @return {qx.ui.mobile.basic.Label} the header.
      */
      getHeader: function getHeader() {
        return this._header;
      },

      /**
      * Getter for the Collapsible's content composite.
      * @return {qx.ui.mobile.container.Composite} the content composite.
      */
      getContent: function getContent() {
        return this._content;
      },

      /**
      * Factory method for the Collapsible's header.
      * @return {qx.ui.mobile.basic.Label} the label which represents the header.
      */
      _createHeader: function _createHeader() {
        var header = new qx.ui.mobile.basic.Label();
        header.setAnonymous(false);
        header.setActivatable(true);
        return header;
      },

      /**
      * Factory method for the Collapsible's content.
      * @return {qx.ui.mobile.container.Composite} the content composite.
      */
      _createContent: function _createContent() {
        return new qx.ui.mobile.container.Composite();
      },
      // property apply
      _applyCollapsed: function _applyCollapsed(value, old) {
        if (value === true) {
          this._content.exclude();

          this.addCssClass("collapsed");
        } else {
          this._content.show();

          this.removeCssClass("collapsed");
        }
      },
      // property apply
      _applyCombined: function _applyCombined(value, old) {
        if (value === true) {
          this.addCssClass("combined");
        } else {
          this.removeCssClass("combined");
        }
      }
    },
    destruct: function destruct() {
      this._header.removeListener("tap", this.toggleCollapsed, this);

      this._disposeObjects("_header", "_content");
    }
  });
  qx.ui.mobile.container.Collapsible.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Objects which are used as delegates for the {@link qx.ui.mobile.container.Scroll#delegate} may
   * implement any of the methods described in this interface. The delegate does
   * not need to implement all the methods of this interface.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * actually implemented.
   */
  qx.Interface.define("qx.ui.mobile.container.IScrollDelegate", {
    members: {
      /**
       * Calculates the scroll offset if container scrolls to a widget/element through <code>scrollToElement()|scrollToWidget()</code>.
       *
       * @return {Array} an array with x,y offset.
       */
      getScrollOffset: function getScrollOffset() {}
    }
  });
  qx.ui.mobile.container.IScrollDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.bom.AnimationFrame": {},
      "qx.ui.mobile.container.Scroll": {},
      "qx.bom.element.Style": {},
      "qx.ui.mobile.list.List": {},
      "qx.Bootstrap": {},
      "qx.util.DisposeUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   *
   * The picker widget gives the user the possibility to select a value out of an array
   * of values. The picker widget can be added to a {@link qx.ui.mobile.dialog.Popup} or to any other container.
   *
   * The picker widget is able to display multiple picker slots, for letting the user choose
   * several values at one time, in one single control.
   *
   * You can add an array with objects which contain the keys <code>title</code>, a <code>subtitle</code> or an <code>image</code> (all optional).
   *
   * <pre>
   * var picker = new qx.ui.mobile.control.Picker();
   * picker.setHeight(200);
   * picker.addListener("changeSelection", function(evt) {
   *   var data = evt.getData();
   * },this);
   *
   * var slotData1 = [{title:"Windows Phone"}, {title:"iOS",subtitle:"Version 7.1"}, {title:"Android"}];
   * var slotData2 = [{title:"Tablet"}, {title:"Smartphone"}, {title:"Phablet"}];
   *
   * picker.addSlot(new qx.data.Array(slotData1));
   * picker.addSlot(new qx.data.Array(slotData2));
   * </pre>
   *
   */
  qx.Class.define("qx.ui.mobile.control.Picker", {
    extend: qx.ui.mobile.container.Composite,
    construct: function construct() {
      qx.ui.mobile.container.Composite.constructor.call(this);
      this._pickerModel = new qx.data.Array();
      this._slots = new qx.data.Array();
      this.addListener("appear", this._onAppear, this);
      this.initVisibleItems();
    },
    events: {
      /**
       * Fired when the selection of a slot has changed.
       * Example:
       * <code> {
       *   index: 0,
       *   item: [Object],
       *   slot: 0
       * }</code>
       */
      changeSelection: "qx.event.type.Data"
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "picker"
      },

      /**
      * Controls how much visible items are shown inside the picker.
      */
      visibleItems: {
        init: 5,
        check: [3, 5, 7, 9],
        apply: "_applyVisibleItems"
      },

      /**
      * Controls the picker height.
      */
      height: {
        init: 200,
        check: "Number"
      }
    },
    members: {
      _slots: null,
      _pickerModel: null,

      /**
      * Handler for <code>appear</code> event of this widget.
      */
      _onAppear: function _onAppear() {
        var itemHeight = this._calcItemHeight();

        this._slots.forEach(function (slot, index) {
          qx.bom.AnimationFrame.request(function () {
            slot.container.scrollTo(0, slot.selectedIndex * itemHeight);
          });
        }, this);
      },
      // property apply
      _applyVisibleItems: function _applyVisibleItems(value) {
        this._setAttribute("data-items", value);
      },

      /**
      * Returns the internal used picker model which contains one or more picker slot models.
      * @return {qx.data.Array} the picker model.
      */
      getModel: function getModel() {
        return this._pickerModel;
      },

      /**
       * Creates a picker slot.
       * @param slotModel {qx.data.Array} the picker slot model.
       * @param slotIndex {Number} the index of this slot.
       * @param delegate {qx.ui.mobile.list.IListDelegate?null} the list delegate object for this slot list.
       * @return {qx.ui.mobile.container.Scroll} the picker slot as a scroll container.
       */
      _createPickerSlot: function _createPickerSlot(slotModel, slotIndex, delegate) {
        var scrollContainer = new qx.ui.mobile.container.Scroll({
          "snap": ".list-item",
          "vScrollbar": false
        });
        scrollContainer.setWaypointsY([".list-item"]);
        qx.bom.element.Style.set(scrollContainer.getContentElement(), "height", this.getHeight() + "px");
        var slot = {
          container: scrollContainer,
          selectedIndex: 0
        };

        this._slots.push(slot);

        scrollContainer.addListener("waypoint", this._onWaypoint, {
          self: this,
          slot: slot,
          slotIndex: slotIndex,
          slotModel: slotModel
        });
        var list = new qx.ui.mobile.list.List(delegate);
        list.setItemHeight(this._calcItemHeight());
        list.addListener("changeSelection", this._onChangeSelection, {
          self: this,
          slotIndex: slotIndex
        });
        list.setModel(slotModel);
        var slotWrapper = new qx.ui.mobile.container.Composite(); // Generate placeholder items at before and after picker data list,
        // for making sure the first and last item can be scrolled
        // to the center of the picker.

        var placeholderItemCount = Math.floor(this.getVisibleItems() / 2);

        for (var i = 0; i < placeholderItemCount; i++) {
          slotWrapper.add(this._createPlaceholderItem());
        }

        slotWrapper.add(list);

        for (var j = 0; j < placeholderItemCount; j++) {
          slotWrapper.add(this._createPlaceholderItem());
        }

        scrollContainer.add(slotWrapper);
        this.add(scrollContainer);
        scrollContainer.refresh();
        return scrollContainer;
      },

      /**
      * Creates a placeholder list item, for making sure the selected item is vertically centered.
      * @return {qx.ui.mobile.container.Composite} the placeholder list item.
      */
      _createPlaceholderItem: function _createPlaceholderItem() {
        var placeholderItem = new qx.ui.mobile.container.Composite();
        qx.bom.element.Style.set(placeholderItem.getContentElement(), "minHeight", this._calcItemHeight() + "px");
        placeholderItem.addCssClass("list-item");
        placeholderItem.addCssClass("placeholder-item");
        return placeholderItem;
      },

      /**
      * Calculates the item height of a picker item.
      * @return {Number} height of the picker item.
      */
      _calcItemHeight: function _calcItemHeight() {
        return this.getHeight() / this.getVisibleItems();
      },

      /**
      * Handler for <code>changeSelection</code> event on picker list.
      * @param evt {qx.event.type.Data} the events data.
      */
      _onChangeSelection: function _onChangeSelection(evt) {
        qx.Bootstrap.bind(this.self.setSelectedIndex, this.self, this.slotIndex, evt.getData()).call();
      },

      /**
      * Handler for <code>waypoint</code> event on scroll container.
      * @param evt {qx.event.type.Data} the waypoint data.
      */
      _onWaypoint: function _onWaypoint(evt) {
        var elementIndex = evt.getData().element;
        this.slot.selectedIndex = elementIndex;
        this.self.fireDataEvent("changeSelection", {
          index: elementIndex,
          item: this.slotModel.getItem(elementIndex),
          slot: this.slotIndex
        });
      },

      /**
      * Getter for the selectedIndex of a picker slot, identified by its index.
      * @param slotIndex {Integer} the index of the target picker slot.
      * @return {Integer} the index of the target picker slot, or null if slotIndex is unknown.
      */
      getSelectedIndex: function getSelectedIndex(slotIndex) {
        return this._slots.getItem(slotIndex).selectedIndex;
      },

      /**
       * Setter for the selectedIndex of a picker slot, identified by its index.
       * @param slotIndex {Integer} the index of the target picker slot.
       * @param selectedIndex {Integer} the selectedIndex of the slot.
       */
      setSelectedIndex: function setSelectedIndex(slotIndex, selectedIndex) {
        var slot = this._slots.getItem(slotIndex);

        slot.selectedIndex = selectedIndex;

        if (this.isVisible()) {
          slot.container.scrollTo(0, selectedIndex * this._calcItemHeight());
        }
      },

      /**
       * Returns the picker slot count, added to this picker.
       * @return {Integer} count of picker slots.
       */
      getSlotCount: function getSlotCount() {
        return this._pickerModel.getLength();
      },

      /**
       * Adds an picker slot to the end of the array.
       * @param slotModel {qx.data.Array} the picker slot model to display.
       * @param delegate {qx.ui.mobile.list.IListDelegate?null} the list delegate object for this slot.
       */
      addSlot: function addSlot(slotModel, delegate) {
        if (slotModel !== null && slotModel instanceof qx.data.Array) {
          this._pickerModel.push(slotModel);

          var slotIndex = this._pickerModel.length - 1;

          var scrollContainer = this._createPickerSlot(slotModel, slotIndex, delegate);

          slotModel.addListener("changeBubble", this._onSlotDataChange, scrollContainer);
          slotModel.addListener("change", this._onSlotDataChange, scrollContainer);
        }
      },

      /**
       * Removes the picker slot at the given slotIndex.
       * @param slotIndex {Integer} the index of the target picker slot.
       */
      removeSlot: function removeSlot(slotIndex) {
        if (this._pickerModel.length > slotIndex && slotIndex > -1) {
          var slotModel = this._pickerModel.getItem(slotIndex);

          var scrollContainer = this._slots.getItem(slotIndex).container;

          slotModel.removeListener("changeBubble", this._onSlotDataChange, scrollContainer);
          slotModel.removeListener("change", this._onSlotDataChange, scrollContainer);
          qx.util.DisposeUtil.destroyContainer(scrollContainer);

          this._pickerModel.removeAt(slotIndex);

          this._slots.removeAt(slotIndex);
        }
      },

      /**
      * Handles the <code>changeBubble</code> and <codechange></code> event on a picker slot model.
      */
      _onSlotDataChange: function _onSlotDataChange() {
        window.setTimeout(function () {
          this.refresh();
        }.bind(this), 0);
      }
    },
    destruct: function destruct() {
      this._pickerModel.dispose();

      this._slots.dispose();

      qx.util.DisposeUtil.destroyContainer(this);
    }
  });
  qx.ui.mobile.control.Picker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.basic.Atom": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.basic.Image": {
        "construct": true
      },
      "qx.bom.element.Animation": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The widget displays a busy indicator.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var busyIndicator = new qx.ui.mobile.dialog.BusyIndicator("Please wait");
   *   this.getRoot().add(busyIndicator);
   * </pre>
   *
   * This example create a widget to display the busy indicator.
   */
  qx.Class.define("qx.ui.mobile.dialog.BusyIndicator", {
    extend: qx.ui.mobile.basic.Atom,

    /**
     * @param label {String} Label to use
     */
    construct: function construct(label) {
      // the image passed as second argument is a blank 1px transparent png
      qx.ui.mobile.basic.Atom.constructor.call(this, label, qx.ui.mobile.basic.Image.PLACEHOLDER_IMAGE);
      this.addListener("appear", this._onAppear, this);
      this.addListener("disappear", this._onDisappear, this);
    },
    properties: {
      /**
       * The spinner css class to use.
       */
      spinnerClass: {
        apply: "_applySpinnerClass",
        nullable: false,
        check: "String",
        init: "spinner"
      }
    },
    statics: {
      SPINNER_ANIMATION: null
    },
    members: {
      __animationHandle: null,

      /**
       * Listener for appear event.
       */
      _onAppear: function _onAppear() {
        this.__animationHandle = qx.bom.element.Animation.animate(this.getIconWidget().getContainerElement(), qx.ui.mobile.dialog.BusyIndicator.SPINNER_ANIMATION);
      },

      /**
       * Handler for disappear event.
       */
      _onDisappear: function _onDisappear() {
        this.__animationHandle.stop();
      },
      // overridden
      _createIconWidget: function _createIconWidget(iconUrl) {
        var iconWidget = qx.ui.mobile.dialog.BusyIndicator.prototype._createIconWidget.base.call(this, iconUrl);

        iconWidget.addCssClass(this.getSpinnerClass());
        return iconWidget;
      },
      // property apply
      _applySpinnerClass: function _applySpinnerClass(value, old) {
        if (old) {
          this.getIconWidget().removeCssClass(old);
        }

        if (value) {
          this.getIconWidget().addCssClass(value);
        }
      }
    },
    destruct: function destruct() {
      this.removeListener("appear", this._onAppear, this);
      this.removeListener("disappear", this._onDisappear, this);

      if (this.__animationHandle) {
        this.__animationHandle.stop();
      }

      this.__animationHandle = null;
    },
    defer: function defer() {
      qx.ui.mobile.dialog.BusyIndicator.SPINNER_ANIMATION = {
        duration: 750,
        timing: "linear",
        origin: "center center",
        repeat: "infinite",
        keyFrames: {
          0: {
            rotate: "0deg"
          },
          100: {
            rotate: "359deg"
          }
        }
      };
    }
  });
  qx.ui.mobile.dialog.BusyIndicator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.bom.client.PhoneGap": {},
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.dialog.Popup": {},
      "qx.core.Init": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.dialog.BusyIndicator": {},
      "qx.ui.mobile.basic.Label": {},
      "qx.ui.mobile.form.TextField": {},
      "qx.ui.mobile.form.Button": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "phonegap": {
          "className": "qx.bom.client.PhoneGap"
        },
        "phonegap.notification": {
          "className": "qx.bom.client.PhoneGap"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * Very basic dialog manager. Displays a native alert or confirm dialog if
   * the application is running in a PhoneGap environment. For debugging in a browser
   * it displays the browser <code>alert</code> or <code>confirm</code> dialog. In the near
   * future this should be replaced by dialog widgets.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *    var buttons = [];
   *    buttons.push(qx.locale.Manager.tr("OK"));
   *    buttons.push(qx.locale.Manager.tr("Cancel"));
   *    var title = "Delete item";
   *    var text = "Do you want to delete the item?"
   *    qx.ui.mobile.dialog.Manager.getInstance().confirm(title, text, function(index) {
   *      if (index==1) {
   *        // delete the item
   *      }
   *    }, this, buttons);
   * </pre>
   *
   * This example displays a confirm dialog and defines a button click handler.
   */
  qx.Class.define("qx.ui.mobile.dialog.Manager", {
    extend: qx.core.Object,
    type: "singleton",

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      INPUT_DIALOG: 1,
      MESSAGE_DIALOG: 2,
      WARNING_DIALOG: 3,
      ERROR_DIALOG: 4,
      WAITING_DIALOG: 5
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Displays an alert box. When the application is running in a PhoneGap
       * environment, a native alert box is shown. When debugging in a browser, a
       * browser alert is shown.
       *
       * @param title {String} The title of the alert box
       * @param text {String} The text to display in the alert box
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed
       * @param scope {Object} The scope of the handler
       * @param button {String} The button title
       * @return {qx.ui.mobile.dialog.Popup|Object} a reference to an alert dialog
       *          instance. An <code>Object</code>, if environment is
       *          <code>phonegap</code>, or a {@link qx.ui.mobile.dialog.Popup}
       *          if not.
       * @lint ignoreDeprecated(alert)
       */
      alert: function alert(title, text, handler, scope, button) {
        // TOOD : MOVE THIS TO PHONEGAP CLASS
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("phonegap.notification")) {
          var callback = function callback() {
            if (handler) {
              handler.call(scope);
            }
          };

          var button = this.__processDialogButtons(button);

          return navigator.notification.alert(text, callback, title, button);
        } else {
          return this.__showNonNativeDialog(title, text, handler, scope, [button], qx.ui.mobile.dialog.Manager.MESSAGE_DIALOG);
        }
      },

      /**
       * Displays a confirm box. When the application is running in a PhoneGap
       * environment, a native confirm box is shown. When debugging in a browser, a
       * browser confirm is shown.
       *
       * @param title {String} The title of the confirm box
       * @param text {String} The text to display in the confirm box
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 0.
       * @param scope {Object} The scope of the handler
       * @param buttons {String[]} Each text entry of the array represents a button and
       *     its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @lint ignoreDeprecated(confirm)
       */
      confirm: function confirm(title, text, handler, scope, buttons) {
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("phonegap.notification")) {
          var callback = function callback(index) {
            handler.call(scope, index - 1);
          };

          var buttons = this.__processDialogButtons(buttons);

          return navigator.notification.confirm(text, callback, title, buttons);
        } else {
          return this.__showNonNativeDialog(title, text, handler, scope, buttons, qx.ui.mobile.dialog.Manager.MESSAGE_DIALOG);
        }
      },

      /**
       * Displays an input dialog.
       *
       * @param title {String} The title of the input dialog.
       * @param text {String} The text to display in the input dialog.
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 1.
       * @param scope {Object} The scope of the handler
       * @param buttons {String[]} Each text entry of the array represents a button and
       *     its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @lint ignoreDeprecated(confirm)
       */
      input: function input(title, text, handler, scope, buttons) {
        return this.__showNonNativeDialog(title, text, handler, scope, buttons, qx.ui.mobile.dialog.Manager.INPUT_DIALOG);
      },

      /**
       * Displays an error dialog. When the application is running in an PhoneGap
       * environment, a native error dialog is shown. For debugging in a browser, a
       * browser confirm is shown.
       *
       * @param title {String} The title of the error dialog.
       * @param text {String} The text to display in the error dialog.
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 1.
       * @param scope {Object} The scope of the handler
       * @param button {String} The text entry represents a button and its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @lint ignoreDeprecated(confirm)
       */
      error: function error(title, text, handler, scope, button) {
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("phonegap.notification")) {
          var callback = function callback() {
            if (handler) {
              handler.call(scope);
            }
          };

          var button = this.__processDialogButtons(button);

          return navigator.notification.alert(text, callback, title, button);
        } else {
          return this.__showNonNativeDialog(title, text, handler, scope, button, qx.ui.mobile.dialog.Manager.ERROR_DIALOG);
        }
      },

      /**
       * Displays a warning dialog. When the application is running in an PhoneGap
       * environment, a native warning dialog is shown. For debugging in a browser, a
       * browser confirm is shown.
       *
       * @param title {String} The title of the warning dialog.
       * @param text {String} The text to display in the warning dialog.
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 1.
       * @param scope {Object} The scope of the handler
       * @param button {String} The text entry represents a button and its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @lint ignoreDeprecated(confirm)
       */
      warning: function warning(title, text, handler, scope, button) {
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("phonegap.notification")) {
          var callback = function callback() {
            if (handler) {
              handler.call(scope);
            }
          };

          var button = this.__processDialogButtons(button);

          return navigator.notification.alert(text, callback, title, button);
        } else {
          return this.__showNonNativeDialog(title, text, handler, scope, button, qx.ui.mobile.dialog.Manager.WARNING_DIALOG);
        }
      },

      /**
       * Displays a waiting dialog.
       *
       * @param title {String} The title of the waiting dialog.
       * @param text {String} The text to display in the waiting dialog.
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 1.
       * @param scope {Object} The scope of the handler
       * @param buttons {String[]} Each text entry of the array represents a button and
       *     its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @lint ignoreDeprecated(confirm)
       */
      wait: function wait(title, text, handler, scope, buttons) {
        return this.__showNonNativeDialog(title, text, handler, scope, buttons, qx.ui.mobile.dialog.Manager.WAITING_DIALOG);
      },

      /**
       * Processes the dialog buttons. Converts them to PhoneGap compatible strings.
       *
       * @param buttons {String[]} Each text entry of the array represents a button and
       *     its title
       * @return {String} The concatenated, PhoneGap compatible, button string
       */
      __processDialogButtons: function __processDialogButtons(buttons) {
        if (buttons) {
          if (buttons instanceof Array) {
            buttons = buttons.join(",");
          } else {
            buttons = "" + buttons;
          }
        }

        return buttons;
      },

      /**
       * Shows a dialog widget.
       *
       * @param title {String} The title of the dialog.
       * @param text {String} The text to display in the dialog.
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 1.
       * @param scope {Object} The scope of the handler
       * @param buttons {String[]} Each text entry of the array represents a button and
       *     its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @param dialogType {Integer} One of the static dialog types.
       */
      __showNonNativeDialog: function __showNonNativeDialog(title, text, handler, scope, buttons, dialogType) {
        var widget = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox().set({
          alignY: "middle"
        }));
        var dialog = new qx.ui.mobile.dialog.Popup(widget);
        dialog.setModal(true);
        dialog.setTitle(title); // prevent the back action until the dialog is visible

        var onBackButton = function onBackButton(evt) {
          if (dialog.isVisible() && !!evt.getData()) {
            evt.preventDefault();
          }
        };

        dialog.addListener("changeVisibility", function (evt) {
          var application = qx.core.Init.getApplication();

          if (evt.getData() === "visible") {
            application.addListener("back", onBackButton, this);
          } else {
            application.removeListener("back", onBackButton, this);
          }
        });

        if (dialogType == qx.ui.mobile.dialog.Manager.WAITING_DIALOG) {
          var waitingWidget = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox().set({
            alignX: "center"
          }));
          widget.add(waitingWidget);
          waitingWidget.add(new qx.ui.mobile.dialog.BusyIndicator(text));
        } else {
          var labelWidget = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox().set({
            alignX: "center"
          }));
          labelWidget.add(new qx.ui.mobile.basic.Label(text));
          labelWidget.addCssClass("gap");
          widget.add(labelWidget);

          if (dialogType == qx.ui.mobile.dialog.Manager.INPUT_DIALOG) {
            var inputWidget = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox().set({
              alignX: "center"
            }));
            inputWidget.addCssClass("gap");
            var inputText = new qx.ui.mobile.form.TextField();
            inputWidget.add(inputText);
            widget.add(inputWidget);
          }

          var buttonContainer = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox().set({
            alignX: "center"
          }));
          buttonContainer.addCssClass("gap");

          for (var i = 0, l = buttons.length; i < l; i++) {
            var button = new qx.ui.mobile.form.Button(buttons[i]);
            /* see the comment in android.css for width: 0 for toolbar-button class*/

            button.addCssClass('dialog-button');
            buttonContainer.add(button, {
              flex: 1
            });

            var callback = function (index) {
              return function () {
                dialog.hide();

                if (handler) {
                  handler.call(scope, index, inputText ? inputText.getValue() : null);
                }

                dialog.destroy();
              };
            }(i);

            button.addListener("tap", callback);
          }

          widget.add(buttonContainer);
        }

        dialog.show();

        if (inputText) {
          inputText.getContainerElement().focus();
        }

        return dialog;
      }
    }
  });
  qx.ui.mobile.dialog.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Creates a HTML canvas widget in your mobile application.
   *
   * *Example*
   *
   * Here is an example of how to use the canvas widget.
   *
   * <pre class='javascript'>
   * var canvas = new qx.ui.mobile.embed.Canvas();
   *
   * canvas.setWidth(150);
   * canvas.setHeight(150);
   * this.getContent().add(canvas);
   *
   * var ctx = canvas.getContext2d();
   * ctx.strokeStyle = '#3D72C9';
   * ctx.beginPath();
   * ctx.arc(75,85,50,0,Math.PI*2,true);
   * ctx.moveTo(110,85);
   * ctx.arc(75,85,35,0,Math.PI,false);
   * ctx.moveTo(65,75);
   * ctx.arc(60,75,5,0,Math.PI*2,true);
   * ctx.moveTo(95,75);
   * ctx.arc(90,75,5,0,Math.PI*2,true);
   * ctx.stroke();
   * </pre>
   *
   */
  qx.Class.define("qx.ui.mobile.embed.Canvas", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     */
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "canvas";
      },

      /**
       * Get the canvas element [<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvas">W3C-HMTL5</a>]
       *
       * @return {Element} The canvas DOM element.
       */
      getCanvas: function getCanvas() {
        return this.getContainerElement();
      },

      /**
       * Set the width attribute of the canvas element. This property controls the
       * size of the canvas coordinate space.
       *
       * @param width {Integer} canvas width
       */
      setWidth: function setWidth(width) {
        this.getContainerElement().width = width;
      },

      /**
       * Get the width attribute of the canvas element
       *
       * @return {Integer} canvas width
       */
      getWidth: function getWidth() {
        return this.getContainerElement().width;
      },

      /**
       * Set the height attribute of the canvas element. This property controls the
       * size of the canvas coordinate space.
       *
       * @param height {Integer} canvas height
       */
      setHeight: function setHeight(height) {
        this.getContainerElement().height = height;
      },

      /**
       * Get the height attribute of the canvas element
       *
       * @return {Integer} canvas height
       */
      getHeight: function getHeight() {
        return this.getContainerElement().height;
      },

      /**
       * Get the canvas' 2D rendering context
       * [<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasrenderingcontext2d">W3C-HTML5</a>].
       * All drawing operations are performed on this context.
       *
       * @return {CanvasRenderingContext2D} The 2D rendering context.
       */
      getContext2d: function getContext2d() {
        return this.getContainerElement().getContext("2d");
      }
    }
  });
  qx.ui.mobile.embed.Canvas.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.renderer.Single": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.TextArea": {},
      "qx.bom.client.Scroll": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.form.Row": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * SinglePlaceholder is a class used to render forms into a mobile page.
   * It presents a label into the placeholder of the form elements
   *
   */
  qx.Class.define("qx.ui.mobile.form.renderer.SinglePlaceholder", {
    extend: qx.ui.mobile.form.renderer.Single,

    /**
     * @param form {qx.ui.mobile.form.Form} The target form of this renderer
     */
    construct: function construct(form) {
      qx.ui.mobile.form.renderer.Single.constructor.call(this, form);
      this.removeCssClass("single");
      this.addCssClass("single-placeholder");
    },
    members: {
      // override
      addItems: function addItems(items, names, title) {
        if (title != null) {
          this._addGroupHeader(title);
        }

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i];
          var name = names[i];

          if (item instanceof qx.ui.mobile.form.TextArea) {
            if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
              this._addToScrollContainer(item, name);
            } else {
              this._addRow(item, name, new qx.ui.mobile.layout.VBox());
            }
          } else {
            if (item.setPlaceholder === undefined) {
              this._addRow(item, name, new qx.ui.mobile.layout.HBox());
            } else {
              var row = new qx.ui.mobile.form.Row(new qx.ui.mobile.layout.HBox());
              item.setPlaceholder(name);
              row.add(item, {
                flex: 1
              });

              this._add(row);
            }
          }

          if (!item.isValid()) {
            this.showErrorForItem(item);
          }
        }
      }
    }
  });
  qx.ui.mobile.form.renderer.SinglePlaceholder.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Objects which are used as delegates for the {@link qx.ui.mobile.list.List#delegate} may
   * implement any of the methods described in this interface. The delegate does
   * not need to implement all the methods of this interface. If a method is not
   * implemented the {@link qx.ui.mobile.list.provider.Provider} provides a default
   * implementation.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * actually implemented.
   */
  qx.Interface.define("qx.ui.mobile.list.IListDelegate", {
    members: {
      /**
       * Configure the list item renderer with the given data. Mandatory method.
       * At least this method has to be defined for the delegate.
       *
       * @param item {qx.ui.mobile.list.renderer.Abstract} Instance of list item renderer to modify
       * @param data {var} The data of the row. Can be used to configure the given item.
       * @param row {Integer} The row index.
       */
      configureItem: function configureItem(item, data, row) {},

      /**
       * Creates an instance of the item renderer to use.
       *
       * @return {qx.ui.mobile.list.renderer.Abstract} An instance of the item renderer.
       */
      createItemRenderer: function createItemRenderer() {}
    }
  });
  qx.ui.mobile.list.IListDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.progressive.structure.Default": {
        "construct": true
      },
      "qx.ui.progressive.State": {},
      "qx.event.Timer": {},
      "qx.ui.core.queue.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * <i>Progressive</i>.
   *
   * Follow progressive instructions provided by a data model.  A variable
   * number of instructions are executed at one time, after which control is
   * returned briefly to the browser.  This allows browser rendering between
   * batches of instructions, improving the visual experience.
   *
   * <i>Progressive</i> may be used for various purposes.  Two predefined
   * purposes for which "renderers" are provided, are a progressively-rendered
   * table which allows variable row height, and a program load/initialization
   * renderer with progress bar.  (Note that the term "renderer" is interpreted
   * quite broadly.  A renderer needn't actually render; rather it is just some
   * set of activities that takes place at one time, e.g a row of table data or
   * a single widget added to the document or a sending a request to a server,
   * etc.)
   */
  qx.Class.define("qx.ui.progressive.Progressive", {
    extend: qx.ui.container.Composite,

    /**
     * @param structure {qx.ui.progressive.structure.Abstract}
     *   The structure of the Progressive pane.
     */
    construct: function construct(structure) {
      qx.ui.container.Composite.constructor.call(this, new qx.ui.layout.VBox()); // Create an object in which we'll track renderers that have been added

      this.__renderer = {}; // Prepare to have our pane structure added to us.

      this.set({
        backgroundColor: "white"
      }); // If no structure is provided...

      if (!structure) {
        // ... then create a default one.
        structure = new qx.ui.progressive.structure.Default();
      } // Prepare our pane structure


      this.__structure = structure;
      structure.applyStructure(this); // We've not yet done our initial render

      this.__bInitialRenderComplete = false; // We're not currently rendering

      this.__bRendering = false; // Number of elements available to be rendered.  Useful for progress
      // handlers, e.g. a progress bar or status counter.

      this.__initialNumElements = 0;
    },
    events: {
      /**
       * Event fired when rendering begins.
       *
       * The event data is an object with the following members:
       * <dl>
       *   <dt>state</dt>
       *   <dd>
       *     The state object.
       *   </dd>
       *
       *   <dt>initial</dt>
       *     The number of elements that are available to be rendered
       *   <dd>
       *   </dd>
       * </dl>
       */
      "renderStart": "qx.event.type.Data",

      /**
       * Event fired when rendering ends.  The data is the state object.
       */
      "renderEnd": "qx.event.type.Data",

      /**
       * This event is fired after each batch of elements is rendered, and
       * control is about to be yielded to the browser.  This is an appropriate
       * event to listen for, to implement a progress bar.
       *
       * The event data is an object with the following members:
       * <dl>
       *   <dt>initial</dt>
       *   <dd>
       *     The number of elements that were available at the start of this
       *     rendering request.
       *   </dd>
       *
       *   <dt>remaining</dt>
       *   <dd>
       *     The number of elements still remaining to be rendered.
       *   </dd>
       * </dl>
       */
      "progress": "qx.event.type.Data",

      /**
       * This event is fired after each element is rendered.
       *
       * The event data is an object with the following members:
       * <dl>
       *   <dt>initial</dt>
       *   <dd>
       *     The number of elements that were available at the start of this
       *     rendering request.
       *   </dd>
       *
       *   <dt>remaining</dt>
       *   <dd>
       *     The number of elements still remaining to be rendered.
       *   </dd>
       *
       *   <dt>element</dt>
       *   <dd>
       *     The object, returned by the data model's getNextElement() method,
       *     that was just rendered.
       *   </dd>
       * </dl>
       *
       * Note: Unless batchSize is set to 1 or we happen to be at the end of a
       *       batch, widgets will not be rendered at this time.  Use this event
       *       for programmatically processing rendered elements, but not for
       *       such things as progress bars.  Instead, where only user-visible
       *       changes such as progress bars are being updated, use the
       *       "progress" event.
       */
      "progressDetail": "qx.event.type.Data"
    },
    properties: {
      /** The data model. */
      dataModel: {
        check: "qx.ui.progressive.model.Abstract",
        apply: "_applyDataModel"
      },

      /**
       * Number of elements to render at one time.  After this number of
       * elements has been rendered, control will be yielded to the browser
       * allowing the elements to actually be displayed.  A short-interval timer
       * will be set, to regain control to render the next batch of elements.
       */
      batchSize: {
        check: "Integer",
        init: 20
      },

      /**
       * Flush the widget queue after each batch is rendered.  This is
       * particularly relevant for such things as progressive loading, where
       * the whole purpose is to be able to see the loading progressing.
       */
      flushWidgetQueueAfterBatch: {
        check: "Boolean",
        init: false
      },

      /**
       * Delay between rendering elements. Zero is normally adequate, but
       * there are times that the user wants more time between rendering
       * some elements.
       */
      interElementTimeout: {
        check: "Integer",
        init: 0
      }
    },
    members: {
      __renderer: null,
      __bRendering: null,
      __t1: null,
      __initialNumElements: null,
      __bInitialRenderComplete: null,
      __structure: null,

      /**
       * Return the structure object
       *
       * @return {qx.ui.progressive.structure.Abstract} The structure object
       */
      getStructure: function getStructure() {
        return this.__structure;
      },

      /**
       * Add a renderer that can be referenced by the data model.
       *
       * @param name {String}
       *   Name referenced in the data model when this renderer is to be used.
       *
       * @param renderer {qx.ui.progressive.renderer.Abstract}
       *   Renderer object used if the data model references the specified name.
       *
       */
      addRenderer: function addRenderer(name, renderer) {
        this.__renderer[name] = renderer;
        renderer.join(this, name);
      },

      /**
       * Remove a previously added renderer.
       *
       * @param name {String}
       *   Remove the renderer which was assigned this name.
       *
       */
      removeRenderer: function removeRenderer(name) {
        if (!this.__renderer[name]) {
          throw new Error("No existing renderer named " + name);
        }

        delete this.__renderer[name];
      },

      /**
       * Render the elements available from the data model.  Elements are
       * rendered in batches of size {@link #batchSize}.  After each batch of
       * elements are rendered, control is returned temporarily to the
       * browser, so that actual screen updates can take place.  A timer is
       * used to regain control a short while later, in order to render the
       * next batch of element.
       *
       */
      render: function render() {
        // Prevent render calls while we're already rendering
        if (this.__bRendering) {
          return;
        }

        this.__bRendering = true;
        var state = new qx.ui.progressive.State({
          progressive: this,
          model: this.getDataModel(),
          pane: this.__structure.getPane(),
          batchSize: this.getBatchSize(),
          rendererData: this.__createStateRendererData(),
          userData: {}
        }); // Record render start time

        this.__t1 = new Date(); // Render the first batch of elements.  Subsequent batches will be via
        // timer started from this.__renderElementBatch().

        if (this.__bInitialRenderComplete) {
          // Get the starting number of elements
          this.__initialNumElements = state.getModel().getElementCount(); // Let listeners know we're beginning to render

          this.fireDataEvent("renderStart", {
            state: state,
            initial: this.__initialNumElements
          }); // Begin rendering

          this.__renderElementBatch(state);
        } else {
          // Ensure we leave enough time that 'this' has been rendered, so that
          // this.getContentElement().getDomElement() is valid and has
          // properties.  It's needed by some renderers.
          //
          // FIXME: Why isn't an event listener for "appear" an adequate delay???
          //        (It's done with a timer like this in Table's Pane too.)
          qx.event.Timer.once(function () {
            this.__initialNumElements = state.getModel().getElementCount();
            this.fireDataEvent("renderStart", {
              state: state,
              initial: this.__initialNumElements
            });

            this.__renderElementBatch(state);

            this.__bInitialRenderComplete = true;
          }, this, 10);
        }
      },

      /**
       * Called when the dataModel property is changed.
       *
       * @param value {qx.ui.progressive.model.Abstract}
       *   The new data model.
       *
       * @param old {qx.ui.progressive.model.Abstract}
       *   The old data model.
       *
       */
      _applyDataModel: function _applyDataModel(value, old) {
        if (old) {
          // Remove the old event listener
          old.removeListener("dataAvailable", this.__dataAvailable, this); // Dispose the old model

          old.dispose();
        } // Add an event listener so we know when data is available in the model


        value.addListener("dataAvailable", this.__dataAvailable, this);
      },

      /**
       * Render a batch of elements.  The batch size is determined by the
       * Progressive's batch size at the time that rendering began.  That batch
       * size was copied into the {@link qx.ui.progressive.State} object and is
       * used herein.
       *
       * @param state {qx.ui.progressive.State}
       *   The current state of rendering.
       *
       */
      __renderElementBatch: function __renderElementBatch(state) {
        var current;
        var element;
        var renderer;

        for (var i = state.getBatchSize(); i > 0; i--) {
          // Retrieve the current element
          current = state.getModel().getNextElement();

          if (!current) {
            // No more elements.  We're done.
            this.debug("Render time: " + (new Date() - this.__t1) + "ms");
            this.__bRendering = false; // Notify any progress handlers that are listening

            this.fireDataEvent("renderEnd", state); // We don't need our render state any longer

            state.dispose(); // See ya!

            return;
          } // Get the element member


          element = current.element; // Get the element's renderer

          renderer = this.__renderer[element.renderer]; // Render this element

          renderer.render(state, element); // Notify any progress detail handlers that are listening

          this.fireDataEvent("progressDetail", {
            initial: this.__initialNumElements,
            remaining: current.remaining,
            element: element
          });
        } // Notify any progress handlers that are listening


        this.fireDataEvent("progress", {
          initial: this.__initialNumElements,
          remaining: current.remaining
        }); // Flush the widget queue

        if (this.getFlushWidgetQueueAfterBatch()) {
          qx.ui.core.queue.Manager.flush();
        } // Set a timer to render the next element


        qx.event.Timer.once(function () {
          this.__renderElementBatch(state);
        }, this, this.getInterElementTimeout());
      },

      /**
       * Create the map of empty objects for use by the renderers.
       * @return {Map} renderer data map
       */
      __createStateRendererData: function __createStateRendererData() {
        var rendererData = {};

        for (var name in this.__renderer) {
          rendererData[name] = {};
        }

        return rendererData;
      },

      /**
       * Event callback for the "dataAvailable" event.
       *
       * @param e {qx.event.type.Data}
       *   A "dataAvailable" event's data contains the initial number of elements
       *
       */
      __dataAvailable: function __dataAvailable(e) {
        this.__initialNumElements = e.getData();
        this.render();
      }
    },

    /**
     */
    destruct: function destruct() {
      // For each renderer...
      for (var name in this.__renderer) {
        // ... dispose it
        this.__renderer[name].dispose();
      } // Clean up references


      this.__t1 = this.__renderer = this.__structure = null;
    }
  });
  qx.ui.progressive.Progressive.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Abstract structure definition for Progressive
   */
  qx.Class.define("qx.ui.progressive.structure.Abstract", {
    type: "abstract",
    extend: qx.core.Object,

    /**
     * The abstract structure for use by Progressive.  It defines the pane
     * container in which items are progressively rendered.
     *
     * @param pane {qx.ui.core.Widget|null}
     *   The container to use as the pane, applied to the Progressive
     *   structure.  If null, a qx.ui.core.Widget will be instantiated for
     *   use as the pane.
     */
    construct: function construct(pane) {
      qx.core.Object.constructor.call(this); // If no pane was specified. Create one.

      if (!pane) {
        this.__container = new qx.ui.core.Widget();
        this.__pane = this.__container;
      } else {
        this.__container = null;
        this.__pane = pane;
      }

      this.__pane.getContentElement().setStyle("overflowY", "auto");
    },
    members: {
      __container: null,
      __pane: null,

      /**
       * Apply the structure typically defined in the constructor to the
       * Progressive.
       *
       * @param progressive {qx.ui.progressive.Progressive}
       *   The Progressive to which the structure is to be applied.
       */
      applyStructure: function applyStructure(progressive) {
        throw new Error("applyStructure() is abstract");
      },

      /**
       * Get the pane in which this Progressive renders.
       *
       * @return {qx.ui.core.Widget}
       */
      getPane: function getPane() {
        return this.__pane;
      }
    },
    destruct: function destruct() {
      if (this.__container) {
        this.__container.dispose();
      }

      this.__container = this.__pane = null;
    }
  });
  qx.ui.progressive.structure.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.structure.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.progressive.headfoot.Null": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Structure definition for Progressive
   */
  qx.Class.define("qx.ui.progressive.structure.Default", {
    extend: qx.ui.progressive.structure.Abstract,

    /**
     * The default structure for use by Progressive.  It includes a header, a
     * footer, and a pane.
     *
     * @param header {qx.ui.progressive.headfoot.Abstract|null}
     *   The heading to apply to the Progressive structure.  If null, then no
     *   header will be visible.
     *
     * @param footer {qx.ui.progressive.headfoot.Abstract|null}
     *   The footer to apply to the Progressive structure.  If null then no
     *   footer will be visible.
     *
     * @param pane {qx.ui.core.Widget|null}
     *   The container to use as the pane, applied to the Progressive
     *   structure.  If null, a qx.ui.core.Widget will be instantiated for
     *   use as the pane.
     */
    construct: function construct(header, footer, pane) {
      qx.ui.progressive.structure.Abstract.constructor.call(this, pane); // If no header was specified, use null header

      if (!header) {
        this.__nullHeader = new qx.ui.progressive.headfoot.Null();
        this.__header = this.__nullHeader;
      } else {
        this.__nullHeader = null;
        this.__header = header;
      } // If no footer was specified, use a null footer


      if (!footer) {
        this.__nullFooter = new qx.ui.progressive.headfoot.Null();
        this.__footer = this.__nullFooter;
      } else {
        this.__nullFooter = null;
        this.__footer = footer;
      }
    },
    members: {
      __header: null,
      __footer: null,
      __nullHeader: null,
      __nullFooter: null,
      // overridden
      applyStructure: function applyStructure(progressive) {
        // Tell the header/footer components who their Progressive is
        this.__header.join(progressive);

        this.__footer.join(progressive); // Add the header, pane, and footer to the Progressive.


        progressive.add(this.__header);
        progressive.add(this.getPane(), {
          flex: 1
        });
        progressive.add(this.__footer);
      },

      /**
       * Return the header
       *
       * @return {qx.ui.progressive.headfoot.Abstract}
       */
      getHeader: function getHeader() {
        return this.__header;
      },

      /**
       * Return the footer
       *
       * @return {qx.ui.progressive.headfoot.Abstract}
       */
      getFooter: function getFooter() {
        return this.__footer;
      }
    },
    destruct: function destruct() {
      if (this.__nullHeader) {
        this.__nullHeader.dispose();

        this.__nullHeader = null;
      }

      if (this.__nullFooter) {
        this.__nullFooter.dispose();

        this.__nullFooter = null;
      }

      this.__header = this.__footer = null;
    }
  });
  qx.ui.progressive.structure.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * State of rendering by Progressive.
   */
  qx.Class.define("qx.ui.progressive.State", {
    extend: qx.core.Object,

    /**
     * @param initialState {Map}
     *   Map containing these members:
     *   <dl>
     *     <dt>progressive</dt>
     *       <dd>see {@link #progressive}</dd>
     *     <dt>model</dt>
     *       <dd>see {@link #model}</dd>
     *     <dt>pane</dt>
     *       <dd>see {@link #pane}</dd>
     *     <dt>batchSize</dt>
     *       <dd>see {@link #batchSize}</dd>
     *     <dt>rendererData</dt>
     *       <dd>see {@link #rendererData}</dd>
     *     <dt>userData</dt>
     *       <dd>see {@link #userData}</dd>
     *   </dl>
     */
    construct: function construct(initialState) {
      qx.core.Object.constructor.call(this);
      this.setProgressive(initialState.progressive);
      this.setModel(initialState.model);
      this.setPane(initialState.pane);
      this.setBatchSize(initialState.batchSize);
      this.setRendererData(initialState.rendererData);
      this.setUserData(initialState.userData);
    },
    properties: {
      /**
       * The {@link qx.ui.progressive.Progressive} with which this {@link
       * State} is associated. This property should be treated as read-only.
       */
      progressive: {
        nullable: true
      },

      /**
       * The data model being used. This property should be treated as
       * read-only.
       */
      model: {
        nullable: true
      },

      /**
       * The widget in which the element data should be rendered.  This property
       * should be treated as read-only.
       */
      pane: {
        nullable: true
      },

      /**
       * How many elements are rendered at a time, before yielding to the
       * browser.  This property should be treated as read-only.
       */
      batchSize: {},

      /**
       * Add a place for renderers' private data.  If multiple renderers are
       * being used, each renderer should place its own private data in the the
       * state object area reserved for that renderer's use:
       * state.getRendererData()[element.renderer].  This property should be
       * accessed only by renderers, and all elements of the array other than a
       * renderer's own element should be treated as read-only.
       *
       * IMPORTANT NOTE:  It is the renderer's responsibility to clean up its
       *                  own mess.  If the renderer places data here, it should
       *                  also add an event listener for "renderEnd" so that it
       *                  can clean up.
       */
      rendererData: {},

      /**
       * User data.  This is useful, for example, by communication between
       * the renderStart event listener and the renderers.
       *
       * IMPORTANT NOTE:  It is the user's responsibility to clean up his
       *                  own mess.  If you place data here, you should
       *                  also add an event listener for "renderEnd" to
       *                  dispose any objects you placed here.
       */
      userData: {}
    },
    destruct: function destruct() {
      // Remove references to other objects
      this.setProgressive(null);
      this.setModel(null);
      this.setPane(null);
    }
  });
  qx.ui.progressive.State.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * The abstract class for a header or footer for use with Progressive's Table
   * renderer.
   */
  qx.Class.define("qx.ui.progressive.headfoot.Abstract", {
    type: "abstract",
    extend: qx.ui.container.Composite,
    construct: function construct() {
      qx.ui.container.Composite.constructor.call(this, new qx.ui.layout.HBox());
    },
    members: {
      __progressive: null,

      /**
       * Join this header/footer to a Progressive.  This makes the Progressive
       * object available to the header/footer through the _progressive member.
       *
       * @param progressive {qx.ui.progressive.Progressive}
       *   Progressive object to which we're being joined.
       *
       */
      join: function join(progressive) {
        this.__progressive = progressive;
      }
    },
    destruct: function destruct() {
      this.__progressive = null;
    }
  });
  qx.ui.progressive.headfoot.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.headfoot.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A null header/footer.  This is not displayed.
   */
  qx.Class.define("qx.ui.progressive.headfoot.Null", {
    extend: qx.ui.progressive.headfoot.Abstract,
    construct: function construct() {
      qx.ui.progressive.headfoot.Abstract.constructor.call(this); // We're null, so don't display.

      this.exclude();
    }
  });
  qx.ui.progressive.headfoot.Null.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.headfoot.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true
      },
      "qx.ui.basic.Atom": {
        "construct": true
      },
      "qx.theme.manager.Color": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * The standard footer used with Progressive's Table renderer, to show
   * progress of loading data into the table.
   */
  qx.Class.define("qx.ui.progressive.headfoot.Progress", {
    extend: qx.ui.progressive.headfoot.Abstract,

    /**
     * @param columnWidths {qx.ui.progressive.renderer.table.Widths}
     *   The set of widths, minimum widths, and maximum widths to be used for
     *   each of the columns in the table.
     *
     * @param labelArr {Array}
     *   Array of labels, one for each of the columns.
     *
     */
    construct: function construct(columnWidths, labelArr) {
      qx.ui.progressive.headfoot.Abstract.constructor.call(this); // Set a default height for the progress bar

      this.setHeight(16);
      this.setPadding(0);
      this.__colors = {};

      this.__linkColors();

      this.set({
        backgroundColor: this.__colors.background
      }); // Create a widget that continually increases its width for progress bar

      this.__progressBar = new qx.ui.core.Widget();

      this.__progressBar.set({
        width: 0,
        backgroundColor: this.__colors.indicatorDone
      });

      this.add(this.__progressBar); // Create a flex area between the progress bar and the percent done

      var spacer = new qx.ui.core.Widget();
      spacer.set({
        backgroundColor: this.__colors.indicatorUndone
      });
      this.add(spacer, {
        flex: 1
      }); // We also like to show progress as a percentage done string.

      this.__percentDone = new qx.ui.basic.Atom("0%");

      this.__percentDone.set({
        width: 100,
        backgroundColor: this.__colors.percentBackground,
        textColor: this.__colors.percentText
      });

      this.add(this.__percentDone); // We're initially invisible

      this.exclude();
    },
    members: {
      __total: null,
      __colors: null,
      __progressBar: null,
      __percentDone: null,
      // overridden
      _onChangeTheme: function _onChangeTheme() {
        qx.ui.progressive.headfoot.Progress.prototype._onChangeTheme.base.call(this);

        this.__linkColors();
      },

      /**
       * Helper to link the theme colors to the current class.
       */
      __linkColors: function __linkColors() {
        // link to color theme
        var colorMgr = qx.theme.manager.Color.getInstance();
        this.__colors.background = colorMgr.resolve("progressive-progressbar-background");
        this.__colors.indicatorDone = colorMgr.resolve("progressive-progressbar-indicator-done");
        this.__colors.indicatorUndone = colorMgr.resolve("progressive-progressbar-indicator-undone");
        this.__colors.percentBackground = colorMgr.resolve("progressive-progressbar-percent-background");
        this.__colors.percentText = colorMgr.resolve("progressive-progressbar-percent-text");
      },
      // overridden
      join: function join(progressive) {
        // Save the progressive handle
        qx.ui.progressive.headfoot.Progress.prototype.join.base.call(this, progressive); // Listen for the "renderStart" event, to save the number of elements on
        // the queue, and to set ourself visible

        progressive.addListener("renderStart", function (e) {
          this.__total = e.getData().initial;
          this.show();
        }, this); // Listen for the "progress" event, to update the progress bar

        progressive.addListener("progress", function (e) {
          var complete = 1.0 - e.getData().remaining / this.__total;

          var mySize = this.getBounds();

          if (mySize) {
            var barWidth = Math.floor((mySize.width - this.__percentDone.getBounds().width) * complete);
            var percent = Math.floor(complete * 100) + "%";

            if (!isNaN(barWidth)) {
              this.__progressBar.setMinWidth(barWidth);

              this.__percentDone.setLabel(percent);
            }
          }
        }, this); // Listen for the "renderEnd" event to make ourself invisible

        progressive.addListener("renderEnd", function (e) {
          this.exclude();
        }, this);
      }
    },
    destruct: function destruct() {
      this.__colors = null;

      this._disposeObjects("__progressBar", "__percentDone");
    }
  });
  qx.ui.progressive.headfoot.Progress.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.headfoot.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.basic.Atom": {
        "construct": true
      },
      "qx.ui.core.Widget": {
        "construct": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.bom.element.Scroll": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A header for a standard table.
   */
  qx.Class.define("qx.ui.progressive.headfoot.TableHeading", {
    extend: qx.ui.progressive.headfoot.Abstract,

    /**
     * @param columnWidths {qx.ui.progressive.renderer.table.Widths}
     *   The set of widths, minimum widths, and maximum widths to be used for
     *   each of the columns in the table.
     *
     * @param labelArr {Array}
     *   Array of labels, one for each of the columns.
     *
     */
    construct: function construct(columnWidths, labelArr) {
      qx.ui.progressive.headfoot.Abstract.constructor.call(this); // Save the Widths object containing all of our column widths

      this.__columnWidths = columnWidths; // Get the array of column width data

      var columnData = columnWidths.getData(); // Create a place to put labels

      this.__labels = []; // For each label...

      for (var i = 0; i < columnData.length; i++) {
        // ... create an atom to hold the label
        var label = new qx.ui.basic.Atom(labelArr[i]);
        label.setAppearance("progressive-table-header-cell"); // Add the label to this heading.

        this.add(label); // Save this label so we can resize it later

        this.__labels[i] = label;
      } // Add a spacer to take up the scroll-bar width


      var spacer = new qx.ui.core.Widget();
      spacer.set({
        height: 16,
        appearance: "progressive-table-header-cell",
        minWidth: 0,
        width: 0
      });
      this.add(spacer, {
        flex: 1
      }); // Arrange to be called when the window appears or is resized, so we
      // can set each style sheet's left and width field appropriately.

      this.addListener("resize", this._resizeColumns, this); // This layout is not connected to a widget but to this class. This class
      // must implement the method "getLayoutChildren", which must return all
      // columns (LayoutItems) which should be recalculated. The call
      // "layout.renderLayout" will call the method "renderLayout" on each
      // column data object The advantage of the use of the normal layout
      // manager is that the semantics of flex and percent are exactly the same
      // as in the widget code.

      this.__layout = new qx.ui.layout.HBox();

      this.__layout.connectToWidget(this);
    },
    properties: {
      appearance: {
        refine: true,
        init: "progressive-table-header"
      }
    },
    members: {
      __columnWidths: null,
      __bCalculateWidths: null,
      __labels: null,
      __layout: null,
      // overridden
      join: function join(progressive) {
        // Save the progressive handle
        qx.ui.progressive.headfoot.TableHeading.prototype.join.base.call(this, progressive);
      },

      /**
       * This method is required by the box layout. If returns an array of items
       * to relayout.
       * @return {Array} List of child items
       */
      getLayoutChildren: function getLayoutChildren() {
        if (this.__bCalculateWidths) {
          return this.__columnWidths.getData();
        } else {
          return qx.ui.progressive.headfoot.TableHeading.prototype.getLayoutChildren.base.call(this);
        }
      },

      /**
       * Event handler for the "resize" event.  We recalculate and set the
       * new widths of each of our columns.
       *
       * @param e {qx.event.type.Event}
       *   Ignored.
       *
       */
      _resizeColumns: function _resizeColumns(e) {
        var width = this.getBounds().width - qx.bom.element.Scroll.getScrollbarWidth(); // Compute the column widths

        this.__bCalculateWidths = true;
        var padding = {
          top: this.getPaddingTop(),
          right: this.getPaddingRight(),
          bottom: this.getPaddingBottom(),
          left: this.getPaddingLeft()
        };

        this.__layout.renderLayout(width, 100, padding);

        this.__bCalculateWidths = false; // Get the column data

        var columnData = this.__columnWidths.getData(); // Get the column width data.  For each label...


        for (var i = 0; i < columnData.length; i++) {
          // ... reset the width of the corresponding column (label)
          this.__labels[i].setWidth(columnData[i].getComputedWidth());
        }
      }
    },
    destruct: function destruct() {
      this.__columnWidths = this.__labels = null;

      this._disposeObjects("_layout");
    }
  });
  qx.ui.progressive.headfoot.TableHeading.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Data Model for Progressive renderer.
   */
  qx.Class.define("qx.ui.progressive.model.Abstract", {
    type: "abstract",
    extend: qx.core.Object,
    events: {
      /**
       * This event is fired when new data has been added to the data model.  It
       * typically informs Progressive to begin its rendering process.
       *
       * The event data is an integer: the number of elements now available on
       * the element queue.
       */
      "dataAvailable": "qx.event.type.Data"
    },
    members: {
      /**
       * Get the number of data elements currently available.
       *
       * @throws {Error} An error if this method is called.
       * @return {Integer}
       */
      getElementCount: function getElementCount() {
        throw new Error("getElementCount() is abstract");
      },

      /**
       * Get the next available element from the data model.
       *
       * @throws {Error} An error if this method is called.
       * @return {Object}
       *   The returned object must provide at least the following members:
       *   <dl>
       *     <dt>
       *       renderer</dt>
       *     <dd>
       *       The name of a renderer.  That name is used by {@link
       *       qx.ui.progressive.Progressive} to select the renderer to be used
       *       to render this element.  The name should match one provided to
       *       {@link qx.ui.progressive.Progressive#addRenderer}.
       *     </dd>
       *
       *     <dt>
       *       data
       *     </dt>
       *     <dd>
       *       The data to be passed to the renderer.  The data may be of any
       *       type that the renderer knows how to render.
       *     </dd>
       *   </dl>
       */
      getNextElement: function getNextElement() {
        throw new Error("getNextElement() is abstract");
      }
    }
  });
  qx.ui.progressive.model.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.model.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Data Model for Progressive renderer.
   */
  qx.Class.define("qx.ui.progressive.model.Default", {
    extend: qx.ui.progressive.model.Abstract,
    construct: function construct() {
      qx.ui.progressive.model.Abstract.constructor.call(this);
      this.__elements = [];
    },
    members: {
      __elements: null,

      /**
       * Add elements to be progressively rendered.  Each element must be an
       * object which contains at least two members: renderer (the renderer
       * name) and data.
       *
       * @param elems {Array}
       *   An array of elements to be added to the element queue
       */
      addElements: function addElements(elems) {
        // Add the new elements to our elements queue.
        this.__elements = this.__elements.concat(elems); // Tell Progressive that data is available

        this.fireDataEvent("dataAvailable", this.__elements.length);
      },

      /**
       * Add a single element to be progressively rendered.  The element must
       * be an object which contains at least two members: renderer (the
       * renderer name) and data.
       *
       * @param elem {var}
       *   An element to be added to the element queue
       */
      addElement: function addElement(elem) {
        // Add the new elements to our elements queue.
        this.__elements.push(elem); // Tell Progressive that data is available


        this.fireDataEvent("dataAvailable", this.__elements.length);
      },
      // overridden
      getElementCount: function getElementCount() {
        return this.__elements.length;
      },
      // overridden
      getNextElement: function getNextElement() {
        // Do we have any remaining elements?
        if (this.__elements.length > 0) {
          // Yup.  Give 'em the first one and remove it from our queue.
          return {
            element: this.__elements.shift(),
            remaining: this.__elements.length
          };
        }

        return null;
      }
    },
    destruct: function destruct() {
      this.__elements = null;
    }
  });
  qx.ui.progressive.model.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Abstract renderer for Progressive.
   */
  qx.Class.define("qx.ui.progressive.renderer.Abstract", {
    type: "abstract",
    extend: qx.core.Object,
    members: {
      /**
       * Render the provided element in the renderer's unique way.
       *
       * @param state {qx.ui.progressive.State}
       *   Data relevant to the current rendering session.
       *
       * @param element {Object}
       *   An object containing at least the following members:
       *   <dl>
       *     <dt>
       *       renderer</dt>
       *     <dd>
       *       The name of a renderer.  That name is used by {@link
       *       qx.ui.progressive.Progressive} to select the renderer to be used
       *       to render this element.  The name should match one provided to
       *       {@link qx.ui.progressive.Progressive#addRenderer}.
       *     </dd>
       *
       *     <dt>
       *       data
       *     </dt>
       *     <dd>
       *       The data to be passed to the renderer.  The data may be of any
       *       type that the renderer knows how to render.
       *     </dd>
       *   </dl>
       *
       */
      render: function render(state, element) {
        throw new Error("render() is abstract");
      },

      /**
       * Join this renderer to its {@link qx.ui.progressive.Progressive}.
       *
       * @param progressive {qx.ui.progressive.Progressive}
       *   The Progressive object to which we are being joined.
       *
       * @param name {String}
       *   The name by which the data model will reference this renderer.  This
       *   is important to know in order to access the appropriate member of the
       *   {@link qx.ui.progressive.State}'s renderer array.  That array is
       *   accessed from the renderer by
       *   state.getRendererData()[element.renderer] where element.renderer will
       *   be the name provided here.
       */
      join: function join(progressive, name) {// nothing to do in the default case
      }
    }
  });
  qx.ui.progressive.renderer.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.Abstract": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Function "renderer" for Progressive.
   * This is a renderer that simply calls the function provided by the data
   * element.
   */
  qx.Class.define("qx.ui.progressive.renderer.FunctionCaller", {
    extend: qx.ui.progressive.renderer.Abstract,
    members: {
      // overridden
      render: function render(state, element) {
        element.data(state.getUserData());
      }
    }
  });
  qx.ui.progressive.renderer.FunctionCaller.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Default": {
        "construct": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.theme.manager.Meta": {
        "construct": true
      },
      "qx.bom.client.Css": {
        "require": true
      },
      "qx.bom.Style": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.manager.Color": {},
      "qx.bom.Stylesheet": {},
      "qx.bom.element.Scroll": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.textoverflow": {
          "load": true,
          "className": "qx.bom.client.Css"
        },
        "css.userselect": {
          "load": true,
          "className": "qx.bom.client.Css"
        },
        "css.userselect.none": {
          "load": true,
          "className": "qx.bom.client.Css"
        },
        "qx.tableResizeDebug": {},
        "css.boxmodel": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
     qooxdoo - the new era of web development
     http://qooxdoo.org
     Copyright:
      2008 Derrell Lipman
     License:
      MIT: https://opensource.org/licenses/MIT
      See the LICENSE file in the project's top-level directory for details.
     Authors:
      * Derrell Lipman (derrell)
  ************************************************************************ */

  /**
   * Table Row renderer for Progressive.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.Row", {
    extend: qx.ui.progressive.renderer.Abstract,

    /**
     * @param columnWidths {qx.ui.progressive.renderer.table.Widths}
     *   Information that indicates how to resize each of the column widths
     */
    construct: function construct(columnWidths) {
      qx.ui.progressive.renderer.Abstract.constructor.call(this); // Save the column widths

      this.__columnWidths = columnWidths; // Create space to store renderers for each column

      this.__renderers = {}; // We need a default cell renderer to use if none is specified

      this.__defaultCellRenderer = new qx.ui.progressive.renderer.table.cell.Default(); // We don't yet know who our Progressive will be

      this.__progressive = null;
      this.__colors = {};

      this.__linkColors(); // This layout is not connected to a widget but to this class. This class
      // must implement the method "getLayoutChildren", which must return all
      // columns (LayoutItems) which should be recalculated. The call
      // "layout.renderLayout" will call the method "renderLayout" on each
      // column data object The advantage of the use of the normal layout
      // manager is that the semantics of flex and percent are exactly the same
      // as in the widget code.


      this.__layout = new qx.ui.layout.HBox();

      this.__layout.connectToWidget(this); // dynamic theme switch


      {
        qx.theme.manager.Meta.getInstance().addListener("changeTheme", this.__linkColors, this);
      }
    },
    statics: {
      /**
       * Storage for each progressive.
       *
       * @internal
       */
      __clazz: null,

      /**
       * Default row padding.
       *
       * @internal
       */
      __padding: 6,
      // modify padding parameter below too if this changes

      /**
       * Default style sheet for table cells.
       *
       * @internal
       */
      __tableCellStyleSheet: "  position: absolute;  top: 0px;  height: 100%;  overflow:hidden;" + (qx.core.Environment.get("css.textoverflow") ? qx.bom.Style.getCssName(qx.core.Environment.get("css.textoverflow")) + ':ellipsis;' : "") + "  white-space:nowrap;" + "  border-right:1px solid #f2f2f2;" + "  border-bottom:1px solid #eeeeee;" + "  padding : 0px 6px 0px 6px;" + "  cursor:default;" + "  font-size: 11px;" + "  font-family: 'Segoe UI', Corbel, Calibri, Tahoma, 'Lucida Sans Unicode', sans-serif;" + (qx.core.Environment.get("css.userselect") ? qx.bom.Style.getCssName(qx.core.Environment.get("css.userselect")) + ':' + qx.core.Environment.get("css.userselect.none") + ';' : '')
    },
    properties: {
      /** The default height of a row, if not altered by a cell renderer. */
      defaultRowHeight: {
        init: 16
      }
    },
    members: {
      __progressive: null,
      __name: null,
      __hash: null,
      __columnWidths: null,
      __renderers: null,
      __defaultCellRenderer: null,
      __colors: null,
      __layout: null,

      /**
       * Helper to link the theme colors to the current class
       */
      __linkColors: function __linkColors() {
        // link to color theme
        var colorMgr = qx.theme.manager.Color.getInstance();
        this.__colors.bgcol = [];
        this.__colors.bgcol[0] = colorMgr.resolve("progressive-table-row-background-even");
        this.__colors.bgcol[1] = colorMgr.resolve("progressive-table-row-background-odd");
      },
      // overridden
      join: function join(progressive, name) {
        // Are we already joined?
        if (this.__progressive) {
          // Yup.  Let 'em know they can't do that.
          throw new Error("Renderer is already joined to a Progressive.");
        } // Save the Progressive to which we're joined


        this.__progressive = progressive; // Save the name that Progressive knows us by

        this.__name = name; // If we haven't created style sheets for this table yet...

        var tr = qx.ui.progressive.renderer.table.Row;

        if (!tr.__clazz) {
          tr.__clazz = {};
        }

        var hash = progressive.toHashCode();

        if (!tr.__clazz[hash]) {
          // ... then do it now.
          tr.__clazz[hash] = {
            rowstylesheet: null,
            cellstylesheet: []
          };
          var stylesheet = ".qx-progressive-" + hash + "-row {" + "  width : 100%;" + "}";
          tr.__clazz[hash].rowstylesheet = qx.bom.Stylesheet.createElement(stylesheet);

          var columnData = this.__columnWidths.getData();

          for (var i = 0; i < columnData.length; i++) {
            var stylesheet = ".qx-progressive-" + hash + "-col-" + i + " {" + tr.__tableCellStyleSheet + "}";
            tr.__clazz[hash].cellstylesheet[i] = qx.bom.Stylesheet.createElement(stylesheet);
          } // Save the hash too


          this.__hash = hash; // Arrange to be called when the window appears or is resized, so we
          // can set each style sheet's left and width field appropriately.

          var pane = progressive.getStructure().getPane();
          pane.addListener("resize", this._resizeColumns, this);
        }
      },

      /**
       * Add a cell renderer for use within a row rendered by this row
       * renderer.
       *
       * @param column {Integer}
       *   The column number for which the cell renderer applies
       *
       * @param renderer {qx.ui.progressive.renderer.table.cell.Abstract}
       *   The cell renderer for the specified column.
       *
       */
      addRenderer: function addRenderer(column, renderer) {
        var columnData = this.__columnWidths.getData();

        if (column < 0 || column >= columnData.length) {
          throw new Error("Column " + column + " out of range (max: " + (columnData.length - 1) + ")");
        }

        this.__renderers[column] = renderer;
      },

      /**
       * Remove a cell renderer previously added with {@link #addRenderer}.
       *
       * @param column {Integer}
       *   The column for which the cell renderer is to be removed.
       *
       */
      removeRenderer: function removeRenderer(column) {
        var columnData = this.__columnWidths.getData();

        if (column < 0 || column >= columnData.length) {
          throw new Error("Column " + column + " out of range (max: " + (columnData.length - 1) + ")");
        }

        if (!this.__renderers[column]) {
          throw new Error("No existing renderer for column " + column);
        }

        delete this.__renderers[column];
      },
      // overridden
      render: function render(state, element) {
        var data = element.data;
        var html = [];
        var cellInfo;
        var renderer;
        var height = 0; // Initialize row counter, if necessary.  We'll use this for shading
        // alternate rows.

        if (state.getRendererData()[this.__name].end === undefined) {
          state.getRendererData()[this.__name] = {
            end: 0,
            start: 1,
            rows: 0,
            totalHeight: 0
          };
        } // Create the div for this row


        var div = document.createElement("div"); // For each cell...

        for (var i = 0; i < data.length; i++) {
          var stylesheet = "qx-progressive-" + this.__hash + "-col-" + i; // Determine what renderer to use for this column

          renderer = this.__renderers[i] || this.__defaultCellRenderer; // Specify information that cell renderer will need

          cellInfo = {
            state: state,
            rowDiv: div,
            stylesheet: stylesheet,
            element: element,
            dataIndex: i,
            cellData: data[i],
            height: height
          }; // Render this cell

          html.push(renderer.render(cellInfo)); // If this cell's height was greater than our current maximum...

          if (cellInfo.height > height) {
            // ... then it becomes our row height
            height = cellInfo.height;
          }
        }

        height = height > 0 ? height : this.getDefaultRowHeight(); // Get a reference to our renderer data

        var rendererData = state.getRendererData()[this.__name]; // Track total height so we can determine if there's a vertical scrollbar


        rendererData.totalHeight += height; // Set properties for the row div

        div.style.position = "relative";
        div.style.height = height + "px";
        div.className = "qx-progressive-" + this.__hash + "-row";
        div.innerHTML = html.join(""); // Add this row to the table

        switch (element.location) {
          case "end":
            // Determine color of row based on state of last added row
            var index = rendererData.end || 0; // Set the background color of this row

            div.style.backgroundColor = this.__colors.bgcol[index]; // Update state for next time

            rendererData.end = index == 0 ? 1 : 0; // Append our new row to the pane.

            state.getPane().getContentElement().getDomElement().appendChild(div);
            break;

          case "start":
            // Get the pane element
            var elem = state.getPane().getContentElement().getDomElement(); // Get its children array

            var children = elem.childNodes; // Are there any children?

            if (children.length > 0) {
              // Yup.  Determine color of row based on state of last added row
              var index = rendererData.start; // Set the background color of this row

              div.style.backgroundColor = this.__colors.bgcol[index]; // Update state for next time

              rendererData.start = index == 0 ? 1 : 0; // Insert our new row before the first child.

              elem.insertBefore(div, children[0]);
              break;
            } else {
              /* No children yet.  We can append our new row. */
              elem.appendChild(div);
            }

            break;

          default:
            throw new Error("Invalid location: " + element.location);
        } // Increment row count


        ++rendererData.rows;
      },

      /**
       * This method is required by the box layout. If returns an array of items
       * to relayout.
       * @return {Array} Array of column data.
       */
      getLayoutChildren: function getLayoutChildren() {
        return this.__columnWidths.getData();
      },

      /**
       * Event handler for the "resize" event.  We recalculate the
       * widths of each of the columns, and modify the stylesheet rule
       * applicable to each column, to apply the new widths.
       *
       * @param e {qx.event.type.Event}
       *   Ignored
       *
       */
      _resizeColumns: function _resizeColumns(e) {
        var pane = this.__progressive.getStructure().getPane();

        var width = pane.getBounds().width - qx.bom.element.Scroll.getScrollbarWidth(); // Get the style sheet rule name for this row

        var stylesheet = ".qx-progressive-" + this.__hash + "-row"; // Remove the style rule for this row

        var tr = qx.ui.progressive.renderer.table.Row;
        qx.bom.Stylesheet.removeRule(tr.__clazz[this.__hash].rowstylesheet, stylesheet); // Create the new rule for this row

        var rule = "width: " + width + "px;"; // Apply the new rule

        qx.bom.Stylesheet.addRule(tr.__clazz[this.__hash].rowstylesheet, stylesheet, rule); // Compute the column widths

        this.__layout.renderLayout(width, 100, {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }); // Get the column data


        var columnData = this.__columnWidths.getData(); // Reset each of the column style sheets to deal with width changes


        for (var i = 0, left = 0; i < columnData.length; i++, left += width) {
          // Get the style sheet rule name for this cell
          var stylesheet = ".qx-progressive-" + this.__hash + "-col-" + i; // Remove the style rule for this column

          var tr = qx.ui.progressive.renderer.table.Row;
          qx.bom.Stylesheet.removeRule(tr.__clazz[this.__hash].cellstylesheet[i], stylesheet); // Get this column width.

          width = columnData[i].getComputedWidth();
          {
            if (qx.core.Environment.get("qx.tableResizeDebug")) {
              this.debug("col " + i + ": width=" + width);
            }
          } // Make our width calculations box-model independent

          var inset;

          if (qx.core.Environment.get("css.boxmodel") == "content") {
            inset = qx.ui.progressive.renderer.table.Row.__padding * 2;
          } else {
            inset = -1;
          } // Create the new rule, based on calculated widths


          var widthRule = width - inset + "px;";
          var paddingRule = "0px " + qx.ui.progressive.renderer.table.Row.__padding + "px " + "0px " + qx.ui.progressive.renderer.table.Row.__padding + "px;";
          var leftRule = left + "px;";
          var rule = tr.__tableCellStyleSheet + "width: " + widthRule + "left: " + leftRule + "padding: " + paddingRule; // Apply the new rule

          qx.bom.Stylesheet.addRule(tr.__clazz[this.__hash].cellstylesheet[i], stylesheet, rule);
        }
      }
    },
    destruct: function destruct() {
      // remove dynamic theme listener
      qx.theme.manager.Meta.getInstance().removeListener("changeTheme", this.__linkColors, this);
      var name;

      for (name in this.__renderers) {
        this.__renderers[name] = null;
      } // Remove any style sheets that we had added


      var tr = qx.ui.progressive.renderer.table.Row;

      var hash = this.__progressive.toHashCode();

      if (tr.__clazz && tr.__clazz[hash]) {
        // Remove the row stylesheet
        if (tr.__clazz[hash].rowstylesheet) {
          // Get the style sheet rule name for this row
          var stylesheet = ".qx-progressive-" + this.__hash + "-row"; // Remove the style rule for this row

          var tr = qx.ui.progressive.renderer.table.Row;
          qx.bom.Stylesheet.removeRule(tr.__clazz[this.__hash].rowstylesheet, stylesheet);
        } // Remove each of the column style sheets


        if (tr.__clazz[hash].cellstylesheet) {
          for (var i = tr.__clazz[hash].cellstylesheet.length - 1; i >= 0; i--) {
            // Get the style sheet rule name for this cell
            var stylesheet = ".qx-progressive-" + this.__hash + "-col-" + i;
            var rule = tr.__clazz[this.__hash].cellstylesheet[i]; // Remove the style rule for this column

            var tr = qx.ui.progressive.renderer.table.Row;
            qx.bom.Stylesheet.removeRule(rule, stylesheet);
          }
        }
      }

      if (this.__progressive && this.__progressive.getRendererData) {
        var rendererData = this.__progressive.getRendererData();

        if (rendererData && rendererData[this.__name] && rendererData[this.__name].end !== undefined) {
          rendererData[this.__name] = null;
        }
      }

      this.__colors = this.__renderers = this.__progressive = this.__columnWidths = null;

      this._disposeObjects("__layout", "__defaultCellRenderer", "__columnData");
    }
  });
  qx.ui.progressive.renderer.table.Row.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Cell Renderer for Progressive's Table.
   *
   * Many of the methods in this class accept a parameter called cellInfo.  This
   * parameter is an object with the following members:
   *
   * <dl>
   *   <dt>
   *     state
   *   </dt>
   *   <dd>
   *     The {@link qx.ui.progressive.State} object pertaining to this rendering
   *     session.
   *   </dd>
   *
   *   <dt>
   *     rowDiv
   *   </dt>
   *   <dd>
   *     The "div" DOM element of the row in which this cell is to be added.
   *   </dd>
   *
   *   <dt>
   *     element
   *   </dt>
   *   <dd>
   *     The entire element object returned by the data model.
   *   </dd>
   *
   *   <dt>
   *     dataIndex
   *   </dt>
   *   <dd>
   *     The index into the data element provided by the data model.
   *     Effectively, this is the column number.
   *   </dd>
   *
   *   <dt>
   *     cellData
   *   </dt>
   *   <dd>
   *     The data from the data model, to be rendered.  This the specific column
   *     data for the column being rendered, and is a shorthand for
   *     element.data[element.dataIndex].
   *   </dd>
   *
   *   <dt>
   *     height <span style="color:red;">Input/Output parameter!</span>
   *   </dt>
   *   <dd>
   *     On input to a cell renderer, this contains the height, as determined to
   *     date, for the current row.  The first column being rendered will
   *     receive a height of zero.  Upon return, it may leave the height at
   *     zero, meaning that it will accept any minimum height, or may specify a
   *     minimum height by setting this member.  Subsequent column cell renderers
   *     will receive the maximum height specified by any previous cell
   *     renderer.  Upon completion of calling each of the cell renderers for a
   *     row, the row height will be set to the value found in this member.
   *   </dd>
   * </dl>
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Abstract", {
    type: "abstract",
    extend: qx.core.Object,
    members: {
      /**
       * Retrieve any style characteristics the cell renderer wants applied to
       * this cell.
       *
       * @param cellInfo {Object}
       *   See {@link qx.ui.progressive.renderer.table.cell.Abstract} class
       *   description for details
       *
       * @return {String}
       *   The style characteristics to be applied to this cell.
       */
      _getCellStyle: function _getCellStyle(cellInfo) {
        return "";
      },

      /**
       * Retrieve any extra attributes the cell renderer wants applied to this
       * cell.  Extra attributes could be such things as
       * "onclick='handleClick()';"
       *
       * @param cellInfo {Object}
       *   See {@link qx.ui.progressive.renderer.table.cell.Abstract} class
       *   description for details
       *
       * @return {String}
       *   The extra attributes to be applied to this cell.
       */
      _getCellExtras: function _getCellExtras(cellInfo) {
        return "";
      },

      /**
       * Retrieve the HTML content to be added to the cell div.
       *
       * @param cellInfo {Object}
       *   See {@link qx.ui.progressive.renderer.table.cell.Abstract} class
       *   description for details
       *
       * @return {String}
       *   The HTML content to be added to the cell div.
       */
      _getContentHtml: function _getContentHtml(cellInfo) {
        return cellInfo.cellData || "";
      },

      /**
       * Given the provided cell information, generate the HTML for this
       * cell.
       *
       * @param cellInfo {Object}
       *   See {@link qx.ui.progressive.renderer.table.cell.Abstract} class
       *   description for details
       *
       * @return {String}
       *   The HTML required to create this cell.
       */
      render: function render(cellInfo) {
        var html = [];

        var style = this._getCellStyle(cellInfo); // Render this cell


        html.push("<div ", "class='", cellInfo.stylesheet, "' ");

        if (style) {
          html.push("style='", style, "'");
        }

        html.push(this._getCellExtras(cellInfo), ">", this._getContentHtml(cellInfo), "</div>");
        return html.join("");
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.bom.String": {},
      "qx.ui.progressive.renderer.table.Row": {},
      "qx.util.format.NumberFormat": {},
      "qx.util.format.DateFormat": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Renderer for Progressive.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Default", {
    extend: qx.ui.progressive.renderer.table.cell.Abstract,

    /**
     */
    construct: function construct() {
      qx.ui.progressive.renderer.table.cell.Abstract.constructor.call(this);
    },
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        return qx.bom.String.escape(this._formatValue(cellInfo.cellData));
      },

      /**
       * Formats a value in a reasonably predictable fashion.
       *
       *
       * @param value {var}
       *   The value to be formatted
       *
       * @return {String}
       * <ul>
       *   <li>
       *     Numbers are formatted with two fractional digits.
       *   </li>
       *   <li>
       *     Dates are formatted in the default format of
       *     {@link qx.util.format.DateFormat}.
       *   </li>
       *   <li>
       *     Any type not otherwise handled, including String values, are
       *     simply returned unaltered.
       *   </li>
       * </ul>
       */
      _formatValue: function _formatValue(value) {
        var ret;

        if (value == null) {
          return "";
        }

        if (typeof value == "string") {
          return value;
        } else if (typeof value == "number") {
          if (!qx.ui.progressive.renderer.table.Row._numberFormat) {
            var numberFormat = new qx.util.format.NumberFormat();
            numberFormat.setMaximumFractionDigits(2);
            qx.ui.progressive.renderer.table.Row._numberFormat = numberFormat;
          }

          ret = qx.ui.progressive.renderer.table.Row._numberFormat.format(value);
        } else if (value instanceof Date) {
          ret = qx.util.format.DateFormat.getDateInstance().format(value);
        } else {
          ret = value;
        }

        return ret;
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.ColumnData": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Column width array for a whole set of columns
   */
  qx.Class.define("qx.ui.progressive.renderer.table.Widths", {
    extend: qx.core.Object,

    /**
     * @param numColumns {Integer}
     *   The number of columns being used.
     */
    construct: function construct(numColumns) {
      qx.core.Object.constructor.call(this); // Create an array of the specified number of columns, and use the default
      // column data.

      this.__columnData = [];

      for (var i = 0; i < numColumns; i++) {
        this.__columnData[i] = new qx.ui.core.ColumnData();
      }
    },
    members: {
      __columnData: null,

      /**
       * Get the array of column data.
       *
       * @return {Array}
       *   Array of column data
       *
       */
      getData: function getData() {
        return this.__columnData;
      },

      /**
       * Set the width, minimum width and/or maximum width of a column at one
       * time.
       *
       * @param column {Integer}
       *   The column number whose attributes are being set.
       *
       * @param map {Map}
       *   An object with any or all of the three members, "width", "minWidth",
       *   "maxWidth".  The property values are as described for {@link
       *   #setWidth}, {@link #setMinWidth} and {@link #setMaxWidth}
       *   respectively.
       *
       */
      set: function set(column, map) {
        for (var key in map) {
          switch (key) {
            case "width":
              this.setWidth(column, map[key]);
              break;

            case "minWidth":
              this.setMinWidth(column, map[key]);
              break;

            case "maxWidth":
              this.setMaxWidth(column, map[key]);
              break;

            default:
              throw new Error("Unrecognized key: " + key);
          }
        }
      },

      /**
       * Set the width of a column.
       *
       *
       * @param column {Integer} The column whose width is to be set
       *
       * @param width {Integer|String}
       *   The width of the specified column.  The width may be specified as
       *   integer number of pixels (e.g. 100), a string representing percentage
       *   of the inner width of the Table (e.g. "25%"), or a string
       *   representing a flex width (e.g. "1*").
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setWidth: function setWidth(column, width) {
        if (column > this.__columnData.length - 1 || column < 0) {
          throw new Error("Column number out of range");
        }

        this.__columnData[column].setColumnWidth(width);
      },

      /**
       * Set the minimum width of a column.
       *
       *
       * @param column {Integer}
       *   The column whose minimum width is to be set
       *
       * @param width {Integer}
       *   The minimum width of the specified column.
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setMinWidth: function setMinWidth(column, width) {
        if (column > this.__columnData.length - 1 || column < 0) {
          throw new Error("Column number out of range");
        }

        this.__columnData[column].setMinWidth(width);
      },

      /**
       * Set the maximum width of a column.
       *
       *
       * @param column {Integer}
       *   The column whose maximum width is to be set
       *
       * @param width {Integer}
       *   The maximum width of the specified column.
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setMaxWidth: function setMaxWidth(column, width) {
        if (column > this.__columnData.length - 1 || column < 0) {
          throw new Error("Column number out of range");
        }

        this.__columnData[column].setMaxWidth(width);
      }
    }
  });
  qx.ui.progressive.renderer.table.Widths.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      },
      "qx.util.ResourceManager": {
        "construct": true
      },
      "qx.bom.client.Css": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.alphaimageloaderneeded": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Abstract Icon cell renderer.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Icon", {
    type: "abstract",
    extend: qx.ui.progressive.renderer.table.cell.Abstract,

    /** Create a new instance of an Icon cell renderer */
    construct: function construct() {
      qx.ui.progressive.renderer.table.cell.Abstract.constructor.call(this);
      var aliasManager = qx.util.AliasManager.getInstance();
      var resourceManager = qx.util.ResourceManager.getInstance();
      var blankImg = aliasManager.resolve("qx/static/blank.gif");
      this.__imageBlank = resourceManager.toUri(blankImg);
    },
    members: {
      /**
       * A blank image for use as a spacer in place of another image
       */
      __imageBlank: null,

      /**
       * Retrieve the URI for a blank image
       *
       * @return {String}
       *   The URI of the blank image.
       */
      getBlankImage: function getBlankImage() {
        return this.__imageBlank;
      },

      /**
       * Identify the image to be displayed in the cell.
       *
       * @param cellInfo {Map}
       *   Information about the cell being renderered, including:
       *   <ul>
       *     <li>state</li>
       *     <li>rowDiv</li>
       *     <li>stylesheet</li>
       *     <li>element</li>
       *     <li>dataIndex</li>
       *     <li>cellData</li>
       *     <li>height</li>
       *   </ul>
       *
       * @return {Map}
       *   The returned map should contain at least the <i>url</i> field, but
       *   may contain any others of these:
       *
       *   <dl>
       *     <dt>
       *       url
       *     </dt>
       *     <dd>
       *       The URL of the image to be displayed
       *     </dd>
       *
       *     <dt>
       *       imageWidth
       *     </dt>
       *     <dd>
       *       The width at which the image should be displayed
       *     </dd>
       *
       *     <dt>
       *       imageHeight
       *     </dt>
       *     <dd>
       *       The height at which the image should be displayed
       *     </dd>
       *
       *     <dt>
       *       extras
       *     </dt>
       *     <dd>
       *       Any extra attributes to be include in the 'image' tag.
       *     </dd>
       *   </dl>
       */
      _identifyImage: function _identifyImage(cellInfo) {
        throw new Error("_identifyImage() is abstract");
      },
      // overridden
      _getCellStyle: function _getCellStyle(cellInfo) {
        var ret = qx.ui.progressive.renderer.table.cell.Icon.prototype._getCellStyle.base.call(this, cellInfo) + "text-align:center;" + "vertical-align:middle;";
        return ret;
      },
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        var html = [];

        var imageData = this.__getImageData(cellInfo); // Start the image tag


        html.push('<img '); // Add magic to make png images work in IE

        if (qx.core.Environment.get("css.alphaimageloaderneeded") && /\.png$/i.test(imageData.url)) {
          html.push('src="', this.__imageBlank, '" style="filter:', "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='", imageData.url, "',sizingMethod='scale')", '" ');
        } else {
          html.push('src="', imageData.url, '" ');
        } // If image width is specified...


        if (imageData.imageWidth) {
          // ... then add it.
          html.push(" width='", imageData.imageWidth, "px'");
        } // If image height is specified...


        if (imageData.imageHeight) {
          // ... then add it.
          html.push(" height='", imageData.imageHeight, "px'");
        } // Move the image off of the top border


        html.push(" style='padding-top:2px;'"); // If a tooltip is specified...

        if (imageData.tooltip) {
          // ... then add it.
          html.push(" title='", imageData.tooltip, "'");
        } // If there are any extra parameters specified, add them now.


        if (imageData.extras) {
          html.push(imageData.extras);
        } // All done.


        html.push(">"); // Give 'em what they came for

        return html.join("");
      },

      /**
       * Obtain the image data (url, tooltip) that's appropriate for this cell
       *
       * @param cellInfo {Map}
       *   Information about the cell being renderered, including:
       *   <ul>
       *     <li>state</li>
       *     <li>rowDiv</li>
       *     <li>stylesheet</li>
       *     <li>element</li>
       *     <li>dataIndex</li>
       *     <li>cellData</li>
       *     <li>height</li>
       *   </ul>
       *
       * @return {Map}
       *   See {@link #_identifyImage}
       */
      __getImageData: function __getImageData(cellInfo) {
        // Query the subclass about image and tooltip
        var imageData = this._identifyImage(cellInfo); // If subclass refuses to give map, construct it


        if (imageData == null || typeof imageData == "string") {
          imageData = {
            url: imageData,
            tooltip: null
          };
        } // If subclass gave null as url, replace with url to empty image


        if (imageData.url == null) {
          imageData.url = this.__imageBlank;
        }

        return imageData;
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.Icon.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Icon": {
        "construct": true,
        "require": true
      },
      "qx.theme.manager.Meta": {
        "construct": true
      },
      "qx.util.AliasManager": {},
      "qx.util.ResourceManager": {},
      "qx.bom.client.Css": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.alphaimageloaderneeded": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Boolean Renderer.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Boolean", {
    extend: qx.ui.progressive.renderer.table.cell.Icon,
    construct: function construct() {
      qx.ui.progressive.renderer.table.cell.Icon.constructor.call(this);

      this.__resolveImages(); // dynamic theme switch


      {
        qx.theme.manager.Meta.getInstance().addListener("changeTheme", this.__resolveImages, this);
      }
    },
    properties: {
      /**
       * Whether to add code which will toggle the checkbox on/off.  (There is
       * not yet code here to generate an event when this occurs, so it's not
       * yet very useful.)
       */
      allowToggle: {
        check: "Boolean",
        init: false
      }
    },
    members: {
      __iconUrlTrue: null,
      __iconUrlFalse: null,
      __numericAllowed: null,
      __conditions: null,
      __defaultTextAlign: null,
      __defaultColor: null,
      __defaultFontStyle: null,
      __defaultFontWeight: null,

      /**
       * Resolve the boolean images using the alias and resource manager.
       */
      __resolveImages: function __resolveImages() {
        var aliasManager = qx.util.AliasManager.getInstance();
        var resourceManager = qx.util.ResourceManager.getInstance();
        var boolTrueImg = aliasManager.resolve("decoration/table/boolean-true.png");
        var boolFalseImg = aliasManager.resolve("decoration/table/boolean-false.png");
        this.__iconUrlTrue = resourceManager.toUri(boolTrueImg);
        this.__iconUrlFalse = resourceManager.toUri(boolFalseImg);
      },
      // overridden
      _identifyImage: function _identifyImage(cellInfo) {
        var imageData = {
          imageWidth: 11,
          imageHeight: 11
        };

        switch (cellInfo.cellData) {
          case true:
            imageData.url = this.__iconUrlTrue;
            imageData.extras = "celldata='1' ";
            break;

          case false:
            imageData.url = this.__iconUrlFalse;
            imageData.extras = "celldata='0' ";
            break;

          default:
            imageData.url = null;
            break;
        }

        if (this.getAllowToggle()) {
          // Toggle the boolean value if clicked
          imageData.extras += "onclick=\"var node = this.attributes.getNamedItem('celldata'); var value = node.nodeValue; var src; if (value == '0') {";

          if (qx.core.Environment.get("css.alphaimageloaderneeded") && /\.png$/i.test(this.__iconUrlTrue)) {
            imageData.extras += "  this.src='" + this.getBlankImage() + "'; " + "  var loader = 'DXImageTransform.Microsoft.AlphaImageLoader'; " + "  var filters = this.filters.item(loader); " + "  filters.src='" + this.__iconUrlTrue + "'; " + "  filters.sizingMethod = 'scale'; ";
          } else {
            imageData.extras += "  this.src='" + this.__iconUrlTrue + "'; ";
          }

          imageData.extras += "  node.nodeValue='1'; } else {";

          if (qx.core.Environment.get("css.alphaimageloaderneeded") && /\.png$/i.test(this.__iconUrlFalse)) {
            imageData.extras += "  this.src='" + this.getBlankImage() + "'; " + "  var loader = 'DXImageTransform.Microsoft.AlphaImageLoader'; " + "  var filters = this.filters.item(loader); " + "  filters.src='" + this.__iconUrlFalse + "'; " + "  filters.sizingMethod = 'scale'; ";
          } else {
            imageData.extras += "  this.src='" + this.__iconUrlFalse + "'; ";
          }

          imageData.extras += "  node.nodeValue='0'; }";
          imageData.extras += // IE doesn't allow setNamedItem() if not explicitly an "attribute"
          "try {   this.attributes.setNamedItem(node); } catch (e) {   var namedItem = document.createAttribute('celldata');   namedItem.value = node.nodeValue;   this.attributes.setNamedItem(namedItem); }\"";
        }

        return imageData;
      },
      // overridden
      _getCellStyle: function _getCellStyle(cellInfo) {
        var ret = qx.ui.progressive.renderer.table.cell.Boolean.prototype._getCellStyle.base.call(this, cellInfo);

        return ret;
      }
    },
    destruct: function destruct() {
      this.__iconUrlTrue = this.__iconUrlFalse = null; // remove dynamic theme listener

      {
        qx.theme.manager.Meta.getInstance().removeListener("changeTheme", this.__resolveImages, this);
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.Boolean.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Tartan Solutions, Inc, http://www.tartansolutions.com
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Dan Hummon
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Renderer for Progressive.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Conditional", {
    extend: qx.ui.progressive.renderer.table.cell.Abstract,

    /**
     * @param align {String}
     *   The default alignment to format the cell with if the condition matches.
     *
     * @param color {String}
     *   The default color to format the cell with if the condition matches.
     *
     * @param style {String}
     *   The default style to format the cell with if the condition matches.
     *
     * @param weight {String}
     *   The default weight to format the cell with if the condition matches.
     */
    construct: function construct(align, color, style, weight) {
      qx.ui.progressive.renderer.table.cell.Abstract.constructor.call(this);
      this.__numericAllowed = ["==", "!=", ">", "<", ">=", "<="];
      this.__betweenAllowed = ["between", "!between"];
      this.__conditions = [];
      this.__defaultTextAlign = align || "";
      this.__defaultColor = color || "";
      this.__defaultFontStyle = style || "";
      this.__defaultFontWeight = weight || "";
    },
    members: {
      __numericAllowed: null,
      __betweenAllowed: null,
      __conditions: null,
      __defaultTextAlign: null,
      __defaultColor: null,
      __defaultFontStyle: null,
      __defaultFontWeight: null,

      /**
       * Applies the cell styles to the style map.
       *
       * @param condition {Array}
       *   The matched condition
       *
       * @param style {Map}
       *   map of already applied styles.
       */
      __applyFormatting: function __applyFormatting(condition, style) {
        if (condition.align) {
          style["text-align"] = condition.align;
        }

        if (condition.color) {
          style["color"] = condition.color;
        }

        if (condition.style) {
          style["font-style"] = condition.style;
        }

        if (condition.weight) {
          style["font-weight"] = condition.weight;
        }
      },

      /**
       * The addNumericCondition method is used to add a basic numeric condition
       * to the cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the
       * align, color, style and weight arguments. Null will allow pre-existing
       * formatting to pass through, where an empty string will clear it back to
       * the default formatting set in the constructor.
       *
       *
       *
       * @param condition {String}
       *   The type of condition. Accepted strings are "==", "!=", ">", "<",
       *   ">=", and "<=".
       *
       * @param value1 {Integer}
       *   The value to compare against.
       *
       * @param align {String}
       *   The alignment to format the cell with if the condition matches.
       *
       * @param color {String}
       *   The color to format the cell with if the condition matches.
       *
       * @param style {String}
       *   The style to format the cell with if the condition matches.
       *
       * @param weight {String}
       *   The weight to format the cell with if the condition matches.
       *
       * @param target {String}
       *   The text value of the column to compare against. If this is null,
       *   comparisons will be against the contents of this cell.
       *
       * @throws {Error} If the condition can not be recognized or the value
       * is null.
       */
      addNumericCondition: function addNumericCondition(condition, value1, align, color, style, weight, target) {
        if (!this.__numericAllowed.includes(condition) || value1 == null) {
          throw new Error("Condition not recognized or value is null!");
        }

        this.__conditions.push({
          condition: condition,
          align: align,
          color: color,
          style: style,
          weight: weight,
          value1: value1,
          target: target
        });
      },

      /**
       * The addBetweenCondition method is used to add a between condition to
       * the cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the
       * align, color, style and weight arguments. Null will allow pre-existing
       * formatting to pass through, where an empty string will clear it back to
       * the default formatting set in the constructor.
       *
       *
       *
       * @param condition {String}
       *   The type of condition. Accepted strings are "between" and "!between".
       *
       * @param value1 {Integer}
       *   The first value to compare against.
       *
       * @param value2 {Integer}
       *   The second value to compare against.
       *
       * @param align {String}
       *   The alignment to format the cell with if the condition matches.
       *
       * @param color {String}
       *   The color to format the cell with if the condition matches.
       *
       * @param style {String}
       *   The style to format the cell with if the condition matches.
       *
       * @param weight {String}
       *   The weight to format the cell with if the condition matches.
       *
       * @param target {String}
       *   The text value of the column to compare against. If this is null,
       *   comparisons will be against the contents of this cell.
       *
       *
       * @throws {Error} If the condition can not recognized or one of the
       * values is null.
       */
      addBetweenCondition: function addBetweenCondition(condition, value1, value2, align, color, style, weight, target) {
        if (!this.__betweenAllowed.includes(condition) || value1 == null || value2 == null) {
          throw new Error("Condition not recognized or value1/value2 is null!");
        }

        this.__conditions.push({
          condition: condition,
          align: align,
          color: color,
          style: style,
          weight: weight,
          value1: value1,
          value2: value2,
          target: target
        });
      },

      /**
       * The addRegex method is used to add a regular expression condition to
       * the cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the
       * align, color, style and weight arguments. Null will allow pre-existing
       * formatting to pass through, where an empty string will clear it back to
       * the default formatting set in the constructor.
       *
       *
       *
       * @param regex {String}
       *   The regular expression to match against.
       *
       * @param align {String}
       *   The alignment to format the cell with if the condition matches.
       *
       * @param color {String}
       *   The color to format the cell with if the condition matches.
       *
       * @param style {String}
       *   The style to format the cell with if the condition matches.
       *
       * @param weight {String}
       *   The weight to format the cell with if the condition matches.
       *
       * @param target {String}
       *   The text value of the column to compare against. If this is null,
       *   comparisons will be against the contents of this cell.
       *
       * @throws {Error} If the regex is null.
       */
      addRegex: function addRegex(regex, align, color, style, weight, target) {
        if (!regex) {
          throw new Error("regex cannot be null!");
        }

        this.__conditions.push({
          condition: "regex",
          align: align,
          color: color,
          style: style,
          weight: weight,
          regex: regex,
          target: target
        });
      },

      /**
       * Overridden; called whenever the cell updates. The cell will iterate
       * through each available condition and apply formatting for those that
       * match. Multiple conditions can match, but later conditions will
       * override earlier ones. Conditions with null values will stack with
       * other conditions that apply to that value.
       *
       *
       * @param cellInfo {Map}
       *   The information about the cell.  See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @return {String}
       */
      _getCellStyle: function _getCellStyle(cellInfo) {
        if (this.__conditions.length == 0) {
          return cellInfo.style || "";
        }

        var i;
        var bTestPassed;
        var compareValue;
        var style = {
          "text-align": this.__defaultTextAlign,
          "color": this.__defaultColor,
          "font-style": this.__defaultFontStyle,
          "font-weight": this.__defaultFontWeight
        };

        for (i = 0; i < this.__conditions.length; i++) {
          var test = this.__conditions[i];
          bTestPassed = false;

          if (this.__numericAllowed.includes(test.condition)) {
            if (test.target == null) {
              compareValue = cellInfo.cellData;
            } else {
              compareValue = cellInfo.element.data[test.target];
            }

            switch (test.condition) {
              case "==":
                if (compareValue == test.value1) {
                  bTestPassed = true;
                }

                break;

              case "!=":
                if (compareValue != test.value1) {
                  bTestPassed = true;
                }

                break;

              case ">":
                if (compareValue > test.value1) {
                  bTestPassed = true;
                }

                break;

              case "<":
                if (compareValue < test.value1) {
                  bTestPassed = true;
                }

                break;

              case ">=":
                if (compareValue >= test.value1) {
                  bTestPassed = true;
                }

                break;

              case "<=":
                if (compareValue <= test.value1) {
                  bTestPassed = true;
                }

                break;
            }
          } else if (this.__betweenAllowed.includes(test.condition)) {
            if (test.target == null) {
              compareValue = cellInfo.cellData;
            } else {
              compareValue = cellInfo.element.data[test.target];
            }

            switch (test.condition) {
              case "between":
                if (compareValue >= test.value1 && compareValue <= test.value2) {
                  bTestPassed = true;
                }

                break;

              case "!between":
                if (compareValue < test.value1 && compareValue > test.value2) {
                  bTestPassed = true;
                }

                break;
            }
          } else if (test.condition == "regex") {
            if (test.target == null) {
              compareValue = cellInfo.cellData;
            } else {
              compareValue = cellInfo.element.data[test.target];
            }

            var the_pattern = new RegExp(test.value1, 'g');
            bTestPassed = the_pattern.test(compareValue);
          } // Apply formatting, if any.


          if (bTestPassed) {
            this.__applyFormatting(test, style);
          }

          var styleString = [];

          for (var key in style) {
            if (style[key]) {
              styleString.push(key, ":", style[key], ";");
            }
          }
        }

        return styleString.join("");
      }
    },
    destruct: function destruct() {
      this.__numericAllowed = this.__betweenAllowed = this.__conditions = null;
    }
  });
  qx.ui.progressive.renderer.table.cell.Conditional.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Abstract": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Html Renderer.
   *
   *  Renderer the specified HTML in the cell.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Html", {
    /*
     * Nothing specific to do here, as the Abstract class already does
     * everything we need.
     */
    extend: qx.ui.progressive.renderer.table.cell.Abstract
  });
  qx.ui.progressive.renderer.table.cell.Html.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Icon": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {},
      "qx.util.ResourceManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Tartan Solutions, Inc, http://www.tartansolutions.com
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Dan Hummon
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Boolean Renderer.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Image", {
    extend: qx.ui.progressive.renderer.table.cell.Icon,

    /**
     * @param height {Integer ? 16}
     *   The height of the image. The default is 16.
     *
     * @param width {Integer ? 16}
     *   The width of the image. The default is 16.
     */
    construct: function construct(width, height) {
      qx.ui.progressive.renderer.table.cell.Icon.constructor.call(this);

      if (width === undefined) {
        this.__imageWidth = width;
      } else {
        this.__imageWidth = 16;
      }

      if (height === undefined) {
        this.__imageHeight = height;
      } else {
        this.__imageHeight = 16;
      }
    },
    members: {
      __imageWidth: null,
      __imageHeight: null,
      // overridden
      _identifyImage: function _identifyImage(cellInfo) {
        var imageData = {
          imageWidth: this.__imageWidth,
          imageHeight: this.__imageHeight
        };
        var height; // String data is the unresolved url for the image.
        // Object data is a map containing the url, tooltip, and a height

        if (typeof cellInfo.cellData == "string") {
          imageData.url = cellInfo.cellData;
        } else {
          imageData.url = cellInfo.cellData.url;
          imageData.tooltip = cellInfo.cellData.tooltip;
          height = cellInfo.cellData.height;
        }

        if (imageData.url == "") {
          imageData.url = this._imageBlank;
        } else {
          var aliasManager = qx.util.AliasManager.getInstance();
          var resourceManager = qx.util.ResourceManager.getInstance();
          var resolved = aliasManager.resolve(imageData.url);
          imageData.url = resourceManager.toUri(resolved);
        } // Adjust the row height, if necessary, to let this image fit


        if (height) {
          cellInfo.height = height;
        }

        return imageData;
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Renderer for Progressive.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.String", {
    extend: qx.ui.progressive.renderer.table.cell.Abstract,

    /**
     */
    construct: function construct() {
      qx.ui.progressive.renderer.table.cell.Abstract.constructor.call(this);
    },
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        return qx.bom.String.escape(cellInfo.cellData);
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menu.Menu": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006-2009 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * This mixin allows easily adding handlers for context menus on table columns.
   */
  qx.Mixin.define("qx.ui.table.MTableContextMenu", {
    construct: function construct() {
      // Add an event listener to handle context menu events.  The actual menu
      // is built by a function registered with a call to
      // setContextMenuHandler(col, handler).
      this.addListener("cellContextmenu", function (e) {
        var contextMenu = this.getContextMenu(); // Dispose of any previously existing context menu

        if (contextMenu && !contextMenu.isDisposed()) {
          // Dispose of the context menu.
          contextMenu.hide();
          this.setContextMenu(null);
          this.getApplicationRoot().remove(contextMenu);
          contextMenu.dispose();
          contextMenu = null;
        } // Get the context menu handler for the column on which the context
        // menu request was issued.


        var col = e.getColumn();
        var contextMenuHandler = this.getContextMenuHandler(col); // If there's no context menu handler for this column, we have nothing
        // to do.

        if (typeof contextMenuHandler !== "function") {
          return;
        } // Get the context object for the handler function


        var handlerContext = this.__contextMenuHandlerContext[col]; // Get the data model

        var tableModel = this.getTableModel(); // Create a context menu for this tree.

        contextMenu = new qx.ui.menu.Menu(); // Don't display context menus from the context menu

        contextMenu.addListener("contextmenu", function (e) {
          e.preventDefault();
        }); // This prevents the display of context menu on table header cells

        contextMenu.addListenerOnce("disappear", function () {
          this.setContextMenu(null);
        }, this); // Call the context menu handler for this column.

        var bShowContextMenu = contextMenuHandler.call(handlerContext, col, e.getRow(), this, tableModel, contextMenu); // If we were told not to display the context menu...

        if (!bShowContextMenu) {
          // ... then we're all done here.
          contextMenu.dispose();
          return;
        } // Set the context menu


        this.setContextMenu(contextMenu);
      }, this); // Provide an array in which context menu handlers will be stored.  The
      // array is indexed by column number.

      this.__contextMenuHandler = [];
      this.__contextMenuHandlerContext = [];
    },
    members: {
      __contextMenuHandler: null,
      __contextMenuHandlerContext: null,

      /**
       * Add a handler for a context menu which is initiated in a specific
       * column.
       *
       * @param col {Integer}
       *   The column number in which the context menu request originated
       *
       * @param handler {Function}
       *   The function to call when a context menu request originates in the
       *   specified column. The handler is called with the following arguments:
       *   <ul>
       *     <li>
       *       <b>column</b>: (Integer)
       *       The number of the column in which the right click was issued
       *     </li>
       *     <li>
       *       <b>row</b>: (Integer)
       *       The number of the row in which the right click was issued
       *     </li>
       *     <li>
       *       <b>table</b>: {@link qx.ui.table.Table}
       *       The table in which the right click was issued
       *     </li>
       *     <li>
       *       <b>dataModel</b>: {@link qx.ui.table.model.Abstract}
       *       Complete data model of the table
       *     </li>
       *     <li>
       *       <b>contextMenu</b>: {@link qx.ui.menu.Menu}
       *       Menu in which buttons can be added to implement this context menu
       *     </li>
       *   </ul>
       *   The function must return a (Boolean), indicating whether the context
       *   menu should be shown or not. The context menu will be shown when the
       *   handler function returns <code>true</code>. When the handler function
       *   returns <code>false</code> the context menu will <b>not</b> be shown.
       *
       * @param context {Object?this}
       *   Optional execution context for the callback (i.e. "this").
       *   If not provided, the {@link qx.ui.table.Table} object this mixin is
       *   applied to is used.
       *
       */
      setContextMenuHandler: function setContextMenuHandler(col, handler, context) {
        this.__contextMenuHandler[col] = handler;
        this.__contextMenuHandlerContext[col] = context || this;
      },

      /**
       * Return the registered context menu handler for a column.
       *
       * @param col {Integer}
       *   The column number for which the context menu handler is requested
       *
       * @return {Function}
       *   The handler function which has been registered for the specified
       *   column. The arguments of the handler is documented in
       *   {@link #setContextMenuHandler}.
       */
      getContextMenuHandler: function getContextMenuHandler(col) {
        return this.__contextMenuHandler[col];
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__contextMenuHandler = null;
      this.__contextMenuHandlerContext = null;
    }
  });
  qx.ui.table.MTableContextMenu.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.table.ICellEditorFactory": {
        "require": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.form.CheckBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 David Perez
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * David Perez (david-perez)
  
  ************************************************************************ */

  /**
   * For editing boolean data in a checkbox. It is advisable to use this in
   * conjunction with {@link qx.ui.table.cellrenderer.Boolean}.
   */
  qx.Class.define("qx.ui.table.celleditor.CheckBox", {
    extend: qx.core.Object,
    implement: qx.ui.table.ICellEditorFactory,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // interface implementation
      createCellEditor: function createCellEditor(cellInfo) {
        var editor = new qx.ui.container.Composite(new qx.ui.layout.HBox().set({
          alignX: "center",
          alignY: "middle"
        })).set({
          focusable: true
        });
        var checkbox = new qx.ui.form.CheckBox().set({
          value: cellInfo.value
        });
        editor.add(checkbox); // propagate focus

        editor.addListener("focus", function () {
          checkbox.focus();
        }); // propagate active state

        editor.addListener("activate", function () {
          checkbox.activate();
        });
        return editor;
      },
      // interface implementation
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        return cellEditor.getChildren()[0].getValue();
      }
    }
  });
  qx.ui.table.celleditor.CheckBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.ICellEditorFactory": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */

  /**
   * A cell editor factory which can dynamically exchange the cell editor
   * based on information retrieved at runtime. This is useful when different
   * rows in a column should have different cellEditors based on cell content
   * or row meta data. A typical example would be a spreadsheet that has different
   * kind of data in one column.
   *
   */
  qx.Class.define("qx.ui.table.celleditor.Dynamic", {
    extend: qx.core.Object,
    implement: qx.ui.table.ICellEditorFactory,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param cellEditorFactoryFunction {Function?null} the factory function
     *    {@link #cellEditorFactoryFunction}.
     */
    construct: function construct(cellEditorFactoryFunction) {
      qx.core.Object.constructor.call(this);

      if (cellEditorFactoryFunction) {
        this.setCellEditorFactoryFunction(cellEditorFactoryFunction);
      }

      this.__infos = {};
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Function that returns a cellEditorFactory instance which will be
       * used for the row that is currently being edited. The function is
       * defined like this:
       * <pre class="javascript">
       * myTable.getTableColumnModel().setCellEditorFactory(function(cellInfo){
       *   // based on the cellInfo map or other information, return the
       *   // appropriate cellEditorFactory
       *   if (cellInfo.row == 5)
       *     return new qx.ui.table.celleditor.CheckBox;
       *   else
       *     return new qx.ui.table.celleditor.TextField;
       * });
       * </pre>
       **/
      cellEditorFactoryFunction: {
        check: "Function",
        nullable: true,
        init: null
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __cellEditorFactory: null,
      __infos: null,

      /**
       * Creates the cell editor based on the cellEditorFactory instance
       * returned by the function stored in the cellEditorFactoryFunction
       * property. Passes the cellInfo map to the function.
       *
       * @param cellInfo {Map} A map containing the information about the cell to
       *      create.
       * @return {qx.ui.core.Widget}
       */
      createCellEditor: function createCellEditor(cellInfo) {
        var cellEditorFactoryFunction = this.getCellEditorFactoryFunction();
        {
          this.assertFunction(cellEditorFactoryFunction, "No function provided! Aborting.");
        }
        this.__cellEditorFactory = cellEditorFactoryFunction(cellInfo);

        var cellEditor = this.__cellEditorFactory.createCellEditor(cellInfo); // save the cell info to the editor (needed for getting the value)


        this.__infos[cellEditor.toHashCode()] = cellInfo;
        return cellEditor;
      },
      // interface implementation
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        var cellEditorFactoryFunction = this.getCellEditorFactoryFunction();
        {
          this.assertFunction(cellEditorFactoryFunction, "No function provided! Aborting.");
        }

        var cellInfo = this.__infos[cellEditor.toHashCode()]; // update the propper factory


        this.__cellEditorFactory = cellEditorFactoryFunction(cellInfo);

        var value = this.__cellEditorFactory.getCellEditorValue(cellEditor);

        return value;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__cellEditorFactory = null;
    }
  });
  qx.ui.table.celleditor.Dynamic.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.bom.Stylesheet": {
        "construct": true
      },
      "qx.util.ResourceManager": {},
      "qx.io.ImageLoader": {},
      "qx.bom.client.Css": {},
      "qx.bom.element.Decoration": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.inlineblock": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
  
  ************************************************************************ */

  /**
   * A template class for cell renderer, which display images. Concrete
   * implementations must implement the method {@link #_identifyImage}.
   */
  qx.Class.define("qx.ui.table.cellrenderer.AbstractImage", {
    extend: qx.ui.table.cellrenderer.Abstract,
    type: "abstract",

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.cellrenderer.Abstract.constructor.call(this);
      var clazz = qx.ui.table.cellrenderer.AbstractImage;

      if (!clazz.stylesheet) {
        clazz.stylesheet = qx.bom.Stylesheet.createElement(".qooxdoo-table-cell-icon {  text-align:center;  padding-top:1px;}");
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether to repeat or scale the image.
       *
       * @param repeat {String}
       *   One of
       *     <code>scale</code>,
       *     <code>scale-x</code>,
       *     <code>scale-y</code>,
       *     <code>repeat</code>,
       *     <code>repeat-x</code>,
       *     <code>repeat-y</code>,
       *     <code>no-repeat</code>
      */
      repeat: {
        check: function check(value) {
          var valid = ["scale", "scale-x", "scale-y", "repeat", "repeat-x", "repeat-y", "no-repeat"];
          return valid.includes(value);
        },
        init: "no-repeat"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __defaultWidth: 16,
      __defaultHeight: 16,
      __imageData: null,
      // overridden
      _insetY: 2,

      /**
       * Identifies the Image to show. This is a template method, which must be
       * implemented by sub classes.
       *
       * @abstract
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {Map} A map having the following attributes:
       *           <ul>
       *           <li>
       *             "url": (type string) must be the URL of the image to show.
       *             The url given must either be managed by the {@link qx.util.ResourceManager}
       *             or pre-loaded with {@link qx.io.ImageLoader}. This is to make sure that
       *             the renderer knows the dimensions and the format of the image.
       *           </li>
       *           <li>"imageWidth": (type int) the width of the image in pixels.</li>
       *           <li>"imageHeight": (type int) the height of the image in pixels.</li>
       *           <li>"tooltip": (type string) must be the image tooltip text.</li>
       *           </ul>
       * @throws {Error} the abstract function warning.
       */
      _identifyImage: function _identifyImage(cellInfo) {
        throw new Error("_identifyImage is abstract");
      },

      /**
       * Retrieves the image infos.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {Map} Map with an "url" attribute (type string)
       *                 holding the URL of the image to show
       *                 and a "tooltip" attribute
       *                 (type string) being the tooltip text (or null if none was specified)
       */
      _getImageInfos: function _getImageInfos(cellInfo) {
        // Query the subclass about image and tooltip
        var imageData = this._identifyImage(cellInfo); // If subclass refuses to give map, construct it with required properties
        // If no map is given, but instead a string, assume that this string is
        // the URL of the image [BUG #4289]


        if (imageData == null || typeof imageData == "string") {
          imageData = {
            url: imageData,
            tooltip: null
          };
        } // If sizes are not included in map given by subclass,
        // fall-back to calculated image size


        if (!imageData.imageWidth || !imageData.imageHeight) {
          var sizes = this.__getImageSize(imageData.url);

          imageData.imageWidth = sizes.width;
          imageData.imageHeight = sizes.height;
        } // Add width and height keys to map [BUG #4289]
        // - [width|height] is read by _getContentHtml()
        // - [imageWidth|imageHeight] is possibly read in legacy applications


        imageData.width = imageData.imageWidth;
        imageData.height = imageData.imageHeight;
        return imageData;
      },

      /**
       * Compute the size of the given image
       *
       * @param source {String} the image URL
       * @return {Map} A map containing the image's <code>width</code> and
       *    <code>height</code>
       */
      __getImageSize: function __getImageSize(source) {
        var ResourceManager = qx.util.ResourceManager.getInstance();
        var ImageLoader = qx.io.ImageLoader;
        var width, height; // Detect if the image registry knows this image

        if (ResourceManager.has(source)) {
          width = ResourceManager.getImageWidth(source);
          height = ResourceManager.getImageHeight(source);
        } else if (ImageLoader.isLoaded(source)) {
          width = ImageLoader.getWidth(source);
          height = ImageLoader.getHeight(source);
        } else {
          width = this.__defaultWidth;
          height = this.__defaultHeight;
        }

        return {
          width: width,
          height: height
        };
      },
      // overridden
      createDataCellHtml: function createDataCellHtml(cellInfo, htmlArr) {
        this.__imageData = this._getImageInfos(cellInfo);
        return qx.ui.table.cellrenderer.AbstractImage.prototype.createDataCellHtml.base.call(this, cellInfo, htmlArr);
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        return qx.ui.table.cellrenderer.AbstractImage.prototype._getCellClass.base.call(this) + " qooxdoo-table-cell-icon";
      },
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        var content = "<div></div>"; // set image

        if (this.__imageData.url) {
          var srcUrl = this.__imageData.url;
          var highResolutionSource = qx.util.ResourceManager.getInstance().findHighResolutionSource(this.__imageData.url);

          if (highResolutionSource) {
            srcUrl = highResolutionSource;
          }

          var style = {
            width: this.__imageData.width + "px",
            height: this.__imageData.height + "px",
            display: qx.core.Environment.get("css.inlineblock"),
            verticalAlign: "top",
            position: "static"
          };

          if (qx.util.ResourceManager.getInstance().getCombinedFormat(this.__imageData.url) === "") {
            // background size is critical for high-resolution images but breaks combined images
            style["background-size"] = this.__imageData.width + "px " + this.__imageData.height + "px";
          }

          content = qx.bom.element.Decoration.create(srcUrl, this.getRepeat(), style);
        }

        return content;
      },
      // overridden
      _getCellAttributes: function _getCellAttributes(cellInfo) {
        var tooltip = this.__imageData.tooltip;

        if (tooltip) {
          return "title='" + tooltip + "'";
        } else {
          return "";
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__imageData = null;
    }
  });
  qx.ui.table.cellrenderer.AbstractImage.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.AbstractImage": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      },
      "qx.theme.manager.Meta": {
        "construct": true
      },
      "qx.util.ResourceManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
  
  ************************************************************************ */

  /**
   * A data cell renderer for boolean values.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Boolean", {
    extend: qx.ui.table.cellrenderer.AbstractImage,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.cellrenderer.AbstractImage.constructor.call(this);
      this.__aliasManager = qx.util.AliasManager.getInstance();
      this.initIconTrue();
      this.initIconFalse(); // dynamic theme switch

      {
        qx.theme.manager.Meta.getInstance().addListener("changeTheme", this._onChangeTheme, this);
      }
    },

    /*
     *****************************************************************************
       PROPERTIES
     *****************************************************************************
     */
    properties: {
      /**
       * The icon used to indicate the true state
       */
      iconTrue: {
        check: "String",
        init: "decoration/table/boolean-true.png",
        apply: "_applyIconTrue"
      },

      /**
      * The icon used to indicate the false state
      */
      iconFalse: {
        check: "String",
        init: "decoration/table/boolean-false.png",
        apply: "_applyIconFalse"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __iconUrlTrue: null,
      __iconUrlFalse: false,
      __aliasManager: null,

      /**
       * Handler for theme changes.
       * @signature function()
       */
      _onChangeTheme: function _onChangeTheme() {
        this._applyIconTrue(this.getIconTrue());

        this._applyIconFalse(this.getIconFalse());
      },
      // property apply
      _applyIconTrue: function _applyIconTrue(value) {
        this.__iconUrlTrue = this.__aliasManager.resolve(value);
      },
      // property apply
      _applyIconFalse: function _applyIconFalse(value) {
        this.__iconUrlFalse = this.__aliasManager.resolve(value);
      },
      // overridden
      _insetY: 5,
      // overridden
      _getCellStyle: function _getCellStyle(cellInfo) {
        return qx.ui.table.cellrenderer.Boolean.prototype._getCellStyle.base.call(this, cellInfo) + ";padding-top:4px;";
      },
      // overridden
      _identifyImage: function _identifyImage(cellInfo) {
        var w;
        var h;
        var rm;
        var id;
        var ids;
        var imageHints; // Retrieve the ID

        rm = qx.util.ResourceManager.getInstance();
        ids = rm.getIds(this.__iconUrlTrue); // If ID was found, we'll use its first (likely only) element here.

        if (ids) {
          id = ids[0]; // Get the natural size of the image

          w = rm.getImageWidth(id);
          h = rm.getImageHeight(id);
        } // Create the size portion of the hint.
        //
        // The traditional (fixed) size of the image was 11x11px. Use that if we
        // weren't able to retrieve the actual size of the image, and never
        // exceed that size.


        imageHints = {
          imageWidth: w ? Math.min(w, 11) : 11,
          imageHeight: h ? Math.min(h, 11) : 11
        }; // Add the URL portion of the hint

        switch (cellInfo.value) {
          case true:
            imageHints.url = this.__iconUrlTrue;
            break;

          case false:
            imageHints.url = this.__iconUrlFalse;
            break;

          default:
            imageHints.url = null;
            break;
        }

        return imageHints;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__aliasManager = null; // remove dynamic theme listener

      {
        qx.theme.manager.Meta.getInstance().removeListener("changeTheme", this._onChangeTheme, this);
      }
    }
  });
  qx.ui.table.cellrenderer.Boolean.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.util.format.NumberFormat": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Tartan Solutions, Inc, http://www.tartansolutions.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
  
     Authors:
       * Dan Hummon
  
  ************************************************************************ */

  /**
   * The conditional cell renderer allows special per cell formatting based on
   * conditions on the cell's value.
   *
   * @require(qx.util.format.NumberFormat)
   */
  qx.Class.define("qx.ui.table.cellrenderer.Conditional", {
    extend: qx.ui.table.cellrenderer.Default,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param align {String|null}
     *   The default text alignment to format the cell with by default.
     *
     * @param color {String|null}
     *   The default font color to format the cell with by default.
     *
     * @param style {String|null}
     *   The default font style to format the cell with by default.
     *
     * @param weight {String|null}
     *   The default font weight to format the cell with by default.
     */
    construct: function construct(align, color, style, weight) {
      qx.ui.table.cellrenderer.Default.constructor.call(this);
      this.numericAllowed = ["==", "!=", ">", "<", ">=", "<="];
      this.betweenAllowed = ["between", "!between"];
      this.conditions = [];
      this.__defaultTextAlign = align || "";
      this.__defaultColor = color || "";
      this.__defaultFontStyle = style || "";
      this.__defaultFontWeight = weight || "";
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __defaultTextAlign: null,
      __defaultColor: null,
      __defaultFontStyle: null,
      __defaultFontWeight: null,

      /**
       * Applies the cell styles to the style map.
       * @param condition {Array} The matched condition
       * @param style {Map} map of already applied styles.
       */
      __applyFormatting: function __applyFormatting(condition, style) {
        if (condition[1] != null) {
          style["text-align"] = condition[1];
        }

        if (condition[2] != null) {
          style["color"] = condition[2];
        }

        if (condition[3] != null) {
          style["font-style"] = condition[3];
        }

        if (condition[4] != null) {
          style["font-weight"] = condition[4];
        }
      },

      /**
       * The addNumericCondition method is used to add a basic numeric condition to
       * the cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the align,
       * color, style and weight arguments. Null will allow pre-existing formatting
       * to pass through, where an empty string will clear it back to the default
       * formatting set in the constructor.
       *
       *
       * @param condition {String} The type of condition. Accepted strings are "==", "!=", ">", "<", ">=",
       *     and "<=".
       * @param value1 {Integer} The value to compare against.
       * @param align {String|null} The text alignment to format the cell with if the condition matches.
       * @param color {String|null} The font color to format the cell with if the condition matches.
       * @param style {String|null} The font style to format the cell with if the condition matches.
       * @param weight {String|null} The font weight to format the cell with if the condition matches.
       * @param target {String|null} The text value of the column to compare against. If this is null,
       *     comparisons will be against the contents of this cell.
       * @throws {Error} If the condition can not be recognized or value is null.
       */
      addNumericCondition: function addNumericCondition(condition, value1, align, color, style, weight, target) {
        var temp = null;

        if (this.numericAllowed.includes(condition)) {
          if (value1 != null) {
            temp = [condition, align, color, style, weight, value1, target];
          }
        }

        if (temp != null) {
          this.conditions.push(temp);
        } else {
          throw new Error("Condition not recognized or value is null!");
        }
      },

      /**
       * The addBetweenCondition method is used to add a between condition to the
       * cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the align,
       * color, style and weight arguments. Null will allow pre-existing formatting
       * to pass through, where an empty string will clear it back to the default
       * formatting set in the constructor.
       *
       *
       * @param condition {String} The type of condition. Accepted strings are "between" and "!between".
       * @param value1 {Integer} The first value to compare against.
       * @param value2 {Integer} The second value to compare against.
       * @param align {String|null} The text alignment to format the cell with if the condition matches.
       * @param color {String|null} The font color to format the cell with if the condition matches.
       * @param style {String|null} The font style to format the cell with if the condition matches.
       * @param weight {String|null} The font weight to format the cell with if the condition matches.
       * @param target {String|null} The text value of the column to compare against. If this is null,
       *     comparisons will be against the contents of this cell.
       * @throws {Error} If the condition can not be recognized or value is null.
       */
      addBetweenCondition: function addBetweenCondition(condition, value1, value2, align, color, style, weight, target) {
        if (this.betweenAllowed.includes(condition)) {
          if (value1 != null && value2 != null) {
            var temp = [condition, align, color, style, weight, value1, value2, target];
          }
        }

        if (temp != null) {
          this.conditions.push(temp);
        } else {
          throw new Error("Condition not recognized or value1/value2 is null!");
        }
      },

      /**
       * The addRegex method is used to add a regular expression condition to the
       * cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the align,
       * color, style and weight arguments. Null will allow pre-existing formatting
       * to pass through, where an empty string will clear it back to the default
       * formatting set in the constructor.
       *
       *
       * @param regex {String} The regular expression to match against.
       * @param align {String|null} The text alignment to format the cell with if the condition matches.
       * @param color {String|null} The font color to format the cell with if the condition matches.
       * @param style {String|null} The font style to format the cell with if the condition matches.
       * @param weight {String|null} The font weight to format the cell with if the condition matches.
       * @param target {String|null} The text value of the column to compare against. If this is null,
       *     comparisons will be against the contents of this cell.
       * @throws {Error} If the regex is null.
       */
      addRegex: function addRegex(regex, align, color, style, weight, target) {
        if (regex != null) {
          var temp = ["regex", align, color, style, weight, regex, target];
        }

        if (temp != null) {
          this.conditions.push(temp);
        } else {
          throw new Error("regex cannot be null!");
        }
      },

      /**
       * Overridden; called whenever the cell updates. The cell will iterate through
       * each available condition and apply formatting for those that
       * match. Multiple conditions can match, but later conditions will override
       * earlier ones. Conditions with null values will stack with other conditions
       * that apply to that value.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {Map}
       */
      _getCellStyle: function _getCellStyle(cellInfo) {
        var tableModel = cellInfo.table.getTableModel();
        var i;
        var cond_test;
        var compareValue;
        var style = {
          "text-align": this.__defaultTextAlign,
          "color": this.__defaultColor,
          "font-style": this.__defaultFontStyle,
          "font-weight": this.__defaultFontWeight
        };

        for (i in this.conditions) {
          cond_test = false;

          if (this.numericAllowed.includes(this.conditions[i][0])) {
            if (this.conditions[i][6] == null) {
              compareValue = cellInfo.value;
            } else {
              compareValue = tableModel.getValueById(this.conditions[i][6], cellInfo.row);
            }

            switch (this.conditions[i][0]) {
              case "==":
                if (compareValue == this.conditions[i][5]) {
                  cond_test = true;
                }

                break;

              case "!=":
                if (compareValue != this.conditions[i][5]) {
                  cond_test = true;
                }

                break;

              case ">":
                if (compareValue > this.conditions[i][5]) {
                  cond_test = true;
                }

                break;

              case "<":
                if (compareValue < this.conditions[i][5]) {
                  cond_test = true;
                }

                break;

              case ">=":
                if (compareValue >= this.conditions[i][5]) {
                  cond_test = true;
                }

                break;

              case "<=":
                if (compareValue <= this.conditions[i][5]) {
                  cond_test = true;
                }

                break;
            }
          } else if (this.betweenAllowed.includes(this.conditions[i][0])) {
            if (this.conditions[i][7] == null) {
              compareValue = cellInfo.value;
            } else {
              compareValue = tableModel.getValueById(this.conditions[i][7], cellInfo.row);
            }

            switch (this.conditions[i][0]) {
              case "between":
                if (compareValue >= this.conditions[i][5] && compareValue <= this.conditions[i][6]) {
                  cond_test = true;
                }

                break;

              case "!between":
                if (compareValue < this.conditions[i][5] || compareValue > this.conditions[i][6]) {
                  cond_test = true;
                }

                break;
            }
          } else if (this.conditions[i][0] == "regex") {
            if (this.conditions[i][6] == null) {
              compareValue = cellInfo.value;
            } else {
              compareValue = tableModel.getValueById(this.conditions[i][6], cellInfo.row);
            }

            var the_pattern = new RegExp(this.conditions[i][5], 'g');
            cond_test = the_pattern.test(compareValue);
          } // Apply formatting, if any.


          if (cond_test == true) {
            this.__applyFormatting(this.conditions[i], style);
          }
        }

        var styleString = [];

        for (var key in style) {
          if (style[key]) {
            styleString.push(key, ":", style[key], ";");
          }
        }

        return styleString.join("");
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.numericAllowed = this.betweenAllowed = this.conditions = null;
    }
  });
  qx.ui.table.cellrenderer.Conditional.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Conditional": {
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 OpenHex SPRL, http://www.openhex.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gaetan de Menten (ged)
  
  ************************************************************************ */

  /**
   * Specific data cell renderer for dates.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Date", {
    extend: qx.ui.table.cellrenderer.Conditional,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * DateFormat used to format the data.
       */
      dateFormat: {
        check: "qx.util.format.DateFormat",
        init: null,
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _getContentHtml: function _getContentHtml(cellInfo) {
        var df = this.getDateFormat();

        if (df) {
          if (cellInfo.value) {
            return qx.bom.String.escape(df.format(cellInfo.value));
          } else {
            return "";
          }
        } else {
          return cellInfo.value || "";
        }
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        return "qooxdoo-table-cell";
      }
    }
  });
  qx.ui.table.cellrenderer.Date.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Abstract": {
        "require": true
      },
      "qx.dev.Debug": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A debug cell editor.  This displays cellInfo.value using
   * {@link qx.dev.Debug#debugObjectToString} so is useful as a starting point
   * during development of a table, before writing each of the cell renderers.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Debug", {
    extend: qx.ui.table.cellrenderer.Abstract,
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        var html = "<div style='height:" + cellInfo.styleHeight + "px;overflow:auto;'>" + qx.dev.Debug.debugObjectToString(cellInfo.value, "row=" + cellInfo.row + ", col=" + cellInfo.col, 10, true) + "</div>";
        return html;
      }
    }
  });
  qx.ui.table.cellrenderer.Debug.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */

  /**
   * A cell renderer factory which can dynamically exchange the cell renderer
   * based on information retrieved at runtime. This is useful when different
   * rows in a column should have different cell renderer based on cell content
   * or row metadata. A typical example would be a spreadsheet that has different
   * kind of data in one column.
   *
   */
  qx.Class.define("qx.ui.table.cellrenderer.Dynamic", {
    extend: qx.ui.table.cellrenderer.Default,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param cellRendererFactoryFunction {Function?null} The initial value for
     *    the property {@link #cellRendererFactoryFunction}.
     */
    construct: function construct(cellRendererFactoryFunction) {
      qx.ui.table.cellrenderer.Default.constructor.call(this);

      if (cellRendererFactoryFunction) {
        this.setCellRendererFactoryFunction(cellRendererFactoryFunction);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Function that returns a cellRenderer instance which will be
       * used for the row that is currently being edited. The function is
       * defined like this:
       *
       * <pre class="javascript">
       * myTable.getTableColumnModel().setCellRenderer(function(cellInfo){
       *   // based on the cellInfo map or other information, return the
       *   // appropriate cell renderer
       *   if (cellInfo.row == 5)
       *     return new qx.ui.table.cellrenderer.Boolean;
       *   else
       *     return new qx.ui.table.cellrenderer.Default;
       * });
       * </pre>
       *
       * the function MUST return at least a qx.ui.table.cellrenderer.Default
       **/
      cellRendererFactoryFunction: {
        check: "Function",
        nullable: true,
        init: null
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Overridden; called whenever the cell updates. The cell will call the
       * function stored in the cellRendererFactoryFunction to retrieve the
       * cell renderer which should be used for this particular cell
       *
       * @param cellInfo {Map} A map containing the information about the cell to
       *     create.
       * @param htmlArr {String[]} Target string container. The HTML of the data
       *     cell should be appended to this array.
       * @return {String} Data cell HTML
       */
      createDataCellHtml: function createDataCellHtml(cellInfo, htmlArr) {
        var cellRendererFactoryFunction = this.getCellRendererFactoryFunction();

        if (!cellRendererFactoryFunction) {
          throw new Error("No function provided! Aborting.");
        }

        var cellRenderer = cellRendererFactoryFunction(cellInfo);
        return cellRenderer.createDataCellHtml(cellInfo, htmlArr);
      }
    }
  });
  qx.ui.table.cellrenderer.Dynamic.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Conditional": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 OpenHex SPRL, http://www.openhex.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Dirk Wellmann (dw(at)piponline.net)
  
  ************************************************************************ */

  /**
   * This Cellrender is for transparent use, without escaping! Use this Cellrender
   * to output plain HTML content.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Html", {
    extend: qx.ui.table.cellrenderer.Conditional,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        return cellInfo.value || "";
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        return "qooxdoo-table-cell";
      }
    }
  });
  qx.ui.table.cellrenderer.Html.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.AbstractImage": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Tartan Solutions, Inc, http://www.tartansolutions.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
  
     Authors:
       * Dan Hummon
  
  ************************************************************************ */

  /**
   * The image cell renderer renders image into table cells.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Image", {
    extend: qx.ui.table.cellrenderer.AbstractImage,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param height {Integer?16} The height of the image. The default is 16.
     * @param width {Integer?16} The width of the image. The default is 16.
     */
    construct: function construct(width, height) {
      qx.ui.table.cellrenderer.AbstractImage.constructor.call(this);

      if (width) {
        this.__imageWidth = width;
      }

      if (height) {
        this.__imageHeight = height;
      }

      this.__am = qx.util.AliasManager.getInstance();
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __am: null,
      __imageHeight: 16,
      __imageWidth: 16,
      // overridden
      _identifyImage: function _identifyImage(cellInfo) {
        var imageHints = {
          imageWidth: this.__imageWidth,
          imageHeight: this.__imageHeight
        };

        if (cellInfo.value == "") {
          imageHints.url = null;
        } else {
          imageHints.url = this.__am.resolve(cellInfo.value);
        }

        imageHints.tooltip = cellInfo.tooltip;
        return imageHints;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__am = null;
    }
  });
  qx.ui.table.cellrenderer.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Conditional": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 OpenHex SPRL, http://www.openhex.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gaetan de Menten (ged)
  
  ************************************************************************ */

  /**
   * Specific data cell renderer for numbers.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Number", {
    extend: qx.ui.table.cellrenderer.Conditional,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * NumberFormat used to format data. If the numberFormat contains a
       * prefix and/or postfix containing characters which needs to be escaped,
       * those need to be given to the numberFormat in their escaped form
       * because no escaping happens at the cellrenderer level.
       */
      numberFormat: {
        check: "qx.util.format.NumberFormat",
        init: null,
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _getContentHtml: function _getContentHtml(cellInfo) {
        var nf = this.getNumberFormat();

        if (nf) {
          if (cellInfo.value || cellInfo.value == 0) {
            // I don't think we need to escape the resulting string, as I
            // don't know of any decimal or separator which use a character
            // which needs escaping. It is much more plausible to have a
            // prefix, postfix containing such characters but those can be
            // (should be) added in their escaped form to the number format.
            return nf.format(cellInfo.value);
          } else {
            return "";
          }
        } else {
          return cellInfo.value == 0 ? "0" : cellInfo.value || "";
        }
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        return "qooxdoo-table-cell qooxdoo-table-cell-right";
      }
    }
  });
  qx.ui.table.cellrenderer.Number.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */

  /**
   * A cell renderer which hides cell values such as passwords form view
   * by masking them by *s
   *
   */
  qx.Class.define("qx.ui.table.cellrenderer.Password", {
    extend: qx.ui.table.cellrenderer.Default,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Overridden; called whenever the cell updates.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {String}
       */
      _getContentHtml: function _getContentHtml(cellInfo) {
        var value = cellInfo.value;

        if (value === null) {
          value = "";
        }

        cellInfo.value = value.replace(/./g, "*");
        return qx.bom.String.escape(this._formatValue(cellInfo));
      }
    }
  });
  qx.ui.table.cellrenderer.Password.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */

  /**
   * The cell will use, if given, the
   * replaceMap property and/or the replaceFunction to look up labels for a
   * specific cell value. if the replaceMap, which does not need to be used but
   * takes precedence if given, has no entry for a specific value, you can implement
   * a fallback lookup in the replacementFunction, or use the replacementFunction exclusively.
   *
   * In editable cells, you need to make sure that the method returning the data
   * to the data storage (for example, a database backend) translates the replaced
   * cell value (the label) back into the corresponding value. Thus, both map and
   * function MUST also take care of the reverse translation of labels into
   * values. Example: if you have a field that should display "Active" on a "1"
   * value and "Inactive" on a "0" value, you must use the following map:
   *
   * <pre class='javascript'>
   * {
   *   0 : "Inactive",
   *   1 : "Active",
   *   "Inactive" : 0,
   *   "Active" : 1
   * }
   * </pre>
   *
   * You can use the addReversedReplaceMap() method to do this for you:
   * <pre class='javascript'>
   * var propertyCellRenderer = new qx.ui.table.cellrenderer.Replace;
   * propertyCellRenderer.setReplaceMap({
   *    1 : "Active",
   *   0 : "Inactive",
   *   2  : "Waiting",
   *   'admin' : "System Administrator",
   *   'manager' : "User Manager",
   *   'user' : "Website User"
   * });
   * propertyCellRenderer.addReversedReplaceMap();
   * </pre>
   *
   * @param cellInfo {Map} The information about the cell.
   *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
   * @return {String}
   */
  qx.Class.define("qx.ui.table.cellrenderer.Replace", {
    extend: qx.ui.table.cellrenderer.Default,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** a hashmap which is used to replace values by labels */
      replaceMap: {
        check: "Object",
        nullable: true,
        init: null
      },

      /**
       * function that provides the label for a specific value
       **/
      replaceFunction: {
        check: "Function",
        nullable: true,
        init: null
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        var value = cellInfo.value;
        var replaceMap = this.getReplaceMap();
        var replaceFunc = this.getReplaceFunction();
        var label; // use map

        if (replaceMap) {
          label = replaceMap[value];

          if (typeof label != "undefined") {
            cellInfo.value = label;
            return qx.bom.String.escape(this._formatValue(cellInfo));
          }
        } // use function


        if (replaceFunc) {
          cellInfo.value = replaceFunc(value);
        }

        return qx.bom.String.escape(this._formatValue(cellInfo));
      },

      /**
       * adds a reversed replaceMap to itself to translate labels back to the original values
       * @return {Boolean} <code>true</code>
       */
      addReversedReplaceMap: function addReversedReplaceMap() {
        var map = this.getReplaceMap();

        for (var key in map) {
          var value = map[key];
          map[value] = key;
        }

        return true;
      }
    }
  });
  qx.ui.table.cellrenderer.Replace.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Conditional": {
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 OpenHex SPRL, http://www.openhex.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gaetan de Menten (ged)
  
  ************************************************************************ */

  /**
   * The string data cell renderer. All it does is escape the incoming String
   * values.
   */
  qx.Class.define("qx.ui.table.cellrenderer.String", {
    extend: qx.ui.table.cellrenderer.Conditional,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        return qx.bom.String.escape(cellInfo.value || "");
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        return "qooxdoo-table-cell";
      }
    }
  });
  qx.ui.table.cellrenderer.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.columnmodel.Basic": {
        "construct": true,
        "require": true
      },
      "qx.locale.MTranslation": {
        "require": true
      },
      "qx.ui.table.columnmodel.resizebehavior.Default": {},
      "qx.event.Timer": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.tableResizeDebug": {}
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A table column model that automatically resizes columns based on a
   * selected behavior.
   *
   * @see qx.ui.table.columnmodel.Basic
   */
  qx.Class.define("qx.ui.table.columnmodel.Resize", {
    extend: qx.ui.table.columnmodel.Basic,
    include: qx.locale.MTranslation,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.columnmodel.Basic.constructor.call(this); // We don't want to recursively call ourself based on our resetting of
      // column sizes.  Track when we're resizing.

      this.__bInProgress = false; // Track when the table has appeared.  We want to ignore resize events
      // until then since we won't be able to determine the available width
      // anyway.

      this.__bAppeared = false;
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The behavior to use.
       *
       * The provided behavior must extend {@link qx.ui.table.columnmodel.resizebehavior.Abstract} and
       * implement the <i>onAppear</i>, <i>onTableWidthChanged</i>,
       * <i>onColumnWidthChanged</i> and <i>onVisibilityChanged</i>methods.
       */
      behavior: {
        check: "qx.ui.table.columnmodel.resizebehavior.Abstract",
        init: null,
        nullable: true,
        apply: "_applyBehavior",
        event: "changeBehavior"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __bAppeared: null,
      __bInProgress: null,
      __table: null,
      // Behavior modifier
      _applyBehavior: function _applyBehavior(value, old) {
        if (old != null) {
          old.dispose();
          old = null;
        } // Tell the new behavior how many columns there are


        value._setNumColumns(this.getOverallColumnCount());

        value.setTableColumnModel(this);
      },

      /**
       * Initializes the column model.
       *
       * @param numColumns {Integer} the number of columns the model should have.
       * @param table {qx.ui.table.Table}
       *   The table which this model is used for. This allows us access to
       *   other aspects of the table, as the <i>behavior</i> sees fit.
       */
      init: function init(numColumns, table) {
        // Call our superclass
        qx.ui.table.columnmodel.Resize.prototype.init.base.call(this, numColumns, table);

        if (this.__table == null) {
          this.__table = table; // We'll do our column resizing when the table appears, ...

          table.addListener("appear", this._onappear, this); // ... when the inner width of the table changes, ...

          table.addListener("tableWidthChanged", this._onTableWidthChanged, this); // ... when a vertical scroll bar appears or disappears

          table.addListener("verticalScrollBarChanged", this._onverticalscrollbarchanged, this); // We want to manipulate the button visibility menu

          table.addListener("columnVisibilityMenuCreateEnd", this._addResetColumnWidthButton, this); // ... when columns are resized, ...

          this.addListener("widthChanged", this._oncolumnwidthchanged, this); // ... and when a column visibility changes.

          this.addListener("visibilityChanged", this._onvisibilitychanged, this);
        } // Set the initial resize behavior


        if (this.getBehavior() == null) {
          this.setBehavior(new qx.ui.table.columnmodel.resizebehavior.Default());
        } // Tell the behavior how many columns there are


        this.getBehavior()._setNumColumns(numColumns);
      },

      /**
       * Get the table widget
       *
       * @return {qx.ui.table.Table} the table widget
       */
      getTable: function getTable() {
        return this.__table;
      },

      /**
       * Reset the column widths to their "onappear" defaults.
       *
       * @param event {qx.event.type.Data}
       *   The "columnVisibilityMenuCreateEnd" event indicating that the menu is
       *   being generated.  The data is a map containing properties <i>table</i>
       *   and <i>menu</i>.
       *
       */
      _addResetColumnWidthButton: function _addResetColumnWidthButton(event) {
        var data = event.getData();
        var columnButton = data.columnButton;
        var menu = data.menu;
        var o; // Add a separator between the column names and our reset button

        o = columnButton.factory("separator");
        menu.add(o); // Add a button to reset the column widths

        o = columnButton.factory("user-button", {
          text: this.tr("Reset column widths")
        });
        menu.add(o);
        o.addListener("execute", this._onappear, this);
      },

      /**
       * Event handler for the "appear" event.
       *
       * @param event {qx.event.type.Event}
       *   The "onappear" event object.
       *
       */
      _onappear: function _onappear(event) {
        // Is this a recursive call?
        if (this.__bInProgress) {
          // Yup.  Ignore it.
          return;
        }

        this.__bInProgress = true;
        {
          if (qx.core.Environment.get("qx.tableResizeDebug")) {
            this.debug("onappear");
          }
        } // this handler is also called by the "execute" event of the menu button

        this.getBehavior().onAppear(event, event.getType() !== "appear");

        this.__table._updateScrollerWidths();

        this.__table._updateScrollBarVisibility();

        this.__bInProgress = false;
        this.__bAppeared = true;
      },

      /**
       * Event handler for the "tableWidthChanged" event.
       *
       * @param event {qx.event.type.Event}
       *   The "onwindowresize" event object.
       *
       */
      _onTableWidthChanged: function _onTableWidthChanged(event) {
        // Is this a recursive call or has the table not yet been rendered?
        if (this.__bInProgress || !this.__bAppeared) {
          // Yup.  Ignore it.
          return;
        }

        this.__bInProgress = true;
        {
          if (qx.core.Environment.get("qx.tableResizeDebug")) {
            this.debug("ontablewidthchanged");
          }
        }
        this.getBehavior().onTableWidthChanged(event);
        this.__bInProgress = false;
      },

      /**
       * Event handler for the "verticalScrollBarChanged" event.
       *
       * @param event {qx.event.type.Data}
       *   The "verticalScrollBarChanged" event object.  The data is a boolean
       *   indicating whether a vertical scroll bar is now present.
       *
       */
      _onverticalscrollbarchanged: function _onverticalscrollbarchanged(event) {
        // Is this a recursive call or has the table not yet been rendered?
        if (this.__bInProgress || !this.__bAppeared) {
          // Yup.  Ignore it.
          return;
        }

        this.__bInProgress = true;
        {
          if (qx.core.Environment.get("qx.tableResizeDebug")) {
            this.debug("onverticalscrollbarchanged");
          }
        }
        this.getBehavior().onVerticalScrollBarChanged(event);
        qx.event.Timer.once(function () {
          if (this.__table && !this.__table.isDisposed()) {
            this.__table._updateScrollerWidths();

            this.__table._updateScrollBarVisibility();
          }
        }, this, 0);
        this.__bInProgress = false;
      },

      /**
       * Event handler for the "widthChanged" event.
       *
       * @param event {qx.event.type.Data}
       *   The "widthChanged" event object.
       *
       */
      _oncolumnwidthchanged: function _oncolumnwidthchanged(event) {
        // Is this a recursive call or has the table not yet been rendered?
        if (this.__bInProgress || !this.__bAppeared) {
          // Yup.  Ignore it.
          return;
        }

        this.__bInProgress = true;
        {
          if (qx.core.Environment.get("qx.tableResizeDebug")) {
            this.debug("oncolumnwidthchanged");
          }
        }
        this.getBehavior().onColumnWidthChanged(event);
        this.__bInProgress = false;
      },

      /**
       * Event handler for the "visibilityChanged" event.
       *
       * @param event {qx.event.type.Data}
       *   The "visibilityChanged" event object.
       *
       */
      _onvisibilitychanged: function _onvisibilitychanged(event) {
        // Is this a recursive call or has the table not yet been rendered?
        if (this.__bInProgress || !this.__bAppeared) {
          // Yup.  Ignore it.
          return;
        }

        this.__bInProgress = true;
        {
          if (qx.core.Environment.get("qx.tableResizeDebug")) {
            this.debug("onvisibilitychanged");
          }
        }
        this.getBehavior().onVisibilityChanged(event);
        this.__bInProgress = false;
      }
    },

    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct: function destruct() {
      var behavior = this.getBehavior();

      if (behavior) {
        behavior.dispose();
      }

      this.__table = null;
    }
  });
  qx.ui.table.columnmodel.Resize.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * An abstract resize behavior.  All resize behaviors should extend this
   * class.
   */
  qx.Class.define("qx.ui.table.columnmodel.resizebehavior.Abstract", {
    type: "abstract",
    extend: qx.core.Object,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Called when the ResizeTableColumnModel is initialized, and upon loading of
       * a new TableModel, to allow the Resize Behaviors to know how many columns
       * are in use.
       *
       * @abstract
       * @param numColumns {Integer} The number of columns in use.
       * @throws {Error} the abstract function warning.
       */
      _setNumColumns: function _setNumColumns(numColumns) {
        throw new Error("_setNumColumns is abstract");
      },

      /**
       * Called when the table has first been rendered.
       *
       * @abstract
       * @param event {var} The <i>onappear</i> event object.
       * @param forceRefresh {Boolean?false} Whether a refresh should be forced
       * @throws {Error} the abstract function warning.
       */
      onAppear: function onAppear(event, forceRefresh) {
        throw new Error("onAppear is abstract");
      },

      /**
       * Called when the table width changes due to either a window size change
       * or a parent object changing size causing the table to change size.
       *
       * @abstract
       * @param event {var} The <i>tableWidthChanged</i> event object.
       * @throws {Error} the abstract function warning.
       */
      onTableWidthChanged: function onTableWidthChanged(event) {
        throw new Error("onTableWidthChanged is abstract");
      },

      /**
       * Called when the use of vertical scroll bar in the table changes, either
       * from present to not present, or vice versa.
       *
       * @abstract
       * @param event {var} The <i>verticalScrollBarChanged</i> event object.  This event has data,
       *     obtained via event.getValue(), which is a boolean indicating whether a
       *     vertical scroll bar is now present.
       * @throws {Error} the abstract function warning.
       */
      onVerticalScrollBarChanged: function onVerticalScrollBarChanged(event) {
        throw new Error("onVerticalScrollBarChanged is abstract");
      },

      /**
       * Called when a column width is changed.
       *
       * @abstract
       * @param event {var} The <i>widthChanged</i> event object.  This event has data, obtained via
       *     event.getValue(), which is an object with three properties: the column
       *     which changed width (data.col), the old width (data.oldWidth) and the new
       *     width (data.newWidth).
       * @throws {Error} the abstract function warning.
       */
      onColumnWidthChanged: function onColumnWidthChanged(event) {
        throw new Error("onColumnWidthChanged is abstract");
      },

      /**
       * Called when a column visibility is changed.
       *
       * @abstract
       * @param event {var} The <i>visibilityChanged</i> event object.  This event has data, obtained
       *     via event.getValue(), which is an object with two properties: the column
       *     which changed width (data.col) and the new visibility of the column
       *     (data.visible).
       * @throws {Error} the abstract function warning.
       */
      onVisibilityChanged: function onVisibilityChanged(event) {
        throw new Error("onVisibilityChanged is abstract");
      },

      /**
       * Determine the inner width available to columns in the table.
       *
       * @return {Integer} The available width
       */
      _getAvailableWidth: function _getAvailableWidth() {
        var tableColumnModel = this.getTableColumnModel(); // Get the inner width off the table

        var table = tableColumnModel.getTable();

        var scrollerArr = table._getPaneScrollerArr();

        if (!scrollerArr[0] || !scrollerArr[0].getLayoutParent().getBounds()) {
          return null;
        }

        ;
        var scrollerParentWidth = scrollerArr[0].getLayoutParent().getBounds().width;
        var lastScroller = scrollerArr[scrollerArr.length - 1];
        scrollerParentWidth -= lastScroller.getPaneInsetRight();
        return scrollerParentWidth;
      }
    }
  });
  qx.ui.table.columnmodel.resizebehavior.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.ui.core.ColumnData": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.columnmodel.resizebehavior.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.util.DeferredCall": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * The default resize behavior.  Until a resize model is loaded, the default
   * behavior is to:
   * <ol>
   *   <li>
   *     Upon the table initially appearing, and upon any window resize, divide
   *     the table space equally between the visible columns.
   *   </li>
   *   <li>
   *     When a column is increased in width, all columns to its right are
   *     pushed to the right with no change to their widths.  This may push some
   *     columns off the right edge of the table, causing a horizontal scroll
   *     bar to appear.
   *   </li>
   *   <li>
   *     When a column is decreased in width, if the total width of all columns
   *     is <i>greater than</i> the table width, no additional column width
   *     change is made.
   *   </li>
   *   <li>
   *     When a column is decreased in width, if the total width of all columns
   *     is <i>less than</i> the table width, the visible column
   *     immediately to the right of the column which decreased in width has its
   *     width increased to fill the remaining space.
   *   </li>
   * </ol>
   *
   * A resize model may be loaded to provide more guidance on how to adjust
   * column width upon each of the events: initial appear, window resize, and
   * column resize. *** TO BE FILLED IN ***
   *
   * @require(qx.ui.core.ColumnData)
   */
  qx.Class.define("qx.ui.table.columnmodel.resizebehavior.Default", {
    extend: qx.ui.table.columnmodel.resizebehavior.Abstract,
    construct: function construct() {
      qx.ui.table.columnmodel.resizebehavior.Abstract.constructor.call(this);
      this.__resizeColumnData = []; // This layout is not connected to a widget but to this class. This class
      // must implement the method "getLayoutChildren", which must return all
      // columns (LayoutItems) which should be recalculated. The call
      // "layout.renderLayout" will call the method "renderLayout" on each column
      // data object
      // The advantage of the use of the normal layout manager is that the
      // semantics of flex and percent are exactly the same as in the widget code.

      this.__layout = new qx.ui.layout.HBox();

      this.__layout.connectToWidget(this);

      this.__deferredComputeColumnsFlexWidth = new qx.util.DeferredCall(this._computeColumnsFlexWidth, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * A function to instantiate a resize behavior column data object.
       */
      newResizeBehaviorColumnData: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.core.ColumnData();
        }
      },

      /**
       * Whether to reinitialize default widths on each appear event.
       * Typically, one would want to initialize the default widths only upon
       * the first appearance of the table, but the original behavior was to
       * reinitialize it even if the table is hidden and then reshown
       * (e.g. it's in a pageview and the page is switched and then switched
       * back).
       */
      initializeWidthsOnEveryAppear: {
        check: "Boolean",
        init: false
      },

      /**
       * The table column model in use.  Of particular interest is the method
       * <i>getTable</i> which is a reference to the table widget.  This allows
       * access to any other features of the table, for use in calculating widths
       * of columns.
       */
      tableColumnModel: {
        check: "qx.ui.table.columnmodel.Resize"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __layout: null,
      __layoutChildren: null,
      __resizeColumnData: null,
      __deferredComputeColumnsFlexWidth: null,

      /**
       * Whether we have initialized widths on the first appear yet
       */
      __widthsInitialized: false,

      /**
       * Set the width of a column.
       *
       * @param col {Integer} The column whose width is to be set
       *
       * @param width {Integer|String}
       *   The width of the specified column.  The width may be specified as
       *   integer number of pixels (e.g. 100), a string representing percentage
       *   of the inner width of the Table (e.g. "25%"), or a string
       *   representing a flex width (e.g. "1*").
       *
       * @param flex {Integer?0} Optional flex value of the column
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setWidth: function setWidth(col, width, flex) {
        // Ensure the column is within range
        if (col >= this.__resizeColumnData.length) {
          throw new Error("Column number out of range");
        } // Set the new width


        this.__resizeColumnData[col].setColumnWidth(width, flex);

        this.__deferredComputeColumnsFlexWidth.schedule();
      },

      /**
       * Set the minimum width of a column.
       *
       * @param col {Integer}
       *   The column whose minimum width is to be set
       *
       * @param width {Integer}
       *   The minimum width of the specified column.
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setMinWidth: function setMinWidth(col, width) {
        // Ensure the column is within range
        if (col >= this.__resizeColumnData.length) {
          throw new Error("Column number out of range");
        } // Set the new width


        this.__resizeColumnData[col].setMinWidth(width);

        this.__deferredComputeColumnsFlexWidth.schedule();
      },

      /**
       * Set the maximum width of a column.
       *
       * @param col {Integer}
       *   The column whose maximum width is to be set
       *
       * @param width {Integer}
       *   The maximum width of the specified column.
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setMaxWidth: function setMaxWidth(col, width) {
        // Ensure the column is within range
        if (col >= this.__resizeColumnData.length) {
          throw new Error("Column number out of range");
        } // Set the new width


        this.__resizeColumnData[col].setMaxWidth(width);

        this.__deferredComputeColumnsFlexWidth.schedule();
      },

      /**
       * Set any or all of the width, minimum width, and maximum width of a
       * column in a single call.
       *
       * @param col {Integer}
       *   The column whose attributes are to be changed
       *
       * @param map {Map}
       *   A map containing any or all of the property names "width", "minWidth",
       *   and "maxWidth".  The property values are as described for
       *   {@link #setWidth}, {@link #setMinWidth} and {@link #setMaxWidth}
       *   respectively.
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      set: function set(col, map) {
        for (var prop in map) {
          switch (prop) {
            case "width":
              this.setWidth(col, map[prop]);
              break;

            case "minWidth":
              this.setMinWidth(col, map[prop]);
              break;

            case "maxWidth":
              this.setMaxWidth(col, map[prop]);
              break;

            default:
              throw new Error("Unknown property: " + prop);
          }
        }
      },
      // overloaded
      onAppear: function onAppear(event, forceRefresh) {
        // If we haven't initialized widths at least once, or
        // they want us to reinitialize widths on every appear event...
        if (forceRefresh === true || !this.__widthsInitialized || this.getInitializeWidthsOnEveryAppear()) {
          // Calculate column widths
          this._computeColumnsFlexWidth(); // Track that we've initialized widths at least once


          this.__widthsInitialized = true;
        }
      },
      // overloaded
      onTableWidthChanged: function onTableWidthChanged(event) {
        this._computeColumnsFlexWidth();
      },
      // overloaded
      onVerticalScrollBarChanged: function onVerticalScrollBarChanged(event) {
        this._computeColumnsFlexWidth();
      },
      // overloaded
      onColumnWidthChanged: function onColumnWidthChanged(event) {
        // Extend the next column to fill blank space
        this._extendNextColumn(event);
      },
      // overloaded
      onVisibilityChanged: function onVisibilityChanged(event) {
        // Event data properties: col, visible
        var data = event.getData(); // If a column just became visible, resize all columns.

        if (data.visible) {
          this._computeColumnsFlexWidth();

          return;
        } // Extend the last column to fill blank space


        this._extendLastColumn(event);
      },
      // overloaded
      _setNumColumns: function _setNumColumns(numColumns) {
        var colData = this.__resizeColumnData; // Are there now fewer (or the same number of) columns than there were
        // previously?

        if (numColumns <= colData.length) {
          // Yup.  Delete the extras.
          colData.splice(numColumns, colData.length);
          return;
        } // There are more columns than there were previously.  Allocate more.


        for (var i = colData.length; i < numColumns; i++) {
          colData[i] = this.getNewResizeBehaviorColumnData()();
          colData[i].columnNumber = i;
        }
      },

      /**
       * This method is required by the box layout. If returns an array of items
       * to relayout.
       *
       * @return {qx.ui.core.ColumnData[]} The list of column data object to layout.
       */
      getLayoutChildren: function getLayoutChildren() {
        return this.__layoutChildren;
      },

      /**
       * Computes the width of all flexible children.
       *
       */
      _computeColumnsFlexWidth: function _computeColumnsFlexWidth() {
        this.__deferredComputeColumnsFlexWidth.cancel();

        var width = this._getAvailableWidth();

        if (width === null) {
          return;
        }

        var tableColumnModel = this.getTableColumnModel();
        var visibleColumns = tableColumnModel.getVisibleColumns();
        var visibleColumnsLength = visibleColumns.length;
        var colData = this.__resizeColumnData;
        var i, l;

        if (visibleColumnsLength === 0) {
          return;
        } // Create an array of the visible columns


        var columns = [];

        for (i = 0; i < visibleColumnsLength; i++) {
          columns.push(colData[visibleColumns[i]]);
        }

        this.__layoutChildren = columns;

        this.__clearLayoutCaches(); // Use a horizontal box layout to determine the available width.


        this.__layout.renderLayout(width, 100, {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }); // Now that we've calculated the width, set it.


        for (i = 0, l = columns.length; i < l; i++) {
          var colWidth = columns[i].getComputedWidth();
          tableColumnModel.setColumnWidth(visibleColumns[i], colWidth);
        }
      },

      /**
       * Clear all layout caches of the column datas.
       */
      __clearLayoutCaches: function __clearLayoutCaches() {
        this.__layout.invalidateChildrenCache();

        var children = this.__layoutChildren;

        for (var i = 0, l = children.length; i < l; i++) {
          children[i].invalidateLayoutCache();
        }
      },

      /**
       * Extend the visible column to right of the column which just changed
       * width, to fill any available space within the inner width of the table.
       * This means that if the sum of the widths of all columns exceeds the
       * inner width of the table, no change is made.  If, on the other hand,
       * the sum of the widths of all columns is less than the inner width of
       * the table, the visible column to the right of the column which just
       * changed width is extended to take up the width available within the
       * inner width of the table.
       *
       *
       * @param event {qx.event.type.Data}
       *   The event object.
       *
       */
      _extendNextColumn: function _extendNextColumn(event) {
        var tableColumnModel = this.getTableColumnModel(); // Event data properties: col, oldWidth, newWidth

        var data = event.getData();
        var visibleColumns = tableColumnModel.getVisibleColumns(); // Determine the available width

        var width = this._getAvailableWidth(); // Determine the number of visible columns


        var numColumns = visibleColumns.length; // Did this column become longer than it was?

        if (data.newWidth > data.oldWidth) {
          // Yup.  Don't resize anything else.  The other columns will just get
          // pushed off and require scrollbars be added (if not already there).
          return;
        } // This column became shorter.  See if we no longer take up the full
        // space that's available to us.


        var i;
        var nextCol;
        var widthUsed = 0;

        for (i = 0; i < numColumns; i++) {
          widthUsed += tableColumnModel.getColumnWidth(visibleColumns[i]);
        } // If the used width is less than the available width...


        if (widthUsed < width) {
          // ... then determine the next visible column
          for (i = 0; i < visibleColumns.length; i++) {
            if (visibleColumns[i] == data.col) {
              nextCol = visibleColumns[i + 1];
              break;
            }
          }

          if (nextCol) {
            // Make the next column take up the available space.
            var newWidth = width - (widthUsed - tableColumnModel.getColumnWidth(nextCol));
            tableColumnModel.setColumnWidth(nextCol, newWidth);
          }
        }
      },

      /**
       * If a column was just made invisible, extend the last column to fill any
       * available space within the inner width of the table.  This means that
       * if the sum of the widths of all columns exceeds the inner width of the
       * table, no change is made.  If, on the other hand, the sum of the widths
       * of all columns is less than the inner width of the table, the last
       * column is extended to take up the width available within the inner
       * width of the table.
       *
       *
       * @param event {qx.event.type.Data}
       *   The event object.
       *
       */
      _extendLastColumn: function _extendLastColumn(event) {
        var tableColumnModel = this.getTableColumnModel(); // Event data properties: col, visible

        var data = event.getData(); // If the column just became visible, don't make any width changes

        if (data.visible) {
          return;
        } // Get the array of visible columns


        var visibleColumns = tableColumnModel.getVisibleColumns(); // If no columns are visible...

        if (visibleColumns.length == 0) {
          return;
        } // Determine the available width


        var width = this._getAvailableWidth(tableColumnModel); // Determine the number of visible columns


        var numColumns = visibleColumns.length; // See if we no longer take up the full space that's available to us.

        var i;
        var lastCol;
        var widthUsed = 0;

        for (i = 0; i < numColumns; i++) {
          widthUsed += tableColumnModel.getColumnWidth(visibleColumns[i]);
        } // If the used width is less than the available width...


        if (widthUsed < width) {
          // ... then get the last visible column
          lastCol = visibleColumns[visibleColumns.length - 1]; // Make the last column take up the available space.

          var newWidth = width - (widthUsed - tableColumnModel.getColumnWidth(lastCol));
          tableColumnModel.setColumnWidth(lastCol, newWidth);
        }
      },

      /**
       * Returns an array of the resizing information of a column.
       *
       * @return {qx.ui.core.ColumnData[]} array of the resizing information of a column.
       */
      _getResizeColumnData: function _getResizeColumnData() {
        return this.__resizeColumnData;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__resizeColumnData = this.__layoutChildren = null;

      this._disposeObjects("__layout", "__deferredComputeColumnsFlexWidth");
    }
  });
  qx.ui.table.columnmodel.resizebehavior.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.headerrenderer.Default": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
  
  ************************************************************************ */

  /**
   * A header cell renderer which renders an icon (only). The icon cannot be combined
   * with text.
   */
  qx.Class.define("qx.ui.table.headerrenderer.Icon", {
    extend: qx.ui.table.headerrenderer.Default,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param iconUrl {String} URL to the icon to show
     * @param tooltip {String ? ""} Text of the tooltip to show if the pointer hovers over the
     *                             icon
     */
    construct: function construct(iconUrl, tooltip) {
      qx.ui.table.headerrenderer.Default.constructor.call(this);

      if (iconUrl == null) {
        iconUrl = "";
      }

      this.setIconUrl(iconUrl);

      if (tooltip) {
        this.setToolTip(tooltip);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * URL of the icon to show
       */
      iconUrl: {
        check: "String",
        init: ""
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      updateHeaderCell: function updateHeaderCell(cellInfo, cellWidget) {
        qx.ui.table.headerrenderer.Icon.prototype.updateHeaderCell.base.call(this, cellInfo, cellWidget);
        cellWidget.setIcon(this.getIconUrl());
      }
    }
  });
  qx.ui.table.headerrenderer.Icon.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.model.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A table model that loads its data from a backend.
   * <p>
   * Only a subset of the available rows, those which are within or near the
   * currently visible area, are loaded. If a quick scroll operation occurs,
   * rows will soon be displayed using asynchronous loading in the background.
   * All loaded data is managed through a cache which automatically removes
   * the oldest used rows when it gets full.
   * <p>
   * This class is abstract: The actual loading of row data must be done by
   * subclasses.
   */
  qx.Class.define("qx.ui.table.model.Remote", {
    type: "abstract",
    extend: qx.ui.table.model.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.model.Abstract.constructor.call(this);
      this._sortColumnIndex = -1;
      this._sortAscending = true;
      this._rowCount = -1;
      this._lruCounter = 0; // Holds the index of the first block that is currently loading.
      // Is -1 if there is currently no request on its way.

      this._firstLoadingBlock = -1; // Holds the index of the first row that should be loaded when the response of
      // the current request arrives. Is -1 we need no following request.

      this._firstRowToLoad = -1; // Counterpart to _firstRowToLoad

      this._lastRowToLoad = -1; // Holds whether the current request will bring obsolete data. When true the
      // response of the current request will be ignored.

      this._ignoreCurrentRequest = false;
      this._rowBlockCache = {};
      this._rowBlockCount = 0;
      this._sortableColArr = null;
      this._editableColArr = null;
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The number of rows that are stored in one cache block. */
      blockSize: {
        check: "Integer",
        init: 50
      },

      /** The maximum number of row blocks kept in the cache. */
      maxCachedBlockCount: {
        check: "Integer",
        init: 15
      },

      /**
       * Whether to clear the cache when some rows are removed.
       * If true the rows are removed locally in the cache.
       */
      clearCacheOnRemove: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether to block remote requests for the row count while a request for
       * the row count is pending. Row counts are requested at various times and
       * from various parts of the code, resulting in numerous requests to the
       * user-provided _loadRowCount() method, often while other requests are
       * already pending. The default behavior now ignores requests to load a
       * new row count if such a request is already pending. It is therefore now
       * conceivable that the row count changes between an initial request for
       * the row count and a later (ignored) request. Since the chance of this
       * is low, the desirability of reducing the server requests outweighs the
       * slight possibility of an altered count (which will, by the way, be
       * detected soon thereafter upon the next request for the row count). If
       * the old behavior is desired, set this property to false.
       */
      blockConcurrentLoadRowCount: {
        check: "Boolean",
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _rowCount: null,
      _ignoreCurrentRequest: null,
      _lruCounter: null,
      _firstLoadingBlock: null,
      _firstRowToLoad: null,
      _lastRowToLoad: null,
      _rowBlockCache: null,
      _rowBlockCount: null,
      _sortColumnIndex: null,
      _sortAscending: null,
      _editableColArr: null,
      _sortableColArr: null,
      _loadRowCountRequestRunning: false,
      _clearCache: false,

      /**
       * Returns whether the current request is ignored by the model.
       *
       * @return {Boolean} true when the current request is ignored by the model.
       */
      _getIgnoreCurrentRequest: function _getIgnoreCurrentRequest() {
        return this._ignoreCurrentRequest;
      },
      // overridden
      getRowCount: function getRowCount() {
        if (this._rowCount == -1) {
          if (!this._loadRowCountRequestRunning || !this.getBlockConcurrentLoadRowCount()) {
            this._loadRowCountRequestRunning = true;

            this._loadRowCount();
          } // NOTE: _loadRowCount may set this._rowCount


          return this._rowCount == -1 ? 0 : this._rowCount;
        } else {
          return this._rowCount;
        }
      },

      /**
       * Implementing classes have to call {@link #_onRowCountLoaded} when the
       * server response arrived. That method has to be called! Even when there
       * was an error.
       *
       * @abstract
       * @throws {Error} the abstract function warning.
       */
      _loadRowCount: function _loadRowCount() {
        throw new Error("_loadRowCount is abstract");
      },

      /**
       * Sets the row count.
       *
       * Has to be called by {@link #_loadRowCount}.
       *
       * @param rowCount {Integer} the number of rows in this model or null if loading.
       */
      _onRowCountLoaded: function _onRowCountLoaded(rowCount) {
        if (this.getBlockConcurrentLoadRowCount()) {
          // There's no longer a loadRowCount() in progress
          this._loadRowCountRequestRunning = false;
        } // this.debug("row count loaded: " + rowCount);


        if (rowCount == null || rowCount < 0) {
          rowCount = 0;
        }

        this._rowCount = Number(rowCount); // Inform the listeners

        var data = {
          firstRow: 0,
          lastRow: rowCount - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1
        };
        this.fireDataEvent("dataChanged", data);
      },

      /**
       * Reloads the model and clears the local cache.
       *
       */
      reloadData: function reloadData() {
        // If there is currently a request on its way, then this request will bring
        // obsolete data -> Ignore it
        if (this._firstLoadingBlock != -1) {
          var cancelingSucceed = this._cancelCurrentRequest();

          if (cancelingSucceed) {
            // The request was canceled -> We're not loading any blocks any more
            this._firstLoadingBlock = -1;
            this._ignoreCurrentRequest = false;
          } else {
            // The request was not canceled -> Ignore it
            this._ignoreCurrentRequest = true;
          }
        } // Force clearing row cache, because of reloading data.


        this._clearCache = true; // Forget a possibly outstanding request
        // (_loadRowCount will tell the listeners anyway, that the whole table
        // changed)
        //
        // NOTE: This will inform the listeners as soon as the new row count is
        // known

        this._firstRowToLoad = -1;
        this._lastRowToLoad = -1;
        this._loadRowCountRequestRunning = true;

        this._loadRowCount();
      },

      /**
       * Clears the cache.
       *
       */
      clearCache: function clearCache() {
        this._rowBlockCache = {};
        this._rowBlockCount = 0;
      },

      /**
       * Returns the current state of the cache.
       * <p>
       * Do not change anything in the returned data. This breaks the model state.
       * Use this method only together with {@link #restoreCacheContent} for backing
       * up state for a later restore.
       *
       * @return {Map} the current cache state.
       */
      getCacheContent: function getCacheContent() {
        return {
          sortColumnIndex: this._sortColumnIndex,
          sortAscending: this._sortAscending,
          rowCount: this._rowCount,
          lruCounter: this._lruCounter,
          rowBlockCache: this._rowBlockCache,
          rowBlockCount: this._rowBlockCount
        };
      },

      /**
       * Restores a cache state created by {@link #getCacheContent}.
       *
       * @param cacheContent {Map} An old cache state.
       */
      restoreCacheContent: function restoreCacheContent(cacheContent) {
        // If there is currently a request on its way, then this request will bring
        // obsolete data -> Ignore it
        if (this._firstLoadingBlock != -1) {
          // Try to cancel the current request
          var cancelingSucceed = this._cancelCurrentRequest();

          if (cancelingSucceed) {
            // The request was canceled -> We're not loading any blocks any more
            this._firstLoadingBlock = -1;
            this._ignoreCurrentRequest = false;
          } else {
            // The request was not canceled -> Ignore it
            this._ignoreCurrentRequest = true;
          }
        } // Restore the cache content


        this._sortColumnIndex = cacheContent.sortColumnIndex;
        this._sortAscending = cacheContent.sortAscending;
        this._rowCount = cacheContent.rowCount;
        this._lruCounter = cacheContent.lruCounter;
        this._rowBlockCache = cacheContent.rowBlockCache;
        this._rowBlockCount = cacheContent.rowBlockCount; // Inform the listeners

        var data = {
          firstRow: 0,
          lastRow: this._rowCount - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1
        };
        this.fireDataEvent("dataChanged", data);
      },

      /**
       * Cancels the current request if possible.
       *
       * Should be overridden by subclasses if they are able to cancel requests. This
       * allows sending a new request directly after a call of {@link #reloadData}.
       *
       * @return {Boolean} whether the request was canceled.
       */
      _cancelCurrentRequest: function _cancelCurrentRequest() {
        return false;
      },

      /**
       * Iterates through all cached rows.
       *
       * The iterator will be called for each cached row with two parameters: The row
       * index of the current row (Integer) and the row data of that row (var[]). If
       * the iterator returns something this will be used as new row data.
       *
       * The iterator is called in the same order as the rows are in the model
       * (the row index is always ascending).
       *
       * @param iterator {Function} The iterator function to call.
       * @param object {Object} context of the iterator
       */
      iterateCachedRows: function iterateCachedRows(iterator, object) {
        var blockSize = this.getBlockSize();
        var blockCount = Math.ceil(this.getRowCount() / blockSize); // Remove the row and move the rows of all following blocks

        for (var block = 0; block <= blockCount; block++) {
          var blockData = this._rowBlockCache[block];

          if (blockData != null) {
            var rowOffset = block * blockSize;
            var rowDataArr = blockData.rowDataArr;

            for (var relRow = 0; relRow < rowDataArr.length; relRow++) {
              // Call the iterator for this row
              var rowData = rowDataArr[relRow];
              var newRowData = iterator.call(object, rowOffset + relRow, rowData);

              if (newRowData != null) {
                rowDataArr[relRow] = newRowData;
              }
            }
          }
        }
      },
      // overridden
      prefetchRows: function prefetchRows(firstRowIndex, lastRowIndex) {
        // this.debug("Prefetch wanted: " + firstRowIndex + ".." + lastRowIndex);
        if (this._firstLoadingBlock == -1) {
          var blockSize = this.getBlockSize();
          var totalBlockCount = Math.ceil(this._rowCount / blockSize); // There is currently no request running -> Start a new one
          // NOTE: We load one more block above and below to have a smooth
          //       scrolling into the next block without blank cells

          var firstBlock = parseInt(firstRowIndex / blockSize, 10) - 1;

          if (firstBlock < 0) {
            firstBlock = 0;
          }

          var lastBlock = parseInt(lastRowIndex / blockSize, 10) + 1;

          if (lastBlock >= totalBlockCount) {
            lastBlock = totalBlockCount - 1;
          } // Check which blocks we have to load


          var firstBlockToLoad = -1;
          var lastBlockToLoad = -1;

          for (var block = firstBlock; block <= lastBlock; block++) {
            if (this._clearCache && !this._loadRowCountRequestRunning || this._rowBlockCache[block] == null || this._rowBlockCache[block].isDirty) {
              // We don't have this block
              if (firstBlockToLoad == -1) {
                firstBlockToLoad = block;
              }

              lastBlockToLoad = block;
            }
          } // Load the blocks


          if (firstBlockToLoad != -1) {
            this._firstRowToLoad = -1;
            this._lastRowToLoad = -1;
            this._firstLoadingBlock = firstBlockToLoad; // this.debug("Starting server request. rows: " + firstRowIndex + ".." + lastRowIndex + ", blocks: " + firstBlockToLoad + ".." + lastBlockToLoad);

            this._loadRowData(firstBlockToLoad * blockSize, (lastBlockToLoad + 1) * blockSize - 1);
          }
        } else {
          // There is already a request running -> Remember this request
          // so it can be executed after the current one is finished.
          this._firstRowToLoad = firstRowIndex;
          this._lastRowToLoad = lastRowIndex;
        }
      },

      /**
       * Loads some row data from the server.
       *
       * Implementing classes have to call {@link #_onRowDataLoaded} when the server
       * response arrived. That method has to be called! Even when there was an error.
       *
       * @abstract
       * @param firstRow {Integer} The index of the first row to load.
       * @param lastRow {Integer} The index of the last row to load.
       * @throws {Error} the abstract function warning.
       */
      _loadRowData: function _loadRowData(firstRow, lastRow) {
        throw new Error("_loadRowData is abstract");
      },

      /**
       * Sets row data.
       *
       * Has to be called by {@link #_loadRowData}.
       *
       * @param rowDataArr {Map[]} the loaded row data or null if there was an error.
       */
      _onRowDataLoaded: function _onRowDataLoaded(rowDataArr) {
        // Clear cache if function was called because of a reload.
        if (this._clearCache) {
          this.clearCache();
          this._clearCache = false;
        }

        if (rowDataArr != null && !this._ignoreCurrentRequest) {
          var blockSize = this.getBlockSize();
          var blockCount = Math.ceil(rowDataArr.length / blockSize);

          if (blockCount == 1) {
            // We got one block -> Use the rowData directly
            this._setRowBlockData(this._firstLoadingBlock, rowDataArr);
          } else {
            // We got more than one block -> We've to split the rowData
            for (var i = 0; i < blockCount; i++) {
              var rowOffset = i * blockSize;
              var blockRowData = [];
              var mailCount = Math.min(blockSize, rowDataArr.length - rowOffset);

              for (var row = 0; row < mailCount; row++) {
                blockRowData.push(rowDataArr[rowOffset + row]);
              }

              this._setRowBlockData(this._firstLoadingBlock + i, blockRowData);
            }
          } // this.debug("Got server answer. blocks: " + this._firstLoadingBlock + ".." + (this._firstLoadingBlock + blockCount - 1) + ". mail count: " + rowDataArr.length + " block count:" + blockCount);
          // Inform the listeners


          var data = {
            firstRow: this._firstLoadingBlock * blockSize,
            lastRow: (this._firstLoadingBlock + blockCount + 1) * blockSize - 1,
            firstColumn: 0,
            lastColumn: this.getColumnCount() - 1
          };
          this.fireDataEvent("dataChanged", data);
        } // We're not loading any blocks any more


        this._firstLoadingBlock = -1;
        this._ignoreCurrentRequest = false; // Check whether we have to start a new request

        if (this._firstRowToLoad != -1) {
          this.prefetchRows(this._firstRowToLoad, this._lastRowToLoad);
        }
      },

      /**
       * Sets the data of one block.
       *
       * @param block {Integer} the index of the block.
       * @param rowDataArr {var[][]} the data to set.
       */
      _setRowBlockData: function _setRowBlockData(block, rowDataArr) {
        if (this._rowBlockCache[block] == null) {
          // This is a new block -> Check whether we have to remove another block first
          this._rowBlockCount++;

          while (this._rowBlockCount > this.getMaxCachedBlockCount()) {
            // Find the last recently used block
            // NOTE: We never remove block 0 and 1
            var lruBlock;
            var minLru = this._lruCounter;

            for (var currBlock in this._rowBlockCache) {
              var currLru = this._rowBlockCache[currBlock].lru;

              if (currLru < minLru && currBlock > 1) {
                minLru = currLru;
                lruBlock = currBlock;
              }
            } // Remove that block
            // this.debug("Removing block: " + lruBlock + ". current LRU: " + this._lruCounter);


            delete this._rowBlockCache[lruBlock];
            this._rowBlockCount--;
          }
        }

        this._rowBlockCache[block] = {
          lru: ++this._lruCounter,
          rowDataArr: rowDataArr
        };
      },

      /**
       * Removes a row from the model.
       *
       * @param rowIndex {Integer} the index of the row to remove.
       */
      removeRow: function removeRow(rowIndex) {
        if (this.getClearCacheOnRemove()) {
          this.clearCache(); // Inform the listeners

          var data = {
            firstRow: 0,
            lastRow: this.getRowCount() - 1,
            firstColumn: 0,
            lastColumn: this.getColumnCount() - 1
          };
          this.fireDataEvent("dataChanged", data);
        } else {
          var blockSize = this.getBlockSize();
          var blockCount = Math.ceil(this.getRowCount() / blockSize);
          var startBlock = parseInt(rowIndex / blockSize, 10); // Remove the row and move the rows of all following blocks

          for (var block = startBlock; block <= blockCount; block++) {
            var blockData = this._rowBlockCache[block];

            if (blockData != null) {
              // Remove the row in the start block
              // NOTE: In the other blocks the first row is removed
              //       (This is the row that was)
              var removeIndex = 0;

              if (block == startBlock) {
                removeIndex = rowIndex - block * blockSize;
              }

              blockData.rowDataArr.splice(removeIndex, 1);

              if (block == blockCount - 1) {
                // This is the last block
                if (blockData.rowDataArr.length == 0) {
                  // It is empty now -> Remove it
                  delete this._rowBlockCache[block];
                }
              } else {
                // Try to copy the first row of the next block to the end of this block
                // so this block can stays clean
                var nextBlockData = this._rowBlockCache[block + 1];

                if (nextBlockData != null) {
                  blockData.rowDataArr.push(nextBlockData.rowDataArr[0]);
                } else {
                  // There is no row to move -> Mark this block as dirty
                  blockData.isDirty = true;
                }
              }
            }
          }

          if (this._rowCount != -1) {
            this._rowCount--;
          } // Inform the listeners


          if (this.hasListener("dataChanged")) {
            var data = {
              firstRow: rowIndex,
              lastRow: this.getRowCount() - 1,
              firstColumn: 0,
              lastColumn: this.getColumnCount() - 1
            };
            this.fireDataEvent("dataChanged", data);
          }
        }
      },

      /**
       *
       * See overridden method for details.
       *
       * @param rowIndex {Integer} the model index of the row.
       * @return {Object} Map containing a value for each column.
       */
      getRowData: function getRowData(rowIndex) {
        var blockSize = this.getBlockSize();
        var block = parseInt(rowIndex / blockSize, 10);
        var blockData = this._rowBlockCache[block];

        if (blockData == null) {
          // This block is not (yet) loaded
          return null;
        } else {
          var rowData = blockData.rowDataArr[rowIndex - block * blockSize]; // Update the last recently used counter

          if (blockData.lru != this._lruCounter) {
            blockData.lru = ++this._lruCounter;
          }

          return rowData;
        }
      },
      // overridden
      getValue: function getValue(columnIndex, rowIndex) {
        var rowData = this.getRowData(rowIndex);

        if (rowData == null) {
          return null;
        } else {
          var columnId = this.getColumnId(columnIndex);
          return rowData[columnId];
        }
      },
      // overridden
      setValue: function setValue(columnIndex, rowIndex, value) {
        var rowData = this.getRowData(rowIndex);

        if (rowData == null) {
          // row has not yet been loaded or does not exist
          return;
        } else {
          var columnId = this.getColumnId(columnIndex);
          rowData[columnId] = value; // Inform the listeners

          if (this.hasListener("dataChanged")) {
            var data = {
              firstRow: rowIndex,
              lastRow: rowIndex,
              firstColumn: columnIndex,
              lastColumn: columnIndex
            };
            this.fireDataEvent("dataChanged", data);
          }
        }
      },

      /**
       * Sets all columns editable or not editable.
       *
       * @param editable {Boolean} whether all columns are editable.
       */
      setEditable: function setEditable(editable) {
        this._editableColArr = [];

        for (var col = 0; col < this.getColumnCount(); col++) {
          this._editableColArr[col] = editable;
        }

        this.fireEvent("metaDataChanged");
      },

      /**
       * Sets whether a column is editable.
       *
       * @param columnIndex {Integer} the column of which to set the editable state.
       * @param editable {Boolean} whether the column should be editable.
       */
      setColumnEditable: function setColumnEditable(columnIndex, editable) {
        if (editable != this.isColumnEditable(columnIndex)) {
          if (this._editableColArr == null) {
            this._editableColArr = [];
          }

          this._editableColArr[columnIndex] = editable;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      isColumnEditable: function isColumnEditable(columnIndex) {
        return this._editableColArr ? this._editableColArr[columnIndex] == true : false;
      },

      /**
        * Sets whether a column is sortable.
        *
        * @param columnIndex {Integer} the column of which to set the sortable state.
        * @param sortable {Boolean} whether the column should be sortable.
        */
      setColumnSortable: function setColumnSortable(columnIndex, sortable) {
        if (sortable != this.isColumnSortable(columnIndex)) {
          if (this._sortableColArr == null) {
            this._sortableColArr = [];
          }

          this._sortableColArr[columnIndex] = sortable;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      isColumnSortable: function isColumnSortable(columnIndex) {
        return this._sortableColArr ? this._sortableColArr[columnIndex] !== false : true;
      },
      // overridden
      sortByColumn: function sortByColumn(columnIndex, ascending) {
        if (this._sortColumnIndex != columnIndex || this._sortAscending != ascending) {
          this._sortColumnIndex = columnIndex;
          this._sortAscending = ascending;
          this.clearCache(); // Inform the listeners

          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      getSortColumnIndex: function getSortColumnIndex() {
        return this._sortColumnIndex;
      },
      // overridden
      isSortAscending: function isSortAscending() {
        return this._sortAscending;
      },

      /**
       * Sets the sorted column without sorting the data.
       * Use this method, if you want to mark the column as the sorted column,
       * (e.g. for appearance reason), but the sorting of the data will be done
       * in another step.
       *
       * @param sortColumnIndex {Integer} the column, which shall be marked as the sorted column.
       */
      setSortColumnIndexWithoutSortingData: function setSortColumnIndexWithoutSortingData(sortColumnIndex) {
        this._sortColumnIndex = sortColumnIndex;
      },

      /**
       * Sets the direction of the sorting without sorting the data.
       * Use this method, if you want to set the direction of sorting, (e.g
       * for appearance reason), but the sorting of the data will be done in
       * another step.
       *
       * @param sortAscending {Boolean} whether the sorting direction is ascending
       *        (true) or not (false).
       */
      setSortAscendingWithoutSortingData: function setSortAscendingWithoutSortingData(sortAscending) {
        this._sortAscending = sortAscending;
      }
    },
    destruct: function destruct() {
      this._sortableColArr = this._editableColArr = this._rowBlockCache = null;
    }
  });
  qx.ui.table.model.Remote.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Objects which are used as delegates for the <code>qx.ui.tree.VirtualTree</code> may
   * implement any of the methods described in this interface. The delegate does
   * not need to implement all the methods of this interface. If a method is not
   * implemented the <code>qx.ui.tree.VirtualTree</code> provides a default
   * implementation.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * actually implemented.
   */
  qx.Interface.define("qx.ui.tree.core.IVirtualTreeDelegate", {
    members: {
      /**
       * Gives the user the opportunity to set individual styles and properties
       * on the widget cells created by the controller.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      configureItem: function configureItem(item) {},

      /**
       * Creates a widget cell which will be used for rendering. Be sure to
       * implement the {@link #bindItem} function as well to get the needed
       * properties bound.
       *
       * @return {qx.ui.core.Widget} A new created item cell.
       */
      createItem: function createItem() {},

      /**
       * Sets up the binding for the given widget cell and index.
       *
       * For every property you want to bind, use
       * {@link MWidgetController#bindProperty} like this:
       * <code>
       * controller.bindProperty(null, "value", options, item, id);
       * </code>
       *
       * @param controller {qx.ui.list.core.MWidgetController} The currently used controller.
       * @param item {qx.ui.core.Widget} The created and used item.
       * @param id {Integer} The id for the binding.
       */
      bindItem: function bindItem(controller, item, id) {},

      /**
       * Gives the user the opportunity to reset properties or states.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      onPool: function onPool(item) {},

      /**
       * Filter checks the current data and returns a boolean if the data should
       * appear in the filtered data set or not.
       *
       * @param data {var} The data which will be checked.
       * @return {Boolean} True, if the data passes the filter, false otherwise.
       */
      filter: function filter(data) {},

      /**
       * Gives the user the opportunity to sort the children items from a node.
       * The sorting method should return a negative value if a < b, zero
       * if a = b, or a positive value if a > b.
       *
       * @param a {var} value to compare.
       * @param b {var} value to compare.
       * @return {Integer} should return a negative value if a < b, zero
       *   if a = b, or a positive value if a > b.
       */
      sorter: function sorter(a, b) {}
    }
  });
  qx.ui.tree.core.IVirtualTreeDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * The default data cell renderer for a virtual tree (columns other than the
   * tree column)
   */
  qx.Class.define("qx.ui.treevirtual.DefaultDataCellRenderer", {
    extend: qx.ui.table.cellrenderer.Default
  });
  qx.ui.treevirtual.DefaultDataCellRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A set of methods which may be used to retrieve various siblings of nodes.
   */
  qx.Mixin.define("qx.ui.treevirtual.MFamily", {
    members: {
      /**
       * Get the first child of the specified node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the first child is desired.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Integer}
       *   The node id of the first child.
       */
      familyGetFirstChild: function familyGetFirstChild(nodeReference) {
        var node;

        if (typeof nodeReference == "object") {
          node = nodeReference;
        } else if (typeof nodeReference == "number") {
          node = this.getTableModel().getData()[nodeReference];
        } else {
          throw new Error("Expected node object or node id");
        }

        if (node.children.length > 0) {
          return node.children[0];
        }

        return null;
      },

      /**
       * Get the last child of the specified node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the last child is desired.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Integer}
       *   The node id of the last child.
       */
      familyGetLastChild: function familyGetLastChild(nodeReference) {
        var node;

        if (typeof nodeReference == "object") {
          node = nodeReference;
        } else if (typeof nodeReference == "number") {
          node = this.getTableModel().getData()[nodeReference];
        } else {
          throw new Error("Expected node object or node id");
        }

        if (node.children.length > 0) {
          return node.children[node.children.length - 1];
        }

        return null;
      },

      /**
       * Get the next sibling of the specified node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the next sibling is desired.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Integer}
       *   The node id of the next sibling.
       */
      familyGetNextSibling: function familyGetNextSibling(nodeReference) {
        var node;
        var nodeId;
        var nodes = this.getTableModel().getData();

        if (typeof nodeReference == "object") {
          node = nodeReference;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
          node = nodes[nodeId];
        } else {
          throw new Error("Expected node object or node id");
        }

        var myNodeId = node.nodeId;
        var parentChildren = nodes[node.parentNodeId].children; // Find this node id in our parent's children array

        for (var i = 0; i < parentChildren.length; i++) {
          // Is this our id?
          if (parentChildren[i] == myNodeId) {
            // Yup.  Ensure there is a next sibling.
            if (i < parentChildren.length - 1) {
              // There is.  Return the next sibling.
              return parentChildren[i + 1];
            } // There's no next sibling


            return null;
          }
        }
      },

      /**
       * Get the previous sibling of the specified node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the previous sibling is desired.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Integer}
       *   The node id of the previous sibling.
       */
      familyGetPrevSibling: function familyGetPrevSibling(nodeReference) {
        var node;
        var nodeId;
        var nodes = this.getTableModel().getData();

        if (typeof nodeReference == "object") {
          node = nodeReference;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
          node = nodes[nodeId];
        } else {
          throw new Error("Expected node object or node id");
        }

        var myNodeId = node.nodeId;
        var parentChildren = nodes[node.parentNodeId].children; // Find this node id in our parent's children array

        for (var i = 0; i < parentChildren.length; i++) {
          // Is this our id?
          if (parentChildren[i] == myNodeId) {
            // Yup.  Ensure there is a previous sibling.
            if (i > 0) {
              // There is.  Return the previous sibling.
              return parentChildren[i - 1];
            } // There's no previous sibling


            return null;
          }
        }
      }
    }
  });
  qx.ui.treevirtual.MFamily.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Utility functions for working with nodes.  These methods allow reference
   * to a node by either the object itself or the object's node id.
   */
  qx.Mixin.define("qx.ui.treevirtual.MNode", {
    members: {
      /**
       * Get a node object given its node id.
       *
       * @param nodeReference {Object | Integer}
       *   The node to have its opened/closed state toggled.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.).
       *
       * @return {Object}
       *   If the nodeReference is a node object itself, that same node object
       *   is returned (identity).  Otherwise, the node object is looked up
       *   using the specified node id.
       */
      nodeGet: function nodeGet(nodeReference) {
        if (typeof nodeReference == "object") {
          return nodeReference;
        } else if (typeof nodeReference == "number") {
          return this.getTableModel().getData()[nodeReference];
        } else {
          throw new Error("Expected node object or node id");
        }
      },

      /**
       * Toggle the opened state of the node: if the node is opened, close
       * it; if it is closed, open it.
       *
       * @param nodeReference {Object | Integer}
       *   The node to have its opened/closed state toggled.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       */
      nodeToggleOpened: function nodeToggleOpened(nodeReference) {
        var node;
        var nodeId;

        if (typeof nodeReference == "object") {
          node = nodeReference;
          nodeId = node.nodeId;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
          node = this.getTableModel().getData()[nodeId];
        } else {
          throw new Error("Expected node object or node id");
        }

        this.getTableModel().setState(nodeId, {
          bOpened: !node.bOpened
        });
      },

      /**
       * Set state attributes of a tree node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which attributes are being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param attributes {Map}
       *   Map with the node properties to be set.  The map may contain any of
       *   the properties described in
       *   {@link qx.ui.treevirtual.SimpleTreeDataModel}
       *
       */
      nodeSetState: function nodeSetState(nodeReference, attributes) {
        var nodeId;

        if (typeof nodeReference == "object") {
          nodeId = nodeReference.nodeId;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
        } else {
          throw new Error("Expected node object or node id");
        }

        this.getTableModel().setState(nodeId, attributes);
      },

      /**
       * Set the label for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the label is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param label {String}
       *   The new label for the specified node
       *
       */
      nodeSetLabel: function nodeSetLabel(nodeReference, label) {
        this.nodeSetState(nodeReference, {
          label: label
        });
      },

      /**
       * Get the label for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the label is being retrieved.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {String}
       *   The label for the specified node
       */
      nodeGetLabel: function nodeGetLabel(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.label;
      },

      /**
       * Set the selected state for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the selected state is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param b {Boolean}
       *   The new selected state for the specified node.
       *
       */
      nodeSetSelected: function nodeSetSelected(nodeReference, b) {
        this.nodeSetState(nodeReference, {
          bSelected: b
        });
      },

      /**
       * Get the selected state for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the selected state is being retrieved.  The node
       *   can be represented either by the node object, or the node id (as
       *   would have been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Boolean}
       *   The selected state for the specified node.
       */
      nodeGetSelected: function nodeGetSelected(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.bSelected;
      },

      /**
       * Set the opened state for a node.  (Note that this method has no effect
       * if the requested state is the same as the current state.)
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the opened state is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param b {Boolean}
       *   The new opened state for the specified node.
       *
       */
      nodeSetOpened: function nodeSetOpened(nodeReference, b) {
        var node;

        if (typeof nodeReference == "object") {
          node = nodeReference;
        } else if (typeof nodeReference == "number") {
          node = this.getTableModel().getData()[nodeReference];
        } else {
          throw new Error("Expected node object or node id");
        } // Only set new state if not already in the requested state, since
        // setting new state involves dispatching events.


        if (b != node.bOpened) {
          this.nodeToggleOpened(node);
        }
      },

      /**
       * Get the opened state for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the opened state is being retrieved.  The node can
       *   be represented either by the node object, or the node id (as would
       *   have been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Boolean}
       *   The opened state for the specified node.
       */
      nodeGetOpened: function nodeGetOpened(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.bOpened;
      },

      /**
       * Set the hideOpenClose state for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the hideOpenClose state is being set.  The node
       *   can be represented either by the node object, or the node id (as
       *   would have been returned by addBranch(), addLeaf(), etc.)
       *
       * @param b {Boolean}
       *   The new hideOpenClose state for the specified node.
       *
       */
      nodeSetHideOpenClose: function nodeSetHideOpenClose(nodeReference, b) {
        this.nodeSetState(nodeReference, {
          bHideOpenClose: b
        });
      },

      /**
       * Get the hideOpenClose state for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the hideOpenClose state is being retrieved.  The
       *   node can be represented either by the node object, or the node id (as
       *   would have been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Boolean}
       *   The new hideOpenClose state for the specified node.
       */
      nodeGetHideOpenClose: function nodeGetHideOpenClose(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.bHideOpenClose;
      },

      /**
       * Set the icon for a node when in its unselected (normal) state.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the icon is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param path {String}
       *   The path to the icon to be used when the node is not selected
       *
       */
      nodeSetIcon: function nodeSetIcon(nodeReference, path) {
        this.nodeSetState(nodeReference, {
          icon: path
        });
      },

      /**
       * Get the icon for a node when in its unselected (normal) state.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the icon is being retrieved.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {String}
       *   The path to the icon to be used when the node is not selected, if a
       *   path has been previously provided (i.e. not using the default icon).
       */
      nodeGetIcon: function nodeGetIcon(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.icon;
      },

      /**
       * Set the icon for a node when in its selected state.
       * <p>
       * NOTE: As of 13 Mar 2009, this feature is disabled by default, by
       *       virtue of the fact that the tree's "alwaysUpdateCells" property
       *       has a setting of 'false' now instead of 'true'. Setting this
       *       property to true allows the icon to change upon selection, but
       *       causes problems such as single clicks not always selecting a
       *       row, and, in IE, double click operations failing
       *       completely. (For more information, see bugs 605 and 2021.) To
       *       re-enable the option to have an unique icon that is displayed
       *       when the node is selected, issue
       *       <code>tree.setAlwaysUpdateCells(true);</code>
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the icon is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param path {String}
       *   The path to the icon to be used when the node is selected
       *
       */
      nodeSetSelectedIcon: function nodeSetSelectedIcon(nodeReference, path) {
        this.nodeSetState(nodeReference, {
          iconSelected: path
        });
      },

      /**
       * Get the icon for a node when in its selected state.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the icon is being retrieved.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {String}
       *   The path to the icon to be used when the node is selected, if a path
       *   has been previously provided (i.e. not using the default icon).
       */
      nodeGetSelectedIcon: function nodeGetSelectedIcon(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.iconSelected;
      },

      /**
       * Set the cell style for a node
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the cell style is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param style {String}
        *   The CSS style to be applied for the tree column cell for this node,
       *   if a style has been previously provided (i.e. not using the default
       *   style).
       *
       */
      nodeSetCellStyle: function nodeSetCellStyle(nodeReference, style) {
        this.nodeSetState(nodeReference, {
          cellStyle: style
        });
      },

      /**
       * Get the cell style for a node
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the cell style is being retrieved.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {String}
       *   The CSS style being applied for the tree column cell for this node.
       */
      nodeGetCellStyle: function nodeGetCellStyle(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.cellStyle;
      },

      /**
       * Set the label style for a node
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the label style is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param style {String}
       *   The CSS style to be applied for the label for this node.
       *
       */
      nodeSetLabelStyle: function nodeSetLabelStyle(nodeReference, style) {
        this.nodeSetState(nodeReference, {
          labelStyle: style
        });
      },

      /**
       * Get the label style for a node
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the label style is being retrieved.  The node can
       *   be represented either by the node object, or the node id (as would
       *   have been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {String}
       *   The CSS style being applied for the label for this node, if a style
       *   has been previously provided (i.e. not using the default style).
       */
      nodeGetLabelStyle: function nodeGetLabelStyle(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.cellStyle;
      }
    }
  });
  qx.ui.treevirtual.MNode.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2010 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Primitives for building trees and tree nodes.
   *
   * The methods in this mixin are included directly in the SimpleTreeDataModel
   * but are also useful for other types of trees (not TreeVirtual) that need
   * similar tree and node creation.
   */
  qx.Mixin.define("qx.ui.treevirtual.MTreePrimitive", {
    statics: {
      /** Primitive types of tree nodes */
      Type: {
        LEAF: 1,
        BRANCH: 2
      },

      /**
       * Add a node to the tree.
       *
       * NOTE: This method is for <b>internal use</b> and should not be called by
       *       users of this class. There is no guarantee that the interface to this
       *       method will remain unchanged over time.
       *
       * @param nodeArr {Array|Map}
       *   The array to which new nodes are to be added. See, however, the
       *   nodeId parameter. If nodeId values will be provided, then nodeArr can
       *   be a map. The traditional TreeVirtual does not provide node ids, and
       *   passes an array for this parameter.
       *
       * @param parentNodeId {Integer}
       *   The node id of the parent of the node being added
       *
       * @param label {String}
       *   The string to display as the label for this node
       *
       * @param bOpened {Boolean}
       *   <i>true</i> if the tree should be rendered in its opened state;
       *   <i>false</i> otherwise.
       *
       * @param bHideOpenCloseButton {Boolean}
       *   <i>true</i> if the open/close button should be hidden (not displayed);
       *   </i>false</i> to display the open/close button for this node.
       *
       * @param type {Integer}
       *   The type of node being added.  The type determines whether children
       *   may be added, and determines the default icons to use.  This
       *   parameter must be one of the following values:
       *   <dl>
       *     <dt>qx.ui.treevirtual.MTreePrimitive.Type.BRANCH</dt>
       *     <dd>
       *       This node is a branch.  A branch node may have children.
       *     </dd>
       *     <dt>qx.ui.treevirtual.MTreePrimitive.Type.LEAF</dt>
       *     <dd>
       *       This node is a leaf, and may not have children
       *     </dd>
       *   </dl>
       *
       * @param icon {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is not a selected node.
       *
       * @param iconSelected {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is a selected node.
       *   <p>
       *   NOTE: As of 13 Mar 2009, this feature is disabled by default, by
       *         virtue of the fact that the tree's "alwaysUpdateCells" property
       *         has a setting of 'false' now instead of 'true'. Setting this
       *         property to true allows the icon to change upon selection, but
       *         causes problems such as single clicks not always selecting a
       *         row, and, in IE, double click operations failing
       *         completely. (For more information, see bugs 605 and 2021.) To
       *         re-enable the option to have an unique icon that is displayed
       *         when the node is selected, issue
       *         <code>tree.setAlwaysUpdateCells(true);</code>
       *
       * @param nodeId {Integer?}
       *   The requested node id for this new node. If not provided, nodeArr
       *   will be assumed to be an array, not a map, and the next available
       *   index of the array will be used. If it is provided, then nodeArr may
       *   be either an array or a map.
       *
       * @return {Integer} The node id of the newly-added node.
       *
       * @throws {Error} If one tries to add a child to a non-existent parent.
       * @throws {Error} If one tries to add a node to a leaf.
       */
      _addNode: function _addNode(nodeArr, parentNodeId, label, bOpened, bHideOpenCloseButton, type, icon, iconSelected, nodeId) {
        var parentNode; // Ensure that if parent was specified, it exists

        if (parentNodeId) {
          parentNode = nodeArr[parentNodeId];

          if (!parentNode) {
            throw new Error("Request to add a child to a non-existent parent");
          } // Ensure parent isn't a leaf


          if (parentNode.type == qx.ui.treevirtual.MTreePrimitive.Type.LEAF) {
            throw new Error("Sorry, a LEAF may not have children.");
          }
        } else {
          // This is a child of the root
          parentNode = nodeArr[0];
          parentNodeId = 0;
        } // If this is a leaf, we don't present open/close icon


        if (type == qx.ui.treevirtual.MTreePrimitive.Type.LEAF) {
          // mask off the opened bit but retain the hide open/close button bit
          bOpened = false;
          bHideOpenCloseButton = false;
        } // Determine the node id of this new node


        if (nodeId === undefined) {
          nodeId = nodeArr.length;
        } // Set the data for this node.


        var node = {
          type: type,
          nodeId: nodeId,
          parentNodeId: parentNodeId,
          label: label,
          bSelected: false,
          bOpened: bOpened,
          bHideOpenClose: bHideOpenCloseButton,
          icon: icon,
          iconSelected: iconSelected,
          children: [],
          columnData: []
        }; // Add this node to the array

        nodeArr[nodeId] = node; // Add this node to its parent's child array.

        parentNode.children.push(nodeId); // Return the node id we just added

        return nodeId;
      },

      /**
       * An empty tree contains only this one node
       *
       * @return {Map}
       *   Returns a root node with all relevant fields filled.
       */
      _getEmptyTree: function _getEmptyTree() {
        return {
          label: "<virtual root>",
          nodeId: 0,
          bOpened: true,
          children: []
        };
      }
    }
  });
  qx.ui.treevirtual.MTreePrimitive.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.selection.Manager": {
        "construct": true,
        "require": true
      },
      "qx.event.type.Mouse": {},
      "qx.bom.element.Location": {},
      "qx.ui.treevirtual.SimpleTreeDataModel": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A selection manager. This is a helper class that handles all selection
   * related events and updates a SelectionModel.
   * <p>
   * This Selection Manager differs from its superclass in that we do not want
   * rows to be selected when moving around with the keyboard.
   */
  qx.Class.define("qx.ui.treevirtual.SelectionManager", {
    extend: qx.ui.table.selection.Manager,

    /**
     * @param table {qx.ui.table.Table}
     *    The table whose selections are being managed
     */
    construct: function construct(table) {
      qx.ui.table.selection.Manager.constructor.call(this);
      this.__table = table;
    },
    members: {
      __table: null,

      /**
       * Getter for the table being managed
       *
       * @return {qx.ui.table.Table}
       *   Table being managed
       */
      getTable: function getTable() {
        return this.__table;
      },

      /**
       * Handles a select event.  First we determine if the click was on the
       * open/close button and toggle the opened/closed state as necessary.
       * Then, if the click was not on the open/close button or if the table's
       * "openCloseClickSelectsRow" property so indicates, call our superclass to
       * handle the actual row selection.
       *
       * @param index {Integer} the index the event is pointing at.
       * @param evt {Map} the mouse event.
       */
      _handleSelectEvent: function _handleSelectEvent(index, evt) {
        var _this = this;

        function handleButtonClick(tree, index, evt) {
          // Get the data model
          var dataModel = tree.getDataModel(); // Determine the column containing the tree

          var treeCol = dataModel.getTreeColumn(); // Get the focused column

          var focusedCol = tree.getFocusedColumn(); // If the click is not in the tree column, ...

          if (focusedCol != treeCol) {
            // ... then let the Table selection manager deal with it
            return false;
          } // If the cell hasn't been focused automatically...


          if (evt instanceof qx.event.type.Mouse) {
            if (!tree.getFocusCellOnPointerMove()) {
              // ... then focus it now so we can determine the node to open/close
              var scrollers = tree._getPaneScrollerArr();

              for (var i = 0; i < scrollers.length; i++) {
                scrollers[i]._focusCellAtPagePos(evt.getViewportLeft(), evt.getViewportTop());
              }
            }
          } // Get the node to which this event applies


          var node = dataModel.getNode(tree.getFocusedRow());

          if (!node) {
            return false;
          } // Was this a mouse event?


          if (evt instanceof qx.event.type.Mouse) {
            // Yup.  Get the order of the columns
            var tcm = tree.getTableColumnModel();

            var columnPositions = tcm._getColToXPosMap(); // Calculate the position of the beginning of the tree column


            var left = qx.bom.element.Location.getLeft(tree.getContentElement().getDomElement());

            for (var i = 0; i < columnPositions[treeCol].visX; i++) {
              left += tcm.getColumnWidth(columnPositions[i].visX);
            } // Was the click on the open/close button?  That button begins at
            // (node.level - 1) * (rowHeight + 3) + 2 (the latter for padding),
            // and has width (rowHeight + 3). We add a bit of latitude to that.


            var x = evt.getViewportLeft();
            var latitude = 2;

            var rowHeight = _this.__table.getRowHeight();

            var buttonPos = left + (node.level - 1) * (rowHeight + 3) + 2;

            if (x >= buttonPos - latitude && x <= buttonPos + rowHeight + 3 + latitude) {
              // Yup.  Toggle the opened state for this node.
              dataModel.setState(node, {
                bOpened: !node.bOpened
              });
              return tree.getOpenCloseClickSelectsRow() ? false : true;
            } else {
              return _this._handleExtendedClick(tree, evt, node, left);
            }
          } else {
            // See which key generated the event
            var identifier = evt.getKeyIdentifier();

            switch (identifier) {
              case "Space":
                // This should only select the row, not toggle the opened state
                return false;

              case "Enter":
                // Toggle the open state if open/close is allowed
                if (!node.bHideOpenClose && node.type != qx.ui.treevirtual.SimpleTreeDataModel.Type.LEAF) {
                  dataModel.setState(node, {
                    bOpened: !node.bOpened
                  });
                }

                return tree.getOpenCloseClickSelectsRow() ? false : true;

              default:
                // Unrecognized key.  Ignore it.
                return true;
            }
          }
        } // Call our local method to toggle the open/close state, if necessary


        var bNoSelect = handleButtonClick(this.__table, index, evt); // If we haven't been told not to do the selection...

        if (!bNoSelect) {
          // then call the superclass to handle it.
          qx.ui.treevirtual.SelectionManager.prototype._handleSelectEvent.base.call(this, index, evt);
        }
      },

      /**
       * Handle a mouse click event that is not normally handled by the simple
       * tree.  This is intended for more sophisticated trees where clicks in
       * different places, e.g. on various icons or on the label itself, should
       * be handled specially.
       *
       * @param tree {qx.ui.treevirtual.TreeVirtual}
       *   The tree on which the event has occurred.
       *
       * @param evt {Map}
       *   The mouse event.  Of particular interest is evt.getViewportLeft()
       *   which is the horizontal offset from the left border of the click.
       *
       * @param node {Map}
       *   The node which the tree row is displaying
       *
       * @param left {Integer}
       *   The offset from the left, of the beginning of the tree column.
       *
       * @return {Boolean}
       *   <i>true</i> if the row should be prevented from being selected;
       *   <i>false</i> otherwise.
       */
      _handleExtendedClick: function _handleExtendedClick(tree, evt, node, left) {
        return false;
      }
    },
    destruct: function destruct() {
      this.__table = null;
    }
  });
  qx.ui.treevirtual.SelectionManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.model.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.treevirtual.MTreePrimitive": {
        "construct": true,
        "defer": "runtime",
        "require": true
      },
      "qx.lang.Array": {},
      "qx.ui.treevirtual.TreeVirtual": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A simple tree data model used as the table model
   *
   * The object structure of a single node of the tree is:
   *
   * <pre class='javascript'>
   * {
   *   // USER-PROVIDED ATTRIBUTES
   *   // ------------------------
   *   type           : qx.ui.treevirtual.MTreePrimitive.Type.LEAF,
   *   parentNodeId   : 23,    // index of the parent node in _nodeArr
   *
   *   label          : "My Documents",
   *   bSelected      : true,  // true if node is selected; false otherwise.
   *   bOpened        : true,  // true (-), false (+)
   *   bHideOpenClose : false, // whether to hide the open/close button
   *   icon           : "images/folder.gif",
   *   iconSelected   : "images/folder_selected.gif",
   *
   *   cellStyle      : "background-color:cyan"
   *   labelStyle     : "background-color:red;color:white"
   *
   *   // USER-PROVIDED COLUMN DATA
   *   columnData     : [
   *                      null, // null at index of tree column (typically 0)
   *                      "text of column 1",
   *                      "text of column 2"
   *                    ],
   *
   *   // APPLICATION-, MIXIN-, and SUBCLASS-PROVIDED CUSTOM DATA
   *   data           : {
   *                      application :
   *                      {
   *                          // application-specific user data goes in here
   *                          foo: "bar",
   *                          ...
   *                      },
   *                      MDragAndDropSupport :
   *                      {
   *                          // Data required for the Drag & Drop mixin.
   *                          // When a mixin is included, its constructor
   *                          // should create this object, named according
   *                          // to the mixin or subclass name (empty or
   *                          // otherwise)
   *                      },
   *                      ... // Additional mixins or subclasses.
   *                    },
   *
   *   // INTERNALLY-CALCULATED ATTRIBUTES
   *   // --------------------------------
   *   // The following properties need not (and should not) be set by the
   *   // caller, but are automatically calculated.  Some are used internally,
   *   // while others may be of use to event listeners.
   *
   *   nodeId         : 42,   // The index in _nodeArr, useful to event listeners.
   *   children       : [ ],  // each value is an index into _nodeArr
   *
   *   level          : 2,    // The indentation level of this tree node
   *
   *   bFirstChild    : true,
   *   lastChild      : [ false ],  // Array where the index is the column of
   *                                // indentation, and the value is a boolean.
   *                                // These are used to locate the
   *                                // appropriate "tree line" icon.
   * }
   * </pre>
   */
  qx.Class.define("qx.ui.treevirtual.SimpleTreeDataModel", {
    extend: qx.ui.table.model.Abstract,
    include: qx.ui.treevirtual.MTreePrimitive,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.model.Abstract.constructor.call(this);
      this._rowArr = []; // rows, resorted into tree order as necessary

      this._nodeArr = []; // tree nodes, organized with hierarchy

      this._nodeRowMap = []; // map nodeArr index to rowArr index.  The
      // index of this array is the index of
      // _nodeArr, and the values in this array are
      // the indexes into _rowArr.

      this._treeColumn = 0; // default column for tree nodes

      this._selections = {}; // list of indexes of selected nodes
      // the root node, needed to store its children

      this._nodeArr.push(qx.ui.treevirtual.MTreePrimitive._getEmptyTree()); // Track which columns are editable


      this.__editableColArr = null;
    },
    properties: {
      /**
       * Gives the user the opportunity to filter the model. The filter
       * function is called for every node in the model. It gets as an argument the
       * <code>node</code> object and has to return
       * <code>true</code> if the given data should be shown and
       * <code>false</code> if the given data should be ignored.
       */
      filter: {
        check: "Function",
        nullable: true,
        apply: "_applyFilter"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __tree: null,
      __editableColArr: null,
      __tempTreeData: null,
      __recalculateLastChildFlags: null,

      /** Rows, resorted into tree order as necessary */
      _rowArr: null,

      /** Tree nodes, organized with hierarchy */
      _nodeArr: null,

      /**
       * Map nodeArr index to rowArr index.  The index of this array is the
       * index of _nodeArr, and the values in this array are the indexes into
       * _rowArr.
       */
      _nodeRowMap: null,

      /** Column for tree nodes */
      _treeColumn: null,

      /** list of indexes of selected nodes */
      _selections: null,

      /**
       * Set the tree object for which this data model is used.
       *
       * @param tree {qx.ui.treevirtual.TreeVirtual}
       *    The tree used to render the data in this model.
       *
       */
      setTree: function setTree(tree) {
        this.__tree = tree;
      },

      /**
       * Get the tree object for which this data model is used.
       *
       * @return {qx.ui.treevirtual.TreeVirtual}
       */
      getTree: function getTree() {
        return this.__tree;
      },

      /**
       * Sets all columns editable or not editable.
       *
       * @param editable {Boolean}
       *   Whether all columns are editable.
       *
       */
      setEditable: function setEditable(editable) {
        this.__editableColArr = [];

        for (var col = 0; col < this.getColumnCount(); col++) {
          this.__editableColArr[col] = editable;
        }

        this.fireEvent("metaDataChanged");
      },

      /**
       * Sets whether a column is editable.
       *
       * @param columnIndex {Integer}
       *   The column of which to set the editable state.
       *
       * @param editable {Boolean}
       *   Whether the column should be editable.
       *
       */
      setColumnEditable: function setColumnEditable(columnIndex, editable) {
        if (editable != this.isColumnEditable(columnIndex)) {
          if (this.__editableColArr == null) {
            this.__editableColArr = [];
          }

          this.__editableColArr[columnIndex] = editable;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      isColumnEditable: function isColumnEditable(columnIndex) {
        // The tree column is not editable
        if (columnIndex == this._treeColumn) {
          return false;
        }

        return this.__editableColArr ? this.__editableColArr[columnIndex] == true : false;
      },
      // overridden
      isColumnSortable: function isColumnSortable(columnIndex) {
        return false;
      },

      /**
       * Sorts the model by a column.
       *
       * @param columnIndex {Integer} the column to sort by.
       * @param ascending {Boolean} whether to sort ascending.
       * @throws {Error} If one tries to sort the tree by column
       */
      sortByColumn: function sortByColumn(columnIndex, ascending) {
        throw new Error("Trees can not be sorted by column");
      },

      /**
       * Returns the column index the model is sorted by. This model is never
       * sorted, so -1 is returned.
       *
       * @return {Integer}
       *   -1, to indicate that the model is not sorted.
       */
      getSortColumnIndex: function getSortColumnIndex() {
        return -1;
      },

      /**
       * Specifies which column the tree is to be displayed in.  The tree is
       * displayed using the SimpleTreeDataCellRenderer.  Other columns may be
       * provided which use different cell renderers.
       *
       * Setting the tree column involves more than simply setting this column
       * index; it also requires setting an appropriate cell renderer for this
       * column, that knows how to render a tree. The expected and typical
       * method of setting the tree column is to provide it in the 'custom'
       * parameter to the TreeVirtual constructor, which also initializes the
       * proper cell renderers. This method does not set any cell renderers. If
       * you wish to call this method on your own, you should also manually set
       * the cell renderer for the specified column, and likely also set the
       * cell renderer for column 0 (the former tree column) to something
       * appropriate to your data.
       *
       *
       * @param columnIndex {Integer}
       *   The index of the column in which the tree should be displayed.
       *
       */
      setTreeColumn: function setTreeColumn(columnIndex) {
        this._treeColumn = columnIndex;
      },

      /**
       * Get the column in which the tree is to be displayed.
       *
       * @return {Integer}
       *   The column in which the tree is to be displayed
       */
      getTreeColumn: function getTreeColumn() {
        return this._treeColumn;
      },
      // overridden
      getRowCount: function getRowCount() {
        return this._rowArr.length;
      },
      // overridden
      getRowData: function getRowData(rowIndex) {
        return this._rowArr[rowIndex];
      },

      /**
       * Returns a cell value by column index.
       *
       * @throws {Error} if the row index is out of bounds.
       * @param columnIndex {Integer} the index of the column.
       * @param rowIndex {Integer} the index of the row.
       * @return {var} The value of the cell.
       * @see #getValueById
       */
      getValue: function getValue(columnIndex, rowIndex) {
        if (rowIndex < 0 || rowIndex >= this._rowArr.length) {
          throw new Error("this._rowArr row (" + rowIndex + ") out of bounds: " + this._rowArr + " (0.." + (this._rowArr.length - 1) + ")");
        }

        if (columnIndex < 0 || columnIndex >= this._rowArr[rowIndex].length) {
          throw new Error("this._rowArr column (" + columnIndex + ") out of bounds: " + this._rowArr[rowIndex] + " (0.." + (this._rowArr[rowIndex].length - 1) + ")");
        }

        return this._rowArr[rowIndex][columnIndex];
      },
      // overridden
      setValue: function setValue(columnIndex, rowIndex, value) {
        if (columnIndex == this._treeColumn) {
          // Ignore requests to set the tree column data using this method
          return;
        } // convert from rowArr to nodeArr, and get the requested node


        var node = this.getNodeFromRow(rowIndex);

        if (node.columnData[columnIndex] != value) {
          node.columnData[columnIndex] = value;
          this.setData(); // Inform the listeners

          if (this.hasListener("dataChanged")) {
            var data = {
              firstRow: rowIndex,
              lastRow: rowIndex,
              firstColumn: columnIndex,
              lastColumn: columnIndex
            };
            this.fireDataEvent("dataChanged", data);
          }
        }
      },

      /**
       * Returns the node object specific to a currently visible row. In this
       * simple tree data model, that's the same as retrieving the value of the
       * tree column of the specified row.
       *
       * @throws {Error}
       *   Thrown if the row index is out of bounds.
       *
       * @param rowIndex {Integer}
       *   The index of the row.
       *
       * @return {Object}
       *   The node object associated with the specified row.
       */
      getNode: function getNode(rowIndex) {
        if (rowIndex < 0 || rowIndex >= this._rowArr.length) {
          throw new Error("this._rowArr row (" + rowIndex + ") out of bounds: " + this._rowArr + " (0.." + (this._rowArr.length - 1) + ")");
        }

        return this._rowArr[rowIndex][this._treeColumn];
      },

      /**
       * Add a branch to the tree.
       *
       * @param parentNodeId {Integer}
       *   The node id of the parent of the node being added
       *
       * @param label {String}
       *   The string to display as the label for this node
       *
       * @param bOpened {Boolean}
       *   <i>True</i> if the branch should be rendered in its opened state;
       *   <i>false</i> otherwise.
       *
       * @param bHideOpenCloseButton {Boolean}
       *   <i>True</i> if the open/close button should not be displayed;
       *   <i>false</i> if the open/close button should be displayed
       *
       * @param icon {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is not a selected node.
       *
       * @param iconSelected {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is a selected node.
       *
       * @return {Integer}
       *   The node id of the newly-added branch.
       */
      addBranch: function addBranch(parentNodeId, label, bOpened, bHideOpenCloseButton, icon, iconSelected) {
        return qx.ui.treevirtual.MTreePrimitive._addNode(this._nodeArr, parentNodeId, label, bOpened, bHideOpenCloseButton, qx.ui.treevirtual.MTreePrimitive.Type.BRANCH, icon, iconSelected);
      },

      /**
       * Add a leaf to the tree.
       *
       * @param parentNodeId {Integer}
       *   The node id of the parent of the node being added
       *
       * @param label {String}
       *   The string to display as the label for this node
       *
       * @param icon {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is not a selected node.
       *
       * @param iconSelected {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is a selected node.
       *
       * @return {Integer} The node id of the newly-added leaf.
       */
      addLeaf: function addLeaf(parentNodeId, label, icon, iconSelected) {
        return qx.ui.treevirtual.MTreePrimitive._addNode(this._nodeArr, parentNodeId, label, false, false, qx.ui.treevirtual.MTreePrimitive.Type.LEAF, icon, iconSelected);
      },

      /**
       * Prune the tree by removing, recursively, all of a node's children.  If
       * requested, also remove the node itself.
       *
       * @param nodeReference {Object | Integer}
       *   The node to be pruned from the tree.  The node can be represented
       *   either by the node object, or the node id (as would have been
       *   returned by addBranch(), addLeaf(), etc.)
       *
       * @param bSelfAlso {Boolean}
       *   If <i>true</i> then remove the node identified by <i>nodeId</i> as
       *   well as all of the children.
       *
       * @throws {Error} If the node object or id is not valid.
       *
       */
      prune: function prune(nodeReference, bSelfAlso) {
        var node;
        var nodeId;

        if (typeof nodeReference == "object") {
          node = nodeReference;
          nodeId = node.nodeId;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
        } else {
          throw new Error("Expected node object or node id");
        } // First, recursively remove all children


        for (var i = this._nodeArr[nodeId].children.length - 1; i >= 0; i--) {
          this.prune(this._nodeArr[nodeId].children[i], true);
        } // Now remove ourself, if requested. (Don't try to remove the root node)


        if (bSelfAlso && nodeId != 0) {
          // Delete ourself from our parent's children list
          node = this._nodeArr[nodeId];
          qx.lang.Array.remove(this._nodeArr[node.parentNodeId].children, nodeId); // Delete ourself from the selections list, if we're in it.

          if (this._selections[nodeId]) {
            delete this._selections[nodeId];
          } // We can't splice the node itself out, because that would muck up the
          // nodeId == index correspondence.  Instead, just replace the node
          // with null so its index just becomes unused.


          this._nodeArr[nodeId] = null;
        }
      },

      /**
       * Move a node in the tree.
       *
       * @param moveNodeReference {Object | Integer}
       *   The node to be moved.  The node can be represented
       *   either by the node object, or the node id (as would have been
       *   returned by addBranch(), addLeaf(), etc.)
       *
       * @param parentNodeReference {Object | Integer}
       *   The new parent node, which must not be a LEAF.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @throws {Error} If the node object or id is not valid.
       * @throws {Error} If one tries to add a child to a non-existent parent.
       * @throws {Error} If one tries to add a node to a leaf.
       */
      move: function move(moveNodeReference, parentNodeReference) {
        var moveNode;
        var moveNodeId;
        var parentNode;
        var parentNodeId; // Replace null parent with node id 0

        parentNodeReference = parentNodeReference || 0;

        if (typeof moveNodeReference == "object") {
          moveNode = moveNodeReference;
          moveNodeId = moveNode.nodeId;
        } else if (typeof moveNodeReference == "number") {
          moveNodeId = moveNodeReference;
          moveNode = this._nodeArr[moveNodeId];
        } else {
          throw new Error("Expected move node object or node id");
        }

        if (typeof parentNodeReference == "object") {
          parentNode = parentNodeReference;
          parentNodeId = parentNode.nodeId;
        } else if (typeof parentNodeReference == "number") {
          parentNodeId = parentNodeReference;
          parentNode = this._nodeArr[parentNodeId];
        } else {
          throw new Error("Expected parent node object or node id");
        } // Ensure parent isn't a leaf


        if (parentNode.type == qx.ui.treevirtual.MTreePrimitive.Type.LEAF) {
          throw new Error("Sorry, a LEAF may not have children.");
        } // Remove the node from its current parent's children list


        var oldParent = this._nodeArr[moveNode.parentNodeId];
        qx.lang.Array.remove(oldParent.children, moveNodeId); // Add the node to its new parent's children list

        parentNode.children.push(moveNodeId); // Replace this node's parent reference

        this._nodeArr[moveNodeId].parentNodeId = parentNodeId;
      },

      /**
       * Orders the node and creates all data needed to render the tree.
       *
       * @param nodeId {Integer}
       *   A node identifier, as previously returned by {@link #addBranch} or
       *   {@link #addLeaf}.
       * @param level {Integer} the level in the hierarchy
       */
      __inorder: function __inorder(nodeId, level) {
        var filter = this.getFilter();
        var child = null;
        var childNodeId; // For each child of the specified node...

        var numChildren = this._nodeArr[nodeId].children.length;
        var index = 0;
        var children = this.__tempTreeData[nodeId] = [];

        for (var i = 0; i < numChildren; i++) {
          // Determine the node id of this child
          childNodeId = this._nodeArr[nodeId].children[i]; // Get the child node

          child = this._nodeArr[childNodeId]; // Skip deleted nodes or apply the filter

          if (child == null || filter && !filter.call(this, child)) {
            this.__recalculateLastChildFlags = true;
            continue;
          } // Remember the children so that we can add the lastChild flags later


          children.push(child); // (Re-)assign this node's level

          child.level = level; // Determine if we're the first child of our parent

          child.bFirstChild = index == 0; // Set the last child flag of the node only when no node was skipped.
          // Otherwise we will have to recalculate the last child flags, as
          // the parent or sibling node might become the first child.

          if (!this.__recalculateLastChildFlags) {
            this.__setLastChildFlag(child, i == numChildren - 1);
          } // Ensure there's an entry in the columnData array for each column


          if (!child.columnData) {
            child.columnData = [];
          }

          if (child.columnData.length < this.getColumnCount()) {
            child.columnData[this.getColumnCount() - 1] = null;
          } // Add this node to the row array.  Initialize a row data array.


          var rowData = []; // If additional column data is provided...

          if (child.columnData) {
            // ... then add each column data.
            for (var j = 0; j < child.columnData.length; j++) {
              // Is this the tree column?
              if (j == this._treeColumn) {
                // Yup.  Add the tree node data
                rowData.push(child);
              } else {
                // Otherwise, add the column data verbatim.
                rowData.push(child.columnData[j]);
              }
            }
          } else {
            // No column data.  Just add the tree node.
            rowData.push(child);
          } // Track the _rowArr index for each node so we can handle
          // selections.


          this._nodeRowMap[child.nodeId] = this._rowArr.length; // Add the row data to the row array

          this._rowArr.push(rowData); // If this node is selected, ...


          if (child.bSelected) {
            // ... indicate so for the row.
            rowData.selected = true;
            this._selections[child.nodeId] = true;
          } // If this child is opened, ...


          if (child.bOpened) {
            // ... then add its children too.
            this.__inorder(childNodeId, level + 1);
          }

          index++;
        }
      },

      /**
       * Calculates the lastChild flags to the nodes, so that the tree can render the
       * tree lines right.
       *
       * @param nodeId {Integer}
       *   A node identifier, as previously returned by {@link #addBranch} or
       *   {@link #addLeaf}.
       */
      __calculateLastChildFlags: function __calculateLastChildFlags(nodeId) {
        var tempTreeData = this.__tempTreeData;
        var children = tempTreeData[nodeId];
        var numChildren = children.length;

        for (var i = 0; i < numChildren; i++) {
          var child = children[i];

          this.__setLastChildFlag(child, i == numChildren - 1);

          var hasChildren = tempTreeData[child.nodeId] && tempTreeData[child.nodeId].length > 0;

          if (hasChildren) {
            this.__calculateLastChildFlags(child.nodeId);
          }
        }
      },

      /**
       * Sets the last child flag for a node and all it's parents.
       *
       * @param node {Object} the node object
       * @param isLastChild {Boolean} whether the node is the last child
       */
      __setLastChildFlag: function __setLastChildFlag(node, isLastChild) {
        // Determine if we're the last child of our parent
        node.lastChild = [isLastChild]; // Get our parent.

        var parent = this._nodeArr[node.parentNodeId]; // For each parent node, determine if it is a last child

        while (parent.nodeId) {
          var bLast = parent.lastChild[parent.lastChild.length - 1];
          node.lastChild.unshift(bLast);
          parent = this._nodeArr[parent.parentNodeId];
        }
      },

      /**
       * Renders the tree data.
       */
      __render: function __render() {
        // Reset the __tempTreeData
        this.__tempTreeData = [];
        this.__recalculateLastChildFlags = false; // Reset the row array

        this._rowArr = []; // Reset the _nodeArr -> _rowArr map

        this._nodeRowMap = []; // Reset the set of selections

        this._selections = {}; // Begin in-order traversal of the tree from the root to regenerate
        // _rowArr.

        this.__inorder(0, 1); // Reset the lastChild flags when needed, so that the tree can render the
        // tree lines right.


        if (this.__recalculateLastChildFlags) {
          this.__calculateLastChildFlags(0);
        } // Give the memory free


        this.__tempTreeData = null; // Inform the listeners

        if (this.hasListener("dataChanged")) {
          var data = {
            firstRow: 0,
            lastRow: this._rowArr.length - 1,
            firstColumn: 0,
            lastColumn: this.getColumnCount() - 1
          };
          this.fireDataEvent("dataChanged", data);
        }
      },

      /**
       * Sets the whole data en bulk, or notifies the data model that node
       * modifications are complete.
       *
       * @param nodeArr {Array | null}
       *   Pass either an Array of node objects, or null.
       *
       *   If non-null, nodeArr is an array of node objects containing the
       *   entire tree to be displayed.  If loading the whole data en bulk in
       *   this way, it is assumed that the data is correct!  No error checking
       *   or validation is done.  You'd better know what you're doing!  Caveat
       *   emptor.
       *
       *
       *   If nodeArr is null, then this call is a notification that the user
       *   has completed building or modifying a tree by issuing a series of
       *   calls to {@link #addBranch} and/or {@link #addLeaf}.
       *
       *
       * @throws {Error} If the parameter has the wrong type.
       */
      setData: function setData(nodeArr) {
        if (nodeArr instanceof Array) {
          // Save the user-supplied data.
          this._nodeArr = nodeArr;
        } else if (nodeArr !== null && nodeArr !== undefined) {
          throw new Error("Expected array of node objects or null/undefined; got " + typeof nodeArr);
        } // Re-render the row array


        this.__render(); // Set selections in the selection model now


        var selectionModel = this.getTree().getSelectionModel();
        var selections = this._selections;

        for (var nodeId in selections) {
          var nRowIndex = this.getRowFromNodeId(nodeId);
          selectionModel.setSelectionInterval(nRowIndex, nRowIndex);
        }
      },

      /**
       * Return the array of node data.
       *
       * @return {Array}
       *  Array of node objects.
       *  See {@link qx.ui.treevirtual.SimpleTreeDataModel} for a description
       *  nodes in this array.
       */
      getData: function getData() {
        return this._nodeArr;
      },

      /**
       * Clears the tree of all nodes
       *
       */
      clearData: function clearData() {
        this._clearSelections();

        this.setData([qx.ui.treevirtual.MTreePrimitive._getEmptyTree()]);
      },

      /**
       * Add data to an additional column (a column other than the tree column)
       * of the tree.
       *
       * @param nodeId {Integer}
       *   A node identifier, as previously returned by {@link #addBranch} or
       *   {@link #addLeaf}.
       *
       * @param columnIndex {Integer}
       *   The column number to which the provided data applies
       *
       * @param data {var}
       *   The cell data for the specified column
       *
       */
      setColumnData: function setColumnData(nodeId, columnIndex, data) {
        this._nodeArr[nodeId].columnData[columnIndex] = data;
      },

      /**
       * Retrieve the data from an additional column (a column other than the
       * tree column) of the tree.
       *
       * @param nodeId {Integer}
       *   A node identifier, as previously returned by {@link #addBranch} or
       *   {@link #addLeaf}.
       *
       * @param columnIndex {Integer}
       *   The column number to which the provided data applies
       *
       * @return {var} The cell data for the specified column
       */
      getColumnData: function getColumnData(nodeId, columnIndex) {
        return this._nodeArr[nodeId].columnData[columnIndex];
      },

      /**
       * Set state attributes of a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node to have its attributes set.  The node can be represented
       *   either by the node object, or the node id (as would have been
       *   returned by addBranch(), addLeaf(), etc.)
       *
       * @param attributes {Map}
       *   Each property name in the map may correspond to the property names of
       *   a node which are specified as <i>USER-PROVIDED ATTRIBUTES</i> in
       *   {@link SimpleTreeDataModel}.  Each property value will be assigned
       *   to the corresponding property of the node specified by nodeId.
       *
       * @throws {Error} If the node object or id is not valid.
       */
      setState: function setState(nodeReference, attributes) {
        var node;
        var nodeId;

        if (typeof nodeReference == "object") {
          node = nodeReference;
          nodeId = node.nodeId;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
          node = this._nodeArr[nodeId];
        } else {
          throw new Error("Expected node object or node id");
        }

        for (var attribute in attributes) {
          // Do any attribute-specific processing
          switch (attribute) {
            case "bSelected":
              var nRowIndex = this.getRowFromNodeId(nodeId);
              var selectionModel = this.getTree().getSelectionModel();
              var TV = qx.ui.treevirtual.TreeVirtual;
              var bChangeSelection = typeof nRowIndex === "number" && this.getTree().getSelectionMode() != TV.SelectionMode.NONE; // The selected state is changing. Keep track of what is selected

              if (attributes[attribute]) {
                this._selections[nodeId] = true; // Add selection range for node

                if (bChangeSelection && !selectionModel.isSelectedIndex(nRowIndex)) {
                  selectionModel.setSelectionInterval(nRowIndex, nRowIndex);
                }
              } else {
                delete this._selections[nodeId]; // Delete selection range for node

                if (bChangeSelection && selectionModel.isSelectedIndex(nRowIndex)) {
                  selectionModel.removeSelectionInterval(nRowIndex, nRowIndex);
                }
              }

              break;

            case "bOpened":
              // Don't do anything if the requested state is the same as the
              // current state.
              if (attributes[attribute] == node.bOpened) {
                break;
              } // Get the tree to which this data model is attached


              var tree = this.__tree; // Are we opening or closing?

              if (node.bOpened) {
                // We're closing.  If there are listeners, generate a treeClose
                // event.
                tree.fireDataEvent("treeClose", node);
              } else {
                // We're opening.  Are there any children?
                if (node.children.length > 0) {
                  // Yup.  If there any listeners, generate a "treeOpenWithContent"
                  // event.
                  tree.fireDataEvent("treeOpenWithContent", node);
                } else {
                  // No children.  If there are listeners, generate a
                  // "treeOpenWhileEmpty" event.
                  tree.fireDataEvent("treeOpenWhileEmpty", node);
                }
              } // Event handler may have modified the opened state.  Check before
              // toggling.


              if (!node.bHideOpenClose) {
                // It's still boolean.  Toggle the state
                node.bOpened = !node.bOpened; // Clear the old selections in the tree

                tree.getSelectionModel()._resetSelection();
              } // Re-render the row data since formerly visible rows may now be
              // invisible, or vice versa.


              this.setData();
              break;

            default:
              // no attribute-specific processing required
              break;
          } // Set the new attribute value


          node[attribute] = attributes[attribute];
        }
      },

      /**
       * Return the mapping of nodes to rendered rows.  This function is intended
       * for use by the cell renderer, not by users of this class.
       * It is also useful to select a node.
       *
       * @return {Array}
       *   The array containing mappings of nodes to rendered rows.
       */
      getNodeRowMap: function getNodeRowMap() {
        return this._nodeRowMap;
      },

      /**
       * This operation maps nodes to rowIndexes.  It does the opposite job to {@link #getNodeFromRow}.
       *
       * @param nodeId {Integer}
       *   The id of the node (as would have been returned by addBranch(),
       *   addLeaf(), etc.) to get the row index for.
       * @return {Integer} row index for the given node ID
       */
      getRowFromNodeId: function getRowFromNodeId(nodeId) {
        return this._nodeRowMap[nodeId];
      },

      /**
       * This operation maps rowIndexes to nodes.  It does the opposite job to {@link #getRowFromNodeId}.
       * This function is useful to map selection (row based) to nodes.
       *
       * @param rowIndex {Integer} zero-based row index.
       * @return {Object} node associated to <tt>rowIndex</tt>.
       */
      getNodeFromRow: function getNodeFromRow(rowIndex) {
        return this._nodeArr[this._rowArr[rowIndex][this._treeColumn].nodeId];
      },

      /**
       * Clear all selections in the data model.  This method does not clear
       * selections displayed in the widget, and is intended for internal use,
       * not by users of this class.
       *
       */
      _clearSelections: function _clearSelections() {
        // Clear selected state for any selected nodes.
        for (var selection in this._selections) {
          this._nodeArr[selection].bSelected = false;
        } // Reinitialize selections array.


        this._selections = {};
      },

      /**
       * Return the nodes that are currently selected.
       *
       * @return {Array}
       *   An array containing the nodes that are currently selected.
       */
      getSelectedNodes: function getSelectedNodes() {
        var nodes = [];

        for (var nodeId in this._selections) {
          nodes.push(this._nodeArr[nodeId]);
        }

        return nodes;
      },
      // property apply
      _applyFilter: function _applyFilter(value, old) {
        this.setData();
      }
    },
    destruct: function destruct() {
      this._rowArr = this._nodeArr = this._nodeRowMap = this._selections = this.__tree = this.__tempTreeData = null;
    },
    defer: function defer(statics) {
      // For backward compatibility, ensure the Type values are available from
      // this class as well as from the mixin.
      statics.Type = qx.ui.treevirtual.MTreePrimitive.Type;
    }
  });
  qx.ui.treevirtual.SimpleTreeDataModel.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.Table": {
        "construct": true,
        "require": true
      },
      "qx.ui.treevirtual.SimpleTreeDataModel": {
        "construct": true
      },
      "qx.ui.treevirtual.SimpleTreeDataCellRenderer": {
        "construct": true
      },
      "qx.ui.treevirtual.DefaultDataCellRenderer": {
        "construct": true
      },
      "qx.ui.treevirtual.SimpleTreeDataRowRenderer": {
        "construct": true
      },
      "qx.ui.treevirtual.SelectionManager": {
        "construct": true
      },
      "qx.ui.table.columnmodel.Resize": {
        "construct": true
      },
      "qx.lang.Type": {
        "construct": true
      },
      "qx.ui.table.selection.Model": {
        "require": true
      },
      "qx.event.type.Dom": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A "virtual" tree
   * <p>
   *   A number of convenience methods are available in the following mixins:
   *   <ul>
   *     <li>{@link qx.ui.treevirtual.MNode}</li>
   *     <li>{@link qx.ui.treevirtual.MFamily}</li>
   *   </ul>
   * </p>
   */
  qx.Class.define("qx.ui.treevirtual.TreeVirtual", {
    extend: qx.ui.table.Table,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param headings {Array | String}
     *   An array containing a list of strings, one for each column, representing
     *   the headings for each column.  As a special case, if only one column is
     *   to exist, the string representing its heading need not be enclosed in an
     *   array.
     *
     * @param custom {Map ? null}
     *   A map provided (typically) by subclasses, to override the various
     *   supplemental classes allocated within this constructor.  For normal
     *   usage, this parameter may be omitted.  Each property must be an object
     *   instance or a function which returns an object instance, as indicated by
     *   the defaults listed here:
     *
     *   <dl>
     *     <dt>initiallyHiddenColumns</dt>
     *       <dd>
     *         {Array?}
     *         A list of column numbers that should be initially invisible. Any
     *         column not mentioned will be initially visible, and if no array
     *         is provided, all columns will be initially visible.
     *       </dd>
     *     <dt>dataModel</dt>
     *       <dd>new qx.ui.treevirtual.SimpleTreeDataModel()</dd>
     *     <dt>treeDataCellRenderer</dt>
     *       <dd>
     *         Instance of {@link qx.ui.treevirtual.SimpleTreeDataCellRenderer}.
     *         Custom data cell renderer for the tree column.
     *       </dd>
     *     <dt>treeColumn</dt>
     *       <dd>
     *         The column number in which the tree is to reside, i.e., which
     *         column uses the SimpleTreeDataCellRenderer or a subclass of it.
     *       </dd>
     *     <dt>defaultDataCellRenderer</dt>
     *       <dd>
     *         Instance of {@link qx.ui.treevirtual.DefaultDataCellRenderer}.
     *         Custom data cell renderer for all columns other than the tree
     *         column.
     *       </dd>
     *     <dt>dataRowRenderer</dt>
     *       <dd>new qx.ui.treevirtual.SimpleTreeDataRowRenderer()</dd>
     *     <dt>selectionManager</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.treevirtual.SelectionManager(obj);
     *         }
     *       </pre></dd>
     *     <dt>tableColumnModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.columnmodel.Resize(obj);
     *         }
     *       </pre></dd>
     *   </dl>
     */
    construct: function construct(headings, custom) {
      //
      // Allocate default objects if custom objects are not specified
      //
      if (!custom) {
        custom = {};
      }

      if (!custom.dataModel) {
        custom.dataModel = new qx.ui.treevirtual.SimpleTreeDataModel();
      }

      if (custom.treeColumn === undefined) {
        custom.treeColumn = 0;
        custom.dataModel.setTreeColumn(custom.treeColumn);
      }

      if (!custom.treeDataCellRenderer) {
        custom.treeDataCellRenderer = new qx.ui.treevirtual.SimpleTreeDataCellRenderer();
      }

      if (!custom.defaultDataCellRenderer) {
        custom.defaultDataCellRenderer = new qx.ui.treevirtual.DefaultDataCellRenderer();
      }

      if (!custom.dataRowRenderer) {
        custom.dataRowRenderer = new qx.ui.treevirtual.SimpleTreeDataRowRenderer();
      }

      if (!custom.selectionManager) {
        custom.selectionManager = function (obj) {
          return new qx.ui.treevirtual.SelectionManager(obj);
        };
      }

      if (!custom.tableColumnModel) {
        custom.tableColumnModel = function (obj) {
          return new qx.ui.table.columnmodel.Resize(obj);
        };
      } // Specify the column headings.  We accept a single string (one single
      // column) or an array of strings (one or more columns).


      if (qx.lang.Type.isString(headings)) {
        headings = [headings];
      }

      custom.dataModel.setColumns(headings);
      custom.dataModel.setTreeColumn(custom.treeColumn); // Save a reference to the tree with the data model

      custom.dataModel.setTree(this); // Call our superclass constructor

      qx.ui.table.Table.constructor.call(this, custom.dataModel, custom); // Arrange to redisplay edited data following editing

      this.addListener("dataEdited", function (e) {
        this.getDataModel().setData();
      }, this); // By default, present the column visibility button only if there are
      // multiple columns.

      this.setColumnVisibilityButtonVisible(headings.length > 1); // Set sizes

      this.setRowHeight(16);
      this.setMetaColumnCounts(headings.length > 1 ? [1, -1] : [1]); // Overflow on trees is always hidden.  The internal elements scroll.

      this.setOverflow("hidden"); // Set the data cell render.  We use the SimpleTreeDataCellRenderer for the
      // tree column, and our DefaultDataCellRenderer for all other columns.

      var stdcr = custom.treeDataCellRenderer;
      var ddcr = custom.defaultDataCellRenderer;
      var tcm = this.getTableColumnModel();
      var treeCol = this.getDataModel().getTreeColumn();

      for (var i = 0; i < headings.length; i++) {
        tcm.setDataCellRenderer(i, i == treeCol ? stdcr : ddcr);
      } // Set the data row renderer.


      this.setDataRowRenderer(custom.dataRowRenderer); // Move the focus with the mouse.  This controls the ROW focus indicator.

      this.setFocusCellOnPointerMove(true); // In a tree we don't typically want a visible cell focus indicator

      this.setShowCellFocusIndicator(false); // Get the list of pane scrollers

      var scrollers = this._getPaneScrollerArr(); // For each scroller...


      for (var i = 0; i < scrollers.length; i++) {
        // Set the pane scrollers to handle the selection before
        // displaying the focus, so we can manipulate the selected icon.
        scrollers[i].setSelectBeforeFocus(true);
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when a tree branch which already has content is opened.
       *
       * Event data: the node object from the data model (of the node
       * being opened) as described in
       * {@link qx.ui.treevirtual.SimpleTreeDataModel}
       */
      "treeOpenWithContent": "qx.event.type.Data",

      /**
       * Fired when an empty tree branch is opened.
       *
       * Event data: the node object from the data model (of the node
       * being opened) as described in
       * {@link qx.ui.treevirtual.SimpleTreeDataModel}
       */
      "treeOpenWhileEmpty": "qx.event.type.Data",

      /**
       * Fired when a tree branch is closed.
       *
       * Event data: the node object from the data model (of the node
       * being closed) as described in
       * {@link qx.ui.treevirtual.SimpleTreeDataModel}
       */
      "treeClose": "qx.event.type.Data",

      /**
       * Fired when the selected rows change.
       *
       * Event data: An array of node objects (the selected rows' nodes)
       * from the data model.  Each node object is described in
       * {@link qx.ui.treevirtual.SimpleTreeDataModel}
       */
      "changeSelection": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * Selection Modes {int}
       *
       *   NONE
       *     Nothing can ever be selected.
       *
       *   SINGLE
       *     Allow only one selected item.
       *
       *   SINGLE_INTERVAL
       *     Allow one contiguous interval of selected items.
       *
       *   MULTIPLE_INTERVAL
       *     Allow any set of selected items, whether contiguous or not.
       *
       *   MULTIPLE_INTERVAL_TOGGLE
       *     Like MULTIPLE_INTERVAL, but clicking on an item toggles its selection state.
       */
      SelectionMode: {
        NONE: qx.ui.table.selection.Model.NO_SELECTION,
        SINGLE: qx.ui.table.selection.Model.SINGLE_SELECTION,
        SINGLE_INTERVAL: qx.ui.table.selection.Model.SINGLE_INTERVAL_SELECTION,
        MULTIPLE_INTERVAL: qx.ui.table.selection.Model.MULTIPLE_INTERVAL_SELECTION,
        MULTIPLE_INTERVAL_TOGGLE: qx.ui.table.selection.Model.MULTIPLE_INTERVAL_SELECTION_TOGGLE
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether a click on the open/close button should also cause selection of
       * the row.
       */
      openCloseClickSelectsRow: {
        check: "Boolean",
        init: false
      },
      appearance: {
        refine: true,
        init: "treevirtual"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Return the data model for this tree.
       *
       * @return {qx.ui.table.ITableModel} The data model.
       */
      getDataModel: function getDataModel() {
        return this.getTableModel();
      },

      /**
       * Set whether lines linking tree children shall be drawn on the tree.
       * Note that not all themes support tree lines.  As of the time of this
       * writing, the Classic theme supports tree lines (and uses +/- icons
       * which lend themselves to tree lines), while the Modern theme, which
       * uses right-facing and downward-facing arrows instead of +/-, does not.
       *
       * @param b {Boolean}
       *   <i>true</i> if tree lines should be shown; <i>false</i> otherwise.
       *
       */
      setUseTreeLines: function setUseTreeLines(b) {
        var dataModel = this.getDataModel();
        var treeCol = dataModel.getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        dcr.setUseTreeLines(b); // Inform the listeners

        if (dataModel.hasListener("dataChanged")) {
          var data = {
            firstRow: 0,
            lastRow: dataModel.getRowCount() - 1,
            firstColumn: 0,
            lastColumn: dataModel.getColumnCount() - 1
          };
          dataModel.fireDataEvent("dataChanged", data);
        }
      },

      /**
       * Get whether lines linking tree children shall be drawn on the tree.
       *
       * @return {Boolean}
       *   <i>true</i> if tree lines are in use;
       *   <i>false</i> otherwise.
       */
      getUseTreeLines: function getUseTreeLines() {
        var treeCol = this.getDataModel().getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        return dcr.getUseTreeLines();
      },

      /**
       * Set whether the open/close button should be displayed on a branch,
       * even if the branch has no children.
       *
       * @param b {Boolean}
       *   <i>true</i> if the open/close button should be shown;
       *   <i>false</i> otherwise.
       *
       */
      setAlwaysShowOpenCloseSymbol: function setAlwaysShowOpenCloseSymbol(b) {
        var dataModel = this.getDataModel();
        var treeCol = dataModel.getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        dcr.setAlwaysShowOpenCloseSymbol(b); // Inform the listeners

        if (dataModel.hasListener("dataChanged")) {
          var data = {
            firstRow: 0,
            lastRow: dataModel.getRowCount() - 1,
            firstColumn: 0,
            lastColumn: dataModel.getColumnCount() - 1
          };
          dataModel.fireDataEvent("dataChanged", data);
        }
      },

      /**
       * Set whether drawing of first-level tree-node lines are disabled even
       * if drawing of tree lines is enabled.
       *
       * @param b {Boolean}
       *   <i>true</i> if first-level tree lines should be disabled;
       *   <i>false</i> for normal operation.
       *
       */
      setExcludeFirstLevelTreeLines: function setExcludeFirstLevelTreeLines(b) {
        var dataModel = this.getDataModel();
        var treeCol = dataModel.getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        dcr.setExcludeFirstLevelTreeLines(b); // Inform the listeners

        if (dataModel.hasListener("dataChanged")) {
          var data = {
            firstRow: 0,
            lastRow: dataModel.getRowCount() - 1,
            firstColumn: 0,
            lastColumn: dataModel.getColumnCount() - 1
          };
          dataModel.fireDataEvent("dataChanged", data);
        }
      },

      /**
       * Get whether drawing of first-level tree lines should be disabled even
       * if drawing of tree lines is enabled.
       * (See also {@link #getUseTreeLines})
       *
       * @return {Boolean}
       *   <i>true</i> if tree lines are in use;
       *   <i>false</i> otherwise.
       */
      getExcludeFirstLevelTreeLines: function getExcludeFirstLevelTreeLines() {
        var treeCol = this.getDataModel().getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        return dcr.getExcludeFirstLevelTreeLines();
      },

      /**
       * Set whether the open/close button should be displayed on a branch,
       * even if the branch has no children.
       *
       * @return {Boolean}
       *   <i>true</i> if tree lines are in use;
       *   <i>false</i> otherwise.
       */
      getAlwaysShowOpenCloseSymbol: function getAlwaysShowOpenCloseSymbol() {
        var treeCol = this.getDataModel().getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        return dcr.getAlwaysShowOpenCloseSymbol();
      },

      /**
       * Set the selection mode.
       *
       * @param mode {Integer}
       *   The selection mode to be used.  It may be any of:
       *     <pre>
       *       qx.ui.treevirtual.TreeVirtual.SelectionMode.NONE:
       *          Nothing can ever be selected.
       *
       *       qx.ui.treevirtual.TreeVirtual.SelectionMode.SINGLE
       *          Allow only one selected item.
       *
       *       qx.ui.treevirtual.TreeVirtual.SelectionMode.SINGLE_INTERVAL
       *          Allow one contiguous interval of selected items.
       *
       *       qx.ui.treevirtual.TreeVirtual.SelectionMode.MULTIPLE_INTERVAL
       *          Allow any selected items, whether contiguous or not.
       *     </pre>
       *
       */
      setSelectionMode: function setSelectionMode(mode) {
        this.getSelectionModel().setSelectionMode(mode);
      },

      /**
       * Get the selection mode currently in use.
       *
       * @return {Integer}
       *   One of the values documented in {@link #setSelectionMode}
       */
      getSelectionMode: function getSelectionMode() {
        return this.getSelectionModel().getSelectionMode();
      },

      /**
       * Obtain the entire hierarchy of labels from the root down to the
       * specified node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the hierarchy is desired.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Array}
       *   The returned array contains one string for each label in the
       *   hierarchy of the node specified by the parameter.  Element 0 of the
       *   array contains the label of the root node, element 1 contains the
       *   label of the node immediately below root in the specified node's
       *   hierarchy, etc., down to the last element in the array contain the
       *   label of the node referenced by the parameter.
       */
      getHierarchy: function getHierarchy(nodeReference) {
        var _this = this;

        var components = [];
        var node;
        var nodeId;

        if (typeof nodeReference == "object") {
          node = nodeReference;
          nodeId = node.nodeId;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
        } else {
          throw new Error("Expected node object or node id");
        }

        function addHierarchy(nodeId) {
          // If we're at the root...
          if (!nodeId) {
            // ... then we're done
            return;
          } // Get the requested node


          var node = _this.getDataModel().getData()[nodeId]; // Add its label to the hierarchy components


          components.unshift(node.label); // Call recursively to our parent node.

          addHierarchy(node.parentNodeId);
        }

        addHierarchy(nodeId);
        return components;
      },

      /**
       * Return the nodes that are currently selected.
       *
       * @return {Array}
       *   An array containing the nodes that are currently selected.
       */
      getSelectedNodes: function getSelectedNodes() {
        return this.getDataModel().getSelectedNodes();
      },

      /**
       * Event handler. Called when a key was pressed.
       *
       * We handle the Enter key to toggle opened/closed tree state.  All
       * other keydown events are passed to our superclass.
       *
       * @param evt {Map}
       *   The event.
       *
       */
      _onKeyPress: function _onKeyPress(evt) {
        if (!this.getEnabled()) {
          return;
        }

        var identifier = evt.getKeyIdentifier();
        var consumed = false;
        var modifiers = evt.getModifiers();

        if (modifiers == 0) {
          switch (identifier) {
            case "Enter":
              // Get the data model
              var dm = this.getDataModel();
              var focusedCol = this.getFocusedColumn();
              var treeCol = dm.getTreeColumn();

              if (focusedCol == treeCol) {
                // Get the focused node
                var focusedRow = this.getFocusedRow();
                var node = dm.getNode(focusedRow);

                if (!node.bHideOpenClose && node.type != qx.ui.treevirtual.SimpleTreeDataModel.Type.LEAF) {
                  dm.setState(node, {
                    bOpened: !node.bOpened
                  });
                }

                consumed = true;
              }

              break;

            case "Left":
              this.moveFocusedCell(-1, 0);
              break;

            case "Right":
              this.moveFocusedCell(1, 0);
              break;
          }
        } else if (modifiers == qx.event.type.Dom.CTRL_MASK) {
          switch (identifier) {
            case "Left":
              // Get the data model
              var dm = this.getDataModel(); // Get the focused node

              var focusedRow = this.getFocusedRow();
              var treeCol = dm.getTreeColumn();
              var node = dm.getNode(focusedRow); // If it's an open branch and open/close is allowed...

              if (node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.BRANCH && !node.bHideOpenClose && node.bOpened) {
                // ... then close it
                dm.setState(node, {
                  bOpened: !node.bOpened
                });
              } // Reset the focus to the current node


              this.setFocusedCell(treeCol, focusedRow, true);
              consumed = true;
              break;

            case "Right":
              // Get the data model
              var dm = this.getDataModel(); // Get the focused node

              focusedRow = this.getFocusedRow();
              treeCol = dm.getTreeColumn();
              node = dm.getNode(focusedRow); // If it's a closed branch and open/close is allowed...

              if (node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.BRANCH && !node.bHideOpenClose && !node.bOpened) {
                // ... then open it
                dm.setState(node, {
                  bOpened: !node.bOpened
                });
              } // Reset the focus to the current node


              this.setFocusedCell(treeCol, focusedRow, true);
              consumed = true;
              break;
          }
        } else if (modifiers == qx.event.type.Dom.SHIFT_MASK) {
          switch (identifier) {
            case "Left":
              // Get the data model
              var dm = this.getDataModel(); // Get the focused node

              var focusedRow = this.getFocusedRow();
              var treeCol = dm.getTreeColumn();
              var node = dm.getNode(focusedRow); // If we're not at the top-level already...

              if (node.parentNodeId) {
                // Find out what rendered row our parent node is at
                var rowIndex = dm.getRowFromNodeId(node.parentNodeId); // Set the focus to our parent

                this.setFocusedCell(this._focusedCol, rowIndex, true);
              }

              consumed = true;
              break;

            case "Right":
              // Get the data model
              var dm = this.getDataModel(); // Get the focused node

              focusedRow = this.getFocusedRow();
              treeCol = dm.getTreeColumn();
              node = dm.getNode(focusedRow); // If we're on a branch and open/close is allowed...

              if (node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.BRANCH && !node.bHideOpenClose) {
                // ... then first ensure the branch is open
                if (!node.bOpened) {
                  dm.setState(node, {
                    bOpened: !node.bOpened
                  });
                } // If this node has children...


                if (node.children.length > 0) {
                  // ... then move the focus to the first child
                  this.moveFocusedCell(0, 1);
                }
              }

              consumed = true;
              break;
          }
        } // Was this one of our events that we handled?


        if (consumed) {
          // Yup.  Don't propagate it.
          evt.preventDefault();
          evt.stopPropagation();
        } else {
          // It's not one of ours.  Let our superclass handle this event
          qx.ui.treevirtual.TreeVirtual.prototype._onKeyPress.base.call(this, evt);
        }
      },

      /**
       * Event handler. Called when the selection has changed.
       *
       * @param evt {Map}
       *   The event.
       *
       */
      _onSelectionChanged: function _onSelectionChanged(evt) {
        // Clear the old list of selected nodes
        this.getDataModel()._clearSelections(); // If selections are allowed, pass an event to our listeners


        if (this.getSelectionMode() != qx.ui.treevirtual.TreeVirtual.SelectionMode.NONE) {
          var selectedNodes = this._calculateSelectedNodes(); // Get the now-focused


          this.fireDataEvent("changeSelection", selectedNodes);
        } // Call the superclass method


        qx.ui.treevirtual.TreeVirtual.prototype._onSelectionChanged.base.call(this, evt);
      },

      /**
       * Calculate and return the set of nodes which are currently selected by
       * the user, on the screen.  In the process of calculating which nodes
       * are selected, the nodes corresponding to the selected rows on the
       * screen are marked as selected by setting their <i>bSelected</i>
       * property to true, and all previously-selected nodes have their
       * <i>bSelected</i> property reset to false.
       *
       * @return {Array}
       *   An array of nodes matching the set of rows which are selected on the
       *   screen.
       */
      _calculateSelectedNodes: function _calculateSelectedNodes() {
        // Create an array of nodes that are now selected
        var stdcm = this.getDataModel();
        var selectedRanges = this.getSelectionModel().getSelectedRanges();
        var selectedNodes = [];
        var node;

        for (var i = 0; i < selectedRanges.length; i++) {
          for (var j = selectedRanges[i].minIndex; j <= selectedRanges[i].maxIndex; j++) {
            node = stdcm.getNode(j);
            stdcm.setState(node, {
              bSelected: true
            });
            selectedNodes.push(node);
          }
        }

        return selectedNodes;
      },

      /**
       * Set the overflow mode.
       *
       * @param s {String}
       *   Overflow mode.  The only allowable mode is "hidden".
       *
       *
       * @throws {Error}
       *   Error if tree overflow mode is other than "hidden"
       */
      setOverflow: function setOverflow(s) {
        if (s != "hidden") {
          throw new Error("Tree overflow must be hidden.  The internal elements of it will scroll.");
        }
      }
    }
  });
  qx.ui.treevirtual.TreeVirtual.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      },
      "qx.util.ResourceManager": {
        "construct": true
      },
      "qx.theme.manager.Appearance": {
        "construct": true
      },
      "qx.io.ImageLoader": {},
      "qx.bom.client.Css": {},
      "qx.bom.element.BoxSizing": {},
      "qx.ui.treevirtual.SimpleTreeDataModel": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxsizing": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
       * David Perez Carmona (david-perez)
  
  ************************************************************************ */

  /**
   * A data cell renderer for the tree column of a simple tree
   *
   * This cell renderer has provisions for subclasses to easily extend the
   * appearance of the tree. If the tree should contain images, labels,
   * etc. before the indentation, the subclass should override the method
   * _addExtraContentBeforeIndentation(). Similarly, content can be added before
   * the icon by overriding _addExtraContentBeforeIcon(), and before the label
   * by overriding _addExtraContentBeforeLabel().
   *
   * Each of these overridden methods that calls _addImage() can provide, as
   * part of the map passed to _addImage(), a member called "tooltip" which
   * contains the tool tip to present when the mouse is hovered over the image.
   *
   * If this class is subclassed to form a new cell renderer, an instance of it
   * must be provided, via the 'custom' parameter, to the TreeVirtual
   * constructor.
   */
  qx.Class.define("qx.ui.treevirtual.SimpleTreeDataCellRenderer", {
    extend: qx.ui.table.cellrenderer.Abstract,
    construct: function construct() {
      var STDCR = qx.ui.treevirtual.SimpleTreeDataCellRenderer; // Begin preloading of the tree images, if not already requested.

      if (STDCR.__bVirgin) {
        STDCR.__preloadImages();

        STDCR.__bVirgin = false;
      }

      qx.ui.table.cellrenderer.Abstract.constructor.call(this);
      this.__am = qx.util.AliasManager.getInstance();
      this.__rm = qx.util.ResourceManager.getInstance();
      this.__tm = qx.theme.manager.Appearance.getInstance(); // Base URL used for indentation

      this.BLANK = this.__rm.toUri(this.__am.resolve("static/blank.gif"));
    },
    statics: {
      /** File names of each of the tree icons */
      __icon: {},

      /** Whether we have not yet requested pre-loading of images */
      __bVirgin: true,

      /**
       * Request preloading of images so they appear immediately upon rendering
       */
      __preloadImages: function __preloadImages() {
        var STDCR = qx.ui.treevirtual.SimpleTreeDataCellRenderer;
        var ImageLoader = qx.io.ImageLoader;
        var am = qx.util.AliasManager.getInstance();
        var rm = qx.util.ResourceManager.getInstance();
        var tm = qx.theme.manager.Appearance.getInstance();

        var loadImage = function loadImage(f) {
          ImageLoader.load(rm.toUri(am.resolve(f)));
        };

        STDCR.__icon.line = tm.styleFrom("treevirtual-line");
        loadImage(STDCR.__icon.line.icon);
        STDCR.__icon.contract = tm.styleFrom("treevirtual-contract");
        loadImage(STDCR.__icon.contract.icon);
        STDCR.__icon.expand = tm.styleFrom("treevirtual-expand");
        loadImage(STDCR.__icon.expand.icon);
        STDCR.__icon.onlyContract = tm.styleFrom("treevirtual-only-contract");
        loadImage(STDCR.__icon.onlyContract.icon);
        STDCR.__icon.onlyExpand = tm.styleFrom("treevirtual-only-expand");
        loadImage(STDCR.__icon.onlyExpand.icon);
        STDCR.__icon.startContract = tm.styleFrom("treevirtual-start-contract");
        loadImage(STDCR.__icon.startContract.icon);
        STDCR.__icon.startExpand = tm.styleFrom("treevirtual-start-expand");
        loadImage(STDCR.__icon.startExpand.icon);
        STDCR.__icon.endContract = tm.styleFrom("treevirtual-end-contract");
        loadImage(STDCR.__icon.endContract.icon);
        STDCR.__icon.endExpand = tm.styleFrom("treevirtual-end-expand");
        loadImage(STDCR.__icon.endExpand.icon);
        STDCR.__icon.crossContract = tm.styleFrom("treevirtual-cross-contract");
        loadImage(STDCR.__icon.crossContract.icon);
        STDCR.__icon.crossExpand = tm.styleFrom("treevirtual-cross-expand");
        loadImage(STDCR.__icon.crossExpand.icon);
        STDCR.__icon.end = tm.styleFrom("treevirtual-end");
        loadImage(STDCR.__icon.end.icon);
        STDCR.__icon.cross = tm.styleFrom("treevirtual-cross");
        loadImage(STDCR.__icon.cross.icon);
      }
    },
    properties: {
      /**
       * Set whether lines linking tree children shall be drawn on the tree
       * if the theme supports tree lines.
       */
      useTreeLines: {
        check: "Boolean",
        init: true
      },

      /**
       * When true, exclude only the first-level tree lines, creating,
       * effectively, multiple unrelated root nodes.
       */
      excludeFirstLevelTreeLines: {
        check: "Boolean",
        init: false
      },

      /**
       * Set whether the open/close button should be displayed on a branch, even
       * if the branch has no children.
       */
      alwaysShowOpenCloseSymbol: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __am: null,
      __tm: null,
      __rm: null,
      // overridden
      _onChangeTheme: function _onChangeTheme() {
        qx.ui.treevirtual.SimpleTreeDataCellRenderer.prototype._onChangeTheme.base.call(this);

        qx.ui.treevirtual.SimpleTreeDataCellRenderer.__preloadImages();
      },
      // overridden
      _getCellStyle: function _getCellStyle(cellInfo) {
        var node = cellInfo.value; // Return the style for the div for the cell.  If there's cell-specific
        // style information provided, append it.

        var html = qx.ui.treevirtual.SimpleTreeDataCellRenderer.prototype._getCellStyle.base.call(this, cellInfo) + (node.cellStyle ? node.cellStyle + ";" : "");
        return html;
      },
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        var html = ""; // Horizontal position

        var pos = 0; // If needed, add extra content before indentation

        var extra = this._addExtraContentBeforeIndentation(cellInfo, pos);

        html += extra.html;
        pos = extra.pos; // Add the indentation (optionally with tree lines)

        var indentation = this._addIndentation(cellInfo, pos);

        html += indentation.html;
        pos = indentation.pos; // If needed, add extra content before icon

        extra = this._addExtraContentBeforeIcon(cellInfo, pos);
        html += extra.html;
        pos = extra.pos; // Add the node icon

        var icon = this._addIcon(cellInfo, pos);

        html += icon.html;
        pos = icon.pos; // If needed, add extra content before label

        extra = this._addExtraContentBeforeLabel(cellInfo, pos);
        html += extra.html;
        pos = extra.pos; // Add the node's label

        html += this._addLabel(cellInfo, pos);
        return html;
      },

      /**
       * Add an image to the tree.  This might be a visible icon or it may be
       * part of the indentation.
       *
       * @param imageInfo {Map}
       *   How to display the image.  It optionally includes any of the
       *   following:
       *   <dl>
       *     <dt>position {Map}</dt>
       *     <dd>
       *       If provided, a div is created to hold the image.  The div's top,
       *       right, bottom, left, width, and/or height may be specified with
       *       members of this map.  Each is expected to be an integer value.
       *     </dd>
       *     <dt>imageWidth, imageHeight</dt>
       *     <dd>
       *       The image's width and height.  These are used only if both are
       *       specified.
       *     </dd>
       *   </dl>
       *
       * @return {String}
       *   The html for this image, possibly with a surrounding div (see
       *   'position', above).
       */
      _addImage: function _addImage(imageInfo) {
        var html = []; // Resolve the URI

        var source = this.__rm.toUri(this.__am.resolve(imageInfo.url)); // If we've been given positioning attributes, enclose image in a div


        if (imageInfo.position) {
          var pos = imageInfo.position;
          html.push('<div style="position:absolute;');

          if (qx.core.Environment.get("css.boxsizing")) {
            html.push(qx.bom.element.BoxSizing.compile("content-box"));
          }

          if (pos.top !== undefined) {
            html.push('top:' + pos.top + 'px;');
          }

          if (pos.right !== undefined) {
            html.push('right:' + pos.right + 'px;');
          }

          if (pos.bottom !== undefined) {
            html.push('bottom:' + pos.bottom + 'px;');
          }

          if (pos.left !== undefined) {
            html.push('left:' + pos.left + 'px;');
          }

          if (pos.width !== undefined) {
            html.push('width:' + pos.width + 'px;');
          }

          if (pos.height !== undefined) {
            html.push('height:' + pos.height + 'px;');
          }

          html.push('">');
        } // Don't use an image tag.  They render differently in Firefox and IE7
        // even if both are enclosed in a div specified as content box.  Instead,
        // add the image as the background image of a div.


        html.push('<div style="');
        html.push('background-image:url(' + source + ');');
        html.push('background-repeat:no-repeat;');

        if (imageInfo.imageWidth && imageInfo.imageHeight) {
          html.push(';width:' + imageInfo.imageWidth + 'px' + ';height:' + imageInfo.imageHeight + 'px');
        }

        var tooltip = imageInfo.tooltip;

        if (tooltip != null) {
          html.push('" title="' + tooltip);
        }

        html.push('">&nbsp;</div>');

        if (imageInfo.position) {
          html.push('</div>');
        }

        return html.join("");
      },

      /**
       * Add the indentation for this node of the tree.
       *
       * The indentation optionally includes tree lines.  Whether tree lines are
       * used depends on (a) the properties 'useTreeLines' and
       * 'excludeFirstLevelTreelines' within this class; and (b) the widget
       * theme in use (some themes don't support tree lines).
       *
       * @param cellInfo {Map} The information about the cell.
       *   See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {Map}
       *   The returned map contains an 'html' member which contains the html for
       *   the indentation, and a 'pos' member which is the starting position
       *   plus the width of the indentation.
       */
      _addIndentation: function _addIndentation(cellInfo, pos) {
        var node = cellInfo.value;
        var imageData;
        var html = ""; // Generate the indentation.  Obtain icon determination values once
        // rather than each time through the loop.

        var bUseTreeLines = this.getUseTreeLines();
        var bExcludeFirstLevelTreeLines = this.getExcludeFirstLevelTreeLines();
        var bAlwaysShowOpenCloseSymbol = this.getAlwaysShowOpenCloseSymbol();

        for (var i = 0; i < node.level; i++) {
          imageData = this._getIndentSymbol(i, node, bUseTreeLines, bAlwaysShowOpenCloseSymbol, bExcludeFirstLevelTreeLines);
          var rowHeight = cellInfo.table.getRowHeight();
          html += this._addImage({
            url: imageData.icon,
            position: {
              top: 0 + (imageData.paddingTop || 0),
              left: pos + (imageData.paddingLeft || 0),
              width: rowHeight + 3,
              height: rowHeight
            },
            imageWidth: rowHeight,
            imageHeight: rowHeight
          });
          pos += rowHeight + 3;
        }

        return {
          html: html,
          pos: pos
        };
      },

      /**
       * Add the icon for this node of the tree.
       *
       * @param cellInfo {Map} The information about the cell.
       *   See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {Map}
       *   The returned map contains an 'html' member which contains the html for
       *   the icon, and a 'pos' member which is the starting position plus the
       *   width of the icon.
       */
      _addIcon: function _addIcon(cellInfo, pos) {
        var node = cellInfo.value; // Add the node's icon

        var imageUrl = node.bSelected ? node.iconSelected : node.icon;

        if (!imageUrl) {
          if (node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.LEAF) {
            var o = this.__tm.styleFrom("treevirtual-file");
          } else {
            var states = {
              opened: node.bOpened
            };

            var o = this.__tm.styleFrom("treevirtual-folder", states);
          }

          imageUrl = o.icon;
        }

        var rowHeight = cellInfo.table.getRowHeight();

        var html = this._addImage({
          url: imageUrl,
          position: {
            top: 0,
            left: pos,
            width: rowHeight + 3,
            height: rowHeight
          },
          imageWidth: rowHeight,
          imageHeight: rowHeight
        });

        return {
          html: html,
          pos: pos + rowHeight + 3
        };
      },

      /**
       * Add the label for this node of the tree.
       *
       * @param cellInfo {Map} The information about the cell.
       *   See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *   Additionally, if defined, the labelSpanStyle member is used to apply
       *   style to the span containing the label.  (This member is for use by
       *   subclasses; it's not otherwise used by this class.)
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {String}
       *   The html for the label.
       */
      _addLabel: function _addLabel(cellInfo, pos) {
        var node = cellInfo.value;
        var label = node.label;
        {
          if (label && label.translate) {
            label = label.translate();
          }
        } // Add the node's label.  We calculate the "left" property with: each
        // tree line (indentation) icon is 19 pixels wide; the folder icon is 16
        // pixels wide, there are two pixels of padding at the left, and we want
        // 2 pixels between the folder icon and the label

        var html = "<div style=\"position:absolute;left:" + pos + 'px;' + 'top:0;' + (node.labelStyle ? node.labelStyle + ";" : "") + '">' + '<span' + (cellInfo.labelSpanStyle ? 'style="' + cellInfo.labelSpanStyle + ';"' : "") + '>' + label + '</span>' + '</div>';
        return html;
      },

      /**
       * Adds extra content just before the indentation.
       *
       * @param cellInfo {Map} The information about the cell.
       *      See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {Map}
       *   The returned map contains an 'html' member which contains the html for
       *   the indentation, and a 'pos' member which is the starting position
       *   plus the width of the indentation.
       */
      _addExtraContentBeforeIndentation: function _addExtraContentBeforeIndentation(cellInfo, pos) {
        return {
          html: '',
          pos: pos
        };
      },

      /**
       * Adds extra content just before the icon.
       *
       * @param cellInfo {Map} The information about the cell.
       *      See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {Map}
       *   The returned map contains an 'html' member which contains the html for
       *   the indentation, and a 'pos' member which is the starting position
       *   plus the width of the indentation.
       */
      _addExtraContentBeforeIcon: function _addExtraContentBeforeIcon(cellInfo, pos) {
        return {
          html: '',
          pos: pos
        };
      },

      /**
       * Adds extra content just before the label.
       *
       * @param cellInfo {Map} The information about the cell.
       *      See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {Map}
       *   The returned map contains an 'html' member which contains the html for
       *   the indentation, and a 'pos' member which is the starting position
       *   plus the width of the indentation.
       */
      _addExtraContentBeforeLabel: function _addExtraContentBeforeLabel(cellInfo, pos) {
        return {
          html: '',
          pos: pos
        };
      },

      /**
       * Determine the symbol to use for indentation of a tree row, at a
       * particular column.  The indentation to use may be just white space or
       * may be a tree line.  Tree lines come in numerous varieties, so the
       * appropriate one is selected.
       *
       * @param column {Integer}
       *   The column of indentation being requested, zero-relative
       *
       * @param node {Node}
       *   The node being displayed in the row.  The properties of a node are
       *   described in {@link qx.ui.treevirtual.SimpleTreeDataModel}
       *
       * @param bUseTreeLines {Boolean}
       *   Whether to find an appropriate tree line icon, or simply provide
       *   white space.
       *
       * @param bAlwaysShowOpenCloseSymbol {Boolean}
       *   Whether to display the open/close icon for a node even if it has no
       *   children.
       *
       * @param bExcludeFirstLevelTreeLines {Boolean}
       *   If bUseTreeLines is enabled, then further filtering of the left-most
       *   tree line may be specified here.  If <i>true</i> then the left-most
       *   tree line, between top-level siblings, will not be displayed.
       *   If <i>false</i>, then the left-most tree line will be displayed
       *   just like all of the other tree lines.
       *
       * @return {Map} map of image properties.
       */
      _getIndentSymbol: function _getIndentSymbol(column, node, bUseTreeLines, bAlwaysShowOpenCloseSymbol, bExcludeFirstLevelTreeLines) {
        var STDCR = qx.ui.treevirtual.SimpleTreeDataCellRenderer; // If we're in column 0 and excludeFirstLevelTreeLines is enabled, then
        // we treat this as if no tree lines were requested.

        if (column == 0 && bExcludeFirstLevelTreeLines) {
          bUseTreeLines = false;
        } // If we're not on the final column...


        if (column < node.level - 1) {
          // then return either a line or a blank icon, depending on
          // bUseTreeLines
          return bUseTreeLines && !node.lastChild[column] ? STDCR.__icon.line : {
            icon: this.BLANK
          };
        }

        var bLastChild = node.lastChild[node.lastChild.length - 1]; // Is this a branch node that does not have the open/close button hidden?

        if (node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.BRANCH && !node.bHideOpenClose) {
          // Does this node have any children, or do we always want the
          // open/close symbol to be shown?
          if (node.children.length > 0 || bAlwaysShowOpenCloseSymbol) {
            // If we're not showing tree lines...
            if (!bUseTreeLines) {
              // ... then just use an expand or contract
              return node.bOpened ? STDCR.__icon.contract : STDCR.__icon.expand;
            } // Are we looking at a top-level, first child of its parent?


            if (column == 0 && node.bFirstChild) {
              // Yup.  If it's also a last child...
              if (bLastChild) {
                // ... then use no tree lines.
                return node.bOpened ? STDCR.__icon.onlyContract : STDCR.__icon.onlyExpand;
              } else {
                // otherwise, use descender lines but no ascender.
                return node.bOpened ? STDCR.__icon.startContract : STDCR.__icon.startExpand;
              }
            } // It's not a top-level, first child.  Is this the last child of its
            // parent?


            if (bLastChild) {
              // Yup.  Return an ending expand or contract.
              return node.bOpened ? STDCR.__icon.endContract : STDCR.__icon.endExpand;
            } // Otherwise, return a crossing expand or contract.


            return node.bOpened ? STDCR.__icon.crossContract : STDCR.__icon.crossExpand;
          }
        } // This node does not have any children.  Return an end or cross, if
        // we're using tree lines.


        if (bUseTreeLines) {
          // If this is a child of the root node...
          if (node.parentNodeId == 0) {
            // If this is the only child...
            if (bLastChild && node.bFirstChild) {
              // ... then return a blank.
              return {
                icon: this.BLANK
              };
            } // Otherwise, if this is the last child...


            if (bLastChild) {
              // ... then return an end line.
              return STDCR.__icon.end;
            } // Otherwise if this is the first child and is a branch...


            if (node.bFirstChild && node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.BRANCH) {
              // ... then return a start line.
              return node.bOpened ? STDCR.__icon.startContract : STDCR.__icon.startExpand;
            }
          } // If this is a last child, return and ending line; otherwise cross.


          return bLastChild ? STDCR.__icon.end : STDCR.__icon.cross;
        }

        return {
          icon: this.BLANK
        };
      }
    },
    destruct: function destruct() {
      this.__am = this.__rm = this.__tm = null;
    }
  });
  qx.ui.treevirtual.SimpleTreeDataCellRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.rowrenderer.Default": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A data row renderer for a simple tree row
   */
  qx.Class.define("qx.ui.treevirtual.SimpleTreeDataRowRenderer", {
    extend: qx.ui.table.rowrenderer.Default,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.rowrenderer.Default.constructor.call(this);
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      updateDataRowElement: function updateDataRowElement(rowInfo, rowElem) {
        // If the node is selected, select the row
        var tree = rowInfo.table;
        var rowData = rowInfo.rowData;
        var tableModel = tree.getTableModel();
        var treeCol = tableModel.getTreeColumn();
        var node = rowData[treeCol]; // Set the row's selected state based on the data model

        rowInfo.selected = node.bSelected;

        if (node.bSelected) {
          // Ensure that the selection model knows it's selected
          var row = rowInfo.row;

          tree.getSelectionModel()._addSelectionInterval(row, row);
        } // Now call our superclass


        qx.ui.treevirtual.SimpleTreeDataRowRenderer.prototype.updateDataRowElement.base.call(this, rowInfo, rowElem);
      }
    }
  });
  qx.ui.treevirtual.SimpleTreeDataRowRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.event.Timer": {
        "construct": true
      },
      "qx.ui.core.queue.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Behavior to support pre-rendering of invisible areas of a virtual scroller.
   * If applied to a scroller it will start a timer and increase the rendered area
   * of the scroller after a certain period of time. Subsequent scrolling will not
   * have to render this pre-computed area again.
   *
   */
  qx.Class.define("qx.ui.virtual.behavior.Prefetch", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param scroller {qx.ui.virtual.core.Scroller} The scroller to prefetch
     * @param settings {Map} This map contains minimum and maximum pixels to
     * prefetch near the view port.
     * <ul>
     *   <li>minLeft: minimum pixels to prefetch left to the view port</li>
     *   <li>maxLeft: maximum pixels to prefetch left to the view port</li>
     *   <li>minRight: minimum pixels to prefetch right to the view port</li>
     *   <li>maxRight: maximum pixels to prefetch right to the view port</li>
     *   <li>minAbove: minimum pixels to prefetch above the view port</li>
     *   <li>maxAbove: maximum pixels to prefetch above the view port</li>
     *   <li>minBelow: minimum pixels to prefetch below the view port</li>
     *   <li>maxBelow: maximum pixels to prefetch below the view port</li>
     * </ul>
     */
    construct: function construct(scroller, settings) {
      {
        this.assertObject(settings);
        this.assertPositiveInteger(settings.minLeft);
        this.assertPositiveInteger(settings.maxLeft);
        this.assertPositiveInteger(settings.minRight);
        this.assertPositiveInteger(settings.maxRight);
        this.assertPositiveInteger(settings.minAbove);
        this.assertPositiveInteger(settings.maxAbove);
        this.assertPositiveInteger(settings.minBelow);
        this.assertPositiveInteger(settings.maxBelow);
      }
      qx.core.Object.constructor.call(this);
      this.setPrefetchX(settings.minLeft, settings.maxLeft, settings.minRight, settings.maxRight);
      this.setPrefetchY(settings.minAbove, settings.maxAbove, settings.minBelow, settings.maxBelow);
      this.__timer = new qx.event.Timer(this.getInterval());

      this.__timer.addListener("interval", this._onInterval, this);

      if (scroller) {
        this.setScroller(scroller);
      }
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      /** @type {qx.ui.virtual.core.Scroller} The scroller to prefetch */
      scroller: {
        check: "qx.ui.virtual.core.Scroller",
        nullable: true,
        init: null,
        apply: "_applyScroller"
      },

      /** @type {Integer} Polling interval */
      interval: {
        check: "Integer",
        init: 200,
        apply: "_applyInterval"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __prefetchX: null,
      __prefetchY: null,
      __timer: null,
      __onScrollXId: null,
      __onScrollYId: null,

      /**
       * Configure horizontal prefetching
       *
       * @param minLeft {Integer} minimum pixels to prefetch left to the view port
       * @param maxLeft {Integer} maximum pixels to prefetch left to the view port
       * @param minRight {Integer} minimum pixels to prefetch right to the view port
       * @param maxRight {Integer} maximum pixels to prefetch right to the view port
       */
      setPrefetchX: function setPrefetchX(minLeft, maxLeft, minRight, maxRight) {
        this.__prefetchX = [minLeft, maxLeft, minRight, maxRight];
      },

      /**
       * Configure vertical prefetching
       *
       * @param minAbove {Integer} minimum pixels to prefetch above the view port
       * @param maxAbove {Integer} maximum pixels to prefetch above the view port
       * @param minBelow {Integer} minimum pixels to prefetch below the view port
       * @param maxBelow {Integer} maximum pixels to prefetch below the view port
       */
      setPrefetchY: function setPrefetchY(minAbove, maxAbove, minBelow, maxBelow) {
        this.__prefetchY = [minAbove, maxAbove, minBelow, maxBelow];
      },

      /**
       * Update prefetching
       */
      _onInterval: function _onInterval() {
        var px = this.__prefetchX;

        if (px[1] && px[3]) {
          this.getScroller().getPane().prefetchX(px[0], px[1], px[2], px[3]);
          qx.ui.core.queue.Manager.flush();
        }

        var py = this.__prefetchY;

        if (py[1] && py[3]) {
          this.getScroller().getPane().prefetchY(py[0], py[1], py[2], py[3]);
          qx.ui.core.queue.Manager.flush();
        }
      },
      // property apply
      _applyScroller: function _applyScroller(value, old) {
        if (old) {
          if (this.__onScrollXId) {
            old.getChildControl("scrollbar-x").removeListenerById(this.__onScrollXId);
          }

          if (this.__onScrollYId) {
            old.getChildControl("scrollbar-y").removeListenerById(this.__onScrollYId);
          }
        }

        if (value) {
          if (!value.getContentElement().getDomElement()) {
            this.__timer.stop();

            value.addListenerOnce("appear", this.__timer.start, this.__timer);
          } else {
            this.__timer.restart();
          } //        if (value.hasChildControl("scrollbar-x"))
          //        {


          this.__onScrollXId = value.getChildControl("scrollbar-x").addListener("scroll", this.__timer.restart, this.__timer); //        }
          //        if (value.hasChildControl("scrollbar-y"))
          //        {

          this.__onScrollYId = value.getChildControl("scrollbar-y").addListener("scroll", this.__timer.restart, this.__timer); //        }
        } else {
          this.__timer.stop();
        }
      },
      // property apply
      _applyInterval: function _applyInterval(value, old) {
        this.__timer.setInterval(value);
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this.setScroller(null);
      this.__prefetchX = this.__prefetchY = null;

      this._disposeObjects("__timer");
    }
  });
  qx.ui.virtual.behavior.Prefetch.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      },
      "qx.util.ResourceManager": {},
      "qx.io.ImageLoader": {},
      "qx.bom.element.Decoration": {},
      "qx.bom.element.Style": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Abstract base class for image cell renderer.
   */
  qx.Class.define("qx.ui.virtual.cell.AbstractImage", {
    extend: qx.ui.virtual.cell.Cell,
    type: "abstract",

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.virtual.cell.Cell.constructor.call(this);
      this._aliasManager = qx.util.AliasManager.getInstance();
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __defaultWidth: 16,
      __defaultHeight: 16,
      _aliasManager: null,

      /**
       * Compute the size of the given image
       *
       * @param source {String} the image URL
       * @return {Map} A map containing the image's <code>width</code> and
       *    <code>height</code>
       */
      __getImageSize: function __getImageSize(source) {
        var ResourceManager = qx.util.ResourceManager.getInstance();
        var ImageLoader = qx.io.ImageLoader;
        var width, height; // Detect if the image registry knows this image

        if (ResourceManager.has(source)) {
          width = ResourceManager.getImageWidth(source), height = ResourceManager.getImageHeight(source);
        } else if (ImageLoader.isLoaded(source)) {
          width = ImageLoader.getWidth(source);
          height = ImageLoader.getHeight(source);
        } else {
          width = this.__defaultWidth;
          height = this.__defaultHeight;
        }

        return {
          width: width,
          height: height
        };
      },

      /**
       * Compute image meta data
       *
       * @param imageData {Object|String} Either a string containing the image URL
       *   or a map, which describes the image. Map keys:
       *   <ul>
       *     <li>url (required)</li>
       *     <li>width</li>
       *     <li>height</li>
       *     <li>tooltip</li>
       *   </ul>
       * @return {Object} A map describing the image. Map keys:
       *   <ul>
       *     <li>url</li>
       *     <li>width</li>
       *     <li>height</li>
       *     <li>tooltip (optional)</li>
       *   </ul>
       */
      __createImage: function __createImage(imageData) {
        if (typeof imageData == "string") {
          imageData = {
            url: imageData
          };
        }

        var url = this._aliasManager.resolve(imageData.url || null);

        var sizes;

        if (imageData.width && imageData.height) {
          sizes = {
            width: imageData.width,
            height: imageData.height
          };
        } else {
          sizes = this.__getImageSize(url);
        }

        return {
          width: sizes.width,
          height: sizes.height,
          url: url,
          tooltip: imageData.tooltip
        };
      },

      /**
       * Identifies the Image to show. This is a template method, which must be
       * implements by sub classes.
       *
       * @abstract
       * @param value {var} The cell's data value
       * @return {Map} A map having the following attributes:
       *           <ul>
       *           <li>"url": (type string) must be the URL of the image to show.</li>
       *           <li>"width": (type int) the width of the image in pixels.</li>
       *           <li>"height": (type int) the height of the image in pixels.</li>
       *           <li>"tooltip": (type string) must be the image tooltip text.</li>
       *           </ul>
       */
      _identifyImage: function _identifyImage(value) {
        throw new Error("_identifyImage is abstract");
      },
      // overridden
      getContent: function getContent(value, states) {
        if (value === null) {
          return "";
        }

        var content = "";

        var imageData = this.__createImage(this._identifyImage(value));

        var tooltip = imageData.tooltip ? 'title="' + imageData.tooltip + '"' : "";
        var styles = {
          width: imageData.width + "px",
          height: imageData.height + "px",
          display: "inline-block",
          verticalAlign: "top",
          position: "static"
        };
        var tag = qx.bom.element.Decoration.getTagName("no-repeat", imageData.url);
        var ret = qx.bom.element.Decoration.getAttributes(imageData.url, "no-repeat", styles);
        var css = qx.bom.element.Style.compile(ret.style);

        if (tag === "img") {
          content = '<img src="' + ret.src + '" style="' + css + '" ';
          content += tooltip + '/>';
        } else {
          content = '<div style="' + css + '" ';
          content += tooltip + '></div>';
        }

        return content;
      }
    }
  });
  qx.ui.virtual.cell.AbstractImage.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.AbstractImage": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.ui.virtual.cell.Boolean", {
    extend: qx.ui.virtual.cell.AbstractImage,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.virtual.cell.AbstractImage.constructor.call(this);
      this.__aliasManager = qx.util.AliasManager.getInstance();
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "cell-boolean"
      },

      /**
      * The icon used to indicate the true state
      */
      iconTrue: {
        check: "String",
        themeable: true,
        apply: "_applyIconTrue"
      },

      /**
      * The icon used to indicate the false state
      */
      iconFalse: {
        check: "String",
        themeable: true,
        apply: "_applyIconFalse"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __imageTrue: null,
      __imageFalse: null,
      __aliasManager: null,
      // property apply
      _applyIconTrue: function _applyIconTrue(value) {
        this.__imageTrue = this.__aliasManager.resolve(value);
      },
      // property apply
      _applyIconFalse: function _applyIconFalse(value) {
        this.__imageFalse = this.__aliasManager.resolve(value);
      },
      // overridden
      _identifyImage: function _identifyImage(value) {
        return value == true ? this.__imageTrue : this.__imageFalse;
      }
    }
  });
  qx.ui.virtual.cell.Boolean.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {
        "construct": true,
        "require": true
      },
      "qx.util.format.DateFormat": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Date cell renderer.
   *
   * Renders a date according to the configured date formatter.
   *
   */
  qx.Class.define("qx.ui.virtual.cell.Date", {
    extend: qx.ui.virtual.cell.Cell,

    /**
     * @param dateFormat {qx.util.format.DateFormat|null} optional date formatter
     *   to use
     */
    construct: function construct(dateFormat) {
      qx.ui.virtual.cell.Cell.constructor.call(this);

      if (dateFormat) {
        this.setDateFormat(dateFormat);
      } else {
        this.initDateFormat(qx.util.format.DateFormat.getDateTimeInstance());
      }
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "cell-date"
      },

      /** The date format used to render the cell */
      dateFormat: {
        check: "qx.util.format.DateFormat",
        deferredInit: true
      }
    },
    members: {
      // overridden
      getContent: function getContent(value, states) {
        return value ? this.getDateFormat().format(value) : "";
      }
    }
  });
  qx.ui.virtual.cell.Date.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.ui.virtual.cell.Html", {
    extend: qx.ui.virtual.cell.Cell,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "cell-html"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        IMPLEMENT CELL API
      ---------------------------------------------------------------------------
      */
      getContent: function getContent(value, states) {
        return value;
      }
    }
  });
  qx.ui.virtual.cell.Html.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Objects, which are used as delegates for {@link qx.ui.virtual.cell.WidgetCell} may
   * implement any of the methods described in this interface. The delegate does
   * not need implement all of the methods of this interface. If a method is not
   * implemented the {@link qx.ui.virtual.cell.WidgetCell} provides a default implementation.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * really implemented.
   */
  qx.Interface.define("qx.ui.virtual.cell.IWidgetCellDelegate", {
    members: {
      /**
       * Creates a <code>Widget</code> which will be used for rendering.
       *
       * @return {qx.ui.core.LayoutItem} A new created <code>Widget</code>.
       */
      createWidget: function createWidget() {}
    }
  });
  qx.ui.virtual.cell.IWidgetCellDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.AbstractImage": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.ui.virtual.cell.Image", {
    extend: qx.ui.virtual.cell.AbstractImage,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "cell-image"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _identifyImage: function _identifyImage(value) {
        return value;
      }
    }
  });
  qx.ui.virtual.cell.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {
        "construct": true,
        "require": true
      },
      "qx.util.format.NumberFormat": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Number cell renderer.
   *
   * Renders the call using the configured number formatter.
   */
  qx.Class.define("qx.ui.virtual.cell.Number", {
    extend: qx.ui.virtual.cell.Cell,

    /**
     * @param numberFormat {qx.util.format.NumberFormat|null} Optional number
     *   format to use.
     */
    construct: function construct(numberFormat) {
      qx.ui.virtual.cell.Cell.constructor.call(this);

      if (numberFormat) {
        this.setNumberFormat(numberFormat);
      }
    },
    properties: {
      /** The number format used to render the cell */
      numberFormat: {
        check: "qx.util.format.NumberFormat",
        // it is on intension that only one number format is used for
        // all instances
        init: new qx.util.format.NumberFormat()
      },
      // overridden
      appearance: {
        refine: true,
        init: "cell-number"
      }
    },
    members: {
      // overridden
      getContent: function getContent(value, states) {
        return value !== null ? this.getNumberFormat().format(value) : "";
      }
    }
  });
  qx.ui.virtual.cell.Number.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {
        "construct": true,
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.ui.virtual.cell.String", {
    extend: qx.ui.virtual.cell.Cell,
    construct: function construct() {
      qx.ui.virtual.cell.Cell.constructor.call(this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "cell-string"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        IMPLEMENT CELL API
      ---------------------------------------------------------------------------
      */
      getContent: function getContent(value, states) {
        return value ? qx.bom.String.escape(value) : "";
      }
    }
  });
  qx.ui.virtual.cell.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.selection.Abstract": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Cell selection manager
   */
  qx.Class.define("qx.ui.virtual.selection.CellRectangle", {
    extend: qx.ui.virtual.selection.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the number of all items in the pane. This number may contain
       * unselectable items as well.
       *
       * @return {Integer} number of items
       */
      _getItemCount: function _getItemCount() {
        return this._pane.getRowConfig().getItemCount() * this._pane.getColumnConfig().getItemCount();
      },

      /*
      ---------------------------------------------------------------------------
        IMPLEMENT ABSTRACT METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _getSelectableFromPointerEvent: function _getSelectableFromPointerEvent(event) {
        var cell = this._pane.getCellAtPosition(event.getDocumentLeft(), event.getDocumentTop());

        if (!cell) {
          return null;
        }

        return this._isSelectable(cell) ? cell : null;
      },
      // overridden
      getSelectables: function getSelectables(all) {
        var selectables = [];

        var rowCount = this._pane.getRowConfig().getItemCount();

        var columnCount = this._pane.getColumnConfig().getItemCount();

        for (var row = 0; row < rowCount; row++) {
          for (var column = 0; column < columnCount; column++) {
            var cell = {
              row: row,
              column: column
            };

            if (this._isSelectable(cell)) {
              selectables.push(cell);
            }
          }
        }

        return selectables;
      },
      // overridden
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        var selectables = [];
        var minRow = Math.min(item1.row, item2.row);
        var maxRow = Math.max(item1.row, item2.row);
        var minColumn = Math.min(item1.column, item2.column);
        var maxColumn = Math.max(item1.column, item2.column);

        for (var row = minRow; row <= maxRow; row++) {
          for (var column = minColumn; column <= maxColumn; column++) {
            var cell = {
              row: row,
              column: column
            };

            if (this._isSelectable(cell)) {
              selectables.push(cell);
            }
          }
        }

        return selectables;
      },
      // overridden
      _getFirstSelectable: function _getFirstSelectable() {
        var rowCount = this._pane.getRowConfig().getItemCount();

        var columnCount = this._pane.getColumnConfig().getItemCount();

        for (var row = 0; row < rowCount; row++) {
          for (var column = 0; column < columnCount; column++) {
            var cell = {
              row: row,
              column: column
            };

            if (this._isSelectable(cell)) {
              return cell;
            }
          }
        }

        return null;
      },
      // overridden
      _getLastSelectable: function _getLastSelectable() {
        var rowCount = this._pane.getRowConfig().getItemCount();

        var columnCount = this._pane.getColumnConfig().getItemCount();

        for (var column = columnCount - 1; column >= 0; column--) {
          for (var row = rowCount - 1; row >= 0; row--) {
            var cell = {
              row: row,
              column: column
            };

            if (this._isSelectable(cell)) {
              return cell;
            }
          }
        }

        return null;
      },
      // overridden
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        var cell = {
          row: item.row,
          column: item.column
        };

        switch (relation) {
          case "above":
            for (var row = item.row - 1; row >= 0; row--) {
              cell.row = row;

              if (this._isSelectable(cell)) {
                return cell;
              }
            }

            break;

          case "under":
            var rowCount = this._pane.getRowConfig().getItemCount();

            for (var row = item.row + 1; row < rowCount; row++) {
              cell.row = row;

              if (this._isSelectable(cell)) {
                return cell;
              }
            }

            break;

          case "left":
            for (var column = item.column - 1; column >= 0; column--) {
              cell.column = column;

              if (this._isSelectable(cell)) {
                return cell;
              }
            }

            break;

          case "right":
            var columnCount = this._pane.getColumnConfig().getItemCount();

            for (var column = item.column + 1; column < columnCount; column++) {
              cell.column = column;

              if (this._isSelectable(cell)) {
                return cell;
              }
            }

            break;
        }

        return null;
      },
      // overridden
      _getPage: function _getPage(lead, up) {
        if (up) {
          return this._getFirstSelectable();
        } else {
          return this._getLastSelectable();
        }
      },
      // overridden
      _selectableToHashCode: function _selectableToHashCode(item) {
        return item.column + "x" + item.row;
      },
      // overridden
      _scrollItemIntoView: function _scrollItemIntoView(item) {
        if (this._autoScrollIntoView) {
          this._pane.scrollCellIntoView(item.column, item.row);
        }
      },
      // overridden
      _getSelectableLocationX: function _getSelectableLocationX(item) {
        var columnConfig = this._pane.getColumnConfig();

        var itemLeft = columnConfig.getItemPosition(item.column);
        var itemRight = itemLeft + columnConfig.getItemSize(item.column) - 1;
        return {
          left: itemLeft,
          right: itemRight
        };
      },
      // overridden
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        var rowConfig = this._pane.getRowConfig();

        var itemTop = rowConfig.getItemPosition(item.row);
        var itemBottom = itemTop + rowConfig.getItemSize(item.row) - 1;
        return {
          top: itemTop,
          bottom: itemBottom
        };
      }
    }
  });
  qx.ui.virtual.selection.CellRectangle.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.selection.CellRectangle": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Cell selection manager
   */
  qx.Class.define("qx.ui.virtual.selection.CellLines", {
    extend: qx.ui.virtual.selection.CellRectangle,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        IMPLEMENT ABSTRACT METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        var selectables = [];

        var columnCount = this._pane.getColumnConfig().getItemCount();

        if (item1.row < item2.row || item1.row == item2.row && item1.column < item2.column) {
          var start = item1.row * columnCount + item1.column;
          var end = item2.row * columnCount + item2.column;
        } else {
          var start = item2.row * columnCount + item2.column;
          var end = item1.row * columnCount + item1.column;
        }

        for (var i = start; i <= end; i++) {
          var cell = {
            row: Math.floor(i / columnCount),
            column: i % columnCount
          };

          if (this._isSelectable(cell)) {
            selectables.push(cell);
          }
        }

        return selectables;
      }
    }
  });
  qx.ui.virtual.selection.CellLines.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.selection.Row": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Column selection manager
   */
  qx.Class.define("qx.ui.virtual.selection.Column", {
    extend: qx.ui.virtual.selection.Row,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the number of all items in the pane. This number may contain
       * unselectable items as well.
       *
       * @return {Integer} number of items
       */
      _getItemCount: function _getItemCount() {
        return this._pane.getColumnConfig().getItemCount();
      },

      /*
      ---------------------------------------------------------------------------
        IMPLEMENT ABSTRACT METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _getSelectableFromPointerEvent: function _getSelectableFromPointerEvent(event) {
        var cell = this._pane.getCellAtPosition(event.getDocumentLeft(), event.getDocumentTop());

        if (!cell) {
          return null;
        }

        return this._isSelectable(cell.column) ? cell.column : null;
      },
      // overridden
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        if (relation == "left") {
          var startIndex = item - 1;
          var endIndex = 0;
          var increment = -1;
        } else if (relation == "right") {
          var startIndex = item + 1;
          var endIndex = this._getItemCount() - 1;
          var increment = 1;
        } else {
          return null;
        }

        for (var i = startIndex; i !== endIndex + increment; i += increment) {
          if (this._isSelectable(i)) {
            return i;
          }
        }

        return null;
      },
      // overridden
      _scrollItemIntoView: function _scrollItemIntoView(item) {
        if (this._autoScrollIntoView) {
          this._pane.scrollColumnIntoView(item);
        }
      },
      // overridden
      _getSelectableLocationX: function _getSelectableLocationX(item) {
        var columnConfig = this._pane.getColumnConfig();

        var itemLeft = columnConfig.getItemPosition(item);
        var itemRight = itemLeft + columnConfig.getItemSize(item) - 1;
        return {
          left: itemLeft,
          right: itemRight
        };
      },
      // overridden
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        return {
          top: 0,
          bottom: this._pane.getRowConfig().getTotalSize() - 1
        };
      }
    }
  });
  qx.ui.virtual.selection.Column.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Objects, which are used as delegates for a virtual selection manager may
   * implement any of the methods described in this interface. The delegate does
   * not need implement all of the methods of this interface. If a method is not
   * implemented the selection manager provides a default implementation.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * really implemented.
   */
  qx.Interface.define("qx.ui.virtual.selection.ISelectionDelegate", {
    members: {
      /**
       * Returns whether the given item is selectable. The type of the item
       * depends on the concrete selection manager implementation. The
       * {@link Row} and {@link Column} selection manager use row/column indexes
       * as items. The {@link qx.ui.virtual.cell.Cell} uses cells as items. Cells are represented by
       * a map containing <code>row</code> and <code>column</code> keys.
       *
       * If this method is not implemented by the delegate all items are selectable.
       *
       * @param item {var} The item to be checked
       * @return {Boolean} Whether the given item is selectable
       */
      isItemSelectable: function isItemSelectable(item) {},

      /**
       * Update the style (appearance) of the given item.
       *
       * @param item {var} Item to modify
       * @param type {String} Any of <code>selected</code>, <code>anchor</code>
       *    or <code>lead</code>
       * @param wasAdded {Boolean} Whether the given style should be added or removed.
       */
      styleSelectable: function styleSelectable(item, type, wasAdded) {}
    }
  });
  qx.ui.virtual.selection.ISelectionDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Dataset": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.util.String": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.event.Native": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "construct": true,
        "defer": "runtime",
        "require": true
      },
      "qx.core.IDisposable": {
        "require": true
      },
      "qx.core.Wrapper": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * This is the base collection for all widgets and offers a good foundation
   * for all widgets including enabled state handling, config and template storage
   * and event handling to name a few key features.
   *
   * @require(qx.module.Dataset)
   * @require(qx.module.util.String)
   * @require(qx.module.event.Native)
   *
   * @group (Widget)
   */
  qx.Bootstrap.define("qx.ui.website.Widget", {
    extend: qxWeb,
    implement: [qx.core.IDisposable],
    statics: {
      /**
       * Factory method for the widget which converts a standard
       * collection into a collection of widgets.
       *
       * @return {qx.ui.website.Widget} A widget.
       *
       * @attach {qxWeb}
       */
      widget: function widget() {
        var widget = new qx.ui.website.Widget(this);
        widget.init();
        return widget;
      },

      /**
       * Creates a new collection from the given argument. This can either be an
       * HTML string, a single DOM element or an array of elements
       *
       * @param html {String|Element[]} HTML string or DOM element(s)
       * @return {qxWeb} Collection of elements
       */
      create: function create(html) {
        return new qx.ui.website.Widget(qxWeb.create(html));
      },

      /**
       * Fetches elements with a data attribute named <code>data-qx-class</code>
       * containing the class name of the desired widget and initializes them as
       * widgets.
       *
       * @param selector {String?} Optional selector expression or filter function to
       * restrict the list of elements
       * @attachStatic {qxWeb}
       */
      initWidgets: function initWidgets(selector) {
        var elements = qxWeb("*[data-qx-class]");

        if (selector) {
          elements = elements.filter(selector);
        }

        elements._forEachElementWrapped(function (widget) {
          widget.init();
        });
      },

      /**
       * Returns a wrapper Array that maps the widget API available on
       * the first item in the current collection to all items in the
       * collection.
       *
       * @attach {qxWeb}
       * @return {qxWeb[]} Collection of widgets
       */
      toWidgetCollection: function toWidgetCollection() {
        var args = this.toArray().map(function (el) {
          return qxWeb(el);
        }); // Set the context for the 'bind' call (will be replaced by new)

        Array.prototype.unshift.call(args, null); // Create temporary constructor with bound arguments

        var Temp = qx.core.Wrapper.bind.apply(qx.core.Wrapper, args);
        return new Temp();
      }
    },
    construct: function construct(selector, context) {
      var col = qxWeb.constructor.call(this, selector, context);

      if (col.length > 1) {
        throw new Error("The collection must not contain more than one element.");
      }

      Array.prototype.push.apply(this, Array.prototype.slice.call(col, 0, col.length));
    },
    members: {
      __cssPrefix: null,

      /**
       * Responsible for initializing of the widget. This checks for the data attribute
       * named <code>data-qx-class</code> and initializes the widget if necessary.
       * @return {Boolean} <code>true</code> if the widget has been initialized
       */
      init: function init() {
        if (this.getProperty("$$qx-widget-initialized")) {
          return false;
        }

        this.setAttribute("data-qx-class", this.classname);
        this.addClass("qx-widget");
        this.addClass(this.getCssPrefix());
        this.setProperty("$$qx-widget-initialized", true);

        if (this[0]) {
          this[0].$widget = this;
        }

        return true;
      },

      /**
       * Return the proper CSS prefix for the current widget. This prefix is
       * based on the current classname.
       *
       * @return {String} The CSS prefix for the current object.
       */
      getCssPrefix: function getCssPrefix() {
        if (!this.__cssPrefix) {
          var split = this.classname.split(".");
          this.__cssPrefix = "qx-" + split[split.length - 1].toLowerCase();
        }

        return this.__cssPrefix;
      },

      /**
       * Changes the enabled state of the current collection, which means all
       * widgets in the collection. This sets the disabled attribute on the
       * elements and all its children.
       *
       * @param value {Boolean} The enabled value.
       * @return {qx.ui.website.Widget} The collection for chaining
       */
      setEnabled: function setEnabled(value) {
        this.setAttribute("disabled", !value);
        this.find("*").setAttribute("disabled", !value);
        return this;
      },

      /**
       * Returns weather the first widget in the collection is enabled or not.
       *
       * @return {Boolean} The enabled state of the collection.
       */
      getEnabled: function getEnabled() {
        return !this.getAttribute("disabled");
      },

      /**
       * Setter for the widget-specific templates. The available templates can
       * be found in the documentation of the corresponding widget. The templates
       * will be rendered using
       * <a href='https://github.com/janl/mustache.js/'>mustache.js</a>.
       *
       * Please keep in mind to call {@link #render} after you change any
       * template or config setting.
       *
       * @param name {String} The name of the template.
       * @param template {String} The template string.
       *
       * @return {qx.ui.website.Widget} The widget instance for chaining.
       */
      setTemplate: function setTemplate(name, template) {
        return this._setData("templates", name, template);
      },

      /**
       * Setter for the widget-specific config. The available config settings can
       * be found in the documentation of the corresponding widget. Each config
       * setting can be set in the markup as data-attribute, prefixed with
       * <code>data-qx</code> e.g. <code>data-qx-length="5"</code>.
       *
       * Please keep in mind to call {@link #render} after you change any
       * template or config setting.
       *
       * @param name {String} The name of the config setting.
       * @param config {var} The value of the config setting.
       * @return {qx.ui.website.Widget} The widget instance for chaining.
       */
      setConfig: function setConfig(name, config) {
        return this._setData("config", name, config);
      },

      /**
       * Helper to set either config or template values.
       *
       * @param type {String} Either <code>templates</code> or <code>config</code>.
       * @param name {String} The name for the value to store.
       * @param data {var} The data to store.
       * @return {qx.ui.website.Widget} The widget instance for chaining.
       */
      _setData: function _setData(type, name, data) {
        if (!this["$$storage_" + type]) {
          this["$$storage_" + type] = {};
        }

        this["$$storage_" + type][name] = data;
        return this;
      },

      /**
       * Returns the used template. This includes custom templates
       * as the default templates defined by the widgets.
       *
       * @param name {String} The name of the template.
       * @return {String} The template string or <code>undefined</code>.
       */
      getTemplate: function getTemplate(name) {
        return this._getData("templates", name);
      },

      /**
       * Returns the config setting currently in use for the given widget.
       * This can either be the user set config value, the value set in
       * the markup via data-attribute, the widgets default config value or
       * <code>undefined</code>, if non is set.
       *
       * @param name {String} The name of the config.
       * @return {var} The value of the config or <code>undefined</code>.
       */
      getConfig: function getConfig(name) {
        return this._getData("config", name);
      },

      /**
       * Internal helper for querying the values for templates and configs. In the
       * case of a config value, the method also reads the corresponding data-attribute
       * for possible values.
       *
       * @param type {String} Either <code>templates</code> or <code>config</code>.
       * @param name {String} The name for the value to fetch.
       * @return {var} The value store for the given arguments.
       */
      _getData: function _getData(type, name) {
        var storage = this["$$storage_" + type];
        var item;

        if (storage) {
          item = storage[name];
        }

        if (item === undefined && type == "config") {
          var attribName = "qx" + qxWeb.string.firstUp(type) + qxWeb.string.firstUp(name);
          item = this.getData(attribName); // not defined HTML attributes result in 'null' values

          if (!this[0] || !this[0].dataset && item === null) {
            item = undefined;
          }

          try {
            item = JSON.parse(item);
          } catch (e) {}
        }

        if (item === undefined && this.constructor["_" + type]) {
          return this.constructor["_" + type][name];
        }

        return item;
      },

      /**
       * The render method is responsible for applying changed config
       * and template settings. This method is usually overridden and specified
       * by the subclassing widgets like the slider or tabs.
       *
       * @return {qx.ui.website.Widget} The widget collection for chaining.
       */
      render: function render() {
        // empty method
        return this;
      },

      /**
       * Dispose the widget, making sure all objects are ready for
       * garbage collection. This mainly means deleting connections to the
       * DOM including event listeners.
       * @return {qxWeb} Plain qxWeb collection
       */
      dispose: function dispose() {
        this.removeAttribute("data-qx-class");
        this.setProperty("config", undefined);
        this.setProperty("templates", undefined);
        var contextProperty = this.classname.replace(/\./g, "-") + "-context";
        this.setProperty(contextProperty, undefined);
        this.setProperty("$$qx-widget-initialized", undefined);
        this.removeClass("qx-widget");
        this.removeClass(this.getCssPrefix());

        for (var name in this.constructor.$$events) {
          this.allOff(name);
        }

        this[0].$widget = null;
        return qxWeb.$init(this, qxWeb);
      }
    },
    defer: function defer(statics) {
      qxWeb.$attach({
        widget: statics.widget,
        toWidgetCollection: statics.toWidgetCollection
      });
      qxWeb.$attachStatic({
        initWidgets: statics.initWidgets
      });
    }
  });
  qx.ui.website.Widget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Template": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.website.Widget": {
        "construct": true,
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      },
      "q": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * A row of buttons used to switch between connected pages. The buttons can be
   * right- or left-aligned, or they can be justified, i.e. they will be stretched
   * to fill the available width.
   *
   * <h2>Markup</h2>
   * Each Tabs widget contains an unordered list element (<code>ul</code>), which
   * will be created if not already present.
   * The tabs are list items (<code>li</code>). Each tab can contain
   * a button with a <code>tabsPage</code> data attribute where the value is a
   * CSS selector string identifying the corresponding page. Headers and pages
   * will not be created automatically. They can be predefined in the DOM before
   * the <code>q().tabs()</code> factory method is called, or added programmatically.
   *
   * <h2>CSS Classes</h2>
   * <table>
   *   <thead>
   *     <tr>
   *       <td>Class Name</td>
   *       <td>Applied to</td>
   *       <td>Description</td>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><code>qx-tabs</code></td>
   *       <td>Container element</td>
   *       <td>Identifies the Tabs widget</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-horizontal</code></td>
   *       <td>Container element</td>
   *       <td>Styles the widget in horizontal orientation</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-vertical</code></td>
   *       <td>Container element</td>
   *       <td>Styles the widget in vertical orientation</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-container</code></td>
   *       <td>Tab page container (<code>div</code>)</td>
   *       <td>Styles the tab pages' container (horizontal orientation only)</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-flex-justify-end</code></td>
   *       <td>Tab container (<code>ul</code>)</td>
   *       <td>Browsers with flexbox support only: Styles the tab buttons when they are right-aligned</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-left</code></td>
   *       <td>Container element</td>
   *       <td>Internet Explorer < 10 only: Styles the tab buttons when they are left-aligned</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-justify</code></td>
   *       <td>Container element</td>
   *       <td>Internet Explorer < 10 only: Styles the tab buttons when they are stretched to fill out the available width</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-right</code></td>
   *       <td>Container element</td>
   *       <td>Internet Explorer < 10 only: Styles the tab buttons when they are right-aligned</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-button</code></td>
   *       <td>Tab button (<code>li</code>)</td>
   *       <td>Identifies and styles the tabs</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-button-active</code></td>
   *       <td>Tab button (<code>li</code>)</td>
   *       <td>Identifies and styles the currently selected tab. Applied in addition to <code>qx-tabs-button</code></td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-flex-1</code></td>
   *       <td>Tab button (<code>li</code>)</td>
   *       <td>Browsers with flexbox support only: Styles the tab buttons when they are stretched to fill out the available width</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-page</code></td>
   *       <td>Tab page (<code>div</code> in horizontal mode, <code>li</code>)</td>
   *       <td>Styles the tab pages.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <h2 class="widget-markup">Generated DOM Structure</h2>
   *
   * @require(qx.module.Template)
   *
   * @group (Widget)
   */
  qx.Bootstrap.define("qx.ui.website.Tabs", {
    extend: qx.ui.website.Widget,
    statics: {
      /**
       * Factory method which converts the current collection into a collection of
       * tabs widgets.
       *
       * @attach{qxWeb}
       * @param align {String?} Tab button alignment. Default: <code>left</code>
       * @param preselected {Integer?} The (zero-based) index of the tab that
       * should initially be selected. Default: <code>0</code>
       * @param orientation {String?} <code>horizontal</code> (default) or <code>vertical</code>
       * @return {qx.ui.website.Tabs}
       */
      tabs: function tabs(align, preselected, orientation) {
        var tabs = new qx.ui.website.Tabs(this);

        if (typeof preselected !== "undefined") {
          tabs.setConfig("preselected", preselected);
        }

        tabs.init();

        if (align) {
          tabs.setConfig("align", align);
        }

        if (orientation) {
          tabs.setConfig("orientation", orientation);
        }

        if (align || orientation) {
          tabs.render();
        }

        return tabs;
      },

      /**
       * *button*
       *
       * Template used by {@link #addButton} to create a new button.
       *
       * Default value: <pre><li><button>{{{content}}}</button></li></pre>
       */
      _templates: {
        button: "<li><button>{{{content}}}</button></li>"
      },

      /**
       * *preselected*
       * The index of the page that should be opened after initial
       * rendering, or <code>null</code> if no page should be opened.
       *
       * Default value: <pre>0</pre>
       *
       * *align*
       * Configuration for the alignment of the tab buttons in horizontal
       * mode. This possible values are <code>left</code>,
       * <code>justify</code> and
       * <code>right</code>
       *
       * Default value: <pre>left</pre>
       *
       * *orientation*
       * Controls the layout of the widget. "horizontal" renders it as a
       * tab bar appropriate for wide screens. "vertical" renders it as a
       * stack of collapsible panes (sometimes called an accordion) that
       * is better suited for narrow screens.
       *
       * *mediaQuery*
       * A CSS media query string that will be used with a
       * media query listener to dynamically set the widget's
       * orientation. The widget will be rendered in vertical mode unless
       * the query matches.
       */
      _config: {
        preselected: 0,
        align: "left",
        orientation: "horizontal",
        mediaQuery: null
      }
    },
    construct: function construct(selector, context) {
      qx.ui.website.Widget.constructor.call(this, selector, context);
    },
    events: {
      /**
       * Fired when the selected page has changed. The value is
       * the newly selected page's index
       */
      "changeSelected": "Number"
    },
    members: {
      __mediaQueryListener: null,
      init: function init() {
        if (!qx.ui.website.Tabs.prototype.init.base.call(this)) {
          return false;
        }

        var mediaQuery = this.getConfig("mediaQuery");

        if (mediaQuery) {
          this.setConfig("orientation", this._initMediaQueryListener(mediaQuery));
        }

        var orientation = this.getConfig("orientation");
        this.addClasses([this.getCssPrefix(), this.getCssPrefix() + "-" + orientation, "qx-flex-ready"]);

        if (this.getChildren("ul").length === 0) {
          var list = qxWeb.create("<ul/>");
          var content = this.getChildren();

          if (content.length > 0) {
            list.insertBefore(content.eq(0));
          } else {
            this.append(list);
          }
        }

        var container = this.find("> ." + this.getCssPrefix() + "-container");
        var buttons = this.getChildren("ul").getFirst().getChildren("li").not("." + this.getCssPrefix() + "-page");

        buttons._forEachElementWrapped(function (button) {
          button.addClass(this.getCssPrefix() + "-button");
          var pageSelector = button.getData(this.getCssPrefix() + "-page");

          if (!pageSelector) {
            return;
          }

          button.addClass(this.getCssPrefix() + "-button").on("tap", this._onTap, this);

          var page = this._getPage(button);

          if (page.length > 0) {
            page.addClass(this.getCssPrefix() + "-page");

            if (orientation == "vertical") {
              this.__deactivateTransition(page);

              if (q.getNodeName(page[0]) == "div") {
                var li = q.create("<li>").addClass(this.getCssPrefix() + "-page").setAttribute("id", page.getAttribute("id")).insertAfter(button[0]);
                page.remove().getChildren().appendTo(li);
                page = li;
              }

              this._storePageHeight(page);
            } else if (orientation == "horizontal") {
              if (q.getNodeName(page[0]) == "li") {
                var div = q.create("<div>").addClass(this.getCssPrefix() + "-page").setAttribute("id", page.getAttribute("id"));
                page.remove().getChildren().appendTo(div);
                page = div;
              }
            }

            if (orientation == "horizontal") {
              if (container.length === 0) {
                container = qxWeb.create("<div class='" + this.getCssPrefix() + "-container'>").insertAfter(this.find("> ul")[0]);
              }

              page.appendTo(container[0]);
            }
          }

          this._showPage(null, button);

          this.__activateTransition(page);
        }.bind(this));

        if (orientation == "vertical" && container.length == 1 && container.getChildren().length === 0) {
          container.remove();
        }

        if (orientation == "horizontal" && this.getConfig("align") == "right" && q.env.get("engine.name") == "mshtml" && q.env.get("browser.documentmode") < 10) {
          buttons.remove();

          for (var i = buttons.length - 1; i >= 0; i--) {
            this.find("> ul").append(buttons[i]);
          }
        }

        var active = buttons.filter("." + this.getCssPrefix() + "-button-active");
        var preselected = this.getConfig("preselected");

        if (active.length === 0 && typeof preselected == "number") {
          active = buttons.eq(preselected).addClass(this.getCssPrefix() + "-button-active");
        }

        if (active.length > 0) {
          var activePage = this._getPage(active);

          this.__deactivateTransition(activePage);

          this._showPage(active, null);

          this.__activateTransition(activePage);
        }

        this.getChildren("ul").getFirst().on("keydown", this._onKeyDown, this);

        if (orientation === "horizontal") {
          this._applyAlignment(this);
        }

        qxWeb(window).on("resize", this._onResize, this);
        return true;
      },
      render: function render() {
        var mediaQuery = this.getConfig("mediaQuery");

        if (mediaQuery) {
          this.setConfig("orientation", this._initMediaQueryListener(mediaQuery));
        }

        var orientation = this.getConfig("orientation");

        if (orientation === "horizontal") {
          return this._renderHorizontal();
        } else if (orientation === "vertical") {
          return this._renderVertical();
        }
      },

      /**
       * Initiates a media query listener for dynamic orientation switching
       * @param mediaQuery {String} CSS media query string
       * @return {String} The appropriate orientation: "horizontal" if the
       * media query matches, "vertical" if it doesn't
       */
      _initMediaQueryListener: function _initMediaQueryListener(mediaQuery) {
        var mql = this.__mediaQueryListener;

        if (!mql) {
          mql = q.matchMedia(mediaQuery);
          this.__mediaQueryListener = mql;
          mql.on("change", function (query) {
            this.render();
          }.bind(this));
        }

        if (mql.matches) {
          return "horizontal";
        } else {
          return "vertical";
        }
      },

      /**
       * Render the widget in horizontal mode
       * @return {qx.ui.website.Tabs} The collection for chaining
       */
      _renderHorizontal: function _renderHorizontal() {
        this.removeClass(this.getCssPrefix() + "-vertical").addClasses([this.getCssPrefix() + "", this.getCssPrefix() + "-horizontal"]).find("> ul").addClass("qx-hbox");
        var container = this.find("> ." + this.getCssPrefix() + "-container");

        if (container.length == 0) {
          container = qxWeb.create("<div class='" + this.getCssPrefix() + "-container'>").insertAfter(this.find("> ul")[0]);
        }

        var selectedPage;

        this.find("> ul > ." + this.getCssPrefix() + "-button")._forEachElementWrapped(function (li) {
          var page = this.find(li.getData(this.getCssPrefix() + "-page"));

          if (q.getNodeName(page[0]) == "li") {
            var div = q.create("<div>").addClass(this.getCssPrefix() + "-page").setAttribute("id", page.getAttribute("id"));
            page.remove().getChildren().appendTo(div);
            page = div;
          }

          page.appendTo(container[0]);

          this._switchPages(page, null);

          if (li.hasClass(this.getCssPrefix() + "-button-active")) {
            selectedPage = page;
          }
        }.bind(this));

        if (!selectedPage) {
          var firstButton = this.find("> ul > ." + this.getCssPrefix() + "-button").eq(0).addClass(this.getCssPrefix() + "-button-active");
          selectedPage = this._getPage(firstButton);
        }

        this._switchPages(null, selectedPage);

        this._applyAlignment(this);

        this.setEnabled(this.getEnabled());
        return this;
      },

      /**
       * Render the widget in vertical mode
       * @return {qx.ui.website.Tabs} The collection for chaining
       */
      _renderVertical: function _renderVertical() {
        this.find("> ul.qx-hbox").removeClass("qx-hbox");

        this.removeClasses([this.getCssPrefix() + "-horizontal"]).addClasses([this.getCssPrefix() + "", this.getCssPrefix() + "-vertical"]).getChildren("ul").getFirst().getChildren("li").not("." + this.getCssPrefix() + "-page")._forEachElementWrapped(function (button) {
          button.addClass(this.getCssPrefix() + "-button");

          var page = this._getPage(button);

          if (page.length === 0) {
            return;
          }

          this.__deactivateTransition(page);

          if (q.getNodeName(page[0]) == "div") {
            var li = q.create("<li>").addClass(this.getCssPrefix() + "-page").setAttribute("id", page.getAttribute("id"));
            page.getChildren().appendTo(li);
            li.insertAfter(button[0]);
            page.remove();
            page = li;
          }

          this._storePageHeight(page);

          if (button.hasClass(this.getCssPrefix() + "-button-active")) {
            this._switchPages(null, page);
          } else {
            this._switchPages(page, null);
          }

          this.__activateTransition(page);
        }.bind(this));

        this.setEnabled(this.getEnabled());
        return this;
      },

      /**
       * Re-render on browser window resize (page heights must be re-
       * calculated)
       */
      _onResize: function _onResize() {
        // make sure this runs after a MediaQueryListener callback
        // which might have changed the orientation
        setTimeout(function () {
          if (this.getConfig("orientation") == "vertical") {
            this._renderVertical();
          }
        }.bind(this), 100);
      },

      /**
       * Adds a new tab button
       *
       * @param label {String} The button's content. Can include markup.
       * @param pageSelector {String} CSS Selector that identifies the associated page
       * @return {qx.ui.website.Tabs} The collection for chaining
       */
      addButton: function addButton(label, pageSelector) {
        var link = qxWeb.create(qxWeb.template.render(this.getTemplate("button"), {
          content: label
        })).addClass(this.getCssPrefix() + "-button");
        var list = this.find("> ul");
        var links = list.getChildren("li");

        if (list.hasClass(this.getCssPrefix() + "-right") && links.length > 0) {
          link.insertBefore(links.getFirst());
        } else {
          link.appendTo(list);
        }

        link.on("tap", this._onTap, this).addClass(this.getCssPrefix() + "-button");

        if (this.find("> ul ." + this.getCssPrefix() + "-button").length === 1) {
          link.addClass(this.getCssPrefix() + "-button-active");
        }

        if (pageSelector) {
          link.setData(this.getCssPrefix() + "-page", pageSelector);

          var page = this._getPage(link);

          page.addClass(this.getCssPrefix() + "-page");

          if (link.hasClass(this.getCssPrefix() + "-button-active")) {
            this._switchPages(null, page);
          } else {
            this._switchPages(page, null);
          }
        }

        return this;
      },

      /**
       * Selects a tab button
       *
       * @param index {Integer} index of the button to select
       * @return {qx.ui.website.Tabs} The collection for chaining
       */
      select: function select(index) {
        var buttons = this.find("> ul > ." + this.getCssPrefix() + "-button");
        var oldButton = this.find("> ul > ." + this.getCssPrefix() + "-button-active").removeClass(this.getCssPrefix() + "-button-active");

        if (this.getConfig("align") == "right") {
          index = buttons.length - 1 - index;
        }

        var newButton = buttons.eq(index).addClass(this.getCssPrefix() + "-button-active");

        this._showPage(newButton, oldButton);

        this.emit("changeSelected", index);
        return this;
      },

      /**
       * Initiates the page switch when a button was clicked/tapped
       *
       * @param e {Event} Tap event
       */
      _onTap: function _onTap(e) {
        if (!this.getEnabled()) {
          return;
        }

        var orientation = this.getConfig("orientation");
        var tappedButton = e.getCurrentTarget();
        var oldButton = this.find("> ul > ." + this.getCssPrefix() + "-button-active");

        if (oldButton[0] == tappedButton && orientation == "horizontal") {
          return;
        }

        oldButton.removeClass(this.getCssPrefix() + "-button-active");

        if (orientation == "vertical") {
          this._showPage(null, oldButton);

          if (oldButton[0] == tappedButton && orientation == "vertical") {
            return;
          }
        }

        var newButton;

        var buttons = this.find("> ul > ." + this.getCssPrefix() + "-button")._forEachElementWrapped(function (button) {
          if (tappedButton === button[0]) {
            newButton = button;
          }
        });

        this._showPage(newButton, oldButton);

        newButton.addClass(this.getCssPrefix() + "-button-active");
        var index = buttons.indexOf(newButton[0]);

        if (this.getConfig("align") == "right") {
          index = buttons.length - 1 - index;
        }

        this.emit("changeSelected", index);
      },

      /**
       * Allows tab selection using the left and right arrow keys
       *
       * @param e {Event} keydown event
       */
      _onKeyDown: function _onKeyDown(e) {
        var key = e.getKeyIdentifier();

        if (!(key == "Left" || key == "Right")) {
          return;
        }

        var rightAligned = this.getConfig("align") == "right";
        var buttons = this.find("> ul > ." + this.getCssPrefix() + "-button");

        if (rightAligned) {
          buttons.reverse();
        }

        var active = this.find("> ul > ." + this.getCssPrefix() + "-button-active");
        var next;

        if (key == "Right") {
          if (!rightAligned) {
            next = active.getNext("." + this.getCssPrefix() + "-button");
          } else {
            next = active.getPrev("." + this.getCssPrefix() + "-button");
          }
        } else {
          if (!rightAligned) {
            next = active.getPrev("." + this.getCssPrefix() + "-button");
          } else {
            next = active.getNext("." + this.getCssPrefix() + "-button");
          }
        }

        if (next.length > 0) {
          var idx = buttons.indexOf(next);
          this.select(idx);
          next.getChildren("button").focus();
        }
      },

      /**
       * Initiates the page switch if a tab button is selected
       *
       * @param newButton {qxWeb} selected button
       * @param oldButton {qxWeb} previously active button
       */
      _showPage: function _showPage(newButton, oldButton) {
        var oldPage = this._getPage(oldButton);

        var newPage = this._getPage(newButton);

        if (this.getConfig("orientation") === "horizontal" && oldPage[0] == newPage[0]) {
          return;
        }

        this._switchPages(oldPage, newPage);
      },

      /**
       * Executes a page switch
       *
       * @param oldPage {qxWeb} the previously selected page
       * @param newPage {qxWeb} the newly selected page
       */
      _switchPages: function _switchPages(oldPage, newPage) {
        var orientation = this.getConfig("orientation");

        if (orientation === "horizontal") {
          if (oldPage) {
            oldPage.hide();
          }

          if (newPage) {
            newPage.show();
          }
        } else if (orientation === "vertical") {
          if (oldPage && oldPage.length > 0) {
            oldPage.setStyle("height", oldPage.getHeight() + "px");
            oldPage[0].offsetHeight;
            oldPage.setStyles({
              "height": "0px",
              "paddingTop": "0px",
              "paddingBottom": "0px"
            });
            oldPage.addClass(this.getCssPrefix() + "-page-closed");
          }

          if (newPage && newPage.length > 0) {
            newPage.removeClass(this.getCssPrefix() + "-page-closed");

            if (!newPage.getStyle("transition") || newPage.getStyle("transition").indexOf("none") === 0) {
              newPage.setStyle("height", "");
            } else {
              var openedHeight = newPage.getProperty("openedHeight");

              if (qxWeb.type.get(openedHeight) == "String") {
                newPage.setStyle("height", openedHeight);
              }
            }
          }
        }
      },

      /**
       * Returns the tab page associated with the given button
       *
       * @param button {qxWeb} Tab button
       * @return {qxWeb} Tab page
       */
      _getPage: function _getPage(button) {
        var pageSelector;

        if (button) {
          pageSelector = button.getData(this.getCssPrefix() + "-page");
        }

        return this.find(pageSelector);
      },

      /**
       * Apply the CSS classes for the alignment
       *
       * @param tabs {qx.ui.website.Tabs[]} tabs collection
       */
      _applyAlignment: function _applyAlignment(tabs) {
        var align = tabs.getConfig("align");
        var buttons = tabs.find("> ul > li");

        if (q.env.get("engine.name") == "mshtml" && q.env.get("browser.documentmode") < 10) {
          if (align == "left") {
            tabs.addClass(this.getCssPrefix() + "-left");
          } else {
            tabs.removeClass(this.getCssPrefix() + "-left");
          }

          if (align == "justify") {
            tabs.addClass(this.getCssPrefix() + "-justify");
          } else {
            tabs.removeClass(this.getCssPrefix() + "-justify");
          }

          if (align == "right") {
            tabs.addClass(this.getCssPrefix() + "-right");
          } else {
            tabs.removeClass(this.getCssPrefix() + "-right");
          }
        } else {
          tabs.find("> ul").addClass("qx-hbox");

          if (align == "justify") {
            buttons.addClass("qx-flex1");
          } else {
            buttons.removeClass("qx-flex1");
          }

          if (align == "right") {
            tabs.find("> ul").addClass("qx-flex-justify-end");
          } else {
            tabs.find("> ul").removeClass("qx-flex-justify-end");
          }
        }
      },

      /**
       * Stores the page's natural height for the page opening transition
       * @param page {qxWeb} page
       */
      _storePageHeight: function _storePageHeight(page) {
        var closedClass = this.getCssPrefix() + "-page-closed";
        var isClosed = page.hasClass(closedClass);

        if (isClosed) {
          page.removeClass(this.getCssPrefix() + "-page-closed");
        }

        var prevDisplay = page[0].style.display;
        var prevHeight = page[0].style.height;
        page[0].style.height = "";
        page[0].style.display = "block";
        page.setProperty("openedHeight", page.getHeight() + "px");

        if (isClosed) {
          page.addClass(this.getCssPrefix() + "-page-closed");
        }

        page[0].style.height = prevHeight;
        page[0].style.display = prevDisplay;
      },

      /**
       * Stores an element's CSS transition styles in a property
       * and removes them from the style declaration
       *
       * @param elem {qxWeb} Element
       */
      __deactivateTransition: function __deactivateTransition(elem) {
        var transition = elem.getStyles(["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"]);

        if (transition.transitionProperty.indexOf("none") == -1) {
          elem.setProperty("__qxtransition", transition);
          elem.setStyle("transition", "none");
        }
      },

      /**
       * Restores an element's transition styles
       *
       * @param elem {qxWeb} Element
       */
      __activateTransition: function __activateTransition(elem) {
        var transition = elem.getProperty("__qxtransition");
        var style = elem.getStyle("transitionProperty");

        if (transition && style.indexOf("none") != -1) {
          elem.setStyles(transition);
          elem.setProperty("__qxtransition", "");
        }
      },
      dispose: function dispose() {
        this.__mediaQueryListener = undefined;
        var cssPrefix = this.getCssPrefix();
        qxWeb(window).off("resize", this._onResize, this);
        this.find("> ul > ." + this.getCssPrefix() + "-button").off("tap", this._onTap, this);
        this.getChildren("ul").getFirst().off("keydown", this._onKeyDown, this).setHtml("");
        this.setHtml("").removeClasses([cssPrefix, "qx-flex-ready"]);
        return qx.ui.website.Tabs.prototype.dispose.base.call(this);
      }
    },
    defer: function defer(statics) {
      qxWeb.$attach({
        tabs: statics.tabs
      });
    }
  });
  qx.ui.website.Tabs.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.util.Object": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.website.Tabs": {
        "construct": true,
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * The Accordion is a group of vertically stacked panels (here called pages),
   * each with a header.
   * By default, only one page is visible while the others are collapsed.
   * Clicking or tapping a collapsed page's header will expand it while collapsing the
   * previously expanded page.
   *
   * <h2>Markup</h2>
   * The Accordion contains an unordered list element (<code>ul</code>), which
   * will be created if not already present.
   * Headers and pages are list items (<code>li</code>). Each header must contain
   * a button with an <code>accordionPage</code> data attribute where the value is a
   * CSS selector string identifying the corresponding page. Headers and pages
   * will not be created automatically. They can be predefined in the DOM before
   * the <code>q().accordion()</code> factory method is called, or added programmatically.
   *
   * <h2>CSS Classes</h2>
   * <table>
   *   <thead>
   *     <tr>
   *       <td>Class Name</td>
   *       <td>Applied to</td>
   *       <td>Description</td>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><code>qx-accordion</code></td>
   *       <td>Container element</td>
   *       <td>Identifies the Accordion widget</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-accordion-button</code></td>
   *       <td>Page header (<code>li</code>)</td>
   *       <td>Identifies and styles the page headers</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-accordion-button-active</code></td>
   *       <td>Page header (<code>li</code>)</td>
   *       <td>Identifies and styles the header of the currently expanded page. Applied in addition to <code>qx-accordion-button</code></td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-accordion-page</code></td>
   *       <td>Page (<code>li</code>)</td>
   *       <td>Identifies and styles the pages</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <h2 class="widget-markup">Generated DOM Structure</h2>
   *
   * @require(qx.module.util.Object)
   *
   * @group (Widget)
   */
  qx.Bootstrap.define("qx.ui.website.Accordion", {
    extend: qx.ui.website.Tabs,
    statics: {
      /**
       * *button*
       *
       * Template used by {@link qx.ui.website.Tabs#addButton} to create a new button.
       *
       * Default value: <pre><li><button>{{{content}}}</button></li></pre>
       */
      _templates: {
        button: "<li><button>{{{content}}}</button></li>"
      },

      /**
       * Factory method which converts the current collection into a collection of
       * accordion widgets.
       *
       * @param preselected {Integer?} The (zero-based) index of the panel that
       * should initially be opened
       * @return {qx.ui.website.Accordion} A new Accordion collection.
       * @attach {qxWeb}
       */
      accordion: function accordion(preselected) {
        var accordion = new qx.ui.website.Accordion(this);
        accordion.setConfig("orientation", "vertical");

        if (preselected) {
          accordion.setConfig("preselected", preselected);
        }

        accordion.init();
        return accordion;
      }
    },
    construct: function construct(selector, context) {
      qx.ui.website.Tabs.constructor.call(this, selector, context);
    },
    defer: function defer(statics) {
      qxWeb.$attach({
        accordion: statics.accordion
      });
    }
  });
  qx.ui.website.Accordion.$$dbClassInfo = $$dbClassInfo;
})();
//# sourceMappingURL=package-9.js.map?dt=1589218301570
qx.$$packageData['9'] = {
  "locales": {},
  "resources": {},
  "translations": {
    "en": {}
  }
};
