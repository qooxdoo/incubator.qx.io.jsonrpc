(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.core.IDisposable": {
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      },
      "qx.bom.rest.Resource": {},
      "qx.event.type.Rest": {},
      "qx.io.request.Xhr": {},
      "qx.lang.Function": {},
      "qx.event.Timer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /**
   * Client-side wrapper of a REST resource.
   *
   * Each instance represents a resource in terms of REST. A number of actions
   * (usually HTTP methods) unique to the resource can be defined and invoked.
   * A resource with its actions is configured declaratively by passing a resource
   * description to the constructor, or programmatically using {@link #map}.
   *
   * Each action is associated to a route. A route is a combination of method,
   * URL pattern and optional parameter constraints.
   *
   * An action is invoked by calling a method with the same name. When a URL
   * pattern of a route contains positional parameters, those parameters must be
   * passed when invoking the associated action. Also, constraints defined in the
   * route must be satisfied.
   *
   * When an action is invoked, a request is configured according to the associated
   * route, is passed the URL parameters, request body data, and finally send.
   * What kind of request is send can be configured by overwriting {@link #_getRequest}.
   *
   * No constraints on the action's name or the scope of the URLs are imposed. However,
   * if you want to follow RESTful design patterns it is recommended to name actions
   * the same as the HTTP action.
   *
   * <pre class="javascript">
   * var description = {
   *  "get": { method: "GET", url: "/photo/{id}" },
   *  "put": { method: "PUT", url: "/photo/{id}"},
   *  "post": { method: "POST", url: "/photos/"}
   * };
   * var photo = new qx.io.rest.Resource(description);
   * // Can also be written: photo.invoke("get", {id: 1});
   * photo.get({id: 1});
   *
   * // Additionally sets request data (provide it as string or set the content type)
   * // In a RESTful environment this creates a new resource with the given 'id'
   * photo.configureRequest(function(req) {
   *  req.setRequestHeader("Content-Type", "application/json");
   * });
   * photo.put({id: 1}, {title: "Monkey"});
   *
   * // Additionally sets request data (provide it as string or set the content type)
   * // In a RESTful environment this adds a new resource to the resource collection 'photos'
   * photo.configureRequest(function(req) {
   *  req.setRequestHeader("Content-Type", "application/json");
   * });
   * photo.post(null, {title: "Monkey"});
   * </pre>
   *
   * To check for existence of URL parameters or constrain them to a certain format, you
   * can add a <code>check</code> property to the description. See {@link #map} for details.
   *
   * <pre class="javascript">
   * var description = {
   *  "get": { method: "GET", url: "/photo/{id}", check: { id: /\d+/ } }
   * };
   * var photo = new qx.io.rest.Resource(description);
   * // photo.get({id: "FAIL"});
   * // -- Error: "Parameter 'id' is invalid"
   * </pre>
   *
   * If your description happens to use the same action more than once, consider
   * defining another resource.
   *
   * <pre class="javascript">
   * var description = {
   *  "get": { method: "GET", url: "/photos"},
   * };
   * // Distinguish "photo" (singular) and "photos" (plural) resource
   * var photos = new qx.io.rest.Resource(description);
   * photos.get();
   * </pre>
   *
   * Basically, all routes of a resource should point to the same URL (resource in
   * terms of HTTP). One acceptable exception of this constraint are resources where
   * required parameters are part of the URL (<code>/photos/1/</code>) or filter
   * resources. For instance:
   *
   * <pre class="javascript">
   * var description = {
   *  "get": { method: "GET", url: "/photos/{tag}" }
   * };
   * var photos = new qx.io.rest.Resource(description);
   * photos.get();
   * photos.get({tag: "wildlife"})
   * </pre>
   *
   * Strictly speaking, the <code>photos</code> instance represents two distinct resources
   * and could therefore just as well mapped to two distinct resources (for instance,
   * named photos and photosTagged). What style to choose depends on the kind of data
   * returned. For instance, it seems sensible to stick with one resource if the filter
   * only limits the result set (i.e. the individual results have the same properties).
   *
   * In order to respond to successful (or erroneous) invocations of actions,
   * either listen to the generic "success" or "error" event and get the action
   * from the event data, or listen to action specific events defined at runtime.
   * Action specific events follow the pattern "&lt;action&gt;Success" and
   * "&lt;action&gt;Error", e.g. "indexSuccess".
   * 
   * NOTE: Instances of this class must be disposed of after use
   *
   */
  qx.Class.define("qx.io.rest.Resource", {
    extend: qx.core.Object,
    implement: [qx.core.IDisposable],

    /**
     * @param description {Map?} Each key of the map is interpreted as
     *  <code>action</code> name. The value associated to the key must be a map
     *  with the properties <code>method</code> and <code>url</code>.
     *  <code>check</code> is optional. Also see {@link #map}.
     *
     * For example:
     *
     * <pre class="javascript">
     * { get: {method: "GET", url: "/photos/{id}", check: { id: /\d+/ }} }
     * </pre>
     *
     * @see qx.bom.rest
     * @see qx.io.rest
     */
    construct: function construct(description) {
      qx.core.Object.constructor.call(this);
      this.__longPollHandlers__P_174_0 = {};
      this.__pollTimers__P_174_1 = {};
      this.__routes__P_174_2 = {};
      this._resource = this._tailorResource(this._getResource());

      try {
        if (typeof description !== "undefined") {
          {
            qx.core.Assert.assertMap(description);
          }

          this.__mapFromDescription__P_174_3(description);
        }
      } catch (e) {
        this.dispose();
        throw e;
      }
    },
    events: {
      /**
       * Fired when any request was successful.
       *
       * The action the successful request is associated to, as well as the
       * request itself, can be retrieved from the event’s properties.
       * Additionally, an action specific event is fired that follows the pattern
       * "<action>Success", e.g. "indexSuccess".
       */
      "success": "qx.event.type.Rest",

      /**
       * Fired when request associated to action given in prefix was successful.
       *
       * For example, "indexSuccess" is fired when <code>index()</code> was
       * successful.
       */
      "actionSuccess": "qx.event.type.Rest",

      /**
       * Fired when any request fails.
       *
       * The action the failed request is associated to, as well as the
       * request itself, can be retrieved from the event’s properties.
       * Additionally, an action specific event is fired that follows the pattern
       * "<action>Error", e.g. "indexError".
       */
      "error": "qx.event.type.Rest",

      /**
       * Fired when any request associated to action given in prefix fails.
       *
       * For example, "indexError" is fired when <code>index()</code> failed.
       */
      "actionError": "qx.event.type.Rest"
    },
    statics: {
      /**
       * Number of milliseconds below a long-poll request is considered immediate and
       * subject to throttling checks.
       */
      POLL_THROTTLE_LIMIT: 100,

      /**
       * Number of immediate long-poll responses accepted before throttling takes place.
       */
      POLL_THROTTLE_COUNT: 30,

      /**
       * A symbol used in checks to declare required parameter.
       */
      REQUIRED: true,

      /**
       * Get placeholders from URL.
       *
       * @param url {String} The URL to parse for placeholders.
       * @return {Array} Array of placeholders without the placeholder prefix.
       */
      placeholdersFromUrl: function placeholdersFromUrl(url) {
        return qx.bom.rest.Resource.placeholdersFromUrl(url);
      }
    },
    members: {
      _resource: null,
      __longPollHandlers__P_174_0: null,
      __pollTimers__P_174_1: null,
      __routes__P_174_2: null,

      /**
       * Get resource.
       *
       * May be overridden to change type of resource.
       * @param description {Map?} See construct.
       * @return {qx.bom.rest.Resource} Resource implementation which does the heavy lifting.
       */
      _getResource: function _getResource(description) {
        return new qx.bom.rest.Resource(description);
      },

      /**
       * Tailors (apply dependency injection) the given resource to fit our needs.
       *
       * @param resource {qx.bom.rest.Resource} Resource.
       * @return {qx.bom.rest.Resource} Tailored resource.
       */
      _tailorResource: function _tailorResource(resource) {
        // inject different request implementation
        resource.setRequestFactory(this._getRequest); // inject different request handling

        resource.setRequestHandler({
          onsuccess: {
            callback: function callback(req, action) {
              return function () {
                var props = [req.getResponse(), null, false, req, action, req.getPhase()];
                this.fireEvent(action + "Success", qx.event.type.Rest, props);
                this.fireEvent("success", qx.event.type.Rest, props);
              };
            },
            context: this
          },
          onfail: {
            callback: function callback(req, action) {
              return function () {
                var props = [req.getResponse(), null, false, req, action, req.getPhase()];
                this.fireEvent(action + "Error", qx.event.type.Rest, props);
                this.fireEvent("error", qx.event.type.Rest, props);
              };
            },
            context: this
          },
          onloadend: {
            callback: function callback(req, action) {
              return function () {
                req.dispose();
              };
            },
            context: this
          }
        });
        return resource;
      },
      //
      // Request
      //

      /**
       * Configure request.
       *
       * @param callback {Function} Function called before request is send.
       *   Receives request, action, params and data.
       *
       * <pre class="javascript">
       * res.configureRequest(function(req, action, params, data) {
       *   if (action === "index") {
       *     req.setAccept("application/json");
       *   }
       * });
       * </pre>
       */
      configureRequest: function configureRequest(callback) {
        this._resource.configureRequest(callback);
      },

      /**
       * Get request.
       *
       * May be overridden to change type of request.
       * @return {qx.io.request.Xhr} Xhr object
       */
      _getRequest: function _getRequest() {
        return new qx.io.request.Xhr();
      },
      //
      // Routes and actions
      //

      /**
       * Map action to combination of method and URL pattern.
       *
       * <pre class="javascript">
       *   res.map("get", "GET", "/photos/{id}", {id: /\d+/});
       *
       *   // GET /photos/123
       *   res.get({id: "123"});
       * </pre>
       *
       * @param action {String} Action to associate to request.
       * @param method {String} Method to configure request with.
       * @param url {String} URL to configure request with. May contain positional
       *   parameters (<code>{param}</code>) that are replaced by values given when the action
       *   is invoked. Parameters are optional, unless a check is defined. A default
       *   value can be provided (<code>{param=default}</code>).
       * @param check {Map?} Map defining parameter constraints, where the key is
       *   the URL parameter and the value a regular expression (to match string) or
       *   <code>qx.io.rest.Resource.REQUIRED</code> (to verify existence).
       */
      map: function map(action, method, url, check) {
        // add dynamic methods also on ourself to allow 'invoke()' delegation
        this.__addAction__P_174_4(action, method, url, check);

        this._resource.map(action, method, url, check);
      },

      /**
       * Map actions to members.
       *
       * @param action {String} Action to associate to request.
       * @param method {String} Method to configure request with.
       * @param url {String} URL to configure request with. May contain positional
       *   parameters (<code>{param}</code>) that are replaced by values given when the action
       *   is invoked. Parameters are optional, unless a check is defined. A default
       *   value can be provided (<code>{param=default}</code>).
       * @param check {Map?} Map defining parameter constraints, where the key is
       *   the URL parameter and the value a regular expression (to match string) or
       *   <code>qx.io.rest.Resource.REQUIRED</code> (to verify existence).
       */
      __addAction__P_174_4: function __addAction__P_174_4(action, method, url, check) {
        this.__routes__P_174_2[action] = [method, url, check]; // Undefine generic getter when action is named "get"

        if (action == "get") {
          this[action] = undefined;
        } // Do not overwrite existing "non-action" methods unless the method is
        // null (i.e. because it exists as a stub for documentation)


        if (typeof this[action] !== "undefined" && this[action] !== null && this[action].action !== true) {
          throw new Error("Method with name of action (" + action + ") already exists");
        }

        this.__declareEvent__P_174_5(action + "Success");

        this.__declareEvent__P_174_5(action + "Error");

        this[action] = qx.lang.Function.bind(function () {
          Array.prototype.unshift.call(arguments, action);
          return this.invoke.apply(this, arguments);
        }, this); // Method is safe to overwrite

        this[action].action = true;
      },

      /**
       * Invoke action with parameters.
       *
       * Internally called by actions dynamically created.
       *
       * May be overridden to customize action and parameter handling.
       *
       * @lint ignoreUnused(successHandler, failHandler, loadEndHandler)
       *
       * @param action {String} Action to invoke.
       * @param params {Map} Map of parameters inserted into URL when a matching
       *  positional parameter is found.
       * @param data {Map|String} Data to be send as part of the request.
       *  See {@link qx.io.request.AbstractRequest#requestData}.
       * @return {Number} Id of the action's invocation.
       */
      invoke: function invoke(action, params, data) {
        var params = params == null ? {} : params; // Cache parameters

        this.__routes__P_174_2[action].params = params;
        return this._resource.invoke(action, params, data);
      },

      /**
       * Set base URL.
       *
       * The base URL is prepended to the URLs given in the description.
       * Changes affect all future invocations.
       *
       * @param baseUrl {String} Base URL.
       */
      setBaseUrl: function setBaseUrl(baseUrl) {
        this._resource.setBaseUrl(baseUrl);
      },

      /**
       * Abort action.
       *
       * Example:
       *
       * <pre class="javascript">
       *   // Abort all invocations of action
       *   res.get({id: 1});
       *   res.get({id: 2});
       *   res.abort("get");
       *
       *   // Abort specific invocation of action (by id)
       *   var actionId = res.get({id: 1});
       *   res.abort(actionId);
       * </pre>
       *
       * @param varargs {String|Number} Action of which all invocations to abort
       *  (when string), or a single invocation of an action to abort (when number)
       */
      abort: function abort(varargs) {
        this._resource.abort(varargs);
      },

      /**
       * Resend request associated to action.
       *
       * Replays parameters given when action was invoked originally.
       *
       * @param action {String} Action to refresh.
       */
      refresh: function refresh(action) {
        this._resource.refresh(action);
      },

      /**
       * Periodically invoke action.
       *
       * Replays parameters given when action was invoked originally. When the
       * action was not yet invoked and requires parameters, parameters must be
       * given.
       *
       * Please note that IE tends to cache overly aggressive. One work-around is
       * to disable caching on the client side by configuring the request with
       * <code>setCache(false)</code>. If you control the server, a better
       * work-around is to include appropriate headers to explicitly control
       * caching. This way you still avoid requests that can be correctly answered
       * from cache (e.g. when nothing has changed since the last poll). Please
       * refer to <a href="http://www.mnot.net/javascript/xmlhttprequest/cache.html">
       * XMLHttpRequest Caching Test</a> for available options.
       *
       * @lint ignoreUnused(intervalListener)
       *
       * @param action {String} Action to poll.
       * @param interval {Number} Interval in ms.
       * @param params {Map?} Map of parameters. See {@link #invoke}.
       * @param immediately {Boolean?false} <code>true</code>, if the poll should
       *   invoke a call immediately.
       * @return {qx.event.Timer} Timer that periodically invokes action. Use to
       *   stop or resume. Is automatically disposed on disposal of object.
       */
      poll: function poll(action, interval, params, immediately) {
        // Dispose timer previously created for action
        if (this.__pollTimers__P_174_1[action]) {
          this.__pollTimers__P_174_1[action].dispose();
        } // Fallback to previous params


        if (typeof params == "undefined") {
          params = this.__routes__P_174_2[action].params;
        } // Invoke immediately


        if (immediately) {
          this.invoke(action, params);
        }

        var intervalListener = function intervalListener() {
          var reqs = this.getRequestsByAction(action),
              req = reqs ? reqs[0] : null;

          if (!immediately && !req) {
            this.invoke(action, params);
            return;
          }

          if (req && (req.isDone() || req.isDisposed())) {
            this.refresh(action);
          }
        };

        var timer = this.__pollTimers__P_174_1[action] = new qx.event.Timer(interval);
        timer.addListener("interval", intervalListener, this._resource);
        timer.start();
        return timer;
      },

      /**
       * Long-poll action.
       *
       * Use Ajax long-polling to continuously fetch a resource as soon as the
       * server signals new data. The server determines when new data is available,
       * while the client keeps open a request. Requires configuration on the
       * server side. Basically, the server must not close a connection until
       * new data is available. For a high level introduction to long-polling,
       * refer to <a href="http://en.wikipedia.org/wiki/Comet_(programming)#Ajax_with_long_polling">
       * Ajax with long polling</a>.
       *
       * Uses {@link #refresh} internally. Make sure you understand the
       * implications of IE's tendency to cache overly aggressive.
       *
       * Note no interval is given on the client side.
       *
       * @lint ignoreUnused(longPollHandler)
       *
       * @param action {String} Action to poll.
       * @return {String} Id of handler responsible for long-polling. To stop
       *  polling, remove handler using {@link qx.core.Object#removeListenerById}.
       */
      longPoll: function longPoll(action) {
        var res = this,
            lastResponse,
            // Keep track of last response
        immediateResponseCount = 0; // Count immediate responses
        // Throttle to prevent high load on server and client

        function throttle() {
          var isImmediateResponse = lastResponse && new Date() - lastResponse < res._getThrottleLimit();

          if (isImmediateResponse) {
            immediateResponseCount += 1;

            if (immediateResponseCount > res._getThrottleCount()) {
              {
                res.debug("Received successful response more than " + res._getThrottleCount() + " times subsequently, each within " + res._getThrottleLimit() + " ms. Throttling.");
              }
              return true;
            }
          } // Reset counter on delayed response


          if (!isImmediateResponse) {
            immediateResponseCount = 0;
          }

          return false;
        }

        var handlerId = this.__longPollHandlers__P_174_0[action] = this.addListener(action + "Success", function longPollHandler() {
          if (res.isDisposed()) {
            return;
          }

          if (!throttle()) {
            lastResponse = new Date();
            res.refresh(action);
          }
        });
        this.invoke(action);
        return handlerId;
      },

      /**
       * Get request configuration for action and parameters.
       *
       * This is were placeholders are replaced with parameters.
       *
       * @param action {String} Action associated to request.
       * @param params {Map} Parameters to embed in request.
       * @return {Map} Map of configuration settings. Has the properties
       *   <code>method</code>, <code>url</code> and <code>check</code>.
       */
      _getRequestConfig: function _getRequestConfig(action, params) {
        return this._resource._getRequestConfig(action, params);
      },

      /**
       * Override to adjust the throttle limit.
       * @return {Integer} Throttle limit in milliseconds
       */
      _getThrottleLimit: function _getThrottleLimit() {
        return qx.io.rest.Resource.POLL_THROTTLE_LIMIT;
      },

      /**
       * Override to adjust the throttle count.
       * @return {Integer} Throttle count
       */
      _getThrottleCount: function _getThrottleCount() {
        return qx.io.rest.Resource.POLL_THROTTLE_COUNT;
      },

      /**
       * Map actions from description.
       *
       * Allows to decoratively define routes.
       *
       * @param description {Map} Map that defines the routes.
       */
      __mapFromDescription__P_174_3: function __mapFromDescription__P_174_3(description) {
        Object.keys(description).forEach(function (action) {
          var route = description[action],
              method = route.method,
              url = route.url,
              check = route.check;
          {
            qx.core.Assert.assertString(method, "Method must be string for route '" + action + "'");
            qx.core.Assert.assertString(url, "URL must be string for route '" + action + "'");
          }
          this.map(action, method, url, check);
        }, this);
      },

      /**
       * Declare event at runtime.
       *
       * @param type {String} Type of event.
       */
      __declareEvent__P_174_5: function __declareEvent__P_174_5(type) {
        if (!this.constructor.$$events) {
          this.constructor.$$events = {};
        }

        if (!this.constructor.$$events[type]) {
          this.constructor.$$events[type] = "qx.event.type.Rest";
        }
      }
    },

    /**
     * Destructs the Resource.
     *
     * All created requests, routes and pollTimers will be disposed.
     */
    destruct: function destruct() {
      var action;

      if (this.__pollTimers__P_174_1) {
        for (action in this.__pollTimers__P_174_1) {
          var timer = this.__pollTimers__P_174_1[action];
          timer.stop();
          timer.dispose();
        }
      }

      if (this.__longPollHandlers__P_174_0) {
        for (action in this.__longPollHandlers__P_174_0) {
          var id = this.__longPollHandlers__P_174_0[action];
          this.removeListenerById(id);
        }
      }

      this._resource.destruct();

      this._resource = this.__routes__P_174_2 = this.__pollTimers__P_174_1 = this.__longPollHandlers__P_174_0 = null;
    }
  });
  qx.io.rest.Resource.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * Abstract class for JSON-RPC transports
   *
   * For the moment, any special configuration of the transport, such as
   * authentication, must be done on the level of the underlying implementation,
   * an abstract API will be added later.
   */
  qx.Class.define("qx.io.transport.AbstractTransport", {
    extend: qx.core.Object,
    type: "abstract",
    properties: {
      /**
       * The uri of the endpoint
       */
      endpoint: {
        check: "String",
        event: "changeEndpoint"
      }
    },
    events: {
      /**
       * Event fired when a message is received from the endpoint. Event data
       * is an UTF-8 encoded string
       */
      "message": "qx.event.type.Data"
    },

    /**
     * Constructor
     * @param {String} endpoint
     */
    construct(endpoint) {
      qx.core.Object.constructor.call(this);
      this.setEndpoint(endpoint);
    }

  });
  qx.io.transport.AbstractTransport.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.io.transport.AbstractTransport": {
        "construct": true,
        "require": true
      },
      "qx.io.transport.ITransport": {
        "require": true
      },
      "qx.core.Assert": {},
      "qx.io.exception.Transport": {},
      "qx.io.graphql.Client": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * The implementation of a HTTP Transport using the Fetch API,
   * See https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch
   */
  qx.Class.define("qx.io.transport.Fetch", {
    extend: qx.io.transport.AbstractTransport,
    implement: [qx.io.transport.ITransport],

    /**
     * Constructor.
     *
     * @param {String} url The URL of the http endpoint
     */
    construct(url) {
      qx.io.transport.AbstractTransport.constructor.call(this, url);
    },

    members: {
      __tranportImpl__P_176_0: null,

      /**
       * Returns the object which implements the transport on the
       * underlying level, so that transport-specific configuration
       * can be done on it. In the case of the Fetch API, the
       * "implementation" is a configuration object which will be
       * passed to the `fetch` method as second parameter.
       *
       * @return {qx.core.Object}
       */
      getTransportImpl() {
        this.__tranportImpl__P_176_0 = this.__tranportImpl__P_176_0 || this._createTransportImpl();
        return this.__tranportImpl__P_176_0;
      },

      /**
       * Transport the given message to the endpoint
       *
       * @param {String} message
       *
       * @return {qx.Promise} Promise that resolves (with no data)
       * when the message has been successfully sent out, and rejects
       * when there is an error or a cancellation up to that point.
       * @ignore(fetch)
       */
      async send(message) {
        qx.core.Assert.assertString(message);
        let init = this.getTransportImpl();
        init.body = message;
        let response;

        try {
          response = await fetch(this.getEndpoint(), init);
        } catch (e) {
          throw new qx.io.exception.Transport(e.message, e.code);
        }

        if (!response.ok) {
          switch (response.status) {
            case 400:
              // "400 Bad Request" is a really a protocol error (syntax error)
              break;

            default:
              throw new qx.io.exception.Transport(response.statusText, response.status);
          }
        }

        let responseData = await response.text(); // notify listeners

        this.fireDataEvent("message", responseData);
      },

      /**
       * Factory method to create a request object. In this implementation,
       * it returns an object that will be used as the `init` parameter of the
       * fetch method.
       * @return {Object}
       */
      _createTransportImpl() {
        let init = {};
        init.headers = {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        };
        init.method = "POST";
        return init;
      }

    },

    defer() {
      qx.io.graphql.Client.registerTransport(/^http/, qx.io.transport.Fetch);
    }

  });
  qx.io.transport.Fetch.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.io.transport.AbstractTransport": {
        "construct": true,
        "require": true
      },
      "qx.io.transport.ITransport": {
        "require": true
      },
      "qx.core.Assert": {},
      "qx.type.BaseError": {},
      "qx.io.exception.Transport": {},
      "qx.io.exception.Cancel": {},
      "qx.io.request.Xhr": {},
      "qx.io.jsonrpc.Client": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * The implementation of a HTTP Transport using the {@link qx.io.request} API,
   * so any special configuration of the HTTP request must be done on the
   * underlying implementation of {@link qx.io.request.AbstractRequest}.
   *
   * More abstract support for authentication will be added later.
   *
   */
  qx.Class.define("qx.io.transport.Xhr", {
    extend: qx.io.transport.AbstractTransport,
    implement: qx.io.transport.ITransport,

    /**
     * Constructor.
     *
     * @param {String} url The URL of the http endpoint
     */
    construct(url) {
      qx.io.transport.AbstractTransport.constructor.call(this, url);
    },

    members: {
      /**
       * Internal implementation of the transport
       * @var {qx.io.request.Xhr}
       */
      __tranportImpl__P_177_0: null,

      /**
       * Returns the object which implements the transport on the
       * underlying level, so that transport-specific configuration
       * can be done on it. Note that since in the HTTP transport,
       * this object cannot be reused, it will return a new object
       * each time which will be used in the immediately next request.
       *
       * @return {qx.core.Object}
       */
      getTransportImpl() {
        this.__tranportImpl__P_177_0 = this._createTransportImpl();
        return this.__tranportImpl__P_177_0;
      },

      /**
       * Transport the given message to the endpoint
       *
       * @param {String} message
       *
       * @return {qx.Promise} Promise that resolves (with no data)
       * when the message has been successfully sent out, and rejects
       * when there is an error or a cancellation up to that point.
       */
      async send(message) {
        qx.core.Assert.assertString(message);
        const req = this.__tranportImpl__P_177_0 || this.getTransportImpl();
        req.setRequestData(message);
        this.__tranportImpl__P_177_0 = null; // free the internal reference for the next request

        try {
          await req.sendWithPromise();
        } catch (e) {
          if (e instanceof qx.type.BaseError) {
            switch (e.getComment()) {
              case "timeout":
                throw new qx.io.exception.Transport(e.toString(), qx.io.exception.Transport.TIMEOUT, {
                  message
                });

              case "parseError":
                throw new qx.io.exception.Transport(e.toString(), qx.io.exception.Transport.INVALID_MSG_DATA, {
                  message
                });

              case "abort":
                throw new qx.io.exception.Cancel(e.toString(), {
                  message
                });

              case "statusError":
              case "error":
                throw new qx.io.exception.Transport(e.toString(), qx.io.exception.Transport.FAILED, {
                  message
                });
            }
          }
        } // notify listeners


        this.fireDataEvent("message", req.getResponse()); // discard old object

        req.dispose();
      },

      /**
       * Factory method to create a request object. By default, a POST
       * request will be made, and the expected response type will be
       * "application/json", but differently to the standard behavior,
       * the response will not be parsed into a javascript object.
       *
       * Classes extending this one may override this method to obtain
       * a Request object with different parameters and/or different
       * authentication settings. The object must be a subclass of {@link
       * qx.io.request.AbstractRequest} or implement its public API.
       *
       * @return {qx.io.jsonrpc.Request}
       */
      _createTransportImpl() {
        const req = new qx.io.request.Xhr(this.getEndpoint(), "POST");
        req.setAccept("application/json");
        req.setCache(false);
        req.setRequestHeader("content-type", "application/json"); // disable parsing, we are going to parse the JSON ourselves

        req.setParser(response => response);
        return req;
      }

    },

    defer() {
      qx.io.jsonrpc.Client.registerTransport(/^http/, qx.io.transport.Xhr);
    }

  });
  qx.io.transport.Xhr.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.locale.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Provides information about locale-dependent number formatting (like the decimal
   * separator).
   *
   * @cldr()
   */
  qx.Class.define("qx.locale.Number", {
    statics: {
      /**
       * Get decimal separator for number formatting
       *
       * @param locale {String} optional locale to be used
       * @return {String} decimal separator.
       */
      getDecimalSeparator: function getDecimalSeparator(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_number_decimal_separator", [], locale);
      },

      /**
       * Get thousand grouping separator for number formatting
       *
       * @param locale {String} optional locale to be used
       * @return {String} group separator.
       */
      getGroupSeparator: function getGroupSeparator(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_number_group_separator", [], locale);
      },

      /**
       * Get percent format string
       *
       * @param locale {String} optional locale to be used
       * @return {String} percent format string.
       */
      getPercentFormat: function getPercentFormat(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_number_percent_format", [], locale);
      }
    }
  });
  qx.locale.Number.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.locale.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Provides information about locale-dependent string formatting (like quotation
   * signs).
   *
   * @cldr()
   */
  qx.Class.define("qx.locale.String", {
    statics: {
      /**
       * Get quotation start sign
       *
       * @param locale {String} optional locale to be used
       * @return {String} quotation start sign
       */
      getQuotationStart: function getQuotationStart(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_quotationStart", [], locale);
      },

      /**
       * Get quotation end sign
       *
       * @param locale {String} optional locale to be used
       * @return {String} quotation end sign
       */
      getQuotationEnd: function getQuotationEnd(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_quotationEnd", [], locale);
      },

      /**
       * Get quotation alternative start sign
       *
       * @param locale {String} optional locale to be used
       * @return {String} alternative quotation start sign
       */
      getAlternateQuotationStart: function getAlternateQuotationStart(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_alternateQuotationStart", [], locale);
      },

      /**
       * Get quotation alternative end sign
       *
       * @param locale {String} optional locale to be used
       * @return {String} alternative quotation end sign
       */
      getAlternateQuotationEnd: function getAlternateQuotationEnd(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_alternateQuotationEnd", [], locale);
      }
    }
  });
  qx.locale.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.bom.Stylesheet": {
        "construct": true
      },
      "qx.log.Logger": {
        "construct": true
      },
      "qx.bom.element.Class": {},
      "qx.log.appender.Formatter": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * This appender is used to log to an existing DOM element
   */
  qx.Class.define("qx.log.appender.Element", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param element {Element} DOM element to use for log output.
     */
    construct: function construct(element) {
      qx.core.Object.constructor.call(this);
      var style = ['.qxappender .level-debug{background:white}', '.qxappender .level-info{background:#DEEDFA}', '.qxappender .level-warn{background:#FFF7D5}', '.qxappender .level-error{background:#FFE2D5}', '.qxappender .level-user{background:#E3EFE9}', '.qxappender .type-string{color:black;font-weight:normal;}', '.qxappender .type-number{color:#155791;font-weight:normal;}', '.qxappender .type-boolean{color:#15BC91;font-weight:normal;}', '.qxappender .type-array{color:#CC3E8A;font-weight:bold;}', '.qxappender .type-map{color:#CC3E8A;font-weight:bold;}', '.qxappender .type-key{color:#565656;font-style:italic}', '.qxappender .type-class{color:#5F3E8A;font-weight:bold}', '.qxappender .type-instance{color:#565656;font-weight:bold}', '.qxappender .type-stringify{color:#565656;font-weight:bold}']; // Include stylesheet

      qx.bom.Stylesheet.createElement(style.join("")); // Finally register to log engine

      qx.log.Logger.register(this);
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __element__P_185_0: null,

      /**
       * Configures the DOM element to use.
       *
       * @param element {Element} DOM element to log to
       */
      setElement: function setElement(element) {
        // Clear old element
        this.clear(); // Add classname

        if (element) {
          qx.bom.element.Class.add(element, "qxappender");
        } // Link to element


        this.__element__P_185_0 = element;
      },

      /**
       * Clears the current output.
       *
       */
      clear: function clear() {
        var elem = this.__element__P_185_0; // Remove all messages

        if (elem) {
          elem.innerHTML = "";
        }
      },

      /**
       * Processes a single log entry
       *
       * @signature function(entry)
       * @param entry {Map} The entry to process
       */
      process: function process(entry) {
        var elem = this.__element__P_185_0;

        if (!elem) {
          return;
        } // Append new content


        var formatter = qx.log.appender.Formatter.getFormatter();
        elem.appendChild(formatter.toHtml(entry)); // Scroll down

        elem.scrollTop = elem.scrollHeight;
      }
    }
  });
  qx.log.appender.Element.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.log.appender.Formatter": {
        "require": true,
        "defer": "runtime"
      },
      "qx.bom.client.Html": {
        "require": true,
        "defer": "runtime"
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.log.Logger": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "html.console": {
          "className": "qx.bom.client.Html"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Processes the incoming log entry and displays it by means of the native
   * logging capabilities of the client.
   *
   * Supported browsers:
   * * Firefox <4 using FireBug (if available).
   * * Firefox >=4 using the Web Console.
   * * WebKit browsers using the Web Inspector/Developer Tools.
   * * Internet Explorer 8+ using the F12 Developer Tools.
   * * Opera >=10.60 using either the Error Console or Dragonfly
   *
   * Currently unsupported browsers:
   * * Opera <10.60
   *
   * @require(qx.log.appender.Formatter)
   * @require(qx.bom.client.Html)
   */
  qx.Bootstrap.define("qx.log.appender.Native", {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * Processes a single log entry
       *
       * @param entry {Map} The entry to process
       */
      process: function process(entry) {
        if (qx.core.Environment.get("html.console")) {
          // Firefox 4's Web Console doesn't support "debug"
          var level = console[entry.level] ? entry.level : "log";

          if (console[level]) {
            var formatter = qx.log.appender.Formatter.getFormatter();
            var args = formatter.toText(entry);
            console[level](args);
          }
        }
      }
    },

    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer: function defer(statics) {
      qx.log.Logger.register(statics);
    }
  });
  qx.log.appender.Native.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006-2011 1&1 Internet AG, Germany, http://www.1and1.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
       * Thomas Herchenroeder (thron7)
  
  ************************************************************************ */

  /**
   * Log appender for qooxdoo applications running in Node.js. Writes log
   * messages to STDOUT/STDERR.
   *
   * @ignore(process.*)
   */
  qx.Class.define("qx.log.appender.NodeConsole", {
    statics: {
      /**
       * process.stdout
       */
      __OUT__P_187_0: null,

      /**
       * process.stderr
       */
      __ERR__P_187_1: null,

      /**
       * Writes a message to the shell. Errors will be sent to STDERR, everything
       * else goes to STDOUT
       *
       * @param logMessage {String} Message to be logged
       * @param level {String} Log level. One of "debug", "info", "warn", "error"
       */
      log: function log(logMessage, level) {
        if (level == "error") {
          this.__ERR__P_187_1.write(logMessage + '\n');
        } else {
          this.__OUT__P_187_0.write(logMessage + '\n');
        }
      },

      /**
       * Logs a debug message
       *
       * @param logMessage {String} Message to be logged
       */
      debug: function debug(logMessage) {
        this.log(logMessage, "debug");
      },

      /**
       * Logs an info message
       *
       * @param logMessage {String} Message to be logged
       */
      info: function info(logMessage) {
        this.log(logMessage, "info");
      },

      /**
       * Logs a warning message
       *
       * @param logMessage {String} Message to be logged
       */
      warn: function warn(logMessage) {
        this.log(logMessage, "warn");
      },

      /**
       * Logs an error message
       *
       * @param logMessage {String} Message to be logged
       */
      error: function error(logMessage) {
        this.log(logMessage, "error");
      },

      /**
       * Process a log entry object from qooxdoo's logging system.
       *
       * @param entry {Map} Log entry object
       */
      process: function process(entry) {
        var level = entry.level || "info";

        for (var prop in entry) {
          if (prop == "items") {
            var items = entry[prop];

            for (var p = 0; p < items.length; p++) {
              var item = items[p];
              this[level](item.text);
            }
          }
        }
      }
    },

    /**
     * @ignore(process.*)
     */
    defer: function defer(statics) {
      if (typeof process !== "undefined") {
        statics.__OUT__P_187_0 = process.stdout;
        statics.__ERR__P_187_1 = process.stderr;
      }
    }
  });
  qx.log.appender.NodeConsole.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.log.appender.Formatter": {
        "require": true,
        "defer": "runtime"
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.log.Logger": {
        "defer": "runtime"
      },
      "qx.bom.client.PhoneGap": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "phonegap": {
          "defer": true,
          "className": "qx.bom.client.PhoneGap"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Unify Project
  
       Homepage:
         http://unify-project.org
  
       Copyright:
         2009-2010 Deutsche Telekom AG, Germany, http://telekom.com
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Processes the incoming log entry and displays it using the PhoneGap
   * logging capabilities.
   *
   * @require(qx.log.appender.Formatter)
   * @ignore(debug.*)
   */
  qx.Class.define("qx.log.appender.PhoneGap", {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * Processes a single log entry
       * @param entry {Map} The entry to process
       */
      process: function process(entry) {
        var formatter = qx.log.appender.Formatter.getFormatter();
        var args = formatter.toText(entry);
        var level = entry.level;

        if (level == "warn") {
          debug.warn(args);
        } else if (level == "error") {
          debug.error(args);
        } else {
          debug.log(args);
        }
      }
    },

    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer: function defer(statics) {
      function register() {
        if (window.debug) {
          qx.log.Logger.register(statics);
        } else {
          window.setTimeout(register, 200);
        }
      }

      if (qx.core.Environment.get("phonegap")) {
        register();
      }
    }
  });
  qx.log.appender.PhoneGap.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006-2010 1&1 Internet AG, Germany, http://www.1and1.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
  
  ************************************************************************ */

  /**
   * Log appender for qooxdoo applications running in Mozilla Rhino. Writes log
   * messages to STDOUT/STDERR.
   *
   * @ignore(java.*)
   */
  qx.Class.define("qx.log.appender.RhinoConsole", {
    statics: {
      /**
       * java.lang.System.out
       */
      __OUT__P_188_0: null,

      /**
       * java.lang.System.err
       */
      __ERR__P_188_1: null,

      /**
       * Writes a message to the shell. Errors will be sent to STDERR, everything
       * else goes to STDOUT
       *
       * @param logMessage {String} Message to be logged
       * @param level {String} Log level. One of "debug", "info", "warn", "error"
       */
      log: function log(logMessage, level) {
        if (level == "error") {
          this.__ERR__P_188_1.println(logMessage);
        } else {
          this.__OUT__P_188_0.println(logMessage);
        }
      },

      /**
       * Logs a debug message
       *
       * @param logMessage {String} Message to be logged
       */
      debug: function debug(logMessage) {
        this.log(logMessage, "debug");
      },

      /**
       * Logs an info message
       *
       * @param logMessage {String} Message to be logged
       */
      info: function info(logMessage) {
        this.log(logMessage, "info");
      },

      /**
       * Logs a warning message
       *
       * @param logMessage {String} Message to be logged
       */
      warn: function warn(logMessage) {
        this.log(logMessage, "warn");
      },

      /**
       * Logs an error message
       *
       * @param logMessage {String} Message to be logged
       */
      error: function error(logMessage) {
        this.log(logMessage, "error");
      },

      /**
       * Process a log entry object from qooxdoo's logging system.
       *
       * @param entry {Map} Log entry object
       */
      process: function process(entry) {
        var level = entry.level || "info";

        for (var prop in entry) {
          if (prop == "items") {
            var items = entry[prop];

            for (var p = 0, l = items.length; p < l; p++) {
              var item = items[p];
              this[level](item.text);
            }
          }
        }
      }
    },
    defer: function defer() {
      if (typeof java !== "undefined" && typeof java.lang !== "undefined") {
        qx.log.appender.RhinoConsole.__OUT__P_188_0 = java.lang.System.out;
        qx.log.appender.RhinoConsole.__ERR__P_188_1 = java.lang.System.err;
      }
    }
  });
  qx.log.appender.RhinoConsole.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006-2011 1&1 Internet AG, Germany, http://www.1and1.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */

  /**
   * Log appender for qooxdoo applications running in Mozilla Rhino. Writes log
   * messages to a text file.
   *
   * @ignore(java.*)
   */
  qx.Class.define("qx.log.appender.RhinoFile", {
    statics: {
      /**
       * Path/name of the log file to use, relative to the directory Rhino was
       * called from.
       */
      FILENAME: null,
      __FILEHANDLE__P_189_0: null,

      /**
       * Writes a message to the file.
       *
       * @param logMessage {String} Message to be logged
       * @param level {String} Log level. One of "debug", "info", "warn", "error"
       */
      log: function log(logMessage, level) {
        if (!qx.log.appender.RhinoFile.__FILEHANDLE__P_189_0) {
          qx.log.appender.RhinoFile.create();
        }

        var logFile = qx.log.appender.RhinoFile.__FILEHANDLE__P_189_0;
        logFile.write(logMessage);
        logFile.newLine();
        logFile.flush();
      },

      /**
       * Logs a debug message
       *
       * @param logMessage {String} Message to be logged
       */
      debug: function debug(logMessage) {
        this.log(logMessage, "debug");
      },

      /**
       * Logs an info message
       *
       * @param logMessage {String} Message to be logged
       */
      info: function info(logMessage) {
        this.log(logMessage, "info");
      },

      /**
       * Logs a warning message
       *
       * @param logMessage {String} Message to be logged
       */
      warn: function warn(logMessage) {
        this.log(logMessage, "warn");
      },

      /**
       * Logs an error message
       *
       * @param logMessage {String} Message to be logged
       */
      error: function error(logMessage) {
        this.log(logMessage, "error");
      },

      /**
       * Process a log entry object from qooxdoo's logging system.
       *
       * @param entry {Map} Log entry object
       */
      process: function process(entry) {
        var level = entry.level || "info";

        for (var prop in entry) {
          if (prop == "items") {
            var items = entry[prop];

            for (var p = 0, l = items.length; p < l; p++) {
              var item = items[p];
              this[level](item.text);
            }
          }
        }
      },

      /**
       * Creates a new log file using the value of {@link #FILENAME} as the
       * file path/name.
       */
      create: function create() {
        if (qx.log.appender.RhinoFile.__FILEHANDLE__P_189_0) {
          qx.log.appender.RhinoFile.__FILEHANDLE__P_189_0.close();
        }

        if (!qx.log.appender.RhinoFile.FILENAME) {
          qx.log.appender.RhinoFile.FILENAME = "qooxdoo.log";
        }

        var fstream = new java.io.FileWriter(qx.log.appender.RhinoFile.FILENAME, true);
        qx.log.appender.RhinoFile.__FILEHANDLE__P_189_0 = new java.io.BufferedWriter(fstream);
      }
    }
  });
  qx.log.appender.RhinoFile.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.log.appender.Formatter": {
        "defer": "runtime",
        "require": true
      },
      "qx.lang.Array": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Contains some common methods available to all log appenders.
   * 
   * @deprecated {6.0} See qx.util.appender.Formatter instead
   */
  qx.Bootstrap.define("qx.log.appender.Util", {
    statics: {
      toHtml: null,
      toText: null,
      toTextArray: null,
      escapeHTML: qx.log.appender.Formatter.escapeHTML
    },
    defer: function defer(statics) {
      var formatter = qx.log.appender.Formatter.getFormatter();
      ["toHtml", "toText", "toTextArray", "escapeHTML"].forEach(function (name) {
        statics[name] = function () {
          return formatter[name].apply(formatter, qx.lang.Array.fromArguments(arguments));
        };
      });
    }
  });
  qx.log.appender.Util.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.element.Attribute": {},
      "qx.bom.Html": {},
      "qx.bom.Input": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Attribute/Property handling for DOM elements.
   * @group (Core)
   */
  qx.Bootstrap.define("qx.module.Attribute", {
    members: {
      /**
       * Returns the HTML content of the first item in the collection
       * @attach {qxWeb}
       * @return {String|null} HTML content or null if the collection is empty
       */
      getHtml: function getHtml() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Attribute.get(this[0], "html");
        }

        return null;
      },

      /**
       * Sets the HTML content of each item in the collection
       *
       * @attach {qxWeb}
       * @param html {String} HTML string
       * @return {qxWeb} The collection for chaining
       */
      setHtml: function setHtml(html) {
        html = qx.bom.Html.fixEmptyTags(html);

        this._forEachElement(function (item) {
          qx.bom.element.Attribute.set(item, "html", html);
        });

        return this;
      },

      /**
       * Sets an HTML attribute on each item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Attribute name
       * @param value {var} Attribute value
       * @return {qxWeb} The collection for chaining
       */
      setAttribute: function setAttribute(name, value) {
        this._forEachElement(function (item) {
          qx.bom.element.Attribute.set(item, name, value);
        });

        return this;
      },

      /**
       * Returns the value of the given attribute for the first item in the
       * collection.
       *
       * @attach {qxWeb}
       * @param name {String} Attribute name
       * @return {var} Attribute value
       */
      getAttribute: function getAttribute(name) {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Attribute.get(this[0], name);
        }

        return null;
      },

      /**
       * Removes the given attribute from all elements in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Attribute name
       * @return {qxWeb} The collection for chaining
       */
      removeAttribute: function removeAttribute(name) {
        this._forEachElement(function (item) {
          qx.bom.element.Attribute.set(item, name, null);
        });

        return this;
      },

      /**
       * Sets multiple attributes for each item in the collection.
       *
       * @attach {qxWeb}
       * @param attributes {Map} A map of attribute name/value pairs
       * @return {qxWeb} The collection for chaining
       */
      setAttributes: function setAttributes(attributes) {
        for (var name in attributes) {
          this.setAttribute(name, attributes[name]);
        }

        return this;
      },

      /**
       * Returns the values of multiple attributes for the first item in the collection
       *
       * @attach {qxWeb}
       * @param names {String[]} List of attribute names
       * @return {Map} Map of attribute name/value pairs
       */
      getAttributes: function getAttributes(names) {
        var attributes = {};

        for (var i = 0; i < names.length; i++) {
          attributes[names[i]] = this.getAttribute(names[i]);
        }

        return attributes;
      },

      /**
       * Removes multiple attributes from each item in the collection.
       *
       * @attach {qxWeb}
       * @param attributes {String[]} List of attribute names
       * @return {qxWeb} The collection for chaining
       */
      removeAttributes: function removeAttributes(attributes) {
        for (var i = 0, l = attributes.length; i < l; i++) {
          this.removeAttribute(attributes[i]);
        }

        return this;
      },

      /**
       * Sets a property on each item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Property name
       * @param value {var} Property value
       * @return {qxWeb} The collection for chaining
       */
      setProperty: function setProperty(name, value) {
        for (var i = 0; i < this.length; i++) {
          this[i][name] = value;
        }

        return this;
      },

      /**
       * Returns the value of the given property for the first item in the
       * collection
       *
       * @attach {qxWeb}
       * @param name {String} Property name
       * @return {var} Property value
       */
      getProperty: function getProperty(name) {
        if (this[0]) {
          return this[0][name];
        }

        return null;
      },

      /**
       * Sets multiple properties for each item in the collection.
       *
       * @attach {qxWeb}
       * @param properties {Map} A map of property name/value pairs
       * @return {qxWeb} The collection for chaining
       */
      setProperties: function setProperties(properties) {
        for (var name in properties) {
          this.setProperty(name, properties[name]);
        }

        return this;
      },

      /**
       * Removes multiple properties for each item in the collection.
       *
       * @attach {qxWeb}
       * @param properties {String[]} An array of property names
       * @return {qxWeb} The collection for chaining
       */
      removeProperties: function removeProperties(properties) {
        for (var i = 0; i < properties.length; i++) {
          this.removeProperty(properties[i]);
        }

        return this;
      },

      /**
       * Returns the values of multiple properties for the first item in the collection
       *
       * @attach {qxWeb}
       * @param names {String[]} List of property names
       * @return {Map} Map of property name/value pairs
       */
      getProperties: function getProperties(names) {
        var properties = {};

        for (var i = 0; i < names.length; i++) {
          properties[names[i]] = this.getProperty(names[i]);
        }

        return properties;
      },

      /**
       * Deletes a property from each item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Property name
       * @return {qxWeb} The collection for chaining
       */
      removeProperty: function removeProperty(name) {
        if (this[0]) {
          this[0][name] = undefined;
        }

        return this;
      },

      /**
       * Returns the currently configured value for the first item in the collection.
       * Works with simple input fields as well as with select boxes or option
       * elements. Returns an array for select boxes with multi selection. In all
       * other cases, a string is returned.
       *
       * @attach {qxWeb}
       * @return {String|String[]} String value or Array of string values (for multiselect)
       */
      getValue: function getValue() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.Input.getValue(this[0]);
        }

        return null;
      },

      /**
       * Applies the given value to each element in the collection.
       * Normally the value is given as a string/number value and applied to the
       * field content (textfield, textarea) or used to detect whether the field
       * is checked (checkbox, radiobutton).
       * Supports array values for selectboxes (multiple selection) and checkboxes
       * or radiobuttons (for convenience).
       *
       * Please note: To modify the value attribute of a checkbox or radiobutton
       * use {@link #setAttribute} instead and manipulate the <code>checked</code> attribute.
       *
       * @attach {qxWeb}
       * @param value {String|Number|Array} The value to apply
       * @return {qxWeb} The collection for chaining
       */
      setValue: function setValue(value) {
        this._forEachElement(function (item) {
          qx.bom.Input.setValue(item, value);
        });

        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.Attribute.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Object": {},
      "qx.lang.Type": {},
      "qx.bom.Html": {},
      "qx.dom.Node": {},
      "qxWeb": {
        "defer": "runtime"
      },
      "qx.dom.Element": {},
      "qx.lang.Array": {},
      "qx.bom.Viewport": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * DOM manipulation module
   *
   * @ignore(qx.bom.element, qx.bom.element.AnimationJs)
   * @group (Core)
   */
  qx.Bootstrap.define("qx.module.Manipulating", {
    statics: {
      /** Default animation descriptions for animated scrolling **/
      _animationDescription: {
        scrollLeft: {
          duration: 700,
          timing: "ease-in",
          keep: 100,
          keyFrames: {
            0: {},
            100: {
              scrollLeft: 1
            }
          }
        },
        scrollTop: {
          duration: 700,
          timing: "ease-in",
          keep: 100,
          keyFrames: {
            0: {},
            100: {
              scrollTop: 1
            }
          }
        }
      },

      /**
       * Performs animated scrolling
       *
       * @param property {String} Element property to animate: <code>scrollLeft</code>
       * or <code>scrollTop</code>
       * @param value {Number} Final scroll position
       * @param duration {Number} The animation's duration in ms
       * @return {q} The collection for chaining.
       */
      __animateScroll__P_193_0: function __animateScroll__P_193_0(property, value, duration) {
        var desc = qx.lang.Object.clone(qx.module.Manipulating._animationDescription[property], true);
        desc.keyFrames[100][property] = value;
        return this.animate(desc, duration);
      },

      /**
       * Creates a new collection from the given argument
       * @param arg {var} Selector expression, HTML string, DOM element or list of
       * DOM elements
       * @return {qxWeb} Collection
       * @internal
       */
      __getCollectionFromArgument__P_193_1: function __getCollectionFromArgument__P_193_1(arg) {
        var coll; // Collection/array of DOM elements

        if (qx.lang.Type.isArray(arg)) {
          coll = qxWeb(arg);
        } // HTML string
        else {
            var arr = qx.bom.Html.clean([arg]);

            if (arr.length > 0 && qx.dom.Node.isElement(arr[0])) {
              coll = qxWeb(arr);
            } // Selector or single element
            else {
                coll = qxWeb(arg);
              }
          }

        return coll;
      },

      /**
       * Returns the innermost element of a DOM tree as determined by a simple
       * depth-first search.
       *
       * @param element {Element} Root element
       * @return {Element} innermost element
       * @internal
       */
      __getInnermostElement__P_193_2: function __getInnermostElement__P_193_2(element) {
        if (element.childNodes.length == 0) {
          return element;
        }

        for (var i = 0, l = element.childNodes.length; i < l; i++) {
          if (element.childNodes[i].nodeType === 1) {
            return this.__getInnermostElement__P_193_2(element.childNodes[i]);
          }
        }

        return element;
      },

      /**
       * Returns an array from a selector expression or a single element
       *
       * @attach{qxWeb}
       * @param arg {String|Element} Selector expression or DOM element
       * @return {Element[]} Array of elements
       * @internal
       */
      __getElementArray__P_193_3: function __getElementArray__P_193_3(arg) {
        if (!qx.lang.Type.isArray(arg)) {
          var fromSelector = qxWeb(arg);
          arg = fromSelector.length > 0 ? fromSelector : [arg];
        }

        return arg.filter(function (item) {
          return item && (item.nodeType === 1 || item.nodeType === 11);
        });
      },

      /**
       * Creates a new collection from the given argument. This can either be an
       * HTML string, a single DOM element or an array of elements
       *
       * When no <code>context</code> is given the global document is used to
       * create new DOM elements.
       *
       * <strong>Note:</strong> When a complex HTML string is provided the <code>innerHTML</code>
       * mechanism of the browser is used. Some browsers do filter out elements like <code>&lt;html&gt;</code>,
       * <code>&lt;head&gt;</code> or <code>&lt;body&gt;</code>. The better approach is to create
       * a single element and the appending the child nodes.
       *
       * @attachStatic{qxWeb}
       * @param html {String|Element[]} HTML string or DOM element(s)
       * @param context {Document?document} Context in which the elements should be created
       * @return {qxWeb} Collection of elements
       */
      create: function create(html, context) {
        return qxWeb.$init(qx.bom.Html.clean([html], context), qxWeb);
      }
    },
    members: {
      /**
       * Clones the items in the current collection and returns them in a new set.
       * Event listeners can also be cloned.
       *
       * @attach{qxWeb}
       * @param events {Boolean} clone event listeners. Default: <code>false</code>
       * @return {qxWeb} New collection with clones
       */
      clone: function clone(events) {
        var clones = [];

        for (var i = 0; i < this.length; i++) {
          if (this[i] && this[i].nodeType === 1) {
            clones[i] = this[i].cloneNode(true);
          }
        }

        if (events === true && this.copyEventsTo) {
          this.copyEventsTo(clones);
        }

        return qxWeb(clones);
      },

      /**
       * Appends content to each element in the current set. Accepts an HTML string,
       * a single DOM element or an array of elements
       *
       * @attach{qxWeb}
       * @param html {String|Element[]|qxWeb} HTML string or DOM element(s) to append
       * @return {qxWeb} The collection for chaining
       */
      append: function append(html) {
        var arr = qx.bom.Html.clean([html]);
        var children = qxWeb.$init(arr, qxWeb);

        this._forEachElement(function (item, index) {
          for (var j = 0, m = children.length; j < m; j++) {
            if (index == 0) {
              // first parent: move the target node(s)
              qx.dom.Element.insertEnd(children[j], item);
            } else {
              qx.dom.Element.insertEnd(children.eq(j).clone(true)[0], item);
            }
          }
        });

        return this;
      },

      /**
       * Appends all items in the collection to the specified parents. If multiple
       * parents are given, the items will be moved to the first parent, while
       * clones of the items will be appended to subsequent parents.
       *
       * @attach{qxWeb}
       * @param parent {String|Element[]|qxWeb} Parent selector expression or list of
       * parent elements
       * @return {qxWeb} The collection for chaining
       */
      appendTo: function appendTo(parent) {
        parent = qx.module.Manipulating.__getElementArray__P_193_3(parent);

        for (var i = 0, l = parent.length; i < l; i++) {
          this._forEachElement(function (item, j) {
            if (i == 0) {
              // first parent: move the target node(s)
              qx.dom.Element.insertEnd(this[j], parent[i]);
            } else {
              // further parents: clone the target node(s)
              qx.dom.Element.insertEnd(this.eq(j).clone(true)[0], parent[i]);
            }
          });
        }

        return this;
      },

      /**
       * Inserts the current collection before each target item. The collection
       * items are moved before the first target. For subsequent targets,
       * clones of the collection items are created and inserted.
       *
       * @attach{qxWeb}
       * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,
       * Array of DOM elements or collection
       * @return {qxWeb} The collection for chaining
       */
      insertBefore: function insertBefore(target) {
        target = qx.module.Manipulating.__getElementArray__P_193_3(target);

        for (var i = 0, l = target.length; i < l; i++) {
          this._forEachElement(function (item, index) {
            if (i == 0) {
              // first target: move the target node(s)
              qx.dom.Element.insertBefore(item, target[i]);
            } else {
              // further targets: clone the target node(s)
              qx.dom.Element.insertBefore(this.eq(index).clone(true)[0], target[i]);
            }
          });
        }

        return this;
      },

      /**
       * Inserts the current collection after each target item. The collection
       * items are moved after the first target. For subsequent targets,
       * clones of the collection items are created and inserted.
       *
       * @attach{qxWeb}
       * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,
       * Array of DOM elements or collection
       * @return {qxWeb} The collection for chaining
       */
      insertAfter: function insertAfter(target) {
        target = qx.module.Manipulating.__getElementArray__P_193_3(target);

        for (var i = 0, l = target.length; i < l; i++) {
          for (var j = this.length - 1; j >= 0; j--) {
            if (!this[j] || this[j].nodeType !== 1) {
              continue;
            }

            if (i == 0) {
              // first target: move the target node(s)
              qx.dom.Element.insertAfter(this[j], target[i]);
            } else {
              // further targets: clone the target node(s)
              qx.dom.Element.insertAfter(this.eq(j).clone(true)[0], target[i]);
            }
          }
        }

        return this;
      },

      /**
       * Wraps each element in the collection in a copy of an HTML structure.
       * Elements will be appended to the deepest nested element in the structure
       * as determined by a depth-first search.
       *
       * @attach{qxWeb}
       * @param wrapper {String|Element|Element[]|qxWeb} Selector expression, HTML string, DOM element or
       * list of DOM elements
       * @return {qxWeb} The collection for chaining
       */
      wrap: function wrap(wrapper) {
        wrapper = qx.module.Manipulating.__getCollectionFromArgument__P_193_1(wrapper);

        if (wrapper.length == 0) {
          return this;
        }

        this._forEachElement(function (item) {
          var clonedwrapper = wrapper.eq(0).clone(true);
          qx.dom.Element.insertAfter(clonedwrapper[0], item);

          var innermost = qx.module.Manipulating.__getInnermostElement__P_193_2(clonedwrapper[0]);

          qx.dom.Element.insertEnd(item, innermost);
        });

        return this;
      },

      /**
       * Removes each element in the current collection from the DOM
       *
       * @attach{qxWeb}
       * @return {qxWeb} The collection for chaining
       */
      remove: function remove() {
        this._forEachElement(function (item) {
          qx.dom.Element.remove(item);
        });

        return this;
      },

      /**
       * Removes all content from the elements in the collection
       *
       * @attach{qxWeb}
       * @return {qxWeb} The collection for chaining
       */
      empty: function empty() {
        this._forEachElement(function (item) {
          // don't use innerHTML="" because of [BUG #7323]
          // and don't use textContent="" because of missing IE8 support
          while (item.firstChild) {
            item.removeChild(item.firstChild);
          }
        });

        return this;
      },

      /**
       * Inserts content before each element in the collection. This can either
       * be an HTML string, an array of HTML strings, a single DOM element or an
       * array of elements.
       *
       * @attach{qxWeb}
       * @param content {String|String[]|Element|Element[]|qxWeb} HTML string(s),
       * DOM element(s) or collection to insert
       * @return {qxWeb} The collection for chaining
       */
      before: function before(content) {
        if (!qx.lang.Type.isArray(content)) {
          content = [content];
        }

        var fragment = document.createDocumentFragment();
        qx.bom.Html.clean(content, document, fragment);

        this._forEachElement(function (item, index) {
          var kids = qx.lang.Array.cast(fragment.childNodes, Array);

          for (var i = 0, l = kids.length; i < l; i++) {
            var child;

            if (index < this.length - 1) {
              child = kids[i].cloneNode(true);
            } else {
              child = kids[i];
            }

            item.parentNode.insertBefore(child, item);
          }
        }, this);

        return this;
      },

      /**
       * Inserts content after each element in the collection. This can either
       * be an HTML string, an array of HTML strings, a single DOM element or an
       * array of elements.
       *
       * @attach{qxWeb}
       * @param content {String|String[]|Element|Element[]|qxWeb} HTML string(s),
       * DOM element(s) or collection to insert
       * @return {qxWeb} The collection for chaining
       */
      after: function after(content) {
        if (!qx.lang.Type.isArray(content)) {
          content = [content];
        }

        var fragment = document.createDocumentFragment();
        qx.bom.Html.clean(content, document, fragment);

        this._forEachElement(function (item, index) {
          var kids = qx.lang.Array.cast(fragment.childNodes, Array);

          for (var i = kids.length - 1; i >= 0; i--) {
            var child;

            if (index < this.length - 1) {
              child = kids[i].cloneNode(true);
            } else {
              child = kids[i];
            }

            item.parentNode.insertBefore(child, item.nextSibling);
          }
        }, this);

        return this;
      },

      /**
       * Returns the left scroll position of the first element in the collection.
       *
       * @attach{qxWeb}
       * @return {Number} Current left scroll position
       */
      getScrollLeft: function getScrollLeft() {
        var obj = this[0];

        if (!obj) {
          return null;
        }

        var Node = qx.dom.Node;

        if (Node.isWindow(obj) || Node.isDocument(obj)) {
          return qx.bom.Viewport.getScrollLeft();
        }

        return obj.scrollLeft;
      },

      /**
       * Returns the top scroll position of the first element in the collection.
       *
       * @attach{qxWeb}
       * @return {Number} Current top scroll position
       */
      getScrollTop: function getScrollTop() {
        var obj = this[0];

        if (!obj) {
          return null;
        }

        var Node = qx.dom.Node;

        if (Node.isWindow(obj) || Node.isDocument(obj)) {
          return qx.bom.Viewport.getScrollTop();
        }

        return obj.scrollTop;
      },

      /**
       * Scrolls the elements of the collection to the given coordinate.
       *
       * @attach{qxWeb}
       * @param value {Number} Left scroll position
       * @param duration {Number?} Optional: Duration in ms for animated scrolling
       * @return {qxWeb} The collection for chaining
       */
      setScrollLeft: function setScrollLeft(value, duration) {
        var Node = qx.dom.Node;

        if (duration && qx.bom.element && qx.bom.element.AnimationJs) {
          qx.module.Manipulating.__animateScroll__P_193_0.bind(this, "scrollLeft", value, duration)();
        }

        for (var i = 0, l = this.length, obj; i < l; i++) {
          obj = this[i];

          if (Node.isElement(obj)) {
            if (!(duration && qx.bom.element && qx.bom.element.AnimationJs)) {
              obj.scrollLeft = value;
            }
          } else if (Node.isWindow(obj)) {
            obj.scrollTo(value, this.getScrollTop(obj));
          } else if (Node.isDocument(obj)) {
            Node.getWindow(obj).scrollTo(value, this.getScrollTop(obj));
          }
        }

        return this;
      },

      /**
       * Scrolls the elements of the collection to the given coordinate.
       *
       * @attach{qxWeb}
       * @param value {Number} Top scroll position
       * @param duration {Number?} Optional: Duration in ms for animated scrolling
       * @return {qxWeb} The collection for chaining
       */
      setScrollTop: function setScrollTop(value, duration) {
        var Node = qx.dom.Node;

        if (duration && qx.bom.element && qx.bom.element.AnimationJs) {
          qx.module.Manipulating.__animateScroll__P_193_0.bind(this, "scrollTop", value, duration)();
        }

        for (var i = 0, l = this.length, obj; i < l; i++) {
          obj = this[i];

          if (Node.isElement(obj)) {
            if (!(duration && qx.bom.element && qx.bom.element.AnimationJs)) {
              obj.scrollTop = value;
            }
          } else if (Node.isWindow(obj)) {
            obj.scrollTo(this.getScrollLeft(obj), value);
          } else if (Node.isDocument(obj)) {
            Node.getWindow(obj).scrollTo(this.getScrollLeft(obj), value);
          }
        }

        return this;
      },

      /**
       * Focuses the first element in the collection
       *
       * @attach{qxWeb}
       * @return {qxWeb} The collection for chaining
       */
      focus: function focus() {
        try {
          this[0].focus();
        } catch (ex) {}

        return this;
      },

      /**
       * Blurs each element in the collection
       *
       * @attach{qxWeb}
       * @return {qxWeb} The collection for chaining
       */
      blur: function blur() {
        this.forEach(function (item, index) {
          try {
            item.blur();
          } catch (ex) {}
        });
        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.Manipulating.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.Selector": {},
      "qxWeb": {
        "defer": "runtime"
      },
      "qx.dom.Hierarchy": {},
      "qx.lang.Array": {},
      "qx.dom.Node": {},
      "qx.bom.client.Html": {},
      "qx.lang.Type": {},
      "qx.bom.element.Location": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "html.node.isequalnode": {
          "className": "qx.bom.client.Html"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * DOM traversal module
   *
   * @require(qx.dom.Hierarchy#getSiblings)
   * @require(qx.dom.Hierarchy#getNextSiblings)
   * @require(qx.dom.Hierarchy#getPreviousSiblings)
   * @require(qx.dom.Hierarchy#contains)
   *
   * @group (Core)
   */
  qx.Bootstrap.define("qx.module.Traversing", {
    statics: {
      /**
       * String attributes used to determine if two DOM nodes are equal
       * as defined in <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode">
       * DOM Level 3</a>
       */
      EQUALITY_ATTRIBUTES: ["nodeType", "nodeName", "localName", "namespaceURI", "prefix", "nodeValue"],

      /**
       * Internal helper for getAncestors and getAncestorsUntil
       *
       * @attach {qxWeb}
       * @param selector {String} Selector that indicates where to stop including
       * ancestor elements
       * @param filter {String?null} Optional selector to match
       * @return {qxWeb} Collection containing the ancestor elements
       * @internal
       */
      __getAncestors__P_198_0: function __getAncestors__P_198_0(selector, filter) {
        var ancestors = [];

        for (var i = 0; i < this.length; i++) {
          var parent = qx.dom.Element.getParentElement(this[i]);

          while (parent) {
            var found = [parent];

            if (selector && qx.bom.Selector.matches(selector, found).length > 0) {
              break;
            }

            if (filter) {
              found = qx.bom.Selector.matches(filter, found);
            }

            ancestors = ancestors.concat(found);
            parent = qx.dom.Element.getParentElement(parent);
          }
        }

        return qxWeb.$init(ancestors, qxWeb);
      },

      /**
       * Helper which returns the element from the given argument. If it's a collection,
       * it returns it's first child. If it's a string, it tries to use the string
       * as selector and returns the first child of the new collection.
       * @param arg {Node|String|qxWeb} The element.
       * @return {Node|var} If a node can be extracted, the node element will be return.
       *   If not, at given argument will be returned.
       */
      __getElementFromArgument__P_198_1: function __getElementFromArgument__P_198_1(arg) {
        if (arg instanceof qxWeb) {
          return arg[0];
        } else if (qx.Bootstrap.isString(arg)) {
          return qxWeb(arg)[0];
        }

        return arg;
      },

      /**
       * Helper that attempts to convert the given argument into a DOM node
       * @param arg {var} object to convert
       * @return {Node|null} DOM node or null if the conversion failed
       */
      __getNodeFromArgument__P_198_2: function __getNodeFromArgument__P_198_2(arg) {
        if (typeof arg == "string") {
          arg = qxWeb(arg);
        }

        if (arg instanceof Array || arg instanceof qxWeb) {
          arg = arg[0];
        }

        return qxWeb.isNode(arg) ? arg : null;
      },

      /**
       * Returns a map containing the given DOM node's attribute names
       * and values
       *
       * @param node {Node} DOM node
       * @return {Map} Map of attribute names/values
       */
      __getAttributes__P_198_3: function __getAttributes__P_198_3(node) {
        var attributes = {};

        for (var attr in node.attributes) {
          if (attr == "length") {
            continue;
          }

          var name = node.attributes[attr].name;
          var value = node.attributes[attr].value;
          attributes[name] = value;
        }

        return attributes;
      },

      /**
       * Helper function that iterates over a set of items and applies the given
       * qx.dom.Hierarchy method to each entry, storing the results in a new Array.
       * Duplicates are removed and the items are filtered if a selector is
       * provided.
       *
       * @attach{qxWeb}
       * @param collection {Array} Collection to iterate over (any Array-like object)
       * @param method {String} Name of the qx.dom.Hierarchy method to apply
       * @param selector {String?} Optional selector that elements to be included
       * must match
       * @return {Array} Result array
       * @internal
       */
      __hierarchyHelper__P_198_4: function __hierarchyHelper__P_198_4(collection, method, selector) {
        // Iterate ourself, as we want to directly combine the result
        var all = [];
        var Hierarchy = qx.dom.Hierarchy;

        for (var i = 0, l = collection.length; i < l; i++) {
          all.push.apply(all, Hierarchy[method](collection[i]));
        } // Remove duplicates


        var ret = qx.lang.Array.unique(all); // Post reduce result by selector

        if (selector) {
          ret = qx.bom.Selector.matches(selector, ret);
        }

        return ret;
      },

      /**
       * Checks if the given object is a DOM element
       *
       * @attachStatic{qxWeb}
       * @param selector {Object|String|qxWeb} Object to check
       * @return {Boolean} <code>true</code> if the object is a DOM element
       */
      isElement: function isElement(selector) {
        return qx.dom.Node.isElement(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Checks if the given object is a DOM node
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} Object to check
       * @return {Boolean} <code>true</code> if the object is a DOM node
       */
      isNode: function isNode(selector) {
        return qx.dom.Node.isNode(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Whether the node has the given node name
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} the node to check
       * @param  nodeName {String} the node name to check for
       * @return {Boolean} <code>true</code> if the node has the given name
       */
      isNodeName: function isNodeName(selector, nodeName) {
        return qx.dom.Node.isNodeName(qx.module.Traversing.__getElementFromArgument__P_198_1(selector), nodeName);
      },

      /**
       * Checks if the given object is a DOM document object
       *
       * @attachStatic{qxWeb}
       * @param node {Object|qxWeb} Object to check. If the value is a qxWeb
       * collection, isDocument will check the first item.
       * @return {Boolean} <code>true</code> if the object is a DOM document
       */
      isDocument: function isDocument(node) {
        if (node instanceof qxWeb) {
          node = node[0];
        }

        return qx.dom.Node.isDocument(node);
      },

      /**
       * Checks if the given object is a DOM document fragment object
       *
       * @attachStatic{qxWeb}
       * @param node {Object|qxWeb} Object to check. If the value is a qxWeb
       * collection, isDocumentFragment will check the first item.
       * @return {Boolean} <code>true</code> if the object is a DOM document fragment
       */
      isDocumentFragment: function isDocumentFragment(node) {
        if (node instanceof qxWeb) {
          node = node[0];
        }

        return qx.dom.Node.isDocumentFragment(node);
      },

      /**
       * Returns the DOM2 <code>defaultView</code> (window) for the given node.
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|Document|Window|String|qxWeb} Node to inspect
       * @return {Window} the <code>defaultView</code> for the given node
       */
      getWindow: function getWindow(selector) {
        return qx.dom.Node.getWindow(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Checks whether the given object is a DOM text node
       *
       * @attachStatic{qxWeb}
       * @param obj {Object} the object to be tested
       * @return {Boolean} <code>true</code> if the object is a textNode
       */
      isTextNode: function isTextNode(obj) {
        return qx.dom.Node.isText(obj);
      },

      /**
       * Check whether the given object is a browser window object.
       *
       * @attachStatic{qxWeb}
       * @param obj {Object|qxWeb} the object to be tested. If the value
       * is a qxWeb collection, isDocument will check the first item.
       * @return {Boolean} <code>true</code> if the object is a window object
       */
      isWindow: function isWindow(obj) {
        if (obj instanceof qxWeb) {
          obj = obj[0];
        }

        return qx.dom.Node.isWindow(obj);
      },

      /**
       * Returns the owner document of the given node
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} Node to get the document for
       * @return {Document|null} The document of the given DOM node
       */
      getDocument: function getDocument(selector) {
        return qx.dom.Node.getDocument(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Get the DOM node's name as a lowercase string
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} DOM Node
       * @return {String} node name
       */
      getNodeName: function getNodeName(selector) {
        return qx.dom.Node.getName(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Returns the text content of a node where the node type may be one of
       * NODE_ELEMENT, NODE_ATTRIBUTE, NODE_TEXT, NODE_CDATA
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} the node from where the search should start. If the
       * node has subnodes the text contents are recursively retrieved and joined
       * @return {String} the joined text content of the given node or null if not
       * appropriate.
       */
      getNodeText: function getNodeText(selector) {
        return qx.dom.Node.getText(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Checks if the given node is a block node
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} the node to check
       * @return {Boolean} <code>true</code> if the node is a block node
       */
      isBlockNode: function isBlockNode(selector) {
        return qx.dom.Node.isBlockNode(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Determines if two DOM nodes are equal as defined in the
       * <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode">DOM Level 3 isEqualNode spec</a>.
       * Also works in legacy browsers without native <em>isEqualNode</em> support.
       *
       * @attachStatic{qxWeb}
       * @param node1 {String|Element|Element[]|qxWeb} first object to compare
       * @param node2 {String|Element|Element[]|qxWeb} second object to compare
       * @return {Boolean} <code>true</code> if the nodes are equal
       */
      equalNodes: function equalNodes(node1, node2) {
        node1 = qx.module.Traversing.__getNodeFromArgument__P_198_2(node1);
        node2 = qx.module.Traversing.__getNodeFromArgument__P_198_2(node2);

        if (!node1 || !node2) {
          return false;
        }

        if (qx.core.Environment.get("html.node.isequalnode")) {
          return node1.isEqualNode(node2);
        } else {
          if (node1 === node2) {
            return true;
          } // quick attributes length check


          var hasAttributes = node1.attributes && node2.attributes;

          if (hasAttributes && node1.attributes.length !== node2.attributes.length) {
            return false;
          }

          var hasChildNodes = node1.childNodes && node2.childNodes; // quick childNodes length check

          if (hasChildNodes && node1.childNodes.length !== node2.childNodes.length) {
            return false;
          } // string attribute check


          var domAttributes = qx.module.Traversing.EQUALITY_ATTRIBUTES;

          for (var i = 0, l = domAttributes.length; i < l; i++) {
            var domAttrib = domAttributes[i];

            if (node1[domAttrib] !== node2[domAttrib]) {
              return false;
            }
          } // attribute values


          if (hasAttributes) {
            var node1Attributes = qx.module.Traversing.__getAttributes__P_198_3(node1);

            var node2Attributes = qx.module.Traversing.__getAttributes__P_198_3(node2);

            for (var attr in node1Attributes) {
              if (node1Attributes[attr] !== node2Attributes[attr]) {
                return false;
              }
            }
          } // child nodes


          if (hasChildNodes) {
            for (var j = 0, m = node1.childNodes.length; j < m; j++) {
              var child1 = node1.childNodes[j];
              var child2 = node2.childNodes[j];

              if (!qx.module.Traversing.equalNodes(child1, child2)) {
                return false;
              }
            }
          }

          return true;
        }
      }
    },
    members: {
      __getAncestors__P_198_0: null,

      /**
       * Adds an element to the collection
       *
       * @attach {qxWeb}
       * @param el {Element|qxWeb} DOM element to add to the collection.
       * If a collection is given, only the first element will be added
       * @return {qxWeb} The collection for chaining
       */
      add: function add(el) {
        if (el instanceof qxWeb) {
          el = el[0];
        }

        if (qx.module.Traversing.isElement(el) || qx.module.Traversing.isDocument(el) || qx.module.Traversing.isWindow(el) || qx.module.Traversing.isDocumentFragment(el)) {
          this.push(el);
        }

        return this;
      },

      /**
       * Gets a set of elements containing all of the unique immediate children of
       * each of the matched set of elements.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?null} Optional selector to match
       * @return {qxWeb} Collection containing the child elements
       */
      getChildren: function getChildren(selector) {
        var children = [];

        for (var i = 0; i < this.length; i++) {
          var found = qx.dom.Hierarchy.getChildElements(this[i]);

          if (selector) {
            found = qx.bom.Selector.matches(selector, found);
          }

          children = children.concat(found);
        }

        ;
        return qxWeb.$init(children, qxWeb);
      },

      /**
       * Executes the provided callback function once for each item in the
       * collection.
       *
       * @attach {qxWeb}
       * @param fn {Function} Callback function which is called with two parameters
       * <ul>
       *  <li>current item - DOM node</li>
       *  <li>current index - Number</li>
       * </ul>
       * @param ctx {Object} Context object
       * @return {qxWeb} The collection for chaining
       */
      forEach: function forEach(fn, ctx) {
        for (var i = 0; i < this.length; i++) {
          fn.call(ctx, this[i], i, this);
        }

        ;
        return this;
      },

      /**
       * Gets a set of elements containing the parent of each element in the
       * collection.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?null} Optional selector to match
       * @return {qxWeb} Collection containing the parent elements
       */
      getParents: function getParents(selector) {
        var parents = [];

        for (var i = 0; i < this.length; i++) {
          var found = qx.dom.Element.getParentElement(this[i]);

          if (selector) {
            found = qx.bom.Selector.matches(selector, [found]);
          }

          parents = parents.concat(found);
        }

        ;
        return qxWeb.$init(parents, qxWeb);
      },

      /**
      * Checks if any element of the current collection is child of any element of a given
      * parent collection.
      *
      * @attach{qxWeb}
      * @param parent {qxWeb | String} Collection or selector of the parent collection to check.
      * @return {Boolean} Returns true if at least one element of the current collection is child of the parent collection
      *
      */
      isChildOf: function isChildOf(parent) {
        if (this.length == 0) {
          return false;
        }

        var ancestors = null,
            parentCollection = qxWeb(parent),
            isChildOf = false;

        for (var i = 0, l = this.length; i < l && !isChildOf; i++) {
          ancestors = qxWeb(this[i]).getAncestors();

          for (var j = 0, len = parentCollection.length; j < len; j++) {
            if (ancestors.indexOf(parentCollection[j]) != -1) {
              isChildOf = true;
              break;
            }
          }

          ;
        }

        return isChildOf;
      },

      /**
       * Gets a set of elements containing all ancestors of each element in the
       * collection.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param filter {String?null} Optional selector to match
       * @return {qxWeb} Collection containing the ancestor elements
       */
      getAncestors: function getAncestors(filter) {
        return this.__getAncestors__P_198_0(null, filter);
      },

      /**
       * Gets a set of elements containing all ancestors of each element in the
       * collection, up to (but not including) the element matched by the provided
       * selector.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String} Selector that indicates where to stop including
       * ancestor elements
       * @param filter {String?null} Optional selector to match
       * @return {qxWeb} Collection containing the ancestor elements
       */
      getAncestorsUntil: function getAncestorsUntil(selector, filter) {
        return this.__getAncestors__P_198_0(selector, filter);
      },

      /**
       * Gets a set containing the closest matching ancestor for each item in
       * the collection.
       * If the item itself matches, it is added to the new set. Otherwise, the
       * item's parent chain will be traversed until a match is found.
       *
       * @attach {qxWeb}
       * @param selector {String} Selector expression to match
       * @return {qxWeb} New collection containing the closest matching ancestors
       */
      getClosest: function getClosest(selector) {
        var closest = [];

        var findClosest = function findClosest(current) {
          var found = qx.bom.Selector.matches(selector, current);

          if (found.length) {
            closest.push(found[0]);
          } else {
            current = current.getParents(); // One up

            if (current[0] && current[0].parentNode) {
              findClosest(current);
            }
          }
        };

        for (var i = 0; i < this.length; i++) {
          findClosest(qxWeb(this[i]));
        }

        ;
        return qxWeb.$init(closest, qxWeb);
      },

      /**
       * Searches the child elements of each item in the collection and returns
       * a new collection containing the children that match the provided selector
       *
       * @attach {qxWeb}
       * @param selector {String} Selector expression to match the child elements
       * against
       * @return {qxWeb} New collection containing the matching child elements
       */
      find: function find(selector) {
        var found = [];

        for (var i = 0; i < this.length; i++) {
          found = found.concat(qx.bom.Selector.query(selector, this[i]));
        }

        ;
        return qxWeb.$init(found, qxWeb);
      },

      /**
       * Gets a new set of elements containing the child nodes of each item in the
       * current set.
       *
       * @attach {qxWeb}
       * @return {qxWeb} New collection containing the child nodes
       */
      getContents: function getContents() {
        var found = [];

        this._forEachElement(function (item) {
          found = found.concat(qx.lang.Array.fromCollection(item.childNodes));
        });

        return qxWeb.$init(found, qxWeb);
      },

      /**
       * Checks if at least one element in the collection passes the provided
       * filter. This can be either a selector expression or a filter
       * function
       *
       * @attach {qxWeb}
       * @param selector {String|Function} Selector expression or filter function
       * @return {Boolean} <code>true</code> if at least one element matches
       */
      is: function is(selector) {
        if (qx.lang.Type.isFunction(selector)) {
          return this.filter(selector).length > 0;
        }

        return !!selector && qx.bom.Selector.matches(selector, this).length > 0;
      },

      /**
       * Reduce the set of matched elements to a single element.
       *
       * @attach {qxWeb}
       * @param index {Number} The position of the element in the collection
       * @return {qxWeb} A new collection containing one element
       */
      eq: function eq(index) {
        return this.slice(index, +index + 1);
      },

      /**
       * Reduces the collection to the first element.
       *
       * @attach {qxWeb}
       * @return {qxWeb} A new collection containing one element
       */
      getFirst: function getFirst() {
        return this.slice(0, 1);
      },

      /**
       * Reduces the collection to the last element.
       *
       * @attach {qxWeb}
       * @return {qxWeb} A new collection containing one element
       */
      getLast: function getLast() {
        return this.slice(this.length - 1);
      },

      /**
       * Gets a collection containing only the elements that have descendants
       * matching the given selector
       *
       * @attach {qxWeb}
       * @param selector {String} Selector expression
       * @return {qxWeb} a new collection containing only elements with matching descendants
       */
      has: function has(selector) {
        var found = [];

        this._forEachElement(function (item, index) {
          var descendants = qx.bom.Selector.matches(selector, this.eq(index).getContents());

          if (descendants.length > 0) {
            found.push(item);
          }
        });

        return qxWeb.$init(found, this.constructor);
      },

      /**
       * Returns a new collection containing only those nodes that
       * contain the given element. Also accepts a qxWeb
       * collection or an Array of elements. In those cases, the first element
       * in the list is used.
       *
       * @attach {qxWeb}
       * @param element {Element|Window|Element[]|qxWeb} element to check for.
       * @return {qxWeb} Collection with matching items
       */
      contains: function contains(element) {
        // qxWeb does not inherit from Array in IE
        if (element instanceof Array || element instanceof qxWeb) {
          element = element[0];
        }

        if (!element) {
          return qxWeb();
        }

        if (qx.dom.Node.isWindow(element)) {
          element = element.document;
        }

        return this.filter(function (el) {
          if (qx.dom.Node.isWindow(el)) {
            el = el.document;
          }

          return qx.dom.Hierarchy.contains(el, element);
        });
      },

      /**
       * Gets a collection containing the next sibling element of each item in
       * the current set.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing next siblings
       */
      getNext: function getNext(selector) {
        var found = this.map(qx.dom.Hierarchy.getNextElementSibling, qx.dom.Hierarchy);

        if (selector) {
          found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);
        }

        return found;
      },

      /**
       * Gets a collection containing all following sibling elements of each
       * item in the current set.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing following siblings
       */
      getNextAll: function getNextAll(selector) {
        var ret = qx.module.Traversing.__hierarchyHelper__P_198_4(this, "getNextSiblings", selector);

        return qxWeb.$init(ret, qxWeb);
      },

      /**
       * Gets a collection containing the following sibling elements of each
       * item in the current set up to but not including any element that matches
       * the given selector.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing following siblings
       */
      getNextUntil: function getNextUntil(selector) {
        var found = [];
        this.forEach(function (item, index) {
          var nextSiblings = qx.dom.Hierarchy.getNextSiblings(item);

          for (var i = 0, l = nextSiblings.length; i < l; i++) {
            if (qx.bom.Selector.matches(selector, [nextSiblings[i]]).length > 0) {
              break;
            }

            found.push(nextSiblings[i]);
          }
        });
        return qxWeb.$init(found, qxWeb);
      },

      /**
       * Gets a collection containing the previous sibling element of each item in
       * the current set.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing previous siblings
       */
      getPrev: function getPrev(selector) {
        var found = this.map(qx.dom.Hierarchy.getPreviousElementSibling, qx.dom.Hierarchy);

        if (selector) {
          found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);
        }

        return found;
      },

      /**
       * Gets a collection containing all preceding sibling elements of each
       * item in the current set.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing preceding siblings
       */
      getPrevAll: function getPrevAll(selector) {
        var ret = qx.module.Traversing.__hierarchyHelper__P_198_4(this, "getPreviousSiblings", selector);

        return qxWeb.$init(ret, qxWeb);
      },

      /**
       * Gets a collection containing the preceding sibling elements of each
       * item in the current set up to but not including any element that matches
       * the given selector.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing preceding siblings
       */
      getPrevUntil: function getPrevUntil(selector) {
        var found = [];
        this.forEach(function (item, index) {
          var previousSiblings = qx.dom.Hierarchy.getPreviousSiblings(item);

          for (var i = 0, l = previousSiblings.length; i < l; i++) {
            if (qx.bom.Selector.matches(selector, [previousSiblings[i]]).length > 0) {
              break;
            }

            found.push(previousSiblings[i]);
          }
        });
        return qxWeb.$init(found, qxWeb);
      },

      /**
       * Gets a collection containing all sibling elements of the items in the
       * current set.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing sibling elements
       */
      getSiblings: function getSiblings(selector) {
        var ret = qx.module.Traversing.__hierarchyHelper__P_198_4(this, "getSiblings", selector);

        return qxWeb.$init(ret, qxWeb);
      },

      /**
       * Remove elements from the collection that do not pass the given filter.
       * This can be either a selector expression or a filter function
       *
       * @attach {qxWeb}
       * @param selector {String|Function} Selector or filter function
       * @return {qxWeb} Reduced collection
       */
      not: function not(selector) {
        if (qx.lang.Type.isFunction(selector)) {
          return this.filter(function (item, index, obj) {
            return !selector(item, index, obj);
          });
        }

        var res = qx.bom.Selector.matches(selector, this);
        return this.filter(function (value) {
          return res.indexOf(value) === -1;
        });
      },

      /**
       * Gets a new collection containing the offset parent of each item in the
       * current set.
       *
       * @attach {qxWeb}
       * @return {qxWeb} New collection containing offset parents
       */
      getOffsetParent: function getOffsetParent() {
        return this.map(qx.bom.element.Location.getOffsetParent);
      },

      /**
       * Whether the first element in the collection is inserted into
       * the document for which it was created.
       *
       * @attach {qxWeb}
       * @return {Boolean} <code>true</code> when the element is inserted
       *    into the document.
       */
      isRendered: function isRendered() {
        if (!this[0]) {
          return false;
        }

        return qx.dom.Hierarchy.isRendered(this[0]);
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this); // manually attach private method which is ignored by attachAll

      qxWeb.$attach({
        "__getAncestors__P_198_0": statics.__getAncestors__P_198_0
      });
    }
  });
  qx.module.Traversing.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Environment": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Manipulating": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Traversing": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Css": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Attribute": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Provides a way to block elements so they will no longer receive (native)
   * events by overlaying them with a DIV element.
   *
   * @require(qx.module.Environment)
   * @require(qx.module.Manipulating)
   * @require(qx.module.Traversing)
   * @require(qx.module.Css)
   * @require(qx.module.Attribute)
   */
  qx.Bootstrap.define("qx.module.Blocker", {
    statics: {
      /**
       * Attaches a blocker div to the given element.
       *
       * @param item {Element|Document} The element to be overlaid with the blocker
       * @param color {String} The color for the blocker element (any CSS color value)
       * @param opacity {Number} The CSS opacity value for the blocker
       * @param zIndex {Number} The zIndex value for the blocker
       */
      __attachBlocker__P_190_0: function __attachBlocker__P_190_0(item, color, opacity, zIndex) {
        var win = qxWeb.getWindow(item);
        var isDocument = qxWeb.isDocument(item);

        if (!isDocument && !qxWeb.isElement(item)) {
          return;
        }

        if (!item.__blocker__P_190_1) {
          item.__blocker__P_190_1 = {
            div: qxWeb.create("<div class='qx-blocker' />")
          };
        }

        if (isDocument) {
          item.__blocker__P_190_1.div.insertBefore(qxWeb(win.document.body).getChildren(':first'));
        } else {
          item.__blocker__P_190_1.div.appendTo(win.document.body);
        }

        qx.module.Blocker.__styleBlocker__P_190_2(item, color, opacity, zIndex, isDocument);
      },

      /**
       * Styles the blocker element(s)
       *
       * @param item {Element|Document} The element to be overlaid with the blocker
       * @param color {String} The color for the blocker element (any CSS color value)
       * @param opacity {Number} The CSS opacity value for the blocker
       * @param zIndex {Number} The zIndex value for the blocker
       * @param isDocument {Boolean} Whether the item is a document node
       */
      __styleBlocker__P_190_2: function __styleBlocker__P_190_2(item, color, opacity, zIndex, isDocument) {
        var qItem = qxWeb(item);
        var styles = {
          "display": "block"
        };
        styles.backgroundColor = typeof color !== 'undefined' ? color : null;
        styles.zIndex = typeof zIndex !== 'undefined' ? zIndex : null;

        if (qxWeb.env.get("browser.name") === "ie" && qxWeb.env.get("browser.version") <= 8) {
          styles.opacity = typeof opacity !== 'undefined' ? opacity : 0;
        } else {
          styles.opacity = typeof opacity !== 'undefined' ? opacity : null;
        }

        if (isDocument) {
          styles.top = "0px";
          styles.left = "0px";
          styles.position = "fixed";
          styles.width = "100%";
          styles.height = "100%";
        } else {
          var pos = qItem.getOffset();
          styles.top = pos.top + "px";
          styles.left = pos.left + "px";
          styles.position = "absolute";
          styles.width = qItem.getWidth() + "px";
          styles.height = qItem.getHeight() + "px";
        }

        item.__blocker__P_190_1.div.setStyles(styles);
      },

      /**
       * Removes the given item's blocker element(s) from the DOM
       *
       * @param item {Element} Blocked element
       * @param index {Number} index of the item in the collection
       */
      __detachBlocker__P_190_3: function __detachBlocker__P_190_3(item, index) {
        if (!item.__blocker__P_190_1) {
          return;
        }

        item.__blocker__P_190_1.div.remove();
      },

      /**
       * Returns the blocker elements as collection
       *
       * @param collection {qxWeb} Collection to get the blocker elements from
       * @return {qxWeb} collection of blocker elements
       */
      __getBlocker__P_190_4: function __getBlocker__P_190_4(collection) {
        var blockerElements = qxWeb();
        collection.forEach(function (item, index) {
          if (typeof item.__blocker__P_190_1 !== "undefined") {
            blockerElements = blockerElements.concat(item.__blocker__P_190_1.div);
          }
        });
        return blockerElements;
      }
    },
    members: {
      /**
       * Adds an overlay to all items in the collection that intercepts mouse
       * events.
       *
       * @attach {qxWeb}
       * @param color {String ? transparent} The color for the blocker element (any CSS color value)
       * @param opacity {Number ? 0} The CSS opacity value for the blocker (floating point number from 0 to 1)
       * @param zIndex {Number ? 10000} The zIndex value for the blocker
       * @return {qxWeb} The collection for chaining
       */
      block: function block(color, opacity, zIndex) {
        if (!this[0]) {
          return this;
        }

        this.forEach(function (item, index) {
          qx.module.Blocker.__attachBlocker__P_190_0(item, color, opacity, zIndex);
        });
        return this;
      },

      /**
       * Removes the blockers from all items in the collection
       *
       * @attach {qxWeb}
       * @return {qxWeb} The collection for chaining
       */
      unblock: function unblock() {
        if (!this[0]) {
          return this;
        }

        this.forEach(qx.module.Blocker.__detachBlocker__P_190_3);
        return this;
      },

      /**
       * Returns all blocker elements as collection.
       *
       * <strong>Note:</strong> This will only return elements if
       * the <code>block</code> method was called at least once,
       * since the blocker elements are created on-demand.
       *
       * @attach {qxWeb}
       * @return {qxWeb} collection with all blocker elements
       */
      getBlocker: function getBlocker() {
        if (!this[0]) {
          return this;
        }

        var collection = qx.module.Blocker.__getBlocker__P_190_4(this);

        return collection;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.Blocker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Cookie": {
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Cookie handling module
   */
  qx.Bootstrap.define("qx.module.Cookie", {
    statics: {
      /**
       * Returns the string value of a cookie.
       *
       * @attachStatic {qxWeb, cookie.get}
       * @param key {String} The key for the saved string value.
       * @return {String|null} Returns the saved string value if the cookie
       *    contains a value for the key, otherwise <code>null</code>
       * @signature function(key)
       */
      get: qx.bom.Cookie.get,

      /**
       * Sets the string value of a cookie.
       *
       * @attachStatic {qxWeb, cookie.set}
       * @param key {String} The key for the string value.
       * @param value {String} The string value.
       * @param expires {Number?null} Expires directive value in days starting from now,
       *    or <code>null</code> if the cookie should be deleted when the browser
       *    is closed.
       * @param path {String?null} Path value.
       * @param domain {String?null} Domain value.
       * @param secure {Boolean?null} Secure flag.
       * @signature function(key, value, expires, path, domain, secure)
       */
      set: qx.bom.Cookie.set,

      /**
       * Deletes the string value of a cookie.
       *
       * @attachStatic {qxWeb, cookie.del}
       * @param key {String} The key for the string value.
       * @param path {String?null} Path value.
       * @param domain {String?null} Domain value.
       * @signature function(key, path, domain)
       */
      del: qx.bom.Cookie.del
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "cookie");
    }
  });
  qx.module.Cookie.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Attribute": {
        "require": true
      },
      "qx.module.Css": {
        "require": true
      },
      "qx.module.Environment": {
        "require": true
      },
      "qx.module.Event": {
        "require": true
      },
      "qx.module.Manipulating": {
        "require": true
      },
      "qx.module.Polyfill": {
        "require": true
      },
      "qx.module.Traversing": {
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * Placeholder class which simply defines and includes the core of qxWeb.
   * The core modules are:
   *
   * * {@link qx.module.Attribute}
   * * {@link qx.module.Css}
   * * {@link qx.module.Environment}
   * * {@link qx.module.Event}
   * * {@link qx.module.Manipulating}
   * * {@link qx.module.Polyfill}
   * * {@link qx.module.Traversing}
   *
   * @require(qx.module.Attribute)
   * @require(qx.module.Css)
   * @require(qx.module.Environment)
   * @require(qx.module.Event)
   * @require(qx.module.Manipulating)
   * @require(qx.module.Polyfill)
   * @require(qx.module.Traversing)
   */
  qx.Bootstrap.define("qx.module.Core", {});
  qx.module.Core.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.element.Dataset": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Romeo Kenfack (rkenfack)
  
  ************************************************************************ */

  /**
   * Module for handling of HTML5 data-* attributes
   */
  qx.Bootstrap.define("qx.module.Dataset", {
    members: {
      /**
       * Sets an HTML "data-*" attribute on each item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Name of the attribute [CamelCase variant]
       * @param value {var} New value of the attribute
       * @return {qxWeb} The collection for chaining
       */
      setData: function setData(name, value) {
        this._forEachElement(function (item) {
          qx.bom.element.Dataset.set(item, name, value);
        });

        return this;
      },

      /**
       *
       * Returns the value of the given HTML "data-*" attribute for the first item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Name of the attribute [CamelCase variant]
       * @return {var} The value of the attribute
       *
       */
      getData: function getData(name) {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Dataset.get(this[0], name);
        }
      },

      /**
       * Returns a map containing all the HTML "data-*" attributes of the specified element
       *
       * @attach {qxWeb}
       * @return {Map} The map containing the "data-*" attributes
       *
       */
      getAllData: function getAllData() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Dataset.getAll(this[0]);
        }

        return {};
      },

      /**
      * Checks if any element in the collection has a "data-*" attribute
      * @return {Boolean} True if any element in the collection has a "data-*" attribute
      */
      hasData: function hasData() {
        return qx.bom.element.Dataset.hasData(this[0]);
      },

      /**
       * Remove an HTML "data-*" attribute on each item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Name of the attribute
       * @return {qxWeb} The collection for chaining
       */
      removeData: function removeData(name) {
        this._forEachElement(function (item) {
          qx.bom.element.Dataset.remove(item, name);
        });

        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.Dataset.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.request.Xhr": {},
      "qx.bom.request.Script": {},
      "qx.bom.request.Jsonp": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This module provides basic IO functionality. It contains three ways to load
   * data:
   *
   * * XMLHttpRequest
   * * Script tag
   * * Script tag using JSONP
   *
   * @require(qx.bom.request.Xhr#open)
   *
   * @group (IO)
   */
  qx.Bootstrap.define("qx.module.Io", {
    statics: {
      /**
       * Returns a configured XMLHttpRequest object. Using the send method will
       * finally send the request.
       *
       * @param url {String} Mandatory URL to load the data from.
       * @param settings {Map?} Optional settings map which may contain one of
       *   the following settings:
       * <ul>
       * <li><code>method</code> The method of the request. Default: <code>GET</code></li>
       * <li><code>async</code> flag to mark the request as asynchronous. Default: <code>true</code></li>
       * <li><code>header</code> A map of request headers.</li>
       * </ul>
       *
       * @attachStatic {qxWeb, io.xhr}
       * @return {qx.bom.request.Xhr} The request object.
       */
      xhr: function xhr(url, settings) {
        if (!settings) {
          settings = {};
        }

        var xhr = new qx.bom.request.Xhr();
        xhr.open(settings.method, url, settings.async);

        if (settings.header) {
          var header = settings.header;

          for (var key in header) {
            xhr.setRequestHeader(key, header[key]);
          }
        }

        return xhr;
      },

      /**
       * Returns a predefined script tag wrapper which can be used to load data
       * from cross-domain origins.
       *
       * @param url {String} Mandatory URL to load the data from.
       * @attachStatic {qxWeb, io.script}
       * @return {qx.bom.request.Script} The request object.
       */
      script: function script(url) {
        var script = new qx.bom.request.Script();
        script.open("get", url);
        return script;
      },

      /**
       * Returns a predefined script tag wrapper which can be used to load data
       * from cross-domain origins via JSONP.
       *
       * @param url {String} Mandatory URL to load the data from.
       * @param settings {Map?} Optional settings map which may contain one of
       *   the following settings:
       *
       * * <code>callbackName</code>: The name of the callback which will
       *      be called by the loaded script.
       * * <code>callbackParam</code>: The name of the callback expected by the server
       * @attachStatic {qxWeb, io.jsonp}
       * @return {qx.bom.request.Jsonp} The request object.
       */
      jsonp: function jsonp(url, settings) {
        var script = new qx.bom.request.Jsonp();

        if (settings && settings.callbackName) {
          script.setCallbackName(settings.callbackName);
        }

        if (settings && settings.callbackParam) {
          script.setCallbackParam(settings.callbackParam);
        }

        script.setPrefix("qxWeb.$$"); // needed in case no callback name is given

        script.open("get", url);
        return script;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "io");
    }
  });
  qx.module.Io.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.MediaQuery": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Romeo Kenfack Tsakem (rkenfack)
       * Tobias Oberrauch (toberrauch)
  
  ************************************************************************ */

  /**
   * Module for mediaqueries evaluation. The module is a wrapper for media.match.js,
   * that implements a polyfill for window.matchMedia when it's not supported natively.
   */
  qx.Bootstrap.define("qx.module.MatchMedia", {
    statics: {
      /**
       * Evaluates the specified mediaquery list
       *
       * @param query {String} the media query to evaluate
       * @return {qx.bom.MediaQuery}  The media query
       * @attachStatic {qxWeb, matchMedia}
       */
      matchMedia: function matchMedia(query) {
        return new qx.bom.MediaQuery(query);
      },

      /**
       * Adds screen size classes (e.g. small-only or medium-up) by pre-defined media queries using em.
       * The range goes from small to medium, large and xlarge up to xxlarge:
       *
       * small: 0em - 40em
       * medium: 40.063em - 64em
       * large: 64.063em - 90em
       * xlarge: 90.063em - 120em
       * xxlarge: > 120.063em
       *
       * The suffix of the class name indicates either that the current screen
       * is larger than this size (*-up) or in that range (*-only).
       *
       * @attachStatic {qxWeb}
       */
      addSizeClasses: function addSizeClasses() {
        qxWeb("html").mediaQueryToClass("only screen", "small-up");
        qxWeb("html").mediaQueryToClass("only screen and (max-width: 40em)", "small-only");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 40.063em)", "medium-up");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 40.063em) and (max-width: 64em)", "medium-only");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 64.063em)", "large-up");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 64.063em) and (max-width: 90em)", "large-only");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 90.063em)", "xlarge-up");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 90.063em) and (max-width: 120em)", "xlarge-only");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 120.063em)", "xxlarge-up");
      },

      /**
       * Adds or removes a class depending on matching a given media query
       *
       * @param query {String} the media query to evaluate
       * @param className {String} css class name that gets bind to an element
       */
      __applyClass__P_194_0: function __applyClass__P_194_0(query, className) {
        if (query.isMatching()) {
          this.addClass(className);
        } else {
          this.removeClass(className);
        }
      }
    },
    members: {
      /**
       * Listens for media query updates and applies/removes the css class.
       *
       * @param queryString {String} the media query to evaluate
       * @param className {String} css class name that gets bind to an element
       *
       * @attach {qxWeb}
       * @return {qxWeb} Self instance for chaining
       */
      mediaQueryToClass: function mediaQueryToClass(queryString, className) {
        var query = qx.module.MatchMedia.matchMedia(queryString);

        var callback = qx.module.MatchMedia.__applyClass__P_194_0.bind(this, query, className); // apply classes initially


        callback(query, className);
        query.on("change", callback);
        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.MatchMedia.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      },
      "qx.event.Messaging": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * Define messages to react on certain channels.
   *
   * The channel names will be used in the q.messaging.on method to define handlers which will
   * be called on certain channels and routes. The q.messaging.emit method can be used
   * to execute a given route on a channel. q.messaging.onAny defines a handler on any channel.
   *
   * @require(qx.event.Messaging#on)
   * @require(qx.event.Messaging#onAny)
   * @require(qx.event.Messaging#remove)
   * @require(qx.event.Messaging#emit)
   */
  qx.Bootstrap.define("qx.module.Messaging", {
    statics: {
      /**
       * Adds a route handler for the given channel. The route is called
       * if the {@link #emit} method finds a match.
       *
       * @attachStatic{qxWeb, messaging.on}
       * @param channel {String} The channel of the message.
       * @param type {String|RegExp} The type, used for checking if the executed path matches.
       * @param handler {Function} The handler to call if the route matches the executed path.
       * @param scope {var ? null} The scope of the handler.
       * @return {String} The id of the route used to remove the route.
       * @signature function(channel, type, handler, scope)
       */
      on: null,

      /**
       * Adds a handler for the "any" channel. The "any" channel is called
       * before all other channels.
       *
       * @attachStatic{qxWeb, messaging.onAny}
       * @param type {String|RegExp} The route, used for checking if the executed path matches
       * @param handler {Function} The handler to call if the route matches the executed path
       * @param scope {var ? null} The scope of the handler.
       * @return {String} The id of the route used to remove the route.
       * @signature function(type, handler, scope)
       */
      onAny: null,

      /**
       * Removes a registered listener by the given id.
       *
       * @attachStatic{qxWeb, messaging.remove}
       * @param id {String} The id of the registered listener.
       * @signature function(id)
       */
      remove: null,

      /**
       * Sends a message on the given channel and informs all matching route handlers.
       *
       * @attachStatic{qxWeb, messaging.emit}
       * @param channel {String} The channel of the message.
       * @param path {String} The path to execute
       * @param params {Map} The given parameters that should be propagated
       * @param customData {var} The given custom data that should be propagated
       * @signature function(channel, path, params, customData)
       */
      emit: null
    },
    defer: function defer(statics) {
      qxWeb.$attachStatic({
        "messaging": new qx.event.Messaging()
      });
    }
  });
  qx.module.Messaging.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Manipulating": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Css": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Attribute": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Environment": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Polyfill": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Traversing": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * The module supplies a fallback implementation for placeholders, which is
   * used on input and textarea elements. If the browser supports native placeholders
   * the API silently ignores all calls. If not, an element will be created for every
   * given input element and acts as placeholder. Most modern browsers support
   * placeholders which makes the fallback only relevant for IE < 10 and FF < 4.
   *
   *  * <a href="http://dev.w3.org/html5/spec/single-page.html#the-placeholder-attribute">HTML Spec</a>
   *
   *  * <a href="http://caniuse.com/#feat=input-placeholder">Browser Support</a>
   *
   * @require(qx.module.Manipulating)
   * @require(qx.module.Css)
   * @require(qx.module.Attribute)
   * @require(qx.module.Event)
   * @require(qx.module.Environment)
   * @require(qx.module.Polyfill)
   * @require(qx.module.Traversing)
   */
  qx.Bootstrap.define("qx.module.Placeholder", {
    statics: {
      /**
       * String holding the property name which holds the placeholder
       * element for each input.
       */
      PLACEHOLDER_NAME: "$qx_placeholder",

      /**
       * Queries for all input and textarea elements on the page and updates
       * their placeholder.
       * @attachStatic{qxWeb, placeholder.update}
       */
      update: function update() {
        // ignore if native placeholder are supported
        if (!qxWeb.env.get("css.placeholder")) {
          qxWeb("input[placeholder], textarea[placeholder]").updatePlaceholder();
        }
      },

      /**
       * Internal helper method to update the styles for a given input element.
       * @param item {qxWeb} The input element to update.
       */
      __syncStyles__P_195_0: function __syncStyles__P_195_0(item) {
        var placeholder = item.getAttribute("placeholder");
        var placeholderEl = item.getProperty(qx.module.Placeholder.PLACEHOLDER_NAME);
        var zIndex = item.getStyle("z-index");
        var paddingHor = parseInt(item.getStyle("padding-left")) + 2 * parseInt(item.getStyle("padding-right"));
        var paddingVer = parseInt(item.getStyle("padding-top")) + 2 * parseInt(item.getStyle("padding-bottom"));
        placeholderEl.setHtml(placeholder).setStyles({
          display: item.getValue() == "" ? "inline" : "none",
          zIndex: zIndex == "auto" ? 1 : zIndex + 1,
          textAlign: item.getStyle("text-align"),
          width: item.getWidth() - paddingHor - 4 + "px",
          height: item.getHeight() - paddingVer - 4 + "px",
          left: item.getPosition().left + "px",
          top: item.getPosition().top + "px",
          fontFamily: item.getStyle("font-family"),
          fontStyle: item.getStyle("font-style"),
          fontVariant: item.getStyle("font-variant"),
          fontWeight: item.getStyle("font-weight"),
          fontSize: item.getStyle("font-size"),
          paddingTop: parseInt(item.getStyle("padding-top")) + 2 + "px",
          paddingRight: parseInt(item.getStyle("padding-right")) + 2 + "px",
          paddingBottom: parseInt(item.getStyle("padding-bottom")) + 2 + "px",
          paddingLeft: parseInt(item.getStyle("padding-left")) + 2 + "px"
        });
      },

      /**
       * Creates a placeholder element based on the given input element.
       * @param item {qxWeb} The input element.
       * @return {qxWeb} The placeholder element.
       */
      __createPlaceholderElement__P_195_1: function __createPlaceholderElement__P_195_1(item) {
        // create the label with initial styles
        var placeholderEl = qxWeb.create("<label>").setStyles({
          position: "absolute",
          color: "#989898",
          overflow: "hidden",
          pointerEvents: "none"
        }); // store the label at the input field

        item.setProperty(qx.module.Placeholder.PLACEHOLDER_NAME, placeholderEl); // update the placeholders visibility on keyUp

        item.on("keyup", function (item) {
          var el = item.getProperty(qx.module.Placeholder.PLACEHOLDER_NAME);
          el.setStyle("display", item.getValue() == "" ? "inline" : "none");
        }.bind(this, item)); // for browsers not supporting pointer events

        if (!qxWeb.env.get("css.pointerevents")) {
          placeholderEl.setStyle("cursor", "text").on("tap", function (item) {
            item.focus();
          }.bind(this, item));
        }

        return placeholderEl;
      }
    },
    members: {
      /**
       * Updates the placeholders for input's and textarea's in the collection.
       * This includes positioning, styles and DOM positioning.
       * In case the browser supports native placeholders, this methods simply
       * does nothing.
       *
       * @attach {qxWeb}
       * @return {qxWeb} The collection for chaining
       */
      updatePlaceholder: function updatePlaceholder() {
        // ignore everything if native placeholder are supported
        if (!qxWeb.env.get("css.placeholder")) {
          for (var i = 0; i < this.length; i++) {
            var item = qxWeb(this[i]); // ignore all not fitting items in the collection

            var placeholder = item.getAttribute("placeholder");
            var tagName = item.getProperty("tagName");

            if (!placeholder || tagName != "TEXTAREA" && tagName != "INPUT") {
              continue;
            } // create the element if necessary


            var placeholderEl = item.getProperty(qx.module.Placeholder.PLACEHOLDER_NAME);

            if (!placeholderEl) {
              placeholderEl = qx.module.Placeholder.__createPlaceholderElement__P_195_1(item);
            } // remove and add handling


            var itemInBody = item.isRendered();
            var placeholderElInBody = placeholderEl.isRendered();

            if (itemInBody && !placeholderElInBody) {
              item.before(placeholderEl);
            } else if (!itemInBody && placeholderElInBody) {
              placeholderEl.remove();
              return this;
            }

            qx.module.Placeholder.__syncStyles__P_195_0(item);
          }

          ;
        }

        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "placeholder");
    }
  });
  qx.module.Placeholder.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.util.placement.KeepAlignAxis": {},
      "qx.util.placement.BestFitAxis": {},
      "qx.util.placement.DirectAxis": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * The Placement module provides a convenient way to align two elements relative
   * to each other using various pre-defined algorithms.
   *
   * @require(qx.util.placement.KeepAlignAxis#computeStart)
   * @require(qx.util.placement.BestFitAxis#computeStart)
   * @require(qx.util.placement.DirectAxis#computeStart)
   */
  qx.Bootstrap.define("qx.module.Placement", {
    statics: {
      /**
       * Returns the appropriate axis implementation for the given placement
       * mode
       *
       * @param mode {String} Placement mode
       * @return {Object} Placement axis class
       */
      _getAxis: function _getAxis(mode) {
        switch (mode) {
          case "keep-align":
            return qx.util.placement.KeepAlignAxis;

          case "best-fit":
            return qx.util.placement.BestFitAxis;

          case "direct":
          default:
            return qx.util.placement.DirectAxis;
        }
      },

      /**
       * Returns the computed coordinates for the element to be placed
       *
       * @param axes {Map} Map with the keys <code>x</code> and <code>y</code>. Values
       * are the axis implementations
       * @param size {Map} Map with the keys <code>width</code> and <code>height</code>
       * containing the size of the placement target
       * @param area {Map} Map with the keys <code>width</code> and <code>height</code>
       * containing the size of the two elements' common parent (available space for
       * placement)
       * @param target {Map} Location of the object to align the object to. This map
       * should have the keys <code>left</code>, <code>top</code>, <code>right</code>
       * and <code>bottom</code>
       * @param offsets {Map} Map of offsets (top, right, bottom, left)
       * @param position {Map} Map with the keys <code>x</code> and <code>y</code>,
       * containing the type of positioning for each axis
       * @return {Map} Map with the keys <code>left</code> and <code>top</code>
       * containing the computed coordinates to which the element should be moved
       */
      _computePlacement: function _computePlacement(axes, size, area, target, offsets, position) {
        var left = axes.x.computeStart(size.width, {
          start: target.left,
          end: target.right
        }, {
          start: offsets.left,
          end: offsets.right
        }, area.width, position.x);
        var top = axes.y.computeStart(size.height, {
          start: target.top,
          end: target.bottom
        }, {
          start: offsets.top,
          end: offsets.bottom
        }, area.height, position.y);
        return {
          left: left,
          top: top
        };
      },

      /**
       * Returns the X axis positioning type for the given edge and alignment
       * values
       *
       * @param edge {String} edge value
       * @param align {String} align value
       * @return {String} X positioning type
       */
      _getPositionX: function _getPositionX(edge, align) {
        if (edge == "left") {
          return "edge-start";
        } else if (edge == "right") {
          return "edge-end";
        } else if (align == "left") {
          return "align-start";
        } else if (align == "center") {
          return "align-center";
        } else if (align == "right") {
          return "align-end";
        }
      },

      /**
       * Returns the Y axis positioning type for the given edge and alignment
       * values
       *
       * @param edge {String} edge value
       * @param align {String} align value
       * @return {String} Y positioning type
       */
      _getPositionY: function _getPositionY(edge, align) {
        if (edge == "top") {
          return "edge-start";
        } else if (edge == "bottom") {
          return "edge-end";
        } else if (align == "top") {
          return "align-start";
        } else if (align == "middle") {
          return "align-center";
        } else if (align == "bottom") {
          return "align-end";
        }
      }
    },
    members: {
      /**
       * Moves the first element in the collection, aligning it with the given
       * target.
       *
       * <div>
       * <strong>NOTE:</strong> The <code>placeTo</code> method also works for hidden
       * elements. However, the visibility / display styles are only manipulated during
       * the placement operation. As a result a previously hidden element <strong>stays hidden</strong>
       * </div>
       *
       * <div>
       * <strong>NOTE:</strong> If the target is changing its position due e.g. a DOM manipulation the
       * placed element <strong>is not</strong> updated automatically. You have to call <code>placeTo</code>
       * again to place the element to the target. The element is <strong>always</strong> positioned by using
       * <code>position:absolute</code> independently on the chosen <code>position</code> and <code>mode</code>.
       * </div>
       *
       * @attach{qxWeb}
       * @param target {Element} Placement target
       * @param position {String} Alignment of the object with the target, any of
       * <code>"top-left"</code>, <code>"top-center"</code>, <code>"top-right"</code>,
       * <code>"bottom-left"</code>, <code>"bottom-center"</code>, <code>"bottom-right"</code>,
       * <code>"left-top"</code>, <code>"left-middle"</code>, <code>"left-bottom"</code>,
       * <code>"right-top"</code>, <code>"right-middle"</code>, <code>"right-bottom"</code>
       * @param offsets {Map?null} Map with the desired offsets between the two elements.
       * Must contain the keys <code>left</code>, <code>top</code>,
       * <code>right</code> and <code>bottom</code>
       * @param modeX {String?"direct"} Horizontal placement mode. Valid values are:
       *   <ul>
       *   <li><code>direct</code>: place the element directly at the given
       *   location.</li>
       *   <li><code>keep-align</code>: if the element is partially outside of the
       *   visible area, it is moved to the best fitting 'edge' and 'alignment' of
       *   the target.
       *   It is guaranteed the the new position attaches the object to one of the
       *   target edges and that it is aligned with a target edge.</li>
       *   <li><code>best-fit</code>: If the element is partially outside of the visible
       *   area, it is moved into the view port, ignoring any offset and position
       *   values.</li>
       *   </ul>
       * @param modeY {String?"direct"} Vertical placement mode. Accepts the same values as
       *   the 'modeX' argument.
       * @return {qxWeb} The collection for chaining
       */
      placeTo: function placeTo(target, position, offsets, modeX, modeY) {
        if (!this[0] || !target) {
          return this;
        }

        target = qxWeb(target); // make sure the DOM elements are rendered so we can get the size of them.
        // It's not necessary to move them out of the viewport - just out of the
        // layout flow.

        var visible = this.isRendered() && this[0].offsetWidth > 0 && this[0].offsetHeight > 0;
        var displayStyleValue = null;
        var visibilityStyleValue = null;

        if (!visible) {
          // do not use the computed style value otherwise we will mess up the styles
          // when resetting them, since these styles might also be set via a CSS class.
          displayStyleValue = this[0].style.display;
          visibilityStyleValue = this[0].style.visibility;
          this.setStyles({
            position: "absolute",
            visibility: "hidden",
            display: "block"
          });
        }

        var axes = {
          x: qx.module.Placement._getAxis(modeX),
          y: qx.module.Placement._getAxis(modeY)
        };
        var size = {
          width: this.getWidth(),
          height: this.getHeight()
        };
        var parent = this.getParents();
        var area = {
          width: parent.getWidth(),
          height: parent.getHeight()
        };
        offsets = offsets || {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        };
        var split = position.split("-");
        var edge = split[0];
        var align = split[1];
        var newPosition = {
          x: qx.module.Placement._getPositionX(edge, align),
          y: qx.module.Placement._getPositionY(edge, align)
        };
        var targetLocation;
        var parentPositioning = parent.getStyle("position");

        if (parentPositioning == "relative" || parentPositioning == "static") {
          targetLocation = target.getOffset();
        } else {
          var targetPos = target.getPosition();
          targetLocation = {
            top: targetPos.top,
            bottom: targetPos.top + target.getHeight(),
            left: targetPos.left,
            right: targetPos.left + target.getWidth()
          };
        }

        var newLocation = qx.module.Placement._computePlacement(axes, size, area, targetLocation, offsets, newPosition);

        while (parent.length > 0) {
          if (parent.getStyle("position") == "relative") {
            var offset = parent.getOffset();
            var borderTop = parseInt(parent.getStyle("border-top-width")) || 0;
            var borderLeft = parseInt(parent.getStyle("border-left-width")) || 0;
            newLocation.left -= offset.left + borderLeft;
            newLocation.top -= offset.top + borderTop;
            parent = [];
          } else {
            parent = parent.getParents();
          }
        } // Reset the styles to hide the element if it was previously hidden


        if (!visible) {
          this[0].style.display = displayStyleValue;
          this[0].style.visibility = visibilityStyleValue;
        }

        this.setStyles({
          position: "absolute",
          left: newLocation.left + "px",
          top: newLocation.top + "px"
        });
        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.Placement.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.rest.Resource": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /**
   * This modules eases the communication with a RESTful web service by providing
   * a client-side wrapper of a REST resource.
   *
   * See {@link qx.bom.rest.Resource}.
   *
   * @group (IO)
   */
  qx.Bootstrap.define("qx.module.Rest", {
    statics: {
      /**
       * @param description {Map?} Each key of the map is interpreted as
       *  <code>action</code> name. The value associated to the key must be a map
       *  with the properties <code>method</code> and <code>url</code>.
       *  <code>check</code> is optional. Also see {@link qx.bom.rest.Resource#map}.
       *
       * @attachStatic {qxWeb, rest.resource}
       * @return {qx.bom.rest.Resource} The resource object.
       */
      resource: function resource(description) {
        return new qx.bom.rest.Resource(description);
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "rest");
    }
  });
  qx.module.Rest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Storage": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This module offers a cross browser storage implementation. The API is aligned
   * with the API of the HTML web storage (http://www.w3.org/TR/webstorage/) which is
   * also the preferred implementation used. As fallback for IE < 8, we use user data.
   * If both techniques are unsupported, we supply a in memory storage, which is
   * of course, not persistent.
   */
  qx.Bootstrap.define("qx.module.Storage", {
    statics: {
      /**
       * Store an item in the storage.
       *
       * @attachStatic {qxWeb, localStorage.setItem}
       * @param key {String} The identifier key.
       * @param value {var} The data, which will be stored as JSON.
       */
      setLocalItem: function setLocalItem(key, value) {
        qx.bom.Storage.getLocal().setItem(key, value);
      },

      /**
       * Returns the stored item.
       *
       * @attachStatic {qxWeb, localStorage.getItem}
       * @param key {String} The identifier to get the data.
       * @return {var} The stored data.
       */
      getLocalItem: function getLocalItem(key) {
        return qx.bom.Storage.getLocal().getItem(key);
      },

      /**
       * Removes an item form the storage.
       * @attachStatic {qxWeb, localStorage.removeItem}
       * @param key {String} The identifier.
       */
      removeLocalItem: function removeLocalItem(key) {
        qx.bom.Storage.getLocal().removeItem(key);
      },

      /**
       * Returns the amount of key-value pairs stored.
       * @attachStatic {qxWeb, localStorage.getLength}
       * @return {Number} The length of the storage.
       */
      getLocalLength: function getLocalLength() {
        return qx.bom.Storage.getLocal().getLength();
      },

      /**
       * Returns the named key at the given index.
       * @attachStatic {qxWeb, localStorage.getKey}
       * @param index {Number} The index in the storage.
       * @return {String} The key stored at the given index.
       */
      getLocalKey: function getLocalKey(index) {
        return qx.bom.Storage.getLocal().getKey(index);
      },

      /**
       * Deletes every stored item in the storage.
       * @attachStatic {qxWeb, localStorage.clear}
       */
      clearLocal: function clearLocal() {
        qx.bom.Storage.getLocal().clear();
      },

      /**
       * Helper to access every stored item.
       *
       * @attachStatic {qxWeb, localStorage.forEach}
       * @param callback {Function} A function which will be called for every item.
       *   The function will have two arguments, first the key and second the value
       *    of the stored data.
       * @param scope {var} The scope of the function.
       */
      forEachLocal: function forEachLocal(callback, scope) {
        qx.bom.Storage.getLocal().forEach(callback, scope);
      },

      /**
       * Store an item in the storage.
       *
       * @attachStatic {qxWeb, sessionStorage.setItem}
       * @param key {String} The identifier key.
       * @param value {var} The data, which will be stored as JSON.
       */
      setSessionItem: function setSessionItem(key, value) {
        qx.bom.Storage.getSession().setItem(key, value);
      },

      /**
       * Returns the stored item.
       *
       * @attachStatic {qxWeb, sessionStorage.getItem}
       * @param key {String} The identifier to get the data.
       * @return {var} The stored data.
       */
      getSessionItem: function getSessionItem(key) {
        return qx.bom.Storage.getSession().getItem(key);
      },

      /**
       * Removes an item form the storage.
       * @attachStatic {qxWeb, sessionStorage.removeItem}
       * @param key {String} The identifier.
       */
      removeSessionItem: function removeSessionItem(key) {
        qx.bom.Storage.getSession().removeItem(key);
      },

      /**
       * Returns the amount of key-value pairs stored.
       * @attachStatic {qxWeb, sessionStorage.getLength}
       * @return {Number} The length of the storage.
       */
      getSessionLength: function getSessionLength() {
        return qx.bom.Storage.getSession().getLength();
      },

      /**
       * Returns the named key at the given index.
       * @attachStatic {qxWeb, sessionStorage.getKey}
       * @param index {Number} The index in the storage.
       * @return {String} The key stored at the given index.
       */
      getSessionKey: function getSessionKey(index) {
        return qx.bom.Storage.getSession().getKey(index);
      },

      /**
       * Deletes every stored item in the storage.
       * @attachStatic {qxWeb, sessionStorage.clear}
       */
      clearSession: function clearSession() {
        qx.bom.Storage.getSession().clear();
      },

      /**
       * Helper to access every stored item.
       *
       * @attachStatic {qxWeb, sessionStorage.forEach}
       * @param callback {Function} A function which will be called for every item.
       *   The function will have two arguments, first the key and second the value
       *    of the stored data.
       * @param scope {var} The scope of the function.
       */
      forEachSession: function forEachSession(callback, scope) {
        qx.bom.Storage.getSession().forEach(callback, scope);
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachStatic({
        "localStorage": {
          setItem: statics.setLocalItem,
          getItem: statics.getLocalItem,
          removeItem: statics.removeLocalItem,
          getLength: statics.getLocalLength,
          getKey: statics.getLocalKey,
          clear: statics.clearLocal,
          forEach: statics.forEachLocal
        },
        "sessionStorage": {
          setItem: statics.setSessionItem,
          getItem: statics.getSessionItem,
          removeItem: statics.removeSessionItem,
          getLength: statics.getSessionLength,
          getKey: statics.getSessionKey,
          clear: statics.clearSession,
          forEach: statics.forEachSession
        }
      });
    }
  });
  qx.module.Storage.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Template": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * HTML templating module. This is a wrapper for mustache.js which is a
   * "framework-agnostic way to render logic-free views".
   *
   * For further details, please visit the mustache.js documentation here:
   *   https://github.com/janl/mustache.js/blob/master/README.md
   */
  qx.Bootstrap.define("qx.module.Template", {
    statics: {
      /**
       * Helper method which provides direct access to templates stored as HTML in
       * the DOM. The DOM node with the given ID will be treated as a template,
       * parsed and a new DOM element will be returned containing the parsed data.
       * Keep in mind that templates can only have one root element.
       * Additionally, you should not put the template into a regular, hidden
       * DOM element because the template may not be valid HTML due to the containing
       * mustache tags. We suggest to put it into a script tag with the type
       * <code>text/template</code>.
       *
       * @attachStatic{qxWeb, template.get}
       * @param id {String} The id of the HTML template in the DOM.
       * @param view {Object} The object holding the data to render.
       * @param partials {Object} Object holding parts of a template.
       * @return {qxWeb} Collection containing a single DOM element with the parsed
       * template data.
       */
      get: function get(id, view, partials) {
        var el = qx.bom.Template.get(id, view, partials);
        el = qx.module.Template.__wrap__P_196_0(el);
        return qxWeb.$init([el], qxWeb);
      },

      /**
       * Original and only template method of mustache.js. For further
       * documentation, please visit <a href="https://github.com/janl/mustache.js">mustache.js</a>.
       *
       * @attachStatic{qxWeb, template.render}
       * @param template {String} The String containing the template.
       * @param view {Object} The object holding the data to render.
       * @param partials {Object} Object holding parts of a template.
       * @return {String} The parsed template.
       */
      render: function render(template, view, partials) {
        return qx.bom.Template.render(template, view, partials);
      },

      /**
       * Combines {@link #render} and {@link #get}. Input is equal to {@link #render}
       * and output is equal to {@link #get}. The advantage over {@link #get}
       * is that you don't need a HTML template but can use a template
       * string and still get a collection. Keep in mind that templates
       * can only have one root element.
       *
       * @attachStatic{qxWeb, template.renderToNode}
       * @param template {String} The String containing the template.
       * @param view {Object} The object holding the data to render.
       * @param partials {Object} Object holding parts of a template.
       * @return {qxWeb} Collection containing a single DOM element with the parsed
       * template data.
       */
      renderToNode: function renderToNode(template, view, partials) {
        var el = qx.bom.Template.renderToNode(template, view, partials);
        el = qx.module.Template.__wrap__P_196_0(el);
        return qxWeb.$init([el], qxWeb);
      },

      /**
       * If the given node is a DOM text node, wrap it in a span element and return
       * the wrapper.
       * @param el {Node} a DOM node
       * @return {Element} Original element or wrapper
       */
      __wrap__P_196_0: function __wrap__P_196_0(el) {
        if (qxWeb.isTextNode(el)) {
          var wrapper = document.createElement("span");
          wrapper.appendChild(el);
          el = wrapper;
        }

        return el;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "template");
    }
  });
  qx.module.Template.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Selection": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Text selection manipulation module
   */
  qx.Bootstrap.define("qx.module.TextSelection", {
    statics: {
      /**
       * Checks if the given DOM node is a text input field or textarea
       *
       * @param el {Element} The node to check
       * @return {Boolean} <code>true</code> if the given node is an input field
       *
       * @attach {qxWeb}
       */
      __isInput__P_197_0: function __isInput__P_197_0(el) {
        var tag = el.tagName ? el.tagName.toLowerCase() : null;
        return tag === "input" || tag === "textarea";
      },

      /**
       * Returns the first text child node of the given element
       *
       * @param el {Element} DOM element
       * @return {Node|null} text node
       *
       * @attach {qxWeb}
       */
      __getTextNode__P_197_1: function __getTextNode__P_197_1(el) {
        for (var i = 0, l = el.childNodes.length; i < l; i++) {
          if (el.childNodes[i].nodeType === 3) {
            return el.childNodes[i];
          }
        }

        return null;
      }
    },
    members: {
      /**
       * Get the text selection of the first element.
       *
       * @return {String|null}
       */
      getTextSelection: function getTextSelection() {
        var el = this[0];

        if (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          return el ? qx.bom.Selection.get(el) : null;
        }

        return null;
      },

      /**
       * Get the length of the text selection of the first element.
       *
       *
       * @return {Integer|null}
       *
       * @attach {qxWeb}
       */
      getTextSelectionLength: function getTextSelectionLength() {
        var el = this[0];

        if (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          return el ? qx.bom.Selection.getLength(el) : null;
        }

        return null;
      },

      /**
       * Get the start of the text selection of the first element.
       *
       * @return {Integer|null}
       *
       * @attach {qxWeb}
       */
      getTextSelectionStart: function getTextSelectionStart() {
        var el = this[0];

        if (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          return el ? qx.bom.Selection.getStart(el) : null;
        }

        return null;
      },

      /**
       * Get the end of the text selection of the first element.
       *
       * @return {Integer|null}
       *
       * @attach {qxWeb}
       */
      getTextSelectionEnd: function getTextSelectionEnd() {
        var el = this[0];

        if (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          return el ? qx.bom.Selection.getEnd(el) : null;
        }

        return null;
      },

      /**
       * Set the text selection of the first element in the collection
       * with the given start and end value.
       * If no end value is passed the selection will extend to the end.
       *
       * @param start {Integer} start of the selection (zero based)
       * @param end {Integer} end of the selection
       * @return {qxWeb} The collection for chaining.
       *
       * @attach {qxWeb}
       */
      setTextSelection: function setTextSelection(start, end) {
        var el = this[0];

        if (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          if (el) {
            qx.bom.Selection.set(el, start, end);
          }
        }

        return this;
      },

      /**
       * Clears the text selection of all elements.
       *
       * @return {qxWeb} The collection for chaining.
       *
       * @attach {qxWeb}
       */
      clearTextSelection: function clearTextSelection() {
        this._forEachElement(function (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          if (el) {
            qx.bom.Selection.clear(el);
          }
        });

        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.TextSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.element.Transform": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This class is responsible for applying CSS3 transforms to the collection.
   * The implementation is mostly a cross browser wrapper for applying the
   * transforms.
   * The API is keep to the spec as close as possible.
   *
   * http://www.w3.org/TR/css3-3d-transforms/
   */
  qx.Bootstrap.define("qx.module.Transform", {
    members: {
      /**
       * Method to apply multiple transforms at once to the given element. It
       * takes a map containing the transforms you want to apply plus the values
       * e.g.<code>{scale: 2, rotate: "5deg"}</code>.
       * The values can be either singular, which means a single value will
       * be added to the CSS. If you give an array, the values will be split up
       * and each array entry will be used for the X, Y or Z dimension in that
       * order e.g. <code>{scale: [2, 0.5]}</code> will result in a element
       * double the size in X direction and half the size in Y direction.
       * Make sure your browser supports all transformations you apply.
       *
       * @attach {qxWeb}
       * @param transforms {Map} The map containing the transforms and value.
       * @return {qxWeb} This reference for chaining.
       */
      transform: function transform(transforms) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.transform(el, transforms);
        });

        return this;
      },

      /**
       * Translates by the given value. For further details, take
       * a look at the {@link #transform} method.
       *
       * @attach {qxWeb}
       * @param value {String|Array} The value to translate e.g. <code>"10px"</code>.
       * @return {qxWeb} This reference for chaining.
       */
      translate: function translate(value) {
        return this.transform({
          translate: value
        });
      },

      /**
       * Scales by the given value. For further details, take
       * a look at the {@link #transform} method.
       *
       * @attach {qxWeb}
       * @param value {Number|Array} The value to scale.
       * @return {qxWeb} This reference for chaining.
       */
      scale: function scale(value) {
        return this.transform({
          scale: value
        });
      },

      /**
       * Rotates by the given value. For further details, take
       * a look at the {@link #transform} method.
       *
       * @attach {qxWeb}
       * @param value {String|Array} The value to rotate e.g. <code>"90deg"</code>.
       * @return {qxWeb} This reference for chaining.
       */
      rotate: function rotate(value) {
        return this.transform({
          rotate: value
        });
      },

      /**
       * Skews by the given value. For further details, take
       * a look at the {@link #transform} method.
       *
       * @attach {qxWeb}
       * @param value {String|Array} The value to skew e.g. <code>"90deg"</code>.
       * @return {qxWeb} This reference for chaining.
       */
      skew: function skew(value) {
        return this.transform({
          skew: value
        });
      },

      /**
       * Sets the transform-origin property.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-origin-property
       *
       * @attach {qxWeb}
       * @param value {String} CSS position values like <code>50% 50%</code> or
       *   <code>left top</code>.
       * @return {qxWeb} This reference for chaining.
       */
      setTransformOrigin: function setTransformOrigin(value) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.setOrigin(el, value);
        });

        return this;
      },

      /**
       * Returns the transform-origin property of the first element.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-origin-property
       *
       * @attach {qxWeb}
       * @return {String} The set property, e.g. <code>50% 50%</code> or null,
       *   of the collection is empty.
       */
      getTransformOrigin: function getTransformOrigin() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Transform.getOrigin(this[0]);
        }

        return "";
      },

      /**
       * Sets the transform-style property.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-style-property
       *
       * @attach {qxWeb}
       * @param value {String} Either <code>flat</code> or <code>preserve-3d</code>.
       * @return {qxWeb} This reference for chaining.
       */
      setTransformStyle: function setTransformStyle(value) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.setStyle(el, value);
        });

        return this;
      },

      /**
       * Returns the transform-style property of the first element.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-style-property
       *
       * @attach {qxWeb}
       * @return {String} The set property, either <code>flat</code> or
       *   <code>preserve-3d</code>.
       */
      getTransformStyle: function getTransformStyle() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Transform.getStyle(this[0]);
        }

        return "";
      },

      /**
       * Sets the perspective property.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-property
       *
       * @attach {qxWeb}
       * @param value {Number} The perspective layer. Numbers between 100
       *   and 5000 give the best results.
       * @return {qxWeb} This reference for chaining.
       */
      setTransformPerspective: function setTransformPerspective(value) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.setPerspective(el, value);
        });

        return this;
      },

      /**
       * Returns the perspective property of the first element.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-property
       *
       * @attach {qxWeb}
       * @return {String} The set property, e.g. <code>500</code>
       */
      getTransformPerspective: function getTransformPerspective() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Transform.getPerspective(this[0]);
        }

        return "";
      },

      /**
       * Sets the perspective-origin property.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-origin-property
       *
       * @attach {qxWeb}
       * @param value {String} CSS position values like <code>50% 50%</code> or
       *   <code>left top</code>.
       * @return {qxWeb} This reference for chaining.
       */
      setTransformPerspectiveOrigin: function setTransformPerspectiveOrigin(value) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.setPerspectiveOrigin(el, value);
        });

        return this;
      },

      /**
       * Returns the perspective-origin property of the first element.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-origin-property
       *
       * @attach {qxWeb}
       * @return {String} The set property, e.g. <code>50% 50%</code>
       */
      getTransformPerspectiveOrigin: function getTransformPerspectiveOrigin() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Transform.getPerspectiveOrigin(this[0]);
        }

        return "";
      },

      /**
       * Sets the backface-visibility property.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#backface-visibility-property
       *
       * @attach {qxWeb}
       * @param value {Boolean} <code>true</code> if the backface should be visible.
       * @return {qxWeb} This reference for chaining.
       */
      setTransformBackfaceVisibility: function setTransformBackfaceVisibility(value) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.setBackfaceVisibility(el, value);
        });

        return this;
      },

      /**
       * Returns the backface-visibility property of the first element.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#backface-visibility-property
       *
       * @attach {qxWeb}
       * @return {Boolean} <code>true</code>, if the backface is visible.
       */
      getTransformBackfaceVisibility: function getTransformBackfaceVisibility() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Transform.getBackfaceVisibility(this[0]);
        }

        return "";
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.Transform.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.FakeServer": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /**
   * A wrapper around Sinon.JS's FakeXMLHttpRequest and FakeServer features that
   * allows quick and simple configuration of mock HTTP backends for testing and
   * development.
   * Automatically creates URL filtering rules to ensure that only configured
   * requests are faked while others will be processed normally by the browser's
   * XHR implementation.
   *
   * @group (IO)
   */
  qx.Bootstrap.define("qx.module.dev.FakeServer", {
    statics: {
      /**
       * Configures a set of fake HTTP responses. Each response is defined as a map
       * that must provide the following keys:
       * <ul>
       *   <li><code>method</code> HTTP method to respond to, e.g. <code>PUT</code></li>
       *   <li><code>url</code> URL used to match requests to fake responses. Can be
       *   a RegExp or a String. REST-style parameter placeholders in curly braces
       *   will be replaced with wildcards, e.g. the string "/resource/{resourceId}"
       *   is interpreted as the RegExp <code>/\/resource\/\{.*?\}/</code>
       *   <li><code>response</code> This can be either:
       *     <ul>
       *       <li>a string: This will be the response body, status code will be 200</li>
       *       <li>an array containing the status code, a map of response headers and
       *         the response text, e.g. <code>[200, { "Content-Type": "text/html" }, "OK"]</code>
       *       </li>
       *       <li>a function: This will be called with a FakeXMLHttpRequest object as
       *       the only argument. Its <code>respond</code> method must be called to send a response.
       *       See <a href="http://sinonjs.org/docs/#respond">Sinon.JS: Respond</a> for details.
       *       </li>
       *     </ul>
       *   </li>
       * </ul>
       *
       * @attachStatic {qxWeb, dev.fakeServer.configure}
       * @param responseData {Map[]} An array of response description maps.
       */
      configure: function configure(responseData) {
        qx.dev.FakeServer.getInstance().configure(responseData);
      },

      /**
       * Removes a response that was configured with {@link #configure}
       * @param method {String} HTTP method of the response
       * @param url {String|RegExp} URL of the response
       *
       * @attachStatic {qxWeb, dev.fakeServer.removeResponse}
       */
      removeResponse: function removeResponse(method, url) {
        qx.dev.FakeServer.getInstance().removeResponse(method, url);
      },

      /**
       * Adds a URL filtering function to decide whether a request should be handled
       * by the FakeServer or passed to the regular XMLHttp implementation.
       * See <a href="http://sinonjs.org/docs/#filtered-requests">Sinon.JS: Filtered Requests</a>
       * for details.
       *
       * @attachStatic {qxWeb, dev.fakeServer.addFilter}
       * @param filter {Function} URL filter function. Will be called with the
       * following arguments: <code>method</code>, <code>url</code>, <code>async</code>,
       * <code>username</code>, <code>password</code>. Must return <code>true</code>
       * if the request should not be faked.
       */
      addFilter: function addFilter(filter) {
        qx.dev.FakeServer.getInstance().addFilter(filter);
      },

      /**
       * Remove a filter that was added with {@link #addFilter}
       * @param filter {Function} filter function to remove
       *
       * @attachStatic {qxWeb, dev.fakeServer.removeFilter}
       */
      removeFilter: function removeFilter(filter) {
        qx.dev.FakeServer.getInstance().removeFilter(filter);
      },

      /**
       * Defines a fake XHR response to a matching request.
       *
       * @attachStatic {qxWeb, dev.fakeServer.respondWith}
       * @param method {String} HTTP method to respond to, e.g. "GET"
       * @param urlRegExp {RegExp} Request URL must match match this expression
       * @param response {Function|Array|String} Response to send. See
       * <a href="http://sinonjs.org/docs/#fakeServer">Sinon.JS: Fake Server</a> for details.
       */
      respondWith: function respondWith(method, urlRegExp, response) {
        qx.dev.FakeServer.getInstance().respondWith(method, urlRegExp, response);
      },

      /**
       * Creates and configures a FakeServer if necessary and returns it.
       *
       * @attachStatic {qxWeb, dev.fakeServer.getFakeServer}
       * @return {Object} FakeServer object
       */
      getFakeServer: function getFakeServer() {
        return qx.dev.FakeServer.getInstance().getFakeServer();
      },

      /**
       * Stops the FakeServer and removes all configured responses and/or filters.
        * @attachStatic {qxWeb, dev.fakeServer.restore}
       */
      restore: function restore() {
        qx.dev.FakeServer.getInstance().restore();
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachStatic({
        "dev": {
          "fakeServer": {
            "configure": statics.configure,
            "removeResponse": statics.removeResponse,
            "addFilter": statics.addFilter,
            "removeFilter": statics.removeFilter,
            "respondWith": statics.respondWith,
            "getFakeServer": statics.getFakeServer,
            "restore": statics.restore
          }
        }
      });
    }
  });
  qx.module.dev.FakeServer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.event.PointerHandler": {
        "defer": "runtime"
      },
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Event": {},
      "qx.event.Emitter": {},
      "qx.event.handler.GestureCore": {},
      "qxWeb": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "event.dispatchevent": {
          "className": "qx.bom.client.Event"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Creates a gesture handler that fires high-level events such as "swipe"
   * based on low-level event sequences on the given element
   *
   * @require(qx.module.Event)
   * @use(qx.module.event.PointerHandler)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.GestureHandler", {
    statics: {
      TYPES: ["tap", "longtap", "swipe", "dbltap", "track", "trackstart", "trackend", "roll", "rotate", "pinch"],

      /**
       * Creates a gesture handler for the given element when a gesture event listener
       * is attached to it
       *
       * @param element {Element} DOM element
       * @param type {String} event type
       */
      register: function register(element, type) {
        if (!element.$$gestureHandler) {
          if (!qx.core.Environment.get("event.dispatchevent")) {
            if (!element.$$emitter) {
              element.$$emitter = new qx.event.Emitter();
            }
          }

          element.$$gestureHandler = new qx.event.handler.GestureCore(element, element.$$emitter);
        }
      },

      /**
       * Removes the gesture event handler from the element if there are no more
       * gesture event listeners attached to it
       * @param element {Element} DOM element
       */
      unregister: function unregister(element) {
        // check if there are any registered listeners left
        if (element.$$gestureHandler) {
          var listeners = element.$$emitter.getListeners();

          for (var type in listeners) {
            if (qx.module.event.GestureHandler.TYPES.indexOf(type) !== -1) {
              if (listeners[type].length > 0) {
                return;
              }
            }
          } // no more listeners, get rid of the handler


          element.$$gestureHandler.dispose();
          element.$$gestureHandler = undefined;
        }
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventHook(statics.TYPES, statics.register, statics.unregister);
    }
  });
  qx.module.event.GestureHandler.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Environment": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      },
      "qx.event.util.Keyboard": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for native keyboard events.
   *
   * NOTE: Some browsers won't fire the <code>keypress</code> event for all keys.
   * It's generally better to listen for <code>keyup</code> or <code>keydown</code>
   * instead.
   *
   * @require(qx.module.Event)
   * @require(qx.module.Environment)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Keyboard", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["keydown", "keypress", "keyup"],

      /**
       * List qx.module.event.Keyboard methods to be attached to native mouse event
       * objects
       * @internal
       */
      BIND_METHODS: ["getKeyIdentifier"],

      /**
       * Identifier of the pressed key. This property is modeled after the <em>KeyboardEvent.keyIdentifier</em> property
       * of the W3C DOM 3 event specification
       * (http://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/events.html#Events-KeyboardEvent-keyIdentifier).
       *
       * Printable keys are represented by an unicode string, non-printable keys
       * have one of the following values:
       *
       * <table>
       * <tr><th>Backspace</th><td>The Backspace (Back) key.</td></tr>
       * <tr><th>Tab</th><td>The Horizontal Tabulation (Tab) key.</td></tr>
       * <tr><th>Space</th><td>The Space (Spacebar) key.</td></tr>
       * <tr><th>Enter</th><td>The Enter key. Note: This key identifier is also used for the Return (Macintosh numpad) key.</td></tr>
       * <tr><th>Shift</th><td>The Shift key.</td></tr>
       * <tr><th>Control</th><td>The Control (Ctrl) key.</td></tr>
       * <tr><th>Alt</th><td>The Alt (Menu) key.</td></tr>
       * <tr><th>CapsLock</th><td>The CapsLock key</td></tr>
       * <tr><th>Meta</th><td>The Meta key. (Apple Meta and Windows key)</td></tr>
       * <tr><th>Escape</th><td>The Escape (Esc) key.</td></tr>
       * <tr><th>Left</th><td>The Left Arrow key.</td></tr>
       * <tr><th>Up</th><td>The Up Arrow key.</td></tr>
       * <tr><th>Right</th><td>The Right Arrow key.</td></tr>
       * <tr><th>Down</th><td>The Down Arrow key.</td></tr>
       * <tr><th>PageUp</th><td>The Page Up key.</td></tr>
       * <tr><th>PageDown</th><td>The Page Down (Next) key.</td></tr>
       * <tr><th>End</th><td>The End key.</td></tr>
       * <tr><th>Home</th><td>The Home key.</td></tr>
       * <tr><th>Insert</th><td>The Insert (Ins) key. (Does not fire in Opera/Win)</td></tr>
       * <tr><th>Delete</th><td>The Delete (Del) Key.</td></tr>
       * <tr><th>F1</th><td>The F1 key.</td></tr>
       * <tr><th>F2</th><td>The F2 key.</td></tr>
       * <tr><th>F3</th><td>The F3 key.</td></tr>
       * <tr><th>F4</th><td>The F4 key.</td></tr>
       * <tr><th>F5</th><td>The F5 key.</td></tr>
       * <tr><th>F6</th><td>The F6 key.</td></tr>
       * <tr><th>F7</th><td>The F7 key.</td></tr>
       * <tr><th>F8</th><td>The F8 key.</td></tr>
       * <tr><th>F9</th><td>The F9 key.</td></tr>
       * <tr><th>F10</th><td>The F10 key.</td></tr>
       * <tr><th>F11</th><td>The F11 key.</td></tr>
       * <tr><th>F12</th><td>The F12 key.</td></tr>
       * <tr><th>NumLock</th><td>The Num Lock key.</td></tr>
       * <tr><th>PrintScreen</th><td>The Print Screen (PrintScrn, SnapShot) key.</td></tr>
       * <tr><th>Scroll</th><td>The scroll lock key</td></tr>
       * <tr><th>Pause</th><td>The pause/break key</td></tr>
       * <tr><th>Win</th><td>The Windows Logo key</td></tr>
       * <tr><th>Apps</th><td>The Application key (Windows Context Menu)</td></tr>
       * </table>
       *
       * @return {String} The key identifier
       */
      getKeyIdentifier: function getKeyIdentifier() {
        if (this.type == "keypress" && (qxWeb.env.get("engine.name") != "gecko" || this.charCode !== 0)) {
          return qx.event.util.Keyboard.charCodeToIdentifier(this.charCode || this.keyCode);
        }

        return qx.event.util.Keyboard.keyCodeToIdentifier(this.keyCode);
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        }

        var bindMethods = qx.module.event.Keyboard.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Keyboard[bindMethods[i]].bind(event);
          }
        }

        return event;
      },

      /**
       * IE9 will not fire an "input" event on text input elements if the user changes
       * the field's value by pressing the Backspace key. We fix this by listening
       * for the "keyup" event and emitting the missing event if necessary
       *
       * @param element {Element} Target element
       * @internal
       */
      registerInputFix: function registerInputFix(element) {
        if (element.type === "text" || element.type === "password" || element.type === "textarea") {
          if (!element.__inputFix__P_199_0) {
            element.__inputFix__P_199_0 = qxWeb(element).on("keyup", qx.module.event.Keyboard._inputFix);
          }
        }
      },

      /**
       * Removes the IE9 input event fix
       *
       * @param element {Element} target element
       * @internal
       */
      unregisterInputFix: function unregisterInputFix(element) {
        if (element.__inputFix__P_199_0 && !qxWeb(element).hasListener("input")) {
          qxWeb(element).off("keyup", qx.module.event.Keyboard._inputFix);
          element.__inputFix__P_199_0 = null;
        }
      },

      /**
       * IE9 fix: Emits an "input" event if a text input element's value was changed
       * using the Backspace key
       * @param ev {Event} Keyup event
       */
      _inputFix: function _inputFix(ev) {
        if (ev.getKeyIdentifier() !== "Backspace") {
          return;
        }

        var target = ev.getTarget();
        var newValue = qxWeb(target).getValue();

        if (!target.__oldInputValue__P_199_1 || target.__oldInputValue__P_199_1 !== newValue) {
          target.__oldInputValue__P_199_1 = newValue;
          ev.type = ev._type = "input";
          target.$$emitter.emit("input", ev);
        }
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Keyboard.TYPES, statics.normalize);

      if (qxWeb.env.get("engine.name") === "mshtml" && qxWeb.env.get("browser.documentmode") === 9) {
        qxWeb.$registerEventHook("input", statics.registerInputFix, statics.unregisterInputFix);
      }
    }
  });
  qx.module.event.Keyboard.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Environment": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      },
      "qx.dom.Node": {},
      "qx.bom.Viewport": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for native mouse events. For cross-device applications that
   * support both mouse and touchscreen interaction, consider using
   * <a href="#Pointer">Pointer</a> and/or Gesture events (e.g. <a href="Tap"></a>).
   *
   * @require(qx.module.Environment)
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Mouse", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout"],

      /**
       * List qx.module.event.Mouse methods to be attached to native mouse event
       * objects
       * @internal
       */
      BIND_METHODS: ["getButton", "getViewportLeft", "getViewportTop", "getDocumentLeft", "getDocumentTop", "getScreenLeft", "getScreenTop"],

      /**
       * Standard mouse button mapping
       */
      BUTTONS_DOM2: {
        0: "left",
        2: "right",
        1: "middle"
      },

      /**
       * Legacy Internet Explorer mouse button mapping
       */
      BUTTONS_MSHTML: {
        1: "left",
        2: "right",
        4: "middle"
      },

      /**
       * Returns the identifier of the mouse button that change state when the
       * event was triggered
       *
       * @return {String} One of <code>left</code>, <code>right</code> or
       * <code>middle</code>
       */
      getButton: function getButton() {
        switch (this.type) {
          case "contextmenu":
            return "right";

          case "click":
            // IE does not support buttons on click --> assume left button
            if (qxWeb.env.get("browser.name") === "ie" && qxWeb.env.get("browser.documentmode") < 9) {
              return "left";
            }

          default:
            if (this.target !== undefined) {
              return qx.module.event.Mouse.BUTTONS_DOM2[this.button] || "none";
            } else {
              return qx.module.event.Mouse.BUTTONS_MSHTML[this.button] || "none";
            }

        }
      },

      /**
       * Get the horizontal coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The horizontal mouse position
       */
      getViewportLeft: function getViewportLeft() {
        return this.clientX;
      },

      /**
       * Get the vertical coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The vertical mouse position
       * @signature function()
       */
      getViewportTop: function getViewportTop() {
        return this.clientY;
      },

      /**
       * Get the horizontal position at which the event occurred relative to the
       * left of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The horizontal mouse position in the document.
       */
      getDocumentLeft: function getDocumentLeft() {
        if (this.pageX !== undefined) {
          return this.pageX;
        } else {
          var win = qx.dom.Node.getWindow(this.srcElement);
          return this.clientX + qx.bom.Viewport.getScrollLeft(win);
        }
      },

      /**
       * Get the vertical position at which the event occurred relative to the
       * top of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The vertical mouse position in the document.
       */
      getDocumentTop: function getDocumentTop() {
        if (this.pageY !== undefined) {
          return this.pageY;
        } else {
          var win = qx.dom.Node.getWindow(this.srcElement);
          return this.clientY + qx.bom.Viewport.getScrollTop(win);
        }
      },

      /**
       * Get the horizontal coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The horizontal mouse position on the screen.
       */
      getScreenLeft: function getScreenLeft() {
        return this.screenX;
      },

      /**
       * Get the vertical coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The vertical mouse position on the screen.
       */
      getScreenTop: function getScreenTop() {
        return this.screenY;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        }

        var bindMethods = qx.module.event.Mouse.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Mouse[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Mouse.TYPES, statics.normalize);
    }
  });
  qx.module.event.Mouse.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Event": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Common normalizations for native events
   *
   * @require(qx.module.Event)
   * @require(qx.bom.Event#getTarget)
   * @require(qx.bom.Event#getRelatedTarget)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Native", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["*"],

      /**
       * List of qx.bom.Event methods to be attached to native event objects
       * @internal
       */
      FORWARD_METHODS: ["getTarget", "getRelatedTarget"],

      /**
       * List of qx.module.event.Native methods to be attached to native event objects
       * @internal
       */
      BIND_METHODS: ["preventDefault", "stopPropagation", "getType"],

      /**
       * Prevent the native default behavior of the event.
       */
      preventDefault: function preventDefault() {
        try {
          // this allows us to prevent some key press events in IE.
          // See bug #1049
          this.keyCode = 0;
        } catch (ex) {}

        this.returnValue = false;
      },

      /**
       * Stops the event's propagation to the element's parent
       */
      stopPropagation: function stopPropagation() {
        this.cancelBubble = true;
      },

      /**
       * Returns the event's type
       *
       * @return {String} event type
       */
      getType: function getType() {
        return this._type || this.type;
      },

      /**
       * Returns the target of the event.
       *
       * @signature function ()
       * @return {Object} Any valid native event target
       */
      getTarget: function getTarget() {},

      /**
       * Computes the related target from the native DOM event
       *
       * @signature function ()
       * @return {Element} The related target
       */
      getRelatedTarget: function getRelatedTarget() {},

      /**
       * Computes the current target from the native DOM event. Emulates the current target
       * for all browsers without native support (like older IEs).
       *
       * @signature function ()
       * @return {Element} The current target
       */
      getCurrentTarget: function getCurrentTarget() {},

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        }

        var fwdMethods = qx.module.event.Native.FORWARD_METHODS;

        for (var i = 0, l = fwdMethods.length; i < l; i++) {
          event[fwdMethods[i]] = qx.bom.Event[fwdMethods[i]].bind(null, event);
        }

        var bindMethods = qx.module.event.Native.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Native[bindMethods[i]].bind(event);
          }
        }

        event.getCurrentTarget = function () {
          return event.currentTarget || element;
        };

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(statics.TYPES, statics.normalize);
    }
  });
  qx.module.event.Native.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for orientationchange events
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Orientation", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["orientationchange"],

      /**
       * List of qx.module.event.Orientation methods to be attached to native
       * event objects
       * @internal
       */
      BIND_METHODS: ["getOrientation", "isLandscape", "isPortrait"],

      /**
       * Returns the current orientation of the viewport in degrees.
       *
       * All possible values and their meaning:
       *
       * * <code>0</code>: "Portrait"
       * * <code>-90</code>: "Landscape (right, screen turned clockwise)"
       * * <code>90</code>: "Landscape (left, screen turned counterclockwise)"
       * * <code>180</code>: "Portrait (upside-down portrait)"
       *
       * @return {Number} The current orientation in degrees
       */
      getOrientation: function getOrientation() {
        return this._orientation;
      },

      /**
       * Whether the viewport orientation is currently in landscape mode.
       *
       * @return {Boolean} <code>true</code> when the viewport orientation
       *     is currently in landscape mode.
       */
      isLandscape: function isLandscape() {
        return this._mode == "landscape";
      },

      /**
       * Whether the viewport orientation is currently in portrait mode.
       *
       * @return {Boolean} <code>true</code> when the viewport orientation
       *     is currently in portrait mode.
       */
      isPortrait: function isPortrait() {
        return this._mode == "portrait";
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @param type {String} Event type
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element, type) {
        if (!event) {
          return event;
        }

        event._type = type;
        var bindMethods = qx.module.event.Orientation.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Orientation[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(statics.TYPES, statics.normalize);
    }
  });
  qx.module.event.Orientation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dom.Node": {},
      "qx.event.Emitter": {},
      "qx.event.handler.OrientationCore": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Orientation handler which is responsible for registering and unregistering a
   * {@link qx.event.handler.OrientationCore} handler for each given element.
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.OrientationHandler", {
    statics: {
      /**
       * List of events that require an orientation handler
       */
      TYPES: ["orientationchange"],

      /**
       * Creates an orientation handler for the given window when an
       * orientationchange event listener is attached to it
       *
       * @param element {Window} DOM Window
       */
      register: function register(element) {
        if (!qx.dom.Node.isWindow(element)) {
          throw new Error("The 'orientationchange' event is only available on window objects!");
        }

        if (!element.__orientationHandler__P_200_0) {
          if (!element.$$emitter) {
            element.$$emitter = new qx.event.Emitter();
          }

          element.__orientationHandler__P_200_0 = new qx.event.handler.OrientationCore(element, element.$$emitter);
        }
      },

      /**
       * Removes the orientation event handler from the element if there are no more
       * orientationchange event listeners attached to it
       * @param element {Element} DOM element
       */
      unregister: function unregister(element) {
        if (element.__orientationHandler__P_200_0) {
          if (!element.$$emitter) {
            element.__orientationHandler__P_200_0 = null;
          } else {
            var hasListener = false;
            var listeners = element.$$emitter.getListeners();
            qx.module.event.OrientationHandler.TYPES.forEach(function (type) {
              if (type in listeners && listeners[type].length > 0) {
                hasListener = true;
              }
            });

            if (!hasListener) {
              element.__orientationHandler__P_200_0 = null;
            }
          }
        }
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventHook(statics.TYPES, statics.register, statics.unregister);
    }
  });
  qx.module.event.OrientationHandler.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for the pinch gesture.
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Pinch", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["pinch"],
      BIND_METHODS: ["getScale"],

      /**
       * Returns the calculated scale of this event.
       *
       * @return {Float} the scale value of this event.
       */
      getScale: function getScale() {
        return this._original.scale;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        } // apply mouse event normalizations


        var bindMethods = qx.module.event.Pinch.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Pinch[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Pinch.TYPES, statics.normalize);
    }
  });
  qx.module.event.Pinch.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.type.dom.Pointer": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for pointer events. Pointer events are hardware-agnostic and
   * will be fired regardless of which input type of input device is used (e.g. mouse or touchscreen).
   *
   * @require(qx.module.Event)
   * @require(qx.module.event.Pointer#getPointerType) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getViewportLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getViewportTop) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getDocumentLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getDocumentTop) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getScreenLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getScreenTop) // static code analysis - this method has to referenced
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Pointer", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["pointerdown", "pointerup", "pointermove", "pointercancel", "pointerover", "pointerout"],

      /**
       * Returns the device type which the event triggered. This can be one
       * of the following strings: <code>mouse</code>, <code>pen</code>
       * or <code>touch</code>.
       *
       * @return {String} The type of the pointer.
       */
      getPointerType: function getPointerType() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the horizontal coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The horizontal mouse position
       */
      getViewportLeft: function getViewportLeft() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the vertical coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The vertical mouse position
       * @signature function()
       */
      getViewportTop: function getViewportTop() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the horizontal position at which the event occurred relative to the
       * left of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The horizontal mouse position in the document.
       */
      getDocumentLeft: function getDocumentLeft() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the vertical position at which the event occurred relative to the
       * top of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The vertical mouse position in the document.
       */
      getDocumentTop: function getDocumentTop() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the horizontal coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The horizontal mouse position on the screen.
       */
      getScreenLeft: function getScreenLeft() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the vertical coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The vertical mouse position on the screen.
       */
      getScreenTop: function getScreenTop() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        }

        qx.event.type.dom.Pointer.normalize(event);
        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Pointer.TYPES, statics.normalize);
    }
  });
  qx.module.event.Pointer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for the rotate gesture.
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Rotate", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["rotate"],
      BIND_METHODS: ["getAngle"],

      /**
       * Returns a number with the current calculated angle between the primary and secondary active pointers.
       *
       * @return {Number} the angle of the two active pointers.
       */
      getAngle: function getAngle() {
        return this._original.angle;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        } // apply mouse event normalizations


        var bindMethods = qx.module.event.Rotate.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Rotate[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Rotate.TYPES, statics.normalize);
    }
  });
  qx.module.event.Rotate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for the swipe gesture. This gesture is based on <a href="#Pointer">Pointer events</a>
   * meaning that it's available on all devices, no matter which input device type is used (e.g. mouse or
   * touchscreen).
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Swipe", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["swipe"],
      BIND_METHODS: ["getStartTime", "getDuration", "getAxis", "getDirection", "getVelocity", "getDistance"],

      /**
       * Returns the start time of the performed swipe.
       *
       * @return {Integer} the start time
       */
      getStartTime: function getStartTime() {
        return this._original.swipe.startTime;
      },

      /**
       * Returns the duration the performed swipe took.
       *
       * @return {Integer} the duration
       */
      getDuration: function getDuration() {
        return this._original.swipe.duration;
      },

      /**
       * Returns whether the performed swipe was on the x or y axis.
       *
       * @return {String} "x"/"y" axis
       */
      getAxis: function getAxis() {
        return this._original.swipe.axis;
      },

      /**
       * Returns the direction of the performed swipe in reference to the axis.
       * y = up / down
       * x = left / right
       *
       * @return {String} the direction
       */
      getDirection: function getDirection() {
        return this._original.swipe.direction;
      },

      /**
       * Returns the velocity of the performed swipe.
       *
       * @return {Number} the velocity
       */
      getVelocity: function getVelocity() {
        return this._original.swipe.velocity;
      },

      /**
       * Returns the distance of the performed swipe.
       *
       * @return {Integer} the distance
       */
      getDistance: function getDistance() {
        return this._original.swipe.distance;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        } // apply mouse event normalizations


        var bindMethods = qx.module.event.Swipe.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Swipe[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Swipe.TYPES, statics.normalize);
    }
  });
  qx.module.event.Swipe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for tap gesture events. These gestures are based on <a href="#Pointer">Pointer events</a>,
   * meaning that they are available on all devices, no matter which input device type is used (e.g. mouse or
   * touchscreen).
   *
   * @require(qx.module.Event)
   * @require(qx.module.event.Tap#getViewportLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Tap#getViewportTop) // static code analysis - this method has to referenced
   * @require(qx.module.event.Tap#getDocumentLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Tap#getDocumentTop) // static code analysis - this method has to referenced
   * @require(qx.module.event.Tap#getScreenLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Tap#getScreenTop) // static code analysis - this method has to referenced
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Tap", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["tap", "longtap", "dbltap"],

      /**
       * List methods to be attached to gesture event
       * objects
       * @internal
       */
      BIND_METHODS: ["getViewportLeft", "getViewportTop", "getDocumentLeft", "getDocumentTop", "getScreenLeft", "getScreenTop"],

      /**
       * Get the horizontal coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The horizontal contact position
       */
      getViewportLeft: function getViewportLeft() {
        return this._original.getViewportLeft();
      },

      /**
       * Get the vertical coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The vertical contact position
       * @signature function()
       */
      getViewportTop: function getViewportTop() {
        return this._original.getViewportTop();
      },

      /**
       * Get the horizontal position at which the event occurred relative to the
       * left of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The horizontal contact position in the document.
       */
      getDocumentLeft: function getDocumentLeft() {
        return this._original.getDocumentLeft();
      },

      /**
       * Get the vertical position at which the event occurred relative to the
       * top of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The vertical contact position in the document.
       */
      getDocumentTop: function getDocumentTop() {
        return this._original.getDocumentTop();
      },

      /**
       * Get the horizontal coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The horizontal contact position on the screen.
       */
      getScreenLeft: function getScreenLeft() {
        return this._original.getScreenLeft();
      },

      /**
       * Get the vertical coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The vertical contact position on the screen.
       */
      getScreenTop: function getScreenTop() {
        return this._original.getScreenTop();
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        }

        var bindMethods = qx.module.event.Tap.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Tap[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Tap.TYPES, statics.normalize);
    }
  });
  qx.module.event.Tap.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for touch events. For cross-device applications that
   * support both mouse and touchscreen interaction, consider using
   * <a href="#Pointer">Pointer</a> and/or Gesture events (e.g. <a href="Tap"></a>).
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Touch", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["tap", "longtap", "swipe", "dbltap"],

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @param type {String} Event type
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element, type) {
        if (!event) {
          return event;
        }

        event._type = type;
        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(statics.TYPES, statics.normalize);
    }
  });
  qx.module.event.Touch.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.Emitter": {},
      "qx.event.handler.TouchCore": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Creates a touch event handler that fires high-level events such as "swipe"
   * based on low-level event sequences on the given element
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.TouchHandler", {
    statics: {
      /**
       * List of events that require a touch handler
       */
      TYPES: ["touchstart", "touchend", "touchmove", "touchcancel"],

      /**
       * Creates a touch handler for the given element when a touch event listener
       * is attached to it
       *
       * @param element {Element} DOM element
       */
      register: function register(element) {
        if (!element.__touchHandler__P_201_0) {
          if (!element.$$emitter) {
            element.$$emitter = new qx.event.Emitter();
          }

          element.__touchHandler__P_201_0 = new qx.event.handler.TouchCore(element, element.$$emitter);
        }
      },

      /**
       * Removes the touch event handler from the element if there are no more
       * touch event listeners attached to it
       * @param element {Element} DOM element
       */
      unregister: function unregister(element) {
        if (element.__touchHandler__P_201_0) {
          if (!element.$$emitter) {
            element.__touchHandler__P_201_0 = null;
          } else {
            var hasTouchListener = false;
            var listeners = element.$$emitter.getListeners();
            qx.module.event.TouchHandler.TYPES.forEach(function (type) {
              if (type in listeners && listeners[type].length > 0) {
                hasTouchListener = true;
              }
            });

            if (!hasTouchListener) {
              element.__touchHandler__P_201_0 = null;
            }
          }
        }
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventHook(statics.TYPES, statics.register, statics.unregister);
    }
  });
  qx.module.event.TouchHandler.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for the track gesture. This gesture is based on <a href="#Pointer">Pointer events</a>,
   * meaning that it's available on all devices, no matter which input device type is used (e.g. mouse or
   * touchscreen).
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Track", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["track"],
      BIND_METHODS: ["getDelta"],

      /**
       * Returns a map with the calculated delta coordinates and axis,
       * relative to the position on <code>trackstart</code> event.
       *
       * @return {Map} a map with contains the delta as <code>x</code> and
       * <code>y</code> and the movement axis as <code>axis</code>.
       */
      getDelta: function getDelta() {
        return this._original.delta;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        } // apply mouse event normalizations


        var bindMethods = qx.module.event.Track.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Track[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Track.TYPES, statics.normalize);
    }
  });
  qx.module.event.Track.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Array": {
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * Utility module to give some support to work with arrays.
   *
   * @group (Utilities)
   */
  qx.Bootstrap.define("qx.module.util.Array", {
    statics: {
      /**
       * Converts an array like object to any other array like
       * object.
       *
       * Attention: The returned array may be same
       * instance as the incoming one if the constructor is identical!
       *
       * @signature function(object, constructor, offset)
       * @attachStatic {qxWeb, array.cast}
       *
       * @param object {var} any array-like object
       * @param constructor {Function} constructor of the new instance
       * @param offset {Number?0} position to start from
       * @return {Array} the converted array
       */
      cast: qx.lang.Array.cast,

      /**
       * Check whether the two arrays have the same content. Checks only the
       * equality of the arrays' content.
       *
       * @signature function(arr1, arr2)
       * @attachStatic {qxWeb, array.equals}
       *
       * @param arr1 {Array} first array
       * @param arr2 {Array} second array
       * @return {Boolean} Whether the two arrays are equal
       */
      equals: qx.lang.Array.equals,

      /**
       * Modifies the first array as it removes all elements
       * which are listed in the second array as well.
       *
       * @signature function(arr1, arr2)
       * @attachStatic {qxWeb, array.exclude}
       *
       * @param arr1 {Array} the array
       * @param arr2 {Array} the elements of this array will be excluded from the other one
       * @return {Array} The modified array.
       */
      exclude: qx.lang.Array.exclude,

      /**
       * Convert an arguments object into an array.
       *
       * @signature function(args, offset)
       * @attachStatic {qxWeb, array.fromArguments}
       *
       * @param args {arguments} arguments object
       * @param offset {Number?0} position to start from
       * @return {Array} a newly created array (copy) with the content of the arguments object.
       */
      fromArguments: qx.lang.Array.fromArguments,

      /**
       * Insert an element into the array after a given second element.
       *
       * @signature function(arr, obj, obj2)
       * @attachStatic {qxWeb, array.insertAfter}
       *
       * @param arr {Array} the array
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 after this object
       * @return {Array} The given array.
       */
      insertAfter: qx.lang.Array.insertAfter,

      /**
       * Insert an element into the array before a given second element.
       *
       * @signature function(arr, obj, obj2)
       * @attachStatic {qxWeb, array.insertBefore}
       *
       * @param arr {Array} the array
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 before this object
       * @return {Array} The given array.
       */
      insertBefore: qx.lang.Array.insertBefore,

      /**
       * Returns the highest value in the given array. Supports
       * numeric values only.
       *
       * @signature function(arr)
       * @attachStatic {qxWeb, array.max}
       *
       * @param arr {Array} Array to process.
       * @return {Number | undefined} The highest of all values or undefined if array is empty.
       */
      max: qx.lang.Array.max,

      /**
       * Returns the lowest value in the given array. Supports
       * numeric values only.
       *
       * @signature function(arr)
       * @attachStatic {qxWeb, array.min}
       *
       * @param arr {Array} Array to process.
       * @return {Number | undefined} The lowest of all values or undefined if array is empty.
       */
      min: qx.lang.Array.min,

      /**
       * Remove an element from the array.
       *
       * @signature function(arr, obj)
       * @attachStatic {qxWeb, array.remove}
       *
       * @param arr {Array} the array
       * @param obj {var} element to be removed from the array
       * @return {var} the removed element
       */
      remove: qx.lang.Array.remove,

      /**
       * Remove all elements from the array
       *
       * @signature function(arr)
       * @attachStatic {qxWeb, array.removeAll}
       *
       * @param arr {Array} the array
       * @return {Array} empty array
       */
      removeAll: qx.lang.Array.removeAll,

      /**
       * Recreates an array which is free of all duplicate elements from the original.
       * This method do not modifies the original array!
       * Keep in mind that this methods deletes undefined indexes.
       *
       * @signature function(arr)
       * @attachStatic {qxWeb, array.unique}
       *
       * @param arr {Array} Incoming array
       * @return {Array} Returns a copy with no duplicates
       *   or the original array if no duplicates were found.
       */
      unique: qx.lang.Array.unique,

      /**
       * Returns a new array with integers from start to stop incremented or decremented by step.
       *
       * @signature function(start, stop, step)
       * @attachStatic {qxWeb, array.range}
       *
       * @param start {Integer} start of the new array, defaults to 0
       * @param stop {Integer} stop of the new array
       * @param step {Integer} increment / decrement - depends whether you use positive or negative values
       * @return {Array} Returns a new array with integers
       */
      range: qx.lang.Array.range
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "array");
    }
  });
  qx.module.util.Array.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.util.Function": {
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
       * Tobias Oberrauch (toberrauch)
  
  ************************************************************************ */

  /**
   * Utility module to give some support to work with functions.
   *
   * @group (Utilities)
   */
  qx.Bootstrap.define("qx.module.util.Function", {
    statics: {
      /**
       * Returns a debounced version of the given callback. The execution of the callback
       * is delayed by the given delay and after no events were triggered anymore.
       * This mechanism is very useful for event handling: only after a specified delay
       * the event should be handled (e.g. at keyboard input by the user) to prevent flooding
       * the handler with a large amounts of events.
       *
       * @attachStatic{qxWeb, func.debounce}
       * @signature function (callback, delay, immediate)
       * @param callback {Function} the callback which should be executed after the given delay
       * if the wrapper method is *not* called during this delay.
       * @param delay {Number} Delay in milliseconds
       * @param immediate {Boolean?} whether to run the callback at the beginning and then debounce, default is <code>false</code>
       * @return {Function} a wrapper function which <em>shields</em> the given callback function
       */
      debounce: qx.util.Function.debounce,

      /**
       * Returns a throttled version of the given callback. The execution of the callback
       * is throttled which means it is only executed in the given interval.
       * This mechanism is very useful for event handling: only in specified intervals
       * the event should be handled (e.g. at resize of the browser window) to prevent flooding
       * the handler with a large amounts of events.
       * As default the <code>leading</code> and <code>trailing</code> calls are executed.
       *
       * @attachStatic{qxWeb, func.throttle}
       * @signature function (callback, interval, options)
       * @param callback {Function} the callback which should be executed in the given interval
       * @param interval {Number} Interval in milliseconds
       * @param options {Map} the keys are <code>leading</code> and <code>trailing</code> to control the
       * executing of the callback precisely. Default values are <code>true</code> for both options.
       * @return {Function} a wrapper function which <em>shields</em> the given callback function
       */
      throttle: qx.util.Function.throttle
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "func");
    }
  });
  qx.module.util.Function.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.util.Array": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Object": {
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */

  /**
   * Helper functions to handle an Object as a Hash map.
   *
   * @group (Utilities)
   * @require (qx.module.util.Array)
   */
  qx.Bootstrap.define("qx.module.util.Object", {
    statics: {
      /**
       * Return a copy of an Object
       *
       * @signature function(source, deep)
       * @attachStatic {qxWeb, object.clone}
       *
       * @param source {Object} Object to copy
       * @param deep {Boolean} If the clone should be a deep clone.
       * @return {Object} A copy of the object
       */
      clone: qx.lang.Object.clone,

      /**
       * Get the values of a map as array
       *
       * @signature function(map)
       * @attachStatic {qxWeb, object.getValues}
       *
       * @param map {Object} the map
       * @return {Array} array of the values of the map
       */
      getValues: qx.lang.Object.getValues,

      /**
       * Inverts a map by exchanging the keys with the values.
       *
       * @signature function(map)
       * @attachStatic {qxWeb, object.invert}
       *
       * If the map has the same values for different keys, information will get lost.
       * The values will be converted to strings using the toString methods.
       *
       * @param map {Object} Map to invert
       * @return {Object} inverted Map
       */
      invert: qx.lang.Object.invert,

      /**
       * Whether the map contains the given value.
       *
       * @signature function(map, value)
       * @attachStatic {qxWeb, object.contains}
       *
       * @param map {Object} Map to search for the value
       * @param value {var} Value to look for
       * @return {Boolean} Whether the value was found in the map.
       */
      contains: qx.lang.Object.contains,

      /**
       * Merges one or more objects into the 'target' object.
       * *The objects are merged by overwriting existing keys.*
       *
       * @attachStatic {qxWeb, object.merge}
       *
       * @param target {Object} target object to merge into
       * @param varargs {var} As many items as you want to merge.
       * @return {Object} the merged object
       */
      merge: function merge(target, varargs) {
        var varargs = qxWeb.array.fromArguments(arguments);
        var target = varargs.shift();
        varargs.forEach(function (sourceObject) {
          target = qx.Bootstrap.objectMergeWith(target, sourceObject);
        });
        return target;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "object");
    }
  });
  qx.module.util.Object.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.String": {
        "require": true
      },
      "qx.bom.String": {
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * Utility module to give some support to work with strings.
   *
   * *Info:* The <pre class='javascript'>trim</pre> method is available as <a href="#String">Polyfill</a>.
   *
   * @group (Utilities)
   */
  qx.Bootstrap.define("qx.module.util.String", {
    statics: {
      /**
       * Converts a hyphenated string (separated by '-') to camel case.
       *
       * @attachStatic {qxWeb, string.camelCase}
       * @param str {String} hyphenated string
       * @return {String} camelcase string
       */
      camelCase: function camelCase(str) {
        return qx.lang.String.camelCase.call(qx.lang.String, str);
      },

      /**
       * Converts a camelcased string to a hyphenated (separated by '-') string.
       *
       * @attachStatic {qxWeb, string.hyphenate}
       * @param str {String} camelcased string
       * @return {String} hyphenated string
       */
      hyphenate: function hyphenate(str) {
        return qx.lang.String.hyphenate.call(qx.lang.String, str);
      },

      /**
       * Convert the first character of the string to upper case.
       *
       * @attachStatic {qxWeb, string.firstUp}
       * @signature function(str)
       * @param str {String} the string
       * @return {String} the string with an upper case first character
       */
      firstUp: qx.lang.String.firstUp,

      /**
       * Convert the first character of the string to lower case.
       *
       * @attachStatic {qxWeb, string.firstLow}
       * @signature function(str)
       * @param str {String} the string
       * @return {String} the string with a lower case first character
       */
      firstLow: qx.lang.String.firstLow,

      /**
       * Check whether the string starts with the given substring.
       *
       * @attachStatic {qxWeb, string.startsWith}
       * @signature function(fullstr, substr)
       * @param fullstr {String} the string to search in
       * @param substr {String} the substring to look for
       * @return {Boolean} whether the string starts with the given substring
       */
      startsWith: function startsWith(fullstr, substr) {
        return fullstr.startsWith(substr);
      },

      /**
       * Check whether the string ends with the given substring.
       *
       * @attachStatic {qxWeb, string.endsWith}
       * @signature function(fullstr, substr)
       * @param fullstr {String} the string to search in
       * @param substr {String} the substring to look for
       * @return {Boolean} whether the string ends with the given substring
       */
      endsWith: function endsWith(fullstr, substr) {
        return fullstr.endsWith(substr);
      },

      /**
       * Escapes all chars that have a special meaning in regular expressions.
       *
       * @attachStatic {qxWeb, string.escapeRegexpChars}
       * @signature function(str)
       * @param str {String} the string where to escape the chars.
       * @return {String} the string with the escaped chars.
       */
      escapeRegexpChars: qx.lang.String.escapeRegexpChars,

      /**
       * Escapes the characters in a <code>String</code> using HTML entities.
       * Supports all known HTML 4.0 entities, including funky accents.
       *
       * @attachStatic {qxWeb, string.escapeHtml}
       * @signature function(str)
       * @param str {String} the String to escape
       * @return {String} a new escaped String
       */
      escapeHtml: qx.bom.String.escape
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "string");
    }
  });
  qx.module.util.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * Utility for checking the type of a variable.
   * It adds a <code>type</code> key static to q and offers the given method.
   *
   * @group (Utilities)
   */
  qx.Bootstrap.define("qx.module.util.Type", {
    statics: {
      /**
       * Get the internal class of the value. The following classes are possible:
       * <pre>
       * <code>"String"</code>,
       * <code>"Array"</code>,
       * <code>"Object"</code>,
       * <code>"RegExp"</code>,
       * <code>"Number"</code>,
       * <code>"Boolean"</code>,
       * <code>"Date"</code>,
       * <code>"Function"</code>,
       * <code>"Error"</code>
       * </pre>
       * @attachStatic {qxWeb, type.get}
       * @signature function(value)
       * @param value {var} Value to get the class for.
       * @return {String} The internal class of the value.
       */
      get: qx.Bootstrap.getClass
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "type");
    }
  });
  qx.module.util.Type.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.core.Object": {
        "construct": true
      },
      "qx.Annotation": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 Zenesis Limited (http://www.zenesis.com)
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com)
  
  ************************************************************************ */
  qx.Class.define("qx.test.Annotation", {
    extend: qx.dev.unit.TestCase,
    members: {
      testBasic: function testBasic() {
        var clazzTop = qx.Class.define(null, {
          "@": ["class-a-anno"],
          extend: qx.core.Object,
          "@construct": ["construct-a-anno"],
          "@destruct": ["destruct-a-anno"],
          properties: {
            alpha: {
              init: null,
              nullable: true,
              "@": ["property-alpha-anno"]
            }
          },
          members: {
            "@methodA": ["method-a-anno"],
            methodA: function methodA() {}
          },
          statics: {
            "@staticA": ["static-a-anno"],
            staticA: function staticA() {
              return true;
            }
          }
        });
        var clazzMiddle = qx.Class.define(null, {
          extend: clazzTop,
          properties: {
            bravo: {
              init: null,
              nullable: true,
              "@": ["property-bravo-anno"]
            }
          },
          members: {
            "@methodB": ["method-b-anno"],
            methodB: function methodB() {}
          }
        });
        var clazzBottom = qx.Class.define(null, {
          extend: clazzMiddle,
          "@": ["class-c-anno"],
          "@construct": ["construct-c-anno"],
          "@destruct": ["destruct-c-anno"],
          properties: {
            bravo: {
              refine: true,
              "@": ["refined-bravo-anno"]
            }
          },
          members: {
            "@methodB": ["refined-method-b-anno"]
          }
        });
        this.assertArrayEquals(["class-a-anno"], qx.Annotation.getOwnClass(clazzTop));
        this.assertArrayEquals(["class-a-anno"], qx.Annotation.getClass(clazzTop));
        this.assertArrayEquals(["construct-a-anno"], qx.Annotation.getConstructor(clazzTop));
        this.assertArrayEquals(["destruct-a-anno"], qx.Annotation.getDestructor(clazzTop));
        this.assertArrayEquals(["method-a-anno"], qx.Annotation.getOwnMember(clazzTop, "methodA"));
        this.assertArrayEquals(["static-a-anno"], qx.Annotation.getStatic(clazzTop, "staticA"));
        this.assertArrayEquals(["property-alpha-anno"], qx.Annotation.getProperty(clazzTop, "alpha"));
        this.assertArrayEquals([], qx.Annotation.getOwnClass(clazzMiddle));
        this.assertArrayEquals(["class-a-anno"], qx.Annotation.getClass(clazzMiddle));
        this.assertArrayEquals([], qx.Annotation.getOwnConstructor(clazzMiddle));
        this.assertArrayEquals(["construct-a-anno"], qx.Annotation.getConstructor(clazzMiddle));
        this.assertArrayEquals([], qx.Annotation.getOwnDestructor(clazzMiddle));
        this.assertArrayEquals(["destruct-a-anno"], qx.Annotation.getDestructor(clazzMiddle));
        this.assertArrayEquals([], qx.Annotation.getOwnMember(clazzMiddle, "methodA"));
        this.assertArrayEquals(["method-a-anno"], qx.Annotation.getMember(clazzMiddle, "methodA"));
        this.assertArrayEquals(["method-b-anno"], qx.Annotation.getMember(clazzMiddle, "methodB"));
        this.assertArrayEquals([], qx.Annotation.getStatic(clazzMiddle, "staticA"));
        this.assertArrayEquals(["property-alpha-anno"], qx.Annotation.getProperty(clazzMiddle, "alpha"));
        this.assertArrayEquals(["property-bravo-anno"], qx.Annotation.getProperty(clazzMiddle, "bravo"));
        this.assertArrayEquals(["bravo"], qx.Annotation.getPropertiesByAnnotation(clazzBottom, "property-bravo-anno"));
        this.assertArrayEquals(["class-c-anno"], qx.Annotation.getOwnClass(clazzBottom));
        this.assertArrayEquals(["class-c-anno", "class-a-anno"], qx.Annotation.getClass(clazzBottom));
        this.assertArrayEquals(["construct-c-anno"], qx.Annotation.getOwnConstructor(clazzBottom));
        this.assertArrayEquals(["construct-c-anno", "construct-a-anno"], qx.Annotation.getConstructor(clazzBottom));
        this.assertArrayEquals(["destruct-c-anno"], qx.Annotation.getOwnDestructor(clazzBottom));
        this.assertArrayEquals(["destruct-c-anno", "destruct-a-anno"], qx.Annotation.getDestructor(clazzBottom));
        this.assertArrayEquals([], qx.Annotation.getOwnMember(clazzBottom, "methodA"));
        this.assertArrayEquals(["method-a-anno"], qx.Annotation.getMember(clazzBottom, "methodA"));
        this.assertArrayEquals(["refined-method-b-anno", "method-b-anno"], qx.Annotation.getMember(clazzBottom, "methodB"));
        this.assertArrayEquals(["property-alpha-anno"], qx.Annotation.getProperty(clazzBottom, "alpha"));
        this.assertArrayEquals(["refined-bravo-anno", "property-bravo-anno"], qx.Annotation.getProperty(clazzBottom, "bravo"));
        this.assertArrayEquals(["refined-bravo-anno"], qx.Annotation.getOwnProperty(clazzBottom, "bravo"));
      },
      testByType: function testByType() {
        var MyAnno = qx.Class.define(null, {
          extend: qx.core.Object,
          construct: function construct(value) {
            qx.core.Object.constructor.call(this);
            if (value) this.setValue(value);
          },
          properties: {
            value: {
              init: 0
            }
          }
        });
        var clazz = qx.Class.define(null, {
          extend: qx.core.Object,
          "@construct": ["construct-a-anno"],
          "@destruct": ["destruct-a-anno"],
          properties: {
            alpha: {
              init: null,
              nullable: true,
              "@": ["property-alpha-anno", new MyAnno(2)]
            }
          },
          members: {
            "@methodA": ["method-a-anno", new MyAnno(3)],
            methodA: function methodA() {}
          },
          statics: {
            "@staticA": ["static-a-anno", new MyAnno(4)],
            staticA: function staticA() {
              return true;
            }
          }
        });
        var match = qx.Annotation.getProperty(clazz, "alpha", MyAnno);
        this.assertEquals(1, match.length);
        this.assertTrue(match[0] instanceof MyAnno);
        var match = qx.Annotation.getOwnProperty(clazz, "alpha", MyAnno);
        this.assertEquals(1, match.length);
        this.assertTrue(match[0] instanceof MyAnno);
        var match = qx.Annotation.getMember(clazz, "methodA", MyAnno);
        this.assertEquals(1, match.length);
        this.assertTrue(match[0] instanceof MyAnno);
      }
    }
  });
  qx.test.Annotation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "defer": "runtime",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.Bootstrap": {
        "defer": "runtime"
      },
      "qx.core.Object": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.Construct.*, qx.test.ExtendError, qx.test.ExtendNull)
   * @ignore(qx.test.ExtendQxObject, qx.test.ExtendSuper.*, qx.test.Super.*)
   * @ignore(qx.test.ROOT, qx.test.MyClass.*, qx.test.Car, qx.test.Bmw.*)
   */
  qx.Class.define("qx.test.Bootstrap", {
    extend: qx.dev.unit.TestCase,
    members: {
      testDefineAnonymous: function testDefineAnonymous() {
        var clazz = qx.Bootstrap.define(null, {
          statics: {
            test: function test() {
              return true;
            }
          }
        });
        this.assertTrue(clazz.test());
        var clazz = qx.Bootstrap.define(null, {
          statics: {
            test2: function test2() {
              return true;
            }
          }
        });
        this.assertTrue(clazz.test2());
      },
      testClassnameProperty: function testClassnameProperty() {
        qx.Bootstrap.define("qx.test.MyClass", {
          //extend : Object,
          members: {}
        });
        var o = new qx.test.MyClass();
        this.assertEquals("qx.test.MyClass", o.classname);
        this.assertEquals("qx.test.MyClass", o.name);
        qx.Class.undefine("qx.test.MyClass");
      },
      testAlternativeRoot: function testAlternativeRoot() {
        var qq = {};
        var foobar = {};
        var myRoots = {
          "qq": qq,
          "foobar": foobar
        };
        qx.Bootstrap.setRoot(myRoots);
        var qqClass = qx.Bootstrap.define("qq.test.ROOT", {});
        var foobarClass = qx.Bootstrap.define("foobar.test.ROOT", {});
        var vanillebaerClass = qx.Bootstrap.define("vanillebaer.test.ROOT", {});
        this.assertEquals(qqClass, qq.test.ROOT);
        this.assertEquals(foobarClass, foobar.test.ROOT);
        this.assertEquals(vanillebaerClass, window.vanillebaer.test.ROOT);
        qx.Bootstrap.setRoot(undefined);
        qx.Class.undefine("vanillebaer.test.ROOT");
      },
      "test: merge methods of same class (statics optimization)": function testMergeMethodsOfSameClassStaticsOptimization() {
        qx.Bootstrap.define("qx.test.MyClass", {
          statics: {
            methodA: function methodA() {
              return true;
            }
          }
        });
        qx.Bootstrap.define("qx.test.MyClass", {
          statics: {
            methodB: function methodB() {
              return true;
            }
          }
        });
        this.assertNotUndefined(qx.test.MyClass.methodA);
        this.assertNotUndefined(qx.test.MyClass.methodB);
        qx.Class.undefine("qx.test.MyClass");
      },
      "test: merge methods of same class (statics optimization) respect defer": function testMergeMethodsOfSameClassStaticsOptimizationRespectDefer() {
        qx.Bootstrap.define("qx.test.MyClass", {
          statics: {
            methodA: function methodA() {
              return true;
            },
            methodB: function methodB() {
              return true;
            }
          }
        });
        qx.Bootstrap.define("qx.test.MyClass", {
          statics: {
            methodA: null
          },
          defer: function defer(statics) {
            statics.methodA = function () {
              return true;
            };
          }
        });
        this.assertNotNull(qx.test.MyClass.methodA);
        this.assertNotUndefined(qx.test.MyClass.methodB);
        qx.Class.undefine("qx.test.MyClass");
      },
      "test: define class with constructor": function testDefineClassWithConstructor() {
        var c = qx.Bootstrap.define("qx.test.Construct", {
          extend: Object,
          construct: function construct() {
            this.called = true;
          }
        });
        var obj = new qx.test.Construct();
        this.assertTrue(obj.called);
        this.assertEquals(c, qx.Bootstrap.getByName("qx.test.Construct"));
        this.assertEquals(qx.test.Construct, qx.Bootstrap.getByName("qx.test.Construct"));
        qx.Class.undefine("qx.test.Construct");
      },
      "test: define bootstrap class, which extends 'Error'": function testDefineBootstrapClassWhichExtendsError() {
        qx.Bootstrap.define("qx.test.ExtendError", {
          extend: Error
        });
        var obj = new qx.test.ExtendError();
        this.assertInstance(obj, Error);
        qx.Class.undefine("qx.test.ExtendError");
      },
      "test: extend from qx.core.Object": function testExtendFromQxCoreObject() {
        qx.Bootstrap.define("qx.test.ExtendQxObject", {
          extend: qx.core.Object
        });
        var obj = new qx.test.ExtendQxObject();
        this.assertInstance(obj, qx.core.Object);
        obj.dispose();
        qx.Class.undefine("qx.test.ExtendQxObject");
      },
      "test: extend from null should extend Object": function testExtendFromNullShouldExtendObject() {
        qx.Bootstrap.define("qx.test.ExtendNull", {
          extend: null,
          members: {}
        });
        var obj = new qx.test.ExtendNull();
        this.assertInstance(obj, Object);
        qx.Class.undefine("qx.test.ExtendNull");
      },
      "test: extend from Bootstrap class": function testExtendFromBootstrapClass() {
        qx.Bootstrap.define("qx.test.Super", {
          members: {}
        });
        qx.Bootstrap.define("qx.test.ExtendSuper", {
          extend: qx.test.Super,
          members: {}
        });
        var obj = new qx.test.ExtendSuper();
        this.assertInstance(obj, Object);
        this.assertInstance(obj, qx.test.Super);
        this.assertInstance(obj, qx.test.ExtendSuper);
        qx.Class.undefine("qx.test.Super");
        qx.Class.undefine("qx.test.ExtendSuper");
      },
      "test: extended Bootstap class should append members to the prototype": function testExtendedBootstapClassShouldAppendMembersToThePrototype() {
        qx.Bootstrap.define("qx.test.Super", {
          members: {
            foo: 10,
            baz: "juhu"
          }
        });
        qx.Bootstrap.define("qx.test.ExtendSuper", {
          extend: qx.test.Super,
          members: {
            bar: "affe",
            foo: 11
          }
        });
        var obj = new qx.test.ExtendSuper();
        this.assertEquals("affe", obj.bar);
        this.assertEquals(11, obj.foo);
        this.assertEquals("juhu", obj.baz);
        this.assertEquals(11, qx.test.ExtendSuper.prototype.foo);
        this.assertEquals(10, qx.test.Super.prototype.foo);
        qx.Class.undefine("qx.test.Super");
        qx.Class.undefine("qx.test.ExtendSuper");
      },
      "test: superclass calls aka basecalls (constructor and methods)": function testSuperclassCallsAkaBasecallsConstructorAndMethods() {
        qx.Bootstrap.define("qx.test.Car", {
          construct: function construct(name) {
            this._name = name;
          },
          members: {
            startEngine: function startEngine() {
              return "start";
            },
            stopEngine: function stopEngine() {
              return "stop";
            },
            getName: function getName() {
              return this._name;
            }
          }
        });
        var car = new qx.test.Car("Audi");
        this.assertEquals("start", car.startEngine());
        this.assertEquals("stop", car.stopEngine());
        this.assertEquals("Audi", car.getName());
        qx.Bootstrap.define("qx.test.Bmw", {
          extend: qx.test.Car,
          construct: function construct(name, prize) {
            qx.test.Car.constructor.call(this, name);
          },
          members: {
            startEngine: function startEngine() {
              var ret = qx.test.Bmw.prototype.startEngine.base.call(this);
              return "brrr " + ret;
            },
            stopEngine: function stopEngine() {
              var ret = qx.test.Bmw.prototype.stopEngine.base.call(this);
              return "brrr " + ret;
            },
            getWheels: function getWheels() {
              return qx.test.Bmw.WHEELS;
            },
            getMaxSpeed: function getMaxSpeed() {
              // call base in non overridden method
              qx.test.Bmw.prototype.getMaxSpeed.base.call(this);
            }
          },
          statics: {
            WHEELS: 4
          }
        });
        var bmw = new qx.test.Bmw("bmw", 44000);
        this.assertEquals("bmw", bmw.getName());
        this.assertEquals("brrr start", bmw.startEngine());
        this.assertEquals("brrr stop", bmw.stopEngine());
        this.assertEquals(4, bmw.getWheels());

        if (this.isDebugOn()) {
          this.assertException(function () {
            bmw.getMaxSpeed();
          }, Error);
        }

        qx.Class.undefine("qx.test.Car");
        qx.Class.undefine("qx.test.Bmw");
      },
      testFunctionWrap: function testFunctionWrap() {
        var context = null;
        var result = 0;

        var add = function add(a, b) {
          context = this;
          return a + b;
        };

        context = null;
        result = add(1, 2);
        this.assertEquals(context, window);
        this.assertEquals(3, result);
        context = null;
        var boundAdd = qx.Bootstrap.bind(add, this);
        result = boundAdd(1, 3);
        this.assertEquals(context, this);
        this.assertEquals(4, result);
        context = null;
        var addOne = qx.Bootstrap.bind(add, this, 1);
        result = addOne(4);
        this.assertEquals(context, this);
        this.assertEquals(5, result);
      },
      testBindWithUndefinedArguments: function testBindWithUndefinedArguments() {
        var undef;

        var callback = function callback(undef, arg) {
          this.assertTrue(arg);
        };

        var bound = qx.Bootstrap.bind(callback, this, undef, true);
        bound();
      },
      testDefineShadowedMembers: function testDefineShadowedMembers() {
        qx.Bootstrap.define("qx.test.Construct", {
          extend: Object,
          members: {
            "isPrototypeOf": 10,
            "hasOwnProperty": 11,
            "toLocaleString": 12,
            "toString": 13,
            "valueOf": 14
          }
        });
        var obj = new qx.test.Construct();
        this.assertEquals(10, obj.isPrototypeOf);
        this.assertEquals(11, obj.hasOwnProperty);
        this.assertEquals(12, obj.toLocaleString);
        this.assertEquals(13, obj.toString);
        this.assertEquals(14, obj.valueOf);
        qx.Class.undefine("qx.test.Construct");
      },
      testDefineShadowedStatics: function testDefineShadowedStatics() {
        qx.Bootstrap.define("qx.test.Construct", {
          extend: Object,
          statics: {
            "isPrototypeOf": 10,
            "toLocaleString": 12,
            "toString": 13,
            "valueOf": 14
          }
        });
        this.assertEquals(10, qx.test.Construct.isPrototypeOf);
        this.assertEquals(12, qx.test.Construct.toLocaleString);
        this.assertEquals(13, qx.test.Construct.toString);
        this.assertEquals(14, qx.test.Construct.valueOf);
        qx.Class.undefine("qx.test.Construct");
      }
    }
  });
  qx.test.Bootstrap.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.theme.Classic": {},
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.core.Init": {},
      "qx.theme.manager.Meta": {},
      "qx.ui.root.Application": {},
      "qx.ui.core.queue.Manager": {},
      "qx.lang.Object": {},
      "qx.core.ObjectRegistry": {},
      "qx.event.Registration": {},
      "qx.lang.Array": {},
      "qx.ui.core.Widget": {},
      "qx.bom.element.Style": {},
      "qx.event.type.Tap": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @use(qx.theme.Classic)
   */
  qx.Class.define("qx.test.ui.LayoutTestCase", {
    extend: qx.dev.unit.TestCase,
    type: "abstract",
    statics: {
      $$clazz: null,
      $$args: null
    },
    members: {
      setUp: function setUp() {
        this.getRoot();
      },
      tearDown: function tearDown() {
        this.getRoot().removeAll().forEach(function (widget) {
          widget.dispose();
        });
        var cls = qx.test.ui.LayoutTestCase;

        if (cls._root) {
          cls._root.destroy();

          cls._root = null;
          qx.core.Init.getApplication = cls.__oldGetApp__P_278_0;
        }
      },
      getRoot: function getRoot() {
        var cls = qx.test.ui.LayoutTestCase;

        if (cls._root) {
          return cls._root;
        }

        qx.theme.manager.Meta.getInstance().initialize();
        cls._root = new qx.ui.root.Application(document);
        cls.__oldApplication__P_278_1 = qx.core.Init.getApplication();
        cls.__oldGetApp__P_278_0 = qx.core.Init.getApplication;

        qx.core.Init.getApplication = function () {
          return {
            getRoot: function getRoot() {
              return cls._root;
            },
            close: function close() {},
            terminate: function terminate() {}
          };
        };

        return cls._root;
      },
      getRunnerApplication: function getRunnerApplication() {
        return qx.test.ui.LayoutTestCase.__oldApplication__P_278_1 || qx.core.Init.getApplication();
      },
      flush: function flush() {
        qx.ui.core.queue.Manager.flush();
      },
      assertDestroy: function assertDestroy(fcn, context, msg) {
        // call function
        fcn.call(context);
        this.flush();
        this.flush(); // copy object registry

        var regCopy = qx.lang.Object.clone(qx.core.ObjectRegistry.getRegistry()); // copy event listener structure

        var eventMgr = qx.event.Registration.getManager(window);
        var listeners = eventMgr.getAllListeners();
        var listenersCopy = {};

        for (var hash in listeners) {
          listenersCopy[hash] = {};

          for (var key in listeners[hash]) {
            listenersCopy[hash][key] = qx.lang.Array.clone(listeners[hash][key]);
          }
        } // call function


        fcn.call(context);
        this.flush();
        this.flush(); // measure increase in object counts
        // check object registry

        var reg = qx.core.ObjectRegistry.getRegistry();

        for (key in reg) {
          var obj = reg[key]; // skip pooled objects + DeferredCall which cleans the event listener blacklist

          if (obj.$$pooled || obj.$$blackListCleaner) {
            continue;
          }

          this.assertNotUndefined(regCopy[key], msg + ": The object '" + obj.classname + "' has not been disposed!");
        }

        listeners = eventMgr.getAllListeners();

        for (var hash in listeners) {
          if (!listenersCopy[hash]) {
            listenersCopy[hash] = {};
          }

          for (key in listeners[hash]) {
            if (!listenersCopy[hash][key]) {
              listenersCopy[hash][key] = [];
            }

            for (var i = 0; i < listeners[hash][key].length; i++) {
              if (listenersCopy[hash][key].indexOf(listeners[hash][key][i]) == -1) {
                this.fail(msg + ": The event listener '" + key + ":" + listeners[hash][key][i] + "'for the object '" + hash + ":" + qx.core.ObjectRegistry.fromHashCode(hash) + "' has not been removed.");
              }
            }
          }
        } // check root children length


        this.assertIdentical(0, this.getRoot().getChildren().length, msg + ": The root Children array must be empty but found: " + this.getRoot().getChildren().join(", "));
      },

      /**
       * @lint ignoreDeprecated(eval)
       */
      assertWidgetDispose: function assertWidgetDispose(clazz, args, msg) {
        this.assertDestroy(function () {
          var argStr = [];

          for (var i = 0; i < args.length; i++) {
            argStr.push("qx.test.ui.LayoutTestCase.$$args[" + i + "]");
          }

          qx.test.ui.LayoutTestCase.$$clazz = clazz;
          qx.test.ui.LayoutTestCase.$$args = args;
          var str = "new qx.test.ui.LayoutTestCase.$$clazz(" + argStr.join(", ") + ");";
          var widget = eval(str);
          this.getRoot().add(widget);
          this.flush();
          widget.destroy();
        }, this, msg);
      },
      _getFixedWidget: function _getFixedWidget() {
        var widget = new qx.ui.core.Widget();
        widget.set({
          width: 200,
          height: 100,
          maxWidth: "pref",
          minWidth: "pref",
          maxHeight: "pref",
          minHeight: "pref"
        });
        return widget;
      },
      assertSize: function assertSize(widget, width, height, msg) {
        this.flush();
        var el = widget.getContentElement().getDomElement();
        var elHeight = parseInt(el.style.height, 10);
        var elWidth = parseInt(el.style.width, 10);
        this.assertEquals(width, elWidth, msg);
        this.assertEquals(height, elHeight, msg);
      },
      assertPadding: function assertPadding(widget, top, right, bottom, left, msg) {
        this.flush();
        this.assertNotNull(widget.getContentElement());
        this.assertNotNull(widget.getContentElement().getDomElement());
        var content = widget.getContentElement().getDomElement();
        var paddingTop = parseInt(qx.bom.element.Style.get(content, "paddingTop"), 10) || 0;
        var paddingRight = parseInt(qx.bom.element.Style.get(content, "paddingRight"), 10) || 0;
        var paddingBottom = parseInt(qx.bom.element.Style.get(content, "paddingBottom"), 10) || 0;
        var paddingLeft = parseInt(qx.bom.element.Style.get(content, "paddingLeft"), 10) || 0;
        this.assertEquals(top, paddingTop, msg);
        this.assertEquals(right, paddingRight, msg);
        this.assertEquals(bottom, paddingBottom, msg);
        this.assertEquals(left, paddingLeft, msg);
      },
      assertStyle: function assertStyle(widget, style, value, msg) {
        this.flush();
        var element = widget.getContentElement().getDomElement();
        var computedStyle = qx.bom.element.Style.get(element, style);

        if (value && style.match(/color/i)) {
          this.assertCssColor(value, computedStyle, msg);
        } else {
          this.assertEquals(value, computedStyle, msg);
        }
      },
      tapOn: function tapOn(widget) {
        widget.fireEvent("tap", qx.event.type.Tap, [{}, widget, widget, false, true]);
      }
    }
  });
  qx.test.ui.LayoutTestCase.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.bom.client.Browser": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "browser.version": {
          "className": "qx.bom.client.Browser"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.Browser", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      testForIn: function testForIn() {
        var map = {};
        map["234"] = 234;
        map["123"] = 123;
        map["345"] = 345;
        var order = ["234", "123", "345"]; // google chrome, opera 10.5, Safari 7 and ie 9

        if (qx.core.Environment.get("browser.name").indexOf("chrome") != -1 || qx.core.Environment.get("browser.name") == "edge" || qx.core.Environment.get("browser.name") == "opera" && qx.core.Environment.get("browser.version") >= 10.5 || qx.core.Environment.get("browser.name") == "ie" && qx.core.Environment.get("browser.documentmode") >= 9 || qx.core.Environment.get("browser.name") == "firefox" && qx.core.Environment.get("browser.version") >= 21 || qx.core.Environment.get("browser.name") == "safari" && qx.core.Environment.get("browser.version") >= 7) {
          var i = 0; // is in a sorted order

          for (var key in map) {
            if (i == 0) {
              this.assertEquals("123", key, "1");
            } else if (i == 1) {
              this.assertEquals("234", key, "2");
            } else {
              this.assertEquals("345", key, "3");
            }

            i++;
          }
        } // default browsers
        else {
            var i = 0; // should be the same order the elements were added

            for (var key in map) {
              this.assertEquals(order[i], key);
              i++;
            }
          }
      }
    }
  });
  qx.test.Browser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Css": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "css.rgba": {
          "load": true,
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Windows classic color theme
   */
  qx.Theme.define("qx.theme.classic.Color", {
    colors: {
      "background": "#EBE9ED",
      "background-light": "#F3F0F5",
      "light-background": "#EBE9ED",
      // compatibility
      "background-focused": "#F3F8FD",
      "background-focused-inner": "#DBEAF9",
      "background-disabled": "#F4F4F4",
      "background-selected": "#3E6CA8",
      "background-field": "white",
      "background-pane": "#FAFBFE",
      "background-invalid": "#FFE0E0",
      "border-lead": "#888888",
      "border-light": "white",
      "border-light-shadow": "#DCDFE4",
      "border-dark-shadow": "#A7A6AA",
      "border-dark": "#85878C",
      // alias for compatibility reasons
      "border-main": "#85878C",
      "border-focused-light": "#BCCEE5",
      "border-focused-light-shadow": "#A5BDDE",
      "border-focused-dark-shadow": "#7CA0CF",
      "border-focused-dark": "#3E6CA8",
      "border-separator": "#808080",
      // shadows
      "shadow": qx.core.Environment.get("css.rgba") ? "rgba(0, 0, 0, 0.4)" : "#666666",
      "invalid": "#990000",
      "border-focused-invalid": "#FF9999",
      "text": "black",
      "text-disabled": "#A7A6AA",
      "text-selected": "white",
      "text-focused": "#3E5B97",
      "text-placeholder": "#CBC8CD",
      "tooltip": "#FFFFE1",
      "tooltip-text": "black",
      "tooltip-invalid": "#C82C2C",
      "button": "#EBE9ED",
      "button-hovered": "#F6F5F7",
      "button-abandoned": "#F9F8E9",
      "button-checked": "#F3F0F5",
      "window-active-caption-text": [255, 255, 255],
      "window-inactive-caption-text": [255, 255, 255],
      "window-active-caption": [51, 94, 168],
      "window-inactive-caption": [111, 161, 217],
      "date-chooser": "white",
      "date-chooser-title": [116, 116, 116],
      "date-chooser-selected": [52, 52, 52],
      "effect": [254, 200, 60],
      "table-pane": "white",
      "table-header": [242, 242, 242],
      "table-header-border": [214, 213, 217],
      "table-header-cell": [235, 234, 219],
      "table-header-cell-hover": [255, 255, 255],
      "table-focus-indicator": [179, 217, 255],
      "table-row-background-focused-selected": [90, 138, 211],
      "table-row-background-focused": [221, 238, 255],
      "table-row-background-selected": [51, 94, 168],
      "table-row-background-even": [250, 248, 243],
      "table-row-background-odd": [255, 255, 255],
      "table-row-selected": [255, 255, 255],
      "table-row": [0, 0, 0],
      "table-row-line": "#EEE",
      "table-column-line": "#EEE",
      "progressive-table-header": "#AAAAAA",
      "progressive-table-row-background-even": [250, 248, 243],
      "progressive-table-row-background-odd": [255, 255, 255],
      "progressive-progressbar-background": "gray",
      "progressive-progressbar-indicator-done": "#CCCCCC",
      "progressive-progressbar-indicator-undone": "white",
      "progressive-progressbar-percent-background": "gray",
      "progressive-progressbar-percent-text": "white"
    }
  });
  qx.theme.classic.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Til Schneider (til132)
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The classic qooxdoo decoration theme.
   */
  qx.Theme.define("qx.theme.classic.Decoration", {
    aliases: {
      decoration: "qx/decoration/Classic"
    },
    decorations: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "main": {
        style: {
          width: 1,
          color: "border-dark"
        }
      },
      "keyboard-focus": {
        style: {
          width: 1,
          color: "black",
          style: "dotted"
        }
      },

      /*
      ---------------------------------------------------------------------------
        THREE DIMENSIONAL
      ---------------------------------------------------------------------------
      */
      "inset": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-dark-shadow", "border-light", "border-light", "border-dark-shadow"],
          innerColor: ["border-dark", "border-light-shadow", "border-light-shadow", "border-dark"]
        }
      },
      "outset": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-light-shadow", "border-dark", "border-dark", "border-light-shadow"],
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"]
        }
      },
      "groove": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-dark-shadow", "border-light", "border-light", "border-dark-shadow"],
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"]
        }
      },
      "ridge": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"],
          innerColor: ["border-dark-shadow", "border-light", "border-light", "border-dark-shadow"]
        }
      },
      "inset-thin": {
        style: {
          width: 1,
          color: ["border-dark-shadow", "border-light", "border-light", "border-dark-shadow"]
        }
      },
      "outset-thin": {
        style: {
          width: 1,
          color: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"]
        }
      },
      "focused-inset": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-focused-dark-shadow", "border-focused-light", "border-focused-light", "border-focused-dark-shadow"],
          innerColor: ["border-focused-dark", "border-focused-light-shadow", "border-focused-light-shadow", "border-focused-dark"]
        }
      },
      "focused-outset": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-focused-light-shadow", "border-focused-dark", "border-focused-dark", "border-focused-light-shadow"],
          innerColor: ["border-focused-light", "border-focused-dark-shadow", "border-focused-dark-shadow", "border-focused-light"]
        }
      },
      "border-invalid": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-dark-shadow", "border-light", "border-light", "border-dark-shadow"],
          innerColor: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        SEPARATOR
      ---------------------------------------------------------------------------
      */
      "separator-horizontal": {
        style: {
          widthLeft: 1,
          colorLeft: "border-separator"
        }
      },
      "separator-vertical": {
        style: {
          widthTop: 1,
          colorTop: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        include: "outset",
        style: {
          shadowLength: 1,
          shadowBlurRadius: 2,
          shadowColor: "shadow"
        }
      },

      /*
      ---------------------------------------------------------------------------
        LIST ITEM
      ---------------------------------------------------------------------------
      */
      "lead-item": {
        style: {
          width: 1,
          style: "dotted",
          color: "border-lead"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOL TIP / POPUP
      ---------------------------------------------------------------------------
      */
      "tooltip": {
        style: {
          width: 1,
          color: "tooltip-text",
          shadowLength: 1,
          shadowBlurRadius: 5,
          shadowColor: "shadow"
        }
      },
      "tooltip-error": {
        style: {
          width: 1,
          color: "tooltip-text",
          shadowLength: 1,
          shadowBlurRadius: 5,
          shadowColor: "shadow"
        }
      },
      "popup": {
        include: "main",
        style: {
          shadowLength: 2,
          shadowBlurRadius: 2,
          shadowColor: "shadow"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar-separator": {
        style: {
          widthLeft: 1,
          colorLeft: "border-dark-shadow"
        }
      },
      "toolbar-part-handle": {
        style: {
          width: 1,
          style: "solid",
          colorTop: "white",
          colorLeft: "white",
          colorRight: "border-dark-shadow",
          colorBottom: "border-dark-shadow"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        include: "outset",
        style: {
          shadowLength: 1,
          shadowBlurRadius: 3,
          shadowColor: "shadow"
        }
      },
      "menu-separator": {
        style: {
          widthTop: 1,
          widthBottom: 1,
          colorTop: "border-dark",
          colorBottom: "border-light"
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser-date-pane": {
        style: {
          widthTop: 1,
          colorTop: "gray",
          style: "solid"
        }
      },
      "datechooser-weekday": {
        style: {
          widthBottom: 1,
          colorBottom: "gray",
          style: "solid"
        }
      },
      "datechooser-week": {
        style: {
          widthRight: 1,
          colorRight: "gray",
          style: "solid"
        }
      },
      "datechooser-week-header": {
        style: {
          widthBottom: 1,
          colorBottom: "gray",
          widthRight: 1,
          colorRight: "gray",
          style: "solid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TAB VIEW
      ---------------------------------------------------------------------------
      */
      "tabview-page-button-top": {
        style: {
          width: 1,
          color: ["border-light-shadow", "border-dark", "border-dark", "border-light-shadow"],
          innerWidth: 1,
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"],
          widthBottom: 0,
          innerWidthBottom: 0
        }
      },
      "tabview-page-button-bottom": {
        style: {
          width: 1,
          color: ["border-light-shadow", "border-dark", "border-dark", "border-light-shadow"],
          innerWidth: 1,
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"],
          widthTop: 0,
          innerWidthTop: 0
        }
      },
      "tabview-page-button-left": {
        style: {
          width: 1,
          color: ["border-light-shadow", "border-dark", "border-dark", "border-light-shadow"],
          innerWidth: 1,
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"],
          widthRight: 0,
          innerWidthRight: 0
        }
      },
      "tabview-page-button-right": {
        style: {
          width: 1,
          color: ["border-light-shadow", "border-dark", "border-dark", "border-light-shadow"],
          innerWidth: 1,
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"],
          widthLeft: 0,
          innerWidthLeft: 0
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table-statusbar": {
        style: {
          widthTop: 1,
          colorTop: "border-dark-shadow",
          styleTop: "solid"
        }
      },
      "table-scroller-header": {
        style: {
          widthBottom: 1,
          colorBottom: "table-header-border",
          styleBottom: "solid"
        }
      },
      "table-scroller-focus-indicator": {
        style: {
          width: 2,
          color: "table-focus-indicator",
          style: "solid"
        }
      },
      "table-header-cell": {
        style: {
          widthRight: 1,
          colorRight: "table-header-border",
          styleRight: "solid"
        }
      },
      "table-header-cell-hovered": {
        style: {
          widthRight: 1,
          colorRight: "table-header-border",
          styleRight: "solid",
          widthBottom: 2,
          colorBottom: "effect",
          styleBottom: "solid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: {
          backgroundColor: "#FFF",
          width: 1,
          color: "border-separator"
        }
      }
    }
  });
  qx.theme.classic.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
  
  ************************************************************************* */

  /**
   * The classic qooxdoo font theme.
   */
  qx.Theme.define("qx.theme.classic.Font", {
    fonts: {
      "default": {
        size: 11,
        lineHeight: 1.4,
        family: ["Lucida Grande", "Tahoma", "Verdana", "Bitstream Vera Sans", "Liberation Sans"]
      },
      "bold": {
        size: 11,
        lineHeight: 1.4,
        family: ["Lucida Grande", "Tahoma", "Verdana", "Bitstream Vera Sans", "Liberation Sans"],
        bold: true
      },
      "small": {
        size: 10,
        lineHeight: 1.4,
        family: ["Lucida Grande", "Tahoma", "Verdana", "Bitstream Vera Sans", "Liberation Sans"]
      },
      "monospace": {
        size: 11,
        lineHeight: 1.4,
        family: ["DejaVu Sans Mono", "Courier New", "monospace"]
      }
    }
  });
  qx.theme.classic.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Til Schneider (til132)
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The classic qooxdoo appearance theme.
   *
   * @asset(qx/icon/Oxygen/16/apps/office-calendar.png)
   * @asset(qx/icon/Oxygen/16/places/folder-open.png)
   * @asset(qx/icon/Oxygen/16/places/folder.png)
   * @asset(qx/icon/Oxygen/16/mimetypes/text-plain.png)
   * @asset(qx/icon/Oxygen/16/actions/view-refresh.png)
   * @asset(qx/icon/Oxygen/16/actions/window-close.png)
   * @asset(qx/icon/Oxygen/16/actions/dialog-cancel.png)
   * @asset(qx/icon/Oxygen/16/actions/dialog-ok.png)
   *
   * @asset(qx/decoration/Classic/*)
   */
  qx.Theme.define("qx.theme.classic.Appearance", {
    appearances: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "widget": {},
      "label": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "image": {
        style: function style(states) {
          return {
            opacity: !states.replacement && states.disabled ? 0.3 : undefined
          };
        }
      },
      "atom": {},
      "atom/label": "label",
      "atom/icon": "image",
      "root": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: "text",
            font: "default"
          };
        }
      },
      "popup": {
        style: function style(states) {
          return {
            decorator: "popup",
            backgroundColor: "background-pane"
          };
        }
      },
      "tooltip": {
        include: "popup",
        style: function style(states) {
          return {
            backgroundColor: "tooltip",
            textColor: "tooltip-text",
            decorator: "tooltip",
            padding: [1, 3, 2, 3],
            offset: [15, 5, 5, 5]
          };
        }
      },
      "tooltip/atom": "atom",
      "tooltip-error": {
        include: "tooltip",
        style: function style(states) {
          return {
            textColor: "text-selected",
            showTimeout: 100,
            hideTimeout: 10000,
            decorator: "tooltip-error",
            font: "bold",
            backgroundColor: "tooltip-invalid"
          };
        }
      },
      "tooltip-error/atom": "atom",
      "iframe": {
        style: function style(states) {
          return {
            backgroundColor: "white",
            decorator: "inset"
          };
        }
      },
      "move-frame": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },
      "resize-frame": "move-frame",
      "dragdrop-cursor": {
        style: function style(states) {
          var icon = "nodrop";

          if (states.copy) {
            icon = "copy";
          } else if (states.move) {
            icon = "move";
          } else if (states.alias) {
            icon = "alias";
          }

          return {
            source: "decoration/cursors/" + icon + ".gif",
            position: "right-top",
            offset: [2, 16, 2, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button-frame": {
        alias: "atom",
        style: function style(states) {
          if (states.pressed || states.abandoned || states.checked) {
            var decorator = !states.inner && states.focused ? "focused-inset" : "inset";
            var padding = [4, 3, 2, 5];
          } else {
            var decorator = !states.inner && states.focused ? "focused-outset" : "outset";
            var padding = [3, 4];
          }

          return {
            backgroundColor: states.abandoned ? "button-abandoned" : states.hovered ? "button-hovered" : states.checked ? "button-checked" : "button",
            decorator: decorator,
            padding: padding
          };
        }
      },
      "button": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          return {
            center: true
          };
        }
      },
      "toggle-button": "button",
      "hover-button": {
        alias: "atom",
        include: "atom",
        style: function style(states) {
          return {
            backgroundColor: states.hovered ? "background-selected" : undefined,
            textColor: states.hovered ? "text-selected" : undefined
          };
        }
      },
      "menubutton": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.gif",
            iconPosition: "right"
          };
        }
      },
      "splitbutton": {},
      "splitbutton/button": "button",
      "splitbutton/arrow": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLLAREA
      ---------------------------------------------------------------------------
      */
      "scrollarea/corner": {
        style: function style() {
          return {
            backgroundColor: "background"
          };
        }
      },
      "scrollarea": "widget",
      "scrollarea/pane": "widget",
      "scrollarea/scrollbar-x": "scrollbar",
      "scrollarea/scrollbar-y": "scrollbar",

      /*
      ---------------------------------------------------------------------------
        LIST
      ---------------------------------------------------------------------------
      */
      "list": {
        alias: "scrollarea",
        style: function style(states) {
          var backgroundColor;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (invalid && !disabled) {
            backgroundColor = "background-invalid";
          } else if (focused && !invalid && !disabled) {
            backgroundColor = "background-focused";
          } else if (disabled) {
            backgroundColor = "background-disabled";
          } else {
            backgroundColor = "white";
          }

          return {
            decorator: states.focused ? "focused-inset" : "inset",
            backgroundColor: backgroundColor
          };
        }
      },
      "listitem": {
        alias: "atom",
        style: function style(states) {
          return {
            gap: 4,
            padding: states.lead ? [2, 4] : [3, 5],
            backgroundColor: states.selected ? "background-selected" : undefined,
            textColor: states.selected ? "text-selected" : undefined,
            decorator: states.lead ? "lead-item" : undefined,
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        FORM FIELDS
      ---------------------------------------------------------------------------
      */
      "form-renderer-label": {
        include: "label",
        style: function style() {
          return {
            paddingTop: 4
          };
        }
      },
      "textfield": {
        style: function style(states) {
          var backgroundColor;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (invalid && !disabled) {
            backgroundColor = "background-invalid";
          } else if (focused && !invalid && !disabled) {
            backgroundColor = "background-focused";
          } else if (disabled) {
            backgroundColor = "background-disabled";
          } else {
            backgroundColor = "background-field";
          }

          var textColor;

          if (states.disabled) {
            textColor = "text-disabled";
          } else if (states.showingPlaceholder) {
            textColor = "text-placeholder";
          } else {
            textColor = undefined;
          }

          return {
            decorator: states.focused ? "focused-inset" : "inset",
            padding: [2, 3],
            textColor: textColor,
            backgroundColor: backgroundColor
          };
        }
      },
      "textarea": "textfield",
      "checkbox": {
        alias: "atom",
        style: function style(states) {
          // The "disabled" icon is set to an icon **without** the -disabled
          // suffix on purpose. This is because the Image widget handles this
          // already by replacing the current image with a disabled version
          // (if available). If no disabled image is found, the opacity style
          // is used.
          var icon; // Checked

          if (states.checked) {
            if (states.disabled) {
              icon = "checkbox-checked";
            } else if (states.focused) {
              icon = "checkbox-checked-focused";
            } else if (states.pressed) {
              icon = "checkbox-checked-pressed";
            } else if (states.hovered) {
              icon = "checkbox-checked-hovered";
            } else {
              icon = "checkbox-checked";
            } // Undetermined

          } else if (states.undetermined) {
            if (states.disabled) {
              icon = "checkbox-undetermined";
            } else if (states.focused) {
              icon = "checkbox-undetermined-focused";
            } else if (states.hovered) {
              icon = "checkbox-undetermined-hovered";
            } else {
              icon = "checkbox-undetermined";
            } // Focused & Pressed & Hovered (when enabled)

          } else if (!states.disabled) {
            if (states.focused) {
              icon = "checkbox-focused";
            } else if (states.pressed) {
              icon = "checkbox-pressed";
            } else if (states.hovered) {
              icon = "checkbox-hovered";
            }
          } // Unchecked


          icon = icon || "checkbox";
          var invalid = states.invalid && !states.disabled ? "-invalid" : "";
          return {
            icon: "decoration/form/" + icon + invalid + ".png",
            gap: 6
          };
        }
      },
      "radiobutton": {
        alias: "checkbox",
        include: "checkbox",
        style: function style(states) {
          // "disabled" state is not handled here with purpose. The image widget
          // does handle this already by replacing the current image with a
          // disabled version (if available). If no disabled image is found the
          // opacity style is used.
          var icon;

          if (states.checked && states.focused) {
            icon = "radiobutton-checked-focused";
          } else if (states.checked && states.disabled) {
            icon = "radiobutton-checked-disabled";
          } else if (states.checked && states.pressed) {
            icon = "radiobutton-checked-pressed";
          } else if (states.checked && states.hovered) {
            icon = "radiobutton-checked-hovered";
          } else if (states.checked) {
            icon = "radiobutton-checked";
          } else if (states.focused) {
            icon = "radiobutton-focused";
          } else if (states.pressed) {
            icon = "radiobutton-pressed";
          } else if (states.hovered) {
            icon = "radiobutton-hovered";
          } else {
            icon = "radiobutton";
          }

          var invalid = states.invalid && !states.disabled ? "-invalid" : "";
          return {
            icon: "decoration/form/" + icon + invalid + ".png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPINNER
      ---------------------------------------------------------------------------
      */
      "spinner": {
        style: function style(states) {
          return {
            decorator: states.focused ? "focused-inset" : "inset",
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "spinner/textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 3]
          };
        }
      },
      "spinner/upbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/up-small.gif",
            padding: states.pressed ? [2, 2, 0, 4] : [1, 3, 1, 3],
            backgroundColor: states.hovered ? "button-hovered" : "button"
          };
        }
      },
      "spinner/downbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down-small.gif",
            padding: states.pressed ? [2, 2, 0, 4] : [1, 3, 1, 3],
            backgroundColor: states.hovered ? "button-hovered" : "button"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATEFIELD
      ---------------------------------------------------------------------------
      */
      "datefield": "combobox",
      "datefield/button": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          return {
            icon: "icon/16/apps/office-calendar.png",
            padding: [0, 3],
            backgroundColor: undefined,
            decorator: undefined
          };
        }
      },
      "datefield/list": {
        alias: "datechooser",
        include: "datechooser",
        style: function style(states) {
          return {
            decorator: states.focused ? "focused-inset" : "inset"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "groupbox": {
        style: function style(states) {
          return {
            backgroundColor: "background"
          };
        }
      },
      "groupbox/legend": {
        alias: "atom",
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: states.invalid ? "invalid" : undefined,
            padding: [1, 0, 1, 4]
          };
        }
      },
      "groupbox/frame": {
        style: function style(states) {
          return {
            padding: [12, 9],
            marginTop: 10,
            decorator: "groove"
          };
        }
      },
      "check-groupbox": "groupbox",
      "check-groupbox/legend": {
        alias: "checkbox",
        include: "checkbox",
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: states.invalid ? "invalid" : undefined,
            padding: [1, 0, 1, 4]
          };
        }
      },
      "radio-groupbox": "groupbox",
      "radio-groupbox/legend": {
        alias: "radiobutton",
        include: "radiobutton",
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: states.invalid ? "invalid" : undefined,
            padding: [1, 0, 1, 4]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar": {
        style: function style(states) {
          return {
            backgroundColor: "background"
          };
        }
      },
      "toolbar/part": {},
      "toolbar/part/container": {},
      "toolbar/part/handle": {
        style: function style(states) {
          return {
            decorator: "toolbar-part-handle",
            backgroundColor: "background",
            padding: [0, 1],
            margin: [3, 2],
            allowGrowY: true
          };
        }
      },
      "toolbar-separator": {
        style: function style(states) {
          return {
            margin: [3, 2],
            decorator: "toolbar-separator"
          };
        }
      },
      "toolbar-button": {
        alias: "atom",
        style: function style(states) {
          if (states.pressed || states.checked || states.abandoned) {
            var border = "inset-thin";
            var padding = [3, 2, 1, 4];
          } else if (states.hovered && !states.disabled) {
            var border = "outset-thin";
            var padding = [2, 3];
          } else {
            var border = undefined;
            var padding = [3, 4];
          }

          return {
            cursor: "default",
            decorator: border,
            padding: padding,
            backgroundColor: states.abandoned ? "button-abandoned" : states.checked ? "background-light" : "button"
          };
        }
      },
      "toolbar-menubutton": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          return {
            showArrow: true
          };
        }
      },
      "toolbar-menubutton/arrow": {
        alias: "image",
        include: "image",
        style: function style(states) {
          return {
            source: "decoration/arrows/down-small.gif"
          };
        }
      },
      "toolbar-splitbutton": {},
      "toolbar-splitbutton/button": "toolbar-button",
      "toolbar-splitbutton/arrow": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDEBAR
      ---------------------------------------------------------------------------
      */
      "slidebar": {},
      "slidebar/scrollpane": {},
      "slidebar/content": {},
      "slidebar/button-forward": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: states.vertical ? "decoration/arrows/down.gif" : "decoration/arrows/next.gif"
          };
        }
      },
      "slidebar/button-backward": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: states.vertical ? "decoration/arrows/up.gif" : "decoration/arrows/left.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview": {},
      "tabview/bar": {
        alias: "slidebar",
        style: function style(states) {
          var marginTop = 0,
              marginRight = 0,
              marginBottom = 0,
              marginLeft = 0;

          if (states.barTop) {
            marginBottom = -2;
          } else if (states.barBottom) {
            marginTop = -2;
          } else if (states.barRight) {
            marginLeft = -2;
          } else {
            marginRight = -2;
          }

          return {
            marginBottom: marginBottom,
            marginTop: marginTop,
            marginLeft: marginLeft,
            marginRight: marginRight
          };
        }
      },
      "tabview/bar/button-forward": {
        include: "slidebar/button-forward",
        alias: "slidebar/button-forward",
        style: function style(states) {
          if (states.barTop || states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 2
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 2
            };
          }
        }
      },
      "tabview/bar/button-backward": {
        include: "slidebar/button-backward",
        alias: "slidebar/button-backward",
        style: function style(states) {
          if (states.barTop || states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 2
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 2
            };
          }
        }
      },
      "tabview/pane": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            decorator: "outset",
            padding: 10
          };
        }
      },
      "tabview-page": "widget",
      "tabview-page/button": {
        style: function style(states) {
          var decorator;
          var marginTop = 0,
              marginRight = 0,
              marginBottom = 0,
              marginLeft = 0;

          if (states.barTop || states.barBottom) {
            var paddingTop = 2,
                paddingBottom = 2,
                paddingLeft = 6,
                paddingRight = 6;
          } else {
            var paddingTop = 6,
                paddingBottom = 6,
                paddingLeft = 6,
                paddingRight = 6;
          }

          if (states.barTop) {
            decorator = "tabview-page-button-top";
          } else if (states.barRight) {
            decorator = "tabview-page-button-right";
          } else if (states.barBottom) {
            decorator = "tabview-page-button-bottom";
          } else {
            decorator = "tabview-page-button-left";
          }

          if (states.checked) {
            if (states.barTop || states.barBottom) {
              paddingLeft += 2;
              paddingRight += 2;
            } else {
              paddingTop += 2;
              paddingBottom += 2;
            }
          } else {
            if (states.barTop || states.barBottom) {
              marginBottom += 2;
              marginTop += 2;
            } else if (states.barLeft || states.barRight) {
              marginRight += 2;
              marginLeft += 2;
            }
          }

          if (states.checked) {
            if (!states.firstTab) {
              if (states.barTop || states.barBottom) {
                marginLeft = -4;
              } else {
                marginTop = -4;
              }
            }

            if (!states.lastTab) {
              if (states.barTop || states.barBottom) {
                marginRight = -4;
              } else {
                marginBottom = -4;
              }
            }
          }

          return {
            zIndex: states.checked ? 10 : 5,
            decorator: decorator,
            backgroundColor: "background",
            padding: [paddingTop, paddingRight, paddingBottom, paddingLeft],
            margin: [marginTop, marginRight, marginBottom, marginLeft],
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "tabview-page/button/label": {
        alias: "label",
        style: function style(states) {
          return {
            padding: states.focused ? [0, 1, 0, 1] : [1, 2, 1, 2],
            decorator: states.focused ? "keyboard-focus" : undefined
          };
        }
      },
      "tabview-page/button/icon": "image",
      "tabview-page/button/close-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: "qx/icon/Oxygen/16/actions/window-close.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar": {},
      "scrollbar/slider": {
        alias: "slider",
        style: function style(states) {
          return {
            backgroundColor: "background-light"
          };
        }
      },
      "scrollbar/slider/knob": {
        include: "button-frame",
        style: function style(states) {
          return {
            height: 14,
            width: 14,
            minHeight: states.horizontal ? undefined : 9,
            minWidth: states.horizontal ? 9 : undefined
          };
        }
      },
      "scrollbar/button": {
        alias: "button",
        include: "button",
        style: function style(states) {
          var padding;

          if (states.up || states.down) {
            if (states.pressed || states.abandoned || states.checked) {
              padding = [5, 2, 3, 4];
            } else {
              padding = [4, 3];
            }
          } else {
            if (states.pressed || states.abandoned || states.checked) {
              padding = [4, 3, 2, 5];
            } else {
              padding = [3, 4];
            }
          }

          var icon = "decoration/arrows/";

          if (states.left) {
            icon += "left.gif";
          } else if (states.right) {
            icon += "right.gif";
          } else if (states.up) {
            icon += "up.gif";
          } else {
            icon += "down.gif";
          }

          return {
            padding: padding,
            icon: icon
          };
        }
      },
      "scrollbar/button-begin": "scrollbar/button",
      "scrollbar/button-end": "scrollbar/button",

      /*
      ---------------------------------------------------------------------------
        SLIDER
      ---------------------------------------------------------------------------
      */
      "slider": {
        style: function style(states) {
          var backgroundColor;

          if (states.disabled) {
            backgroundColor = "background-disabled";
          } else if (states.invalid) {
            backgroundColor = "background-invalid";
          } else if (states.focused) {
            backgroundColor = "background-light";
          } else {
            backgroundColor = "background-field";
          }

          return {
            backgroundColor: backgroundColor,
            decorator: states.focused ? "focused-inset" : "inset"
          };
        }
      },
      "slider/knob": {
        include: "button-frame",
        style: function style(states) {
          return {
            width: 14,
            height: 14,
            decorator: "outset"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREE
      ---------------------------------------------------------------------------
      */
      "tree-folder/open": {
        style: function style(states) {
          return {
            source: states.opened ? "decoration/tree/minus.gif" : "decoration/tree/plus.gif"
          };
        }
      },
      "tree-folder": {
        style: function style(states) {
          return {
            padding: [2, 3, 2, 0],
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png",
            iconOpened: "icon/16/places/folder-open.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree-folder/icon": {
        style: function style(states) {
          return {
            padding: [0, 4, 0, 0]
          };
        }
      },
      "tree-folder/label": {
        style: function style(states) {
          return {
            padding: [1, 2],
            backgroundColor: states.selected ? "background-selected" : undefined,
            textColor: states.selected ? "text-selected" : undefined
          };
        }
      },
      "tree-file": {
        include: "tree-folder",
        alias: "tree-folder",
        style: function style(states) {
          return {
            icon: "icon/16/mimetypes/text-plain.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree": {
        include: "list",
        alias: "list",
        style: function style(states) {
          return {
            contentPadding: [4, 4, 4, 4]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREEVIRTUAL
      ---------------------------------------------------------------------------
      */
      "treevirtual": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },
      "treevirtual-folder": {
        style: function style(states) {
          return {
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-file": {
        include: "treevirtual-folder",
        alias: "treevirtual-folder",
        style: function style(states) {
          return {
            icon: "icon/16/mimetypes/text-plain.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-line": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/line.gif"
          };
        }
      },
      "treevirtual-contract": {
        style: function style(states) {
          return {
            icon: "decoration/tree/minus.gif"
          };
        }
      },
      "treevirtual-expand": {
        style: function style(states) {
          return {
            icon: "decoration/tree/plus.gif"
          };
        }
      },
      "treevirtual-only-contract": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/only_minus.gif"
          };
        }
      },
      "treevirtual-only-expand": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/only_plus.gif"
          };
        }
      },
      "treevirtual-start-contract": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/start_minus.gif"
          };
        }
      },
      "treevirtual-start-expand": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/start_plus.gif"
          };
        }
      },
      "treevirtual-end-contract": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/end_minus.gif"
          };
        }
      },
      "treevirtual-end-expand": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/end_plus.gif"
          };
        }
      },
      "treevirtual-cross-contract": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/cross_minus.gif"
          };
        }
      },
      "treevirtual-cross-expand": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/cross_plus.gif"
          };
        }
      },
      "treevirtual-end": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/end.gif"
          };
        }
      },
      "treevirtual-cross": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/cross.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: function style(states) {
          return {
            contentPadding: [10, 10, 10, 10],
            backgroundColor: "background",
            decorator: states.maximized ? undefined : "window"
          };
        }
      },
      "window-resize-frame": "resize-frame",
      "window/pane": {},
      "window/captionbar": {
        style: function style(states) {
          return {
            padding: 1,
            backgroundColor: states.active ? "window-active-caption" : "window-inactive-caption",
            textColor: states.active ? "window-active-caption-text" : "window-inactive-caption-text"
          };
        }
      },
      "window/icon": {
        style: function style(states) {
          return {
            marginRight: 4
          };
        }
      },
      "window/title": {
        style: function style(states) {
          return {
            cursor: "default",
            font: "bold",
            marginRight: 20,
            alignY: "middle"
          };
        }
      },
      "window/minimize-button": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: "decoration/window/minimize.gif",
            padding: states.pressed || states.abandoned ? [2, 1, 0, 3] : [1, 2]
          };
        }
      },
      "window/restore-button": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: "decoration/window/restore.gif",
            padding: states.pressed || states.abandoned ? [2, 1, 0, 3] : [1, 2]
          };
        }
      },
      "window/maximize-button": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: "decoration/window/maximize.gif",
            padding: states.pressed || states.abandoned ? [2, 1, 0, 3] : [1, 2]
          };
        }
      },
      "window/close-button": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            marginLeft: 2,
            icon: "decoration/window/close.gif",
            padding: states.pressed || states.abandoned ? [2, 1, 0, 3] : [1, 2]
          };
        }
      },
      "window/statusbar": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            padding: [2, 6]
          };
        }
      },
      "window/statusbar-text": "label",

      /*
      ---------------------------------------------------------------------------
        RESIZER
      ---------------------------------------------------------------------------
      */
      "resizer": {
        style: function style(states) {
          return {
            decorator: "outset"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane": {},
      "splitpane/splitter": {
        style: function style(states) {
          return {
            backgroundColor: "background"
          };
        }
      },
      "splitpane/splitter/knob": {
        style: function style(states) {
          return {
            source: states.horizontal ? "decoration/splitpane/knob-horizontal.png" : "decoration/splitpane/knob-vertical.png",
            padding: 2
          };
        }
      },
      "splitpane/slider": {
        style: function style(states) {
          return {
            backgroundColor: "border-dark",
            opacity: 0.3
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTBOX
      ---------------------------------------------------------------------------
      */
      "selectbox": {
        include: "button-frame",
        style: function style(states) {
          var background = "button";

          if (states.invalid && !states.disabled) {
            background = "background-invalid";
          } else if (states.abandoned) {
            background = "button-abandoned";
          } else if (!states.abandoned && states.hovered) {
            background = "button-hovered";
          } else if (!states.abandoned && !states.hovered && states.checked) {
            background = "button-checked";
          }

          return {
            backgroundColor: background
          };
        }
      },
      "selectbox/atom": "atom",
      "selectbox/popup": "popup",
      "selectbox/list": "list",
      "selectbox/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: "decoration/arrows/down.gif",
            paddingRight: 4,
            paddingLeft: 5
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser": {
        style: function style(states) {
          return {
            decorator: "outset"
          };
        }
      },
      "datechooser/navigation-bar": {
        style: function style(states) {
          return {
            backgroundColor: "date-chooser",
            textColor: states.disabled ? "text-disabled" : states.invalid ? "invalid" : undefined,
            padding: [2, 10]
          };
        }
      },
      "datechooser/last-year-button-tooltip": "tooltip",
      "datechooser/last-month-button-tooltip": "tooltip",
      "datechooser/next-year-button-tooltip": "tooltip",
      "datechooser/next-month-button-tooltip": "tooltip",
      "datechooser/last-year-button": "datechooser/button",
      "datechooser/last-month-button": "datechooser/button",
      "datechooser/next-year-button": "datechooser/button",
      "datechooser/next-month-button": "datechooser/button",
      "datechooser/button/icon": {},
      "datechooser/button": {
        style: function style(states) {
          var result = {
            width: 17,
            show: "icon"
          };

          if (states.lastYear) {
            result.icon = "decoration/arrows/rewind.gif";
          } else if (states.lastMonth) {
            result.icon = "decoration/arrows/left.gif";
          } else if (states.nextYear) {
            result.icon = "decoration/arrows/forward.gif";
          } else if (states.nextMonth) {
            result.icon = "decoration/arrows/right.gif";
          }

          if (states.pressed || states.checked || states.abandoned) {
            result.decorator = "inset-thin";
          } else if (states.hovered) {
            result.decorator = "outset-thin";
          } else {
            result.decorator = undefined;
          }

          if (states.pressed || states.checked || states.abandoned) {
            result.padding = [2, 0, 0, 2];
          } else if (states.hovered) {
            result.padding = 1;
          } else {
            result.padding = 2;
          }

          return result;
        }
      },
      "datechooser/month-year-label": {
        style: function style(states) {
          return {
            font: "bold",
            textAlign: "center"
          };
        }
      },
      "datechooser/date-pane": {
        style: function style(states) {
          return {
            decorator: "datechooser-date-pane",
            backgroundColor: "date-chooser"
          };
        }
      },
      "datechooser/weekday": {
        style: function style(states) {
          return {
            decorator: "datechooser-weekday",
            font: "bold",
            textAlign: "center",
            textColor: states.disabled ? "text-disabled" : states.weekend ? "date-chooser-title" : "date-chooser",
            backgroundColor: states.weekend ? "date-chooser" : "date-chooser-title"
          };
        }
      },
      "datechooser/day": {
        style: function style(states) {
          return {
            textAlign: "center",
            decorator: states.today ? "main" : undefined,
            textColor: states.disabled ? "text-disabled" : states.selected ? "text-selected" : states.otherMonth ? "text-disabled" : undefined,
            backgroundColor: states.disabled ? undefined : states.selected ? "date-chooser-selected" : undefined,
            padding: [2, 4]
          };
        }
      },
      "datechooser/week": {
        style: function style(states) {
          return {
            textAlign: "center",
            textColor: "date-chooser-title",
            padding: [2, 4],
            decorator: states.header ? "datechooser-week-header" : "datechooser-week"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COMBOBOX
      ---------------------------------------------------------------------------
      */
      "combobox": {
        style: function style(states) {
          var backgroundColor;

          if (states.disabled) {
            backgroundColor = "background-disabled";
          } else if (states.invalid) {
            backgroundColor = "background-invalid";
          } else if (states.focused) {
            backgroundColor = "background-focused";
          } else {
            backgroundColor = "background-field";
          }

          return {
            decorator: states.focused ? "focused-inset" : "inset",
            textColor: states.disabled ? "text-disabled" : undefined,
            backgroundColor: backgroundColor
          };
        }
      },
      "combobox/button": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.gif",
            backgroundColor: states.hovered ? "button-hovered" : "button"
          };
        }
      },
      "combobox/popup": "popup",
      "combobox/list": "list",
      "combobox/textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 3],
            backgroundColor: undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        style: function style(states) {
          var result = {
            backgroundColor: "background",
            decorator: "menu",
            spacingX: 6,
            spacingY: 1,
            iconColumnWidth: 16,
            arrowColumnWidth: 4,
            padding: 1,
            placementModeY: states.submenu || states.contextmenu ? "best-fit" : "keep-align"
          };

          if (states.submenu) {
            result.position = "right-top";
            result.offset = [-2, -3];
          }

          if (states.contextmenu) {
            result.offset = 4;
          }

          return result;
        }
      },
      "menu/slidebar": "menu-slidebar",
      "menu-slidebar": "widget",
      "menu-slidebar-button": {
        style: function style(states) {
          return {
            backgroundColor: states.hovered ? "background-selected" : undefined,
            padding: 6,
            center: true
          };
        }
      },
      "menu-slidebar/button-backward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: states.hovered ? "decoration/arrows/up-invert.gif" : "decoration/arrows/up.gif"
          };
        }
      },
      "menu-slidebar/button-forward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: states.hovered ? "decoration/arrows/down-invert.gif" : "decoration/arrows/down.gif"
          };
        }
      },
      "menu-separator": {
        style: function style(states) {
          return {
            height: 0,
            decorator: "menu-separator",
            marginTop: 4,
            marginBottom: 4,
            marginLeft: 2,
            marginRight: 2
          };
        }
      },
      "menu-button": {
        alias: "atom",
        style: function style(states) {
          return {
            backgroundColor: states.selected ? "background-selected" : undefined,
            textColor: states.selected ? "text-selected" : undefined,
            padding: [2, 6]
          };
        }
      },
      "menu-button/icon": {
        include: "image",
        style: function style(states) {
          return {
            alignY: "middle"
          };
        }
      },
      "menu-button/label": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            padding: 1
          };
        }
      },
      "menu-button/shortcut": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            marginLeft: 14,
            padding: 1
          };
        }
      },
      "menu-button/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: states.selected ? "decoration/arrows/right-invert.gif" : "decoration/arrows/right.gif",
            alignY: "middle"
          };
        }
      },
      "menu-checkbox": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : states.selected ? "decoration/menu/checkbox-invert.gif" : "decoration/menu/checkbox.gif"
          };
        }
      },
      "menu-radiobutton": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : states.selected ? "decoration/menu/radiobutton-invert.gif" : "decoration/menu/radiobutton.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            decorator: "outset"
          };
        }
      },
      "menubar-button": {
        alias: "atom",
        style: function style(states) {
          return {
            padding: [2, 6],
            backgroundColor: states.pressed || states.hovered && !states.disabled ? "background-selected" : undefined,
            textColor: states.pressed || states.hovered ? "text-selected" : undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR SELECTOR
      ---------------------------------------------------------------------------
      */
      "colorselector": "widget",
      "colorselector/control-bar": "widget",
      "colorselector/visual-pane": "groupbox",
      "colorselector/control-pane": "widget",
      "colorselector/preset-grid": "widget",
      "colorselector/colorbucket": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            width: 16,
            height: 16
          };
        }
      },
      "colorselector/preset-field-set": "groupbox",
      "colorselector/input-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/preview-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/hex-field-composite": "widget",
      "colorselector/hex-field": "textfield",
      "colorselector/rgb-spinner-composite": "widget",
      "colorselector/rgb-spinner-red": "spinner",
      "colorselector/rgb-spinner-green": "spinner",
      "colorselector/rgb-spinner-blue": "spinner",
      "colorselector/hsb-spinner-composite": "widget",
      "colorselector/hsb-spinner-hue": "spinner",
      "colorselector/hsb-spinner-saturation": "spinner",
      "colorselector/hsb-spinner-brightness": "spinner",
      "colorselector/preview-content-old": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            width: 50,
            height: 10
          };
        }
      },
      "colorselector/preview-content-new": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            backgroundColor: "white",
            width: 50,
            height: 10
          };
        }
      },
      "colorselector/hue-saturation-field": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            margin: 5
          };
        }
      },
      "colorselector/brightness-field": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            margin: [5, 7]
          };
        }
      },
      "colorselector/hue-saturation-pane": "widget",
      "colorselector/hue-saturation-handle": "widget",
      "colorselector/brightness-pane": "widget",
      "colorselector/brightness-handle": "widget",

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table": "widget",
      "table/statusbar": {
        style: function style(states) {
          return {
            decorator: "table-statusbar",
            paddingLeft: 2,
            paddingRight: 2
          };
        }
      },
      "table/column-button": {
        alias: "button",
        style: function style(states) {
          var border, padding;

          if (states.pressed || states.checked || states.abandoned) {
            border = "inset-thin";
            padding = [3, 2, 1, 4];
          } else if (states.hovered) {
            border = "outset-thin";
            padding = [2, 3];
          } else {
            border = undefined;
            padding = [3, 4];
          }

          return {
            decorator: border,
            padding: padding,
            backgroundColor: states.abandoned ? "button-abandoned" : "button",
            icon: "decoration/table/select-column-order.png"
          };
        }
      },
      "table-column-reset-button": {
        extend: "menu-button",
        alias: "menu-button",
        style: function style() {
          return {
            icon: "icon/16/actions/view-refresh.png"
          };
        }
      },
      "table-scroller/scrollbar-x": "scrollbar",
      "table-scroller/scrollbar-y": "scrollbar",
      "table-scroller": "widget",
      "table-scroller/header": {
        style: function style(states) {
          return {
            decorator: "table-scroller-header",
            backgroundColor: "table-header"
          };
        }
      },
      "table-scroller/pane": {
        style: function style(states) {
          return {
            backgroundColor: "table-pane"
          };
        }
      },
      "table-scroller/focus-indicator": {
        style: function style(states) {
          return {
            decorator: "table-scroller-focus-indicator"
          };
        }
      },
      "table-scroller/resize-line": {
        style: function style(states) {
          return {
            backgroundColor: "table-header-border",
            width: 3
          };
        }
      },
      "table-header-cell": {
        alias: "atom",
        style: function style(states) {
          return {
            minWidth: 13,
            paddingLeft: 2,
            paddingRight: 2,
            paddingBottom: states.hovered ? 0 : 2,
            decorator: states.hovered ? "table-header-cell-hovered" : "table-header-cell",
            backgroundColor: states.hovered ? "table-header-cell-hover" : "table-header-cell",
            sortIcon: states.sorted ? states.sortedAscending ? "decoration/table/ascending.png" : "decoration/table/descending.png" : undefined
          };
        }
      },
      "table-header-cell/icon": {
        style: function style(states) {
          return {
            marginRight: 4,
            opacity: states.disabled ? 0.3 : 1
          };
        }
      },
      "table-header-cell/sort-icon": {
        style: function style(states) {
          return {
            alignY: "middle",
            opacity: states.disabled ? 0.3 : 1
          };
        }
      },
      "table-editor-textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 2]
          };
        }
      },
      "table-editor-selectbox": {
        include: "selectbox",
        alias: "selectbox",
        style: function style(states) {
          return {
            padding: [0, 2]
          };
        }
      },
      "table-editor-combobox": {
        include: "combobox",
        alias: "combobox",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },
      "progressive-table-header": {
        alias: "table-scroller/header"
      },
      "progressive-table-header-cell": {
        style: function style(states) {
          return {
            decorator: "table-header-cell",
            backgroundColor: "table-header-cell",
            padding: [0, 6, 0, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR POPUP
      ---------------------------------------------------------------------------
      */
      "colorpopup": {
        alias: "popup",
        include: "popup",
        style: function style(states) {
          return {
            decorator: "outset",
            padding: 5,
            backgroundColor: "background"
          };
        }
      },
      "colorpopup/field": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            margin: 2,
            width: 14,
            height: 14,
            backgroundColor: "background"
          };
        }
      },
      "colorpopup/selector-button": "button",
      "colorpopup/auto-button": "button",
      "colorpopup/preview-pane": "groupbox",
      "colorpopup/current-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginLeft: 4,
            decorator: "inset-thin",
            allowGrowX: true
          };
        }
      },
      "colorpopup/selected-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginRight: 4,
            decorator: "inset-thin",
            allowGrowX: true
          };
        }
      },
      "colorpopup/colorselector-okbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-ok.png"
          };
        }
      },
      "colorpopup/colorselector-cancelbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-cancel.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "virtual-list": "list",
      "virtual-list/row-layer": "row-layer",
      "row-layer": "widget",
      "column-layer": "widget",
      "group-item": {
        include: "label",
        alias: "label",
        style: function style(states) {
          return {
            padding: 4,
            backgroundColor: "#BABABA",
            textColor: "white",
            font: "bold"
          };
        }
      },
      "virtual-selectbox": "selectbox",
      "virtual-selectbox/dropdown": "popup",
      "virtual-selectbox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-combobox": "combobox",
      "virtual-combobox/dropdown": "popup",
      "virtual-combobox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-tree": {
        include: "tree",
        alias: "tree",
        style: function style(states) {
          return {
            itemHeight: 21
          };
        }
      },
      "virtual-tree-folder": "tree-folder",
      "virtual-tree-file": "tree-file",
      "cell": {
        style: function style(states) {
          return {
            backgroundColor: states.selected ? "table-row-background-selected" : "table-row-background-even",
            textColor: states.selected ? "text-selected" : "text",
            padding: [3, 6]
          };
        }
      },
      "cell-string": "cell",
      "cell-number": {
        include: "cell",
        style: function style(states) {
          return {
            textAlign: "right"
          };
        }
      },
      "cell-image": "cell",
      "cell-boolean": "cell",
      "cell-atom": "cell",
      "cell-date": "cell",
      "cell-html": "cell",

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: function style(states) {
          return {
            decorator: "progressbar",
            padding: [1],
            backgroundColor: "white",
            width: 200,
            height: 20
          };
        }
      },
      "progressbar/progress": {
        style: function style(states) {
          return {
            backgroundColor: states.disabled ? "background-disabled" : "background-selected"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header": {
        style: function style(states) {
          return {
            textColor: "text-selected",
            backgroundColor: "background-selected",
            padding: [8, 12]
          };
        }
      },
      "app-header-label": "label",
      "app-splitpane": {
        alias: "splitpane",
        style: function style(states) {
          return {
            padding: [0, 10, 10, 10],
            backgroundColor: "light-background"
          };
        }
      }
    }
  });
  qx.theme.classic.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * KDE Oxygen icons
   */
  qx.Theme.define("qx.theme.icon.Oxygen", {
    title: "Oxygen",
    aliases: {
      "icon": "qx/icon/Oxygen"
    }
  });
  qx.theme.icon.Oxygen.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.classic.Color": {
        "require": true
      },
      "qx.theme.classic.Decoration": {
        "require": true
      },
      "qx.theme.classic.Font": {
        "require": true
      },
      "qx.theme.classic.Appearance": {
        "require": true
      },
      "qx.theme.icon.Oxygen": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * Classic Windows Theme
   */
  qx.Theme.define("qx.theme.Classic", {
    title: "Classic Windows",
    meta: {
      color: qx.theme.classic.Color,
      decoration: qx.theme.classic.Decoration,
      font: qx.theme.classic.Font,
      appearance: qx.theme.classic.Appearance,
      icon: qx.theme.icon.Oxygen
    }
  });
  qx.theme.Classic.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "defer": "runtime",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.core.Object": {
        "defer": "runtime"
      },
      "qx.ui.core.MChildrenHandling": {},
      "qx.ui.core.Widget": {
        "defer": "runtime"
      },
      "qx.Mixin": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.juhu": {}
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @ignore(qx.AbstractCar, qx.Bmw, qx.Car, qx.ConcreteCar, qx.Defer.*)
   * @ignore(qx.DeferFoo, qx.Empty, qx.FuncName, qx.MyClass, qx.MyMixin)
   * @ignore(qx.Single1.*, qx.test.u.u.*)
   * @ignore(qx.Insect, qx.Butterfly, qx.Firefly, qx.Grasshopper, qx.Bug)
  
   */
  qx.Class.define("qx.test.Class", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      testAnonymous: function testAnonymous() {
        var clazz = qx.Class.define(null, {
          statics: {
            test: function test() {
              return true;
            }
          }
        });
        this.assertTrue(clazz.test());
      },
      testOverridePropertyMethod: function testOverridePropertyMethod() {
        this.require(["qx.debug"]);

        var C = qx.Class.define(null, {
          extend: qx.core.Object,
          properties: {
            prop: {
              init: "unset",
              check: "String",
              inheritable: true,
              themeable: true
            }
          }
        });
        var D = qx.Class.define(null, {
          extend: C,
          members: {
            setProp: function setProp(value) {
              return undefined.prototype.setProp.base.call(this, value + "-set");
            },
            getProp: function getProp() {
              return undefined.prototype.getProp.base.call(this) + "-get";
            }
          }
        });
        var d = new D();
        d.setProp("hello");
        this.assertEquals("hello-set-get", d.getProp());
      },
      testEmptyClass: function testEmptyClass() {
        qx.Class.define("qx.Empty", {
          extend: Object,
          construct: function construct() {}
        });
        var empty = new qx.Empty();
        this.assertEquals("object", typeof empty);
        this.assertTrue(empty instanceof qx.Empty);
      },
      testSuperClassCall: function testSuperClassCall() {
        qx.Class.define("qx.Car", {
          extend: qx.core.Object,
          construct: function construct(name) {
            this._name = name;
          },
          members: {
            startEngine: function startEngine() {
              return "start";
            },
            stopEngine: function stopEngine() {
              return "stop";
            },
            getName: function getName() {
              return this._name;
            }
          }
        });
        var car = new qx.Car("Audi");
        this.assertEquals("start", car.startEngine());
        this.assertEquals("stop", car.stopEngine());
        this.assertEquals("Audi", car.getName());
        qx.Class.define("qx.Bmw", {
          extend: qx.Car,
          construct: function construct(name, prize) {
            qx.Car.constructor.call(this, name);
          },
          members: {
            startEngine: function startEngine() {
              var ret = qx.Bmw.prototype.startEngine.base.call(this);
              return "brrr " + ret;
            },
            stopEngine: function stopEngine() {
              var ret = qx.Bmw.prototype.stopEngine.base.call(this);
              return "brrr " + ret;
            },
            getWheels: function getWheels() {
              return qx.test.Class.WHEELS;
            },
            getMaxSpeed: function getMaxSpeed() {
              // call base in non overridden method
              qx.Bmw.prototype.getMaxSpeed.base.call(this);
            }
          },
          statics: {
            WHEELS: 4
          }
        });
        var bmw = new qx.Bmw("bmw", 44000);
        this.assertEquals("bmw", bmw.getName());
        this.assertEquals("brrr start", bmw.startEngine());
        this.assertEquals("brrr stop", bmw.stopEngine());
        this.assertEquals(4, bmw.getWheels());

        if (this.isDebugOn()) {
          this.assertException(function () {
            bmw.getMaxSpeed();
          }, Error);
        }
      },
      testAbstract: function testAbstract() {
        qx.Class.define("qx.AbstractCar", {
          extend: qx.core.Object,
          type: "abstract",
          construct: function construct(color) {
            this._color = color;
          },
          members: {
            startEngine: function startEngine() {}
          }
        }); // instantiating abstract classes should fail

        if (this.isDebugOn()) {
          this.assertException(function () {
            new qx.AbstractCar("blue");
          }, Error, new RegExp("The class .* is abstract"));
        } // check if subclasses of abstract classes work


        qx.Class.define("qx.ConcreteCar", {
          extend: qx.AbstractCar,
          construct: function construct(color) {
            qx.AbstractCar.constructor.call(this, color);
          }
        });
        var car = new qx.ConcreteCar("red");
        this.assertNotUndefined(car);
        this.assertEquals("red", car._color);
      },
      testSingleton: function testSingleton() {
        qx.Class.define("qx.Single1", {
          extend: Object,
          type: "singleton",
          construct: function construct() {
            this._date = new Date().toString();
          }
        }); // direct instantiation should fail

        if (this.isDebugOn()) {
          this.assertException(function () {
            new qx.Single1();
          }, Error, new RegExp("The class .* is a singleton"));
        }

        ;
        this.assertEquals(qx.Single1.getInstance()._date, qx.Single1.getInstance()._date, "getInstance should always return the same object!");
        qx.Class.undefine("qx.Single1");
      },
      testInvalidImplicitStatic: function testInvalidImplicitStatic() {
        // different error message if no "extend" key was configured
        if (this.isDebugOn()) {
          this.assertException(function () {
            qx.Class.define("qx.MyClass1", {
              include: [qx.ui.core.MChildrenHandling]
            });
          }, Error, new RegExp('Assumed static class.*'));
        }
      },
      testEnvironment: function testEnvironment() {
        qx.Class.define("qx.Setting1", {
          environment: {
            "qx.juhu": "kinners"
          }
        });
        this.assertEquals("kinners", qx.core.Environment.get("qx.juhu"));
        qx.Class.undefine("qx.Setting1");
      },
      testDefer: function testDefer() {
        // this is BAD practice, don't code like this!
        qx.Class.define("qx.Defer", {
          extend: qx.core.Object,
          defer: function defer(statics, members, properties) {
            statics.FOO = 12;

            statics.sayHello = function () {
              return "Hello";
            };

            members.sayJuhu = function () {
              return "Juhu";
            };

            properties.add("color", {});
          }
        });
        this.assertEquals(12, qx.Defer.FOO);
        this.assertEquals("Hello", qx.Defer.sayHello());
        var defer = new qx.Defer();
        this.assertEquals("Juhu", defer.sayJuhu());
        defer.setColor("red");
        this.assertEquals("red", defer.getColor());
        defer.dispose();
      },
      testSubClassOf: function testSubClassOf() {
        this.assertTrue(qx.Class.isSubClassOf(qx.ui.core.Widget, qx.core.Object));
      },
      testClassUndefine: function testClassUndefine() {
        qx.Class.define("qx.test.u.u.Undefine", {
          extend: qx.core.Object
        });
        this.assertNotUndefined(qx.test.u.u.Undefine);
        qx.Class.undefine("qx.test.u.u.Undefine");
        this.assertUndefined(qx.test["u"]);
      },
      testPatch: function testPatch() {
        qx.Mixin.define("qx.MyMixin", {
          properties: {
            "property": {
              init: "p"
            }
          },
          members: {
            getP: function getP() {
              return "p";
            }
          }
        });
        qx.Class.define("qx.MyClass", {
          extend: qx.core.Object
        });
        qx.Class.patch(qx.MyClass, qx.MyMixin);
        var o = new qx.MyClass(); // just check of the properties are ok

        this.assertEquals("p", o.getProperty());
        this.assertEquals("p", o.getP()); // clean up

        o.dispose();
        qx.Class.undefine("qx.MyClass");
        qx.Class.undefine("qx.MyMixin");
      },
      testPatchWithConstructor: function testPatchWithConstructor() {
        qx.Mixin.define("qx.MyMixin", {
          construct: function construct() {
            this.__p__P_202_0 = "p";
          },
          properties: {
            "property": {
              init: "p"
            }
          },
          members: {
            getP: function getP() {
              return this.__p__P_202_0;
            }
          }
        });
        qx.Class.define("qx.MyClass", {
          extend: qx.core.Object
        });
        qx.Class.patch(qx.MyClass, qx.MyMixin);
        var o = new qx.MyClass(); // just check of the properties are ok

        this.assertEquals("p", o.getProperty());
        this.assertEquals("p", o.getP()); // clean up

        o.dispose();
        qx.Class.undefine("qx.MyClass");
        qx.Class.undefine("qx.MyMixin");
      },
      testInclude: function testInclude() {
        qx.Mixin.define("qx.MyMixin", {
          properties: {
            "property": {
              init: "p"
            }
          },
          members: {
            getP: function getP() {
              return "p";
            }
          }
        });
        qx.Class.define("qx.MyClass", {
          extend: qx.core.Object
        });
        qx.Class.include(qx.MyClass, qx.MyMixin);
        var o = new qx.MyClass(); // just check of the properties are ok

        this.assertEquals("p", o.getProperty());
        this.assertEquals("p", o.getP()); // clean up

        o.dispose();
        qx.Class.undefine("qx.MyClass");
        qx.Class.undefine("qx.MyMixin");
      },
      testIncludeWithConstructor: function testIncludeWithConstructor() {
        qx.Mixin.define("qx.MyMixin", {
          construct: function construct() {
            this.__p__P_202_0 = "p";
          },
          properties: {
            "property": {
              init: "p"
            }
          },
          members: {
            getP: function getP() {
              return this.__p__P_202_0;
            }
          }
        });
        qx.Class.define("qx.MyClass", {
          extend: qx.core.Object
        });
        qx.Class.include(qx.MyClass, qx.MyMixin);
        var o = new qx.MyClass(); // just check of the properties are ok

        this.assertEquals("p", o.getProperty());
        this.assertEquals("p", o.getP()); // clean up

        o.dispose();
        qx.Class.undefine("qx.MyClass");
        qx.Class.undefine("qx.MyMixin");
      },
      testSubclasses: function testSubclasses() {
        qx.Class.define("qx.Insect", {
          extend: qx.core.Object
        });
        qx.Class.define("qx.Butterfly", {
          extend: qx.Insect
        });
        qx.Class.define("qx.Firefly", {
          extend: qx.Insect
        });
        qx.Class.define("qx.Grasshopper", {
          extend: qx.Insect
        });
        var subclasses = qx.Class.getSubclasses(qx.Insect); // we should find 3 subclasses of qx.Insect

        this.assertEquals(Object.keys(subclasses).length, 3); // qx.Firefly should be a subclass of qx.Insect

        this.assertEquals(subclasses["qx.Firefly"], qx.Firefly);
        subclasses = qx.Class.getSubclasses(qx.Firefly); // there should be no subclasses for qx.Firefly

        this.assertEquals(Object.keys(subclasses).length, 0);
        subclasses = qx.Class.getSubclasses(qx.Bug); // there should be no class qx.Bug

        this.assertEquals(subclasses, null);
      },
      "test: instantiate class in defer and access property": function testInstantiateClassInDeferAndAccessProperty() {
        var self = this;
        qx.Class.define("qx.DeferFoo", {
          extend: qx.core.Object,
          properties: {
            juhu: {}
          },
          defer: function defer() {
            var df = new qx.DeferFoo();
            df.setJuhu("23");
            self.assertEquals("23", df.getJuhu());
            df.dispose();
          }
        });
        qx.Class.undefine("qx.DeferFoo");
      }
    }
  });
  qx.test.Class.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dom.Node": {},
      "qx.dom.Hierarchy": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.Dom", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        var div = document.createElement("div");
        div.id = "html_basics";
        div.innerHTML = "<div id=\"test1\"><div id=\"test2\"></div><div id=\"test3\"><div id=\"test4\"></div></div></div>";
        document.body.appendChild(div);
      },
      tearDown: function tearDown() {
        var div = document.getElementById("html_basics");
        document.body.removeChild(div);
      },
      testIsDocument: function testIsDocument() {
        this.assertTrue(qx.dom.Node.isDocument(document));
        this.assertFalse(qx.dom.Node.isDocument(document.body));
        this.assertFalse(qx.dom.Node.isDocument(window));
      },
      testContains: function testContains() {
        var test1 = document.getElementById("test1");
        var test2 = document.getElementById("test2");
        var test3 = document.getElementById("test3");
        var test4 = document.getElementById("test4");
        this.assertTrue(qx.dom.Hierarchy.contains(document, document.body));
        this.assertTrue(qx.dom.Hierarchy.contains(test1, test2));
        this.assertTrue(qx.dom.Hierarchy.contains(test1, test4));
        this.assertTrue(qx.dom.Hierarchy.contains(document, test2));
        this.assertTrue(qx.dom.Hierarchy.contains(document.body, test2));
        this.assertFalse(qx.dom.Hierarchy.contains(document.body, document));
        this.assertFalse(qx.dom.Hierarchy.contains(test2, test1));
        this.assertFalse(qx.dom.Hierarchy.contains(test4, test1));
        this.assertFalse(qx.dom.Hierarchy.contains(test2, document));
        this.assertFalse(qx.dom.Hierarchy.contains(test2, document.body));
        this.assertFalse(qx.dom.Hierarchy.contains(test2, test3));
        this.assertFalse(qx.dom.Hierarchy.contains(test2, test4));
      }
    }
  });
  qx.test.Dom.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.lang.String": {},
      "qx.util.EditDistance": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.EditDistance", {
    extend: qx.dev.unit.TestCase,
    members: {
      assertTransform: function assertTransform(strA, strB) {
        var arrA = qx.lang.String.toArray(strA);
        var arrB = qx.lang.String.toArray(strB);
        var job;
        var operations = qx.util.EditDistance.getEditOperations(arrA, arrB);

        for (var i = 0, l = operations.length; i < l; i++) {
          job = operations[i];

          switch (job.operation) {
            case qx.util.EditDistance.OPERATION_DELETE:
              qx.lang.Array.removeAt(arrA, job.pos);
              break;

            case qx.util.EditDistance.OPERATION_REPLACE:
              arrA[job.pos] = job.value;
              break;

            case qx.util.EditDistance.OPERATION_INSERT:
              qx.lang.Array.insertAt(arrA, job.value, job.pos);
              break;

            default:
              throw new Error("Invalid operation: " + job.operation);
          }
        }

        var result = arrA.join("");

        if (result !== strB) {
          throw new Error("Implementation could not transform: " + strA + " to " + strB + "! Result was: " + result);
        } // this.debug("Successfully transformed: " + strA + " to " + strB + ".");

      },
      testBasics: function testBasics() {
        this.assertTransform("hello world", "hallo welt");
        this.assertTransform("abcdef", "abdcef");
        this.assertTransform("abcdef", "fedcba");
        this.assertTransform("abcdef", "abc");
        this.assertTransform("abcdef", "def");
        this.assertTransform("abcdef", "bcef");
        this.assertTransform("abcdef", "abcghi");
        this.assertTransform("abcdef", "abcstudef");
      }
    }
  });
  qx.test.EditDistance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Class to implement different edit distance ideas.
   *
   * <a href="http://en.wikipedia.org/wiki/Edit_distance">Edit distance on Wikipedia</a>
   * <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance on Wikipedia</a>
   */
  qx.Class.define("qx.util.EditDistance", {
    statics: {
      OPERATION_DELETE: 1,
      OPERATION_INSERT: 2,
      OPERATION_REPLACE: 3,

      /**
       * Returns a distant matrix following a concept
       * named Levenshtein distance for two data structures
       *
       * @param dataA {Array} incoming source data
       * @param dataB {Array} incoming target data
       * @return {Integer[][]} outgoing matrix
       */
      __computeLevenshteinDistance__P_572_0: function __computeLevenshteinDistance__P_572_0(dataA, dataB) {
        // distance is dataA table with dataA.length+1 rows and dataB.length+1 columns
        var distance = []; // posA and posB are used to iterate over str1 and str2

        var posA, posB, cost;

        for (posA = 0; posA <= dataA.length; posA++) {
          distance[posA] = [];
          distance[posA][0] = posA;
        }

        for (posB = 1; posB <= dataB.length; posB++) {
          distance[0][posB] = posB;
        }

        for (posA = 1; posA <= dataA.length; posA++) {
          for (posB = 1; posB <= dataB.length; posB++) {
            cost = dataA[posA - 1] === dataB[posB - 1] ? 0 : 1;

            if (distance[posA] === undefined) {
              distance[posA] = [];
            }

            distance[posA][posB] = Math.min(distance[posA - 1][posB] + 1, // deletion
            distance[posA][posB - 1] + 1, // insertion
            distance[posA - 1][posB - 1] + cost // substitution
            );
          }
        }

        return distance;
      },

      /**
       * Computes the operations needed to transform dataA to dataB.
       *
       * @param distance {Integer[][]} Precomputed matrix for the data fields
       * @param dataA {Array} incoming source data
       * @param dataB {Array} incoming target data
       * @return {Map[]} Array of maps describing the operations needed
       */
      __computeEditOperations__P_572_1: function __computeEditOperations__P_572_1(distance, dataA, dataB) {
        var operations = [];
        var posA = dataA.length;
        var posB = dataB.length;

        if (posA === 0) {
          // insert from begin to end
          // reverted order than in all other cases for optimal performance
          for (var i = 0; i < posB; i++) {
            operations.push({
              operation: this.OPERATION_INSERT,
              pos: i,
              old: null,
              value: dataB[i]
            });
          }

          return operations;
        }

        if (posB === 0) {
          // remove from end to begin
          for (var i = posA - 1; i >= 0; i--) {
            operations.push({
              operation: this.OPERATION_DELETE,
              pos: i,
              old: dataA[i],
              value: null
            });
          }

          return operations;
        }

        while (posA !== 0 || posB !== 0) {
          if (posA != 0 && distance[posA][posB] == distance[posA - 1][posB] + 1) {
            operations.push({
              operation: this.OPERATION_DELETE,
              pos: posA - 1,
              old: dataA[posA - 1],
              value: null
            });
            posA -= 1;
          } else if (posB != 0 && distance[posA][posB] == distance[posA][posB - 1] + 1) {
            operations.push({
              operation: this.OPERATION_INSERT,
              pos: posA,
              old: null,
              value: dataB[posB - 1]
            });
            posB -= 1;
          } else {
            if (dataA[posA - 1] !== dataB[posB - 1]) {
              operations.push({
                operation: this.OPERATION_REPLACE,
                pos: posA - 1,
                old: dataA[posA - 1],
                value: dataB[posB - 1]
              });
            }

            posA -= 1;
            posB -= 1;
          }
        }

        return operations;
      },

      /**
       * Returns the operations needed to transform dataA to dataB.
       *
       * @param dataA {Array} incoming source data
       * @param dataB {Array} incoming target data
       * @return {Map[]} Array of maps describing the operations needed
       */
      getEditOperations: function getEditOperations(dataA, dataB) {
        var distance = this.__computeLevenshteinDistance__P_572_0(dataA, dataB);

        var operations = this.__computeEditOperations__P_572_1(distance, dataA, dataB);

        return operations;
      }
    }
  });
  qx.util.EditDistance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.Interface": {},
      "qx.core.Object": {},
      "qx.core.AssertionError": {},
      "qx.lang.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.i.*)
   */
  qx.Class.define("qx.test.Interface", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        qx.Interface.define("qx.test.i.ICar", {
          members: {
            startEngine: function startEngine() {
              return true;
            }
          },
          properties: {
            color: {}
          }
        });
      },
      tearDown: function tearDown() {
        qx.Class.undefine("qx.test.i.ICar");
      },
      testClassImplements: function testClassImplements() {
        // test correct implementations
        qx.Class.define("qx.test.i.Audi", {
          extend: Object,
          construct: function construct() {},
          implement: [qx.test.i.ICar],
          members: {
            startEngine: function startEngine() {
              return "start";
            }
          },
          statics: {
            honk: function honk() {
              return "honk";
            }
          },
          properties: {
            color: {}
          }
        });
        var audi = new qx.test.i.Audi("audi");
        this.assertTrue(qx.Interface.classImplements(qx.test.i.Audi, qx.test.i.ICar));
        qx.Class.undefine("qx.test.i.Audi");
      },
      testEverythingImplemented: function testEverythingImplemented() {
        qx.Class.define("qx.test.i.Bmw1", {
          extend: Object,
          construct: function construct() {},
          members: {
            startEngine: function startEngine() {
              return "start";
            }
          },
          statics: {
            honk: function honk() {
              return "honk";
            }
          },
          properties: {
            color: {}
          }
        });
        this.assertTrue(qx.Interface.classImplements(qx.test.i.Bmw1, qx.test.i.ICar));
        qx.Class.undefine("qx.test.i.Bmw1");
      },
      testMissingMembers: function testMissingMembers() {
        qx.Class.define("qx.test.i.Bmw2", {
          extend: Object,
          construct: function construct() {},
          statics: {
            honk: function honk() {
              return "honk";
            }
          },
          properties: {
            color: {}
          }
        });
        this.assertFalse(qx.Interface.classImplements(qx.test.i.Bmw2, qx.test.i.ICar));
        qx.Class.undefine("qx.test.i.Bmw2");
      },
      testMissingStatics: function testMissingStatics() {
        // (ie it does implement all necessary)
        qx.Class.define("qx.test.i.Bmw3", {
          extend: Object,
          construct: function construct() {},
          members: {
            startEngine: function startEngine() {
              return "start";
            }
          },
          properties: {
            color: {}
          }
        });
        this.assertTrue(qx.Interface.classImplements(qx.test.i.Bmw3, qx.test.i.ICar));
        qx.Class.undefine("qx.test.i.Bmw3");
      },
      testMissingProperties: function testMissingProperties() {
        qx.Class.define("qx.test.i.Bmw4", {
          extend: Object,
          construct: function construct() {},
          members: {
            startEngine: function startEngine() {
              return "start";
            }
          },
          statics: {
            honk: function honk() {
              return "honk";
            }
          }
        });
        this.assertFalse(qx.Interface.classImplements(qx.test.i.Bmw4, qx.test.i.ICar));
        qx.Class.undefine("qx.test.i.Bmw4");
      },
      testWithDebug: function testWithDebug() {
        if (this.isDebugOn()) {
          this.assertException(function () {
            var i = new qx.test.i.ICar();
          }, Error); // nothing defined

          this.assertException(function () {
            qx.Class.define("qx.test.i.Audi1", {
              extend: Object,
              construct: function construct() {},
              implement: [qx.test.i.ICar]
            });
          }, Error, new RegExp('Implementation of method .* is missing')); // members not defined

          this.assertException(function () {
            qx.Class.define("qx.test.i.Audi2", {
              extend: Object,
              construct: function construct() {},
              implement: [qx.test.i.ICar],
              statics: {
                honk: function honk() {
                  return "honk";
                }
              },
              properties: {
                color: {}
              }
            });
          }, Error, 'Implementation of method "startEngine" is missing'); // property not defined

          this.assertException(function () {
            qx.Class.define("qx.test.i.Audi4", {
              extend: Object,
              construct: function construct() {},
              implement: [qx.test.i.ICar],
              members: {
                startEngine: function startEngine() {
                  return "start";
                }
              },
              statics: {
                honk: function honk() {
                  return "honk";
                }
              }
            });
          }, Error, new RegExp("property .* not supported"));
        }
      },
      testAssertions: function testAssertions() {
        qx.Interface.define("qx.test.i.IComplex", {
          members: {
            add: function add(a) {
              this.assertArgumentsCount(arguments, 1, 1);
              this.assertInterface(a.constructor, qx.test.i.IComplex);
            },
            setReal: function setReal(r) {
              this.assertArgumentsCount(arguments, 1, 1);
              this.assertType(r, "number");
            },
            abs: function abs() {
              this.assert(arguments[0] == undefined);
            }
          }
        });
        qx.Class.define("qx.test.i.Complex", {
          extend: qx.core.Object,
          implement: qx.test.i.IComplex,
          construct: function construct(real, imag) {
            this._real = real;
            this._imag = imag;
          },
          members: {
            add: function add(a) {
              this._real += a._real;
              this._imag += a._imag;
            },
            setReal: function setReal(r) {
              this._real = r;
            },
            abs: function abs() {
              return Math.sqrt(this._real * this._real + (this._imag + this._imag));
            },
            toString: function toString() {
              return this._real + "+" + this._imag + "i";
            }
          }
        });
        var a = new qx.test.i.Complex(1, 1);
        var b = new qx.test.i.Complex(2, -3.4); // valid usage

        a.add(b);
        a.setReal(20);
        a.abs(); // invalid usage

        if (this.isDebugOn()) {
          this.assertException(function () {
            a.add(b, b);
          }, qx.core.AssertionError, null, "a");
          this.assertException(function () {
            a.setReal();
          }, qx.core.AssertionError, null, "b");
          this.assertException(function () {
            a.setReal(1, 2);
          }, qx.core.AssertionError, null, "c");
          this.assertException(function () {
            a.setReal("Juhu");
          }, qx.core.AssertionError, null, "d");
          this.assertException(function () {
            a.abs({});
          }, qx.core.AssertionError, null, "e");
          this.assertException(function () {
            a.add("Juhu");
          }, qx.core.AssertionError, null, "f");
        }

        ;
      },
      testProperties: function testProperties() {
        qx.Interface.define("qx.test.i.IProperties1", {
          properties: {
            value: {}
          }
        });
        qx.Class.define("qx.test.i.Properties1", {
          extend: qx.core.Object,
          implement: [qx.test.i.IProperties1],
          properties: {
            value: {
              check: "Integer"
            }
          }
        });

        if (this.isDebugOn()) {
          this.assertException(function () {
            qx.Class.define("qx.test.i.Properties2", {
              extend: qx.core.Object,
              implement: [qx.test.i.IProperties1],
              members: {
                getValue: function getValue() {},
                setValue: function setValue(value) {}
              }
            });
          });
        }

        ;
        qx.Interface.define("qx.test.i.IProperties2", {
          members: {
            getValue: function getValue() {},
            setValue: function setValue(value) {}
          }
        });
        qx.Class.define("qx.test.i.Properties3", {
          extend: qx.core.Object,
          implement: [qx.test.i.IProperties2],
          properties: {
            value: {
              check: "Integer"
            }
          }
        });
        qx.Class.define("qx.test.i.Properties4", {
          extend: qx.core.Object,
          implement: [qx.test.i.IProperties2],
          members: {
            getValue: function getValue() {},
            setValue: function setValue(value) {}
          }
        });
      },
      testEvents: function testEvents() {
        qx.Interface.define("qx.test.i.IEvents1", {
          events: {
            "change": "qx.event.type.Event"
          }
        });
        qx.Class.define("qx.test.i.Event1", {
          extend: qx.core.Object,
          implement: [qx.test.i.IEvents1],
          events: {
            change: "qx.event.type.Event"
          }
        });

        if (this.isDebugOn()) {
          this.assertException(function () {
            qx.Class.define("qx.test.i.Event2", {
              extend: qx.core.Object,
              implement: [qx.test.i.IEvents1]
            });
          });
        }

        ;
      },
      testIncludes: function testIncludes() {
        qx.Interface.define("qx.test.i.IMember", {
          members: {
            sayJuhu: function sayJuhu() {
              return true;
            }
          }
        });
        qx.Interface.define("qx.test.i.IProperties", {
          properties: {
            "color": {},
            "name": {}
          }
        });
        qx.Interface.define("qx.test.i.IAll", {
          extend: [qx.test.i.IMember, qx.test.i.IProperties]
        });
        qx.Interface.define("qx.test.i.IOther", {
          members: {
            bar: function bar() {
              return true;
            }
          }
        });
        var classDef = {
          extend: Object,
          implement: qx.test.i.IAll,
          members: {
            sayJuhu: function sayJuhu() {}
          },
          statics: {
            sayHello: function sayHello() {
              return true;
            }
          },
          properties: {
            "color": {},
            "name": {}
          }
        }; // all implemented

        var def = qx.lang.Object.clone(classDef);
        qx.Class.define("qx.test.i.Implement1", def);
        this.assertTrue(qx.Class.implementsInterface(qx.test.i.Implement1, qx.test.i.IAll), "implements IAll");
        this.assertTrue(qx.Class.implementsInterface(qx.test.i.Implement1, qx.test.i.IMember), "implements IMember");
        this.assertTrue(qx.Class.implementsInterface(qx.test.i.Implement1, qx.test.i.IProperties), "implements IProperties");
        this.assertFalse(qx.Class.implementsInterface(qx.test.i.Implement1, qx.test.i.IOther), "not implements IOther"); // no members

        var def = qx.lang.Object.clone(classDef);
        delete def.members;

        if (this.isDebugOn()) {
          this.assertException(function () {
            qx.Class.define("qx.test.i.Implement2", def);
          }, Error, "Implementation of method", "No members defined.");
        }

        ; // no properties

        var def = qx.lang.Object.clone(classDef);
        delete def.properties;

        if (this.isDebugOn()) {
          this.assertException(function () {
            qx.Class.define("qx.test.i.Implement4", def);
          }, Error, new RegExp("property .* is not supported"), "No properties defined.");
        }

        ;
      },

      /**
       * abstract classes may define an interface and implement it only partially
       * sub classes must implement the missing methods
       */
      testAbstractClass: function testAbstractClass() {
        qx.Interface.define("qx.test.i.IJuhu", {
          members: {
            sayJuhu: function sayJuhu() {},
            sayKinners: function sayKinners() {}
          }
        }); // should not raise an exception

        qx.Class.define("qx.test.i.AbstractJuhu1", {
          extend: qx.core.Object,
          implement: qx.test.i.IJuhu,
          type: "abstract"
        }); // should not raise an exception

        qx.Class.define("qx.test.i.AbstractJuhu2", {
          extend: qx.core.Object,
          implement: qx.test.i.IJuhu,
          type: "abstract",
          members: {
            sayJuhu: function sayJuhu() {
              return "Juhu";
            }
          }
        }); // should raise an exception

        if (this.isDebugOn()) {
          this.assertException(function () {
            qx.Class.define("qx.test.i.Juhu1", {
              extend: qx.test.i.AbstractJuhu1,
              members: {
                sayJuhu: function sayJuhu() {
                  return "Juhu";
                }
              }
            });
          }, Error, '.*Implementation of method "sayKinners" is missing in class "qx.test.i.Juhu1" required by interface "qx.test.i.IJuhu"');
        }

        ;
        qx.Class.define("qx.test.i.Juhu1", {
          extend: qx.test.i.AbstractJuhu2,
          members: {
            sayKinners: function sayKinners() {
              return "Kinners";
            }
          }
        });
      },
      testGeneratedIsMethods: function testGeneratedIsMethods() {
        qx.Interface.define("qx.test.i.IIs", {
          members: {
            isProp: function isProp() {}
          }
        });
        qx.Class.define("qx.test.i.Is", {
          extend: qx.core.Object,
          implement: qx.test.i.IIs,
          properties: {
            prop: {
              check: "Boolean",
              init: true
            }
          }
        });
      }
    }
  });
  qx.test.Interface.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.Mixin": {},
      "qx.core.Object": {},
      "qx.test.testclasses.BaseClassIncluded": {},
      "qx.test.testclasses.BaseClassPatched": {},
      "qx.test.testclasses.BaseClassBoth": {},
      "qx.test.testclasses.DerivedClassIncluded": {},
      "qx.test.testclasses.DerivedClassPatched": {},
      "qx.test.testclasses.DerivedClassBoth": {},
      "qx.test.testclasses.RootClass": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @ignore(qx.ExtendUseLog1, qx.Mix, qx.MLogger, qx.MMix1, qx.MMix1.foo)
   * @ignore(qx.MMix2, qx.MPatch, qx.Patch1, qx.Patch2, qx.UseLog1, qx.UseLog2)
   * @ignore(qx.UseLog3)
   */
  qx.Class.define("qx.test.Mixin", {
    extend: qx.dev.unit.TestCase,
    members: {
      testMixinBasic: function testMixinBasic() {
        qx.Mixin.define("qx.MMix1", {
          statics: {
            data: null,
            foo: function foo() {
              return "foo";
            }
          },
          members: {
            bar: function bar() {
              return "bar";
            }
          },
          properties: {
            color: {}
          }
        });
        qx.Mixin.define("qx.MMix2", {
          members: {
            bar: function bar() {
              return "bar";
            }
          }
        });
        qx.Class.define("qx.Mix", {
          extend: Object,
          include: qx.MMix1,
          construct: function construct() {}
        });
        this.assertEquals("foo", qx.MMix1.foo());
        this.assertEquals("bar", new qx.Mix().bar());
        var mix = new qx.Mix();
        mix.setColor("red");
        this.assertEquals("red", mix.getColor());

        if (this.isDebugOn()) {
          this.assertException(function () {
            qx.Class.define("qx.Mix1", {
              extend: Object,
              include: [qx.MMix1, qx.MMix2],
              construct: function construct() {}
            });
          }, Error, "Overwriting member", "t1");
          this.assertException(function () {
            qx.Class.define("qx.Mix2", {
              extend: Object,
              include: qx.MMix1,
              construct: function construct() {},
              members: {
                bar: function bar() {
                  return "bar";
                }
              }
            });
          }, Error, "Overwriting member", "t2");
        }

        ; // this is allowed

        qx.Class.define("qx.Mix3", {
          extend: Object,
          include: qx.MMix1,
          construct: function construct() {},
          statics: {
            foo: function foo() {
              return "foo";
            }
          }
        });

        if (this.isDebugOn()) {
          this.assertException(function () {
            qx.Class.define("qx.Mix4", {
              extend: Object,
              include: qx.MMix1,
              construct: function construct() {},
              properties: {
                color: {}
              }
            });
          }, Error, "already has a property", "t3");
        }

        ;
      },
      testInclude: function testInclude() {
        qx.Mixin.define("qx.MLogger", {
          members: {
            log: function log(msg) {
              return msg;
            }
          }
        }); // normal usage

        qx.Class.define("qx.UseLog1", {
          extend: Object,
          construct: function construct() {}
        });
        qx.Class.include(qx.UseLog1, qx.MLogger);
        this.assertEquals("Juhu", new qx.UseLog1().log("Juhu")); // not allowed to overwrite!

        qx.Class.define("qx.UseLog2", {
          extend: Object,
          construct: function construct() {},
          members: {
            log: function log() {
              return "foo";
            }
          }
        });

        if (this.isDebugOn()) {
          this.assertException(function () {
            qx.Class.include(qx.UseLog2, qx.MLogger);
          }, Error, "Overwriting member");
        }

        ; // allowed to overwrite!

        qx.Class.define("qx.UseLog3", {
          extend: Object,
          construct: function construct() {},
          members: {
            log: function log() {
              return "foo";
            }
          }
        });
        this.assertEquals("foo", new qx.UseLog3().log("Juhu"));
        qx.Class.patch(qx.UseLog3, qx.MLogger);
        this.assertEquals("Juhu", new qx.UseLog3().log("Juhu")); // extended classes must have included methods as well

        qx.Class.define("qx.ExtendUseLog1", {
          extend: qx.UseLog1
        });
        this.assertEquals("Juhu", new qx.ExtendUseLog1().log("Juhu"));
      },
      testPatchOverwritten: function testPatchOverwritten() {
        qx.Class.define("qx.Patch1", {
          extend: qx.core.Object,
          members: {
            sayJuhu: function sayJuhu() {
              return "Juhu";
            },
            foo: function foo() {
              return "foo";
            }
          }
        });
        qx.Class.define("qx.Patch2", {
          extend: qx.core.Object,
          members: {
            sayJuhu: function sayJuhu() {
              return "Huhu";
            },
            foo: function foo() {
              return "bar";
            }
          }
        });
        qx.Mixin.define("qx.MPatch", {
          members: {
            sayJuhu: function sayJuhu() {
              return qx.MPatch.$$members.sayJuhu.base.call(this) + " Kinners";
            },

            /** @lint ignoreUndeclaredPrivates(__b) */
            foo: function foo(dontRecurs) {
              var s = "";

              if (!dontRecurs) {
                this.__b__P_203_0 = new qx.Patch2();
                s += "++" + this.__b__P_203_0.foo(true) + "____P_203_1";
              }

              s += qx.MPatch.$$members.foo.base.call(this);
              return s;
            }
          }
        });

        if (this.isDebugOn()) {
          this.assertException(function () {
            qx.Class.include(qx.Patch1, qx.MPatch);
          }, Error, new RegExp('Overwriting member ".*" of Class ".*" is not allowed!'));
        }

        ;
        qx.Class.patch(qx.Patch1, qx.MPatch);
        qx.Class.patch(qx.Patch2, qx.MPatch);
        var o = new qx.Patch1();
        this.assertEquals("Juhu Kinners", o.sayJuhu());
        o.dispose();
        var o = new qx.Patch2();
        this.assertEquals("Huhu Kinners", o.sayJuhu());
        o.dispose(); // very special case with recursive calls from different classes to
        // the mixin member

        var o = new qx.Patch1();
        this.assertEquals("++bar__foo", o.foo());

        o.__b__P_203_0.dispose();

        o.dispose();
      },
      testPatchConstructors: function testPatchConstructors() {
        this.assertTrue(qx.test.testclasses.BaseClassIncluded.constructor === qx.test.testclasses.BaseClassIncluded);
        this.assertTrue(qx.test.testclasses.BaseClassPatched.constructor === qx.test.testclasses.BaseClassPatched);
        this.assertTrue(qx.test.testclasses.BaseClassBoth.constructor === qx.test.testclasses.BaseClassBoth);
        this.assertTrue(qx.test.testclasses.DerivedClassIncluded.constructor === qx.test.testclasses.DerivedClassIncluded);
        this.assertTrue(qx.test.testclasses.DerivedClassPatched.constructor === qx.test.testclasses.DerivedClassPatched);
        this.assertTrue(qx.test.testclasses.DerivedClassBoth.constructor === qx.test.testclasses.DerivedClassBoth);
        var objBaseIncluded = new qx.test.testclasses.BaseClassIncluded();
        this.assertArrayEquals(["root", "base", "mixin-one", "mixin-two"], objBaseIncluded.state);
        this.assertEquals("mixin-one", objBaseIncluded.getSomething());
        var objIncluded = new qx.test.testclasses.DerivedClassIncluded();
        this.assertArrayEquals(["root", "base", "mixin-one", "mixin-two", "derived"], objIncluded.state);
        this.assertEquals("mixin-one:derived", objIncluded.getSomething());
        var objBasePatched = new qx.test.testclasses.BaseClassPatched();
        this.assertArrayEquals(["root", "base", "mixin-one", "mixin-two"], objBasePatched.state);
        this.assertEquals("mixin-one", objBasePatched.getSomething());
        var objPatched = new qx.test.testclasses.DerivedClassPatched();
        this.assertArrayEquals(["root", "base", "mixin-one", "mixin-two", "derived"], objPatched.state);
        this.assertEquals("mixin-one:derived", objPatched.getSomething());
        var objBaseBoth = new qx.test.testclasses.BaseClassBoth();
        this.assertArrayEquals(["root", "base", "mixin-one", "mixin-two"], objBaseBoth.state);
        this.assertEquals("mixin-one", objBaseBoth.getSomething());
        var objBoth = new qx.test.testclasses.DerivedClassBoth();
        this.assertArrayEquals(["root", "base", "mixin-one", "mixin-two", "derived"], objBoth.state);
        this.assertEquals("mixin-one:derived", objBoth.getSomething());
        this.assertTrue(objBaseIncluded.constructor === qx.test.testclasses.BaseClassIncluded);
        this.assertTrue(objIncluded.constructor === qx.test.testclasses.DerivedClassIncluded);
        this.assertTrue(objBasePatched.constructor === qx.test.testclasses.BaseClassPatched);
        this.assertTrue(objPatched.constructor === qx.test.testclasses.DerivedClassPatched);
        this.assertTrue(objBaseBoth.constructor === qx.test.testclasses.BaseClassBoth);
        this.assertTrue(objBoth.constructor === qx.test.testclasses.DerivedClassBoth);
        this.assertTrue(objBaseIncluded instanceof qx.test.testclasses.BaseClassIncluded);
        this.assertTrue(objIncluded instanceof qx.test.testclasses.DerivedClassIncluded);
        this.assertTrue(objIncluded instanceof qx.test.testclasses.BaseClassIncluded);
        this.assertTrue(objBasePatched instanceof qx.test.testclasses.BaseClassPatched);
        this.assertTrue(objPatched instanceof qx.test.testclasses.BaseClassPatched);
        this.assertTrue(objPatched instanceof qx.test.testclasses.DerivedClassPatched);
        this.assertTrue(objBaseBoth instanceof qx.test.testclasses.BaseClassBoth);
        this.assertTrue(objBoth instanceof qx.test.testclasses.BaseClassBoth);
        this.assertTrue(objBoth instanceof qx.test.testclasses.DerivedClassBoth);
        this.assertTrue(objBaseIncluded instanceof qx.test.testclasses.RootClass);
        this.assertTrue(objBaseBoth instanceof qx.test.testclasses.RootClass);
        this.assertTrue(objPatched instanceof qx.test.testclasses.RootClass);
      }
    }
  });
  qx.test.Mixin.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.testclasses.RootClass", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      qx.core.Assert.assertTrue(this.state === null);
      this.state = ["root"];
    },
    members: {
      state: null,
      getSomething: function getSomething() {
        return "root";
      }
    }
  });
  qx.test.testclasses.RootClass.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Mixin.define("qx.test.testclasses.MMixinOne", {
    construct: function construct() {
      qx.core.Assert.assertTrue(this.state !== null);
      this.state.push("mixin-one");
    },
    members: {
      getSomething: function getSomething() {
        return "mixin-one";
      }
    }
  });
  qx.test.testclasses.MMixinOne.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Mixin.define("qx.test.testclasses.MMixinTwo", {
    construct: function construct() {
      qx.core.Assert.assertTrue(this.state !== null);
      this.state.push("mixin-two");
    }
  });
  qx.test.testclasses.MMixinTwo.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.testclasses.RootClass": {
        "construct": true,
        "require": true
      },
      "qx.test.testclasses.MMixinOne": {
        "require": true
      },
      "qx.test.testclasses.MMixinTwo": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.testclasses.BaseClassIncluded", {
    extend: qx.test.testclasses.RootClass,
    include: [qx.test.testclasses.MMixinOne, qx.test.testclasses.MMixinTwo],
    construct: function construct() {
      qx.test.testclasses.RootClass.constructor.call(this);
      this.state.push("base");
    }
  });
  qx.test.testclasses.BaseClassIncluded.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "defer": "runtime",
        "require": true
      },
      "qx.test.testclasses.RootClass": {
        "construct": true,
        "require": true
      },
      "qx.test.testclasses.MMixinOne": {
        "defer": "runtime"
      },
      "qx.test.testclasses.MMixinTwo": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.testclasses.BaseClassPatched", {
    extend: qx.test.testclasses.RootClass,
    construct: function construct() {
      qx.test.testclasses.RootClass.constructor.call(this);
      this.state.push("base");
    },
    defer: function defer() {
      qx.Class.patch(qx.test.testclasses.BaseClassPatched, qx.test.testclasses.MMixinOne);
      qx.Class.patch(qx.test.testclasses.BaseClassPatched, qx.test.testclasses.MMixinTwo);
    }
  });
  qx.test.testclasses.BaseClassPatched.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "defer": "runtime",
        "require": true
      },
      "qx.test.testclasses.RootClass": {
        "construct": true,
        "require": true
      },
      "qx.test.testclasses.MMixinOne": {
        "require": true
      },
      "qx.test.testclasses.MMixinTwo": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.testclasses.BaseClassBoth", {
    extend: qx.test.testclasses.RootClass,
    include: [qx.test.testclasses.MMixinOne],
    construct: function construct() {
      qx.test.testclasses.RootClass.constructor.call(this);
      this.state.push("base");
    },
    defer: function defer() {
      qx.Class.patch(qx.test.testclasses.BaseClassBoth, qx.test.testclasses.MMixinTwo);
    }
  });
  qx.test.testclasses.BaseClassBoth.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.testclasses.BaseClassIncluded": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.testclasses.DerivedClassIncluded", {
    extend: qx.test.testclasses.BaseClassIncluded,
    construct: function construct() {
      qx.test.testclasses.BaseClassIncluded.constructor.call(this);
      this.state.push("derived");
    },
    members: {
      getSomething: function getSomething() {
        return qx.test.testclasses.DerivedClassIncluded.prototype.getSomething.base.call(this) + ":derived";
      }
    }
  });
  qx.test.testclasses.DerivedClassIncluded.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.testclasses.BaseClassPatched": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.testclasses.DerivedClassPatched", {
    extend: qx.test.testclasses.BaseClassPatched,
    construct: function construct() {
      qx.test.testclasses.BaseClassPatched.constructor.call(this);
      this.state.push("derived");
    },
    members: {
      getSomething: function getSomething() {
        return qx.test.testclasses.DerivedClassPatched.prototype.getSomething.base.call(this) + ":derived";
      }
    }
  });
  qx.test.testclasses.DerivedClassPatched.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.testclasses.BaseClassBoth": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.testclasses.DerivedClassBoth", {
    extend: qx.test.testclasses.BaseClassBoth,
    construct: function construct() {
      qx.test.testclasses.BaseClassBoth.constructor.call(this);
      this.state.push("derived");
    },
    members: {
      getSomething: function getSomething() {
        return qx.test.testclasses.DerivedClassBoth.prototype.getSomething.base.call(this) + ":derived";
      }
    }
  });
  qx.test.testclasses.DerivedClassBoth.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.util.ResourceManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Mixin.define("qx.test.io.MRemoteTest", {
    members: {
      getUrl: function getUrl(path) {
        return qx.util.ResourceManager.getInstance().toUri(path);
      },
      isLocal: function isLocal() {
        return window.location.protocol == "file:";
      },
      needsPHPWarning: function needsPHPWarning() {
        this.warn("This test can only be run from a web server with PHP support.");
      }
    }
  });
  qx.test.io.MRemoteTest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.Part": {},
      "qx.io.part.ClosurePart": {},
      "qx.io.part.Part": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
  qooxdoo - the new era of web development
  
  http://qooxdoo.org
  
  Copyright:
    2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
  License:
       MIT: https://opensource.org/licenses/MIT
    See the LICENSE file in the project's top-level directory for details.
  
  Authors:
    * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   * @asset(qx/test/*)
   * @ignore(qx.test.PART_FILES.*)
   */
  qx.Class.define("qx.test.Part", {
    extend: qx.dev.unit.TestCase,
    include: qx.test.io.MRemoteTest,
    members: {
      testLoaderStructureParsing: function testLoaderStructureParsing() {
        var loader = {
          parts: {
            "juhu": [0, 1],
            "kinners": [0, 2]
          },
          packages: {
            0: {
              uris: ["1.js"]
            },
            1: {
              uris: ["2.js"]
            },
            2: {
              uris: ["3.1.js", "3.2.js"]
            }
          },
          closureParts: {
            "juhu": true
          },
          boot: "juhu"
        };
        var partLoader = new qx.Part(loader); // get the parts

        var parts = partLoader.getParts();
        this.assertEquals(2, Object.keys(parts).length);
        var juhu = parts["juhu"];
        var kinners = parts["kinners"]; // check part instances

        this.assertInstance(juhu, qx.io.part.ClosurePart);
        this.assertInstance(kinners, qx.io.part.Part); // confirm part packages

        var packages = kinners.getPackages();
        this.assertEquals(2, packages.length);
        this.assertEquals("0", packages[0].getId());
        this.assertEquals("2", packages[1].getId()); // check package uris

        var pkg2 = packages[1];
        var pkg2Urls = pkg2.getUrls();
        var refUrls = loader.packages[2].uris;

        for (var s = 0; s < refUrls.length; s++) {
          this.assertMatch(pkg2Urls[s], new RegExp(refUrls[s] + ".*")); // matches "?nocache=..." if present
        }
      },
      testPreload: function testPreload() {
        qx.test.PART_FILES = [];
        var loader = {
          parts: {
            "juhu": ["p1"],
            "affe": ["p0"]
          },
          packages: {
            p0: {
              uris: ["boot.js"]
            },
            p1: {
              uris: [this.getUrl("qx/test/part/file1-closure.js")]
            }
          },
          closureParts: {
            "juhu": true
          },
          boot: "affe"
        };
        var partLoader = new qx.Part(loader);
        qx.Part.$$instance = partLoader;
        var self = this;
        var part = partLoader.getParts()["juhu"];
        window.setTimeout(function () {
          self.resume(function () {
            self.assertEquals(0, qx.test.PART_FILES.length);
            self.assertJsonEquals([], qx.test.PART_FILES);
            self.assertEquals("initialized", part.getReadyState());
            self.assertEquals("cached", part.getPackages()[0].getReadyState()); // execute closure to check if it is the correct one

            part.getPackages()[0].execute();
            self.assertJsonEquals(["file1-closure"], qx.test.PART_FILES);
          });
        }, 1000);
        partLoader.preload("juhu");
        this.wait();
      },
      testPreloadCallback: function testPreloadCallback() {
        qx.test.PART_FILES = [];
        var loader = {
          parts: {
            "juhu": ["p1"],
            "affe": ["p0"]
          },
          packages: {
            p0: {
              uris: ["boot.js"]
            },
            p1: {
              uris: [this.getUrl("qx/test/part/file1-closure.js")]
            }
          },
          closureParts: {
            "juhu": true
          },
          boot: "affe"
        };
        var partLoader = new qx.Part(loader);
        qx.Part.$$instance = partLoader;
        var self = this;
        var preloadExecuted = false;
        partLoader.preload(["affe", "juhu"], function (states) {
          self.resume(function () {
            preloadExecuted = true;
            self.assertEquals(self, this, "context wrong");
            self.assertEquals("complete", states[0], "states wrong");
            self.assertEquals("initialized", states[1], "states wrong");
          }, self);
        }, this);
        this.wait();
      },
      testPreloadAndLoadAfterwards: function testPreloadAndLoadAfterwards() {
        qx.test.PART_FILES = [];
        var loader = {
          parts: {
            "juhu": ["p1"],
            "affe": ["p0"]
          },
          packages: {
            p0: {
              uris: ["boot.js"]
            },
            p1: {
              uris: [this.getUrl("qx/test/part/file1-closure.js")]
            }
          },
          closureParts: {
            "juhu": true
          },
          boot: "affe"
        };
        var partLoader = new qx.Part(loader);
        qx.Part.$$instance = partLoader;
        partLoader.preload("juhu");
        var part = partLoader.getParts()["juhu"];
        var self = this;

        part.getPackages()[0].loadClosure = function () {
          self.resume(function () {
            self.fail("load called twice!");
          });
        };

        partLoader.require("juhu", function () {
          this.resume(function () {
            this.assertEquals("complete", part.getPackages()[0].getReadyState());
            this.assertEquals("complete", part.getReadyState());
            this.assertEquals(1, qx.test.PART_FILES.length);
            this.assertJsonEquals(["file1-closure"], qx.test.PART_FILES);
          });
        }, this);

        this.wait();
      },
      testRequireState: function testRequireState() {
        qx.test.PART_FILES = []; // create a dummy loader

        var loader = {
          parts: {
            "juhu": ["p1"],
            "affe": ["p0"],
            "fail": ["p2"]
          },
          packages: {
            p0: {
              uris: ["boot.js"]
            },
            p1: {
              uris: [this.getUrl("qx/test/part/file1-closure.js")]
            },
            p2: {
              uris: ["_fail.js"]
            }
          },
          closureParts: {
            "juhu": true,
            "fail": true
          },
          boot: "affe"
        };
        var partLoader = new qx.Part(loader);
        qx.Part.$$instance = partLoader; // preload one part

        partLoader.preload("juhu");
        var timeout = qx.Part.TIMEOUT;
        qx.Part.TIMEOUT = 1000; // require all three parts and check the ready states

        partLoader.require(["affe", "juhu", "fail"], function (states) {
          this.resume(function () {
            qx.Part.TIMEOUT = timeout;
            this.assertEquals("complete", states[0]);
            this.assertEquals("complete", states[1]);
            this.assertEquals("error", states[2]);
            delete qx.Part.$$instance;
          }, this);
        }, this);

        this.wait();
      },
      testRequireUnknownPart: function testRequireUnknownPart() {
        qx.test.PART_FILES = []; // create a dummy loader

        var loader = {
          parts: {
            "affe": ["p0"]
          },
          packages: {
            p0: {
              uris: ["boot.js"]
            }
          },
          boot: "affe"
        };
        var partLoader = new qx.Part(loader);
        qx.Part.$$instance = partLoader; // require unknown part

        this.assertException(function () {
          partLoader.require(['unknown']);
        }, Error);
        delete qx.Part.$$instance;
      }
    }
  });
  qx.test.Part.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.Promise": {},
      "qx.core.Object": {},
      "qx.data.Array": {},
      "qx.event.GlobalError": {},
      "qx.core.Assert": {},
      "qx.data.marshal.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.Promise", {
    extend: qx.dev.unit.TestCase,
    members: {
      /**
       * Tests a new promise that resolves with no errors
       */
      testNewPromise: function testNewPromise() {
        var self = this;
        var p = new qx.Promise(function (resolve, reject) {
          setTimeout(function () {
            resolve("ok");
          });
        }, this);
        p.then(function (value) {
          this.assertIdentical(this, self);
          this.assertEquals(value, "ok");
          this.resume();
        }, function (err) {
          this.assertTrue(false);
          this.resume();
        });
        this.wait(1000);
      },

      /**
       * Tests a new promise that is rejected
       */
      testReject: function testReject() {
        var self = this;
        var p = new qx.Promise(function (resolve, reject) {
          setTimeout(function () {
            reject(new Error("oops"));
          });
        }, this);
        p.then(function (value) {
          this.assertTrue(false);
          this.resume();
        }, function (err) {
          this.assertIdentical(this, self);
          this.assertEquals(err.message, "oops");
          this.resume();
        });
        this.wait(1000);
      },
      testCatchFinally: function testCatchFinally() {
        var caughtException = null;
        qx.Promise.resolve().then(function () {
          throw new Error("oops");
        }).catch(function (ex) {
          caughtException = ex;
        }).finally(function () {
          this.assertNotNull(caughtException);
          this.resume();
        }, this);
        this.wait(1000);
      },

      /**
       * Tests the qx.Promise.allOf method
       */
      testAllOf: function testAllOf() {
        var t = this;
        var dt = new Date();
        var obj = {
          a: new qx.Promise(),
          b: new qx.Promise(),
          c: new qx.Promise(),
          d: "four",
          e: dt
        };
        qx.Promise.allOf(obj).then(function (obj2) {
          t.assertTrue(obj === obj2);
          t.assertEquals("one", obj.a);
          t.assertEquals("two", obj.b);
          t.assertEquals("three", obj.c);
          t.assertEquals("four", obj.d);
          t.assertTrue(obj.e === dt);
          t.resume();
        });
        obj.a.then(function () {
          obj.b.resolve("two");
        });
        obj.b.then(function () {
          obj.c.resolve("three");
        });
        obj.a.resolve("one");
        t.wait(1000);
      },

      /**
       * Tests that setting a property value with a promise will delay setting the
       * value until the promise is resolved.  In this case, the property is *not*
       * marked as async and the setXxx method is used
       */
      testPropertySetValueAsPromise1: function testPropertySetValueAsPromise1() {
        var t = this;
        var Clazz = qx.Class.define("testPropertySetValueAsPromise1.Clazz", {
          extend: qx.core.Object,
          properties: {
            alpha: {
              init: null,
              nullable: true
            }
          }
        });
        this.assertTrue(!!Clazz.prototype.setAlpha);
        this.assertFalse(!!Clazz.prototype.setAlphaAsync);
        var obj = new Clazz();
        var p = new qx.Promise(function (resolve) {
          resolve(123);
        });
        obj.setAlpha(p);
        p.then(function () {
          t.assertEquals(123, obj.getAlpha());
          qx.Class.undefine("testPropertySetValueAsPromise1.Clazz");
          t.resume();
        });
        this.wait(1000);
      },

      /**
       * Tests that setting a property value with a promise will delay setting the
       * value until the promise is resolved.  In this case, the property *is*
       * marked as async and the setXxxAsync method is used to test chaining
       */
      testPropertySetValueAsPromise2: function testPropertySetValueAsPromise2() {
        var t = this;
        var Clazz = qx.Class.define("testPropertySetValueAsPromise2.Clazz", {
          extend: qx.core.Object,
          properties: {
            alpha: {
              init: null,
              nullable: true,
              async: true
            }
          }
        });
        this.assertTrue(!!Clazz.prototype.setAlpha);
        this.assertTrue(!!Clazz.prototype.setAlphaAsync);
        var obj = new Clazz();
        var p = new qx.Promise(function (resolve) {
          resolve(123);
        });
        obj.setAlphaAsync(p).then(function () {
          t.assertEquals(123, obj.getAlpha());
          qx.Class.undefine("testPropertySetValueAsPromise2.Clazz");
          t.resume();
        });
        this.wait(1000);
      },

      /**
       * Tests that a property apply method can return a promise; in this case, the
       * property is not marked as async so the apply method is only able to delay
       * the event handler
       */
      testPropertySetValueAsyncApply1: function testPropertySetValueAsyncApply1() {
        var t = this;
        var p;
        var Clazz = qx.Class.define("testPropertySetValueAsyncApply1.Clazz", {
          extend: qx.core.Object,
          properties: {
            alpha: {
              init: null,
              nullable: true,
              apply: "_applyAlpha",
              event: "changeAlpha"
            }
          },
          members: {
            _applyAlpha: function _applyAlpha(value, oldValue) {
              return p = new qx.Promise(function (resolve) {
                setTimeout(function () {
                  resolve("xyz");
                }, 250);
              });
            }
          }
        });
        var obj = new Clazz();
        var eventFired = 0;
        obj.addListener("changeAlpha", function (evt) {
          eventFired++;
        });
        obj.setAlpha("abc");
        this.assertTrue(!!p);
        this.assertEquals(0, eventFired);
        this.assertEquals("abc", obj.getAlpha());
        p.then(function (value) {
          this.assertEquals("xyz", value); // "xyz" because this is the internal promise

          this.assertEquals("abc", obj.getAlpha());
          this.assertEquals(1, eventFired);
          qx.Class.undefine("testPropertySetValueAsyncApply1.Clazz");
          t.resume();
        }, this);
        this.wait(1000);
      },

      /**
       * Tests that a property apply method can return a promise; in this case, the
       * property *is* marked as async, and we use the setAlphaAsync to test chaining
       */
      testPropertySetValueAsyncApply2: function testPropertySetValueAsyncApply2() {
        var t = this;
        var Clazz = qx.Class.define("testPropertySetValueAsyncApply2.Clazz", {
          extend: qx.core.Object,
          properties: {
            alpha: {
              init: null,
              nullable: true,
              async: true,
              apply: "_applyAlpha",
              event: "changeAlpha"
            }
          },
          members: {
            _applyAlpha: function _applyAlpha(value, oldValue) {
              return new qx.Promise(function (resolve) {
                setTimeout(function () {
                  resolve("xyz");
                }, 250);
              });
            }
          }
        });
        var obj = new Clazz();
        var eventFired = 0;
        obj.addListener("changeAlpha", function (evt) {
          eventFired++;
        });
        var p = obj.setAlphaAsync("abc");
        this.assertEquals(0, eventFired);
        p.then(function (value) {
          this.assertEquals("abc", value);
          this.assertEquals("abc", obj.getAlpha());
          this.assertEquals(1, eventFired); // Set the same value, should return a new promise but not fire an event

          p = obj.setAlphaAsync("abc");
          p.then(function (value) {
            this.assertEquals("abc", value);
            this.assertEquals("abc", obj.getAlpha());
            this.assertEquals(1, eventFired);
            qx.Class.undefine("testPropertySetValueAsyncApply2.Clazz");
            t.resume();
          }, this);
        }, this);
        this.wait(1000);
      },

      /**
       * Tests that a property apply method can take a promise
       */
      testPropertySetValueAsyncApply3: function testPropertySetValueAsyncApply3() {
        var t = this;
        var Clazz = qx.Class.define("testPropertySetValueAsyncApply3.Clazz", {
          extend: qx.core.Object,
          properties: {
            alpha: {
              init: null,
              nullable: true,
              check: "qx.Promise"
            }
          }
        });
        var obj = new Clazz();
        var p = qx.Promise.resolve("hello");
        obj.setAlpha(p);
        this.assertEquals(p, obj.getAlpha());
        qx.Class.undefine("testPropertySetValueAsyncApply3.Clazz");
      },
      testBinding: function testBinding() {
        var t = this;
        var AsyncClazz = qx.Class.define("testBinding.AsyncClazz", {
          extend: qx.core.Object,
          properties: {
            alpha: {
              init: null,
              nullable: true,
              async: true,
              event: "changeAlpha"
            }
          },
          members: {
            _applyAlpha: function _applyAlpha(value, oldValue) {
              return new qx.Promise(function (resolve) {
                setTimeout(resolve, 250);
              });
            }
          }
        });
        var SyncClazz = qx.Class.define("testBinding.SyncClazz", {
          extend: qx.core.Object,
          properties: {
            bravo: {
              init: null,
              nullable: true,
              event: "changeBravo"
            }
          }
        });
        /*
         * Test binding an async property to a "normal" sync property
         */

        var asyncToSync = new qx.Promise(function (resolve) {
          var asyncObj = new AsyncClazz();
          var syncObj = new SyncClazz();
          var p1 = new qx.Promise();
          asyncObj.addListenerOnce("changeAlphaAsync", function (evt) {
            var data = evt.getData();
            this.assertTrue(data instanceof qx.Promise);
            p1.resolve();
          }, this);
          var p2 = new qx.Promise();
          var bravoEvents = 0;
          var id = syncObj.addListener("changeBravo", function (evt) {
            bravoEvents++;
            this.assertTrue(bravoEvents <= 2);
            var data = evt.getData(); // First event is .bind() setting the initial value

            if (bravoEvents == 1) {
              this.assertNull(data); // Second event was caused by asyncObj.setAlphaAsync()
            } else if (bravoEvents == 2) {
              this.assertEquals("zyx", data);
              syncObj.removeListenerById(id);
              p2.resolve();
            }
          }, this);
          asyncObj.getAlphaAsync();
          asyncObj.bind("alphaAsync", syncObj, "bravo");
          asyncObj.setAlphaAsync("zyx");
          qx.Promise.all([p1, p2]).then(function () {
            var p3 = new qx.Promise();
            syncObj.addListenerOnce("changeBravo", function (evt) {
              var data = evt.getData();
              this.assertEquals("wvu", data);
              p3.resolve();
            }, this);
            asyncObj.setAlphaAsync("wvu");
            p3.then(function () {
              this.resume();
            }, this);
          }, this);
        }, this);
        /*
         * Test binding a "normal" sync property to an async property
         */

        asyncToSync.then(function () {
          var asyncObj = new AsyncClazz();
          var syncObj = new SyncClazz();
          var p1 = new qx.Promise();
          asyncObj.addListenerOnce("changeAlphaAsync", function (evt) {
            var data = evt.getData();
            this.assertEquals("def", data);
            p1.resolve();
          }, this);
          syncObj.bind("bravo", asyncObj, "alphaAsync");
          syncObj.setBravo("def");
          p1.then(function () {
            var p2 = new qx.Promise();
            asyncObj.addListenerOnce("changeAlphaAsync", function (evt) {
              var data = evt.getData();
              this.assertEquals("ghi", data);
              p2.resolve();
            }, this);
            syncObj.setBravo("ghi");
            return p2.then(function () {
              qx.Class.undefine("testBinding.AsyncClazz");
              qx.Class.undefine("testBinding.SyncClazz");
              this.resume();
            }, this);
          }, this);
        }, this);
        this.wait(1000);
      },

      /**
       * Tests event handlers bound to the "changeXxxAsync" events, and which return
       * a promise.  Event handlers must be triggered in sequence and by returning
       * a promise will defer subsequent event handlers from firing
       */
      testAsyncEventHandlers: function testAsyncEventHandlers() {
        var Clazz = qx.Class.define("testAsyncEventHandlers.Clazz", {
          extend: qx.core.Object,
          properties: {
            value: {},
            alpha: {
              init: null,
              nullable: true,
              async: true,
              apply: "_applyAlpha",
              event: "changeAlpha"
            },
            bravo: {
              init: null,
              nullable: true,
              async: true,
              apply: "_applyBravo",
              event: "changeBravo"
            }
          },
          members: {
            _applyAlpha: function _applyAlpha(value, oldValue) {
              var p = new qx.Promise(function (resolve) {
                console.log("in _applyAlpha qx.Promise, value=" + value);
                setTimeout(function () {
                  console.log("in _applyAlpha resolving qx.Promise, value=" + value);
                  resolve("xyz");
                }, 50);
              });
              console.log("in _applyAlpha, value=" + value + ", p=" + p);
              return p;
            },
            _applyBravo: function _applyBravo(value, oldValue) {
              return new qx.Promise(function (resolve) {
                setTimeout(function () {
                  resolve("uvw");
                }, 50);
              });
            }
          }
        });

        function createObj(name) {
          var obj = new Clazz().set({
            value: name
          });
          obj.addListener("changeAlphaAsync", function (evt) {
            var value = evt.getData();
            var p = new qx.Promise(function (resolve) {
              console.log(name + ": changeAlphaAsync 1 in qx.Promise, value=" + value);
              setTimeout(function () {
                if (str.length) str += ",";
                str += name;
                console.log(name + ": changeAlphaAsync 1 resolving qx.Promise, value=" + value);
                resolve();
              }, 200);
            }).then(function () {
              console.log(name + ": changeAlphaAsync 1 resolved qx.Promise, value=" + value);
            });
            console.log(name + ": changeAlphaAsync 1, value=" + value + ", p=" + p);
            return p;
          });
          return obj;
        }

        var objOne = createObj("one");
        var objTwo = createObj("two");
        var str = "";
        objOne.addListener("changeAlphaAsync", function (evt) {
          var value = evt.getData();
          console.log("objOne.alphaAsync setting, value=" + value);
          return objTwo.setAlphaAsync("def").then(function () {
            str += "xxx";
            console.log("objOne.alphaAsync done, value=" + value);
          });
        });
        console.log("objOne.alphaAsync going to set value=abc");
        objOne.setAlphaAsync("abc").then(function () {
          console.log("objOne.alphaAsync completed set value=abc");
          this.assertEquals("one,twoxxx", str);
          qx.Class.undefine("testAsyncEventHandlers.Clazz");
          this.resume();
        }, this);
        this.wait(2500);
      },

      /**
       * Tests using bind() on async properties (using the "changeXxxAsync" events) between
       * a series of objects.  The test must show that the property values are fired in
       * order, and that if an async event handler returns a promise it defers bind from
       * propagating onto other objects.
       */
      testWaterfallBinding: function testWaterfallBinding() {
        var t = this;
        var Clazz = qx.Class.define("testWaterfallBinding.Clazz", {
          extend: qx.core.Object,
          properties: {
            value: {},
            alpha: {
              init: null,
              nullable: true,
              async: true,
              apply: "_applyAlpha",
              event: "changeAlpha"
            }
          },
          members: {
            _applyAlpha: function _applyAlpha(value, oldValue) {
              var t = this;
              console.log("pre applyAlpha[" + t.getValue() + "] = " + value);
              return new qx.Promise(function (resolve) {
                setTimeout(function () {
                  console.log("applyAlpha[" + t.getValue() + "] = " + value);
                  resolve("xyz");
                }, 50);
              });
            }
          }
        });
        var objs = [];
        var str = "";

        function trap(i) {
          var obj = new Clazz().set({
            value: i
          });
          var bindPromise;

          if (i > 0) {
            bindPromise = objs[i - 1].bindAsync("alphaAsync", obj, "alphaAsync");
          } else {
            bindPromise = qx.Promise.resolve(true);
          }

          return bindPromise.then(function () {
            obj.addListener("changeAlpha", function (evt) {
              var obj = evt.getTarget();
              var data = evt.getData();
              var delay = (5 - i + 1) * 100;
              console.log("pre changeAlpha " + obj.getValue() + " = " + data + " after " + delay);
              return new qx.Promise(function (resolve) {
                setTimeout(function () {
                  if (str.length) str += ",";
                  str += obj.getValue() + ":" + data;
                  console.log("changeAlpha " + obj.getValue() + " = " + data + " after " + delay);
                  resolve();
                }, delay);
              });
            }, this);
            objs[i] = obj;
          });
        }

        qx.Promise.mapSeries([0, 1, 2, 3, 4], trap).then(function () {
          var p = objs[0].setAlphaAsync("abc");
          p.then(function () {
            t.assertEquals("0:abc,1:abc,2:abc,3:abc,4:abc", str);
            qx.Class.undefine("testWaterfallBinding.Clazz");
            t.resume();
          }, t);
        });
        this.wait(10000);
      },

      /**
       * Tests the each method of promise, using qx.data.Array which the Bluebird implementation
       * does not understand.  The values are scalar values
       */
      testEach1: function testEach1() {
        var t = this;
        var arr = new qx.data.Array();
        arr.push("a");
        arr.push("b");
        arr.push("c");
        var str = "";
        var promise = qx.Promise.resolve(arr);
        promise.forEach(function (item) {
          str += item;
        }).then(function () {
          t.assertEquals("abc", str);
          t.resume();
        });
        t.wait(1000);
      },

      /**
       * Tests the each method of promise, using qx.data.Array which the Bluebird implementation
       * does not understand.  The values are a mixture of promises and scalar values
       */
      testEach2: function testEach2() {
        var t = this;
        var arr = new qx.data.Array();
        arr.push(new qx.Promise(function (resolve) {
          setTimeout(function () {
            resolve("a");
          }, 500);
        }));
        arr.push(new qx.Promise(function (resolve) {
          setTimeout(function () {
            resolve("b");
          }, 300);
        }));
        arr.push(new qx.Promise(function (resolve) {
          setTimeout(function () {
            resolve("c");
          }, 100);
        }));
        arr.push("d");
        arr.push("e");
        var str = "";
        var promise = qx.Promise.resolve(arr);
        this.assertInstance(promise, qx.Promise);
        var pEach = promise.forEach(function (item) {
          str += item;
        });
        this.assertInstance(pEach, qx.Promise);
        var pThen = pEach.then(function () {
          t.assertEquals("abcde", str);
          t.resume();
        });
        this.assertInstance(pThen, qx.Promise);
        t.wait(1000);
      },

      /**
       * Tests unhandled rejections being passed to the global error handler
       */
      testGlobalError: function testGlobalError() {
        var t = this;
        qx.event.GlobalError.setErrorHandler(function (ex) {
          t.assertEquals(ex.message, "oops");
          t.resume();
        });
        var self = this;
        var p = new qx.Promise(function (resolve, reject) {
          setTimeout(function () {
            resolve("ok");
          });
        }, this);
        p.then(function (value) {
          throw new Error("oops");
        });
        this.wait(1000);
      },

      /**
       * Tests promisification of methods
       */
      testMethod: function testMethod() {
        var t = this;
        var fn = qx.Promise.method(function (value) {
          return value;
        });
        var promise = fn("yes");
        this.assertInstance(promise, qx.Promise);
        promise.then(function (value) {
          t.assertEquals(value, "yes");
          t.resume();
        });
        this.wait(1000);
      },

      /**
       * Tests binding of all callbacks via .bind()
       */
      testBinding1: function testBinding1() {
        var t = this;
        var p = qx.Promise.resolve("hello").bind(this);
        p.then(function (value) {
          qx.core.Assert.assertIdentical(t, this);
          t.resume();
        });
        this.wait(1000);
      },

      /**
       * Tests binding on a per-method basis
       */
      testBinding2: function testBinding2() {
        var t = this;
        var p = qx.Promise.forEach(["a", "b", "c"], function (item) {
          qx.core.Assert.assertIdentical(t, this);
        }, this).then(function (value) {
          qx.core.Assert.assertIdentical(t, this);
          this.resume();
        }, this);
        this.wait(1000);
      },
      testMarshal: function testMarshal() {
        var marshal = new qx.data.marshal.Json();
        marshal.toClass(qx.test.Promise.TEST_MODEL.children[0], true);
        var model = marshal.toModel(qx.test.Promise.TEST_MODEL.children[0]);
      },

      /**
       * Tests binding where the context is static class
       */
      testBindingToStatic: function testBindingToStatic() {
        var t = this;
        qx.Promise.resolve(true).then(function () {
          qx.core.Assert.assertIdentical(qx.Promise, this);
          t.resume();
        }, qx.Promise);
        this.wait(1000);
      },

      /**
       * Tests the context parameter for qx.Promise.resolve
       */
      testBindingResolve: function testBindingResolve() {
        var t = this;
        qx.Promise.resolve(true, this).then(function () {
          qx.core.Assert.assertIdentical(t, this);
          t.resume();
        });
        this.wait(1000);
      },

      /**
       * Tests the context parameter for qx.Promise.reject
       */
      testBindingReject: function testBindingReject() {
        var t = this;
        qx.Promise.reject(new Error("Dummy Error"), this).catch(function () {
          qx.core.Assert.assertIdentical(t, this);
          t.resume();
        });
        this.wait(1000);
      },

      /**
       * Tests wrapping of parameters preserves the original values
       */
      testWrapping: function testWrapping() {
        var t = this;
        new qx.Promise(function (resolve) {
          resolve();
        }).then(function () {
          return qx.Promise.all(["foo", new qx.data.Array(["a", "b", "c"])]);
        }).spread(function (str, arr) {
          t.assertEquals(str, "foo");
          t.assertInstance(arr, qx.data.Array);
          t.assertEquals(arr.join(""), "abc");
          t.resume();
        });
        this.wait(1000);
      }
    },
    statics: {
      TEST_MODEL: {
        "name": "qx",
        "children": [{
          "name": "test",
          "children": [{
            "name": "Class",
            "children": [{
              "name": "test: instantiate class in defer and access property"
            }, {
              "name": "testAbstract"
            }, {
              "name": "testAnonymous"
            }]
          }, {
            "name": "Bootstrap",
            "children": [{
              "name": "test: define bootstrap class, which extends 'Error'"
            }, {
              "name": "test: define class with constructor"
            }, {
              "name": "test: extend from Bootstrap class"
            }]
          }]
        }]
      }
    }
  });
  qx.test.Promise.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.theme.manager.Decoration": {},
      "qx.Theme": {},
      "qx.ui.decoration.Decorator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @ignore(qx.theme.Foo)
   */
  qx.Class.define("qx.test.Theme", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.__formerTheme__P_204_0 = qx.theme.manager.Decoration.getInstance().getTheme();
      },
      tearDown: function tearDown() {
        qx.test.Theme.themes = null;
        qx.theme.manager.Decoration.getInstance().setTheme(this.__formerTheme__P_204_0);
        this.__formerTheme__P_204_0 = null;
      },
      testExtendTheme: function testExtendTheme() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          decorations: {
            "basic": {
              style: {}
            }
          }
        });
        qx.Theme.define("qx.test.Theme.themes.B", {
          extend: qx.test.Theme.themes.A,
          decorations: {}
        });
        var decorationManager = qx.theme.manager.Decoration.getInstance();
        decorationManager.setTheme(qx.test.Theme.themes.B);
        this.assertInstance(decorationManager.resolve("basic"), qx.ui.decoration.Decorator);
      },
      testIncludeTheme: function testIncludeTheme() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          decorations: {
            "basic": {
              style: {}
            }
          }
        });
        qx.Theme.define("qx.test.Theme.themes.B", {
          include: qx.test.Theme.themes.A,
          decorations: {}
        });
        var decorationManager = qx.theme.manager.Decoration.getInstance();
        decorationManager.setTheme(qx.test.Theme.themes.B);
        this.assertInstance(decorationManager.resolve("basic"), qx.ui.decoration.Decorator);
      },
      testIncludeInvalidTheme: function testIncludeInvalidTheme() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          decorations: {
            "basic": {
              style: {}
            }
          }
        });
        var decorationManager = qx.theme.manager.Decoration.getInstance();
        decorationManager.setTheme(qx.test.Theme.themes.A);
        this.assertException(function () {
          var invalidTheme = qx.theme.Foo;
          qx.Theme.include(qx.test.Theme.themes.A, invalidTheme);
        }, Error, "Mixin theme is not a valid theme!");
        this.assertException(function () {
          var invalidTheme = null;
          qx.Theme.include(qx.test.Theme.themes.A, invalidTheme);
        }, Error, "Mixin theme is not a valid theme!");
      },
      testPatchTheme: function testPatchTheme() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          decorations: {
            "basic": {
              style: {}
            }
          }
        });
        qx.Theme.define("qx.test.Theme.themes.B", {
          patch: qx.test.Theme.themes.A,
          decorations: {
            "basic": {
              style: {}
            }
          }
        });
        var decorationManager = qx.theme.manager.Decoration.getInstance();
        decorationManager.setTheme(qx.test.Theme.themes.B);
        this.assertInstance(decorationManager.resolve("basic"), qx.ui.decoration.Decorator);
      },
      testPatchInvalidTheme: function testPatchInvalidTheme() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          decorations: {
            "basic": {
              style: {}
            }
          }
        });
        var decorationManager = qx.theme.manager.Decoration.getInstance();
        decorationManager.setTheme(qx.test.Theme.themes.A);
        this.assertException(function () {
          var invalidTheme = qx.theme.Foo;
          qx.Theme.patch(qx.test.Theme.themes.A, invalidTheme);
        }, Error, "Mixin theme is not a valid theme!");
        this.assertException(function () {
          var invalidTheme = null;
          qx.Theme.patch(qx.test.Theme.themes.A, invalidTheme);
        }, Error, "Mixin theme is not a valid theme!");
      },
      testIncludeThemeWithIncludes: function testIncludeThemeWithIncludes() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          decorations: {
            "basic": {
              style: {}
            }
          }
        });
        qx.Theme.define("qx.test.Theme.themes.B", {
          include: [qx.test.Theme.themes.A],
          decorations: {}
        });
        qx.Theme.define("qx.test.Theme.themes.C", {
          include: [qx.test.Theme.themes.B],
          decorations: {}
        });
        var decorationManager = qx.theme.manager.Decoration.getInstance();
        decorationManager.setTheme(qx.test.Theme.themes.C);
        this.assertInstance(decorationManager.resolve("basic"), qx.ui.decoration.Decorator);
      },
      testDoubleExtend: function testDoubleExtend() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          decorations: {
            "basic": {
              style: {}
            }
          }
        });
        qx.Theme.define("qx.test.Theme.themes.B", {
          extend: qx.test.Theme.themes.A,
          decorations: {}
        });
        qx.Theme.define("qx.test.Theme.themes.C", {
          extend: qx.test.Theme.themes.B,
          decorations: {}
        });
        var decorationManager = qx.theme.manager.Decoration.getInstance();
        decorationManager.setTheme(qx.test.Theme.themes.C);
        this.assertInstance(decorationManager.resolve("basic"), qx.ui.decoration.Decorator);
      },
      testExtendThemeWithIncludes: function testExtendThemeWithIncludes() {
        qx.Theme.define("qx.test.Theme.themes.A", {
          decorations: {
            "basic": {
              style: {}
            }
          }
        });
        qx.Theme.define("qx.test.Theme.themes.B", {
          include: [qx.test.Theme.themes.A],
          decorations: {}
        });
        qx.Theme.define("qx.test.Theme.themes.C", {
          extend: qx.test.Theme.themes.B,
          decorations: {}
        });
        var decorationManager = qx.theme.manager.Decoration.getInstance();
        decorationManager.setTheme(qx.test.Theme.themes.C);
        this.assertInstance(decorationManager.resolve("basic"), qx.ui.decoration.Decorator);
      }
    }
  });
  qx.test.Theme.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.xml.Element": {},
      "qx.xml.Document": {},
      "qx.dom.Node": {},
      "qx.bom.client.Engine": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.version": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.Xml", {
    extend: qx.dev.unit.TestCase,
    members: {
      serializeArray: function serializeArray(arr) {
        var ser = [];

        for (var i = 0; i < arr.length; i++) {
          ser[i] = qx.xml.Element.serialize(arr[i]);
        }

        return ser.join(", ");
      },
      testParseSerializeXml: function testParseSerializeXml() {
        var doc = qx.xml.Document.create();
        this.assertTrue(qx.dom.Node.isDocument(doc));
        var div = doc.createElement("div");
        this.assertEquals("div", div.tagName);
        var xmlStr = "<html><body>Juhu <em id=\"toll\">Kinners</em>. Wie geht es <em>Euch</em>?</body></html>";
        var doc2 = qx.xml.Document.fromString(xmlStr);
        this.assertTrue(qx.dom.Node.isDocument(doc2));
        this.assertEquals(xmlStr, qx.xml.Element.serialize(doc2));
      },
      testFromString: function testFromString() {
        var data = "<Root><Row>test1</Row><Row>test2</Row><Row>test3</Row></Root>";
        var xml = qx.xml.Document.fromString(data); // this.debug("Converted to XML Document ", xml);
      },
      testCreateDocument: function testCreateDocument() {
        var doc = qx.xml.Document.create("", "rss");
        this.assertEquals('rss', doc.documentElement.tagName);
        this.assertEquals(0, doc.documentElement.childNodes.length);
        doc = qx.xml.Document.create("http://www.w3.org/1999/xhtml/", "html");
        this.assertEquals('http://www.w3.org/1999/xhtml/', doc.documentElement.namespaceURI);
        this.assertEquals('html', doc.documentElement.tagName);
        this.assertEquals(0, doc.documentElement.childNodes.length);
      },
      testXPath: function testXPath() {
        var xmlStr = '<html><body>Juhu <em id="toll">Kinners</em>. Wie geht es <em>Euch</em>?</body></html>';
        var doc2 = qx.xml.Document.fromString(xmlStr);
        var em = doc2.getElementsByTagName("em")[0];
        this.assertEquals('<em id="toll">Kinners</em>', qx.xml.Element.serialize(em));
        this.assertEquals(qx.xml.Element.serialize(em), qx.xml.Element.serialize(qx.xml.Element.selectSingleNode(doc2, '//*[@id="toll"]')));
        this.assertEquals(qx.xml.Element.serialize(doc2.getElementsByTagName("body")[0]), qx.xml.Element.serialize(qx.xml.Element.selectSingleNode(doc2, '//body')));
        this.assertEquals(this.serializeArray(doc2.getElementsByTagName("em")), this.serializeArray(qx.xml.Element.selectNodes(doc2, '//em')));
        this.assertEquals(this.serializeArray(doc2.getElementsByTagName("em")), this.serializeArray(qx.xml.Element.selectNodes(doc2.documentElement, '//em')));
      },
      testXPathNS: function testXPathNS() {
        var xmlStr = '<html xmlns="http://www.w3.org/1999/xhtml/"><body>Juhu <em id="toll">Kinners</em>. Wie geht es <em>Euch</em>?<foo xmlns="http://qooxdoo.org" id="bar"/></body></html>';
        var doc = qx.xml.Document.fromString(xmlStr);
        var em = qx.xml.Element.getElementsByTagNameNS(doc, "http://www.w3.org/1999/xhtml/", "em")[0];
        var foo = qx.xml.Element.getElementsByTagNameNS(doc, "http://qooxdoo.org", "foo")[0];
        var emStr = qx.xml.Element.serialize(em);
        var fooStr = qx.xml.Element.serialize(foo);
        var nsMap = {
          "xhtml": "http://www.w3.org/1999/xhtml/",
          "qx": "http://qooxdoo.org"
        };
        var q1 = "//xhtml:em";
        var q2 = "//qx:foo";
        var q3 = "//xhtml:body"; // Chrome versions older than 532.2 will throw an exception. See Chromium
        // bug #671 (http://code.google.com/p/chromium/issues/detail?id=671)

        if (navigator.userAgent.indexOf('Chrome') > 0 && qx.core.Environment.get("engine.version") < 532.2) {
          this.assertException(function () {
            qx.xml.Element.selectSingleNode(doc, q1, nsMap);
          }, Error, "DOM Exception 14", "Namespaced XPath query worked in Chrome < 532.2!");
          this.assertException(function () {
            qx.xml.Element.selectSingleNode(doc, q2, nsMap);
          }, Error, "DOM Exception 14", "Namespaced XPath query worked in Chrome < 532.2!");
        } else {
          var n1 = qx.xml.Element.selectSingleNode(doc, q1, nsMap);
          var s1 = qx.xml.Element.serialize(n1); // this.debug("Found node: " + s1);

          this.assertEquals(s1, emStr);
          var n2 = qx.xml.Element.selectSingleNode(doc, q2, nsMap);
          var s2 = qx.xml.Element.serialize(n2); // this.debug("Found node: " + s2);

          this.assertEquals(s2, fooStr);
          var n3 = qx.xml.Element.selectNodes(doc, q3, nsMap);
          var n4 = qx.xml.Element.selectNodes(n3[0], q2, nsMap);
          var s4 = qx.xml.Element.serialize(n4[0]);
          this.assertEquals(s4, fooStr);
        }
      },
      testGetElementsByTagNameNS: function testGetElementsByTagNameNS() {
        var xmlStr = "<?xml version='1.0' encoding='UTF-8'?><xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'><xsl:output method='xml' version='1.0' encoding='UTF-8' indent='yes'/><xsl:template match='*'></xsl:template><xsl:template match='@*'></xsl:template></xsl:stylesheet>";
        var nsDoc = qx.xml.Document.fromString(xmlStr);
        var templates = qx.xml.Element.getElementsByTagNameNS(nsDoc, "http://www.w3.org/1999/XSL/Transform", "template"); // this.debug(qx.xml.String.escape(this.serializeArray(templates)));

        this.assertEquals(2, templates.length, "getElementsByTagNameNS for XML documents failed!");
        this.assertEquals("xsl:template", templates[0].tagName, "getElementsByTagNameNS for XML documents failed!");
        var templates = qx.xml.Element.getElementsByTagNameNS(nsDoc.documentElement, "http://www.w3.org/1999/XSL/Transform", "template");
        this.assertEquals(2, templates.length, "getElementsByTagNameNS for element nodes failed!");
        this.assertEquals("xsl:template", templates[0].tagName, "getElementsByTagNameNS for element nodes failed!");
      },
      testSetAttributeNS: function testSetAttributeNS() {
        var doc = qx.xml.Document.create("http://www.w3.org/1999/xhtml/", "html");
        var node = doc.createElement("a");
        var namespaceURI = "http://www.qooxdoo.org/";
        qx.xml.Element.setAttributeNS(doc, node, namespaceURI, "qxid", "foo");

        if (node.getAttributeNS) {
          this.assertEquals("foo", node.getAttributeNS(namespaceURI, "qxid"));
        } else {
          this.assertEquals(namespaceURI, node.getAttributeNode("qxid").namespaceURI);
        }
      },
      testGetAttributeNS: function testGetAttributeNS() {
        var doc = qx.xml.Document.create("http://www.w3.org/1999/xhtml/", "html");
        var node = doc.createElement("a");
        var namespaceURI = "http://www.qooxdoo.org/";
        qx.xml.Element.setAttributeNS(doc, node, namespaceURI, "qxid", "foo");
        this.assertEquals('foo', qx.xml.Element.getAttributeNS(node, namespaceURI, 'qxid'));
      },
      testCreateSubElementNS: function testCreateSubElementNS() {
        var xmlStr = '<html><body>Juhu <em id="toll">Kinners</em>.</body></html>';
        var doc = qx.xml.Document.fromString(xmlStr);
        var parent = doc.getElementsByTagName("em")[0];
        var namespaceUri = "http://qooxdoo.org";
        var subElem = qx.xml.Element.createSubElementNS(doc, parent, "foo", namespaceUri);
        var createdNode = qx.xml.Element.getElementsByTagNameNS(doc.documentElement, namespaceUri, "foo")[0];
        this.assertEquals(subElem, createdNode);
        this.assertTrue(subElem.parentNode == parent);
      }
    }
  });
  qx.test.Xml.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dom.Node": {},
      "qx.bom.client.Html": {},
      "qx.bom.client.Xml": {},
      "qx.bom.client.Engine": {
        "defer": "runtime"
      },
      "qx.bom.client.Browser": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "html.xpath": {
          "className": "qx.bom.client.Html"
        },
        "xml.selectsinglenode": {
          "className": "qx.bom.client.Xml"
        },
        "xml.selectnodes": {
          "className": "qx.bom.client.Xml"
        },
        "xml.getelementsbytagnamens": {
          "className": "qx.bom.client.Xml"
        },
        "xml.domproperties": {
          "className": "qx.bom.client.Xml"
        },
        "xml.attributens": {
          "className": "qx.bom.client.Xml"
        },
        "xml.createnode": {
          "className": "qx.bom.client.Xml"
        },
        "xml.getqualifieditem": {
          "className": "qx.bom.client.Xml"
        },
        "xml.createelementns": {
          "className": "qx.bom.client.Xml"
        },
        "engine.name": {
          "defer": true,
          "className": "qx.bom.client.Engine"
        },
        "engine.version": {
          "defer": true,
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "defer": true,
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Cross browser XML Element API
   *
   * API to select, query and serialize XML elements.
   *
   * Further information:
   *
   * * <a href="https://developer.mozilla.org/en-US/docs/Parsing_and_serializing_XML">MDN Parsing and Serializing XML</a>
   *
   * Please note that nodes selected using the <code>selectSingleNode()</code> and
   * <code>selectNodes()</code> methods remain in their document context so
   * <code>qx.xml.Element.selectNodes(foo, "//bar");</code>
   * will search the entire document for any nodes named "bar", not just the
   * <code>foo</code> node.
   */
  qx.Class.define("qx.xml.Element", {
    statics: {
      __xpe__P_587_0: null,

      /**
       * @type {Boolean} <code>true</code> if the native XMLSerializer should be used,
       * <code>false</code> otherwise.
       */
      XML_SERIALIZER: false,

      /**
       * The subtree rooted by the specified element or document is serialized to a string.
       *
       * @param element {Element | Document} The root of the subtree to be serialized. This could be any node, including a Document.
       * @return {String} Serialized subtree
       */
      serialize: function serialize(element) {
        if (qx.dom.Node.isDocument(element)) {
          element = element.documentElement;
        }

        if (this.XML_SERIALIZER) {
          return new XMLSerializer().serializeToString(element);
        } else {
          return element.xml || element.outerHTML;
        }
      },

      /**
       * Selects the first XmlNode that matches the XPath expression.
       *
       * @param element {Element | Document} root element for the search
       * @param query {String} XPath query
       * @param namespaces {Map} optional map of prefixes and their namespace URIs
       * @return {Element} first matching element
       */
      selectSingleNode: function selectSingleNode(element, query, namespaces) {
        if (qx.core.Environment.get("html.xpath")) {
          if (!this.__xpe__P_587_0) {
            this.__xpe__P_587_0 = new XPathEvaluator();
          }

          var xpe = this.__xpe__P_587_0;
          var resolver;

          if (namespaces) {
            resolver = function resolver(prefix) {
              return namespaces[prefix] || null;
            };
          } else {
            resolver = xpe.createNSResolver(element);
          }

          try {
            return xpe.evaluate(query, element, resolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
          } catch (err) {
            throw new Error("selectSingleNode: query: " + query + ", element: " + element + ", error: " + err);
          }
        }

        if (qx.core.Environment.get("xml.selectsinglenode")) {
          if (namespaces) {
            var namespaceString = "";

            for (var prefix in namespaces) {
              namespaceString += "xmlns:" + prefix + "='" + namespaces[prefix] + "' ";
            } // If the element is a node, set the selection namespace on its parent document.


            if (element.ownerDocument) {
              element.ownerDocument.setProperty("SelectionNamespaces", namespaceString);
            } // element is a document
            else {
                element.setProperty("SelectionNamespaces", namespaceString);
              }
          }

          return element.selectSingleNode(query);
        }

        throw new Error("No XPath implementation available!");
      },

      /**
       * Selects a list of nodes matching the XPath expression.
       *
       * @param element {Element | Document} root element for the search
       * @param query {String} XPath query
       * @param namespaces {Map} optional map of prefixes and their namespace URIs
       * @return {Element[]} List of matching elements
       */
      selectNodes: function selectNodes(element, query, namespaces) {
        if (qx.core.Environment.get("html.xpath")) {
          var xpe = this.__xpe__P_587_0;

          if (!xpe) {
            this.__xpe__P_587_0 = xpe = new XPathEvaluator();
          }

          var resolver;

          if (namespaces) {
            resolver = function resolver(prefix) {
              return namespaces[prefix] || null;
            };
          } else {
            resolver = xpe.createNSResolver(element);
          }

          try {
            var result = xpe.evaluate(query, element, resolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
          } catch (err) {
            throw new Error("selectNodes: query: " + query + ", element: " + element + ", error: " + err);
          }

          var nodes = [];

          for (var i = 0; i < result.snapshotLength; i++) {
            nodes[i] = result.snapshotItem(i);
          }

          return nodes;
        }

        if (qx.core.Environment.get("xml.selectnodes")) {
          if (namespaces) {
            var namespaceString = "";

            for (var prefix in namespaces) {
              namespaceString += "xmlns:" + prefix + "='" + namespaces[prefix] + "' ";
            } // If the element is a node, set the selection namespace on its parent document.


            if (element.ownerDocument) {
              element.ownerDocument.setProperty("SelectionNamespaces", namespaceString);
            } // element is a document
            else {
                element.setProperty("SelectionNamespaces", namespaceString);
              }
          }

          return element.selectNodes(query);
        }

        throw new Error("No XPath implementation available!");
      },

      /**
       * Returns a list of elements with the given tag name belonging to the given namespace
       *
       * (See
       * <a href="https://developer.mozilla.org/en-US/docs/DOM/element.getElementsByTagNameNS">MDN
       * Reference</a>).
       *
       * @param element {Element | Document} the element from where the search should start.
       *       Note that only the descendants of this element are included in the search, not the node itself.
       * @param namespaceURI {var} is the namespace URI of elements to look for . For example, if you need to look
       *       for XHTML elements, use the XHTML namespace URI, <tt>http://www.w3.org/1999/xhtml/</tt>.
       * @param tagname {String} the tagname to look for
       * @return {Element[]} a list of found elements in the order they appear in the tree.
       */
      getElementsByTagNameNS: function getElementsByTagNameNS(element, namespaceURI, tagname) {
        if (qx.core.Environment.get("xml.getelementsbytagnamens")) {
          return element.getElementsByTagNameNS(namespaceURI, tagname);
        }

        if (qx.core.Environment.get("xml.domproperties")) {
          var doc = element.ownerDocument || element;
          doc.setProperty("SelectionLanguage", "XPath");
          doc.setProperty("SelectionNamespaces", "xmlns:ns='" + namespaceURI + "'");
          return qx.xml.Element.selectNodes(element, 'descendant-or-self::ns:' + tagname);
        }

        throw new Error("The client does not support this operation!");
      },

      /**
       * Selects the first XmlNode that matches the XPath expression and returns the text content of the element
       *
       * @param element {Element|Document} root element for the search
       * @param query {String}  XPath query
       * @return {String} the joined text content of the found element or null if not appropriate.
       */
      getSingleNodeText: function getSingleNodeText(element, query) {
        var node = this.selectSingleNode(element, query);
        return qx.dom.Node.getText(node);
      },

      /**
       * Adds or sets an attribute with the given namespace on a node
       *
       * @param document {Document} The node's parent document, created e.g. by
       * {@link qx.xml.Document#create}
       * @param element {Element} XML/DOM element to modify
       * @param namespaceUri {String} Namespace URI
       * @param name {String} Attribute name
       * @param value {String} Attribute value
       */
      setAttributeNS: function setAttributeNS(document, element, namespaceUri, name, value) {
        if (qx.core.Environment.get("xml.attributens")) {
          element.setAttributeNS(namespaceUri, name, value);
        } else if (qx.core.Environment.get("xml.createnode")) {
          var attr = document.createNode(2, name, namespaceUri);
          attr.nodeValue = value;
          element.setAttributeNode(attr);
        } else {
          throw new Error("The client does not support this operation!");
        }
      },

      /**
       * Get the value of the attribute with the given namespace and name
       *
       * @param element {Element} XML/DOM element to modify
       * @param namespaceUri {String} Namespace URI
       * @param name {String} Attribute name
       * @return {String} the value of the attribute, empty string if not found
       */
      getAttributeNS: function getAttributeNS(element, namespaceUri, name) {
        if (qx.core.Environment.get("xml.attributens")) {
          var value = element.getAttributeNS(namespaceUri, name);
          return value === null ? '' : value;
        }

        if (qx.core.Environment.get("xml.getqualifieditem")) {
          var attributes = element.attributes;
          var value = null;

          if (attributes) {
            var attribute = attributes.getQualifiedItem(name, namespaceUri);

            if (attribute) {
              value = attribute.nodeValue;
            }
          }

          return value === null ? '' : value;
        }

        throw new Error("The client does not support this operation!");
      },

      /**
       * Creates an element with the given namespace and appends it to an existing
       * element
       *
       * @param document {Document} The node's parent document, created e.g. by
       * {@link qx.xml.Document#create}
       * @param parent {Element} The parent element for the new sub-element
       * @param name {String} The new element's name
       * @param namespaceUri {String} Namespace URI for the new element
       *
       * @return {Element} The newly created sub-element
       */
      createSubElementNS: function createSubElementNS(document, parent, name, namespaceUri) {
        if (qx.core.Environment.get("xml.createelementns")) {
          // the "x" prefix has no importance. when there's a conflict,
          // mozilla engine assigns an alternative prefix automatically.
          // not putting a prefix means to assign default namespace prefix
          // to the given namespace uri.
          var node = document.createElementNS(namespaceUri, "x:" + name);
          parent.appendChild(node);
          return node;
        }

        if (qx.core.Environment.get("xml.createnode")) {
          var node = document.createNode(1, name, namespaceUri);
          parent.appendChild(node);
          return node;
        }

        throw new Error("The client does not support this operation!");
      }
    },

    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer: function defer(statics) {
      statics.XML_SERIALIZER = window.XMLSerializer && !(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("engine.version") >= 9 && qx.core.Environment.get("browser.documentmode") >= 9);
    }
  });
  qx.xml.Element.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.bom.History": {},
      "qx.application.Routing": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.application.Routing", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      __r__P_205_0: null,
      __initialState__P_205_1: null,
      setUp: function setUp() {
        this.__initialState__P_205_1 = qx.bom.History.getInstance().getState();
        this.__r__P_205_0 = new qx.application.Routing();
      },
      tearDown: function tearDown() {
        qx.bom.History.getInstance().setState(this.__initialState__P_205_1);

        this.__r__P_205_0.dispose();
      },
      testGet: function testGet() {
        var handler = this.spy();

        this.__r__P_205_0.onGet("/abc", handler);

        this.__r__P_205_0.executeGet("/abc");

        this.assertCalledOnce(handler);
      },
      testBack: function testBack() {
        var aHandler = this.spy();
        var bHandler = this.spy();

        this.__r__P_205_0.onGet("/a", aHandler);

        this.__r__P_205_0.onGet("/b", bHandler);

        this.__r__P_205_0.executeGet("/a");

        this.__r__P_205_0.executeGet("/b");

        this.__r__P_205_0.back();

        this.assertCalledTwice(aHandler);
        this.assertCalledOnce(bHandler);
      },

      /**
      * Tests the ability of app routing to detect and remove route cycles.
      * After A >> B >> C >> B >> routing.back(), the routing should display A and not C.
      */
      testBackCycle: function testBackCycle() {
        var aHandler = this.spy();
        var bHandler = this.spy();
        var cHandler = this.spy();

        this.__r__P_205_0.onGet("/a", aHandler);

        this.__r__P_205_0.onGet("/b", bHandler);

        this.__r__P_205_0.onGet("/c", cHandler);

        this.__r__P_205_0.executeGet("/a");

        this.__r__P_205_0.executeGet("/b");

        this.__r__P_205_0.executeGet("/c");

        this.__r__P_205_0.executeGet("/b");

        this.__r__P_205_0.back();

        this.assertCalledTwice(aHandler);
        this.assertCalledTwice(bHandler);
        this.assertCalledOnce(cHandler);
      },
      testGetCustomData: function testGetCustomData() {
        var handler = this.spy();

        this.__r__P_205_0.onGet("/abc", handler);

        this.__r__P_205_0.executeGet("/abc", {
          a: true
        });

        this.assertCalledOnce(handler);
        this.assertTrue(handler.args[0][0].customData.a);
      },
      testGetCustomDataTwoInstances: function testGetCustomDataTwoInstances() {
        var r2 = new qx.application.Routing();
        var handler = this.spy();

        this.__r__P_205_0.onGet("/abc", handler);

        r2.executeGet("/abc", {
          a: true
        });
        this.assertCalledOnce(handler);
        this.assertTrue(handler.args[0][0].customData.a);
        r2.dispose();
      },
      testOn: function testOn() {
        var handler = this.spy();

        this.__r__P_205_0.on("/", handler);

        this.__r__P_205_0.execute("/");

        this.assertCalledOnce(handler);
      },
      testPost: function testPost() {
        var handler = this.spy();

        this.__r__P_205_0.onPost("/abc", handler);

        this.__r__P_205_0.executePost("/abc");

        this.assertCalledOnce(handler);
      },
      testPostParam: function testPostParam() {
        var handler = this.spy();
        var data = {
          data: "test"
        };

        this.__r__P_205_0.onPost("/{id}/affe", handler);

        this.__r__P_205_0.executePost("/123456/affe", data, "custom data");

        this.assertCalledOnce(handler);
        this.assertCalledWith(handler, {
          customData: "custom data",
          params: {
            id: "123456",
            data: "test"
          },
          path: "/123456/affe"
        });
      },
      testDelete: function testDelete() {
        var handler = this.spy();

        this.__r__P_205_0.onDelete("/abc", handler);

        this.__r__P_205_0.executeDelete("/abc");

        this.assertCalledOnce(handler);
      },
      testPut: function testPut() {
        var handler = this.spy();

        this.__r__P_205_0.onPut("/abc", handler);

        this.__r__P_205_0.executePut("/abc");

        this.assertCalledOnce(handler);
      },
      testAny: function testAny() {
        var handler = this.spy();

        this.__r__P_205_0.onAny("/abc", handler);

        this.__r__P_205_0.executePost("/abc");

        this.__r__P_205_0.executeDelete("/abc");

        this.assertCalledTwice(handler);
      },
      testInit: function testInit() {
        var handler = this.spy();
        var defaultHandler = this.spy();

        this.__r__P_205_0.dispose();

        this.__r__P_205_0 = new qx.application.Routing();

        this.__r__P_205_0.onGet("/a/b/c", handler);

        this.assertNotCalled(handler);

        this.__r__P_205_0.onGet("/", defaultHandler);

        this.assertNotCalled(defaultHandler);

        this.__r__P_205_0.init();

        this.assertNotCalled(handler);
        this.assertCalledOnce(defaultHandler);
        qx.bom.History.getInstance().setState("/a/b/c");
        this.assertCalledOnce(handler);
      },
      testGetPathOrFallback: function testGetPathOrFallback() {
        this.__r__P_205_0.on("/registered", function () {});

        this.assertEquals("/", this.__r__P_205_0._getPathOrFallback(""));
        this.assertEquals("/", this.__r__P_205_0._getPathOrFallback(null));
        this.assertEquals("/", this.__r__P_205_0._getPathOrFallback("/not/registered"));
        this.assertEquals("/given/default", this.__r__P_205_0._getPathOrFallback("use_default_instead_of_this", "/given/default"));
        this.assertEquals("/registered", this.__r__P_205_0._getPathOrFallback("/registered"));
      }
    }
  });
  qx.test.application.Routing.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.bom.AnimationFrame": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.AnimationFrame", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock],
    members: {
      setUp: function setUp() {
        this.__frame__P_206_0 = new qx.bom.AnimationFrame();
      },
      testStart: function testStart() {
        var clb = this.spy();

        this.__frame__P_206_0.once("frame", clb);

        this.__frame__P_206_0.startSequence(300);

        this.wait(500, function () {
          this.assertCalledOnce(clb);
          this.assertTrue(clb.args[0][0] >= 0);
        }, this);
      },
      testCancel: function testCancel() {
        var clb = this.spy();

        this.__frame__P_206_0.once("frame", clb);

        this.__frame__P_206_0.startSequence(300);

        this.__frame__P_206_0.cancelSequence();

        this.wait(500, function () {
          this.assertNotCalled(clb);
        }, this);
      }
    }
  });
  qx.test.bom.AnimationFrame.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.element.Attribute": {},
      "qx.util.ResourceManager": {},
      "qx.bom.client.Browser": {},
      "qx.bom.client.Engine": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */

  /* ************************************************************************
  ************************************************************************ */

  /**
   *
   * @asset(qx/icon/Tango/48/places/folder.png)
   */
  qx.Class.define("qx.test.bom.Attribute", {
    extend: qx.dev.unit.TestCase,
    members: {
      __maxLengthValues__P_207_0: null,
      setUp: function setUp() {
        var div = document.createElement("div");
        div.id = "el";
        this._el = div;
        document.body.appendChild(div);
        var input = document.createElement("input");
        this._input = input;
        document.body.appendChild(input);
        var checkBox = document.createElement("input");
        checkBox.type = "checkbox";
        this._checkBox = checkBox;
        document.body.appendChild(checkBox);
        var img = document.createElement("img");
        this._img = img;
        document.body.appendChild(img);
        this.__maxLengthValues__P_207_0 = {
          "mshtml": 2147483647,
          "default": -1
        };
      },
      tearDown: function tearDown() {
        document.body.removeChild(this._el);
        document.body.removeChild(this._checkBox);
        document.body.removeChild(this._img);
        document.body.removeChild(this._input);
      },
      testSetAttribute: function testSetAttribute() {
        var Attribute = qx.bom.element.Attribute;
        Attribute.set(this._el, "maxLength", 10);
        this.assertEquals(10, this._el.getAttribute("maxLength"));
        Attribute.set(this._checkBox, "checked", true);
        this.assertTrue(this._checkBox["checked"]);
        Attribute.set(this._el, "className", "vanillebaer");
        this.assertEquals("vanillebaer", this._el["className"]);
        Attribute.set(this._el, "selected", true);
        this.assertEquals("selected", this._el.getAttribute("selected"));
        var imgSrc = qx.util.ResourceManager.getInstance().toUri("qx/icon/Tango/48/places/folder.png");
        Attribute.set(this._img, "src", imgSrc);
        this.assertEquals(imgSrc, this._img.getAttribute("src", 2));
        Attribute.set(this._el, "data-foo", true);
        this.assertEquals("true", this._el.getAttribute("data-foo"));
      },
      testSetAttributeWithUndefinedValue: function testSetAttributeWithUndefinedValue() {
        var Attribute = qx.bom.element.Attribute;
        Attribute.set(this._el, "src", undefined);
        this.assertNotEquals("undefined", this._el.getAttribute("src"));
      },
      testGetAttribute: function testGetAttribute() {
        var Attribute = qx.bom.element.Attribute;

        if (qx.core.Environment.get("browser.name") == "edge") {
          this.assertEquals(Attribute.get(this._input, "maxLength"), this.__maxLengthValues__P_207_0.mshtml);
        } else if (qx.core.Environment.get("browser.name") == "chrome" || qx.core.Environment.get("browser.name") == "safari") {
          this.assertEquals(Attribute.get(this._input, "maxLength"), this.__maxLengthValues__P_207_0["default"]);
        } else {
          this.assertNull(Attribute.get(this._input, "maxLength"));
        }

        this.assertFalse(Attribute.get(this._checkBox, "checked"));
        this.assertNull(Attribute.get(this._el, "className"));
        this.assertNull(Attribute.get(this._el, "innerHTML"));
        this.assertNull(Attribute.get(this._checkBox, "tabIndex"));
        this.assertFalse(Attribute.get(this._checkBox, "readOnly"));
        this.assertNull(Attribute.get(this._input, "value"));

        this._checkBox.setAttribute("checked", true);

        this.assertEquals(true, Attribute.get(this._checkBox, "checked"));

        this._checkBox.removeAttribute("checked");

        this.assertFalse(Attribute.get(this._checkBox, "checked"));
        this._el["className"] = "vanillebaer";
        this.assertEquals("vanillebaer", Attribute.get(this._el, "className"));
        this._el.innerHTML = "vanillebaer";
        this.assertEquals("vanillebaer", Attribute.get(this._el, "innerHTML"));
        this._checkBox["tabIndex"] = 1000;
        this.assertEquals(1000, Attribute.get(this._checkBox, "tabIndex"));
        this._checkBox["tabIndex"] = 0;
        this.assertNull(Attribute.get(this._checkBox, "tabIndex"));
        this._checkBox["tabIndex"] = -1;
        this.assertEquals(-1, Attribute.get(this._checkBox, "tabIndex"));
        this._checkBox["readOnly"] = true;
        this.assertTrue(Attribute.get(this._checkBox, "readonly"));
        this._checkBox["value"] = "vanillebaer";
        this.assertEquals("vanillebaer", Attribute.get(this._checkBox, "value"));
        var imgSrc = qx.util.ResourceManager.getInstance().toUri("qx/icon/Tango/48/places/folder.png");
        Attribute.set(this._img, "src", imgSrc);
        this.assertEquals(imgSrc, Attribute.get(this._img, "src"));
      },
      testRemoveAttribute: function testRemoveAttribute() {
        var Attribute = qx.bom.element.Attribute;
        Attribute.set(this._input, "maxLength", 10);
        Attribute.set(this._input, "maxLength", null);
        var maxLengthValue = qx.core.Environment.select("engine.name", this.__maxLengthValues__P_207_0);

        if (qx.core.Environment.get("browser.name") == "edge") {
          maxLengthValue = this.__maxLengthValues__P_207_0.mshtml;
        } else if (qx.core.Environment.get("browser.name") == "chrome" || qx.core.Environment.get("browser.name") == "safari") {
          maxLengthValue = this.__maxLengthValues__P_207_0["default"];
        }

        this.assertEquals(maxLengthValue, this._input["maxLength"]);

        if (qx.core.Environment.get("browser.name") == "edge") {
          this.assertEquals(Attribute.get(this._input, "maxLength"), this.__maxLengthValues__P_207_0.mshtml);
        } else if (qx.core.Environment.get("browser.name") == "chrome" || qx.core.Environment.get("browser.name") == "safari") {
          this.assertEquals(Attribute.get(this._input, "maxLength"), this.__maxLengthValues__P_207_0["default"]);
        } else {
          this.assertNull(Attribute.get(this._input, "maxLength"));
        }

        Attribute.set(this._checkBox, "checked", true);
        Attribute.set(this._checkBox, "checked", null);
        this.assertFalse(this._checkBox["checked"]);
        Attribute.set(this._el, "html", "vanillebaer");
        Attribute.set(this._el, "html", null);
        this.assertNull(this._el.getAttribute("html"));
      },
      testResetAttribute: function testResetAttribute() {
        var Attribute = qx.bom.element.Attribute;
        Attribute.set(this._input, "maxLength", 10);
        Attribute.reset(this._input, "maxLength");

        if (qx.core.Environment.get("browser.name") == "edge") {
          this.assertEquals(Attribute.get(this._input, "maxLength"), this.__maxLengthValues__P_207_0.mshtml);
        } else if (qx.core.Environment.get("browser.name") == "chrome" || qx.core.Environment.get("browser.name") == "safari") {
          this.assertEquals(Attribute.get(this._input, "maxLength"), this.__maxLengthValues__P_207_0["default"]);
        } else {
          this.assertNull(Attribute.get(this._input, "maxLength"));
        }

        Attribute.set(this._checkBox, "disabled", true);
        Attribute.reset(this._checkBox, "disabled");
        this.assertFalse(Attribute.get(this._checkBox, "disabled"));
        Attribute.set(this._checkBox, "multiple", true);
        Attribute.reset(this._checkBox, "multiple");
        this.assertFalse(Attribute.get(this._checkBox, "multiple"));
        Attribute.set(this._el, "innerHTML", "<b>foo</b>");
        Attribute.reset(this._el, "innerHTML");
        this.assertNull(Attribute.get(this._el, "innerHTML"));
        Attribute.set(this._el, "tabIndex", 10);
        Attribute.reset(this._el, "tabIndex");
        this.assertNull(Attribute.get(this._el, "tabIndex"));
        Attribute.set(this._input, "tabIndex", 20);
        Attribute.reset(this._input, "tabIndex");
        this.assertNull(Attribute.get(this._input, "tabIndex"));
        Attribute.set(this._checkBox, "checked", true);
        Attribute.reset(this._checkBox, "checked");
        this.assertFalse(Attribute.get(this._checkBox, "checked"));
        Attribute.set(this._checkBox, "readOnly", true);
        Attribute.reset(this._checkBox, "readonly");
        this.assertFalse(Attribute.get(this._checkBox, "readonly"));
        Attribute.set(this._input, "value", "foo");
        Attribute.reset(this._input, "value");
        this.assertNull(Attribute.get(this._input, "value"));
      }
    }
  });
  qx.test.bom.Attribute.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.element.Attribute": {},
      "qx.bom.element.Style": {},
      "qx.bom.element.Opacity": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Basic", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        var div = document.createElement("div");
        div.id = "html_basics";
        div.innerHTML = "<div id=\"test1\" class=\"hello world\" title=\"hello world title\"> <input id=\"test2\" name=\"foo2\" type=\"text\" maxlength=\"20\" value=\"hello\"/>  <input tabindex=\"2\" id=\"test3\" type=\"checkbox\" checked=\"true\" name=\"foo3\" value=\"bar\"/>  <input id=\"test4\" type=\"text\" disabled=\"disabled\"/>  <input id=\"test5\" type=\"text\" disabled=\"false\" READONLY=\"true\"/>  <a id=\"test6\" style=\"color:red;background:blue\" href=\"../foo.html\"><b>Foo</b>-Link</a>  <table id=\"test7\" valign=\"bottom\"><tr><td colspan=\"3\"></td></tr></table>  <span id=\"test8\">Black</span></div>";
        document.body.appendChild(div);
      },
      tearDown: function tearDown() {
        var div = document.getElementById("html_basics");
        document.body.removeChild(div);
      },
      testElementAttributes: function testElementAttributes() {
        var attrib = qx.bom.element.Attribute;
        var style = qx.bom.element.Style;
        var opac = qx.bom.element.Opacity;
        var test1 = document.getElementById("test1");
        this.assertEquals("hello world", attrib.get(test1, "class"));
        this.assertEquals("hello world title", attrib.get(test1, "title"));
        var test2 = document.getElementById("test2");
        this.assertEquals("foo2", attrib.get(test2, "name"));
        this.assertEquals("hello", attrib.get(test2, "value"));
        this.assertEquals("text", attrib.get(test2, "type"));
        this.assertEquals(20, attrib.get(test2, "maxlength"));
        var test3 = document.getElementById("test3");
        this.assertEquals("foo3", attrib.get(test3, "name"));
        this.assertEquals("bar", attrib.get(test3, "value"));
        this.assertEquals("checkbox", attrib.get(test3, "type"));
        this.assertTrue(attrib.get(test3, "checked"));
        this.assertFalse(attrib.get(test3, "disabled"));
        this.assertEquals(2, attrib.get(test3, "tabindex"));
        this.info("test4");
        this.assertTrue(attrib.get(document.getElementById("test4"), "disabled"));
        this.assertFalse(attrib.get(document.getElementById("test4"), "readonly"));
        this.info("test5");
        this.assertTrue(attrib.get(document.getElementById("test5"), "disabled"));
        this.assertTrue(attrib.get(document.getElementById("test5"), "readonly"));
        this.info("test6");
        this.assert(attrib.get(document.getElementById("test6"), "href").endsWith("/foo.html"));
        var test6Color = style.get(document.getElementById("test6"), "color");
        this.assertCssColor("red", test6Color);
        var test6BackgroundColor = style.get(document.getElementById("test6"), "backgroundColor");
        this.assertCssColor("blue", test6BackgroundColor);
        this.assertIdentical("", style.get(document.getElementById("test6"), "font", style.LOCAL_MODE)); // This test fails in IE, Webkit and Opera but the value is correct
        //this.assertEquals("serif", style.get(document.getElementById("test6"), "fontFamily"));

        this.assertEquals("Foo-Link", attrib.get(document.getElementById("test6"), "text"));
        this.assertEquals("<b>foo</b>-link", attrib.get(document.getElementById("test6"), "html").toLowerCase());
        this.assertEquals(1, opac.get(document.getElementById("test6")));
        this.info("test7");
        this.assertEquals("bottom", attrib.get(document.getElementById("test7"), "valign"));
        this.assertEquals(3, attrib.get(document.getElementById("test7").getElementsByTagName("td")[0], "colspan"));
        this.info("test8");
        style.set(document.getElementById("test8"), "color", "red");
        style.set(document.getElementById("test8"), "backgroundColor", "black");
        opac.set(document.getElementById("test8"), 0.5);
        var test8Color = style.get(document.getElementById("test8"), "color");
        this.assertCssColor("red", test8Color);
        var test8BackgroundColor = style.get(document.getElementById("test8"), "backgroundColor");
        this.assertCssColor("black", test8BackgroundColor);
        this.assertEquals(0.5, opac.get(document.getElementById("test8")));
      }
    }
  });
  qx.test.bom.Basic.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.Blocker": {},
      "qx.dom.Element": {},
      "qx.bom.element.Style": {},
      "qx.bom.Document": {},
      "qx.bom.element.Dimension": {},
      "qx.bom.client.Engine": {},
      "qx.dom.Hierarchy": {},
      "qx.event.Timer": {},
      "qx.bom.element.Location": {},
      "qx.util.ColorUtil": {},
      "qx.bom.element.Opacity": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Blocker", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.__blocker__P_208_0 = new qx.bom.Blocker();

        this.__blocker__P_208_0.setBlockerZIndex(199);

        this.__blockedElement__P_208_1 = qx.dom.Element.create("div");
        qx.bom.element.Style.setStyles(this.__blockedElement__P_208_1, {
          position: "absolute",
          top: "100px",
          left: "100px",
          width: "500px",
          height: "400px",
          zIndex: 200
        });
        qx.dom.Element.insertBegin(this.__blockedElement__P_208_1, document.body);
      },
      tearDown: function tearDown() {
        this.__blocker__P_208_0.unblock();

        this.__blocker__P_208_0.dispose();

        this.__blocker__P_208_0 = null;
        qx.dom.Element.remove(this.__blockedElement__P_208_1);
      },
      testBlockWholeDocument: function testBlockWholeDocument() {
        this.__blocker__P_208_0.block();

        var blockerElement = this.__blocker__P_208_0.getBlockerElement();

        this.assertNotNull(blockerElement, "Blocker element not inserted.");
        this.assertEquals(qx.bom.Document.getWidth(), qx.bom.element.Dimension.getWidth(blockerElement));
        this.assertEquals(qx.bom.Document.getHeight(), qx.bom.element.Dimension.getHeight(blockerElement));

        if (qx.core.Environment.get("engine.name") == "mshtml") {
          var childElements = qx.dom.Hierarchy.getChildElements(document.body);
          var blockerIframeElement = childElements[childElements.length - 1];
          this.assertNotNull(blockerIframeElement, "Blocker iframe element not inserted");
          this.assertEquals(qx.bom.Document.getWidth(), qx.bom.element.Dimension.getWidth(blockerIframeElement));
          this.assertEquals(qx.bom.Document.getHeight(), qx.bom.element.Dimension.getHeight(blockerIframeElement));
        }

        this.__blocker__P_208_0.unblock();
      },
      testUnblockWholeDocument: function testUnblockWholeDocument() {
        this.__blocker__P_208_0.block();

        if (qx.core.Environment.get("engine.name") == "mshtml") {
          var childElements = qx.dom.Hierarchy.getChildElements(document.body);
          var blockerIframeElement = childElements[childElements.length - 1];
        }

        this.__blocker__P_208_0.unblock();

        var blockerElement = this.__blocker__P_208_0.getBlockerElement();

        this.assertFalse(qx.dom.Element.isInDom(blockerElement, window), "Blocker element not correctly removed");

        if (qx.core.Environment.get("engine.name") == "mshtml") {
          this.assertFalse(qx.dom.Element.isInDom(blockerIframeElement, window), "Blocker iframe element not correctly removed");
        }
      },
      testBlockElement: function testBlockElement() {
        this.__blocker__P_208_0.block(this.__blockedElement__P_208_1); // Timer is needed for IE6, otherwise the test will fail because IE6
        // is not able to resize the blockerElement fast enough


        qx.event.Timer.once(function () {
          var self = this;
          this.resume(function () {
            var blockerElement = self.__blocker__P_208_0.getBlockerElement();

            self.assertNotNull(blockerElement, "Blocker element not inserted.");
            self.assertEquals(qx.bom.element.Dimension.getWidth(self.__blockedElement__P_208_1), qx.bom.element.Dimension.getWidth(blockerElement));
            self.assertEquals(qx.bom.element.Dimension.getHeight(self.__blockedElement__P_208_1), qx.bom.element.Dimension.getHeight(blockerElement));
            self.assertEquals(qx.bom.element.Location.getLeft(self.__blockedElement__P_208_1), qx.bom.element.Location.getLeft(blockerElement));
            self.assertEquals(qx.bom.element.Location.getTop(self.__blockedElement__P_208_1), qx.bom.element.Location.getTop(blockerElement));
            self.assertEquals(qx.bom.element.Style.get(self.__blockedElement__P_208_1, "zIndex") - 1, qx.bom.element.Style.get(blockerElement, "zIndex"));

            if (qx.core.Environment.get("engine.name") == "mshtml") {
              var childElements = qx.dom.Hierarchy.getChildElements(document.body);
              var blockerIframeElement = childElements[childElements.length - 1];
              self.assertEquals(qx.bom.element.Style.get(self.__blockedElement__P_208_1, "zIndex") - 2, qx.bom.element.Style.get(blockerIframeElement, "zIndex"));
            }

            self.__blocker__P_208_0.unblock();
          }, self);
        }, this, 1000);
        this.wait();
      },
      testBlockerColor: function testBlockerColor() {
        this.__blocker__P_208_0.setBlockerColor("#FF0000");

        this.__blocker__P_208_0.block();

        var blockerElement = this.__blocker__P_208_0.getBlockerElement();

        var color = qx.bom.element.Style.get(blockerElement, "backgroundColor");

        if (qx.util.ColorUtil.isRgbString(color)) {
          this.assertEquals("rgb(255, 0, 0)", color);
        } else {
          this.assertEquals("#ff0000", color);
        }

        this.__blocker__P_208_0.unblock();
      },
      testBlockerOpacity: function testBlockerOpacity() {
        this.__blocker__P_208_0.setBlockerOpacity(0.7);

        this.__blocker__P_208_0.block();

        var blockerElement = this.__blocker__P_208_0.getBlockerElement();

        var value = qx.bom.element.Opacity.get(blockerElement);

        if (qx.core.Environment.get("engine.name") == "webkit") {
          value = Math.round(value * 10) / 10;
        }

        this.assertEquals(0.7, value);

        this.__blocker__P_208_0.unblock();
      },
      testDoubleBlocking: function testDoubleBlocking() {
        var before = qx.dom.Hierarchy.getDescendants(document.body);

        this.__blocker__P_208_0.block(this.__blockedElement__P_208_1);

        this.__blocker__P_208_0.block(this.__blockedElement__P_208_1);

        var after = qx.dom.Hierarchy.getDescendants(document.body);

        if (qx.core.Environment.get("engine.name") == "mshtml") {
          this.assertEquals(after.length, before.length + 2);
        } else {
          this.assertEquals(after.length, before.length + 1);
        }

        this.__blocker__P_208_0.unblock();
      },
      testDoubleUnBlocking: function testDoubleUnBlocking() {
        this.__blocker__P_208_0.block(this.__blockedElement__P_208_1);

        this.__blocker__P_208_0.unblock();

        this.__blocker__P_208_0.unblock();

        var blockerElement = this.__blocker__P_208_0.getBlockerElement();

        this.assertNotEquals(blockerElement.parentNode, this.__blockedElement__P_208_1);
      }
    }
  });
  qx.test.bom.Blocker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.element.Class": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Class", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this._el = document.createElement("div");
        document.body.appendChild(this._el);
      },
      tearDown: function tearDown() {
        document.body.removeChild(this._el);
      },
      testAddClass: function testAddClass() {
        var result = qx.bom.element.Class.add(this._el, "vanillebaer");
        this.assertEquals("vanillebaer", this._el.className);
        this.assertEquals("vanillebaer", result);
      },
      testAddClasses: function testAddClasses() {
        qx.bom.element.Class.addClasses(this._el, ["vanillebaer", "schokobaer"]);
        this.assertTrue(qx.bom.element.Class.has(this._el, "vanillebaer"));
        this.assertTrue(qx.bom.element.Class.has(this._el, "schokobaer"));
      },
      testHasClass: function testHasClass() {
        this._el.className = "vanillebaer";
        this.assertTrue(qx.bom.element.Class.has(this._el, "vanillebaer"));
        this.assertFalse(qx.bom.element.Class.has(this._el, "schokobaer"));
      },
      testRemoveClass: function testRemoveClass() {
        this._el.className = "vanillebaer";
        var result = qx.bom.element.Class.remove(this._el, "vanillebaer");
        this.assertEquals("", qx.bom.element.Class.get(this._el));
        this.assertEquals("vanillebaer", result);
      },
      testRemoveClasses: function testRemoveClasses() {
        this._el.className = "vanillebaer schokobaer karamellbaer";
        qx.bom.element.Class.removeClasses(this._el, ["vanillebaer", "schokobaer"]);
        this.assertFalse(qx.bom.element.Class.has(this._el, "vanillebaer"));
        this.assertFalse(qx.bom.element.Class.has(this._el, "schokobaer"));
        this.assertTrue(qx.bom.element.Class.has(this._el, "karamellbaer"));
      },
      testToggleClass: function testToggleClass() {
        this._el.className = "vanillebaer";
        qx.bom.element.Class.toggle(this._el, "vanillebaer");
        this.assertFalse(qx.bom.element.Class.has(this._el, "vanillebaer"));
        qx.bom.element.Class.toggle(this._el, "vanillebaer");
        this.assertTrue(qx.bom.element.Class.has(this._el, "vanillebaer"));
      },
      testReplaceClass: function testReplaceClass() {
        this._el.className = "vanillebaer";
        qx.bom.element.Class.replace(this._el, "vanillebaer", "schokobaer");
        this.assertTrue(qx.bom.element.Class.has(this._el, "schokobaer"));
        this.assertFalse(qx.bom.element.Class.has(this._el, "vanillebaer"));
      }
    }
  });
  qx.test.bom.Class.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.Cookie": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Cookie", {
    extend: qx.dev.unit.TestCase,
    members: {
      testSaveSimpleData: function testSaveSimpleData() {
        var key = "qx.test.bom.Cookie.testSaveSimpleData";
        var dataToSave = "Qooxdoo"; // Check that no value exists

        var result = qx.bom.Cookie.get(key);
        this.assertNull(result, "Empty check before start"); // Set and restore value

        qx.bom.Cookie.set(key, dataToSave);
        result = qx.bom.Cookie.get(key);
        this.assertEquals(dataToSave, result, "It is expected that this test fails if you start this test from a file system with Google Chrome."); // remove value

        qx.bom.Cookie.del(key);
        result = qx.bom.Cookie.get(key);
        this.assertNull(result, "Remove value");
      },
      testSaveData: function testSaveData() {
        var key1 = "qx.test.bom.Cookie.testSaveData2";
        var key2 = "qx.test.bom.Cookie.testSaveData1";
        var dataToSave1 = "Qooxdoo 1";
        var dataToSave2 = "Qooxdoo 2"; // Check that no values exist

        var result1 = qx.bom.Cookie.get(key1);
        var result2 = qx.bom.Cookie.get(key2);
        this.assertNull(result1, "Empty check before start (one)");
        this.assertNull(result2, "Empty check before start (tow)"); // Set and restore values

        qx.bom.Cookie.set(key1, dataToSave1);
        qx.bom.Cookie.set(key2, dataToSave2);
        result1 = qx.bom.Cookie.get(key1);
        result2 = qx.bom.Cookie.get(key2);
        this.assertEquals(dataToSave1, result1, "It is expected that this test fails if you start this test from a file system with Google Chrome.");
        this.assertEquals(dataToSave2, result2, "It is expected that this test fails if you start this test from a file system with Google Chrome."); // remove values

        qx.bom.Cookie.del(key1);
        qx.bom.Cookie.del(key2);
        result1 = qx.bom.Cookie.get(key1);
        result2 = qx.bom.Cookie.get(key2);
        this.assertNull(result1, "Remove value (one)");
        this.assertNull(result2, "Remove value (tow)");
      },
      testEncoding: function testEncoding() {
        var special = '~!@#$%^&*(){}[]=:/,;?+\'"\\';
        var utf = 'äëíöü';
        qx.bom.Cookie.set('special', special);
        qx.bom.Cookie.set('utf', utf);
        var escapedSpecial = escape(special);
        var escapedUtf = escape(utf);
        var expectedSpecial = unescape(escapedSpecial);
        var resultSpecial = qx.bom.Cookie.get('special');
        var expectedUtf = unescape(escapedUtf);
        var resultUtf = qx.bom.Cookie.get('utf');
        var escapedCookie = ['manualEscaped', "=", escapedUtf];
        document.cookie = escapedCookie.join("");
        this.assertNull(qx.bom.Cookie.get('manualEscaped'));
        this.assertTrue(decodeURIComponent(escapedSpecial) == unescape(escapedSpecial), 'There is some incompatible characters.'); // this.assertTrue((decodeURIComponent(escapedUtf) == unescape(escapedUtf)), 'There is some incompatible characters.');

        this.assertEquals(expectedSpecial, resultSpecial, 'There is some incompatible characters.');
        this.assertEquals(expectedUtf, resultUtf, 'There is some incompatible characters.');
      }
    }
  });
  qx.test.bom.Cookie.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.element.Dataset": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Dataset", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        var div = document.createElement("div");
        div.id = "el";
        this._el = div;
        document.body.appendChild(div);
      },
      tearDown: function tearDown() {
        document.body.removeChild(this._el);
      },
      testSetAttribute: function testSetAttribute() {
        var Dataset = qx.bom.element.Dataset;
        Dataset.set(this._el, "maxAge", "100");
        this.assertEquals("100", Dataset.get(this._el, "maxAge"));
        this.assertEquals("100", this._el.getAttribute("data-max-age"));
      },
      testSetAttributeWithUndefinedValue: function testSetAttributeWithUndefinedValue() {
        var Dataset = qx.bom.element.Dataset;
        Dataset.set(this._el, "age", undefined);
        this.assertNull(this._el.getAttribute("data-age"));
        this.assertUndefined(Dataset.get(this._el, "age", undefined));
        Dataset.set(this._el, "age2", null);
        this.assertNull(this._el.getAttribute("data-age2"));
        this.assertUndefined(Dataset.get(this._el, "age2", null));
      },
      testGetAttribute: function testGetAttribute() {
        var Dataset = qx.bom.element.Dataset;
        this.assertUndefined(Dataset.get(this._el, "salary"));

        this._el.setAttribute("data-salary", "20");

        this.assertEquals("20", Dataset.get(this._el, "salary"));
      },
      testRemoveAttribute: function testRemoveAttribute() {
        var Dataset = qx.bom.element.Dataset;
        Dataset.set(this._el, "age", "44");
        Dataset.remove(this._el, "age");
        this.assertNull(this._el.getAttribute("age"));
        this.assertUndefined(Dataset.get(this._el, "age"));
      }
    }
  });
  qx.test.bom.Dataset.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.Element": {},
      "qx.event.Registration": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Element", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        var div = document.createElement("div");
        div.id = "el";
        this._el = div;
        document.body.appendChild(div);
      },
      tearDown: function tearDown() {
        document.body.removeChild(this._el);
      },
      testAddListener: function testAddListener() {
        var listener = function listener() {};

        qx.bom.Element.addListener(this._el, "click", listener, this, false);
        this.assertTrue(qx.bom.Element.hasListener(this._el, "click", false));
        qx.bom.Element.removeListener(this._el, "click", listener, this, false);
        this.assertFalse(qx.bom.Element.hasListener(this._el, "click", false));
      },
      testRemoveListenerById: function testRemoveListenerById() {
        var id = qx.bom.Element.addListener(this._el, "click", function () {}, this, false);
        this.assertTrue(qx.bom.Element.hasListener(this._el, "click", false));
        qx.bom.Element.removeListenerById(this._el, id);
        this.assertFalse(qx.bom.Element.hasListener(this._el, "click", false));
      },
      testFocus: function testFocus() {
        qx.event.Registration.addListener(this._el, "focus", function () {
          this.resume(function () {
            this.info("Element focused.");
          }, this);
        }, this);
        var self = this;
        window.setTimeout(function () {
          qx.bom.Element.focus(self._el);
        }, 100);
        this.wait();
      },
      testBlur: function testBlur() {
        qx.event.Registration.addListener(this._el, "blur", function () {
          this.resume(function () {
            this.info("Element blurred.");
          }, this);
        }, this);
        var self = this;
        window.setTimeout(function () {
          qx.bom.Element.focus(self._el);
          qx.bom.Element.blur(self._el);
        }, 100);
        this.wait();
      },
      testActivate: function testActivate() {
        qx.bom.Element.activate(this._el);
        this.warn("needs better test!");
      },
      testDeactivate: function testDeactivate() {
        qx.bom.Element.deactivate(this._el);
        this.warn("needs better test!");
      },
      testCapture: function testCapture() {
        qx.bom.Element.capture(this._el);
        this.warn("needs better test!");
      },
      testReleaseCapture: function testReleaseCapture() {
        qx.bom.Element.releaseCapture(this._el);
        this.warn("needs better test!");
      },
      testClone: function testClone() {
        var clone = qx.bom.Element.clone(this._el);
        this.assertElement(clone, "Cloning of the element failed!");
        this.assertEquals(clone.id, "el", "Cloning of the element failed! Attribute 'id' was not cloned.");
        this.assertEquals(clone.nodeName.toLowerCase(), "div", "Cloning of the element failed! Different node name.");
      }
    }
  });
  qx.test.bom.Element.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.Event": {},
      "qx.log.Logger": {},
      "qx.bom.client.Event": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "event.mspointer": {
          "className": "qx.bom.client.Event"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
       * Tobias Oberrauch (toberrauch) <tobias.oberrauch@1und1.de>
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Event", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      testSupportsEvent: function testSupportsEvent() {
        var eventsToCheck = ["click", "mousedown", "mousemove", "mouseup", "mouseout"];
        var el;

        for (var i = 0, j = eventsToCheck.length; i < j; i++) {
          el = qx.dom.Element.create("div", {
            name: "vanillebaer"
          }, window);
          qx.bom.Event.addNativeListener(el, eventsToCheck[i], function (e) {
            qx.log.Logger.info("done");
          });
          this.assertTrue(qx.bom.Event.supportsEvent(el, eventsToCheck[i]), "Failed to check support for '" + eventsToCheck[i] + "'");
        }

        var el2 = qx.dom.Element.create("div", {
          name: "schokobaer"
        }, window);
        this.assertFalse(qx.bom.Event.supportsEvent(el2, "click2"));

        if (qx.core.Environment.get("event.mspointer")) {
          var pointerEventsToCheck = window.navigator.msPointerEnabled ? ["MSPointerDown", "MSPointerUp", "MSPointerOut", "MSPointerOver", "MSPointerCancel", "MSPointerMove"] : ["pointerdown", "pointerup", "pointerout", "pointerover", "pointercancel", "pointermove"];

          for (var i = 0, j = pointerEventsToCheck.length; i < j; i++) {
            el = qx.dom.Element.create("div", {
              name: "vanillebaer"
            }, window);
            qx.bom.Event.addNativeListener(el, pointerEventsToCheck[i], function (e) {
              qx.log.Logger.info("done");
            });
            this.assertTrue(qx.bom.Event.supportsEvent(el, pointerEventsToCheck[i]), "Failed to check support for '" + pointerEventsToCheck[i] + "'");
          }
        }
      },
      testSafariMobile: function testSafariMobile() {
        this.require(["html.audio"]);

        var el = qx.dom.Element.create("audio");
        var supportedEvents = ['loadeddata', 'progress', 'timeupdate', 'seeked', 'canplay', 'play', 'playing', 'pause', 'loadedmetadata', 'ended', 'volumechange'];

        for (var i = 0, l = supportedEvents.length; i < l; i++) {
          this.assertTrue(qx.bom.Event.supportsEvent(el, supportedEvents[i]), "Failed to check support for '" + supportedEvents[i] + "'");
        }
      }
    }
  });
  qx.test.bom.Event.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.client.Html": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "html.filereader": {
          "className": "qx.bom.client.Html"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/webworker.js)
   */
  qx.Class.define("qx.test.bom.FileReader", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      hasReader: function hasReader() {
        return qx.core.Environment.get("html.filereader");
      },
      setUp: function setUp() {},
      tearDown: function tearDown() {}
    }
  });
  qx.test.bom.FileReader.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.bom.Font": {},
      "qx.ui.basic.Label": {},
      "qx.bom.client.Browser": {},
      "qx.lang.Object": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
       * Mustafa Sak (msak)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Font", {
    extend: qx.test.ui.LayoutTestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      hasNoIe: function hasNoIe() {
        return qx.core.Environment.get("engine.name") !== "mshtml";
      },
      setUp: function setUp() {
        this.__font__P_209_0 = new qx.bom.Font();
      },
      tearDown: function tearDown() {
        qx.test.bom.Font.prototype.tearDown.base.call(this);

        this.__font__P_209_0.dispose();
      },
      testBold: function testBold() {
        this.__font__P_209_0.setBold(true);

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals("bold", styles.fontWeight, "Wrong style value for 'bold' property!");
      },
      testWeight: function testWeight() {
        this.__font__P_209_0.setWeight("400");

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals("400", styles.fontWeight, "something went wrong settng the 'font weight'");
      },
      testItalic: function testItalic() {
        this.__font__P_209_0.setItalic(true);

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals("italic", styles.fontStyle, "Wrong style value for 'italic' property!");
      },
      testDecorationUnderline: function testDecorationUnderline() {
        this.__font__P_209_0.setDecoration("underline");

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals("underline", styles.textDecoration, "Wrong style value for 'decoration' property!");
      },
      testDecorationLineThrough: function testDecorationLineThrough() {
        this.__font__P_209_0.setDecoration("line-through");

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals("line-through", styles.textDecoration, "Wrong style value for 'decoration' property!");
      },
      testDecorationOverline: function testDecorationOverline() {
        this.__font__P_209_0.setDecoration("overline");

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals("overline", styles.textDecoration, "Wrong style value for 'decoration' property!");
      },
      testFontFamily: function testFontFamily() {
        this.__font__P_209_0.setFamily(["Arial"]);

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals("Arial", styles.fontFamily, "Wrong style value for 'family' property!");
      },
      testFontFamilyMultipleWords: function testFontFamilyMultipleWords() {
        this.__font__P_209_0.setFamily(['Times New Roman']);

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals('"Times New Roman"', styles.fontFamily, "Wrong style value for 'family' property!");
      },
      testLineHeight: function testLineHeight() {
        this.__font__P_209_0.setLineHeight(1.5);

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals(1.5, styles.lineHeight, "Wrong style value for 'lineHeight' property!");
      },
      testSize: function testSize() {
        this.__font__P_209_0.setSize(20);

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals("20px", styles.fontSize, "Wrong style value for 'size' property!");
      },
      testColor: function testColor() {
        this.__font__P_209_0.setColor("red");

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals("red", styles.color, "Wrong style value for 'color' property!");
      },
      testTextShadow: function testTextShadow() {
        this.require(["noIe"]);

        this.__font__P_209_0.setTextShadow("red 1px 1px 3px, green -1px -1px 3px, white -1px 1px 3px, white 1px -1px 3px");

        var styles = this.__font__P_209_0.getStyles();

        this.assertEquals("red 1px 1px 3px, green -1px -1px 3px, white -1px 1px 3px, white 1px -1px 3px", styles.textShadow, "Wrong style value for 'textShadow' property!");
      },
      testColorAtWidget: function testColorAtWidget() {
        this.__font__P_209_0.setColor("#ff0000");

        var label = new qx.ui.basic.Label("myLabel");
        label.setFont(this.__font__P_209_0);
        this.getRoot().add(label);
        this.flush();
        var useRgbValue = true;

        if (qx.core.Environment.get("browser.name") == "ie" && qx.core.Environment.get("browser.documentmode") < 9) {
          useRgbValue = false;
        }

        var checkValue = useRgbValue ? "rgb(26, 26, 26)" : "#1a1a1a";
        var color = label.getContentElement().getDomElement().style["color"]; // the current implementation has a higher priority for the color which is
        // set using the color theme. So this default color should show up and not
        // the defined color of the font.

        this.assertEquals(checkValue, color, "Wrong style applied for 'color' property!");
        label.destroy();
      },
      testGetStyles: function testGetStyles() {
        var styles = this.__font__P_209_0.getStyles(); // we expect a map with only 'fontFamily' set, otherwise the null values
        // which are returned are overwriting styles. Only return styles which are set.


        var keys = Object.keys(styles);
        this.assertMap(styles, "Method 'getStyles' should return a map!");
        this.assertEquals(8, qx.lang.Object.getLength(styles), "Map should contain 8 key!");
        this.assertNotUndefined(styles.fontFamily, "Key 'fontFamily' has to be present!");
        this.assertNotUndefined(styles.fontStyle, "Key 'fontStyle' has to be present!");
        this.assertNotUndefined(styles.fontWeight, "Key 'fontWeight' has to be present!");
        this.assertNotUndefined(styles.fontSize, "Key 'fontSize' has to be present!");
        this.assertNotUndefined(styles.lineHeight, "Key 'lineHeight' has to be present!");
        this.assertNotUndefined(styles.textDecoration, "Key 'textDecoration' has to be present!");
        this.assertNotUndefined(styles.color, "Key 'color' has to be present!");
        this.assertNotUndefined(styles.textShadow, "Key 'textShadow' has to be present!");
      },
      testGetSomeStyles: function testGetSomeStyles() {
        this.__font__P_209_0.setBold(true);

        this.__font__P_209_0.setItalic(true);

        this.__font__P_209_0.setColor("#3f3f3f");

        this.__font__P_209_0.setDecoration("underline");

        var styles = this.__font__P_209_0.getStyles();

        var keys = Object.keys(styles);
        this.assertMap(styles, "Method 'getStyles' should return a map!");
        this.assertEquals("fontFamily", keys[0], "Key 'fontFamily' has to be present!");
        this.assertEquals("", styles.fontFamily, "'fontFamily' has to have the value ''!");
        this.assertEquals("italic", styles.fontStyle, "Wrong value for 'fontStyle'!");
        this.assertEquals("bold", styles.fontWeight, "Wrong value for 'fontWeight'!");
        this.assertEquals("#3f3f3f", styles.color, "Wrong value for 'color'!");
        this.assertEquals("underline", styles.textDecoration, "Wrong value for 'textDecoration'!");
      },
      testFromConfig: function testFromConfig() {
        var config = {
          bold: true,
          italic: false,
          decoration: "underline",
          lineHeight: 1.2,
          size: 20,
          family: ["Arial"],
          color: "red"
        };
        var font = qx.bom.Font.fromConfig(config);
        var expected = {
          fontWeight: "bold",
          fontStyle: "normal",
          textDecoration: "underline",
          lineHeight: 1.2,
          fontSize: "20px",
          fontFamily: "Arial",
          color: "red"
        };
        var found = font.getStyles();
        this.assertEquals(expected.fontWeight, found.fontWeight, "Wrong value for 'fontWeight'");
        this.assertEquals(expected.fontStyle, found.fontStyle, "Wrong value for 'fontStyle'");
        this.assertEquals(expected.fontSize, found.fontSize, "Wrong value for 'fontSize'");
        this.assertEquals(expected.lineHeight, found.lineHeight, "Wrong value for 'lineHeight'");
        this.assertEquals(expected.textDecoration, found.textDecoration, "Wrong value for 'textDecoration'");
        this.assertEquals(expected.fontFamily, found.fontFamily, "Wrong value for 'fontFamily'");
        this.assertEquals(expected.textColor, found.textColor, "Wrong value for 'textColor'");
        font.dispose();
      },
      testFromString: function testFromString() {
        var config = "bold italic underline 20px Arial";
        var font = qx.bom.Font.fromString(config);
        var expected = {
          fontWeight: "bold",
          fontStyle: "italic",
          textDecoration: "underline",
          fontSize: "20px",
          fontFamily: "Arial"
        };
        var found = font.getStyles();
        this.assertEquals(expected.fontWeight, found.fontWeight, "Wrong value for 'fontWeight'");
        this.assertEquals(expected.fontStyle, found.fontStyle, "Wrong value for 'fontStyle'");
        this.assertEquals(expected.fontSize, found.fontSize, "Wrong value for 'fontSize'");
        this.assertEquals(expected.textDecoration, found.textDecoration, "Wrong value for 'textDecoration'");
        this.assertEquals(expected.fontFamily, found.fontFamily, "Wrong value for 'fontFamily'");
        font.dispose();
      }
    }
  });
  qx.test.bom.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.client.Html": {},
      "qx.bom.GeoLocation": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "html.geolocation": {
          "className": "qx.bom.client.Html"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.GeoLocation", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock, qx.dev.unit.MRequirements],
    members: {
      _geo: null,
      _position: null,
      hasGeolocation: function hasGeolocation() {
        return qx.core.Environment.get("html.geolocation");
      },
      setUp: function setUp() {
        this._position = {
          timestamp: new Date().getTime(),
          coords: {
            latitude: 1,
            longitude: 2,
            altitude: 3,
            accuracy: 4,
            altitudeAccuracy: 5,
            heading: 6,
            speed: 7
          }
        };

        this.require(["geolocation"]);

        this._geo = qx.bom.GeoLocation.getInstance();
      },
      tearDown: function tearDown() {
        qx.bom.GeoLocation.$$instance = undefined;

        this._geo.dispose();

        this._geo = null;
        this._position = null;
      },
      testGetCurrentPosition: function testGetCurrentPosition() {
        var that = this; //test the position event

        var getCurrentPositionStub = this.stub(this._geo._geolocation, "getCurrentPosition", function (succ, err, config) {
          succ(that._position);
        });
        this.assertEventFired(this._geo, "position", function () {
          that._geo.getCurrentPosition(false, 1000, 1000);

          that.assert(getCurrentPositionStub.called);
        }, function (e) {
          that.assertEquals(that._position.timestamp, e.getTimestamp());
          that.assertEquals(that._position.coords.latitude, e.getLatitude());
          that.assertEquals(that._position.coords.longitude, e.getLongitude());
          that.assertEquals(that._position.coords.altitude, e.getAltitude());
          that.assertEquals(that._position.coords.accuracy, e.getAccuracy());
          that.assertEquals(that._position.coords.altitudeAccuracy, e.getAltitudeAccuracy());
          that.assertEquals(that._position.coords.heading, e.getHeading());
          that.assertEquals(that._position.coords.speed, e.getSpeed());
        });
        getCurrentPositionStub.restore(); //test the error event

        var getCurrentPositionStub = this.stub(this._geo._geolocation, "getCurrentPosition", function (succ, err, config) {
          err({
            code: 1,
            message: "Error"
          });
        });
        this.assertEventFired(this._geo, "error", function () {
          that._geo.getCurrentPosition(false, 1000, 1000);

          that.assert(getCurrentPositionStub.called);
        }, function (e) {
          that.assertEquals(1, e.getData().code);
          that.assertEquals("Error", e.getData().message);
        });
        getCurrentPositionStub.restore();
      },
      testWatchPosition: function testWatchPosition() {
        var that = this;
        var watchStub = this.stub(this._geo._geolocation, "watchPosition", function (succ, err, config) {
          succ(that._position);
          return 200;
        });
        var clearWatchStub = this.stub(this._geo._geolocation, "clearWatch");
        this.assertEventFired(this._geo, "position", function () {
          that._geo.startWatchPosition(false, 1000, 1000);

          that.assert(watchStub.called);
          that.assertEquals(200, that._geo._watchId);
        }, function (e) {
          that.assertEquals(that._position.timestamp, e.getTimestamp());
          that.assertEquals(that._position.coords.latitude, e.getLatitude());
          that.assertEquals(that._position.coords.longitude, e.getLongitude());
          that.assertEquals(that._position.coords.altitude, e.getAltitude());
          that.assertEquals(that._position.coords.accuracy, e.getAccuracy());
          that.assertEquals(that._position.coords.altitudeAccuracy, e.getAltitudeAccuracy());
          that.assertEquals(that._position.coords.heading, e.getHeading());
          that.assertEquals(that._position.coords.speed, e.getSpeed());
        });

        this._geo.stopWatchPosition();

        this.assert(clearWatchStub.called);
        that.assertNull(that._geo._watchId);
        watchStub.restore();
        clearWatchStub.restore();
      }
    }
  });
  qx.test.bom.GeoLocation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.bom.History": {},
      "qx.bom.client.Browser": {},
      "qx.bom.HashHistory": {},
      "qx.bom.IframeHistory": {},
      "qx.bom.client.Event": {},
      "qx.bom.NativeHistory": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        },
        "event.hashchange": {
          "className": "qx.bom.client.Event"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
       * Mustafa Sak (msak)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.History", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      __history__P_210_0: null,
      hasNoIe: function hasNoIe() {
        return qx.core.Environment.get("engine.name") !== "mshtml";
      },
      setUp: function setUp() {
        this.__history__P_210_0 = qx.bom.History.getInstance();
      },
      testInstance: function testInstance() {
        var runsInIframe = !(window == window.top);

        if (!this.$$instance) {
          // in iframe + IE9
          if (runsInIframe && qx.core.Environment.get("browser.documentmode") == 9) {
            this.assertInstance(this.__history__P_210_0, qx.bom.HashHistory);
          } // in iframe + IE<9
          else if (runsInIframe && qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9) {
              this.assertInstance(this.__history__P_210_0, qx.bom.IframeHistory);
            } // browser with hashChange event
            else if (qx.core.Environment.get("event.hashchange")) {
                this.assertInstance(this.__history__P_210_0, qx.bom.NativeHistory);
              } // IE without hashChange event
              else if (qx.core.Environment.get("engine.name") == "mshtml") {
                  this.assertInstance(this.__history__P_210_0, qx.bom.IframeHistory);
                }
        }
      },
      testAddState: function testAddState() {
        this.__history__P_210_0.addToHistory("foo", "Title Foo");

        var self = this;
        window.setTimeout(function () {
          self.resume(function () {
            this.__checkState__P_210_1();
          }, self);
        }, 200);
        this.wait();
      },
      testNavigateBack: function testNavigateBack() {
        this.__history__P_210_0.addToHistory("foo", "Title Foo");

        var self = this;
        window.setTimeout(function () {
          self.resume(function () {
            this.__checkFooAndSetBar__P_210_2();
          }, self);
        }, 200);
        this.wait();
      },
      __checkFooAndSetBar__P_210_2: function __checkFooAndSetBar__P_210_2() {
        var self = this;
        this.assertEquals("foo", this.__history__P_210_0._readState(), "check1");

        this.__history__P_210_0.addToHistory("bar", "Title Bar");

        window.setTimeout(function () {
          self.resume(function () {
            this.__checkBarAndGoBack__P_210_3();
          }, self);
        }, 200);
        this.wait();
      },
      __checkBarAndGoBack__P_210_3: function __checkBarAndGoBack__P_210_3() {
        var self = this;
        this.assertEquals("bar", this.__history__P_210_0._readState(), "check2");
        history.back();
        window.setTimeout(function () {
          self.resume(function () {
            this.__checkState__P_210_1();
          }, self);
        }, 200);
        this.wait();
      },
      __checkState__P_210_1: function __checkState__P_210_1() {
        this.assertEquals("foo", this.__history__P_210_0._readState(), "check3");
        this.assertEquals("Title Foo", this.__history__P_210_0.getTitle());
      },
      testNavigateBackAfterSetState: function testNavigateBackAfterSetState() {
        this.__history__P_210_0.setState("affe");

        var self = this;
        window.setTimeout(function () {
          self.resume(function () {
            this.__setState_checkAffeAndSetFoo__P_210_4();
          }, self);
        }, 200);
        this.wait();
      },
      __setState_checkAffeAndSetFoo__P_210_4: function __setState_checkAffeAndSetFoo__P_210_4() {
        var self = this;
        this.assertEquals("affe", this.__history__P_210_0._readState(), "check0");

        this.__history__P_210_0.setState("foo");

        window.setTimeout(function () {
          self.resume(function () {
            this.__setState_checkFooAndSetBar__P_210_5();
          }, self);
        }, 200);
        this.wait();
      },
      __setState_checkFooAndSetBar__P_210_5: function __setState_checkFooAndSetBar__P_210_5() {
        var self = this;
        this.assertEquals("foo", this.__history__P_210_0._readState(), "check1");

        this.__history__P_210_0.setState("bar");

        window.setTimeout(function () {
          self.resume(function () {
            this.__setState_checkBarAndGoBack__P_210_6();
          }, self);
        }, 300);
        this.wait();
      },
      __setState_checkBarAndGoBack__P_210_6: function __setState_checkBarAndGoBack__P_210_6() {
        var self = this;
        this.assertEquals("bar", this.__history__P_210_0._readState(), "check2");
        history.back();
        window.setTimeout(function () {
          self.resume(function () {
            this.assertEquals("foo", this.__history__P_210_0._readState(), "check3");
          }, self);
        }, 200);
        this.wait();
      },
      testRequestEvent: function testRequestEvent() {
        // "request" event just will be fired, if a user goes back or forward in
        // the history
        var self = this;

        this.__history__P_210_0.addListenerOnce("request", function () {
          self.resume(function () {
            // "request" event has been fired
            this.assertTrue(true);
          }, self);
        }, this);

        this.__history__P_210_0.setState("bar");

        history.back();
        this.wait();
      },
      testRequestEventAddHistory: function testRequestEventAddHistory() {
        this.__history__P_210_0.addListenerOnce("request", function (ev) {
          this.resume(function () {
            this.assertEquals("baz", ev.getData());
          }, this);
        }, this);

        var self = this;
        window.setTimeout(function () {
          self.__history__P_210_0.addToHistory("baz");
        }, 250);
        this.wait(500);
      }
    }
  });
  qx.test.bom.History.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.IdleCallback": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "client.idle": {}
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 GONICUS GmbH, Germany, http://www.gonicus.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Cajus Pollmeier (cajus)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.IdleCallback", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock, qx.dev.unit.MRequirements],
    members: {
      tearDown: function tearDown() {
        this.getSandbox().restore();
      },
      "test: emulated requestIdleCallback": function testEmulatedRequestIdleCallback() {
        var setting = this.stub(qx.core.Environment, "get").withArgs("client.idle");
        setting.returns(false);
        var clb = this.spy();
        qx.bom.IdleCallback.request(clb);
        this.getSandbox().restore();
        this.wait(500, function () {
          this.assertCalledOnce(clb);
          this.assertFalse(clb.args[0][0].didTimeout);
          this.assertFunction(clb.args[0][0].timeRemaining);
          this.assertNumber(clb.args[0][0].timeRemaining());
          this.assertNumber(clb.args[0][0].timeRemaining(), 0);
        }, this);
      },
      "test: emulated cancelIdleCallback": function testEmulatedCancelIdleCallback() {
        var setting = this.stub(qx.core.Environment, "get").withArgs("client.idle");
        setting.returns(false);
        var clb = this.spy();
        var request = qx.bom.IdleCallback.request(clb);
        qx.bom.IdleCallback.cancel(request);
        this.getSandbox().restore();
        this.wait(500, function () {
          this.assertNotCalled(clb);
        }, this);
      },
      "test: native requestIdleCallback": function testNativeRequestIdleCallback() {
        if (!qx.core.Environment.get("client.idle")) {
          this.skip();
        }

        var clb = this.spy();
        qx.bom.IdleCallback.request(clb);
        this.wait(500, function () {
          this.assertCalledOnce(clb);
          this.assertFalse(clb.args[0][0].didTimeout);
          this.assertFunction(clb.args[0][0].timeRemaining);
          this.assertNumber(clb.args[0][0].timeRemaining());
        }, this);
      },
      "test: native cancelIdleCallback": function testNativeCancelIdleCallback() {
        if (!qx.core.Environment.get("client.idle")) {
          this.skip();
        }

        var clb = this.spy();
        var request = qx.bom.IdleCallback.request(clb);
        qx.bom.IdleCallback.cancel(request);
        this.wait(500, function () {
          this.assertNotCalled(clb);
        }, this);
      }
    }
  });
  qx.test.bom.IdleCallback.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.Iframe": {},
      "qx.lang.Object": {},
      "qx.bom.client.Engine": {},
      "qx.bom.element.Attribute": {},
      "qx.dom.Element": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Iframe", {
    extend: qx.dev.unit.TestCase,
    members: {
      __iframe__P_211_0: null,
      tearDown: function tearDown() {
        this.__iframe__P_211_0 = null;
      },
      testCreate: function testCreate() {
        this.__iframe__P_211_0 = qx.bom.Iframe.create();

        this.__testAttributes__P_211_1(qx.bom.Iframe.DEFAULT_ATTRIBUTES);
      },
      testCreateWithAttributes: function testCreateWithAttributes() {
        var attributes = qx.lang.Object.clone(qx.bom.Iframe.DEFAULT_ATTRIBUTES);
        attributes.allowTransparency = false;
        this.__iframe__P_211_0 = qx.bom.Iframe.create(attributes);

        this.__testAttributes__P_211_1(attributes);
      },
      __testAttributes__P_211_1: function __testAttributes__P_211_1(attributes) {
        // do not test 'onload' on IE, this returns always 'undefined'
        // http://tobielangel.com/2007/1/11/attribute-nightmare-in-ie/
        if (qx.core.Environment.get("engine.name") == "mshtml") {
          delete attributes["onload"];
        }

        for (var key in attributes) {
          this.assertEquals(attributes[key], qx.bom.element.Attribute.get(this.__iframe__P_211_0, key), "Wrong value on attribute '" + key + "'");
        }
      },
      testGetWindow: function testGetWindow() {
        this.__iframe__P_211_0 = qx.bom.Iframe.create();
        qx.dom.Element.insertBegin(this.__iframe__P_211_0, document.body);
        this.assertNotNull(qx.bom.Iframe.getWindow(this.__iframe__P_211_0));
        qx.dom.Element.remove(this.__iframe__P_211_0);
      }
    }
  });
  qx.test.bom.Iframe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.lang.Object": {},
      "qx.bom.client.Css": {},
      "qx.bom.client.Html": {},
      "qx.bom.client.OperatingSystem": {},
      "qx.bom.Label": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.textoverflow": {
          "className": "qx.bom.client.Css"
        },
        "html.xul": {
          "className": "qx.bom.client.Html"
        },
        "os.name": {
          "className": "qx.bom.client.OperatingSystem"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Label", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.__boldStyle__P_212_0 = {
          fontWeight: "bold"
        };
        this.__italicStyle__P_212_1 = {
          fontStyle: "italic"
        };
        this.__boldItalicStyle__P_212_2 = {
          fontWeight: "bold",
          fontStyle: "italic"
        };
        this.__familyStyle__P_212_3 = {
          fontFamily: ["Verdana"]
        };
        this.__fontSizeStyle__P_212_4 = {
          fontSize: "20px"
        };
        this.__paddingStyle__P_212_5 = {
          padding: "10px"
        };
        this.__marginStyle__P_212_6 = {
          margin: "10px"
        };
        this.__allTogetherStyle__P_212_7 = {};
        qx.lang.Object.mergeWith(this.__allTogetherStyle__P_212_7, this.__boldStyle__P_212_0);
        qx.lang.Object.mergeWith(this.__allTogetherStyle__P_212_7, this.__italicStyle__P_212_1);
        qx.lang.Object.mergeWith(this.__allTogetherStyle__P_212_7, this.__boldItalicStyle__P_212_2);
        qx.lang.Object.mergeWith(this.__allTogetherStyle__P_212_7, this.__familyStyle__P_212_3);
        qx.lang.Object.mergeWith(this.__allTogetherStyle__P_212_7, this.__fontSizeStyle__P_212_4);
        qx.lang.Object.mergeWith(this.__allTogetherStyle__P_212_7, this.__paddingStyle__P_212_5);
        qx.lang.Object.mergeWith(this.__allTogetherStyle__P_212_7, this.__marginStyle__P_212_6);
      },
      tearDown: function tearDown() {
        this.__boldStyle__P_212_0 = null;
        this.__italicStyle__P_212_1 = null;
        this.__familyStyle__P_212_3 = null;
        this.__fontSizeStyle__P_212_4 = null;
        this.__paddingStyle__P_212_5 = null;
        this.__marginStyle__P_212_6 = null;
        this.__allTogetherStyle__P_212_7 = null;
      },
      // test only XUL labels under windows to get comparable results
      // to ensure the change of bug #5011 does not break anything
      testMeasureSizeTextNormal: function testMeasureSizeTextNormal() {
        if (!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul") && qx.core.Environment.get("os.name") == "win") {
          var text = "vanillebaer";
          var size = null;
          size = qx.bom.Label.getTextSize(text);
          this.assertEquals(53, size.width);
          this.assertEquals(14, size.height);
          size = qx.bom.Label.getTextSize(text, this.__fontSizeStyle__P_212_4);
          this.assertEquals(94, size.width);
          this.assertEquals(24, size.height);
          size = qx.bom.Label.getTextSize(text, this.__familyStyle__P_212_3);
          this.assertEquals(64, size.width);
          this.assertEquals(13, size.height);
          size = qx.bom.Label.getTextSize(text, this.__paddingStyle__P_212_5);
          this.assertEquals(53, size.width);
          this.assertEquals(14, size.height);
          size = qx.bom.Label.getTextSize(text, this.__marginStyle__P_212_6);
          this.assertEquals(53, size.width);
          this.assertEquals(14, size.height);
          size = qx.bom.Label.getTextSize(text, this.__allTogetherStyle__P_212_7);
          this.assertEquals(125, size.width);
          this.assertEquals(25, size.height);
        } else {
          this.skip();
        }
      },
      testMeasureSizeTextBold: function testMeasureSizeTextBold() {
        if (!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul") && qx.core.Environment.get("os.name") == "win") {
          var text = "vanillebaer";
          var size = null;
          size = qx.bom.Label.getTextSize(text, this.__boldStyle__P_212_0);
          this.assertEquals(61, size.width);
          this.assertEquals(14, size.height);
        } else {
          this.assertTrue(true);
        }
      },
      testMeasureSizeTextItalic: function testMeasureSizeTextItalic() {
        if (!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul") && qx.core.Environment.get("os.name") == "win") {
          var text = "vanillebaer";
          var size = null;
          size = qx.bom.Label.getTextSize(text, this.__italicStyle__P_212_1);
          this.assertEquals(56, size.width);
          this.assertEquals(14, size.height);
        } else {
          this.assertTrue(true);
        }
      },
      testMeasureSizeTextBoldItalic: function testMeasureSizeTextBoldItalic() {
        if (!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul") && qx.core.Environment.get("os.name") == "win") {
          var text = "vanillebaer";
          var size = null;
          size = qx.bom.Label.getTextSize(text, this.__boldItalicStyle__P_212_2);
          this.assertEquals(64, size.width);
          this.assertEquals(13, size.height);
        } else {
          this.assertTrue(true);
        }
      },
      testMeasureSizeTextFontSize: function testMeasureSizeTextFontSize() {
        if (!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul") && qx.core.Environment.get("os.name") == "win") {
          var text = "vanillebaer";
          var size = null;
          size = qx.bom.Label.getTextSize(text, this.__fontSize__P_212_8);
          this.assertEquals(53, size.width);
          this.assertEquals(14, size.height);
        } else {
          this.assertTrue(true);
        }
      },
      testMeasureSizeTextFontFamily: function testMeasureSizeTextFontFamily() {
        if (!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul") && qx.core.Environment.get("os.name") == "win") {
          var text = "vanillebaer";
          var size = null;
          size = qx.bom.Label.getTextSize(text, this.__familyStyle__P_212_3);
          this.assertEquals(64, size.width);
          this.assertEquals(13, size.height);
        } else {
          this.assertTrue(true);
        }
      },
      testMeasureSizeTextPadding: function testMeasureSizeTextPadding() {
        if (!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul") && qx.core.Environment.get("os.name") == "win") {
          var text = "vanillebaer";
          var size = null;
          size = qx.bom.Label.getTextSize(text, this.__paddingStyle__P_212_5);
          this.assertEquals(53, size.width);
          this.assertEquals(14, size.height);
        } else {
          this.assertTrue(true);
        }
      },
      testMeasureSizeTextMargin: function testMeasureSizeTextMargin() {
        if (!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul") && qx.core.Environment.get("os.name") == "win") {
          var text = "vanillebaer";
          var size = null;
          size = qx.bom.Label.getTextSize(text, this.__marginStyle__P_212_6);
          this.assertEquals(53, size.width);
          this.assertEquals(14, size.height);
        } else {
          this.assertTrue(true);
        }
      },
      testMeasureSizeTextAllTogether: function testMeasureSizeTextAllTogether() {
        if (!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul") && qx.core.Environment.get("os.name") == "win") {
          var text = "vanillebaer";
          var size = null;
          size = qx.bom.Label.getTextSize(text, this.__allTogetherStyle__P_212_7);
          this.assertEquals(125, size.width);
          this.assertEquals(25, size.height);
        } else {
          this.assertTrue(true);
        }
      },
      testSanitizer: function testSanitizer() {
        var element = document.createElement("div");
        element.useHtml = true; // function to sanitize string

        qx.bom.Label.setSanitizer(function (html) {
          if (html.indexOf("<script") > -1) {
            return '';
          }

          return html;
        }); // test clean string

        var value = "foo<b></b>";
        qx.bom.Label.setValue(element, value);
        this.assertEquals(qx.bom.Label.getValue(element).toLowerCase(), value); // test dirty string

        value = "foo<script></script>";
        qx.bom.Label.setValue(element, value);
        this.assertEquals(qx.bom.Label.getValue(element), ''); // reset function to sanitize string

        qx.bom.Label.setSanitizer(null);
      }
    }
  });
  qx.test.bom.Label.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.element.Location": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.quirksmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Location", {
    extend: qx.dev.unit.TestCase,
    members: {
      __el__P_213_0: null,
      __bodyStyles__P_213_1: null,
      __marginTop__P_213_2: null,
      __marginLeft__P_213_3: null,
      __left__P_213_4: null,
      __top__P_213_5: null,
      __position__P_213_6: null,
      __border__P_213_7: null,
      __padding__P_213_8: null,
      setUp: function setUp() {
        this.__el__P_213_0 = qx.dom.Element.create("div", {
          "id": "testRoot"
        });
        document.body.appendChild(this.__el__P_213_0);
        this.__bodyStyles__P_213_1 = document.body.style;
        this.__marginTop__P_213_2 = this.__bodyStyles__P_213_1.marginTop;
        this.__marginLeft__P_213_3 = this.__bodyStyles__P_213_1.marginLeft;
        this.__left__P_213_4 = this.__bodyStyles__P_213_1.left;
        this.__top__P_213_5 = this.__bodyStyles__P_213_1.top;
        this.__position__P_213_6 = this.__bodyStyles__P_213_1.position;
        this.__border__P_213_7 = this.__bodyStyles__P_213_1.border;
        this.__padding__P_213_8 = this.__bodyStyles__P_213_1.padding; // set up the defaults

        this.__bodyStyles__P_213_1.marginLeft = "0px";
        this.__bodyStyles__P_213_1.marginTop = "0px";
        this.__bodyStyles__P_213_1.left = "0px";
        this.__bodyStyles__P_213_1.top = "0px";
        this.__bodyStyles__P_213_1.position = "static";
        this.__bodyStyles__P_213_1.padding = "0px";
      },
      tearDown: function tearDown() {
        this.__bodyStyles__P_213_1.marginTop = this.__marginTop__P_213_2;
        this.__bodyStyles__P_213_1.marginLeft = this.__marginLeft__P_213_3;
        this.__bodyStyles__P_213_1.top = this.__top__P_213_5;
        this.__bodyStyles__P_213_1.left = this.__left__P_213_4;
        this.__bodyStyles__P_213_1.position = this.__position__P_213_6;
        this.__bodyStyles__P_213_1.border = this.__border__P_213_7;
        this.__bodyStyles__P_213_1.padding = this.__padding__P_213_8;
        document.body.removeChild(this.__el__P_213_0);
        this.__el__P_213_0 = null;
      },
      testBodyLocationDefault: function testBodyLocationDefault() {
        // check the defaults
        var pos = qx.bom.element.Location.get(document.body);
        this.assertEquals(0, pos.left);
        this.assertEquals(0, pos.top);
      },
      testBodyLocationMargins: function testBodyLocationMargins() {
        // set the defaults
        this.__bodyStyles__P_213_1.marginLeft = "10px";
        this.__bodyStyles__P_213_1.marginTop = "20px";
        var pos = qx.bom.element.Location.get(document.body);
        this.assertEquals(10, pos.left);
        this.assertEquals(20, pos.top);
      },
      testBodyLocationBorder: function testBodyLocationBorder() {
        this.__bodyStyles__P_213_1.border = "5px solid black";
        var pos = qx.bom.element.Location.get(document.body);
        this.assertEquals(0, pos.left);
        this.assertEquals(0, pos.top);
      },
      testBodyLocationPadding: function testBodyLocationPadding() {
        this.__bodyStyles__P_213_1.padding = "5px";
        var pos = qx.bom.element.Location.get(document.body);
        this.assertEquals(0, pos.left);
        this.assertEquals(0, pos.top);
      },
      testBodyLocationMode: function testBodyLocationMode() {
        this.__bodyStyles__P_213_1.marginLeft = "10px";
        this.__bodyStyles__P_213_1.marginTop = "20px";
        this.__bodyStyles__P_213_1.border = "5px solid black";
        this.__bodyStyles__P_213_1.padding = "30px";
        var pos = qx.bom.element.Location.get(document.body, "margin");
        this.assertEquals(0, pos.left);
        this.assertEquals(0, pos.top);
        var pos = qx.bom.element.Location.get(document.body, "box");
        this.assertEquals(10, pos.left);
        this.assertEquals(20, pos.top);
        var pos = qx.bom.element.Location.get(document.body, "border");
        this.assertEquals(15, pos.left);
        this.assertEquals(25, pos.top);
        var pos = qx.bom.element.Location.get(document.body, "scroll");
        this.assertEquals(15, pos.left);
        this.assertEquals(25, pos.top);
        var pos = qx.bom.element.Location.get(document.body, "padding");
        this.assertEquals(45, pos.left);
        this.assertEquals(55, pos.top);
      },
      testDivStatic: function testDivStatic() {
        this.__el__P_213_0.innerHTML = "<div id=\"div1\" style=\" position: static; margin: 5px; border: 2px solid #000; padding: 3px; width: 200px; height: 200px;\"><div id=\"div2\" style=\"position: static; margin: 5px; border: 2px solid #000; padding: 3px; width: 150px; height: 150px;\"><div id=\"div3\" style=\"position: static; margin: 5px; border: 2px solid #000; padding: 3px; width: 100px; height: 100px;\"></div></div></div>";
        var div1 = document.getElementById("div1");
        var pos = qx.bom.element.Location.get(div1);
        this.assertEquals(5, pos.left, "left1");
        this.assertEquals(5, pos.top, "top1");
        var div2 = document.getElementById("div2");
        var pos = qx.bom.element.Location.get(div2);
        this.assertEquals(15, pos.left, "left2");
        this.assertEquals(15, pos.top, "top2");
        var div3 = document.getElementById("div3");
        var pos = qx.bom.element.Location.get(div3);
        this.assertEquals(25, pos.left, "left3");
        this.assertEquals(25, pos.top, "top3");
      },
      testDivRelative: function testDivRelative() {
        this.__el__P_213_0.innerHTML = "<div id=\"div1\" style=\"position: relative; top: 5px; left: 5px; margin: 5px; border: 2px solid #000; padding: 3px; width: 200px; height: 200px;\"><div id=\"div2\" style=\"position: relative; top: 5px; left: 5px; margin: 5px; border: 2px solid #000; padding: 3px; width: 150px; height: 150px;\"><div id=\"div3\" style=\"position: relative; top: -5px; left: -5px; margin: 5px; border: 2px solid #000; padding: 3px; width: 100px; height: 100px;\"></div></div></div>";
        var div1 = document.getElementById("div1");
        var pos = qx.bom.element.Location.get(div1);
        this.assertEquals(10, pos.left);
        this.assertEquals(10, pos.top);
        var div2 = document.getElementById("div2");
        var pos = qx.bom.element.Location.get(div2);
        this.assertEquals(25, pos.left, "left2");
        this.assertEquals(25, pos.top, "top2");
        var div3 = document.getElementById("div3");
        var pos = qx.bom.element.Location.get(div3);
        this.assertEquals(30, pos.left, "left3");
        this.assertEquals(30, pos.top, "top3");
      },
      testDivAbsolute: function testDivAbsolute() {
        this.__el__P_213_0.innerHTML = "<div id=\"div1\" style=\"position: absolute; top: 200px; left: 10px; margin: 5px; border: 2px solid #000; padding: 3px; width: 200px; height: 200px;\"><div id=\"div2\" style=\"position: absolute; top: -100px; left: -10px; margin: 5px; border: 2px solid #000; padding: 3px; width: 150px; height: 150px;\"><div id=\"div3\" style=\"position: absolute; top: 100px; left: 10px; margin: 5px; border: 2px solid #000; padding: 3px; width: 100px; height: 100px;\"></div></div></div>";
        var div1 = document.getElementById("div1");
        var pos = qx.bom.element.Location.get(div1);
        this.assertEquals(15, pos.left);
        this.assertEquals(205, pos.top);
        var div2 = document.getElementById("div2");
        var pos = qx.bom.element.Location.get(div2);
        this.assertEquals(12, pos.left);
        this.assertEquals(112, pos.top);
        var div3 = document.getElementById("div3");
        var pos = qx.bom.element.Location.get(div3);
        this.assertEquals(29, pos.left);
        this.assertEquals(219, pos.top);
      },
      testDivMixedPositions: function testDivMixedPositions() {
        this.__el__P_213_0.innerHTML = "<div id=\"absolute1\" style=\"position: absolute; top: 300px; left: 400px; margin: 5px; border: 2px solid #000; padding: 3px; width: 100px; height: 100px;\"> <div id=\"relative1\" style=\"position: relative; top: 50px; left: 50px; margin: 5px; border: 2px solid #000; padding: 3px; width: 300px; height: 300px;\">   <div id=\"static1\" style=\"overflow: hidden; position: static; margin: 5px; border: 2px solid #000; padding: 3px; width: 250px; height: 250px;\">     <div id=\"relative2\" style=\"overflow: auto; position: relative; top: 10px; left: 10px; margin: 5px; border: 2px solid #000; padding: 3px; width: 200px; height: 200px;\">       <div id=\"absolute2\" style=\"position: absolute; top: 30px; left: -90px; margin: 5px; border: 2px solid #000; padding: 3px; width: 200px; height: 200px;\">         <div id=\"static2\" style=\"position: static; margin: 10px; border: 2px solid #000; padding: 3px; width: 250px; height: 250px;\">         </div>       </div>     </div>   </div>  </div></div>";
        var absolute1 = document.getElementById("absolute1");
        var pos = qx.bom.element.Location.get(absolute1);
        this.assertEquals(405, pos.left);
        this.assertEquals(305, pos.top);
        var relative1 = document.getElementById("relative1");
        var pos = qx.bom.element.Location.get(relative1);
        this.assertEquals(465, pos.left);
        this.assertEquals(365, pos.top, "top2");
        var static1 = document.getElementById("static1");
        var pos = qx.bom.element.Location.get(static1);
        this.assertEquals(475, pos.left);
        this.assertEquals(375, pos.top, "top3");
        var relative2 = document.getElementById("relative2");
        var pos = qx.bom.element.Location.get(relative2);
        this.assertEquals(495, pos.left);
        this.assertEquals(395, pos.top, "top4");
        var absolute2 = document.getElementById("absolute2");
        var pos = qx.bom.element.Location.get(absolute2);
        this.assertEquals(412, pos.left);
        this.assertEquals(432, pos.top, "top4");
        var static2 = document.getElementById("static2");
        var pos = qx.bom.element.Location.get(static2);
        this.assertEquals(427, pos.left);
        this.assertEquals(447, pos.top, "top5");
      },
      testDivWithBodyMargin: function testDivWithBodyMargin() {
        this.__bodyStyles__P_213_1.marginLeft = "10px";
        this.__bodyStyles__P_213_1.marginTop = "20px";
        this.__el__P_213_0.innerHTML = '<div id="div">affe</div>';
        var div = document.getElementById("div");
        var pos = qx.bom.element.Location.get(div);
        this.assertEquals(10, pos.left);
        this.assertEquals(20, pos.top);
      },
      testDivWithBodyPadding: function testDivWithBodyPadding() {
        this.__bodyStyles__P_213_1.padding = "10px";
        this.__el__P_213_0.innerHTML = '<div id="div"></div>';
        var div = document.getElementById("div");
        var pos = qx.bom.element.Location.get(div);
        this.assertEquals(10, pos.left);
        this.assertEquals(10, pos.top);
      },
      testDivWithBodyBorder: function testDivWithBodyBorder() {
        this.__bodyStyles__P_213_1.border = "10px solid black";
        this.__el__P_213_0.innerHTML = '<div id="div">juhu</div>';
        var div = document.getElementById("div");
        var pos = qx.bom.element.Location.get(div); // IE quirks mode puts the border outside of the body

        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.quirksmode")) {
          this.assertEquals(0, pos.left);
          this.assertEquals(0, pos.top);
        } else {
          this.assertEquals(10, pos.left);
          this.assertEquals(10, pos.top);
        }
      },
      testDivLocationMode: function testDivLocationMode() {
        this.__el__P_213_0.innerHTML = '<div id="div" style="margin: 5px; padding: 10px; border: 3px solid green;"></div>';
        var div = document.getElementById("div");
        var pos = qx.bom.element.Location.get(div, "margin");
        this.assertEquals(0, pos.left);
        this.assertEquals(0, pos.top);
        var pos = qx.bom.element.Location.get(div, "box");
        this.assertEquals(5, pos.left);
        this.assertEquals(5, pos.top);
        var pos = qx.bom.element.Location.get(div, "border");
        this.assertEquals(8, pos.left);
        this.assertEquals(8, pos.top);
        var pos = qx.bom.element.Location.get(div, "scroll");
        this.assertEquals(8, pos.left);
        this.assertEquals(8, pos.top);
        var pos = qx.bom.element.Location.get(div, "padding");
        this.assertEquals(18, pos.left);
        this.assertEquals(18, pos.top);
      },
      testDivInline: function testDivInline() {
        this.__el__P_213_0.innerHTML = "<div style=\"width:100px\"><span id=\"span1\" style=\"margin-left: 10px\"><img src=\"about:blank\" width=\"10px\" height=\"10px\" style=\"border: 0px\"></img></span><span id=\"span2\" style=\"margin-left: 10px\">a</span></div>";
        var span1 = document.getElementById("span1");
        var pos = qx.bom.element.Location.get(span1);
        this.assertEquals(10, pos.left);
        var span2 = document.getElementById("span2");
        var pos = qx.bom.element.Location.get(span2);
        this.assertEquals(30, pos.left);
      },
      testDivFixed: function testDivFixed() {
        this.__el__P_213_0.innerHTML = "<div style=\"position: absolute; left: 0px; top: 0px; width: 20px; height: 2000px;\"></div><div id=\"test\" style=\"position: fixed; width: 300px; height: 600px; top: 50px;\"></div>";
        window.scrollTo(0, 100);
        var pos = qx.bom.element.Location.get(document.getElementById("test"));
        this.assertEquals(150, pos.top);
      }
    }
  });
  qx.test.bom.Location.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.bom.PageVisibility": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.PageVisibility", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock],
    members: {
      setUp: function setUp() {
        this.__visibility__P_214_0 = new qx.bom.PageVisibility();
      },
      testVisibilityState: function testVisibilityState() {
        var possible = ["hidden", "visible", "prerender", "unloaded"];

        var value = this.__visibility__P_214_0.getVisibilityState();

        this.assertInArray(value, possible);
      },
      testHidden: function testHidden() {
        this.assertBoolean(this.__visibility__P_214_0.isHidden());
      },
      testGetInstance: function testGetInstance() {
        this.assertEquals(qx.bom.PageVisibility.getInstance(), qx.bom.PageVisibility.getInstance());
      }
    }
  });
  qx.test.bom.PageVisibility.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.Selector": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Selector", {
    extend: qx.dev.unit.TestCase,
    members: {
      testElementClass: function testElementClass() {
        var Element = qx.dom.Element;
        var elements = [];

        for (var i = 0; i < 250; i++) {
          var el = Element.create("ul", {
            "class": "fromcode",
            "html": "<li>one</li><li>two</li><li>three</li>",
            "id": "setid" + i
          });
          document.body.appendChild(el);
          elements.push(el);
        }

        this.assertEquals(250, qx.bom.Selector.query("ul.fromcode", document.body).length);
        this.assertEquals(750, qx.bom.Selector.query("ul > li").length);
        elements.forEach(function (el) {
          document.body.removeChild(el);
        });
      }
    }
  });
  qx.test.bom.Selector.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.String", {
    extend: qx.dev.unit.TestCase,
    members: {
      testToText_Break: function testToText_Break() {
        this.assertEquals(qx.bom.String.toText("<br>"), "\n");
        this.assertEquals(qx.bom.String.toText("<br />"), "\n");
      },
      testToText_Advanced: function testToText_Advanced() {
        this.assertEquals(qx.bom.String.toText("<div style='padding:5px;'>"), "");
        this.assertEquals(qx.bom.String.toText("<div style='padding:5px;'>foo</div></div>"), "foo");
        this.assertEquals(qx.bom.String.toText("<div style='padding:5px;'> "), " ");
        this.assertEquals(qx.bom.String.toText("<div style='padding:5px;'> foo </div></div>"), " foo ");
      }
    }
  });
  qx.test.bom.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.Stylesheet": {},
      "qx.util.ResourceManager": {},
      "qx.core.AssertionError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
  
  ************************************************************************ */

  /* ************************************************************************
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/style.css)
   */
  qx.Class.define("qx.test.bom.Stylesheet", {
    extend: qx.dev.unit.TestCase,
    members: {
      tearDown: function tearDown() {
        if (this.__sheet__P_215_0) {
          var ownerNode = this.__sheet__P_215_0.ownerNode || this.__sheet__P_215_0.owningNode;

          if (ownerNode && ownerNode.parentNode) {
            ownerNode.parentNode.removeChild(ownerNode);
          } else {
            qx.bom.Stylesheet.removeAllRules(this.__sheet__P_215_0);
          }
        }
      },
      testAddImport: function testAddImport() {
        var sheet = this.__sheet__P_215_0 = qx.bom.Stylesheet.createElement();
        var uri = qx.util.ResourceManager.getInstance().toUri("qx/test/style.css");
        qx.bom.Stylesheet.addImport(sheet, uri);

        if (sheet.cssRules) {
          var rules = sheet.cssRules || sheet.rules;
          this.assertEquals(1, sheet.cssRules.length);
          this.assertNotUndefined(sheet.cssRules[0].href);
        } else if (sheet.cssText) {
          this.assertMatch(sheet.cssText, /@import/);
        }

        qx.bom.Stylesheet.removeImport(sheet, uri);
      },
      testAddRule: function testAddRule() {
        var sheet = this.__sheet__P_215_0 = qx.bom.Stylesheet.createElement();
        qx.bom.Stylesheet.addRule(sheet, "#foo", "color: red;");
        var rules = sheet.cssRules || sheet.rules;
        this.assertEquals(1, rules.length);
        this.assertEquals("#foo", rules[0].selectorText);
        {
          this.assertException(function () {
            qx.bom.Stylesheet.addRule(sheet, "#foo", "{color: red;}");
          }, qx.core.AssertionError);
        }
      },
      testCreateElement: function testCreateElement() {
        var sheet = this.__sheet__P_215_0 = qx.bom.Stylesheet.createElement();
        var rules = sheet.cssRules || sheet.rules;
        this.assertNotUndefined(rules, "Created element is not a stylesheet!");
        this.assertEquals(0, rules.length);
      },
      testCreateElementWithText: function testCreateElementWithText() {
        var cssText = "#foo { color: red; }";
        var sheet = this.__sheet__P_215_0 = qx.bom.Stylesheet.createElement(cssText);
        var rules = sheet.cssRules || sheet.rules;
        this.assertNotUndefined(rules, "Created element is not a stylesheet!");
        this.assertEquals(1, rules.length);
        this.assertEquals("#foo", rules[0].selectorText);
      },
      testIncludeFile: function testIncludeFile() {
        var uri = qx.util.ResourceManager.getInstance().toUri("qx/test/style.css");
        qx.bom.Stylesheet.includeFile(uri);
        var linkElems = document.getElementsByTagName("link");
        var found = false;

        for (var i = 0, l = linkElems.length; i < l; i++) {
          if (linkElems[i].href.match(/test\/style\.css/)) {
            found = true;
            break;
          }
        }

        this.assert(found, "Link element was not added to the document!");
      },
      testRemoveAllImports: function testRemoveAllImports() {
        var sheet = this.__sheet__P_215_0 = qx.bom.Stylesheet.createElement();
        var uri = qx.util.ResourceManager.getInstance().toUri("qx/test/style.css");
        qx.bom.Stylesheet.addImport(sheet, uri);
        qx.bom.Stylesheet.addImport(sheet, uri);
        qx.bom.Stylesheet.removeAllImports(sheet);

        if (sheet.cssRules) {
          var rules = sheet.cssRules || sheet.rules;
          this.assertEquals(0, sheet.cssRules.length);
        } else if (typeof sheet.cssText == "string") {
          this.assertEquals("", sheet.cssText);
        }
      },
      testRemoveAllRules: function testRemoveAllRules() {
        var sheet = this.__sheet__P_215_0 = qx.bom.Stylesheet.createElement();
        qx.bom.Stylesheet.addRule(sheet, "#foo", "color: red;");
        qx.bom.Stylesheet.addRule(sheet, "#bar", "color: blue;");
        var rules = sheet.cssRules || sheet.rules;
        this.assertEquals(2, rules.length);
        qx.bom.Stylesheet.removeAllRules(sheet);
        rules = sheet.cssRules || sheet.rules;
        this.assertEquals(0, rules.length);
      },
      testRemoveImport: function testRemoveImport() {
        var sheet = this.__sheet__P_215_0 = qx.bom.Stylesheet.createElement();
        var uri = qx.util.ResourceManager.getInstance().toUri("qx/test/style.css");
        qx.bom.Stylesheet.addImport(sheet, uri);
        qx.bom.Stylesheet.removeImport(sheet, uri);

        if (sheet.cssRules) {
          var rules = sheet.cssRules || sheet.rules;
          this.assertEquals(0, sheet.cssRules.length);
        } else if (typeof sheet.cssText == "string") {
          this.assertEquals("", sheet.cssText);
        }
      },
      testRemoveRule: function testRemoveRule() {
        var sheet = this.__sheet__P_215_0 = qx.bom.Stylesheet.createElement("#foo { color: red; }");
        qx.bom.Stylesheet.removeRule(sheet, "#foo");
        var rules = sheet.cssRules || sheet.rules;
        this.assertEquals(0, rules.length);
      }
    }
  });
  qx.test.bom.Stylesheet.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.Template": {},
      "qx.bom.element.Attribute": {},
      "qx.bom.element.Style": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Template", {
    extend: qx.dev.unit.TestCase,
    members: {
      __tmpl__P_216_0: null,
      tearDown: function tearDown() {
        if (this.__tmpl__P_216_0) {
          qx.dom.Element.removeChild(this.__tmpl__P_216_0, document.body);
        }
      },

      /**
       * render()
       */
      testReplace: function testReplace() {
        var template = "{{name}} xyz";
        var view = {
          name: "abc"
        };
        var result = qx.bom.Template.render(template, view);
        var expected = "abc xyz";
        this.assertEquals(expected, result);
      },
      testFunc: function testFunc() {
        var template = "{{name}} xyz";
        var view = {
          name: function name() {
            return "abc";
          }
        };
        var result = qx.bom.Template.render(template, view);
        var expected = "abc xyz";
        this.assertEquals(expected, result);
      },
      testList: function testList() {
        var template = "{{#l}}{{.}}{{/l}}";
        var view = {
          l: ["a", "b", "c"]
        };
        var result = qx.bom.Template.render(template, view);
        var expected = "abc";
        this.assertEquals(expected, result);
      },
      conditional: function conditional() {
        var template = "{{#b}}yo{{/b}}";
        var view = {
          b: true
        };
        var result = qx.bom.Template.render(template, view);
        var expected = "yo";
        this.assertEquals(expected, result);
        template = "{{#b}}yo{{/b}}";
        view = {
          b: false
        };
        result = qx.bom.Template.render(template, view);
        expected = "";
        this.assertEquals(expected, result);
      },
      testObject: function testObject() {
        var template = "{{#o}}{{b}}{{a}}{{/o}}";
        var view = {
          o: {
            a: 1,
            b: 2
          }
        };
        var result = qx.bom.Template.render(template, view);
        var expected = "21";
        this.assertEquals(expected, result);
      },
      testWrapper: function testWrapper() {
        var template = "{{#b}}yo{{/b}}";
        var view = {
          b: function b() {
            return function (text, render) {
              return "!" + render(text) + "!";
            };
          }
        };
        var result = qx.bom.Template.render(template, view);
        var expected = "!yo!";
        this.assertEquals(expected, result);
      },
      testInvertedSelection: function testInvertedSelection() {
        var template = "{{^a}}yo{{/a}}";
        var view = {
          a: []
        };
        var result = qx.bom.Template.render(template, view);
        var expected = "yo";
        this.assertEquals(expected, result);
      },
      testEscaping: function testEscaping() {
        var template = "{{a}}";
        var view = {
          a: "<a>"
        };
        var result = qx.bom.Template.render(template, view);
        var expected = "&lt;a&gt;";
        this.assertEquals(expected, result);
        var template = "{{{a}}}";
        var view = {
          a: "<a>"
        };
        var result = qx.bom.Template.render(template, view);
        var expected = "<a>";
        this.assertEquals(expected, result);
      },

      /**
       * renderToNode()
       */
      testRenderToNode: function testRenderToNode() {
        var el = qx.bom.Template.renderToNode("<div>{{a}}</div>", {
          a: 123
        });
        this.assertEquals("DIV", el.tagName);
        this.assertEquals("123", el.innerHTML);
      },
      testRenderToNodePlainText: function testRenderToNodePlainText() {
        var tmpl = "{{a}}.{{b}}";
        var el = qx.bom.Template.renderToNode(tmpl, {
          a: 123,
          b: 234
        });
        this.assertEquals("123.234", el.data);
      },
      testRenderToNodeMixed: function testRenderToNodeMixed() {
        var tmpl = "<div>{{a}}<span>{{b}}</span></div>";
        var el = qx.bom.Template.renderToNode(tmpl, {
          a: 123,
          b: 234
        });
        this.assertEquals("123<span>234</span>", el.innerHTML.toLowerCase());
      },

      /**
       * _createNodeFromTemplate()
       */
      testCreateNodeFromTemplateTextNode: function testCreateNodeFromTemplateTextNode() {
        var tmpl = "{{a}}.{{b}}";

        var el = qx.bom.Template._createNodeFromTemplate(tmpl); // Node.TEXT_NODE === 3 (IE <= 8 doesn't know 'Node')


        this.assertEquals(3, el.nodeType);
      },
      testCreateNodeFromTemplateElementNode: function testCreateNodeFromTemplateElementNode() {
        var tmpl = "<div>{{a}}</div>";

        var el = qx.bom.Template._createNodeFromTemplate(tmpl); // Node.ELEMENT_NODE === 1 (IE <= 8 doesn't know 'Node')


        this.assertEquals(1, el.nodeType);
      },

      /**
       * get()
       */
      testGet: function testGet() {
        // add template
        this.__tmpl__P_216_0 = qx.dom.Element.create("div");
        qx.bom.element.Attribute.set(this.__tmpl__P_216_0, "id", "qx-test-template");
        qx.bom.element.Style.set(this.__tmpl__P_216_0, "display", "none");
        this.__tmpl__P_216_0.innerHTML = "<div>{{a}}</div>";
        qx.dom.Element.insertEnd(this.__tmpl__P_216_0, document.body); // test the get method

        var el = qx.bom.Template.get("qx-test-template", {
          a: 123
        });
        this.assertEquals("DIV", el.tagName);
        this.assertEquals("123", el.innerHTML);
      },
      testPlainText: function testPlainText() {
        // add template
        this.__tmpl__P_216_0 = qx.dom.Element.create("div");
        qx.bom.element.Attribute.set(this.__tmpl__P_216_0, "id", "qx-test-template");
        qx.bom.element.Style.set(this.__tmpl__P_216_0, "display", "none");
        this.__tmpl__P_216_0.innerHTML = "{{a}}.{{b}}";
        qx.dom.Element.insertEnd(this.__tmpl__P_216_0, document.body); // test the get method

        var el = qx.bom.Template.get("qx-test-template", {
          a: 123,
          b: 234
        });
        this.assertEquals("123.234", el.data);
      },
      testGetMixed: function testGetMixed() {
        // add template
        this.__tmpl__P_216_0 = qx.dom.Element.create("div");
        qx.bom.element.Attribute.set(this.__tmpl__P_216_0, "id", "qx-test-template");
        qx.bom.element.Style.set(this.__tmpl__P_216_0, "display", "none");
        this.__tmpl__P_216_0.innerHTML = "<div>{{a}}<span>{{b}}</span></div>";
        qx.dom.Element.insertEnd(this.__tmpl__P_216_0, document.body); // test the get method

        var el = qx.bom.Template.get("qx-test-template", {
          a: 123,
          b: 234
        }); // IE uses uppercase tag names

        this.assertEquals("123<span>234</span>", el.innerHTML.toLowerCase());
      },
      // test a potential exploit https://nodesecurity.io/advisories/62
      testHtmlEscaping: function testHtmlEscaping() {
        var template = "<a href={{foo}}/>";
        var view = {
          foo: 'test.com onload=alert(1)'
        };
        var result = qx.bom.Template.render(template, view);
        var expected = "<a href=test.com onload&#x3D;alert(1)/>";
        this.assertEquals(expected, result);
      }
    }
  });
  qx.test.bom.Template.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.Viewport": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Viewport", {
    extend: qx.dev.unit.TestCase,
    members: {
      testGetScrollLeft: function testGetScrollLeft() {
        this.assertPositiveInteger(qx.bom.Viewport.getScrollLeft());
      },
      testGetScrollTop: function testGetScrollTop() {
        this.assertPositiveInteger(qx.bom.Viewport.getScrollTop());
      }
    }
  });
  qx.test.bom.Viewport.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.util.ResourceManager": {},
      "qx.dev.unit.RequirementError": {},
      "qx.bom.WebWorker": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "engine.version": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/webworker.js)
   */
  qx.Class.define("qx.test.bom.WebWorker", {
    extend: qx.dev.unit.TestCase,
    members: {
      _url: null,
      _worker: null,
      _send: null,

      /*
       * Firefox 8+ throws an exception ("Could not get domain") when trying
       * to create a worker using a source URI that doesn't contain a TLD, e.g.
       * "localhost" or an IP address.
       *
       * http://bugzilla.qooxdoo.org/show_bug.cgi?id=5565
       * https://bugzilla.mozilla.org/show_bug.cgi?id=683280
       */
      _isBuggyGecko: function _isBuggyGecko() {
        return qx.core.Environment.get("engine.name") === "gecko" && parseInt(qx.core.Environment.get("engine.version"), 10) >= 8 && parseInt(qx.core.Environment.get("engine.version"), 10) < 9;
      },
      setUp: function setUp() {
        this._url = qx.util.ResourceManager.getInstance().toUri("qx/test/webworker.js");

        if (this._isBuggyGecko()) {
          throw new qx.dev.unit.RequirementError("foo", "Test skipped due to Firefox bug #683280");
        }

        this._worker = new qx.bom.WebWorker(this._url);

        this._send = function (message, fn) {
          this._worker.addListener("message", function (e) {
            this.assertType(e.getData(), typeof message);
            fn.call(this, message, e);
          }, this);

          this._worker.postMessage(message);
        };
      },
      tearDown: function tearDown() {
        this._worker.dispose();

        this._worker = null;
        this._send = null;
        this._url = null;
      },
      testConstructor: function testConstructor() {
        this.assertInstance(this._worker, qx.bom.WebWorker);
      },
      testMessageEvent: function testMessageEvent() {
        this._send("message", function (mess, e) {
          this.assertIdentical(mess, e.getData());
        });
      },
      testErrorEvent: function testErrorEvent() {
        var message = "error";

        this._worker.addListener("error", function (e) {
          this.assertTrue(/error/.test(e.getData()));
        }, this);

        this._worker.postMessage(message);
      },
      testPostMessageWithNumber: function testPostMessageWithNumber() {
        this._send(1, function (mess, e) {
          this.assertIdentical(mess, e.getData());
        });
      },
      testPostMessageWithBoolean: function testPostMessageWithBoolean() {
        this._send(true, function (mess, e) {
          this.assertIdentical(mess, e.getData());
        });
      },
      testPostMessageWithNull: function testPostMessageWithNull() {
        this._send(null, function (mess, e) {
          this.assertIdentical(mess, e.getData());
        });
      },
      testPostMessageWithObject: function testPostMessageWithObject() {
        //this._send({a:"1", b:2, c:3});
        this._send({
          a: "1",
          b: 2,
          c: true
        }, function (mess, e) {
          this.assertIdentical(mess.a, e.getData().a);
          this.assertIdentical(mess.b, e.getData().b);
          this.assertIdentical(mess.c, e.getData().c);
        });
      },
      testPostMessageWithArray: function testPostMessageWithArray() {
        //this._send(["1", 2, true]);
        this._send(["1", 2, true], function (mess, e) {
          this.assertIdentical(mess[0], e.getData()[0]);
          this.assertIdentical(mess[1], e.getData()[1]);
          this.assertIdentical(mess[2], e.getData()[2]);
        });
      }
    }
  });
  qx.test.bom.WebWorker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.Window", {
    extend: qx.dev.unit.TestCase,
    members: {// Disabling tests for native window because every browser has a popup
      // blocker enabled. As long as we do not have special setup test machines
      // these tests will fail. Adding a try ... catch block won't helper either
      // since we do not want to blur the test results

      /*testOpen : function()
      {
        var win = qx.bom.Window.open("http://qooxdoo.org");
        this.assertFalse(win.closed);
        win.close();
      },
       testClose : function()
      {
        var win = qx.bom.Window.open("http://qooxdoo.org");
        qx.bom.Window.close(win);
        this.assertTrue(qx.bom.Window.isClosed(win));
      },
       testIsClosed : function()
      {
        var win = qx.bom.Window.open("http://qooxdoo.org");
        this.assertFalse(qx.bom.Window.isClosed(win));
        win.close();
         var win2 = qx.bom.Window.open("http://qooxdoo.org");
        win2.close();
        this.assertTrue(qx.bom.Window.isClosed(win2));
      }*/
    }
  });
  qx.test.bom.Window.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.client.Css": {},
      "qx.dev.unit.RequirementError": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.borderimage": {
          "className": "qx.bom.client.Css"
        },
        "css.borderimage.standardsyntax": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.client.Css", {
    extend: qx.dev.unit.TestCase,
    members: {
      testBorderImageSyntax: function testBorderImageSyntax() {
        var styleName = qx.core.Environment.get("css.borderimage");

        if (typeof styleName !== "string") {
          throw new qx.dev.unit.RequirementError("css.borderimage");
        }

        var standardSyntax = qx.core.Environment.get("css.borderimage.standardsyntax");
        this.assertBoolean(standardSyntax, "Browser supports borderImage but syntax type was not detected!");

        if (styleName == "borderImage") {
          this.assertTrue(standardSyntax, "Browser supports unprefixed borderImage but syntax type detected as non-standard!");
        } else {
          this.assertFalse(standardSyntax, "Browser supports prefixed borderImage but syntax type detected as standard!");
        }
      }
    }
  });
  qx.test.bom.client.Css.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.client.Device": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.client.Device", {
    extend: qx.dev.unit.TestCase,
    members: {
      testDetectDeviceType: function testDetectDeviceType() {
        var mobileUserAgentTests = ["Mozilla/5.0 (Linux; U; Android 2.2.1; en-us; Nexus One Build/FRG83) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1", "Mozilla/5.0 (iPod; U; CPU iPhone OS 2_0_2 like Mac OS X; en-us) AppleWebKit/525.18.1 (KHTML, like Gecko) Version/3.1.1 Mobile/5C1 Safari/525.20", "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; ARM; Touch; IEMobile/10.0; <Manufacturer>; <Device> [;<Operator>])", "Mozilla/5.0 (Mobile; Windows Phone 8.1; Android 4.0; ARM; Trident/7.0; Touch; rv:11.0; IEMobile/11.0; NOKIA; Limia 830) like iPhone OS 7_0_3 Mac OS X AppleWebKit/537 (KHTML, like Gecko) Mobile Safari/537"];
        var tabletUserAgentTests = ["Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13", "Mozilla/5.0 (iPad; U; CPU iPhone OS 4_3 like Mac OS X; en_us) AppleWebKit/525.18.1 (KHTML, like Gecko )", "Mozilla/4.0 (compatible; Linux 2.6.10) NetFront/3.3 Kindle/1.0 (screen 600x800)", "Mozilla/5.0 (Linux; U; Android 3.1; en-us; Xoom Build/HMJ37) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13", "Mozilla/5.0 (iPad; U; CPU iPhone OS 3_2 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Mobile/7D11", "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; ARM; Trident/6.0)&lt;/PRE<p><p>&#160;</p>"];
        var desktopUserAgentTests = ["Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/534.51.22 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22", "Mozilla/5.0 (Windows NT 6.2; rv:9.0.1) Gecko/20100101 Firefox/9.0.1", "Microsoft Internet Explorer/1.0 (Windows 95)", "Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.7.5) Gecko/20070321 Netscape/9.0", "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0", "Mozilla/5.0 (compatible: MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0; Touch; .NET4.0E; .NET4.0C; Tablet PC 2.0)", "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; Tablet PC 2.0)"];

        for (var i = 0; i < mobileUserAgentTests.length; i++) {
          this.info("Mobile User Agent Testing:" + mobileUserAgentTests[i]);
          this.assertEquals("mobile", qx.bom.client.Device.detectDeviceType(mobileUserAgentTests[i]), "Expected User Agent string to be detected as a mobile device: " + mobileUserAgentTests[i]);
        }

        for (i = 0; i < tabletUserAgentTests.length; i++) {
          this.info("Tablet User Agent Testing:" + tabletUserAgentTests[i]);
          this.assertEquals("tablet", qx.bom.client.Device.detectDeviceType(tabletUserAgentTests[i]), "Expected User Agent string to be detected as a tablet device: " + tabletUserAgentTests[i]);
        }

        for (i = 0; i < desktopUserAgentTests.length; i++) {
          this.info("Desktop User Agent Testing:" + desktopUserAgentTests[i]);
          this.assertEquals("desktop", qx.bom.client.Device.detectDeviceType(desktopUserAgentTests[i]), "Expected User Agent string to be detected as a desktop device:" + desktopUserAgentTests[i]);
        }
      }
    }
  });
  qx.test.bom.client.Device.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.client.OperatingSystem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
   qooxdoo - the new era of web development
  
   http://qooxdoo.org
  
   Copyright:
   2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
   License:
       MIT: https://opensource.org/licenses/MIT
   See the LICENSE file in the project's top-level directory for details.
  
   Authors:
   * Christopher Zuendorf (czuendorf)
  
   ************************************************************************ */
  qx.Class.define("qx.test.bom.client.OperatingSystem", {
    extend: qx.dev.unit.TestCase,
    members: {
      testUsageOfGetName: function testUsageOfGetName() {
        var osName = qx.bom.client.OperatingSystem.getName();
        this.assertString(osName);
        this.assertNotEquals("", osName);
      },
      testUsageOfGetVersion: function testUsageOfGetVersion() {
        if (qx.bom.client.OperatingSystem.getName() !== "linux") {
          var osVersion = qx.bom.client.OperatingSystem.getVersion();
          this.assertString(osVersion);
          this.assertNotEquals("", osVersion);
        }
      }
    }
  });
  qx.test.bom.client.OperatingSystem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.core.Environment": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /**
   * Test for PDF.js detection.
   *
   * You can enable/disable it via "about:config"
   * and "pdfjs.disabled" (true/false).
   */
  qx.Class.define("qx.test.bom.client.Pdfjs", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      "test: is PDF.js available": function testIsPDFJsAvailable() {
        this.require(["firefox"]);

        qx.core.Environment.getAsync("plugin.pdfjs", function (result) {
          this.resume(function () {
            this.assertTrue(result);
          }, this);
        }, this);
        this.wait();
      }
    }
  });
  qx.test.bom.client.Pdfjs.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.client.CssAnimation": {},
      "qx.dev.unit.RequirementError": {},
      "qx.dom.Element": {},
      "qx.bom.element.Animation": {},
      "qx.bom.element.AnimationJs": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.animation": {
          "className": "qx.bom.client.CssAnimation"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.element.AnimationHandle", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock, qx.dev.unit.MRequirements],
    members: {
      setUp: function setUp() {
        this.__keys__P_217_0 = qx.core.Environment.get("css.animation");

        if (this.__keys__P_217_0 == null) {
          // skip the test
          throw new qx.dev.unit.RequirementError("css.animation");
        }
      },
      "test stop of CSS animation": function testStopOfCSSAnimation() {
        var el = qx.dom.Element.create("div");
        var handle = qx.bom.element.Animation.animate(el, {
          "duration": 100,
          "keyFrames": {
            0: {
              "opacity": 1
            },
            100: {
              "opacity": 0
            }
          },
          "delay": 200
        });
        var spy = this.spy(qx.bom.element.AnimationJs, "stop");
        handle.on("start", spy);
        handle.stop();
        this.wait(500, function () {
          this.assertNotCalled(spy);
        }, this);
      }
    }
  });
  qx.test.bom.element.AnimationHandle.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.element.AnimationJs": {},
      "qx.bom.element.Style": {},
      "qx.bom.client.Browser": {},
      "qx.dev.unit.RequirementError": {},
      "qx.bom.element.Animation": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "browser.name": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.element.AnimationJs", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      __el__P_218_0: null,
      testStop: function testStop() {
        var el = qx.dom.Element.create("div");
        var handle = qx.bom.element.AnimationJs.animate(el, {
          "duration": 100,
          "keyFrames": {
            0: {
              "opacity": 1
            },
            100: {
              "opacity": 0
            }
          },
          "delay": 200
        });
        var spy = this.spy();
        handle.on("start", spy);
        handle.stop();
        this.wait(500, function () {
          this.assertNotCalled(spy);
        }, this);
      },
      setUp: function setUp() {
        this.__el__P_218_0 = qx.dom.Element.create("img");
        qx.bom.element.Style.setStyles(this.__el__P_218_0, {
          width: "200px",
          height: "200px"
        });
        document.body.appendChild(this.__el__P_218_0);
      },
      tearDown: function tearDown() {
        document.body.removeChild(this.__el__P_218_0);
        this.__el__P_218_0 = null;
      },
      "test animate properties which are CSS properties and element attributes": function testAnimatePropertiesWhichAreCSSPropertiesAndElementAttributes() {
        // known to fail in chrome
        if (qx.core.Environment.get("browser.name") == "chrome") {
          throw new qx.dev.unit.RequirementError();
        }

        var handle = qx.bom.element.Animation.animate(this.__el__P_218_0, {
          "duration": 100,
          "keyFrames": {
            0: {
              "width": "200px",
              "height": "200px"
            },
            100: {
              "width": "400px",
              "height": "400px"
            }
          },
          "keep": 100
        });
        this.wait(500, function () {
          this.assertEquals("400px", qx.bom.element.Style.get(this.__el__P_218_0, "width"));
          this.assertEquals("400px", qx.bom.element.Style.get(this.__el__P_218_0, "height"));
        }, this);
      }
    }
  });
  qx.test.bom.element.AnimationJs.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.element.Background": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */

  /* ************************************************************************
  ************************************************************************ */

  /**
   *
   * @asset(qx/static/blank.gif)
   */
  qx.Class.define("qx.test.bom.element.Background", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.__divElement__P_219_0 = document.createElement("div");
        document.body.appendChild(this.__divElement__P_219_0);
        this.__backgroundUrlBase64__P_219_1 = "data:image/gif;base64,R0lGODlhEAFRAPcAAGGCnMDihW+PnomrjFR4lKbFkr3eioeqi2+SkH2hi1F4hmmOjaLFh42xiLjah1B1klBzmNX2hF2Bk5S1k05xmHKUkr7hhHudkWyOlZ2+kXmeiZG0imWKil19oNP0g53BhMzthVJ0mpi8iGaKklZ4nanNhXOZhoqvhll+kXCSmKnKi6bJipW4jVV2m2GHibTXhGuRhmqLm67RiLfZhrvciUBoiV6Fhk1ykFl6nl5+oaTHiHWZjjtkhZS3jHGWi5W5hlJ4jU92hMnrhEVuhZ7Ai7DRi8Lkhm6TiWKElmGAolp7n7nbiFyCjHucmIurmqzOhmaMjJy/ipe5jcjqg0hvjlB2i4WmlqDCjJK3hIKmiFV8h4mqkqTFj4KljkZsjEtyiHCTkoGjlUpwj2yQj2GFj0xziVZ6j5u8kIClhneYl2OJibXWi1h7ll1/mkNqinWXlLLTimaFomeNhWKGkFt9mFiAg4+ziY2vjoeokX6jhmOCpGCClBZEdxhGeBpIeRlHeRZFdzxjjR5LezRdiDJahzBZhhxJeh1Key9YhTNciDJbhytVgy5XhR9MfDlgiyJOfidSgRdFdyFNfSxWhCZRgBdGeCNPfiVRgClUgjdfihtJej5ljj9mjzhgijZeijhfizFahipVgyRPfyhTgS1XhEFnkDphjCVQfzZeiUdrkyBMfTVdiTpijCRQfz5kjjtijD1jjUVqkipUgklulUNokUhtlENpkUBmkEBmj0tvlkJokEdslEZrk0hslERpkURpktT1g9T1hE1xl1V3nExwlk1wl0pulU5xl0xwl1F0mcvshVx9n3SWk8rshLPWhMvthbXYhYuvh1qAi1yBi1t8n1d5nYithYmuhoWnkHabh9b3hZi7h1qBhF2DhomuhWaImLbYhp/DhcTlh2SHkM/wh1+Fh6PGiKPEjn+jjYSoiabKg3eciKzNjZO2i3SToLjYjcDgi2+NpF6DjYSmj4CfmoWknjVfg1l8l8foiTNdgWiOhj5nhxVDdhRDdt7/gxNCdSH5BAAAAAAALAAAAAAQAVEAAAj/AP8JHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8ePIEOKHEmypMmTKFOqXMmypcuXMGPKnEmzps2bOHPq3Mmzp8+fDfsJ7edQKNCjSGUOXcq0qdOnSaNKBfm0qtWrRKdq3RrRKb+vYMOK7Se2LNimXNOqNcgULJ+3cAHBnRt2rt23YZmu3bt16de4kSpV6kOYsOBIkQApXgwIseDHieXyObuUr+WjfvnxaTz4zx8/oEP78fynsGnSqEv3qST5K9bKl2PDHPoXUGc/hgwdEsSb96FDhjSJDq0pt27joEuzxuv6NWzZMbHupK05Up/PuhupkvSoe3dJkhr5/wb+m3cj7apUiRd0SHjpxMzN5q0KPaVzpzapb76uaTd3UZdQQgkkkFBySSuiPAKeettxZ4kop5wiiiUKiheccpHddVdZ+NUXklXy8QOVUkJpZttnhzTyiCiUjBLKIpOQMskki4QyioGnWKKjKK0ECMkooxB4oCXhATeaaYU9VglikUkWn4jPeZiRV2Jp ONl8UbLVoUSv/WUdbiq2AkkokyACiiJoKgIKIowsgkmQA0KCiSwwkiJjjTcmqAp7wQ0nGmqmLalY fHottKWU/zRVV1yNMcnkoITeZ5VCkpJlYiV/aCKIJKdAsggjhAziSSeOOPJJJquoiQiNi8DICCKF EP8iKyGFMDIJJpS0QuR6v/Xq62/GCTeaaoIyV6hAlRr1EH04tfXXW40OVlhqqvUB35XOjcUsViF6 2QeYllBiTxCKoOJIIJtwwsk0HKjhQg2J0FpIIaAQ0o0N5XzhySrxclNHKJBcQiF4BHPnHcHq8Qqc sBgam+ykBz2c1UvOarZZYIR5BpomxRmXG8OrRRIpdYs+2RyIZW0414l+HCKJKFr4I/PMNM+chSOe DKLzIDHXTLM6AB8Y4Sk9BiiggZdcIqGOCoYnnpGqiYytot1qmyxlEKvkLLQYa9xxeYKcJ/Z5fGqi XGtVMsoYpCOTbDG0a8fdtSGbtoIJNyZY4LPMA9z/UMomgZhSqiOsBDINODQD4003q9pI4I+YvNgq qzW+WaCBCA78tHvWmvws3GvThTWVKct3KElbb9bZZ8XtFvZ23e0oyuyas2f2ak7CjTGSgV57ZcnR 8i58xmA+ckkoiAxiCgN7jzBLKr/csokrrqSLSyl20JxFJonUOoksodA5yauxzkorImyyGorluSYo ie1+hKwhZ9LyvqTv86UNOmN2YansSJl5S9f80LrXOQhCRvsRkOB0CT0JwhBHOoxgMvYZAnIsOMI6 krVyxzVpaWxjHAuhn3CTIuPJohCreIUYlOEzKUAAGbXgxS9ooQtd0OIXsdDBzAIQiE4MghDpG5+Z /xQxCFRkIhOdOCIqBpEIRRACFIVg050wUSBdva89GGKSBysIwtB4xjD4cwvXdie8w0BqdBP7iH74 MEDdhO2Ap/DRKOZUJ0bYkRR4auAjGgE11BAwN64LG9l80ydiOWZ1f9RNIHvTG2ABUhCqCNcJVxGI UqDDZxFoQzIokIta7CIVoNwFCmgGhR7+sFbkI2ImHPGKQFAPFoEI3KlQsQomOhGKiMAjrqz4QM5d p4KAXOR4+qRBxKxtdx8c4bDAiLYsaSSAtuEP3RrhoDgKSE5zihEj6IWmRDSRVqSQRcCIxCfjlOc8 4ImdjihUobIN64MFPE+DvEPPBa3njZY4XvJeUf+KXUTAZ2cYRgggIAxk5MIYs5jFCmY2g028IhOn RN8QulEOF3AAClBYgEY1ilEOSENwp8qEJ5bYRO/h6hSP2NPCvibIdNZTEuohpC9PwzpFCrNXH1vm cqb2v2eWSID82Y0qHmEJa2JTfKR41ZkSsQokfsJUEFVEIW5FCfeNDXY6imMCCYQ5q5YzmG8k6oOI lrSjIS1zTXPQJTDBiEQ4Ahep6AEmAVCNFgwUAhQoBhhoJg9XmMITUkVfIbrhjBfs7bBCeEE01ABS VMWrTbjS03rQKVayJu2yrchR7RYmmtbtRjsu/Y49n5abCLbGmRWhjeq+RbehAqhFktMm+XggB2v/ OEMINQPGE9TgQ0K0KWCa3ZFR5xjbGbXKRgZyX8JAS1RrDmiOkZMFnRYBPiriaJ0AwgQpCNGJTcSC AP+sWQaWgQMStMCuEFjCzMyBC1MC0Y6FUMQqHAGEZhz2vv5gAAcCwYpPeCIRoPit0tiZVTliInKh WN+BGZijdrLHdcwtatEuK7QJDUw9UMMdT6f00xP1R0UAGpOrBDsvBWBBb/iVGQP+qojG3ehokEMq +UBBY1y2CWDtW+dw6QgjbaLvx+lzUxXJ6qlCoCIQtJiFFHymjTjkgLzmxcPMgnGDTZhiFUCUESkQ oQhPvIITCajZHophjF7cYAHpYAAwfCYEDbgi/xCOQIVUwwmna0aujnbMMyNkRKP1VXFC34ndjg9M 6AVz9UATCs8DjySXk11EtR6GZD4hIYsylQ9NQ8DCFGQ2hQ+YQAvn4sQCAuAzH7h3Va2anBBhRQhF eHMQq0AFLQfhxFy6KUgEmqP4XgWredWrm978Zq2EbKAByaKtjuBEKsDrswIkIQcdUAIAwuuPBNwi EJloMY3oBCpPBOIWo6QZM44Bw1TYohS44IQPEFezGQABcJ9IlfdSLUR6me/eUIyirfBUoMsO6M6y zbOdZqQ+61qRj4Z4z4ZTayk+YEpTL6MEmRBBiETAGhXlcMbMPqAAVzeVFa4ohS8ewEKayeDacf+O 17xW/mtX28AE1zhBNGZ+BDeYKmeq2rOPWd1qRejDtij2R2J/4IJO4LwQdC6QnCZBCG//whh32Js7 9PBsLszMAb7YhCMGMVUbuYgUoDhyKVLxDJq5kBiz4AUtbsGJTaQLCjPIrbVd8YpO8OuJNG61xQex j3Lk4RrXyIMNtLAzbzpR36yabr1lhaZZ5Xte6LMjjagosPdBsHNQSmNXfmodiHdqERQXFalcEHRv 7CNNFs+EKTZRCl7MIuo1i8XfXuHfWu6M7yYoAX6fsN/+5qyJqNfZKr4QDg+kWAhHcAREfSvkH4E+ Eaa4xS6OAQKfwSMOeqDHzCKAAlrAItuMwHH/ixaBQn6mogg0gwMEiFEL2XMClrBIVykOEIyaRcEW uKC78kfqiSN2IhtB5zMvgAZlcET7QmtPtHJ6d3EwcA3O8IDO8AHWoA9DkCZORCu2clJ7dHkik3kU 0WHfcgiqIApFlgiewErSAA0z8wJlwETmkwjmEnKpkAsV4DPPg39vxgql8gllEA4zYwHRkA1qoAHb sGY0Ywdtx1+m0glM+FRu8AMrmA0F2AlucAQqSDMM4AWf8EOQRSCYwHSZAAu+kAtvsDdOEAf4MDN3 0Aul8ApctwjAdQoShwjQdwtxRTMgAAG5sAu2wAmB8AqmUDiugAu2MAf1RzNRwAu2ID2wFEuB/+AF TzAzQhAN65AN0VACRigzFqABr6CDIcV/TuUIR5CJe+MBJZANNXCAatImo3AJGxg/jdZTEPFTmGII jRAu5DcInRAIVCACNNMAykdrUcRqulhJM8gMPnMMudALsbB2becF2zAz4VAGpWIKrwALnCAG5lAz G/AL6NZ21EM904BbQqcGjsCEnfAJpuBKGlAz4ABngwAKpOA4owB6g8AKpVALEEADPkMOBTAzNEAB qYALjpAIjIAJAkNUrTAKpKAIycYLXVAzx2AMvFAKsGAKSZQJn/AKrBcL40BtMtMFtZAKvkALpVAK t3ALpCYz6fBmgFiN63CFMiMEUACOjhhL1f/TjjN5BLJUBjAQDqQYDi6gfPJ2K674QH9QCZMxFFxi KYDwLZuiT4nwCYHABCspMxoAZ/9VKzLyKl32CnaYCxjgMwOFdrsQC78gD/YldNKgg4NzjZxQCrEg AzWDArvAC2hpC7RACwlghAHgBa9wjv53LptwC2F2hD2UCIjQfNpFCJmwCbwgDN+AX5kkkJzwCYQw CZAgCgSDi9zlXQhQMxVQC77ACQ/FREy1i5xgC7uwVzQTAXuQC7MwkqnACxswM0/AiC9ZKoWjAaRo DjeglzVkQ7ZgBjMDDEDwfnAWUv9nWDMDDR8FUaBwK63wPrC4lJoXFGTBRn9gi6LAkIrQCbD/4AOk eAC3AAuOgGWrAj6LQAqFMAjJFgu5gIw1MwwtgFfIMAvocIjNQAV/eI7pSJhy+QCHKDMrQAwHNZu1 MA7H+W5wJlJG9Akgdwu/oEM0AwSv4AmEMI+5Rn6U9Au50AIZcF9WMAzHkAqbkAmgsAgCwyAmVAhh +AsjUDMX0Au04ApbiHehQpVjZwwqUDMqAAHHUFC5QAAFSgal4Ic62ITruAlUcJX+YAQP0AtUSqW1 EAUzowOLCDimwJyE45s0sw3wOJ2bqQoJp5RQ0pSagSkucwkndGRQUDMyIHuwsIVdFySjcGzh6V3z 6TPlhV4XQDNkgAuw0F+ZgAr9ZwqwcAu+/1ALRFAz9wABQioMzCYzB/A3geBfO3OCgYALv/AANWMH WqeYi4BrxwZ9pTALIQAA5LA3RZADJAABqcAJKioLrige1GQ3iEBJtFALNdMDqVAK2NZidkRxq2AK nBALs7AHPvMN6AUB8zBlsaALfrh/ETqhN2AENGMEBFAM3loMwlB2MoMOsgc4+9d/EgoLVBB3O+QF W1cItvoIggCLzbF5mgGVj0AJk6AInwAEpOgPEpAKugALnUCq/UYJX+iYsPB09Ekz5FUNw/AN1NYO vnCepgBRFrcKnfBlttALM0ozaXBedvWjMhMMD0ALDhVVaDIImcCxqbBQM9MMuPAKqDCdVP80Jozg kLigj9WgfdaXBNUAAb3ACZ0ACvG6HpyCCclTSbtQM+3AC7jACqsgj5PDZWHYq8JAsjMzASRgny0A B1cnsA7VCSQlKueCCyNXcjJzBSHQtiGABDSDAKmAspmaM0WkerCAC7RgoTLzl9lGCpvZCAnXgbJo KCXylJpiCaPACPfIPDSjAnvofZ2gCAeZK3FUZEdmC7MQqDRjAB2wDEqAA/w4MyhApynHePMFC7ow gyB5BjhQDSQwmTOzAny4CazwX/kmX47gCqu7AzVjBt9HuV4XCtvVCZywCxBQDTnwDnszATgQArNQ Co5ACItACXvEGy+zuImAj6ngtLHACQX/uZgHRiagQEn9VAxSRjNrELrlRW0yILZ/9U2q9GW/0AsR STPfMAz6mwY0AwZza7sYa3GcSogkRzMiwAqDgAihUJ2HkJTYOYuH2wea0AiioLSUtJYzwwzsZwuu 8LcImSNyKAu7imRKVjMGAG3LkALbmnbCmqO+lgiZ8G28kAujKzPsoAQ4fA40cwe18AtWpp7kA8My TAA1swCb8AmkOr4NabypcAwkkANOsDfaEAMtkAu28AqJALi7Qk0k2FbRlwraenXfG76ygKfPZwpw RQxj2bnLALoxQDPAqguusHXyEl+osHodiwzVNzPngAN+fAb9uwsoe7qtVoyc8AupEJo0/1MFmUC9 1nsIfoCmhUspEWyLp4AJheBtPsMMxVALHDy5pPDBEEIJIjwIJLxkNFMAOQBtIzozkBusibkmr0II x8oJvjALLNC5HfC5BkAzFTALWbd1ARYjFIcKrJCstSCuMpMAnGAKXDcJCfYp/KpsThwH2nBYBjAM whALroAKiIAJrZBS1HQK2vvF6iXG4GuQ4jQgoYBsnMALyJAMJozCTQDHuzCwBSvLZjIIn+AKtNAL xHAFnUsNy0ANrSwzYGCjc0xrUFRxLXvIuzALyuwP6TC5k2C989oHD7wsldwIl2xkgeAz2CAMwDyq 4We5l1BkvFrCNJMBq9wBB+0PUpALsP/MPVy5TVPpCrZQC7k8M54Lbb08M788xvFoK+MDCvC5Cb9Q C+csMxsQtVPbJjBCh2/VxMMQ1IcVBhBQCwSZmZupII9gN23FCnbY1P7gAGOsmOJEIO3skMmaCxAw z7s8AXDcC/jcPbaC0zHcT8iADbq8y1jtD6N5o3Tsa112zLaQCrNg1g3wCYqgmfIaPxtdFBE8wRU8 wlDqDypA0t/rzIVQqsWWsJ4AC5qLyjNjBS8d0ypADPdMsHidVIWQCOLZq5wrMz/dAYFdAcbwvVLr WzOyTUnNmmb91DSbZeNDy/zUC8cAyDKThphEB7nwC4GwCgrcQA+yVvvUT2a9BKlwCwj//NlUhAnP F5+5ALc0wwW7vAwxvQQ26tpIR8yKsNfH+Ne47cuevNDnY8erRwupUAsOQDMV/dgYLdlpCsH36geC YAmQ4MU+4DN7MAuxcG0aCllzJM3d5QvGUNsykwbQ1gF0PTMg0Mm2oHU/xCY4LZ660AuuadvLwMtm lwu8cAsZ2mJdidSOsAn8TZczkwAzC1jDGNsx3KtrLDP18I8+cw7HsAvgqwihfCApTX5HluIgSbvC igobCj6V9p7IKp8a7g9W0MYGTTNLcN9IfNPxFcO3wAvG8KgzwwVtvAy5PQs+XNjcdMeboAuxQKCL 3MjV+wiQLMnZabhr2jL5ugiO6Qrb/yjmLFynRU0jR60879ynNIPCy/DGvgzhpom787Kjqtua6ovD SmB1MwMHNC2s+cwmoXfj/I2lM7MAfsg9tHImdu4LBLDH/lAAcRAPreozGBDdgeAJNuuFYEjavkoz LODJBKttM0JxXoYLas7mMgMCfvzHYt7DJP5esCLEuKCsYSwzKYADOBznpWkKctbQMLi7IjcAWPjd oXAJktDAgG6v3GkIqqCryvOkNbMCvKALtou7PwYKQjx2xNCw/mAAYB667CDmxhCs6Hl3FWcuOL4L uUAzruvHKkwzEiDIWlfusWKCrIDjqfDfM3MDpqmy8sWjvKDj/gACcZAEehDFPiMOx//QC979zNHM ZZ+wCRheMyyA6VcGROgTKrvYepUqM1ugv8NAAmFQ7aV5u2qy6cWItmOQfkn/ujUs2Jj+UPJrgmd7 A5not5Q7CqIguH9AuIFOyV+BuAmur03Hi4mepbRQraiw9Z6Ax7VQDBqeATj8ujjQBiDZBb3wC36o qUWkmqw58Woosi1w9SsQ+H5od02UmoHACbTACyLvD83A73VnexrLsZc0M2GwDDng8vCwN3eQC7Fw xHj96MjKC0T84rDsQxdogqYQcrzQDjRDA8mQDG7LvzTTfu0l+6hLlat5+RHABiFwXsNw9UN9bfEW +WaLLuzmD3/5rn2e0YBQr/JeCS3/k7Q5G8OccACkGABMUKiEH/1oWwvCYNr+8O3VALtdmwLUFgEj ILDV+gmkMqG+sAuKDBD+/GFIBsEgEoEJx/i65YpVJ1SrUGVyFIgTrVjBEopo+NATKk+dWG0qhUKj QDjDquFYlkNAQpgR2NSiFShTIlCFQCnKFKhUKjAw/TEr1svWJlOZBi319CnQJl1kYBohQIxYMQrH EMJEEasULEeeBiVKNMhTxU0JEgYbgUzYMQjJaMDsMcsrWKVkzX5ixSAhOC+fBoGaNEqUqkN/KvHh 16/fP8iRJU+W7Jgfn0h9NAl6dCkUI56sXAGZIXSbF0edMq3+9IpkrFnCVCQUh6Ma/4lhLXS3wBAh YYQxsXRxghXIuCtOumL12pHwmbBixJBN7wIz2I1SnAKZ+tTpU0VXuGihgGlGO3fWom/9cvAbSYgQ LUjgoJZBqEAVxVKVsjk20SpHYNFllwuEYkYYu3AJxJHVMvnEFIvkASYhZcbZ5cJeapkll2dgGsCr TR5CZamJHHllmgn9AYaMVHbRMBdiloBphVq8ciWpEZkq4wWBgMmCwUEIIQWTSx4RRJM+ImHMMcqa pMyxfi6r5A9DGrGEks8IWaU1WKAAByZgwtHik+9YsUgXXmYpxjeBthgmN93ggw8DI2BqJxZasuOE k1t08YWXXqJIqJ1ZaunlwgsFTf8oADE4cSUQVkwx5ZWn+twgIXNwedSR7hxhBZaLBqBLGGEoMKiF YQAA4b6hjImFk1c68cSTTEaypZcehEKCgll4KWWT7RxxZNIuU/QngBto0aUUXWixJZZUFBVImV9+ XTCTj2h15IgUwaHillJKoeXPXdqx7oFfboFFxKX2ucYDgX6oQSxFCpmEyEcaMUSxJZl08l/ILOMD kD78OMTKSzAhpZBEUHnwFQ6eEMqCaFygNLlYalkhIRrihC8ZkOW854qpgrOFFmf/TOWBk4J5IBZf bNFlZmcPABOKTYozLhBYNsHFjBSBoeJRUzgd9kyTnDNmFqY3FAaCFrZglQYKajn/asHvLLpVRpgg QDAVWoh7RVJWqvBrIyo2eXTnTTgpxQyhMt1UtVnLCKfHLCjduWdcdIEbphkavXYVLbCA1wNvvhhL EVAYWYRISxo5xI8+AOkXYMyhvCwzgxvpbJRFGAGlrJA+KQMNC+6DBpwZZlBGKCOwYcMg2g0CORlm 5krICHRQ4IWXFlGoU6AdbMlObVhgcaVtKISAiYEqduZ5EyAC6HGaQF7h1DsTXVmvvYR26CUVmP/s JReoxWEVm1z2A5aVi2lJ5aSEVCCgFl6GK46VI+5OCBoOQCo12KLVgwLhinQI5QnSYAWDagAD/3ng BDVYzaxoRREzbcIOQgEGNKLx/wNnHO4DciAEIXKCCEZMIhSQaEW+Jpekfj0GcwCzzOYKViVJiIIS mAhdIQhRlkFIpAbZCEfqWOUP+gmkCF24SqlqZ5AKqIBN03JAFdeyA1rgAlhFI5OwzOSFBhjLHxZo wBE4cAQGpEgIDORUgzqBllI0JyEOSIUvdHGLPfUtTRR4A6tAcL9faMo4PSuFzVjlABnY4QnQMGJC SuCC7nhiFYlQhAlBQQhF7IUVWbgPMF4whYQ4wwT7IIsiKmnCEpKOL0doZEI84AxrdKMQiEAhI0gx icdB4hKWkITkKKckfjRGhjP8l+Zs6AdDCEIVlmjFDhdBCkToBJOK0AvhXOCCBv80AAoLuEEs5qCD JAZjBWBABlaeCAE2XIAIw5tKO5KFi3VBxD9lmch33JCFVgpFCNFwg2oispRVUOQpYmgGTOZQrfcR Cxe+qIUwdCcUFtjFWoGowhOsd0RWAaMEaPjCPxNBiFnechGLmAQ0fxjQMvwgn87Aggl4YMJCzJIR KcTlJCbBCET80CzeueY1B1HJQtgSl7IIBSYgQYlLiOIRqhCEIX7JGGEOk5hOMiZm+vAHTRxMEsyk BCR4WFKcxhST9Hzj9HDBrBsk4KIUisIIsAIXgxyDAsKQDgHAgIAR1GIXsbBFR5TCuFlGc6yDAEkm ygCDE/zgBS/4wQlc8JGlUNL/lNR0mGtEABMd9NUhEJFIJ1xji1qMgFURIACIsgfGI0BhmwsYwxgO sAE72CGb0aiYFiJrSpAighSPG8VRuzqKUNzUh0C8LUxpKdSRFhUSvoUEcHs41lKaEIW4VC4lkHoK SyxVEIfQxB9gGEwoTXWGVQVEJW6o1UeI4hJdxUQoZEFSUoRVpyHx1HHaxgQRiNEfyriDBEpFAQBD Rzq5WNr4fGGtTgRJtyMd6U0Fa0qyRDjCuD0hLQU7iEyYQgNC8YF2wvLRSyoCFY7YBC16sbH7yIAh rtCesOq7vD1tAljak9XijJvCRYRiFEgVRXYfYQn1epWkYY2pTG85VEwYFamt/+ixJZx8ivU6N77H xXF1L3GKHj+il9vVhB8UYznw+ku8mdMcH6z6B2QeQhCNkER6W7He5rYXvozwITUJm4k3TuqAGpCY UJ5BhBFYxSrIyEUuCkW+sC0IFYpAhAp721WvhmLIOI1mkS0sVFw2mM4KsMEP7sMADjhiFfWiqegG 4QhXiEEGR2yGBjjghkxEpLDcE5Y/x3JjJO84qVpuRCMEsWZVbLWZXn0vg4ma5OUuOcuSUEWvex3s 9MI5ydM+6iWYnF1m+/oQhuiydyMB5qiOeapQitJlAJEZNGvCEGpm848tcYo3/xYT73VwnenpIAgB IR1rXcsKuiCBpR2ar7cI0f9NCkGKFV5ZFAuPt1fnzWBjFxUTvV2ukIOAUYF4gBCOm3h7J8GwTmwY 4/64BiVLWMLJTta4Ii3qo5PKS6Zum9vqZnebmble6+bc2ljGdrO3K3NDrFvN0H53K4zO80fw+tfb 7nYfkgRucot7zOQO5sAyc1U/0PzXjYD2j+EN51E8vN4npcgrYDENERT0PsrQwQDGcAPjAesTNjAc DHSJbUnk3d1QxnnOrXuJnS8c3l0NxRC4oYCdkkkL5eiGAhghC10a/RKQWAQiFOEJ0QBhAZtfABQ4 oAYXlKNeKDxySUlR+kXIYuLVvnLPfc1tL3v3qmhe95rb7G4nJz3vPt8u7P//8HvgZ732XM/77nvd e997txLfNnOYxSz1cRvzMgMzL9aFfwg1A1vvQIbybyU9iWhSthMQcgV++T1yf6gjH7vcMvbZzebb Ozn3ui/+9pvJQzpTs5SgaDQmKIHdpHs3LCEFUMAwCNkZVvgET/ioRuOtinvAv9u53Ms7X+u92OuD 5YsEDTSvdKu9rTu+pZO5blO+DIwEDuxAoXO/oBtBp1s+y4GqqJIq6Js6qpu+czNBp/s9PxA+ods6 olMv9nomRNiJvYAQWAACDWCA8xMKZ+AG/xOFXmK6HVS3HvzACvw597O9aIOE4Jqp41Khu+slX2Mz S7gE0Mmp/5iVEWHASZAF/13jOfnzMfprNm2Twt/DQOYzMz08txycQiqcuR28QDx8QT20uuoLvh0E vhZ0weYLphiUwRkUN3Irt+mzOhzMQR3kwfezuWZyLjrDJLOgCFMwk0DgAA6grWg4gWvoBh54PBZy oabDRDTLOk2oRVsMxEBUN9sTQIeTOF1SqpgLumTyHB3iIWiytBRyQ0poBde7wl/DwhXssgtkRBh0 RBvcQKebPdnLxgwkRGt0RDMDhHOrBHIsx27UQ2ucREiMROhTR2ssRHHcwEPUQa1rNyAcBVlwsJ0o i1WYlQpahVvTLchrIcRwqhbUQBOsvmxcSIbEuqzSQlH4ulYAwGBMROFTpv9HgLJIC4WW0yXsar9o xMVAVMRFzMN0nERwDMd4REhxJMRqdMeULESZ/EZ1XEd2jMSapMSqk8l4PMQdHL6t6j7nqrdLOrkT 2i2jYkamMshKcMk9XMlva8mWxMF028Ti87lt87KF/L2HVIUfi8ijy7Jms8NtXMhy1MCWREdHzMka jEm1pEm2lL5vPEl1vEm7LCa2nMtKNESHrL1gAzJpcy+SsimbSj2jujLtcqova8S5lEkYLESq/MkU xD7fG8R4zMF6VAXN5L2svMNudMqZhMtJrIycnMu4FLPTPM27XM3xSs13DMer68Ca87p4g7RkA7we i0LFbEoYrEm9bEzqw0T/XLzDQeTJyPxDYWRBaqzG34xLGkrNmiSz1GRN6pTE03zN8urDzIy/OHQ9 LqMc3nQ+6ETJnexJczxH5izPSwQ+4qRGuhzP5yMm1axO+qzPdoTJSsxO66O57HM2ELRDDIS60YTP GtpJx2TMR4xJqETLF3zP6bRPCI1QCZVP8szP9ZzFWkxOafTMBo1B66zQ33xE/DRQBBXR+JxQFE1R FW0S/HzKS5RFszRJ8cRJAh1PvczJFc1RHd3RgBlReFxQcSzEtQyvuxxPvIRPHk1SJVXR0vxGxxRN Iq3PE6XQ6FxSK71SFI1L08RRLO1SL/1SHq1RmwRTMi1TM61OtjxTNV1TIDZtUzd9UziNUzmdUzqtUzu9UzzNUz3dUz7tUz9N0oAAADs=";
      },
      tearDown: function tearDown() {
        document.body.removeChild(this.__divElement__P_219_0);
        this.__divElement__P_219_0 = null;
      },
      testGetStyles: function testGetStyles() {
        var styles = qx.bom.element.Background.getStyles("foo/bar/baz.gif", "no-repeat", null, null);
        this.assertKeyInMap("backgroundImage", styles, "Key 'backgroundImage' is not present!");
        this.assertKeyInMap("backgroundPosition", styles, "Key 'backgroundPosition' is not present!"); // check for "url(IMAGE-URL)" to be sure that "'" chars are used
        // for normal images. Image names with spaces will then also work

        this.assertEquals("url('foo/bar/baz.gif')", styles.backgroundImage, "Do always use \"'\" for image urls!");
      },
      testGetStylesBase64: function testGetStylesBase64() {
        var styles = qx.bom.element.Background.getStyles(this.__backgroundUrlBase64__P_219_1, "no-repeat", null, null);
        this.assertKeyInMap("backgroundImage", styles, "Key 'backgroundImage' is not present!");
        this.assertKeyInMap("backgroundPosition", styles, "Key 'backgroundPosition' is not present!");
        this.assertEquals("url('" + this.__backgroundUrlBase64__P_219_1 + "')", styles['backgroundImage'], "Wrong value for base64 encoded background image!");
      },
      testCompile: function testCompile() {
        var cssString = qx.bom.element.Background.compile("foo/bar/baz", "no-repeat", null, null);
        var expected = "background-image:url('foo/bar/baz');background-position:0 0;background-repeat:no-repeat;";
        this.assertEquals(expected, cssString, "Compiled CSS string is not valid!");
      },
      testCompileBase64: function testCompileBase64() {
        var cssStringBase64 = qx.bom.element.Background.compile(this.__backgroundUrlBase64__P_219_1, "no-repeat", null, null);
        var expected = "background-image:url('" + this.__backgroundUrlBase64__P_219_1 + "');" + "background-position:0 0;background-repeat:no-repeat;";
        this.assertEquals(expected, cssStringBase64, "Compiled CSS string for base64 image is not valid!");
      }
    }
  });
  qx.test.bom.element.Background.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.client.Css": {},
      "qx.bom.client.Engine": {},
      "qx.bom.element.BoxSizing": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxsizing": {
          "className": "qx.bom.client.Css"
        },
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.element.BoxSizing", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      __support__P_220_0: {
        mshtml: ["border-box", "content-box"],
        opera: ["border-box", "content-box"],
        gecko: ["border-box", "content-box"],
        webkit: ["border-box", "content-box"]
      },
      __el__P_220_1: null,
      setUp: function setUp() {
        this.__el__P_220_1 = document.createElement("div");
        document.body.appendChild(this.__el__P_220_1);
      },
      tearDown: function tearDown() {
        document.body.removeChild(this.__el__P_220_1);
        delete this.__el__P_220_1;
      },
      hasBoxsizing: function hasBoxsizing() {
        return !!qx.core.Environment.get("css.boxsizing");
      },
      testGet: function testGet() {
        this.require(["boxsizing"]);

        var supported = this.__support__P_220_0[qx.core.Environment.get("engine.name")] || [];
        this.assertInArray(qx.bom.element.BoxSizing.get(this.__el__P_220_1), supported);
      },
      testSet: function testSet() {
        this.require(["boxsizing"]);

        var allValues = this.__support__P_220_0["gecko"];
        var supported = this.__support__P_220_0[qx.core.Environment.get("engine.name")] || [];

        for (var i = 0, l = allValues.length; i < l; i++) {
          qx.bom.element.BoxSizing.set(this.__el__P_220_1, allValues[i]);

          if (supported.includes(allValues[i])) {
            this.assertEquals(supported[i], qx.bom.element.BoxSizing.get(this.__el__P_220_1), "supported boxSizing value was not applied!");
          } else {
            this.assertNotEquals(supported[i], qx.bom.element.BoxSizing.get(this.__el__P_220_1), "boxSizing value was unexpectedly applied, maybe browser support has changed?");
          }
        }
      },
      testCompile: function testCompile() {
        this.require(["boxsizing"]);

        var css = qx.bom.element.BoxSizing.compile("border-box");
        this.assertMatch(css, /box-sizing/);
      }
    }
  });
  qx.test.bom.element.BoxSizing.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.element.Class": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.element.Class", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        var div = document.createElement("div");
        div.id = "el";
        this._el = div;
        document.body.appendChild(div);
      },
      tearDown: function tearDown() {
        document.body.removeChild(this._el);
        this._el = null;
      },
      "test: get should return the className for svg element": function testGetShouldReturnTheClassNameForSvgElement() {
        if (document.createElementNS) {
          var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttribute('id', 'svgEl');
          svg.setAttribute('class', 'svgclassname');
          document.body.appendChild(svg);
          var Class = qx.bom.element.Class;
          this.assertEquals("svgclassname", Class.get(svg));
          document.body.removeChild(svg);
        }
      },
      "test: get on new element should return empty string": function testGetOnNewElementShouldReturnEmptyString() {
        var Class = qx.bom.element.Class;
        this.assertEquals("", Class.get(this._el));
      },
      "test: get should return the className": function testGetShouldReturnTheClassName() {
        var Class = qx.bom.element.Class;
        this._el.className = "juhu kinners";
        this.assertEquals("juhu kinners", Class.get(this._el));
      },
      "test: add() on new element should set the class name": function testAddOnNewElementShouldSetTheClassName() {
        var Class = qx.bom.element.Class;
        this.assertEquals("juhu", Class.add(this._el, "juhu"));
        this.assertEquals("juhu", Class.get(this._el));
      },
      "test: add() on element with class should not set it again": function testAddOnElementWithClassShouldNotSetItAgain() {
        var Class = qx.bom.element.Class;
        Class.add(this._el, "juhu");
        Class.add(this._el, "juhu");
        this.assertEquals("juhu", Class.get(this._el));
      },
      "test: addClasses() on new element should set multiple classes": function testAddClassesOnNewElementShouldSetMultipleClasses() {
        var Class = qx.bom.element.Class;
        this.assertEquals("juhu kinners", Class.addClasses(this._el, ["juhu", "kinners"]));
        this.assertEquals("juhu kinners", Class.get(this._el));
      },
      "test: addClasses() should ignore class names, which are already set": function testAddClassesShouldIgnoreClassNamesWhichAreAlreadySet() {
        var Class = qx.bom.element.Class;
        Class.addClasses(this._el, ["juhu", "kinners"]);
        Class.addClasses(this._el, ["juhu"]);
        Class.addClasses(this._el, ["kinners"]);
        this.assertEquals("juhu kinners", Class.get(this._el));
      },
      "test: has()": function testHas() {
        var Class = qx.bom.element.Class;
        this.assertFalse(Class.has(this._el, "juhu"));
        Class.addClasses(this._el, ["juhu", "kinners"]);
        this.assertTrue(Class.has(this._el, "juhu"));
        this.assertTrue(Class.has(this._el, "kinners"));
        this.assertFalse(Class.has(this._el, "foo"));
      },
      "test: remove() non existing class should be ignored": function testRemoveNonExistingClassShouldBeIgnored() {
        var Class = qx.bom.element.Class;
        this.assertEquals("", Class.get(this._el));
        this.assertEquals("juhu", Class.remove(this._el, "juhu"));
        this.assertEquals("", Class.get(this._el));
      },
      "test: remove() existing classes": function testRemoveExistingClasses() {
        var Class = qx.bom.element.Class;
        Class.addClasses(this._el, ["juhu", "kinners"]);
        this.assertEquals("juhu", Class.remove(this._el, "juhu"));
        this.assertMatch(Class.get(this._el), /\s*kinners\s*/);
        this.assertEquals("kinners", Class.remove(this._el, "kinners"));
        this.assertEquals("", Class.get(this._el));
      },
      "test: removeClasses() to remove several classes at once": function testRemoveClassesToRemoveSeveralClassesAtOnce() {
        var Class = qx.bom.element.Class;
        Class.addClasses(this._el, ["a", "juhu", "b", "kinners", "c"]);
        this.assertEquals("a b c", Class.removeClasses(this._el, ["kinners", "juhu"]));
        this.assertEquals("a b c", Class.get(this._el));
      },
      "test: replace()": function testReplace() {
        var Class = qx.bom.element.Class;
        Class.addClasses(this._el, ["juhu", "kinners"]);
        this.assertEquals("foo", Class.replace(this._el, "juhu", "foo"));
        this.assertFalse(Class.has(this._el, "juhu"));
        this.assertTrue(Class.has(this._el, "foo"));
        this.assertTrue(Class.has(this._el, "kinners"));
        this.assertEquals("bar", Class.replace(this._el, "kinners", "bar"));
        this.assertFalse(Class.has(this._el, "juhu"));
        this.assertFalse(Class.has(this._el, "kinners"));
        this.assertTrue(Class.has(this._el, "foo"));
        this.assertTrue(Class.has(this._el, "bar"));
        this.assertEquals("", Class.replace(this._el, "i-dont-exist", "baz"));
        this.assertFalse(Class.has(this._el, "juhu"));
        this.assertFalse(Class.has(this._el, "kinners"));
        this.assertTrue(Class.has(this._el, "foo"));
        this.assertTrue(Class.has(this._el, "bar"));
        this.assertFalse(Class.has(this._el, "baz"));
      },
      "test: toggle() non existing class should add it": function testToggleNonExistingClassShouldAddIt() {
        var Class = qx.bom.element.Class;
        this.assertEquals("juhu", Class.toggle(this._el, "juhu"));
        this.assertEquals("juhu", Class.get(this._el));
      },
      "test: toggle() existing class name should remove it": function testToggleExistingClassNameShouldRemoveIt() {
        var Class = qx.bom.element.Class;
        Class.addClasses(this._el, ["juhu", "kinners"]);
        this.assertEquals("juhu", Class.toggle(this._el, "juhu"));
        this.assertMatch(Class.get(this._el), /\s*kinners\s*/);
      }
    }
  });
  qx.test.bom.element.Class.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.element.Dimension": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.element.Dimension", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.__inlineElement__P_221_0 = document.createElement("span");
        document.body.appendChild(this.__inlineElement__P_221_0);
        this.__inlineElementWithPadding__P_221_1 = document.createElement("span");
        this.__inlineElementWithPadding__P_221_1.style.padding = "2px";
        document.body.appendChild(this.__inlineElementWithPadding__P_221_1);
        this.__blockElement__P_221_2 = document.createElement("div");
        this.__blockElement__P_221_2.style.width = "200px";
        document.body.appendChild(this.__blockElement__P_221_2);
        this.__blockElementWithPadding__P_221_3 = document.createElement("div");
        this.__blockElementWithPadding__P_221_3.style.padding = "2px";
        this.__blockElementWithPadding__P_221_3.style.width = "200px";
        document.body.appendChild(this.__blockElementWithPadding__P_221_3);
      },
      tearDown: function tearDown() {
        document.body.removeChild(this.__inlineElement__P_221_0);
        this.__inlineElement__P_221_0 = null;
        document.body.removeChild(this.__inlineElementWithPadding__P_221_1);
        this.__inlineElementWithPadding__P_221_1 = null;
        document.body.removeChild(this.__blockElement__P_221_2);
        this.__blockElement__P_221_2 = null;
        document.body.removeChild(this.__blockElementWithPadding__P_221_3);
        this.__blockElementWithPadding__P_221_3 = null;
      },
      testContentWidthOfInlineElement: function testContentWidthOfInlineElement() {
        this.assertEquals(0, qx.bom.element.Dimension.getContentWidth(this.__inlineElement__P_221_0));
      },
      testContentWidthOfInlineElementWithPadding: function testContentWidthOfInlineElementWithPadding() {
        this.assertEquals(0, qx.bom.element.Dimension.getContentWidth(this.__inlineElementWithPadding__P_221_1));
      },
      testContentWidthOfBlockElement: function testContentWidthOfBlockElement() {
        this.assertEquals(200, qx.bom.element.Dimension.getContentWidth(this.__blockElement__P_221_2));
      },
      testContentWidthOfBlockElementWithPadding: function testContentWidthOfBlockElementWithPadding() {
        this.assertEquals(200, qx.bom.element.Dimension.getContentWidth(this.__blockElementWithPadding__P_221_3));
      },
      testRoundingErrorInWidthAndHeightGetters: function testRoundingErrorInWidthAndHeightGetters() {
        // width = left - right = height = bottom - top = 38.416656494140625
        var mockElement1 = {
          getBoundingClientRect: function getBoundingClientRect() {
            return {
              right: 91.58332824707031,
              left: 53.16667175292969,
              bottom: 91.58332824707031,
              top: 53.16667175292969
            };
          }
        }; // exactly same width and height as mockElement1

        var mockElement2 = {
          getBoundingClientRect: function getBoundingClientRect() {
            return {
              right: 91.58332824707031,
              left: 53.16667175292969,
              bottom: 91.58332824707031,
              top: 53.16667175292969
            };
          }
        }; // make sure both mock objects have the same width

        this.assertEquals(mockElement1.getBoundingClientRect().right - mockElement1.getBoundingClientRect().left, mockElement2.getBoundingClientRect().right - mockElement2.getBoundingClientRect().left); // ... and the same height

        this.assertEquals(mockElement1.getBoundingClientRect().bottom - mockElement1.getBoundingClientRect().top, mockElement2.getBoundingClientRect().bottom - mockElement2.getBoundingClientRect().top); // the width and height calculation for both objects should return the same

        this.assertEquals(qx.bom.element.Dimension.getWidth(mockElement1), qx.bom.element.Dimension.getWidth(mockElement2));
        this.assertEquals(qx.bom.element.Dimension.getHeight(mockElement1), qx.bom.element.Dimension.getHeight(mockElement2));
      }
    }
  });
  qx.test.bom.element.Dimension.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.client.Css": {},
      "qx.bom.element.Style": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.dev.unit.RequirementError": {},
      "qx.bom.Stylesheet": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxshadow": {
          "className": "qx.bom.client.Css"
        },
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        },
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "browser.version": {
          "className": "qx.bom.client.Browser"
        },
        "css.opacity": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.element.Style", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      __element__P_222_0: null,
      hasCssBoxshadow: function hasCssBoxshadow() {
        return qx.core.Environment.get("css.boxshadow") !== null;
      },
      setUp: function setUp() {
        this.__element__P_222_0 = document.createElement("div");
        document.body.appendChild(this.__element__P_222_0);
      },
      tearDown: function tearDown() {
        document.body.removeChild(this.__element__P_222_0);
        this.__element__P_222_0 = null;
      },
      testSetStylesWithCss3: function testSetStylesWithCss3() {
        if (this.require(["cssBoxshadow"])) {
          var styles = {
            "MozBoxShadow": "6px 6px 10px rgb(128, 128, 128)",
            "WebkitBoxShadow": "6px 6px 10px rgb(128, 128, 128)",
            "boxShadow": "6px 6px 10px rgb(128, 128, 128)"
          };
          qx.bom.element.Style.setStyles(this.__element__P_222_0, styles);
          var expected = qx.core.Environment.select("engine.name", {
            "webkit": "rgb(128, 128, 128) 6px 6px 10px",
            "mshtml": "6px 6px 10px rgb(128,128,128)",
            "default": "6px 6px 10px rgb(128, 128, 128)"
          });
          this.assertEquals(expected, this.__element__P_222_0.style["boxShadow"]);
        }
      },
      testSetAndGetCss: function testSetAndGetCss() {
        var css = "font-weight: bold;";
        qx.bom.element.Style.setCss(this.__element__P_222_0, css);
        this.assertMatch(qx.bom.element.Style.getCss(this.__element__P_222_0), /font-weight.*?bold/i);
      },
      testSet: function testSet() {
        var name = "border";
        var style = ["1px", "solid", "red"];
        qx.bom.element.Style.set(this.__element__P_222_0, name, style.join(" "));

        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9) {
          this.assertEquals("red 1px solid", this.__element__P_222_0.style.border);
        } else {
          this.assertEquals(style.join(" "), this.__element__P_222_0.style.border);
        }

        this.assertEquals(style[0], this.__element__P_222_0.style.borderWidth);
        this.assertEquals(style[1], this.__element__P_222_0.style.borderStyle);
        this.assertEquals(style[2], this.__element__P_222_0.style.borderColor);
      },
      testGet: function testGet() {
        var name = "border";
        var style = "1px solid red";
        var engine = qx.core.Environment.get("engine.name");
        var expected = ["1px", "solid", "red"];
        var isOldSafari = qx.core.Environment.get("browser.name") == "safari" && qx.core.Environment.get("browser.version") < 6;

        if (engine == "opera" || engine == "webkit" && !isOldSafari && qx.core.Environment.get("browser.name") !== "edge") {
          expected = ["1px", "solid", "rgb(255, 0, 0)"];
        }

        qx.bom.element.Style.set(this.__element__P_222_0, name, style);

        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9 && qx.core.Environment.get("browser.name") !== "edge") {
          this.assertEquals("red 1px solid", qx.bom.element.Style.get(this.__element__P_222_0, name));
        } else {
          this.assertEquals(expected.join(" "), qx.bom.element.Style.get(this.__element__P_222_0, name));
        }

        this.assertEquals(expected[0], qx.bom.element.Style.get(this.__element__P_222_0, "borderWidth"));
        this.assertEquals(expected[1], qx.bom.element.Style.get(this.__element__P_222_0, "borderStyle"));
        this.assertEquals(expected[2], qx.bom.element.Style.get(this.__element__P_222_0, "borderColor"));
      },
      testSetFloat: function testSetFloat() {
        qx.bom.element.Style.set(this.__element__P_222_0, "float", "left");
        this.assertEquals("left", this.__element__P_222_0.style.float || this.__element__P_222_0.style.styleFloat);
      },
      testCompileFloat: function testCompileFloat() {
        var css = qx.bom.element.Style.compile({
          "float": "left"
        });
        this.assertEquals("float:left;", css);
      },
      testGetFloat: function testGetFloat() {
        // known to fail in chrome
        if (qx.core.Environment.get("browser.name") == "chrome") {
          throw new qx.dev.unit.RequirementError();
        } // important to set this value as CSS class


        var sheet = qx.bom.Stylesheet.createElement('.right { float: right; }');
        this.__element__P_222_0.className = 'right';
        var floatValue = qx.bom.element.Style.get(this.__element__P_222_0, 'float');
        this.assertEquals('right', floatValue);
        qx.bom.Stylesheet.removeSheet(sheet);
        this.__element__P_222_0.className = '';
      },
      testCompileContent: function testCompileContent() {
        var css = qx.bom.element.Style.compile({
          "content": ""
        });
        this.assertEquals("content:\"\";", css);
      },
      testSetOpacity: function testSetOpacity() {
        if (!qx.core.Environment.get("css.opacity")) {
          throw new qx.dev.unit.RequirementError("css.opacity");
        }

        qx.bom.element.Style.set(this.__element__P_222_0, "opacity", 1);
        this.assertEquals("1", this.__element__P_222_0.style.opacity);
      },
      testCompileOpacity: function testCompileOpacity() {
        if (!qx.core.Environment.get("css.opacity")) {
          throw new qx.dev.unit.RequirementError("css.opacity");
        }

        var css = qx.bom.element.Style.compile({
          "opacity": 1
        });
        this.assertEquals("opacity:1;", css);
      }
    }
  });
  qx.test.bom.element.Style.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.client.CssTransform": {},
      "qx.dev.unit.RequirementError": {},
      "qx.bom.element.Transform": {},
      "qx.bom.Stylesheet": {},
      "qx.bom.Style": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.transform": {
          "className": "qx.bom.client.CssTransform"
        },
        "css.transform.3d": {
          "className": "qx.bom.client.CssTransform"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.element.Transform", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      __el__P_223_0: null,
      __keys__P_223_1: null,
      setUp: function setUp() {
        this.__keys__P_223_1 = qx.core.Environment.get("css.transform");

        if (this.__keys__P_223_1 == null) {
          // skip the test
          throw new qx.dev.unit.RequirementError("css.transform");
        }

        this.__el__P_223_0 = {
          style: {}
        };
      },
      tearDown: function tearDown() {
        this.__el__P_223_0 = null;
      },

      /**
       * TRANSFORM FUNCTIONS
       */
      testTranslate: function testTranslate() {
        qx.bom.element.Transform.translate(this.__el__P_223_0, "123px");
        this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("translate(123px)") != -1);
      },
      testRotate: function testRotate() {
        qx.bom.element.Transform.rotate(this.__el__P_223_0, "123deg");
        this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("rotate(123deg)") != -1);
      },
      testSkew: function testSkew() {
        qx.bom.element.Transform.skew(this.__el__P_223_0, "123deg");
        this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("skew(123deg)") != -1);
      },
      testScale: function testScale() {
        qx.bom.element.Transform.scale(this.__el__P_223_0, 1.5);
        this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("scale(1.5)") != -1);
      },
      testTransform: function testTransform() {
        qx.bom.element.Transform.transform(this.__el__P_223_0, {
          scale: 1.2,
          translate: "123px"
        });
        this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("translate(123px)") != -1);
        this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("scale(1.2)") != -1);
      },
      "testAddStyleSheetRuleWith-X-Axis": function testAddStyleSheetRuleWithXAxis() {
        var css = qx.bom.element.Transform.getCss({
          scale: 1.2,
          translate: "123px"
        });
        var sheet = qx.bom.Stylesheet.createElement();
        qx.bom.Stylesheet.addRule(sheet, ".test", css);
        var computedRule = sheet.cssRules[0].cssText;
        this.assertTrue(computedRule.indexOf("translate(123px)") != -1, "Found: " + computedRule);
        this.assertTrue(computedRule.indexOf("scale(1.2)") != -1, "Found: " + computedRule);
      },
      "testAddStyleSheetRuleWith-XY-Axis": function testAddStyleSheetRuleWithXYAxis() {
        var css = qx.bom.element.Transform.getCss({
          scale: "1.2, 1",
          translate: "123px,234px"
        });
        var sheet = qx.bom.Stylesheet.createElement();
        qx.bom.Stylesheet.addRule(sheet, ".test", css);
        var computedRule = sheet.cssRules[0].cssText;
        this.assertTrue(computedRule.indexOf("translate(123px, 234px)") != -1, "Found: " + computedRule);
        this.assertTrue(computedRule.indexOf("scale(1.2, 1)") != -1, "Found: " + computedRule);
      },

      /**
       * ARRAY VALUES
       */
      test3D: function test3D() {
        qx.bom.element.Transform.translate(this.__el__P_223_0, ["1px", "2px", "3px"]); // 3d property

        if (qx.core.Environment.get("css.transform.3d")) {
          this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("translate3d(1px, 2px, 3px)") != -1, "translate3d");
        } // 2d property
        else {
            this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("translateX(1px) translateY(2px)") != -1);
          }
      },
      "testAddStyleSheetRuleWith-XYZ-Axis": function testAddStyleSheetRuleWithXYZAxis() {
        var css = qx.bom.element.Transform.getCss({
          scale: [1.2, 1, 0],
          translate: ["123px", "234px", "345em"]
        });
        var sheet = qx.bom.Stylesheet.createElement();
        qx.bom.Stylesheet.addRule(sheet, ".test", css);
        var computedRule = sheet.cssRules[0].cssText; // 3d property

        if (qx.core.Environment.get("css.transform.3d")) {
          this.assertTrue(computedRule.indexOf("translate3d(123px, 234px, 345em)") != -1, "Found: " + computedRule);
          this.assertTrue(computedRule.indexOf("scale3d(1.2, 1, 0)") != -1, "Found: " + computedRule);
        } // 2d property
        else {
            this.assertTrue(computedRule.indexOf("translateX(123px)") != -1, "Found: " + computedRule);
            this.assertTrue(computedRule.indexOf("translateY(234px)") != -1, "Found: " + computedRule);
            this.assertFalse(computedRule.indexOf("translateY(345em)") != -1, "Found: " + computedRule);
            this.assertTrue(computedRule.indexOf("scaleX(1.2)") != -1, "Found: " + computedRule);
            this.assertTrue(computedRule.indexOf("scaleY(1)") != -1, "Found: " + computedRule);
            this.assertFalse(computedRule.indexOf("scaleZ(0)") != -1, "Found: " + computedRule);
          }
      },

      /**
       * CSS HELPER
       */
      testGetCss: function testGetCss() {
        var value = qx.bom.element.Transform.getCss({
          scale: 1.2
        });
        this.assertEquals(qx.bom.Style.getCssName(this.__keys__P_223_1.name) + ":scale(1.2);", value);
      },

      /**
       * ADDITIONAL CSS TRANSFORM PROPERTIES
       */
      testOrigin: function testOrigin() {
        qx.bom.element.Transform.setOrigin(this.__el__P_223_0, "30% 20%");
        this.assertEquals("30% 20%", this.__el__P_223_0.style[this.__keys__P_223_1["origin"]]);
        this.assertEquals("30% 20%", qx.bom.element.Transform.getOrigin(this.__el__P_223_0));
      },
      testStyle: function testStyle() {
        qx.bom.element.Transform.setStyle(this.__el__P_223_0, "affe");
        this.assertEquals("affe", this.__el__P_223_0.style[this.__keys__P_223_1["style"]]);
        this.assertEquals("affe", qx.bom.element.Transform.getStyle(this.__el__P_223_0));
      },
      testPerspective: function testPerspective() {
        qx.bom.element.Transform.setPerspective(this.__el__P_223_0, 123);
        this.assertEquals("123px", this.__el__P_223_0.style[this.__keys__P_223_1["perspective"]]);
        this.assertEquals("123px", qx.bom.element.Transform.getPerspective(this.__el__P_223_0));
      },
      testPerspectiveOrigin: function testPerspectiveOrigin() {
        qx.bom.element.Transform.setPerspectiveOrigin(this.__el__P_223_0, "30% 10%");
        this.assertEquals("30% 10%", this.__el__P_223_0.style[this.__keys__P_223_1["perspective-origin"]]);
        this.assertEquals("30% 10%", qx.bom.element.Transform.getPerspectiveOrigin(this.__el__P_223_0));
      },
      testBackfaceVisibility: function testBackfaceVisibility() {
        qx.bom.element.Transform.setBackfaceVisibility(this.__el__P_223_0, true);
        this.assertEquals("visible", this.__el__P_223_0.style[this.__keys__P_223_1["backface-visibility"]]);
        this.assertTrue(qx.bom.element.Transform.getBackfaceVisibility(this.__el__P_223_0));
      },
      testGetTransformValue: function testGetTransformValue() {
        var cssValue; // one axis

        cssValue = qx.bom.element.Transform.getTransformValue({
          scale: [1]
        });
        this.assertEquals(cssValue, "scaleX(1)"); // two axis

        cssValue = qx.bom.element.Transform.getTransformValue({
          scale: [1, 2]
        });
        this.assertEquals(cssValue, "scaleX(1) scaleY(2)"); // three axis

        cssValue = qx.bom.element.Transform.getTransformValue({
          scale: [1, 2, 3]
        }); // 3d property

        if (qx.core.Environment.get("css.transform.3d")) {
          this.assertEquals(cssValue, "scale3d(1, 2, 3)");
        } // 2d property
        else {
            this.assertEquals(cssValue, "scaleX(1) scaleY(2)");
          }
      },
      testTransformArray: function testTransformArray() {
        qx.bom.element.Transform.transform(this.__el__P_223_0, {
          translate: ["1px", "2px", "3px"],
          scale: [1, 2, 3],
          rotate: ["1deg", "2deg", "3deg"],
          skew: ["1deg", "2deg"]
        }); // 3d property

        if (qx.core.Environment.get("css.transform.3d")) {
          this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("translate3d(1px, 2px, 3px)") != -1, "translate3d");
          this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("scale3d(1, 2, 3)") != -1, "scale3d");
          this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("rotateZ(3deg)") != -1, "rotate");
          this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("skewX(1deg) skewY(2deg)") != -1, "skew");
        } // 2d property
        else {
            this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("translateX(1px) translateY(2px)") != -1, "translate");
            this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("scaleX(1) scaleY(2)") != -1, "scale");
            this.assertTrue(this.__el__P_223_0.style[this.__keys__P_223_1.name].indexOf("skewX(1deg) skewY(2deg)") != -1, "skew");
          }
      }
    }
  });
  qx.test.bom.element.Transform.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.media.Audio": {},
      "qx.bom.client.Browser": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.test.travis": {},
        "browser.name": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */

  /**
   * @ignore(DOMException)
   */
  qx.Class.define("qx.test.bom.media.MediaTestCase", {
    type: "abstract",
    extend: qx.dev.unit.TestCase,
    members: {
      _media: null,
      _src: null,
      _getSrc: function _getSrc() {},
      _createMedia: function _createMedia() {},
      _checkFeature: function _checkFeature() {},
      setUp: function setUp() {
        this._checkFeature();

        this._src = this._getSrc();
        this._media = this._createMedia();
      },
      tearDown: function tearDown() {
        this._media.dispose();

        this._media = null;
        this._src = null;
      },
      testId: function testId() {
        var id = "mediaid";

        this._media.setId(id);

        this.assertEquals(id, this._media.getId());
      },
      testVolume: function testVolume() {
        var exReg = /index.*?size.*?err/i;
        var that = this;

        this._media.setVolume(1);

        this.assertEquals(1, this._media.getVolume());

        this._media.setVolume(0);

        this.assertEquals(0, this._media.getVolume());
        this.assertException(function () {
          that._media.setVolume(-1);
        }, DOMException, exReg);
        this.assertException(function () {
          that._media.setVolume(2);
        }, DOMException, exReg);
      },
      testMute: function testMute() {
        this.assertFalse(this._media.isMuted());

        this._media.setMuted(true);

        this.assertTrue(this._media.isMuted());

        this._media.setMuted(false);

        this.assertFalse(this._media.isMuted());
      },
      testCurrentTime: function testCurrentTime() {
        var that = this;
        this.assertEquals(0, this._media.getCurrentTime());
      },
      testSource: function testSource() {
        this._media.dispose();

        this._media = new qx.bom.media.Audio();

        this._media.setSource(this._src);

        var _ref = this._src.split("/");

        var expectedFile = _ref[_ref.length - 1];
        _ref = this._media.getSource().split("/");
        var foundFile = _ref[_ref.length - 1];
        this.assertEquals(expectedFile, foundFile);
      },
      testControls: function testControls() {
        this.assertFalse(this._media.hasControls());

        this._media.showControls();

        this.assertTrue(this._media.hasControls());

        this._media.hideControls();

        this.assertFalse(this._media.hasControls());
      },
      testAutoplay: function testAutoplay() {
        this.assertFalse(this._media.getAutoplay());

        this._media.setAutoplay(true);

        this.assertTrue(this._media.getAutoplay());

        this._media.setAutoplay(false);

        this.assertFalse(this._media.getAutoplay());
      },
      testGetMediaObject: function testGetMediaObject() {
        this.assertElement(this._media.getMediaObject());
      },
      testPreload: function testPreload() {
        //default
        this.assertEquals("auto", this._media.getPreload(), "a");

        this._media.setPreload("none");

        this.assertEquals("none", this._media.getPreload());

        this._media.setPreload("metadata");

        this.assertEquals("metadata", this._media.getPreload(), "12");

        this._media.setPreload("auto");

        this.assertEquals("auto", this._media.getPreload(), "b"); //the preload default is auto

        this._media.setPreload("none");

        this._media.setPreload("affe");

        this.assertEquals("auto", this._media.getPreload(), "c");
      },
      testLoop: function testLoop() {
        this.assertFalse(this._media.isLoop());

        this._media.setLoop(true);

        this.assertTrue(this._media.isLoop());

        this._media.setLoop(false);

        this.assertFalse(this._media.isLoop());
      },
      testVolumeChangeEvent: function testVolumeChangeEvent() {
        this._media.addListener("volumechange", function (e) {
          this.resume(function () {
            this.assertEquals(0.5, this._media.getVolume());
          }, this);
        }, this);

        this._media.setVolume(0.5);

        this.wait();
      },
      // On safari this test fails, if we are running the
      // complete testsuite and the test is not the first
      // test in qx.test.bom.media.MediaTestCase. By naming
      // it with a blank behind test it is enqueued as the first
      // test and the test run succeeds.
      //
      // Note that the tests in qx.test.bom.media.MediaTestCase
      // are started seperately or this test is restarted after 
      // it failed, then it succeeds.
      // This is some weird timing or caching issue which could
      // not be solved otherwise.
      //
      "test Play Event": function testPlayEvent() {
        // Disabled on travis because of events not being fired reliable
        if (qx.core.Environment.get("qx.test.travis") == "true") {
          this.skip("HTML5 audio/video play event test disabled on travis");
        } // BUG #8778


        if (qx.core.Environment.get("browser.name") == "mobile chrome") {
          this.skip("HTML5 audio/video playback must be triggered by user interaction in Chrome on Android.");
        }

        this.assertTrue(this._media.isPaused());

        this._media.addListener("play", function (e) {
          this.resume(function () {
            this.assertFalse(this._media.isPaused());
          }, this);
        }, this);

        this._media.play();

        this.wait();
      }
    }
  });
  qx.test.bom.media.MediaTestCase.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.bom.media.MediaTestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.client.Html": {},
      "qx.util.ResourceManager": {},
      "qx.bom.media.Audio": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "html.audio.mp3": {
          "className": "qx.bom.client.Html"
        },
        "html.audio.ogg": {
          "className": "qx.bom.client.Html"
        },
        "html.audio.wav": {
          "className": "qx.bom.client.Html"
        },
        "html.audio": {
          "className": "qx.bom.client.Html"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/media/*)
   */
  qx.Class.define("qx.test.bom.media.Audio", {
    extend: qx.test.bom.media.MediaTestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      _getSrc: function _getSrc() {
        if (qx.core.Environment.get("html.audio.mp3")) {
          return qx.util.ResourceManager.getInstance().toUri("qx/test/media/knock.mp3");
        } else if (qx.core.Environment.get("html.audio.ogg")) {
          return qx.util.ResourceManager.getInstance().toUri("qx/test/media/knock.ogg");
        } else if (qx.core.Environment.get("html.audio.wav")) {
          return qx.util.ResourceManager.getInstance().toUri("qx/test/media/knock.wav");
        }
      },
      _createMedia: function _createMedia() {
        return new qx.bom.media.Audio(this._src);
      },
      _checkFeature: function _checkFeature() {
        this.require(["audio"]);
      },
      hasAudio: function hasAudio() {
        return qx.core.Environment.get("html.audio");
      }
    }
  });
  qx.test.bom.media.Audio.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.bom.media.MediaTestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.client.Html": {},
      "qx.util.ResourceManager": {},
      "qx.bom.media.Video": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "html.video.h264": {
          "className": "qx.bom.client.Html"
        },
        "html.video.ogg": {
          "className": "qx.bom.client.Html"
        },
        "html.video.webm": {
          "className": "qx.bom.client.Html"
        },
        "html.video": {
          "className": "qx.bom.client.Html"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/media/*)
   */
  qx.Class.define("qx.test.bom.media.Video", {
    extend: qx.test.bom.media.MediaTestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      _getSrc: function _getSrc() {
        if (qx.core.Environment.get("html.video.h264")) {
          return qx.util.ResourceManager.getInstance().toUri("qx/test/media/qx.mp4");
        } else if (qx.core.Environment.get("html.video.ogg")) {
          return qx.util.ResourceManager.getInstance().toUri("qx/test/media/qx.ogv");
        } else if (qx.core.Environment.get("html.video.webm")) {
          return qx.util.ResourceManager.getInstance().toUri("qx/test/media/qx.webm");
        }
      },
      _createMedia: function _createMedia() {
        return new qx.bom.media.Video(this._src);
      },
      _checkFeature: function _checkFeature() {
        this.require(["video"]);
      },
      hasVideo: function hasVideo() {
        return qx.core.Environment.get("html.video");
      },
      testWidth: function testWidth() {
        this._media.setWidth(200);

        this.assertEquals(200, this._media.getWidth());
      },
      testHeight: function testHeight() {
        this._media.setWidth(200);

        this.assertEquals(200, this._media.getWidth());
      },
      testVideoWidthAndHeight: function testVideoWidthAndHeight(e) {
        this.assertEquals(0, this._media.getVideoWidth());
        this.assertEquals(0, this._media.getVideoHeight()); //we know the video width and hight when meta data is loaded

        this._media.addListener("loadedmetadata", function (e) {
          var v = e._target;
          this.assertEquals(720, v.getVideoWidth());
          this.assertEquals(704, v.getVideoHeight());
        }, this); //or when the entire video is loaded


        this._media.addListener("loadeddata", function (e) {
          var v = e._target;
          this.assertEquals(720, v.getVideoWidth());
          this.assertEquals(704, v.getVideoHeight());
        }, this);
      }
    }
  });
  qx.test.bom.media.Video.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.bom.request.Jsonp": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.dev.unit.RequirementError": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/script.js)
   * @asset(qx/test/jsonp_primitive.php)
   *
   * @ignore(myExistingCallback)
   */
  qx.Class.define("qx.test.bom.request.Jsonp", {
    extend: qx.dev.unit.TestCase,
    include: [qx.test.io.MRemoteTest, qx.dev.unit.MRequirements, qx.dev.unit.MMock],
    members: {
      setUp: function setUp() {
        this.require(["php"]);

        var req = this.req = new qx.bom.request.Jsonp();
        this.url = this.getUrl("qx/test/jsonp_primitive.php"); // Assume timeout after 1s in Opera (no error!)

        if (qx.core.Environment.get("engine.name") === "opera") {
          req.timeout = 1000;
        }
      },
      tearDown: function tearDown() {
        window.SCRIPT_LOADED = undefined;
        this.getSandbox().restore();
        this.req.dispose();
      },
      //
      // Callback
      //
      "test: setCallbackParam()": function testSetCallbackParam() {
        var req = this.req;
        req.setCallbackParam("myMethod");
        req.open("GET", this.url);
        req.send();
        this.assertMatch(req._getUrl(), /(myMethod=)/);
      },
      "test: setCallbackName()": function testSetCallbackName() {
        var req = this.req;
        req.setCallbackName("myCallback");
        req.open("GET", this.url);
        req.send();
        this.assertMatch(req._getUrl(), /(=myCallback)/);
      },
      "test: has default callback param and name": function testHasDefaultCallbackParamAndName() {
        var req = this.req,
            regExp;
        req.open("GET", this.url);
        req.send(); // String is URL encoded

        regExp = /\?callback=qx\.bom\.request\.Jsonp.*\d{16,}.*\.callback/;
        this.assertMatch(req._getUrl(), regExp);
      },

      /**
       * @ignore(myExistingCallback)
       */
      "test: not overwrite existing callback": function testNotOverwriteExistingCallback() {
        var that = this; // User provided callback that must not be overwritten

        window.myExistingCallback = function () {
          return "Affe";
        };

        this.req.setCallbackName("myExistingCallback");

        this.req.onload = function () {
          that.resume(function () {
            that.assertEquals("Affe", myExistingCallback());
            window.myExistingCallback = undefined;
          });
        };

        this.request();
        this.wait();
      },
      //
      // Properties
      //
      "test: responseJson holds response with default callback": function testResponseJsonHoldsResponseWithDefaultCallback() {
        var that = this;

        this.req.onload = function () {
          that.resume(function () {
            var data = this.req.responseJson;
            that.assertObject(data);
            that.assertTrue(data["boolean"]);
          });
        };

        this.request();
        this.wait();
      },
      "test: reset responseJson when reopened": function testResetResponseJsonWhenReopened() {
        var req = this.req,
            that = this;

        req.onload = function () {
          that.resume(function () {
            req.open("GET", "/url");
            that.assertNull(req.responseJson);
          });
        };

        this.request();
        this.wait();
      },
      "test: status indicates success when default callback called": function testStatusIndicatesSuccessWhenDefaultCallbackCalled() {
        var that = this;

        this.req.onload = function () {
          that.resume(function () {
            that.assertEquals(200, that.req.status);
          });
        };

        this.request();
        this.wait();
      },
      "test: status indicates success when custom callback called": function testStatusIndicatesSuccessWhenCustomCallbackCalled() {
        var that = this;

        this.req.onload = function () {
          that.resume(function () {
            that.assertEquals(200, that.req.status);
          });
        };

        this.req.setCallbackName("myCallback");
        this.request();
        this.wait();
      },
      // Error handling
      "test: status indicates failure when default callback not called": function testStatusIndicatesFailureWhenDefaultCallbackNotCalled() {
        var that = this;

        this.req.onload = function () {
          that.resume(function () {
            that.assertEquals(500, that.req.status);
          });
        };

        this.request(this.getUrl("qx/test/script.js"));
        this.wait();
      },
      "test: status indicates failure when custom callback not called": function testStatusIndicatesFailureWhenCustomCallbackNotCalled() {
        var that = this;

        this.req.onload = function () {
          that.resume(function () {
            that.assertEquals(500, that.req.status);
          });
        };

        this.req.setCallbackName("myCallback");
        this.request(this.getUrl("qx/test/script.js"));
        this.wait();
      },
      "test: status indicates failure when callback not called on second request": function testStatusIndicatesFailureWhenCallbackNotCalledOnSecondRequest() {
        var count = 0,
            req = this.req,
            that = this;

        req.onload = function () {
          count += 1;

          if (count == 2) {
            that.resume(function () {
              that.assertEquals(500, req.status);
            });
            return;
          }

          that.request(that.getUrl("qx/test/script.js"));
        };

        this.request();
        this.wait();
      },
      //
      // Event handlers
      //
      "test: call onload": function testCallOnload() {
        var that = this;

        this.req.onload = function () {
          that.resume(function () {});
        };

        this.request();
        this.wait();
      },
      // Error handling
      "test: call onerror on network error": function testCallOnerrorOnNetworkError() {
        var that = this; // For legacy IEs, timeout needs to be lower than browser timeout
        // or false "load" is fired. Alternatively, a false "load"
        // can be identified by checking status property.

        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9) {
          this.req.timeout = 2000;
        }

        this.req.onerror = function () {
          that.resume(function () {});
        };

        this.request("http://fail.tld");
        this.wait(15100);
      },
      "test: call onloadend on network error": function testCallOnloadendOnNetworkError() {
        var that = this;

        this.req.onloadend = function () {
          that.resume(function () {});
        };

        this.request("http://fail.tld");
        this.wait(15100);
      },
      request: function request(customUrl) {
        this.req.open("GET", customUrl || this.url);
        this.req.send();
      },
      skip: function skip(msg) {
        throw new qx.dev.unit.RequirementError(null, msg);
      }
    }
  });
  qx.test.bom.request.Jsonp.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.bom.request.Script": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.dev.unit.RequirementError": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/jsonp_primitive.php)
   * @asset(qx/test/script.js)
   * @asset(qx/test/xmlhttp/sample.txt)
   * @ignore(SCRIPT_LOADED)
   */
  qx.Class.define("qx.test.bom.request.Script", {
    extend: qx.dev.unit.TestCase,
    include: [qx.test.io.MRemoteTest, qx.dev.unit.MRequirements, qx.dev.unit.MMock],
    members: {
      setUp: function setUp() {
        var req = this.req = new qx.bom.request.Script();
        this.url = this.getUrl("qx/test/script.js"); // Assume timeout after 1s in Opera (no error!)

        if (qx.core.Environment.get("engine.name") === "opera") {
          req.timeout = 1000;
        }
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();
        this.req.dispose();
      },
      //
      // General
      //
      "test: create instance": function testCreateInstance() {
        this.assertObject(this.req);
      },
      "test: dispose() removes script from DOM": function testDisposeRemovesScriptFromDOM() {
        var script;
        this.req.open();
        this.req.send();
        script = this.req._getScriptElement();
        this.req.dispose();
        this.assertFalse(this.isInDom(script));
      },
      "test: isDisposed()": function testIsDisposed() {
        this.assertFalse(this.req.isDisposed());
        this.req.dispose();
        this.assertTrue(this.req.isDisposed());
      },
      "test: allow many requests with same object": function testAllowManyRequestsWithSameObject() {
        var count = 0,
            that = this;

        this.req.onload = function () {
          count += 1;

          if (count == 2) {
            that.resume(function () {});
            return;
          }

          that.request();
        };

        this.request();
        this.wait();
      },
      //
      // Event helper
      //
      "test: call event handler": function testCallEventHandler() {
        var req = this.req;
        req.onevent = this.spy();

        req._emit("event");

        this.assertCalled(req.onevent);
      },
      "test: fire event": function testFireEvent() {
        var req = this.req;
        var event = this.spy();
        req.onevent = this.spy();
        req.on("event", event);

        req._emit("event");

        this.assertCalled(event);
      },
      //
      // Properties
      //
      "test: properties indicate success when request completed": function testPropertiesIndicateSuccessWhenRequestCompleted() {
        var that = this,
            req = this.req;

        req.onload = function () {
          that.resume(function () {
            that.assertEquals(4, req.readyState);
            that.assertEquals(200, req.status);
            that.assertEquals("200", req.statusText);
          });
        };

        this.request();
        this.wait();
      },

      /**
       * @ignore(SCRIPT_LOADED)
       */
      "test: status indicates success when determineSuccess returns true": function testStatusIndicatesSuccessWhenDetermineSuccessReturnsTrue() {
        var that = this;

        this.req.onload = function () {
          that.resume(function () {
            that.assertEquals(200, that.req.status);
          });
        };

        this.req.setDetermineSuccess(function () {
          return SCRIPT_LOADED === true;
        });
        this.request(this.getUrl("qx/test/script.js"));
        this.wait();
      },
      // Error handling
      "test: properties indicate failure when request failed": function testPropertiesIndicateFailureWhenRequestFailed() {
        // Known to fail in legacy IEs
        if (this.isIeBelow(9)) {
          this.skip();
        }

        var that = this,
            req = this.req;

        req.onerror = function () {
          that.resume(function () {
            that.assertEquals(4, req.readyState);
            that.assertEquals(0, req.status);
            that.assertNull(req.statusText);
          });
        };

        this.request("http://fail.tld");
        this.wait(15000);
      },
      "test: properties indicate failure when request timed out": function testPropertiesIndicateFailureWhenRequestTimedOut() {
        // Known to fail in legacy IEs
        if (this.isIeBelow(9)) {
          this.skip();
        }

        var that = this,
            req = this.req;
        req.timeout = 25;

        req.ontimeout = function () {
          that.resume(function () {
            that.assertEquals(4, req.readyState);
            that.assertEquals(0, req.status);
            that.assertNull(req.statusText);
          });
        };

        this.requestPending();
        this.wait();
      },
      "test: status indicates failure when determineSuccess returns false": function testStatusIndicatesFailureWhenDetermineSuccessReturnsFalse() {
        var that = this;

        this.req.onload = function () {
          that.resume(function () {
            that.assertEquals(500, that.req.status);
          });
        };

        this.req.setDetermineSuccess(function () {
          return false;
        });
        this.request();
        this.wait();
      },
      "test: reset XHR properties when reopened": function testResetXHRPropertiesWhenReopened() {
        var req = this.req,
            that = this;

        req.onload = function () {
          that.resume(function () {
            req.open("GET", "/url");
            that.assertIdentical(1, req.readyState);
            that.assertIdentical(0, req.status);
            that.assertIdentical("", req.statusText);
          });
        };

        this.request();
        this.wait();
      },
      //
      // open()
      //
      "test: open() stores URL": function testOpenStoresURL() {
        this.req.open("GET", this.url);
        this.assertEquals(this.url, this.req._getUrl());
      },
      //
      // send()
      //
      "test: send() adds script element to DOM": function testSendAddsScriptElementToDOM() {
        var req = this.req; // Helper triggers send()

        this.request();
        this.assert(this.isInDom(req._getScriptElement()), "Script element not in DOM");
      },
      "test: send() sets script src to URL": function testSendSetsScriptSrcToURL() {
        this.request();
        this.assertMatch(this.req._getScriptElement().src, /qx\/test\/script.js$/);
      },
      "test: send() with data": function testSendWithData() {
        this.skip();
      },
      //
      // abort()
      //
      "test: abort() removes script element": function testAbortRemovesScriptElement() {
        var req = this.req;
        this.requestPending();
        req.abort();
        this.assertFalse(this.isInDom(req._getScriptElement()), "Script element in DOM");
      },
      "test: abort() makes request not fire load": function testAbortMakesRequestNotFireLoad() {
        var req = this.req;
        this.spy(req, "onload");

        if (this.isIe()) {
          this.request(this.noCache(this.url));
        } else {
          this.request();
        }

        req.abort();
        this.wait(300, function () {
          this.assertNotCalled(req.onload);
        }, this);
      },
      //
      // setRequestHeader()
      //
      "test: setRequestHeader() throws error when other than OPENED": function testSetRequestHeaderThrowsErrorWhenOtherThanOPENED() {
        var req = this.req;
        this.assertException(function () {
          req.setRequestHeader();
        }, null, "Invalid state");
      },
      "test: setRequestHeader() appends to URL": function testSetRequestHeaderAppendsToURL() {
        var req = this.req;
        req.open("GET", "/affe");
        req.setRequestHeader("key1", "value1");
        req.setRequestHeader("key2", "value2");
        this.assertMatch(req._getUrl(), /key1=value1/);
        this.assertMatch(req._getUrl(), /key2=value2/);
      },
      //
      // Event handlers
      //
      "test: call onload": function testCallOnload() {
        // More precisely, the request completes when the browser
        // has loaded and parsed the script
        var that = this;

        this.req.onload = function () {
          that.resume(function () {});
        };

        this.request();
        this.wait();
      },
      "test: call onreadystatechange and have appropriate readyState": function testCallOnreadystatechangeAndHaveAppropriateReadyState() {
        var req = this.req,
            readyStates = [],
            that = this;

        req.onreadystatechange = function () {
          readyStates.push(req.readyState);

          if (req.readyState === 4) {
            that.resume(function () {
              that.assertArrayEquals([1, 2, 3, 4], readyStates);
            });
          }
        };

        if (this.isIe()) {
          this.request(this.noCache(this.url));
        } else {
          this.request();
        }

        this.wait();
      },
      // Error handling
      "test: call onloadend on network error": function testCallOnloadendOnNetworkError() {
        var that = this;

        this.req.onloadend = function () {
          that.resume(function () {});
        };

        this.request("http://fail.tld");
        this.wait(15000);
      },
      "test: call onloadend when request completes": function testCallOnloadendWhenRequestCompletes() {
        var that = this;

        this.req.onloadend = function () {
          that.resume(function () {});
        };

        this.request();
        this.wait();
      },
      "test: not call onload when loading failed because of network error": function testNotCallOnloadWhenLoadingFailedBecauseOfNetworkError() {
        // Known to fail in IE < 9,
        // i.e. all browsers using onreadystatechange event handlerattribute
        //
        // After a short delay, readyState progresses to "loaded" even
        // though the resource could not be loaded.
        if (this.isIeBelow(9)) {
          this.skip();
        }

        var that = this;

        this.req.onload = function () {
          that.resume(function () {
            throw Error("Called onload");
          });
        };

        this.req.onerror = function () {
          that.resume();
        };

        this.request("http://fail.tld");
        this.wait(15000);
      },
      "test: call onerror on network error": function testCallOnerrorOnNetworkError() {
        // Known to fail in legacy IEs
        if (this.isIeBelow(9)) {
          this.skip();
        }

        var that = this;

        this.req.onerror = function () {
          that.resume(function () {});
        };

        this.request("http://fail.tld");
        this.wait(15000);
      },
      "test: call onerror on invalid script": function testCallOnerrorOnInvalidScript() {
        // Known to fail in all browsers tested
        // Native "error" event not fired for script element.
        //
        // A possible work-around is to listen to the global "error"
        // event dispatched on the window.
        this.skip();
        var that = this;

        this.req.onerror = function () {
          that.resume(function () {});
        }; // Invalid JavaScript


        this.request(this.getUrl("qx/test/xmlhttp/sample.txt"));
        this.wait();
      },
      "test: not call onerror when request exceeds timeout limit": function testNotCallOnerrorWhenRequestExceedsTimeoutLimit() {
        var req = this.req; // Known to fail in browsers not supporting the error event
        // because timeouts are used to fake the "error"

        if (!this.supportsErrorHandler()) {
          this.skip();
        }

        this.spy(req, "onerror");
        req.timeout = 25;
        this.requestPending();
        this.wait(20, function () {
          this.assertNotCalled(req.onerror);
        }, this);
      },
      "test: call ontimeout when request exceeds timeout limit": function testCallOntimeoutWhenRequestExceedsTimeoutLimit() {
        // Known to fail in legacy IEs
        if (this.isIeBelow(9)) {
          this.skip();
        }

        var that = this;
        this.req.timeout = 25;

        this.req.ontimeout = function () {
          that.resume(function () {});
        };

        this.requestPending();
        this.wait();
      },
      "test: not call ontimeout when request is within timeout limit": function testNotCallOntimeoutWhenRequestIsWithinTimeoutLimit() {
        var req = this.req,
            that = this;
        this.spy(req, "ontimeout");

        req.onload = function () {
          that.resume(function () {
            // Assert that onload() cancels timeout
            that.wait(350, function () {
              that.assertNotCalled(req.ontimeout);
            });
          });
        };

        req.timeout = 300;
        this.request();
        this.wait();
      },
      "test: call onabort when request was aborted": function testCallOnabortWhenRequestWasAborted() {
        var req = this.req;
        this.spy(req, "onabort");
        this.request();
        req.abort();
        this.assertCalled(req.onabort);
      },
      //
      // Clean-Up
      //
      "test: remove script from DOM when request completed": function testRemoveScriptFromDOMWhenRequestCompleted() {
        var script,
            that = this;

        this.req.onload = function () {
          that.resume(function () {
            script = this.req._getScriptElement();
            that.assertFalse(that.isInDom(script));
          });
        };

        this.request();
        this.wait();
      },
      "test: remove script from DOM when request failed": function testRemoveScriptFromDOMWhenRequestFailed() {
        var script,
            that = this; // In IE < 9, "load" is fired instead of "error"

        this.req.onerror = this.req.onload = function () {
          that.resume(function () {
            script = this.req._getScriptElement();
            that.assertFalse(that.isInDom(script));
          });
        };

        this.request("http://fail.tld");
        this.wait(15000);
      },
      "test: remove script from DOM when request timed out": function testRemoveScriptFromDOMWhenRequestTimedOut() {
        // Known to fail in legacy IEs
        if (this.isIeBelow(9)) {
          this.skip();
        }

        var script,
            that = this;
        this.req.timeout = 25;

        this.req.ontimeout = function () {
          that.resume(function () {
            script = that.req._getScriptElement();
            that.assertFalse(that.isInDom(script));
          });
        };

        this.requestPending();
        this.wait();
      },
      request: function request(customUrl) {
        this.req.open("GET", customUrl || this.url, true);
        this.req.send();
      },
      requestPending: function requestPending(sleep) {
        this.require(["php"]);

        var url = this.noCache(this.getUrl("qx/test/jsonp_primitive.php")); // In legacy browser, a long running script request blocks subsequent requests
        // even if the script element is removed. Keep duration very low to work around.
        //
        // Sleep 50ms

        url += "&sleep=" + (sleep || 50);
        this.request(url);
      },
      isInDom: function isInDom(elem) {
        return elem.parentNode ? true : false;
      },
      isIe: function isIe(version) {
        return qx.core.Environment.get("engine.name") === "mshtml";
      },
      isIeBelow: function isIeBelow(version) {
        return qx.core.Environment.get("engine.name") === "mshtml" && qx.core.Environment.get("browser.documentmode") < version;
      },
      supportsErrorHandler: function supportsErrorHandler() {
        var isLegacyIe = qx.core.Environment.get("engine.name") === "mshtml" && qx.core.Environment.get("browser.documentmode") < 9;
        var isOpera = qx.core.Environment.get("engine.name") === "opera";
        return !(isLegacyIe || isOpera);
      },
      noCache: function noCache(url) {
        return url + "?nocache=" + new Date().valueOf();
      },
      skip: function skip(msg) {
        throw new qx.dev.unit.RequirementError(null, msg);
      }
    }
  });
  qx.test.bom.request.Script.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.bom.request.SimpleXhr": {},
      "qx.lang.Json": {},
      "qx.bom.request.Xhr": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.request.SimpleXhr", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock],
    members: {
      setUp: function setUp() {
        this.req = new qx.bom.request.SimpleXhr();
      },
      tearDown: function tearDown() {
        this.req = null;
        this.getSandbox().restore();
      },
      //
      // setRequestHeader()
      // getRequestHeader()
      //
      "test: set/get request header": function testSetGetRequestHeader() {
        var key = "Accept",
            value = "application/json";
        this.assertEquals(value, this.req.setRequestHeader(key, value).getRequestHeader(key));
      },
      //
      // setUrl()
      // getUrl()
      //
      "test: set/get url": function testSetGetUrl() {
        var url = "http://example.org";
        this.assertEquals(url, this.req.setUrl(url).getUrl());
      },
      //
      // setMethod()
      // getMethod()
      //
      "test: set/get method": function testSetGetMethod() {
        var method = "GET";
        this.assertEquals(method, this.req.setMethod(method).getMethod());
      },
      //
      // setRequestData()
      // getRequestData()
      //
      "test: set/get request data": function testSetGetRequestData() {
        var data = {
          "abc": "def",
          "uvw": "xyz"
        };
        this.assertEquals(data, this.req.setRequestData(data).getRequestData());
      },
      //
      // _setResponse()
      // getResponse()
      //
      "test: set/get response": function testSetGetResponse() {
        var req = this.req,
            json = '{"animals": ["monkey", "mouse"]}',
            xml = "<animals><monkey/><mouse/></animals>",
            obj = {
          a: "b"
        };
        req._transport.responseText = json;
        this.assertEquals(json, req.getResponse());
        req._transport.responseXML = xml;
        this.assertEquals(xml, req.getResponse());

        req._setResponse(obj);

        this.assertEquals(obj, req.getResponse());
      },
      //
      // setTimeout()
      // getTimeout()
      //
      "test: set/get timeout in millis": function testSetGetTimeoutInMillis() {
        this.assertEquals(150, this.req.setTimeout(150).getTimeout());
      },
      //
      //  useCaching
      //  isCaching
      //
      "test: use/is caching": function testUseIsCaching() {
        this.assertTrue(this.req.useCaching(true).isCaching());
        this.assertFalse(this.req.useCaching(false).isCaching());
      },
      //
      // setParser()
      //
      "test: set (custom) parser": function testSetCustomParser() {
        var req = this.req,
            acceptedParser = null,
            customParser = function customParser() {};

        acceptedParser = req.setParser(customParser);
        this.assertEquals(customParser, acceptedParser);
      },
      //
      // _serializeData()
      //
      "test: serialize data": function testSerializeData() {
        var data = {
          "abc": "def",
          "uvw": "xyz"
        },
            contentType = "application/json";
        this.assertNull(this.req._serializeData(null));
        this.assertEquals("leaveMeIntact", this.req._serializeData("leaveMeIntact"));
        this.assertEquals("abc=def&uvw=xyz", this.req._serializeData(data));
        this.assertEquals("abc=def&uvw=xyz", this.req._serializeData(data, "arbitrary/contentType"));
        this.assertEquals('{"abc":"def","uvw":"xyz"}', this.req._serializeData(data, contentType));
        this.assertEquals('[1,2,3]', this.req._serializeData([1, 2, 3], contentType));
      },
      //
      // send()
      //
      stubTransportMethods: function stubTransportMethods(methods) {
        var stubbedTransport = this.req._createTransport(),
            l = methods.length;

        while (l--) {
          this.stub(stubbedTransport, methods[l]);
        }

        this.req._transport = stubbedTransport;
        return stubbedTransport;
      },
      "test: send() w/ timeout": function testSendWTimeout() {
        var req = this.req,
            method = "GET",
            url = "http://example.org",
            stubbedTransport = {};
        req.setUrl(url);
        req.setTimeout(150);
        stubbedTransport = this.stubTransportMethods(["open", "send"]);
        req.send();
        this.assertCalledWith(stubbedTransport.open, method, url, true);
        this.assertCalledWith(stubbedTransport.send);
        this.assertEquals(stubbedTransport.timeout, req.getTimeout());
      },
      "test: send() w/o data and w/o headers": function testSendWODataAndWOHeaders() {
        var req = this.req,
            method = "GET",
            url = "http://example.org",
            stubbedTransport = {};
        req.setUrl(url);
        stubbedTransport = this.stubTransportMethods(["open", "send"]);
        req.send();
        this.assertCalledWith(stubbedTransport.open, method, url, true);
        this.assertCalledWith(stubbedTransport.send);
      },
      "test: send() GET w/ data and w/ headers": function testSendGETWDataAndWHeaders() {
        var req = this.req,
            method = "GET",
            url = "http://example.org",
            obj = {
          a: "b"
        },
            stubbedTransport = {};
        req.setUrl(url);
        req.setRequestHeader("Accept", "application/json");
        req.setRequestData(obj);
        stubbedTransport = this.stubTransportMethods(["open", "setRequestHeader", "send"]);
        req.send();
        this.assertCalledWith(stubbedTransport.open, method, url + "?a=b", true);
        this.assertCalledWith(stubbedTransport.setRequestHeader, "Accept", "application/json");
        this.assertCalledWith(stubbedTransport.send);
      },
      "test: send() GET w/ enabled caching sets nocache param": function testSendGETWEnabledCachingSetsNocacheParam() {
        var req = this.req,
            method = "GET",
            url = "http://example.org",
            expectedUrl = new RegExp(url + "\\?nocache=[0-9]{13,}"),
            stubbedTransport = {};
        req.setUrl(url);
        req.useCaching(false);
        stubbedTransport = this.stubTransportMethods(["open", "send"]);
        req.send();
        this.assertCalledWithMatch(stubbedTransport.open, method, expectedUrl, true);
        this.assertCalledWith(stubbedTransport.send);
      },
      "test: send() GET w/ caching header overrides cache prevention": function testSendGETWCachingHeaderOverridesCachePrevention() {
        var req = this.req,
            method = "GET",
            url = "http://example.org",
            stubbedTransport = {};
        req.setUrl(url);
        req.setRequestHeader("Cache-Control", "no-cache");
        stubbedTransport = this.stubTransportMethods(["open", "setRequestHeader", "send"]);
        req.send();
        this.assertCalledWith(stubbedTransport.open, method, url, true);
        this.assertCalledWith(stubbedTransport.setRequestHeader, "Cache-Control", "no-cache");
        this.assertCalledWith(stubbedTransport.send);
      },
      "test: send() POST w/ data (default content-type)": function testSendPOSTWDataDefaultContentType() {
        var req = this.req,
            method = "POST",
            url = "http://example.org",
            obj = {
          a: "b"
        },
            stubbedTransport = {};
        req.setUrl(url);
        req.setMethod(method);
        req.setRequestData(obj);
        stubbedTransport = this.stubTransportMethods(["open", "setRequestHeader", "send"]);
        req.send();
        this.assertCalledWith(stubbedTransport.open, method, url, true);
        this.assertCalledWith(stubbedTransport.setRequestHeader, "Content-Type", "application/x-www-form-urlencoded");
        this.assertCalledWith(stubbedTransport.send, "a=b");
      },
      "test: send() POST w/ data (application/json)": function testSendPOSTWDataApplicationJson() {
        var req = this.req,
            method = "POST",
            url = "http://example.org",
            obj = {
          a: "b"
        },
            stubbedTransport = {};
        req.setUrl(url);
        req.setMethod(method);
        req.setRequestData(obj);
        req.setRequestHeader("Content-Type", "application/json");
        stubbedTransport = this.stubTransportMethods(["open", "setRequestHeader", "send"]);
        req.send();
        this.assertCalledWith(stubbedTransport.open, method, url, true);
        this.assertCalledWith(stubbedTransport.send, qx.lang.Json.stringify(obj));
      },
      "test: send() POST w/ FormData": function testSendPOSTWFormData() {
        var req = this.req,
            method = "POST",
            url = "http://example.org",
            stubbedTransport = {};

        if (!window.FormData) {
          this.skip("FormData API not supported");
        }

        if (!req.setMethod) {
          this.skip("POST requests not supported by this transport");
        }

        var formData = new FormData();
        formData.append("foo", "bar");
        formData.append("baz", "qux");
        req.setUrl(url);
        req.setMethod(method);
        req.setRequestData(formData);
        stubbedTransport = this.stubTransportMethods(["open", "setRequestHeader", "send"]);
        req.send();
        this.assertCalledWith(stubbedTransport.send, formData);
      },
      "test: send() POST w/ Blob": function testSendPOSTWBlob() {
        var req = this.req,
            method = "POST",
            url = "http://example.org",
            stubbedTransport = {};

        if (!window.Blob) {
          this.skip("Blob API not supported");
        }

        if (!req.setMethod) {
          this.skip("POST requests not supported by this transport");
        }

        var blob = new window.Blob(['abc123'], {
          type: 'text/plain'
        });
        req.setUrl(url);
        req.setMethod(method);
        req.setRequestData(blob);
        stubbedTransport = this.stubTransportMethods(["open", "setRequestHeader", "send"]);
        req.send();
        this.assertCalledWith(stubbedTransport.send, blob);
      },
      "test: send() POST w/ ArrayBuffer": function testSendPOSTWArrayBuffer() {
        var req = this.req,
            method = "POST",
            url = "http://example.org",
            stubbedTransport = {};

        if (!window.ArrayBuffer) {
          this.skip("ArrayBuffer API not supported");
        }

        if (!req.setMethod) {
          this.skip("POST requests not supported by this transport");
        }

        var arrayBuffer = new window.ArrayBuffer(512);
        req.setUrl(url);
        req.setMethod(method);
        req.setRequestData(arrayBuffer);
        stubbedTransport = this.stubTransportMethods(["open", "setRequestHeader", "send"]);
        req.send();
        this.assertCalledWith(stubbedTransport.send, arrayBuffer);
      },
      //
      // abort()
      //
      "test: abort() aborts transport": function testAbortAbortsTransport() {
        var stubbedTransport = this.stubTransportMethods(["abort"]);
        this.req.abort();
        this.assertCalled(stubbedTransport.abort);
      },
      //
      // dispose()
      //
      "test: dispose() disposes transport": function testDisposeDisposesTransport() {
        this.assertTrue(this.req.dispose());
      },
      //
      // addListenerOnce()
      //
      "test: addListenerOnce() event handler": function testAddListenerOnceEventHandler() {
        var req = this.req,
            stubbedTransport = this.req._createTransport(),
            name = "test-success",
            listener = function listener() {},
            ctx = this;

        this.stub(req, "once");
        req._transport = stubbedTransport;
        req.addListenerOnce(name, listener, ctx);
        this.assertCalledWith(req.once, name, listener, ctx);
      },
      //
      // _onReadyStateChange()
      // __onReadyStateDone()
      //
      "test: _onReadyStateDone() success": function test_onReadyStateDoneSuccess() {
        var req = this.req,
            json = '{"animals": ["monkey", "mouse"]}',
            obj = {
          animals: ["monkey", "mouse"]
        },
            contentType = "application/json",
            stubbedTransport = req._createTransport(); // prep transport


        this.stub(req, "emit");
        this.stub(stubbedTransport, "getResponseHeader").returns(contentType);
        req._transport = req._registerTransportListener(stubbedTransport);
        req._transport.readyState = qx.bom.request.Xhr.DONE;
        req._transport.responseText = json;
        req._transport.status = 200;

        req._transport.onreadystatechange();

        this.assertArrayEquals(obj.animals, req.getResponse().animals);
        this.assertCalledWith(req.emit, "success");
      },
      "test: _onReadyStateDone() fail w/ response": function test_onReadyStateDoneFailWResponse() {
        var req = this.req,
            json = '{"animals": ["monkey", "mouse"]}',
            obj = {
          animals: ["monkey", "mouse"]
        },
            contentType = "application/json",
            stubbedTransport = req._createTransport(); // prep transport


        this.stub(req, "emit");
        this.stub(stubbedTransport, "getResponseHeader").returns(contentType);
        req._transport = req._registerTransportListener(stubbedTransport);
        req._transport.readyState = qx.bom.request.Xhr.DONE;
        req._transport.responseText = json;
        req._transport.status = 404;

        req._transport.onreadystatechange();

        this.assertArrayEquals(obj.animals, req.getResponse().animals);
        this.assertCalledWith(req.emit, "fail");
      },
      "test: _onReadyStateDone() fail w/o response": function test_onReadyStateDoneFailWOResponse() {
        var req = this.req,
            contentType = "hasToExist/ButContentDoesntMatter",
            stubbedTransport = req._createTransport(); // prep transport


        this.stub(req, "emit");
        this.stub(stubbedTransport, "getResponseHeader").returns(contentType);
        req._transport = req._registerTransportListener(stubbedTransport);
        req._transport.readyState = qx.bom.request.Xhr.DONE;
        req._transport.status = 404;

        req._transport.onreadystatechange();

        this.assertEquals("", req.getResponse());
        this.assertCalledWith(req.emit, "fail");
      },
      //
      // onLoadEnd()
      //
      "test: onLoadEnd()": function testOnLoadEnd() {
        var req = this.req,
            stubbedTransport = req._createTransport(); // prep transport


        this.stub(req, "emit");
        req._transport = req._registerTransportListener(stubbedTransport);

        req._transport.onloadend();

        this.assertCalledWith(req.emit, "loadEnd");
      },
      //
      // onAbort()
      //
      "test: onAbort()": function testOnAbort() {
        var req = this.req,
            stubbedTransport = req._createTransport(); // prep transport


        this.stub(req, "emit");
        req._transport = req._registerTransportListener(stubbedTransport);

        req._transport.onabort();

        this.assertCalledWith(req.emit, "abort");
      },
      //
      // onTimeout()
      //
      "test: onTimeout()": function testOnTimeout() {
        var req = this.req,
            stubbedTransport = req._createTransport(); // prep transport


        this.stub(req, "emit");
        req._transport = req._registerTransportListener(stubbedTransport);

        req._transport.ontimeout();

        this.assertCalledWith(req.emit, "timeout");
        this.assertEquals(2, req.emit.callCount); // + emit("fail")
      },
      //
      // onError()
      //
      "test: onError()": function testOnError() {
        var req = this.req,
            stubbedTransport = req._createTransport(); // prep transport


        this.stub(req, "emit");
        req._transport = req._registerTransportListener(stubbedTransport);

        req._transport.onerror();

        this.assertCalledWith(req.emit, "error");
        this.assertEquals(2, req.emit.callCount); // + emit("fail")
      },
      testGetResponseHeaders: function testGetResponseHeaders() {
        this.useFakeServer();
        this.getServer().autoRespond = true;
        this.getServer().respondWith("GET", "/foo", [200, {
          "x-affe": "AFFE"
        }, "Response Body"]);
        var req = new qx.bom.request.SimpleXhr('/foo', 'GET');
        req.on("success", function () {
          this.resume(function () {
            this.assertEquals("AFFE", req.getResponseHeader("x-affe"));
            var headers = req.getAllResponseHeaders();
            this.assertMatch(headers, /x-affe.*?AFFE/);
          }.bind(this));
        }.bind(this));
        window.setTimeout(function () {
          req.send();
        }, 100);
        this.wait(200);
      }
    }
  });
  qx.test.bom.request.SimpleXhr.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.request.Xhr": {},
      "qx.bom.client.Engine": {},
      "qx.lang.Function": {},
      "qx.bom.client.Browser": {},
      "qx.dev.unit.RequirementError": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "engine.version": {
          "className": "qx.bom.client.Engine"
        },
        "browser.version": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.request.Xhr", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock, qx.dev.unit.MRequirements],
    statics: {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    },
    members: {
      /**
       * The faked XMLHttpRequest.
       */
      fakedXhr: null,

      /**
       * Holds instances created by the faked XMLHttpRequest.
       */
      fakeReqs: null,

      /**
       * The request to test.
       */
      req: null,
      setUp: function setUp() {
        this.fakeNativeXhr();
        this.req = new qx.bom.request.Xhr();
      },
      tearDown: function tearDown() {
        this.req = null;
        this.getSandbox().restore();
      },
      //
      // General
      //
      "test: create instance": function testCreateInstance() {
        this.assertObject(this.req);
      },
      "test: detect native XHR": function testDetectNativeXHR() {
        var nativeXhr = this.req.getRequest();
        this.assertObject(nativeXhr);
        this.assertNotNull(nativeXhr.readyState);
      },
      //
      // open()
      //
      "test: open request": function testOpenRequest() {
        var fakeReq = this.getFakeReq();
        this.spy(fakeReq, "open");
        var url = "/foo";
        var method = "GET";
        this.req.open(method, url);
        this.assertCalledWith(fakeReq.open, method, url);
      },
      "test: open request throws when missing arguments": function testOpenRequestThrowsWhenMissingArguments() {
        var req = this.req;
        var msg = /Not enough arguments/;
        this.assertException(function () {
          req.open();
        }, Error, msg);
        this.assertException(function () {
          req.open("GET");
        }, Error, msg);
      },
      "test: open async request on default": function testOpenAsyncRequestOnDefault() {
        var fakeReq = this.getFakeReq();
        this.spy(fakeReq, "open");
        this.req.open(null, null);
        this.assertTrue(fakeReq.open.args[0][2], "async must be true");
      },
      "test: open sync request": function testOpenSyncRequest() {
        var fakeReq = this.getFakeReq();
        this.spy(fakeReq, "open");
        this.req.open(null, null, false);
        this.assertFalse(fakeReq.open.args[0][2], "async must be false");
      },
      "test: open request with username and password": function testOpenRequestWithUsernameAndPassword() {
        var fakeReq = this.getFakeReq();
        this.spy(fakeReq, "open");
        this.req.open(null, null, null, "affe", "geheim");
        this.assertEquals("affe", fakeReq.open.args[0][3], "Unexpected user");
        this.assertEquals("geheim", fakeReq.open.args[0][4], "Unexpected password");
      },
      //
      // setRequestHeader()
      //
      "test: set request header": function testSetRequestHeader() {
        var fakeReq = this.getFakeReq();
        this.spy(fakeReq, "setRequestHeader"); // Request must be opened before request headers can be set

        this.req.open("GET", "/");
        this.req.setRequestHeader("header", "value");
        this.assertCalledWith(fakeReq.setRequestHeader, "header", "value");
      },
      //
      // send()
      //
      "test: send() with data": function testSendWithData() {
        var fakeReq = this.getFakeReq();
        this.spy(fakeReq, "send");
        var data = "AFFE";
        this.req.open("GET", "/affe");
        this.req.send(data);
        this.assertCalledWith(fakeReq.send, data);
      },
      // BUGFIXES
      "test: send() without data": function testSendWithoutData() {
        var fakeReq = this.getFakeReq();
        this.spy(fakeReq, "send");
        this.req.open("GET", "/affe");
        this.req.send();
        this.assertCalledWith(fakeReq.send, null);
      },
      //
      // abort()
      //
      "test: abort() aborts native Xhr": function testAbortAbortsNativeXhr() {
        var req = this.req;
        var fakeReq = this.getFakeReq();
        this.spy(fakeReq, "abort");
        req.abort();
        this.assertCalled(fakeReq.abort);
      },
      "test: abort() resets readyState": function testAbortResetsReadyState() {
        var req = this.req;
        req.open("GET", "/");
        req.abort();
        this.assertEquals(this.constructor.UNSENT, req.readyState, "Must be UNSENT");
      },
      //
      // Event helper
      //
      "test: call event handler": function testCallEventHandler() {
        var req = this.req;
        req.onevent = this.spy();

        req._emit("event");

        this.assertCalled(req.onevent);
      },
      "test: fire event": function testFireEvent() {
        var req = this.req;
        var event = this.spy();
        req.onevent = this.spy();
        req.on("event", event);

        req._emit("event");

        this.assertCalled(event);
      },
      //
      //
      // onreadystatechange()
      //
      "test: responseText set before onreadystatechange is called": function testResponseTextSetBeforeOnreadystatechangeIsCalled() {
        var req = this.req;
        var fakeReq = this.getFakeReq();
        var that = this;

        req.onreadystatechange = function () {
          that.assertEquals("Affe", req.responseText);
        };

        fakeReq.responseText = "Affe";
        fakeReq.readyState = 4;
        fakeReq.responseHeaders = {};
        fakeReq.onreadystatechange();
      },
      "test: emit readystatechange when reopened": function testEmitReadystatechangeWhenReopened() {
        var req = this.req;
        var fakeReq = this.getFakeReq();
        this.stub(req, "_emit"); // Send and respond

        req.open("GET", "/");
        req.send();
        fakeReq.respond(); // Reopen

        req.open("GET", "/");
        this.assertCalledWith(req._emit, "readystatechange");
      },
      // BUGFIXES
      "test: ignore onreadystatechange when readyState is unchanged": function testIgnoreOnreadystatechangeWhenReadyStateIsUnchanged() {
        var req = this.req;
        var fakeReq = this.getFakeReq();
        this.spy(req, "onreadystatechange");
        req.readyState = this.constructor.OPENED;
        fakeReq.onreadystatechange();
        fakeReq.onreadystatechange();
        this.assertCalledOnce(req.onreadystatechange);
      },
      "test: native onreadystatechange is disposed once DONE": function testNativeOnreadystatechangeIsDisposedOnceDONE() {
        var req = this.req;
        var fakeReq = this.getFakeReq();

        req.onreadystatechange = function () {
          return "OP";
        };

        req.open("GET", "/");
        req.send();
        fakeReq.respond();
        this.assertUndefined(req.getRequest().onreadystatechange());
      },
      //
      // onload()
      //
      "test: emit load on successful request": function testEmitLoadOnSuccessfulRequest() {
        var req = this.req;
        var fakeReq = this.getFakeReq();
        this.stub(req._emitter, "emit");
        req.open("GET", "/");
        req.send(); // Status does not matter. Set a non-empty response for file:// workaround.

        fakeReq.respond(200, {}, "RESPONSE");
        this.assertCalledWith(req._emitter.emit, "load");
        this.assertEquals(6, req._emitter.emit.callCount);
      },
      //
      // onerror()
      //
      // See XhrWithBackend
      //
      //
      // onabort()
      //
      "test: emit abort": function testEmitAbort() {
        var req = this.req;
        this.spy(req, "_emit");
        req.open("GET", "/");
        req.send();
        req.abort();
        this.assertCalledWith(req._emit, "abort");
      },
      "test: emit abort before loadend": function testEmitAbortBeforeLoadend() {
        var req = this.req;
        var emit = this.stub(req, "_emit");
        var abort = emit.withArgs("abort");
        var loadend = emit.withArgs("loadend");
        req.open("GET", "/");
        req.send();
        req.abort();
        this.assertCallOrder(abort, loadend);
      },
      //
      // ontimeout()
      //
      "test: emit timeout": function testEmitTimeout() {
        var req = this.req,
            that = this;
        var timeout = this.stub(req, "_emit").withArgs("timeout");
        req.timeout = 10;
        req.open("GET", "/");
        req.send();
        this.wait(20, function () {
          this.assertCalledOnce(timeout);
        }, this);
      },
      "test: not emit error when timeout": function testNotEmitErrorWhenTimeout() {
        // Since Opera does not fire "error" on network error, fire additional
        // "error" on timeout (may well be related to network error)
        if (qx.core.Environment.get("engine.name") === "opera") {
          this.skip();
        }

        var req = this.req;
        var error = this.stub(req, "_emit").withArgs("error");
        req.timeout = 10;
        req.open("GET", "/");
        req.send();
        this.wait(20, function () {
          this.assertNotCalled(error);
        }, this);
      },
      "test: not emit error when aborted immediately": function testNotEmitErrorWhenAbortedImmediately() {
        var req = this.req;
        var error = this.stub(req, "_emit").withArgs("error");
        req.open("GET", "/");
        req.send();
        req.abort();
        this.assertNotCalled(error);
      },
      "test: cancel timeout when DONE": function testCancelTimeoutWhenDONE() {
        var fakeReq = this.getFakeReq(),
            req = this.req;
        this.spy(req, "ontimeout");
        req.timeout = 10;
        req.open("GET", "/");
        req.send();
        fakeReq.respond();
        this.wait(20, function () {
          this.assertNotCalled(req.ontimeout);
        }, this);
      },
      "test: cancel timeout when handler throws": function testCancelTimeoutWhenHandlerThrows() {
        var fakeReq = this.getFakeReq(),
            req = this.req;
        this.spy(req, "ontimeout");
        req.timeout = 10;
        req.open("GET", "/");
        req.send(); // Simulate error in handler for readyState DONE

        req.onreadystatechange = function () {
          if (req.readyState === 4) {
            // Throw only once
            req.onreadystatechange = function () {};

            throw new Error();
          }
        };

        try {
          fakeReq.respond();
        } catch (e) {} finally {
          this.wait(20, function () {
            this.assertNotCalled(req.ontimeout);
          }, this);
        }
      },
      //
      // onloadend()
      //
      "test: fire loadend when request complete": function testFireLoadendWhenRequestComplete() {
        var req = this.req;
        var fakeReq = this.getFakeReq();
        var loadend = this.stub(req, "_emit").withArgs("loadend");
        req.open("GET", "/");
        req.send(); // Status does not matter

        fakeReq.respond();
        this.assertCalled(loadend);
      },
      //
      // Events
      //
      //
      // readyState
      //
      "test: set readyState appropriate to native readyState": function testSetReadyStateAppropriateToNativeReadyState() {
        var req = this.req;
        var fakeReq = this.getFakeReq(); // Created

        this.assertEquals(this.constructor.UNSENT, req.readyState); // Open

        req.open("GET", "/affe");
        this.assertEquals(this.constructor.OPENED, req.readyState); // Send (and receive)

        req.send();
        fakeReq.respond(this.constructor.DONE);
        this.assertEquals(this.constructor.DONE, req.readyState);
      },
      //
      // responseText
      //
      "test: responseText is empty string when OPEN": function testResponseTextIsEmptyStringWhenOPEN() {
        this.req.open("GET", "/affe");
        this.assertIdentical("", this.req.responseText);
      },
      "test: responseText is empty string when reopened": function testResponseTextIsEmptyStringWhenReopened() {
        var fakeReq = this.getFakeReq(); // Send and respond

        var req = this.req;
        req.open("GET", "/");
        req.send();
        fakeReq.respond(200, {
          "Content-Type": "text/html"
        }, "Affe"); // Reopen

        req.open("GET", "/elefant");
        this.assertIdentical("", req.responseText);
      },
      "test: responseText is set when DONE": function testResponseTextIsSetWhenDONE() {
        var req = this.req;
        var fakeReq = this.getFakeReq();
        req.open("GET", "/");
        req.send();
        fakeReq.respond(200, {
          "Content-Type": "text/html"
        }, "Affe");
        this.assertEquals("Affe", req.responseText);
      },
      // BUGFIXES
      "test: query responseText when available": function testQueryResponseTextWhenAvailable() {
        var that = this;
        var req = this.req;
        var fakeReq = this.getFakeReq();

        function success(state) {
          // Stub and prepare success
          fakeReq.readyState = state;
          fakeReq.responseText = "YIPPIE";
          fakeReq.responseHeaders = {}; // Trigger readystatechange handler

          fakeReq.onreadystatechange();
          that.assertEquals("YIPPIE", req.responseText, "When readyState is " + state);
        }

        success(this.constructor.DONE); // Assert responseText to be set when in progress
        // in browsers other than IE < 9

        if (!this.isIEBelow(9)) {
          success(this.constructor.HEADERS_RECEIVED);
          success(this.constructor.LOADING);
        }
      },
      "test: not query responseText if unavailable": function testNotQueryResponseTextIfUnavailable() {
        var that = this;
        var req = this.req;
        var fakeReq = this.getFakeReq();

        function trap(state) {
          // Stub and set trap
          fakeReq.readyState = state;
          fakeReq.responseText = "BOGUS"; // Trigger readystatechange handler

          fakeReq.onreadystatechange();
          that.assertNotEquals("BOGUS", req.responseText, "When readyState is " + state);
        }

        if (this.isIEBelow(9)) {
          trap(this.constructor.UNSENT);
          trap(this.constructor.OPENED);
          trap(this.constructor.HEADERS_RECEIVED);
          trap(this.constructor.LOADING);
        }
      },
      //
      // responseXML
      //
      "test: responseXML is null when not DONE": function testResponseXMLIsNullWhenNotDONE() {
        this.assertNull(this.req.responseXML);
      },
      "test: responseXML is null when reopened": function testResponseXMLIsNullWhenReopened() {
        var fakeReq = this.getFakeReq(); // Send and respond

        var req = this.req;
        req.open("GET", "/");
        req.send();
        fakeReq.respond(200, {
          "Content-Type": "application/xml"
        }, "<affe></affe>"); // Reopen

        req.open("GET", "/");
        this.assertNull(req.responseXML);
      },
      "test: responseXML is parsed document with XML response": function testResponseXMLIsParsedDocumentWithXMLResponse() {
        var req = this.req;
        var fakeReq = this.getFakeReq();
        req.open("GET", "/");
        req.send();
        var headers = {
          "Content-Type": "application/xml"
        };
        var body = "<animals><monkey/><mouse/></animals>";
        fakeReq.respond(200, headers, body);
        this.assertObject(req.responseXML);
      },
      //
      // status and statusText
      //
      "test: http status is 0 when UNSENT": function testHttpStatusIs0WhenUNSENT() {
        this.assertIdentical(0, this.req.status);
      },
      "test: http status is 0 when OPENED": function testHttpStatusIs0WhenOPENED() {
        var req = this.req;
        req.open("GET", "/");
        this.assertIdentical(0, req.status);
      },
      "test: http status is 0 when aborted immediately": function testHttpStatusIs0WhenAbortedImmediately() {
        this.require(["http"]);

        var req = this.req;
        req.open("GET", "/");
        req.send();
        req.abort();
        this.assertIdentical(0, req.status);
      },
      "test: http status when DONE": function testHttpStatusWhenDONE() {
        var req = this.req;
        var fakeReq = this.getFakeReq();
        req.open("GET", "/");
        fakeReq.respond(200);
        this.assertIdentical(200, req.status);
      },
      "test: statusText is empty string when UNSENT": function testStatusTextIsEmptyStringWhenUNSENT() {
        this.assertIdentical("", this.req.statusText);
      },
      "test: statusText is set when DONE": function testStatusTextIsSetWhenDONE() {
        var fakeReq = this.getFakeReq();
        var req = this.req;
        req.open("GET", "/");
        fakeReq.respond(200);
        this.assertIdentical("OK", req.statusText);
      },
      "test: status is set when LOADING": function testStatusIsSetWhenLOADING() {
        var fakeReq = this.getFakeReq();
        var req = this.req;
        req.open("GET", "/");
        fakeReq.readyState = this.constructor.LOADING;
        fakeReq.status = 200;
        fakeReq.responseHeaders = {};
        fakeReq.onreadystatechange();
        this.assertIdentical(200, req.status);
      },
      "test: reset status when reopened": function testResetStatusWhenReopened() {
        var fakeReq = this.getFakeReq();
        var req = this.req;
        req.open("GET", "/");
        fakeReq.respond(200);
        req.open("GET", "/");
        this.assertIdentical(0, req.status);
        this.assertIdentical("", req.statusText);
      },
      // BUGFIXES
      "test: normalize status 1223 to 204": function testNormalizeStatus1223To204() {
        var fakeReq = this.getFakeReq();
        var req = this.req;
        req.open("GET", "/");
        req.send();
        fakeReq.respond(1223);
        this.assertIdentical(204, req.status);
      },
      "test: normalize status 0 to 200 when DONE and file protocol": function testNormalizeStatus0To200WhenDONEAndFileProtocol() {
        var fakeReq = this.getFakeReq();
        var req = this.req;
        req.open("GET", "/");
        req.send();
        this.stub(req, "_getProtocol").returns("file:");
        fakeReq.respond(0, {}, "Response");
        this.assertEquals(200, req.status);
      },
      "test: keep status 0 when not yet DONE and file protocol": function testKeepStatus0WhenNotYetDONEAndFileProtocol() {
        var fakeReq = this.getFakeReq();
        var req = this.req;
        this.stub(req, "_getProtocol").returns("file:");
        req.open("GET", "/");
        fakeReq.readyState = 3;
        fakeReq.onreadystatechange();
        this.assertEquals(0, req.status);
      },
      "test: keep status 0 when DONE with network error and file protocol": function testKeepStatus0WhenDONEWithNetworkErrorAndFileProtocol() {
        var fakeReq = this.getFakeReq();
        var req = this.req;
        req.open("GET", "/");
        req.send();
        this.stub(req, "_getProtocol").returns("file:"); // Indicate network error

        fakeReq.readyState = 4;
        fakeReq.responseText = "";
        fakeReq.onreadystatechange();
        this.assertEquals(0, req.status);
      },
      //
      // _getProtocol()
      //
      "test: read protocol from requested URL when it contains protocol": function testReadProtocolFromRequestedURLWhenItContainsProtocol() {
        var req = this.req;
        req.open("GET", "http://example.org/index.html");
        this.assertEquals("http:", req._getProtocol());
      },
      "test: read protocol from window if requested URL is without protocol": function testReadProtocolFromWindowIfRequestedURLIsWithoutProtocol() {
        this.require(["http"]);

        var req = this.req;
        req.open("GET", "index.html");
        this.assertMatch(req._getProtocol(), /https?:/);
      },
      //
      // getResponseHeader()
      //
      "test: getResponseHeader()": function testGetResponseHeader() {
        var fakeReq = this.getFakeReq();
        fakeReq.open();
        fakeReq.setResponseHeaders({
          "key": "value"
        });
        var responseHeader = this.req.getResponseHeader("key");
        this.assertEquals("value", responseHeader);
      },
      //
      // getAllResponseHeaders()
      //
      "test: getAllResponseHeaders()": function testGetAllResponseHeaders() {
        var fakeReq = this.getFakeReq();
        fakeReq.open();
        fakeReq.setResponseHeaders({
          "key1": "value1",
          "key2": "value2"
        });
        var responseHeaders = this.req.getAllResponseHeaders();
        this.assertMatch(responseHeaders, /key1: value1/);
        this.assertMatch(responseHeaders, /key2: value2/);
      },
      //
      // dispose()
      //
      "test: dispose() deletes native Xhr": function testDisposeDeletesNativeXhr() {
        this.req.dispose();
        this.assertNull(this.req.getRequest());
      },
      "test: dispose() aborts": function testDisposeAborts() {
        var req = this.req;
        this.spy(req, "abort");
        this.req.dispose();
        this.assertCalled(req.abort);
      },
      "test: isDisposed()": function testIsDisposed() {
        this.assertFalse(this.req.isDisposed());
        this.req.dispose();
        this.assertTrue(this.req.isDisposed());
      },
      "test: invoking public method throws when disposed": function testInvokingPublicMethodThrowsWhenDisposed() {
        var req = this.req;
        var assertDisposedException = qx.lang.Function.bind(function (callback) {
          this.assertException(qx.lang.Function.bind(callback, this), Error, /Already disposed/);
        }, this);
        this.req.dispose();
        assertDisposedException(function () {
          req.open("GET", "/");
        });
        assertDisposedException(function () {
          req.setRequestHeader();
        });
        assertDisposedException(function () {
          req.send();
        });
        assertDisposedException(function () {
          req.abort();
        });
        assertDisposedException(function () {
          req.getResponseHeader();
        });
        assertDisposedException(function () {
          req.getAllResponseHeaders();
        });
      },
      fakeNativeXhr: function fakeNativeXhr() {
        this.fakedXhr = this.useFakeXMLHttpRequest(); // Reset pre-existing request so that it uses the faked XHR

        if (this.req) {
          this.req = new qx.bom.request.Xhr();
        }
      },
      getFakeReq: function getFakeReq() {
        return this.getRequests().slice(-1)[0];
      },
      isIEBelow: function isIEBelow(targetVersion) {
        var name = qx.core.Environment.get("engine.name");
        var version = qx.core.Environment.get("engine.version");
        return name == "mshtml" && version < targetVersion;
      },
      isFFBelow: function isFFBelow(targetVersion) {
        var name = qx.core.Environment.get("engine.name");
        var version = qx.core.Environment.get("browser.version");
        return name == "gecko" && parseFloat(version) < targetVersion;
      },
      hasIEBelow9: function hasIEBelow9() {
        return this.isIEBelow(9);
      },
      skip: function skip(msg) {
        throw new qx.dev.unit.RequirementError(null, msg);
      }
    }
  });
  qx.test.bom.request.Xhr.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "construct": true,
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.request.Xhr": {},
      "qx.event.Timer": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/xmlhttp/*)
   */
  qx.Class.define("qx.test.bom.request.XhrWithRemote", {
    extend: qx.dev.unit.TestCase,
    include: [qx.test.io.MRemoteTest, qx.dev.unit.MMock, qx.dev.unit.MRequirements],
    construct: function construct() {
      qx.dev.unit.TestCase.constructor.call(this);
    },
    members: {
      req: null,
      setUp: function setUp() {
        this.req = new qx.bom.request.Xhr();
      },
      tearDown: function tearDown() {
        this.req.dispose();
      },
      //
      // Basic
      //
      "test: GET with event attribute handler": function testGETWithEventAttributeHandler() {
        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/sample.txt");
        req.open("GET", this.noCache(url));
        var that = this;

        req.onreadystatechange = function () {
          if (req.readyState == 4) {
            that.resume(function () {
              that.assertEquals(req.responseText, "SAMPLE");
            });
          }
        };

        req.send();
        this.wait();
      },
      "test: GET with event": function testGETWithEvent() {
        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/sample.txt");
        req.open("GET", this.noCache(url));
        var that = this;

        var onreadystatechange = function onreadystatechange() {
          if (req.readyState == 4) {
            that.resume(function () {
              that.assertEquals(req.responseText, "SAMPLE");
            });
          }
        };

        req.on("readystatechange", onreadystatechange);
        req.send();
        this.wait();
      },
      "test: GET XML": function testGETXML() {
        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/sample.xml");
        req.open("GET", this.noCache(url));
        var that = this;

        req.onreadystatechange = function () {
          if (req.readyState == 4) {
            that.resume(function () {
              that.assertObject(req.responseXML.documentElement, "Must be XML object");
            });
          }
        };

        req.send();
        this.wait();
      },
      "test: handle arbitrary XML": function testHandleArbitraryXML() {
        this.require(["php"]); // Content-Type: foo/bar+xml


        var url = this.getUrl("qx/test/xmlhttp/xml.php");
        var req = this.req;
        req.open("GET", this.noCache(url));
        var that = this;

        req.onreadystatechange = function () {
          if (req.readyState == 4) {
            that.resume(function () {
              that.assertObject(req.responseXML.documentElement, "Must be XML object");
            });
          }
        };

        req.send();
        this.wait();
      },
      "test: handle invalid XML": function testHandleInvalidXML() {
        var url = this.getUrl("qx/test/xmlhttp/invalid.xml"),
            req = this.req,
            that = this;

        req.onreadystatechange = function () {
          if (req.readyState == 4) {
            that.resume(function () {
              req.responseXML;
            });
          }
        };

        req.open("GET", url);
        req.send();
        this.wait();
      },
      "test: POST": function testPOST() {
        this.require(["php"]);

        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/echo_post_request.php");
        req.open("POST", this.noCache(url));
        req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        var that = this;

        req.onreadystatechange = function () {
          if (req.readyState == 4) {
            that.resume(function () {
              that.assertEquals('{"affe":"true"}', req.responseText);
            });
          }
        };

        req.send("affe=true");
        this.wait();
      },
      "test: have readyState UNSENT": function testHaveReadyStateUNSENT() {
        var req = this.req;
        this.assertIdentical(0, req.readyState);
      },
      "test: have readyState OPENED": function testHaveReadyStateOPENED() {
        this.require(["php"]);

        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/echo_post_request.php");
        req.open("GET", this.noCache(url));
        this.assertIdentical(1, req.readyState);
      },
      "test: abort pending request": function testAbortPendingRequest() {
        this.require(["php"]);

        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/echo_get_request.php");
        req.open("GET", this.noCache(url));
        req.abort();
        this.assertNotEquals(4, req.readyState, "Request must not complete");
      },
      "test: have status 200 when modified": function testHaveStatus200WhenModified() {
        this.require(["php"]);

        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/echo_get_request.php"); // Make sure resource is not served from cache

        req.open("GET", this.noCache(url));
        var that = this;

        req.onreadystatechange = function () {
          if (req.readyState == 4) {
            that.resume(function () {
              that.assertEquals(200, req.status);
            });
          }
        };

        req.send();
        this.wait();
      },
      "test: validate freshness": function testValidateFreshness() {
        this.require(["php", "noIe"]);

        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/time.php");

        var send = function send() {
          req.open("GET", url);
          req.send();
        };

        var that = this;
        var count = 0;
        var results = [];

        req.onload = function () {
          count += 1;
          results.push(req.responseText);

          if (count < 2) {
            send();
          } else {
            that.resume(function () {
              that.assertNotEquals(results[0], results[1], "Response must differ");
            });
          }
        };

        send();
        this.wait();
      },
      // "test: GET simultaneously": function() {
      //   var count = 1,
      //       upTo = 20,
      //       startedAt = new Date(),
      //       duration = 0,
      //       that = this;
      //
      //   for (var i=0; i<upTo; i++) {
      //     (function() {
      //       var req = new qx.bom.request.Xhr(),
      //           url = that.noCache(that.getUrl("qx/test/xmlhttp/loading.php")) + "&duration=2";
      //
      //       req.onreadystatechange = function() {
      //         if (req.readyState != 4) {
      //           return;
      //         }
      //
      //         that.resume(function() {
      //
      //           // In seconds
      //           duration = (new Date() - startedAt) / 1000;
      //           that.debug("Request #" + count + " completed (" +  duration + ")");
      //
      //           if (count == upTo) {
      //             return;
      //           }
      //
      //           ++count;
      //           that.wait();
      //         });
      //       }
      //
      //       req.open("GET", url);
      //       req.send();
      //     })();
      //   }
      //
      //   // Provided two concurrent requests are made (each 6s), 20 requests
      //   // (i.e. 10 packs of requests) should complete after 60s
      //   this.wait(15000 + 1000);
      // },
      "test: open throws error with insecure method": function testOpenThrowsErrorWithInsecureMethod() {
        var req = this.req,
            url = this.getUrl("qx/test/xmlhttp/sample.txt");
        this.assertException(function () {
          // Type of error is of no interest
          try {
            req.open("TRACE", url);
          } catch (e) {
            throw Error();
          }
        });
      },
      "test: overrideMimeType content type unchanged": function testOverrideMimeTypeContentTypeUnchanged() {
        this.require(["php", "noIe"]);

        var req = this.req,
            that = this;

        var onloadAssertContentTypeUnchanged = function onloadAssertContentTypeUnchanged() {
          that.resume(function () {
            that.assertEquals("text/html;charset=iso-8859-1", req.getResponseHeader("Content-Type"));
            that.assertEquals("ƒeƒXƒg", req.responseText);
          });
        };

        var query = "?type=" + encodeURIComponent("text/html;charset=iso-8859-1") + "&content=%83%65%83%58%83%67";
        var url = this.getUrl("qx/test/xmlhttp/get_content.php") + query;
        req.onload = onloadAssertContentTypeUnchanged;
        req.open("GET", url);
        req.send();
        this.wait();
      },
      "test: overrideMimeType content type override": function testOverrideMimeTypeContentTypeOverride() {
        this.require(["php", "noIe"]);

        var req = this.req,
            that = this;

        var onloadAssertContentTypeOverride = function onloadAssertContentTypeOverride() {
          that.resume(function () {
            // may or may not work - see API docs of overrideMimeType
            // that.assertEquals("text/plain;charset=Shift-JIS", req.getResponseHeader("Content-Type"));
            that.assertEquals("テスト", req.responseText);
          });
        };

        var query = "?type=" + encodeURIComponent("text/html;charset=iso-8859-1") + "&content=%83%65%83%58%83%67";
        var url = this.getUrl("qx/test/xmlhttp/get_content.php") + query;
        req.onload = onloadAssertContentTypeOverride;
        req.open("GET", url);
        req.overrideMimeType("text/plain;charset=Shift-JIS");
        req.send();
        this.wait();
      },
      // BUGFIXES
      "test: progress to readyState DONE": function testProgressToReadyStateDONE() {
        // This is a mess, see
        // http://www.quirksmode.org/blog/archives/2005/09/xmlhttp_notes_r_2.html.
        var req = this.req,
            states = [],
            that = this;

        req.onreadystatechange = function () {
          states.push(req.readyState);

          if (req.readyState == 4) {
            that.resume(function () {
              that.assertArrayEquals([1, 2, 3, 4], states);
            });
          }
        };

        var url = this.getUrl("qx/test/xmlhttp/sample.txt");
        req.open("GET", this.noCache(url));
        req.send();
        this.wait();
      },
      "test: progress to readyState DONE when sync": function testProgressToReadyStateDONEWhenSync() {
        var req = this.req,
            states = [];

        req.onreadystatechange = function () {
          states.push(req.readyState);
        };

        var url = this.getUrl("qx/test/xmlhttp/sample.txt");
        req.open("GET", this.noCache(url), false);
        req.send(); // There is no HEADERS_RECEIVED and LOADING when sync.
        // See http://www.w3.org/TR/XMLHttpRequest/#the-send-method

        this.assertArrayEquals([1, 4], states);
      },
      "test: progress to readyState DONE when from cache": function testProgressToReadyStateDONEWhenFromCache() {
        var primeReq = this.req,
            url = this.noCache(this.getUrl("qx/test/xmlhttp/sample.txt")),
            states = [],
            count = 0,
            that = this;

        primeReq.onreadystatechange = function () {
          if (primeReq.readyState == 4) {
            that.resume(function () {
              // From cache with new request
              var req = new qx.bom.request.Xhr();

              req.onreadystatechange = function () {
                states.push(req.readyState);

                if (req.readyState == 4) {
                  that.resume(function () {
                    that.assertArrayEquals([1, 2, 3, 4], states);
                  });
                }
              };

              req.open("GET", url);
              req.send();
              that.wait();
            });
          }
        }; // Prime cache


        primeReq.open("GET", url);
        primeReq.send();
        this.wait();
      },
      "test: have status 304 when cache is fresh": function testHaveStatus304WhenCacheIsFresh() {
        this.require(["php"]);

        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/not_modified.php");
        var that = this;

        req.onreadystatechange = function () {
          if (req.readyState == 4) {
            that.resume(function () {
              that.assertIdentical(304, req.status);
            });
          }
        };

        req.open("GET", url); // Pretend that client has a fresh representation of
        // this resource in its cache. Please note the ETag given
        // must be in sync with the current ETag of the file requested.
        //
        // XMLHttpRequest states:
        //
        // For 304 Not Modified responses that are a result of a user
        // agent generated conditional request the user agent must act
        // as if the server gave a 200 OK response with the appropriate
        // content. The user agent must allow setRequestHeader() to
        // override automatic cache validation by setting request
        // headers (e.g. If-None-Match or If-Modified-Since),
        // in which case 304 Not Modified responses must be passed through.
        //
        // Copied from:
        //
        // XMLHttpRequest [http://www.w3.org/TR/XMLHttpRequest/]
        // W3C Candidate Recommendation
        // Copyright © 2009 W3C® (MIT, ERCIM, Keio), All Rights Reserved.
        //
        // The actual ETag is not of importance here, since the server
        // is returning 304 anyway. We're just triggering the behavior
        // specified above.

        req.setRequestHeader("If-None-Match", "\"4893a3a-b0-49ea970349b00\"");
        req.send();
        this.wait();
      },
      "test: allow many requests with same object": function testAllowManyRequestsWithSameObject() {
        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/sample.txt");
        var count = 0;
        var that = this;

        function request() {
          req.open("GET", that.noCache(url));
          req.send();
        }

        req.onreadystatechange = function () {
          if (req.readyState == 4) {
            that.resume(function () {
              if (++count < 3) {
                request();
                this.wait();
              } else {
                that.assertEquals(3, count);
              }
            });
          }
        };

        request();
        this.wait();
      },
      //
      // onreadystatechange()
      //
      "test: call onreadystatechange for OPEN": function testCallOnreadystatechangeForOPEN() {
        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/sample.txt");
        var that = this;
        var count = 0;

        req.onreadystatechange = function () {
          // Count call for state OPENED
          if (req.readyState == 1) {
            count = count + 1;
          } // Assert when DONE


          if (req.readyState == 4) {
            that.resume(function () {
              // onreadystatechange should only be called
              // once for state OPENED
              that.assertEquals(1, count);
            });
          }
        };

        req.open("GET", this.noCache(url));
        req.send();
        this.wait();
      },
      "test: not call onreadystatechange when aborting OPENED": function testNotCallOnreadystatechangeWhenAbortingOPENED() {
        var req = this.req; // OPENED, without send flag

        var url = this.getUrl("qx/test/xmlhttp/sample.txt");
        req.open("GET", this.noCache(url));
        this.spy(req, "onreadystatechange");
        req.abort();
        this.wait(100, function () {
          this.assertNotCalled(req.onreadystatechange);
        }, this);
      },
      "test: call onreadystatechange when aborting LOADING": function testCallOnreadystatechangeWhenAbortingLOADING() {
        this.require(["php", "noIe9"]);

        var req = this.req;
        var that = this;

        req.onreadystatechange = function () {
          if (req.readyState == 4) {
            that.resume();
          }
        }; // Will "never" complete
        // OPENED, finally LOADING


        var url = this.getUrl("qx/test/xmlhttp/loading.php");
        req.open("GET", url + "?duration=100");
        req.send();
        window.setTimeout(function () {
          req.abort();
        }, 0);
        this.wait();
      },
      "test: call onloadend when aborting LOADING": function testCallOnloadendWhenAbortingLOADING() {
        this.require(["php", "noIe9"]);

        var req = this.req;
        var that = this;

        req.onloadend = function () {
          that.resume();
        }; // Will "never" complete
        // OPENED, finally LOADING


        var url = this.getUrl("qx/test/xmlhttp/loading.php");
        req.open("GET", url + "?duration=100");
        req.send();
        window.setTimeout(function () {
          req.abort();
        }, 0);
        this.wait(15000);
      },
      //
      // onerror()
      //
      "test: call onerror on network error": function testCallOnerrorOnNetworkError() {
        var req = this.req;
        var that = this;

        req.onerror = function () {
          that.resume(function () {
            that.assertEquals(4, req.readyState);
          });
        }; // Network error (async)
        // Is sync in Opera >= 11.5


        qx.event.Timer.once(function () {
          req.open("GET", "http://fail.tld");
          req.send();
        }, this, 0); // May take a while to detect network error

        this.wait(15000);
      },
      "test: call onerror on file error": function testCallOnerrorOnFileError() {
        this.require(["file"]);

        var req = this.req;
        var that = this;

        req.onerror = function () {
          that.resume(function () {
            that.assertEquals(4, req.readyState);
          });
        };

        req.open("GET", "not-found");
        req.send();
        this.wait();
      },
      "test: throw error on network error when sync": function testThrowErrorOnNetworkErrorWhenSync() {
        var req = this.req; // Network error (sync)

        req.open("GET", "http://fail.tld", false);
        this.assertException(function () {
          try {
            req.send();
          } catch (e) {
            throw Error();
          }
        });
      },
      //
      // ontimeout()
      //
      "test: not call ontimeout when DONE and sync": function testNotCallOntimeoutWhenDONEAndSync() {
        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/sample.txt");
        this.spy(req, "ontimeout"); // Assume that request completes in given interval

        req.timeout = 400;
        req.open("GET", url, false);
        req.send();
        this.wait(function () {
          this.assertNotCalled(req.ontimeout);
        }, 500, this);
      },
      "test: timeout triggers timeout error": function testTimeoutTriggersTimeoutError() {
        // "timeout error" is specified here
        // http://www.w3.org/TR/XMLHttpRequest2/#timeout-error
        this.require(["php"]);

        var req = this.req,
            url = this.getUrl("qx/test/xmlhttp/loading.php"),
            that = this;

        req.onloadend = function () {
          that.resume(function () {
            that.assertEquals(4, req.readyState);
            that.assertIdentical("", req.responseText);
            that.assertIdentical(null, req.responseXML);
            that.assertCallOrder(req.onreadystatechange, req.ontimeout, req.onloadend);
          });
        };

        req.timeout = 100;
        req.open("GET", url + "?duration=100");
        req.send();
        this.spy(req, "onreadystatechange");
        this.spy(req, "onerror");
        this.spy(req, "ontimeout");
        this.spy(req, "onloadend");
        this.wait();
      },
      "test: timeout not call onabort": function testTimeoutNotCallOnabort() {
        this.require(["php"]);

        var req = this.req,
            url = this.getUrl("qx/test/xmlhttp/loading.php"),
            that = this;

        req.ontimeout = function () {
          that.resume(function () {
            that.assertNotCalled(req.onabort);
          });
        };

        req.timeout = 100;
        req.open("GET", url + "?duration=100");
        req.send();
        this.spy(req, "onabort");
        this.wait();
      },
      //
      // onloadend()
      //
      "test: call onloadend on network error": function testCallOnloadendOnNetworkError() {
        var req = this.req;
        var that = this;

        req.onloadend = function () {
          that.resume();
        }; // Network error
        // Is sync in Opera >= 11.5


        qx.event.Timer.once(function () {
          req.open("GET", "http://fail.tld");
          req.send();
        }, this, 0); // May take a while to detect network error

        this.wait(15000);
      },
      //
      // Call order
      //
      "test: call handler in order when request successful": function testCallHandlerInOrderWhenRequestSuccessful() {
        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/sample.txt");
        var that = this;

        req.onloadend = function () {
          that.resume(function () {
            that.assertCallOrder(req.onreadystatechange, req.onload, req.onloadend);
          });
        };

        this.spy(req, "onreadystatechange");
        this.spy(req, "onload");
        this.spy(req, "onloadend");
        req.open("GET", url);
        req.send();
        this.wait();
      },
      "test: call handler in order when request failed": function testCallHandlerInOrderWhenRequestFailed() {
        var req = this.req;
        var that = this;

        req.onloadend = function () {
          that.resume(function () {
            that.assertCallOrder(req.onreadystatechange, req.onerror, req.onloadend);
          });
        };

        this.spy(req, "onreadystatechange");
        this.spy(req, "onerror");
        this.spy(req, "onloadend"); // Is sync in Opera >= 11.5

        qx.event.Timer.once(function () {
          req.open("GET", "http://fail.tld");
          req.send();
        }, this, 0); // May take a while to detect network error

        this.wait(15000);
      },
      //
      // Disposing
      //
      "test: dispose hard-working": function testDisposeHardWorking() {
        var req = this.req;
        var url = this.getUrl("qx/test/xmlhttp/sample.txt");
        req.open("GET", this.noCache(url));
        var that = this;

        req.onreadystatechange = function () {
          if (req.readyState == 4) {
            that.resume(function () {
              // Must not throw error
              req.dispose();
            });
          }
        };

        req.send();
        this.wait();
      },
      noCache: function noCache(url) {
        return url + "?nocache=" + new Date().valueOf();
      },
      hasNoIe: function hasNoIe() {
        return qx.core.Environment.get("engine.name") !== "mshtml" && qx.core.Environment.get("browser.name") !== "edge";
      },
      hasNoIe9: function hasNoIe9() {
        return qx.core.Environment.get("engine.name") !== "mshtml" || qx.core.Environment.get("browser.documentmode") !== 9;
      },
      hasFile: function hasFile() {
        return location.protocol === "file:";
      }
    }
  });
  qx.test.bom.request.XhrWithRemote.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.bom.request.SimpleXhr": {},
      "qx.bom.rest.Resource": {},
      "qx.lang.Function": {},
      "qx.lang.Json": {},
      "qx.core.Environment": {},
      "qx.dev.unit.RequirementError": {},
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /**
   * @asset(qx/test/xmlhttp/*)
   */
  qx.Class.define("qx.test.bom.rest.Resource", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements, qx.dev.unit.MMock],
    members: {
      setUp: function setUp() {
        this.setUpDoubleRequest();
        this.setUpResource();
      },
      setUpDoubleRequest: function setUpDoubleRequest() {
        // Restore Xhr when wrapped before
        if (typeof qx.bom.request.SimpleXhr.restore == "function") {
          qx.bom.request.SimpleXhr.restore();
        }

        var req = this.req = new qx.bom.request.SimpleXhr(); // Stub request methods, but
        // - leave event system intact (addListenerOnce)
        // - leave disposable intact, cause test methods stub it themselves (dispose)

        req = this.shallowStub(req, qx.bom.request.SimpleXhr, ["dispose", "addListenerOnce", "getTransport"]); // Inject double and return

        this.injectStub(qx.bom.request, "SimpleXhr", req); // Remember request for later disposal

        this.__reqs__P_224_0 = this.__reqs__P_224_0 || [];

        this.__reqs__P_224_0.push(this.req);

        return req;
      },
      setUpResource: function setUpResource() {
        this.res && this.res.dispose();
        var res = this.res = new qx.bom.rest.Resource(); // Default routes

        res.map("get", "GET", "/photos");
        res.map("post", "POST", "/photos");
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();
        this.res.dispose();

        this.__reqs__P_224_0.forEach(function (req) {
          req.dispose();
        });
      },
      //
      // Configuration
      //
      "test: configure request receives pre-configured but unsent request": function testConfigureRequestReceivesPreConfiguredButUnsentRequest() {
        var res = this.res,
            req = this.req;
        res.configureRequest(qx.lang.Function.bind(function (req) {
          this.assertCalledWith(req.setMethod, "GET");
          this.assertCalled(req.setUrl, "/photos");
          this.assertNotCalled(req.send);
        }, this));
        res.get();
      },
      "test: configure request receives invocation details": function testConfigureRequestReceivesInvocationDetails() {
        var res = this.res,
            req = this.req,
            params = {},
            data = {},
            callback;
        callback = this.spy(qx.lang.Function.bind(function (req, _action, _params, _data) {
          this.assertEquals("get", _action, "Unexpected action");
          this.assertEquals(params, _params, "Unexpected params");
          this.assertEquals(data, _data, "Unexpected data");
        }, this));
        res.configureRequest(callback);
        res.get(params, data);
        this.assertCalled(callback);
      },
      //
      // Route
      //
      "test: map action": function testMapAction() {
        var res = this.res,
            params;
        params = res._getRequestConfig("get");
        this.assertEquals("GET", params.method);
        this.assertEquals("/photos", params.url);
      },
      "test: map action when base URL": function testMapActionWhenBaseURL() {
        var res = this.res,
            params;
        res.setBaseUrl("http://example.com");
        params = res._getRequestConfig("get");
        this.assertEquals("http://example.com/photos", params.url);
      },
      "test: map existing action": function testMapExistingAction() {
        var res = this.res,
            params;
        res.map("post", "GET", "/articles");
        params = res._getRequestConfig("post");
        this.assertEquals("/articles", params.url);
      },
      "test: map action creates method": function testMapActionCreatesMethod() {
        var res = this.res,
            req = this.req;
        this.assertFunction(res.get);
      },
      "test: map action throws when existing method": function testMapActionThrowsWhenExistingMethod() {
        this.require(["debug"]);

        var res = this.res,
            req = this.req; // For whatever reason

        res.popular = function () {};

        this.assertException(function () {
          res.map("popular", "GET", "/photos/popular");
        }, Error);
      },
      "test: map action does not throw when existing method is empty": function testMapActionDoesNotThrowWhenExistingMethodIsEmpty() {
        this.require(["debug"]);

        var res = this.res,
            req = this.req; // For documentation purposes

        res.get = function () {};

        res.map("get", "GET", "/photos/popular");
      },
      "test: dynamically created action forwards arguments": function testDynamicallyCreatedActionForwardsArguments() {
        var res = this.res,
            req = this.req;
        this.spy(res, "invoke");
        res.get({}, 1, 2, 3);
        this.assertCalledWith(res.invoke, "get", {}, 1, 2, 3);
      },
      "test: dynamically created action returns what invoke returns": function testDynamicallyCreatedActionReturnsWhatInvokeReturns() {
        var id = 1;
        this.stub(this.res, "invoke").returns(id);
        this.assertEquals(id, this.res.get());
      },
      "test: map actions from description": function testMapActionsFromDescription() {
        var req = this.req,
            description,
            res,
            check = {},
            params;
        description = {
          get: {
            method: "GET",
            url: "/photos"
          },
          create: {
            method: "POST",
            url: "/photos",
            check: check
          }
        };
        res = new qx.bom.rest.Resource(description);
        params = res._getRequestConfig("get");
        this.assertEquals("GET", params.method);
        this.assertEquals("/photos", params.url);
        params = res._getRequestConfig("create");
        this.assertEquals("POST", params.method);
        this.assertEquals("/photos", params.url);
        this.assertEquals(check, params.check);
        res.dispose();
      },
      "test: map action from description throws with non-object": function testMapActionFromDescriptionThrowsWithNonObject() {
        this.require(["debug"]);

        this.assertException(function () {
          var res = new qx.bom.rest.Resource([]);
        });
      },
      "test: map action from description throws with incomplete route": function testMapActionFromDescriptionThrowsWithIncompleteRoute() {
        this.require(["debug"]);

        this.res.dispose();
        this.assertException(function () {
          var description = {
            get: {
              method: "GET"
            }
          };
          this.res = new qx.bom.rest.Resource(description);
        }, Error, "URL must be string for route 'get'");
      },
      //
      // Invoke
      //
      "test: invoke action generically": function testInvokeActionGenerically() {
        var res = this.res,
            req = this.req,
            result;
        result = res.invoke("get");
        this.assertSend();
      },
      "test: invoke action": function testInvokeAction() {
        var res = this.res,
            req = this.req;
        res.get();
        this.assertSend();
      },
      "test: invoke action returns id of request": function testInvokeActionReturnsIdOfRequest() {
        var res = this.res,
            req = this.req;
        req.toHashCode.restore();
        this.assertNumber(res.invoke("get"));
      },
      "test: invoke action while other is in progress": function testInvokeActionWhileOtherIsInProgress() {
        var res = this.res,
            req1,
            req2;
        req1 = this.req;
        res.get();
        this.setUpDoubleRequest();
        req2 = this.req;
        res.post();
        this.assertCalledOnce(req1.send);
        this.assertCalledOnce(req2.send);
      },
      "test: invoke same action handles multiple requests": function testInvokeSameActionHandlesMultipleRequests() {
        var res = this.res,
            req1,
            req2,
            getSuccess = this.spy();
        res.addListener("getSuccess", getSuccess);
        req1 = this.req;
        res.get();
        this.setUpDoubleRequest();
        req2 = this.req;
        res.get();
        this.respond("", req1);
        this.respond("", req2);
        this.assertCalledTwice(getSuccess);
      },
      "test: invoke action with positional params": function testInvokeActionWithPositionalParams() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}");
        res.get({
          id: "1"
        });
        this.assertCalledWith(req.setUrl, "/photos/1");
      },
      "test: invoke action with positional params that evaluate to false": function testInvokeActionWithPositionalParamsThatEvaluateToFalse() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}");
        res.get({
          id: 0
        });
        this.assertCalledWith(req.setUrl, "/photos/0");
      },
      "test: invoke action with non-string params": function testInvokeActionWithNonStringParams() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}");
        res.get({
          id: 1
        });
        this.assertCalledWith(req.setUrl, "/photos/1");
      },
      "test: invoke action with params and data": function testInvokeActionWithParamsAndData() {
        var res = this.res,
            req = this.req;
        res.map("put", "PUT", "/articles/{id}");
        res.put({
          id: "1"
        }, {
          article: '{title: "Affe"}'
        }); // Note that with method GET, parameters are appended to the URLs query part.
        // Please refer to the API docs of qx.io.request.AbstractRequest#requestData.
        //
        // res.get({id: "1"}, {lang: "de"});
        // --> /articles/1/?lang=de

        this.assertCalledWith(req.setRequestData, {
          article: '{title: "Affe"}'
        });
      },
      "test: invoke action with multiple positional params": function testInvokeActionWithMultiplePositionalParams() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}/comments/{commentId}");
        res.get({
          id: "1",
          commentId: "2"
        });
        this.assertCalledWith(req.setUrl, "/photos/1/comments/2");
      },
      "test: invoke action with positional params in query": function testInvokeActionWithPositionalParamsInQuery() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}/comments?id={commentId}");
        res.get({
          id: "1",
          commentId: "2"
        });
        this.assertCalledWith(req.setUrl, "/photos/1/comments?id=2");
      },
      "test: invoke action with undefined params": function testInvokeActionWithUndefinedParams() {
        var res = this.res,
            req = this.req;
        res.get();
        this.assertCalled(req.send);
      },
      "test: invoke action with null params": function testInvokeActionWithNullParams() {
        var res = this.res,
            req = this.req;
        res.get(null);
        this.assertCalled(req.send);
      },
      "test: invoke action when content type json": function testInvokeActionWhenContentTypeJson() {
        var res = this.res,
            req = this.req;
        req.setRequestHeader.restore();
        req.getRequestHeader.restore();
        res.configureRequest(function (req) {
          req.setRequestHeader("Content-Type", "application/json");
        });
        this.spy(qx.lang.Json, "stringify");
        var data = {
          location: "Karlsruhe"
        };
        res.map("post", "POST", "/photos/{id}/meta");
        res.post({
          id: 1
        }, data);
        this.assertCalledWith(req.setRequestData, '{"location":"Karlsruhe"}');
        this.assertCalledWith(qx.lang.Json.stringify, data);
      },
      "test: invoke action when content type json and get": function testInvokeActionWhenContentTypeJsonAndGet() {
        var res = this.res,
            req = this.req;
        req.setMethod.restore();
        req.getMethod.restore();
        this.spy(qx.lang.Json, "stringify");
        req.getRequestHeader.withArgs("Content-Type").returns("application/json");
        res.get();
        this.assertNotCalled(qx.lang.Json.stringify);
      },
      "test: invoke action for url with port": function testInvokeActionForUrlWithPort() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "http://example.com:8080/photos/{id}");
        res.get({
          id: "1"
        });
        this.assertCalledWith(req.setUrl, "http://example.com:8080/photos/1");
      },
      "test: invoke action for relative url": function testInvokeActionForRelativeUrl() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "{page}");
        res.get({
          page: "index"
        });
        this.assertCalledWith(req.setUrl, "index");
      },
      "test: invoke action for relative url with dots": function testInvokeActionForRelativeUrlWithDots() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "../{page}");
        res.get({
          page: "index"
        });
        this.assertCalledWith(req.setUrl, "../index");
      },
      "test: invoke action for route with check": function testInvokeActionForRouteWithCheck() {
        var res = this.res;
        res.map("get", "GET", "/photos/zoom/{id}", {
          id: /\d+/
        });
        res.get({
          id: "123"
        });
        this.assertSend("GET", "/photos/zoom/123");
      },
      "test: invoke action fills in empty string when missing param and no default": function testInvokeActionFillsInEmptyStringWhenMissingParamAndNoDefault() {
        var res = this.res;
        res.map("get", "GET", "/photos/{tag}");
        res.get();
        this.assertSend("GET", "/photos/");
      },
      "test: invoke action fills in default when missing param": function testInvokeActionFillsInDefaultWhenMissingParam() {
        var res = this.res;
        res.map("get", "GET", "/photos/{tag=recent}/{size}");
        res.get({
          size: "large"
        });
        this.assertSend("GET", "/photos/recent/large");
      },
      "test: invoke action throws when missing required positional param": function testInvokeActionThrowsWhenMissingRequiredPositionalParam() {
        var res = this.res; // Require positional param

        res.map("get", "GET", "/photos/{tag}", {
          tag: qx.bom.rest.Resource.REQUIRED
        });
        this.assertException(function () {
          res.get();
        }, Error, "Missing parameter 'tag'");
      },
      "test: invoke action throws when missing required request param": function testInvokeActionThrowsWhenMissingRequiredRequestParam() {
        var res = new qx.bom.rest.Resource(); // Require request body param

        res.map("post", "POST", "/photos/", {
          photo: qx.bom.rest.Resource.REQUIRED
        });
        this.assertException(function () {
          res.post();
        }, Error, "Missing parameter 'photo'");
      },
      "test: invoke action throws when param not match check": function testInvokeActionThrowsWhenParamNotMatchCheck() {
        var res = this.res;
        res.map("get", "GET", "/photos/{id}", {
          id: /\d+/
        });
        this.assertException(function () {
          res.get({
            id: "FAIL"
          });
        }, Error, "Parameter 'id' is invalid");
      },
      "test: invoke action ignores invalid check in production": function testInvokeActionIgnoresInvalidCheckInProduction() {
        this.require(["debug"]);

        var res = this.res;
        var setting = this.stub(qx.core.Environment, "get").withArgs("qx.debug");
        setting.returns(false); // Invalid check

        res.map("get", "GET", "/photos/{id}", {
          id: ""
        });
        res.get({
          id: 1
        });
      },
      //
      // Abort
      //
      "test: abort action": function testAbortAction() {
        var res = this.res,
            req = this.req;
        res.get();
        res.abort("get");
        this.assertCalledOnce(req.abort);
      },
      "test: abort action when multiple requests": function testAbortActionWhenMultipleRequests() {
        var res = this.res,
            req1,
            req2;
        req1 = this.setUpDoubleRequest();
        res.get();
        req2 = this.setUpDoubleRequest();
        res.get();
        res.abort("get");
        this.assertCalledOnce(req1.abort);
        this.assertCalledOnce(req2.abort);
      },
      "test: abort by action id": function testAbortByActionId() {
        var res = this.res,
            req = this.req;
        req.toHashCode.restore();
        var id = res.get();
        res.abort(id);
        this.assertCalledOnce(req.abort);
      },
      //
      // Helper
      //
      "test: refresh action": function testRefreshAction() {
        var res = this.res,
            req = this.req;
        res.get();
        this.assertSend();
        res.refresh("get");
        this.assertSend();
      },
      "test: refresh action replaying previous params": function testRefreshActionReplayingPreviousParams() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}");
        res.get({
          id: "1"
        });
        this.assertSend("GET", "/photos/1");
        res.refresh("get");
        this.assertSend("GET", "/photos/1");
      },
      "test: poll action": function testPollAction() {
        var res = this.res,
            sandbox = this.getSandbox();
        sandbox.useFakeTimers();
        this.spy(res, "refresh");
        res.poll("get", 10);
        this.respond();
        sandbox.clock.tick(20);
        this.assertCalledWith(res.refresh, "get");
        this.assertCalledOnce(res.refresh);
      },
      "test: not poll action when no response received yet": function testNotPollActionWhenNoResponseReceivedYet() {
        var res = this.res,
            sandbox = this.getSandbox();
        sandbox.useFakeTimers();
        this.spy(res, "refresh");
        res.poll("get", 10);
        sandbox.clock.tick(20);
        this.assertNotCalled(res.refresh);
      },
      "test: poll action immediately": function testPollActionImmediately() {
        var res = this.res;
        this.spy(res, "invoke");
        res.poll("get", 10, undefined, true);
        this.assertCalled(res.invoke);
      },
      "test: poll action sets initial params": function testPollActionSetsInitialParams() {
        var res = this.res;
        res.map("get", "GET", "/photos/{id}");
        this.stub(res, "invoke");
        res.poll("get", 10, {
          id: "1"
        }, true);
        this.assertCalledWith(res.invoke, "get", {
          id: "1"
        });
      },
      "test: poll action replaying previous params": function testPollActionReplayingPreviousParams() {
        var res = this.res,
            req = this.req;
        res.map("get", "GET", "/photos/{id}");
        res.get({
          id: "1"
        });
        this.assertSend("GET", "/photos/1");
        res.poll("get");
        this.assertSend("GET", "/photos/1");
      },
      "test: poll action repeatedly ends previous timer": function testPollActionRepeatedlyEndsPreviousTimer() {
        var res = this.res,
            sandbox = this.getSandbox(),
            msg;
        sandbox.useFakeTimers();
        this.stub(res, "refresh");
        res.poll("get", 10);
        this.respond();
        sandbox.clock.tick(20);
        res.poll("get", 100);
        this.respond();
        sandbox.clock.tick(100);
        this.assertCalledTwice(res.refresh);
      },
      "test: poll many actions": function testPollManyActions() {
        var res = this.res,
            sandbox = this.getSandbox(),
            spy,
            get,
            post;
        this.stub(this.req, "dispose");
        sandbox.useFakeTimers();
        spy = this.spy(res, "refresh");
        get = spy.withArgs("get");
        post = spy.withArgs("post");
        res.poll("get", 10);
        res.poll("post", 10);
        this.respond();
        sandbox.clock.tick(20);
        this.assertCalledOnce(get);
        this.assertCalledOnce(post);
        this.req.dispose.restore();
        this.req.dispose();
      },
      "test: end poll action": function testEndPollAction() {
        var res = this.res,
            sandbox = this.getSandbox(),
            timer,
            numCalled;
        sandbox.useFakeTimers();
        this.spy(res, "refresh");
        res.poll("get", 10);
        this.respond(); // 10ms invoke, 20ms refresh, 30ms refresh

        sandbox.clock.tick(30);
        res.stopPollByAction("get");
        sandbox.clock.tick(100);
        this.assertCalledTwice(res.refresh);
      },
      "test: end poll action does not end polling of other action": function testEndPollActionDoesNotEndPollingOfOtherAction() {
        var res = this.res,
            sandbox = this.getSandbox(),
            timer,
            spy;
        sandbox.useFakeTimers();
        spy = this.spy(res, "refresh").withArgs("get");
        this.respond();
        res.poll("get", 10);
        res.poll("post", 10);
        sandbox.clock.tick(20);
        res.stopPollByAction("post");
        sandbox.clock.tick(10);
        this.assertCalledTwice(spy);
      },
      "test: restart poll action": function testRestartPollAction() {
        var res = this.res,
            sandbox = this.getSandbox(),
            timer;
        sandbox.useFakeTimers();
        this.respond();
        res.poll("get", 10);
        sandbox.clock.tick(10);
        res.stopPollByAction("get");
        this.spy(res, "refresh");
        res.restartPollByAction("get");
        sandbox.clock.tick(10);
        this.assertCalled(res.refresh);
      },
      "test: long poll action": function testLongPollAction() {
        var res = this.res,
            req = this.req,
            responses = []; // undo this line from setUp() ...
        // this.injectStub(qx.bom.request, "SimpleXhr", req);
        // ... in order to have unique reqs instead of always
        //     the same stubbed req from the setUp method.

        qx.bom.request.SimpleXhr.restore();
        this.stub(req, "dispose");
        res.addListener("getSuccess", function (e) {
          responses.push(e.response);
        }, this);
        res.longPoll("get"); // longPoll() sets up new request when receiving a response

        this.respondSubsequent("1", 0, true);
        this.respondSubsequent("2", 1, true);
        this.respondSubsequent("3", 2, true);
        this.assertArrayEquals(["1", "2", "3"], responses);
      },
      "test: throttle long poll": function testThrottleLongPoll() {
        var res = this.res,
            req = this.req;
        this.stub(req, "dispose");
        this.spy(res, "refresh");
        this.stub(qx.bom.rest.Resource, "POLL_THROTTLE_COUNT", "3");
        res.longPoll("get"); // A number of immediate responses, above count

        for (var i = 0; i < 4; i++) {
          this.respond();
        }

        res.refresh = function () {
          throw new Error("With throttling in effect, must not make new request.");
        }; // Throttling


        this.respond();
      },
      "test: not throttle long poll when not received within limit": function testNotThrottleLongPollWhenNotReceivedWithinLimit() {
        var res = this.res,
            req = this.req,
            sandbox = this.getSandbox(); // undo this line from setUp() ...
        // this.injectStub(qx.bom.request, "SimpleXhr", req);
        // ... in order to have unique reqs instead of always
        //     the same stubbed req from the setUp method.

        qx.bom.request.SimpleXhr.restore();
        this.stub(req, "dispose");
        sandbox.useFakeTimers();
        res.longPoll("get"); // A number of delayed responses, above count

        for (var i = 0; i < 31; i++) {
          sandbox.clock.tick(101);
          this.respondSubsequent(null, i);
        }

        this.spy(res, "refresh");
        sandbox.clock.tick(101);
        this.respondSubsequent(null, i);
        this.assertCalled(res.refresh);
      },
      "test: not throttle long poll when not received subsequently": function testNotThrottleLongPollWhenNotReceivedSubsequently() {
        var res = this.res,
            req = this.req,
            sandbox = this.getSandbox(); // undo this line from setUp() ...
        // this.injectStub(qx.bom.request, "SimpleXhr", req);
        // ... in order to have unique reqs instead of always
        //     the same stubbed req from the setUp method.

        qx.bom.request.SimpleXhr.restore();
        this.stub(req, "dispose");
        sandbox.useFakeTimers();
        res.longPoll("get"); // A number of immediate responses

        for (var i = 0; i < 30; i++) {
          this.respondSubsequent(null, i);
        } // Delayed response


        sandbox.clock.tick(101);
        this.respondSubsequent(null, i++); // // More immediate responses, total count above limit

        this.spy(res, "refresh");

        for (var j = 0; j < 10; j++) {
          this.respondSubsequent(null, i + j);
        }

        this.assertCallCount(res.refresh, 10);
      },
      "test: end long poll action": function testEndLongPollAction() {
        var res = this.res,
            req = this.req,
            handlerId,
            msg; // undo this line from setUp() ...
        // this.injectStub(qx.bom.request, "SimpleXhr", req);
        // ... in order to have unique reqs instead of always
        //     the same stubbed req from the setUp method.

        qx.bom.request.SimpleXhr.restore();
        this.stub(req, "dispose");
        this.spy(res, "refresh");
        handlerId = res.longPoll("get");
        this.respondSubsequent(null, 0);
        this.respondSubsequent(null, 1);
        res.removeListenerById(handlerId);
        this.respondSubsequent(null, 2);
        this.assertCalledTwice(res.refresh);
      },
      //
      // Events
      //
      "test: fire actionSuccess": function testFireActionSuccess() {
        var res = this.res,
            req = this.req,
            that = this;
        res.get();
        this.assertEventFired(res, "getSuccess", function () {
          that.respond("Affe");
        }, function (e) {
          that.assertEquals("Affe", e.response);
          that.assertIdentical(req, e.request);
          that.assertEquals("get", e.action);
        });
      },
      "test: fire success": function testFireSuccess() {
        var res = this.res,
            req = this.req,
            that = this;
        res.get();
        this.assertEventFired(res, "success", function () {
          that.respond("Affe");
        }, function (e) {
          that.assertEquals("Affe", e.response);
          that.assertIdentical(req, e.request);
          that.assertEquals("get", e.action);
        });
      },
      "test: fire actionError": function testFireActionError() {
        var res = this.res,
            req = this.req,
            that = this;
        res.get();
        this.assertEventFired(res, "getError", function () {
          that.respondError();
        }, function (e) {
          that.assertIdentical(req, e.request);
          that.assertEquals("get", e.action);
        });
      },
      "test: fire error": function testFireError() {
        var res = this.res,
            req = this.req,
            that = this;
        res.get();
        this.assertEventFired(res, "error", function () {
          that.respondError();
        }, function (e) {
          that.assertIdentical(req, e.request);
          that.assertEquals("get", e.action);
        });
      },
      "test: fire started": function testFireStarted() {
        qx.bom.request.SimpleXhr.restore();
        var res = this.res,
            req = this.req,
            that = this;
        var listener = this.spy();
        res.on("started", listener);
        res.get();
        window.setTimeout(function () {
          this.resume(function () {
            this.assertTrue(listener.calledOnce);
          }, this);
        }.bind(this), 200);
        this.wait(500);
      },
      //
      // Dispose
      //
      "test: dispose requests": function testDisposeRequests() {
        var res = this.res,
            req1,
            req2;
        req1 = this.req;
        res.get();
        this.setUpDoubleRequest();
        req2 = this.req;
        res.post();
        this.spy(req1, "dispose");
        this.spy(req2, "dispose");
        res.dispose();
        this.assertCalled(req1.dispose);
        this.assertCalled(req2.dispose);
      },
      "test: dispose requests of same action": function testDisposeRequestsOfSameAction() {
        var res = this.res,
            req1,
            req2;
        req1 = this.req;
        res.get();
        this.setUpDoubleRequest();
        req2 = this.req;
        res.get();
        this.spy(req1, "dispose");
        this.spy(req2, "dispose");
        res.dispose();
        this.assertCalled(req1.dispose);
        this.assertCalled(req2.dispose);
      },
      "test: dispose request on loadEnd": function testDisposeRequestOnLoadEnd() {
        var res = this.res,
            req = this.req;
        this.spy(req, "dispose");
        res.get();
        this.respond();
        window.setTimeout(function () {
          this.resume(function () {
            this.assertCalledOnce(req.dispose);
          }, this);
        }.bind(this), 100);
        this.wait(200);
      },
      assertSend: function assertSend(method, url) {
        var req = this.req;
        method = method || "GET";
        url = url || "/photos";
        this.assertCalledWith(req.setMethod, method);
        this.assertCalledWith(req.setUrl, url);
        this.assertCalled(req.send);
      },
      skip: function skip(msg) {
        throw new qx.dev.unit.RequirementError(null, msg);
      },
      hasDebug: function hasDebug() {
        return true;
      },
      // Fake response
      respond: function respond(response, req) {
        req = req || this.req;
        response = response || "";
        req.isDone.returns(true);
        req.getResponse.returns(response);
        req.emit("success");
        req.emit("loadEnd");
      },
      // Fake response but find and manipulate matching requests *within* res
      // which is important for tests with more than one request (e.g. poll and long poll)
      respondSubsequent: function respondSubsequent(response, reqIdx, shouldStubResp) {
        var response = response || "",
            validReqIdx = reqIdx !== undefined; // this.res.__requests isn't available after 'privates' optimization
        // so find it by some kind of feature detection - this isn't beautiful,
        // but adding a protected getter just for that is worse

        var requests = "";
        Object.keys(this.res).forEach(function (propName) {
          if (propName.indexOf("____P_224_1") === 0 && "get" in this.res[propName] && qx.lang.Type.isArray(this.res[propName].get) && qx.lang.Type.isObject(this.res[propName].get[0]) && "$$hash" in this.res[propName].get[0]) {
            requests = propName;
          }
        }, this);

        if (validReqIdx && requests) {
          var reqWithin = this.res[requests].get[reqIdx];

          if (shouldStubResp) {
            this.stub(reqWithin, "isDone");
            this.stub(reqWithin, "getResponse");
            reqWithin.isDone.returns(true);
            reqWithin.getResponse.returns(response);
          }

          reqWithin.emit("success");
          reqWithin.emit("loadEnd");
          this.res[requests].get[reqIdx] = reqWithin;
        }
      },
      // Fake erroneous response
      respondError: function respondError() {
        var req = this.req;
        req.emit("fail");
        req.emit("loadEnd");
      }
    }
  });
  qx.test.bom.rest.Resource.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.bom.rest.Resource": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /**
   * @asset(qx/test/xmlhttp/random.php)
   * @asset(qx/test/xmlhttp/long_poll.php)
   * @asset(qx/test/xmlhttp/sample.txt)
   */
  qx.Class.define("qx.test.bom.rest.ResourceWithRemote", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements, qx.test.io.MRemoteTest],
    members: {
      setUp: function setUp() {
        this.require(["http"]);

        this.res = new qx.bom.rest.Resource();
      },
      tearDown: function tearDown() {
        this.res.dispose();
      },
      "test: invoke action and handle response": function testInvokeActionAndHandleResponse() {
        // Handles GET
        var url = this.getUrl("qx/test/xmlhttp/sample.txt"),
            res = this.res;
        res.map("get", "GET", url);
        res.addListener("getSuccess", function (e) {
          this.resume(function () {
            this.assertEquals("SAMPLE", e.response);
          }, this);
        }, this);
        res.get();
        this.wait();
      },
      "test: invoke action and handle failure": function testInvokeActionAndHandleFailure() {
        var url = "/not-found",
            res = this.res;
        res.map("get", "GET", url);
        res.addListener("error", function (e) {
          this.resume(function () {
            this.assertEquals("get", e.action);
          }, this);
        }, this);
        res.get();
        this.wait();
      },
      "test: poll action": function testPollAction() {
        // Handles GET
        var url = this.getUrl("qx/test/xmlhttp/random.php"),
            res = this.res,
            count = 0,
            previousResponse = "";
        res.map("get", "GET", url); // Response headers must contain explicit cache control for this
        // to work in IE

        res.addListener("getSuccess", function (e) {
          var response = e.response;
          count++;
          this.assert(response.length === 32, "Response must be MD5");
          this.assertNotEquals(previousResponse, response, "Response must be different from previous");
          previousResponse = response;

          if (count >= 10) {
            this.resume();
          }
        }, this);
        res.poll("get", 100);
        this.wait();
      },
      "test: long poll": function testLongPoll() {
        var res = this.res,
            url = this.getUrl("qx/test/xmlhttp/long_poll.php"),
            count = 0,
            responses = [];
        res.map("get", "GET", url);
        res.addListener("getSuccess", function (e) {
          var response = e.response;
          responses.push(response);

          if (++count >= 5) {
            this.resume(function () {
              this.assert(parseFloat(responses[4]) > parseFloat(responses[0]), "Must increase");
            }, this);
          }
        }, this);
        res.longPoll("get");
        this.wait();
      }
    }
  });
  qx.test.bom.rest.ResourceWithRemote.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.storage.WebStorageTestCase", {
    type: "abstract",
    extend: qx.dev.unit.TestCase,
    members: {
      _storage: null,
      setUp: function setUp() {
        this._storage = this._getStorage();

        this._storage.clear();
      },
      tearDown: function tearDown() {
        this._storage = null;
      },
      testItem: function testItem() {
        this.assertNull(this._storage.getItem("key1"));

        this._storage.setItem("key1", "value1");

        this.assertEquals("value1", this._storage.getItem("key1"));

        this._storage.removeItem("key1");

        this.assertNull(this._storage.getItem("key1"));

        this._storage.setItem("key2", [1, "a"]);

        this.assertArrayEquals([1, "a"], this._storage.getItem("key2"));

        this._storage.setItem("key2", {
          "a": 1,
          "b": "c"
        });

        this.assertMap({
          "a": 1,
          "b": "c"
        }, this._storage.getItem("key2")); //overriding

        this._storage.setItem("key2", 12);

        this.assertEquals(12, this._storage.getItem("key2"));
      },
      testGetKey: function testGetKey() {
        // the order is unreliable, so just test that the getKey works
        this._storage.setItem("key1", "value");

        this.assertNotEquals(-1, Object.keys(this._storage.getStorage()).indexOf("key1"));
      },
      testLength: function testLength() {
        this.assertEquals(0, this._storage.getLength());

        for (var i = 0; i < 10; i++) {
          this._storage.setItem("key" + i, "value");
        }

        this.assertEquals(10, this._storage.getLength());
      },
      testClear: function testClear() {
        for (var i = 0; i < 10; i++) {
          this._storage.setItem("key" + i, "value");
        }

        this.assertEquals(10, this._storage.getLength());

        this._storage.clear();

        this.assertEquals(0, this._storage.getLength());
      },
      testForEach: function testForEach() {
        var i;

        for (i = 0; i < 10; i++) {
          this._storage.setItem("key" + i, "value");
        } //don't rely on the order


        i = 0;

        this._storage.forEach(function (key, item) {
          this.assertEquals(this._storage.getItem(key), item);
          i++;
        }, this);

        this.assertEquals(10, i);
      }
    }
  });
  qx.test.bom.storage.WebStorageTestCase.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.bom.storage.WebStorageTestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.Storage": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.storage.Local", {
    extend: qx.test.bom.storage.WebStorageTestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      _getStorage: function _getStorage() {
        return qx.bom.Storage.getLocal();
      }
    }
  });
  qx.test.bom.storage.Local.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.bom.storage.WebStorageTestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.Storage": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.storage.Session", {
    extend: qx.test.bom.storage.WebStorageTestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      _getStorage: function _getStorage() {
        return qx.bom.Storage.getSession();
      }
    }
  });
  qx.test.bom.storage.Session.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.bom.client.Browser": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "browser.version": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.webfonts.Abstract", {
    extend: qx.dev.unit.TestCase,
    members: {
      hasWebFontSupport: function hasWebFontSupport() {
        var browser = qx.core.Environment.get("browser.name");
        var version = qx.core.Environment.get("browser.version");

        if (browser == "firefox" && version < 3.5 || browser == "opera" && version < 10) {
          return false;
        }

        return true;
      }
    }
  });
  qx.test.bom.webfonts.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.bom.webfonts.Abstract": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.util.ResourceManager": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.webfonts.Manager": {},
      "qx.bom.webfonts.WebFont": {},
      "qx.event.Timer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */

  /* ************************************************************************
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/webfonts/*)
   */
  qx.Class.define("qx.test.bom.webfonts.Manager", {
    extend: qx.test.bom.webfonts.Abstract,
    include: [qx.dev.unit.MRequirements],
    members: {
      __fontDefinitions__P_225_0: {
        finelinerScript: {
          family: "FinelinerScriptRegular",
          source: [qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fineliner_script-webfont.woff"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fineliner_script-webfont.ttf"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fineliner_script-webfont.eot")]
        },
        fontawesome: {
          family: "FontAwesome",
          source: [qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fontawesome-webfont.woff"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fontawesome-webfont.ttf"), qx.util.ResourceManager.getInstance().toUri("qx/test/webfonts/fontawesome-webfont.eot")]
        },
        invalid: {
          family: "MonkeypooBold",
          source: ["404.woff", "404.ttf", "404.eot"]
        }
      },
      __findRule__P_225_1: function __findRule__P_225_1(familyName) {
        var reg = new RegExp("@font-face.*?" + familyName, "m");

        var helper = function helper(cssText) {
          cssText = cssText.replace(/\n/g, "").replace(/\r/g, "");

          if (reg.exec(cssText)) {
            return true;
          }

          return false;
        };

        for (var i = 0, l = document.styleSheets.length; i < l; i++) {
          var sheet = document.styleSheets[i];

          if (sheet.cssText) {
            if (helper(sheet.cssText)) {
              return true;
            }
          } else if (sheet.cssRules) {
            for (var j = 0, m = sheet.cssRules.length; j < m; j++) {
              if (helper(sheet.cssRules[j].cssText)) {
                return true;
              }
            }
          }
        }

        return false;
      },
      setUp: function setUp() {
        this.require(["webFontSupport"]);

        this.__nodesBefore__P_225_2 = document.body.childNodes.length;
        this.__sheetsBefore__P_225_3 = document.styleSheets.length;
        this.__manager__P_225_4 = qx.bom.webfonts.Manager.getInstance();
      },
      tearDown: function tearDown() {
        this.__manager__P_225_4.dispose();

        qx.bom.webfonts.Manager.VALIDATION_TIMEOUT = 5000;
        delete qx.bom.webfonts.Manager.$$instance;
        this.__manager__P_225_4 = null;
        this.assertEquals(this.__nodesBefore__P_225_2, document.body.childNodes.length, "Manager did not remove all nodes!");
        this.assertEquals(this.__sheetsBefore__P_225_3, document.styleSheets.length, "Manager did not remove stylesheet!");
      },
      "test: create rule for valid font": function testCreateRuleForValidFont() {
        var font = new qx.bom.webfonts.WebFont();
        font.set({
          size: 18,
          family: ["monospace"],
          sources: [this.__fontDefinitions__P_225_0.finelinerScript]
        });
        qx.event.Timer.once(function () {
          this.resume(function () {
            var foundRule = this.__findRule__P_225_1(this.__fontDefinitions__P_225_0.finelinerScript.family);

            this.assertTrue(foundRule, "@font-face rule not found in document styles!");
          }, this);
        }, this, 2000);
        this.wait(3000);
      },
      "test: do not create rule for invalid font": function testDoNotCreateRuleForInvalidFont() {
        qx.bom.webfonts.Manager.VALIDATION_TIMEOUT = 100;
        var font = new qx.bom.webfonts.WebFont();
        font.set({
          family: ["monospace"],
          sources: [this.__fontDefinitions__P_225_0.invalid]
        });
        var that = this;
        window.setTimeout(function () {
          that.resume(function () {
            var foundRule = this.__findRule__P_225_1(this.__fontDefinitions__P_225_0.invalid.family);

            this.assertFalse(foundRule, "@font-face rule for invalid font found in document styles!");
          }, that);
        }, 2000);
        this.wait(3000);
      },
      "test: load webfont whith custom comparisonString": function testLoadWebfontWhithCustomComparisonString() {
        qx.bom.webfonts.Manager.VALIDATION_TIMEOUT = 100;
        var font = new qx.bom.webfonts.WebFont();
        font.set({
          family: ["fontawesome"],
          comparisonString: "\uf206\uf1e3\uf118\uf2a7",
          sources: [this.__fontDefinitions__P_225_0.fontawesome]
        });
        var that = this;
        window.setTimeout(function () {
          that.resume(function () {
            var foundRule = this.__findRule__P_225_1(this.__fontDefinitions__P_225_0.fontawesome.family);

            this.assertTrue(foundRule, "@font-face rule for custom comparisonString font not found in document styles!");
          }, that);
        }, 2000);
        this.wait(3000);
      },
      "test: load webfont with custom version": function testLoadWebfontWithCustomVersion() {
        var font = new qx.bom.webfonts.WebFont();
        font.set({
          family: ["monospace"],
          version: "1.0",
          sources: [this.__fontDefinitions__P_225_0.finelinerScript]
        });
        qx.event.Timer.once(function () {
          this.resume(function () {
            var foundRule = false; // it is browser dependent which type of font is loaded (woff, eot or ttf) so we have to
            // check all given types, stopping the loop if the font rule was found

            for (var n = 0; n < this.__fontDefinitions__P_225_0.finelinerScript.source.length && foundRule === false; n++) {
              foundRule = this.__findRule__P_225_1(this.__fontDefinitions__P_225_0.finelinerScript.source[n] + "\\?1\\.0");
            }

            this.assertTrue(foundRule, "@font-face rule for custom version not found in document styles!");
          }, this);
        }, this, 2000);
        this.wait(3000);
      }
    }
  });
  qx.test.bom.webfonts.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.bom.webfonts.Abstract": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.bom.webfonts.Validator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */
  qx.Class.define("qx.test.bom.webfonts.Validator", {
    extend: qx.test.bom.webfonts.Abstract,
    include: [qx.dev.unit.MRequirements],
    members: {
      setUp: function setUp() {
        this.__nodesBefore__P_226_0 = document.body.childNodes.length;

        this.require(["webFontSupport"]);

        this.__val__P_226_1 = new qx.bom.webfonts.Validator();
      },
      tearDown: function tearDown() {
        if (this.__val__P_226_1) {
          this.__val__P_226_1.dispose();

          delete this.__val__P_226_1;
        }

        qx.bom.webfonts.Validator.removeDefaultHelperElements();
        this.assertEquals(this.__nodesBefore__P_226_0, document.body.childNodes.length, "Validator did not clean up correctly!");
      },
      testValidFont: function testValidFont() {
        this.__val__P_226_1.setFontFamily("monospace, courier");

        this.__val__P_226_1.addListener("changeStatus", function (ev) {
          var result = ev.getData();
          this.resume(function (ev) {
            this.assertTrue(result.valid);
          }, this);
        }, this);

        var that = this;
        window.setTimeout(function () {
          that.__val__P_226_1.validate();
        }, 0);
        this.wait(1000);
      },
      testInvalidFont: function testInvalidFont() {
        this.__val__P_226_1.setFontFamily("zzzzzzzzzzzzzzz");

        this.__val__P_226_1.setTimeout(250);

        this.__val__P_226_1.addListener("changeStatus", function (ev) {
          var result = ev.getData();
          this.resume(function (ev) {
            this.assertFalse(result.valid);
          }, this);
        }, this);

        var that = this;
        window.setTimeout(function () {
          that.__val__P_226_1.validate();
        }, 0);
        this.wait(500);
      }
    }
  });
  qx.test.bom.webfonts.Validator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.ui.container.Composite": {},
      "qx.core.Assert": {},
      "qx.core.AssertionError": {},
      "qx.core.Object": {},
      "qx.type.BaseString": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.core.Assert", {
    extend: qx.dev.unit.TestCase,
    members: {
      testQxWidget: function testQxWidget() {
        // working widget
        var widget = new qx.ui.core.Widget();
        this.assertQxWidget(widget);
        widget.dispose();
        var comp = new qx.ui.container.Composite();
        this.assertQxWidget(comp);
        comp.dispose(); // not working

        this.assertException(function () {
          qx.core.Assert.assertQxWidget(true);
        }, qx.core.AssertionError, null, "1");
        this.assertException(function () {
          qx.core.Assert.assertQxWidget({});
        }, qx.core.AssertionError, null, "2");
        var o = new qx.core.Object();
        this.assertException(function () {
          qx.core.Assert.assertQxWidget(o);
        }, qx.core.AssertionError, null, "3");
        o.dispose();
      },
      testQxObject: function testQxObject() {
        // working widget
        var o = new qx.core.Object();
        this.assertQxObject(o);
        o.dispose();
        var widget = new qx.ui.core.Widget();
        this.assertQxObject(widget);
        widget.dispose(); // not working

        this.assertException(function () {
          qx.core.Assert.assertQxObject(true);
        }, qx.core.AssertionError, null, "1");
        this.assertException(function () {
          qx.core.Assert.assertQxObject({});
        }, qx.core.AssertionError, null, "2");
        this.assertException(function () {
          qx.core.Assert.assertQxObject(new qx.type.BaseString());
        }, qx.core.AssertionError, null, "2");
      },
      testCSSColor: function testCSSColor() {
        // working
        this.assertCssColor("red", "red");
        this.assertCssColor("black", "black");
        this.assertCssColor("aqua", "rgb(0,255,255)");
        this.assertCssColor("rgb(159,123,147)", "rgb(159,123,147)"); // not working

        this.assertException(function () {
          qx.core.Assert.assertCssColor("red", true);
        }, qx.core.AssertionError, null, "1");
        this.assertException(function () {
          qx.core.Assert.assertCssColor("red", "reed");
        }, qx.core.AssertionError, null, "2");
        this.assertException(function () {
          qx.core.Assert.assertCssColor("red", "rgb(15,45,56)");
        }, qx.core.AssertionError, null, "3"); // non existing color

        this.assertException(function () {
          qx.core.Assert.assertCssColor("grey", "grey");
        }, Error, null, "4");
      },
      testAssertElement: function testAssertElement() {
        // working
        this.assertElement(document.body);
        this.assertElement(document.createElement("div")); // not working

        this.assertException(function () {
          qx.core.Assert.assertElement("test");
        }, qx.core.AssertionError, null, "1");
        this.assertException(function () {
          qx.core.Assert.assertElement({});
        }, qx.core.AssertionError, null, "2");
        this.assertException(function () {
          qx.core.Assert.assertElement(true);
        }, qx.core.AssertionError, null, "2");
        this.assertException(function () {
          qx.core.Assert.assertElement(window);
        }, qx.core.AssertionError, null, "4");
      },
      testAssertArgumentsCount: function testAssertArgumentsCount() {
        this.assertException(function () {
          var f = function f(a, b) {
            qx.core.Assert.assertArgumentsCount(arguments, 2, 2);
          };

          f("1", "2", "3", "4", "5");
        }, qx.core.AssertionError, /but found '5' arguments\./g);
      },
      testAssertEventFired: function testAssertEventFired() {
        //  assertEventFired : function(obj, event, invokeFunc, listenerFunc, msg)
        var obj = new qx.core.Object();
        this.assertEventFired(obj, "xyz", function () {
          this.fireEvent("xyz");
        });
        this.assertException(function () {
          qx.core.Assert.assertEventFired(obj, "xyz", function () {
            this.fireEvent("xyz1");
          });
        }, qx.core.AssertionError);
      },
      testAssertEqualsFloat: function testAssertEqualsFloat() {
        this.assertEqualsFloat(1.0, 1.0);
        this.assertEqualsFloat(0.3, 0.30000000000000004);
        this.assertException(function () {
          qx.core.Assert.assertEqualsFloat(1.0, 1.0000001);
        }, qx.core.AssertionError);
        this.assertException(function () {
          qx.core.Assert.assertEqualsFloat(1.0, 0.0000009);
        }, qx.core.AssertionError); // test error message

        this.assertException(function () {
          qx.core.Assert.assertEqualsFloat(1.5, 1.6);
        }, qx.core.AssertionError, "Expected '1.5' to be equal with '1.6'!");
      },
      testAssertNotEqualsFloat: function testAssertNotEqualsFloat() {
        this.assertNotEqualsFloat(1.0, 1.0000001);
        this.assertNotEqualsFloat(1.5, 1.6);
        this.assertNotEqualsFloat(1.0, 0.0000009);
        this.assertException(function () {
          qx.core.Assert.assertNotEqualsFloat(1.0, 1.0);
        }, qx.core.AssertionError);
        this.assertException(function () {
          qx.core.Assert.assertNotEqualsFloat(0.3, 0.30000000000000004);
        }, qx.core.AssertionError); // test error message

        this.assertException(function () {
          qx.core.Assert.assertNotEqualsFloat(1.5, 1.5);
        }, qx.core.AssertionError, "Expected '1.5' to be not equal with '1.5'!");
      }
    }
  });
  qx.test.core.Assert.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.scroll.ScrollBar": {}
    },
    "environment": {
      "provided": ["qx.nativeScrollBars"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.core.Environment.add("qx.nativeScrollBars", false);
  /**
   * Include this widget if you want to create scrollbars depending on the global
   * "qx.nativeScrollBars" setting.
   */

  qx.Mixin.define("qx.ui.core.scroll.MScrollBarFactory", {
    members: {
      /**
       * Creates a new scrollbar. This can either be a styled qooxdoo scrollbar
       * or a native browser scrollbar.
       *
       * @param orientation {String?"horizontal"} The initial scroll bar orientation
       * @return {qx.ui.core.scroll.IScrollBar} The scrollbar instance
       */
      _createScrollBar: function _createScrollBar(orientation) {
        {
          return new qx.ui.core.scroll.ScrollBar(orientation);
        }
      }
    }
  });
  qx.ui.core.scroll.MScrollBarFactory.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.io.remote.Request": {
        "require": true
      },
      "qx.ui.core.scroll.MScrollBarFactory": {
        "require": true
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.bom.client.Locale": {},
      "qx.bom.client.OperatingSystem": {},
      "qx.bom.client.Plugin": {},
      "qx.bom.client.Flash": {},
      "qx.bom.client.Transport": {},
      "qx.bom.client.Html": {},
      "qx.bom.client.Stylesheet": {},
      "qx.bom.client.Xml": {},
      "qx.bom.client.Css": {},
      "qx.bom.client.PhoneGap": {},
      "qx.bom.client.Event": {},
      "qx.bom.client.EcmaScript": {},
      "qx.bom.client.Device": {},
      "qx.event.GlobalError": {},
      "qx.bom.client.Scroll": {},
      "qx.bom.client.CssAnimation": {},
      "qx.bom.client.CssTransform": {},
      "qx.bom.client.CssTransition": {}
    },
    "environment": {
      "provided": ["affe"],
      "required": {
        "affe": {},
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "engine.version": {
          "className": "qx.bom.client.Engine"
        },
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "browser.version": {
          "className": "qx.bom.client.Browser"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        },
        "browser.quirksmode": {
          "className": "qx.bom.client.Browser"
        },
        "locale": {
          "className": "qx.bom.client.Locale"
        },
        "locale.variant": {
          "className": "qx.bom.client.Locale"
        },
        "os.name": {
          "className": "qx.bom.client.OperatingSystem"
        },
        "os.version": {
          "className": "qx.bom.client.OperatingSystem"
        },
        "plugin.quicktime": {
          "className": "qx.bom.client.Plugin"
        },
        "plugin.quicktime.version": {
          "className": "qx.bom.client.Plugin"
        },
        "plugin.skype": {
          "className": "qx.bom.client.Plugin"
        },
        "plugin.windowsmedia": {
          "className": "qx.bom.client.Plugin"
        },
        "plugin.windowsmedia.version": {
          "className": "qx.bom.client.Plugin"
        },
        "plugin.divx": {
          "className": "qx.bom.client.Plugin"
        },
        "plugin.divx.version": {
          "className": "qx.bom.client.Plugin"
        },
        "plugin.silverlight": {
          "className": "qx.bom.client.Plugin"
        },
        "plugin.silverlight.version": {
          "className": "qx.bom.client.Plugin"
        },
        "plugin.flash": {
          "className": "qx.bom.client.Flash"
        },
        "plugin.flash.version": {
          "className": "qx.bom.client.Flash"
        },
        "plugin.flash.express": {
          "className": "qx.bom.client.Flash"
        },
        "plugin.flash.strictsecurity": {
          "className": "qx.bom.client.Flash"
        },
        "plugin.pdf": {
          "className": "qx.bom.client.Plugin"
        },
        "plugin.pdf.version": {
          "className": "qx.bom.client.Plugin"
        },
        "io.maxrequests": {
          "className": "qx.bom.client.Transport"
        },
        "io.ssl": {
          "className": "qx.bom.client.Transport"
        },
        "io.xhr": {
          "className": "qx.bom.client.Transport"
        },
        "html.webworker": {
          "className": "qx.bom.client.Html"
        },
        "html.geolocation": {
          "className": "qx.bom.client.Html"
        },
        "html.audio": {
          "className": "qx.bom.client.Html"
        },
        "html.audio.ogg": {
          "className": "qx.bom.client.Html"
        },
        "html.audio.mp3": {
          "className": "qx.bom.client.Html"
        },
        "html.audio.wav": {
          "className": "qx.bom.client.Html"
        },
        "html.audio.aif": {
          "className": "qx.bom.client.Html"
        },
        "html.audio.au": {
          "className": "qx.bom.client.Html"
        },
        "html.video": {
          "className": "qx.bom.client.Html"
        },
        "html.video.ogg": {
          "className": "qx.bom.client.Html"
        },
        "html.video.h264": {
          "className": "qx.bom.client.Html"
        },
        "html.video.webm": {
          "className": "qx.bom.client.Html"
        },
        "html.storage.local": {
          "className": "qx.bom.client.Html"
        },
        "html.storage.session": {
          "className": "qx.bom.client.Html"
        },
        "html.storage.userdata": {
          "className": "qx.bom.client.Html"
        },
        "html.classlist": {
          "className": "qx.bom.client.Html"
        },
        "html.xpath": {
          "className": "qx.bom.client.Html"
        },
        "html.xul": {
          "className": "qx.bom.client.Html"
        },
        "html.canvas": {
          "className": "qx.bom.client.Html"
        },
        "html.svg": {
          "className": "qx.bom.client.Html"
        },
        "html.vml": {
          "className": "qx.bom.client.Html"
        },
        "html.console": {
          "className": "qx.bom.client.Html"
        },
        "html.stylesheet.createstylesheet": {
          "className": "qx.bom.client.Stylesheet"
        },
        "html.stylesheet.insertrule": {
          "className": "qx.bom.client.Stylesheet"
        },
        "html.stylesheet.deleterule": {
          "className": "qx.bom.client.Stylesheet"
        },
        "html.stylesheet.addimport": {
          "className": "qx.bom.client.Stylesheet"
        },
        "html.stylesheet.removeimport": {
          "className": "qx.bom.client.Stylesheet"
        },
        "html.element.contains": {
          "className": "qx.bom.client.Html"
        },
        "html.element.compareDocumentPosition": {
          "className": "qx.bom.client.Html"
        },
        "html.element.textcontent": {},
        "html.image.naturaldimensions": {
          "className": "qx.bom.client.Html"
        },
        "html.history.state": {
          "className": "qx.bom.client.Html"
        },
        "html.selection": {
          "className": "qx.bom.client.Html"
        },
        "html.node.isequalnode": {
          "className": "qx.bom.client.Html"
        },
        "xml.implementation": {
          "className": "qx.bom.client.Xml"
        },
        "xml.domparser": {
          "className": "qx.bom.client.Xml"
        },
        "xml.selectsinglenode": {
          "className": "qx.bom.client.Xml"
        },
        "xml.selectnodes": {
          "className": "qx.bom.client.Xml"
        },
        "xml.getelementsbytagnamens": {
          "className": "qx.bom.client.Xml"
        },
        "xml.domproperties": {
          "className": "qx.bom.client.Xml"
        },
        "xml.attributens": {
          "className": "qx.bom.client.Xml"
        },
        "xml.createnode": {
          "className": "qx.bom.client.Xml"
        },
        "xml.getqualifieditem": {
          "className": "qx.bom.client.Xml"
        },
        "xml.createelementns": {
          "className": "qx.bom.client.Xml"
        },
        "plugin.gears": {
          "className": "qx.bom.client.Plugin"
        },
        "plugin.activex": {
          "className": "qx.bom.client.Plugin"
        },
        "css.boxmodel": {
          "className": "qx.bom.client.Css"
        },
        "css.placeholder": {
          "className": "qx.bom.client.Css"
        },
        "css.rgba": {
          "className": "qx.bom.client.Css"
        },
        "css.boxshadow": {
          "className": "qx.bom.client.Css"
        },
        "css.borderradius": {
          "className": "qx.bom.client.Css"
        },
        "css.borderimage": {
          "className": "qx.bom.client.Css"
        },
        "css.borderimage.standardsyntax": {
          "className": "qx.bom.client.Css"
        },
        "css.textoverflow": {
          "className": "qx.bom.client.Css"
        },
        "css.userselect": {
          "className": "qx.bom.client.Css"
        },
        "css.userselect.none": {
          "className": "qx.bom.client.Css"
        },
        "css.usermodify": {
          "className": "qx.bom.client.Css"
        },
        "css.appearance": {
          "className": "qx.bom.client.Css"
        },
        "css.boxsizing": {
          "className": "qx.bom.client.Css"
        },
        "css.inlineblock": {
          "className": "qx.bom.client.Css"
        },
        "css.opacity": {
          "className": "qx.bom.client.Css"
        },
        "css.gradient.linear": {
          "className": "qx.bom.client.Css"
        },
        "css.gradient.radial": {
          "className": "qx.bom.client.Css"
        },
        "css.gradient.legacywebkit": {
          "className": "qx.bom.client.Css"
        },
        "css.alphaimageloaderneeded": {
          "className": "qx.bom.client.Css"
        },
        "css.pointerevents": {
          "className": "qx.bom.client.Css"
        },
        "phonegap": {
          "className": "qx.bom.client.PhoneGap"
        },
        "phonegap.notification": {
          "className": "qx.bom.client.PhoneGap"
        },
        "event.touch": {
          "className": "qx.bom.client.Event"
        },
        "event.help": {
          "className": "qx.bom.client.Event"
        },
        "event.hashchange": {
          "className": "qx.bom.client.Event"
        },
        "event.dispatchevent": {
          "className": "qx.bom.client.Event"
        },
        "event.customevent": {
          "className": "qx.bom.client.Event"
        },
        "event.mouseevent": {
          "className": "qx.bom.client.Event"
        },
        "ecmascript.error.stacktrace": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.array.indexof": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.array.lastindexof": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.array.foreach": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.array.filter": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.array.map": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.array.some": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.array.every": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.array.reduce": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.array.reduceright": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.function.bind": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.object.keys": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.date.now": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.error.toString": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.string.trim": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.string.endsWith": {
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.string.startsWith": {
          "className": "qx.bom.client.EcmaScript"
        },
        "device.name": {
          "className": "qx.bom.client.Device"
        },
        "device.type": {
          "className": "qx.bom.client.Device"
        },
        "device.pixelRatio": {
          "className": "qx.bom.client.Device"
        },
        "qx.application": {},
        "qx.debug.dispose.level": {},
        "qx.globalErrorHandling": {
          "className": "qx.event.GlobalError"
        },
        "qx.debug.io.remote": {},
        "qx.debug.io.remote.data": {},
        "qx.mobile.nativescroll": {
          "className": "qx.bom.client.Scroll"
        },
        "css.animation": {
          "className": "qx.bom.client.CssAnimation"
        },
        "css.transform": {
          "className": "qx.bom.client.CssTransform"
        },
        "css.transition": {
          "className": "qx.bom.client.CssTransition"
        },
        "css.transform.3d": {
          "className": "qx.bom.client.CssTransform"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @require(qx.io.remote.Request)
   * @require(qx.ui.core.scroll.MScrollBarFactory)
   */
  qx.Class.define("qx.test.core.Environment", {
    extend: qx.test.ui.LayoutTestCase,
    members: {
      // /////////////////////////////////
      // TESTS FOR THE ENVIRONMENT CLASS
      // ////////////////////////////// //
      testGet: function testGet() {
        // fake the check
        qx.core.Environment.getChecks()["affe"] = function () {
          return "affe";
        };

        this.assertEquals("affe", qx.core.Environment.get("affe")); // clear the fake check

        delete qx.core.Environment.getChecks()["affe"];
        qx.core.Environment.invalidateCacheKey("affe");
      },
      testGetAsync: function testGetAsync() {
        // fake the check
        qx.core.Environment.getAsyncChecks()["affe"] = function (clb, self) {
          window.setTimeout(function () {
            clb.call(self, "affe");
          }, 0);
        };

        qx.core.Environment.getAsync("affe", function (result) {
          this.resume(function () {
            this.assertEquals("affe", result); // clear the fake check

            delete qx.core.Environment.getAsyncChecks()["affe"];
            qx.core.Environment.invalidateCacheKey("affe");
          }, this);
        }, this);
        this.wait();
      },
      testSelect: function testSelect() {
        // fake the check
        qx.core.Environment.getChecks()["affe"] = function () {
          return "affe";
        };

        var test;
        test = qx.core.Environment.select("affe", {
          "affe": "affe"
        });
        this.assertEquals(test, "affe"); // clear the fake check

        delete qx.core.Environment.getChecks()["affe"];
        qx.core.Environment.invalidateCacheKey("affe");
      },
      testSelectDefault: function testSelectDefault() {
        // fake the check
        qx.core.Environment.getChecks()["affe"] = function () {
          return "affe";
        };

        var test;
        test = qx.core.Environment.select("affe", {
          "default": "affe"
        });
        this.assertEquals(test, "affe"); // clear the fake check

        delete qx.core.Environment.getChecks()["affe"];
        qx.core.Environment.invalidateCacheKey("affe");
      },
      testSelectAsync: function testSelectAsync() {
        // fake the check
        qx.core.Environment.addAsync("affe", function (clb, self) {
          window.setTimeout(function () {
            clb.call(self, "AFFE");
          }, 0);
        });
        qx.core.Environment.selectAsync("affe", {
          "affe": function affe(result) {
            this.resume(function () {
              // clear the fake check
              delete qx.core.Environment.getChecks()["affe"];
              qx.core.Environment.invalidateCacheKey("affe");
              this.assertEquals("AFFE", result);
            }, this);
          }
        }, this);
        this.wait();
      },
      testCache: function testCache() {
        // fake the check
        qx.core.Environment.getChecks()["affe"] = function () {
          return "affe";
        };

        this.assertEquals("affe", qx.core.Environment.get("affe")); // clear the fake check

        delete qx.core.Environment.getChecks()["affe"];
        this.assertEquals("affe", qx.core.Environment.get("affe"));
        qx.core.Environment.invalidateCacheKey("affe");
      },
      testCacheInvalidation: function testCacheInvalidation() {
        // fake the check
        qx.core.Environment.getChecks()["affe"] = function () {
          return "affe";
        };

        this.assertEquals("affe", qx.core.Environment.get("affe"));
        qx.core.Environment.invalidateCacheKey("affe"); // fake another check

        qx.core.Environment.getChecks()["affe"] = function () {
          return "affe2";
        };

        this.assertEquals("affe2", qx.core.Environment.get("affe")); // clear the fake check

        delete qx.core.Environment.getChecks()["affe"];
        qx.core.Environment.invalidateCacheKey("affe");
      },
      testAddFunction: function testAddFunction() {
        qx.core.Environment.add("affe", function () {
          return "AFFE";
        });
        this.assertEquals("AFFE", qx.core.Environment.get("affe")); // clear the check

        delete qx.core.Environment.getChecks()["affe"];
        qx.core.Environment.invalidateCacheKey("affe");
      },
      testAddValue: function testAddValue() {
        qx.core.Environment.add("affe", "AFFE");
        this.assertEquals("AFFE", qx.core.Environment.get("affe")); // clear the check

        delete qx.core.Environment.getChecks()["affe"];
        qx.core.Environment.invalidateCacheKey("affe");
      },
      testAddAsyncFunction: function testAddAsyncFunction() {
        qx.core.Environment.addAsync("affe", function (clb, self) {
          window.setTimeout(function () {
            clb.call(self, "AFFE");
          }, 0);
        });
        qx.core.Environment.getAsync("affe", function (result) {
          this.resume(function () {
            this.assertEquals("AFFE", result); // clear the fake check

            delete qx.core.Environment.getAsyncChecks()["affe"];
            qx.core.Environment.invalidateCacheKey("affe");
          }, this);
        }, this);
        this.wait();
      },
      testFilter: function testFilter() {
        // fake the checks
        qx.core.Environment.getChecks()["affe1"] = function () {
          return true;
        };

        qx.core.Environment.getChecks()["affe2"] = function () {
          return false;
        };

        qx.core.Environment.getChecks()["affe3"] = function () {
          return true;
        };

        var array = qx.core.Environment.filter({
          "affe1": 1,
          "affe2": 2,
          "affe3": 3
        });
        this.assertEquals(2, array.length);
        this.assertEquals(1, array[0]);
        this.assertEquals(3, array[1]); // clear the fake check

        delete qx.core.Environment.getChecks()["affe1"];
        delete qx.core.Environment.getChecks()["affe2"];
        delete qx.core.Environment.getChecks()["affe3"];
        qx.core.Environment.invalidateCacheKey("affe1");
        qx.core.Environment.invalidateCacheKey("affe2");
        qx.core.Environment.invalidateCacheKey("affe3");
      },
      // //////////////////////////////
      // TESTS FOR THE CHECKS
      // //////////////////////////////
      testEngineName: function testEngineName() {
        this.assertNotEquals("", qx.core.Environment.get("engine.name"));
      },
      testEngineVersion: function testEngineVersion() {
        this.assertNotEquals("", qx.core.Environment.get("engine.version"));
      },
      testBrowser: function testBrowser() {
        this.assertNotEquals("", qx.core.Environment.get("browser.name"));
        this.assertNotEquals("", qx.core.Environment.get("browser.version"));
        qx.core.Environment.get("browser.documentmode");
        this.assertBoolean(qx.core.Environment.get("browser.quirksmode"));
      },
      testLocale: function testLocale() {
        this.assertNotEquals("", qx.core.Environment.get("locale"));
      },
      testVariant: function testVariant() {
        // just make sure the call is working
        qx.core.Environment.get("locale.variant");
      },
      testOS: function testOS() {
        // just make sure the call is working
        this.assertString(qx.core.Environment.get("os.name"));
        this.assertString(qx.core.Environment.get("os.version"));
      },
      testQuicktime: function testQuicktime() {
        // just make sure the call is working
        this.assertBoolean(qx.core.Environment.get("plugin.quicktime"));
        qx.core.Environment.get("plugin.quicktime.version");
      },
      testSkype: function testSkype() {
        // just make sure the call is working
        this.assertBoolean(qx.core.Environment.get("plugin.skype"));
      },
      testWmv: function testWmv() {
        // just make sure the call is working
        this.assertBoolean(qx.core.Environment.get("plugin.windowsmedia"));
        qx.core.Environment.get("plugin.windowsmedia.version");
      },
      testDivx: function testDivx() {
        // just make sure the call is working
        this.assertBoolean(qx.core.Environment.get("plugin.divx"));
        qx.core.Environment.get("plugin.divx.version");
      },
      testSilverlight: function testSilverlight() {
        // just make sure the call is working
        this.assertBoolean(qx.core.Environment.get("plugin.silverlight"));
        qx.core.Environment.get("plugin.silverlight.version");
      },
      testFlash: function testFlash() {
        // just make sure the call is working
        this.assertBoolean(qx.core.Environment.get("plugin.flash"));
        qx.core.Environment.get("plugin.flash.version");
        this.assertBoolean(qx.core.Environment.get("plugin.flash.express"));
        this.assertBoolean(qx.core.Environment.get("plugin.flash.strictsecurity"));
      },
      testPdf: function testPdf() {
        // just make sure the call is working
        this.assertBoolean(qx.core.Environment.get("plugin.pdf"));
        qx.core.Environment.get("plugin.pdf.version");
      },
      testIO: function testIO() {
        // just make sure the call is working
        qx.core.Environment.get("io.maxrequests");
        this.assertBoolean(qx.core.Environment.get("io.ssl"));
      },
      testIOXhr: function testIOXhr() {
        var xhr = qx.core.Environment.get("io.xhr");
        this.assertString(xhr); // Should return "xhr" when standard XHR is available

        if (window.XMLHttpRequest && window.location.protocol !== "file:") {
          this.assertEquals("xhr", xhr);
        }
      },
      testHtml: function testHtml() {
        // just make sure the call is working
        this.assertBoolean(qx.core.Environment.get("html.webworker"));
        this.assertBoolean(qx.core.Environment.get("html.geolocation"));
        this.assertBoolean(qx.core.Environment.get("html.audio"));
        this.assertString(qx.core.Environment.get("html.audio.ogg"));
        this.assertString(qx.core.Environment.get("html.audio.mp3"));
        this.assertString(qx.core.Environment.get("html.audio.wav"));
        this.assertString(qx.core.Environment.get("html.audio.aif"));
        this.assertString(qx.core.Environment.get("html.audio.au"));
        this.assertBoolean(qx.core.Environment.get("html.video"));
        this.assertString(qx.core.Environment.get("html.video.ogg"));
        this.assertString(qx.core.Environment.get("html.video.h264"));
        this.assertString(qx.core.Environment.get("html.video.webm"));
        this.assertBoolean(qx.core.Environment.get("html.storage.local"));
        this.assertBoolean(qx.core.Environment.get("html.storage.session"));
        this.assertBoolean(qx.core.Environment.get("html.storage.userdata"));
        this.assertBoolean(qx.core.Environment.get("html.classlist"));
        this.assertBoolean(qx.core.Environment.get("html.xpath"));
        this.assertBoolean(qx.core.Environment.get("html.xul"));
        this.assertBoolean(qx.core.Environment.get("html.canvas"));
        this.assertBoolean(qx.core.Environment.get("html.svg"));
        this.assertBoolean(qx.core.Environment.get("html.vml"));
        this.assertBoolean(qx.core.Environment.get("html.console"));
        this.assertBoolean(qx.core.Environment.get("html.stylesheet.createstylesheet"));
        this.assertBoolean(qx.core.Environment.get("html.stylesheet.insertrule"));
        this.assertBoolean(qx.core.Environment.get("html.stylesheet.deleterule"));
        this.assertBoolean(qx.core.Environment.get("html.stylesheet.addimport"));
        this.assertBoolean(qx.core.Environment.get("html.stylesheet.removeimport"));
        this.assertBoolean(qx.core.Environment.get("html.element.contains"));
        this.assertBoolean(qx.core.Environment.get("html.element.compareDocumentPosition"));
        this.assertBoolean(qx.core.Environment.get("html.element.textcontent"));
        this.assertBoolean(qx.core.Environment.get("html.image.naturaldimensions"));
        this.assertBoolean(qx.core.Environment.get("html.history.state"));
        this.assertString(qx.core.Environment.get("html.selection"));
        this.assertBoolean(qx.core.Environment.get("html.node.isequalnode"));
      },
      testXml: function testXml() {
        this.assertBoolean(qx.core.Environment.get("xml.implementation"));
        this.assertBoolean(qx.core.Environment.get("xml.domparser"));
        this.assertBoolean(qx.core.Environment.get("xml.selectsinglenode"));
        this.assertBoolean(qx.core.Environment.get("xml.selectnodes"));
        this.assertBoolean(qx.core.Environment.get("xml.getelementsbytagnamens"));
        this.assertBoolean(qx.core.Environment.get("xml.domproperties"));
        this.assertBoolean(qx.core.Environment.get("xml.attributens"));
        this.assertBoolean(qx.core.Environment.get("xml.createnode"));
        this.assertBoolean(qx.core.Environment.get("xml.getqualifieditem"));
        this.assertBoolean(qx.core.Environment.get("xml.createelementns"));
      },
      testGears: function testGears() {
        this.assertBoolean(qx.core.Environment.get("plugin.gears"));
      },
      testActiveX: function testActiveX() {
        this.assertBoolean(qx.core.Environment.get("plugin.activex"));
      },
      testCss: function testCss() {
        this.assertNotEquals("", qx.core.Environment.get("css.boxmodel"));
        this.assertBoolean(qx.core.Environment.get("css.placeholder"));
        this.assertBoolean(qx.core.Environment.get("css.rgba"));
        var boxShadow = qx.core.Environment.get("css.boxshadow");
        this.assert(typeof boxShadow === "string" || boxShadow === null);
        var borderRadius = qx.core.Environment.get("css.borderradius");
        this.assert(typeof borderRadius == "string" || borderRadius === null);
        var borderImage = qx.core.Environment.get("css.borderimage");
        this.assert(typeof borderImage == "string" || borderImage === null);
        var borderImageSyntax = qx.core.Environment.get("css.borderimage.standardsyntax");
        this.assert(typeof borderImageSyntax == "boolean" || borderImageSyntax === null);
        var textOverflow = qx.core.Environment.get("css.textoverflow");
        this.assert(typeof textOverflow == "string" || textOverflow === null);
        var userSelect = qx.core.Environment.get("css.userselect");
        this.assert(typeof userSelect == "string" || userSelect === null);
        var userSelectNone = qx.core.Environment.get("css.userselect.none");
        this.assert(typeof userSelectNone == "string" || userSelectNone === null);
        var userModify = qx.core.Environment.get("css.usermodify");
        this.assert(typeof userModify == "string" || userModify === null);
        var appearance = qx.core.Environment.get("css.appearance");
        this.assert(typeof appearance == "string" || appearance === null);
        var boxSizing = qx.core.Environment.get("css.boxsizing");
        this.assert(typeof boxSizing == "string" || boxSizing === null);
        var inlineBlock = qx.core.Environment.get("css.inlineblock");
        this.assert(typeof inlineBlock == "string" || inlineBlock === null);
        this.assertBoolean(qx.core.Environment.get("css.opacity"));
        var linearGradient = qx.core.Environment.get("css.gradient.linear");
        this.assert(typeof linearGradient == "string" || linearGradient === null);
        var radialGradient = qx.core.Environment.get("css.gradient.radial");
        this.assert(typeof radialGradient == "string" || radialGradient === null);
        this.assertBoolean(qx.core.Environment.get("css.gradient.legacywebkit"));
        this.assertBoolean(qx.core.Environment.get("css.alphaimageloaderneeded"));
        this.assertBoolean(qx.core.Environment.get("css.pointerevents"));
      },
      testPhoneGap: function testPhoneGap() {
        this.assertBoolean(qx.core.Environment.get("phonegap"));
        this.assertBoolean(qx.core.Environment.get("phonegap.notification"));
      },
      testEvent: function testEvent() {
        this.assertBoolean(qx.core.Environment.get("event.touch"));
        this.assertBoolean(qx.core.Environment.get("event.help"));
        this.assertBoolean(qx.core.Environment.get("event.hashchange"));
        this.assertBoolean(qx.core.Environment.get("event.dispatchevent"));
        this.assertBoolean(qx.core.Environment.get("event.customevent"));
        this.assertBoolean(qx.core.Environment.get("event.mouseevent"));
      },
      testEcmaScript: function testEcmaScript() {
        var stackTrace = qx.core.Environment.get("ecmascript.error.stacktrace");
        this.assert(typeof stackTrace == "string" || stackTrace === null);
        this.assertBoolean(qx.core.Environment.get("ecmascript.array.indexof"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.array.lastindexof"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.array.foreach"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.array.filter"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.array.map"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.array.some"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.array.every"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.array.reduce"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.array.reduceright"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.function.bind"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.object.keys"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.date.now"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.error.toString"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.string.trim"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.string.endsWith"));
        this.assertBoolean(qx.core.Environment.get("ecmascript.string.startsWith"));
      },
      testDataUrl: function testDataUrl() {
        qx.core.Environment.getAsync("html.dataurl", function (result) {
          this.resume(function () {
            this.assertBoolean(result);
          }, this);
        }, this);
        this.wait();
      },
      testDevice: function testDevice() {
        this.assertString(qx.core.Environment.get("device.name"));
      },
      testDeviceType: function testDeviceType() {
        this.assertString(qx.core.Environment.get("device.type"));
      },
      testDevicePixelRatio: function testDevicePixelRatio() {
        this.assertNumber(qx.core.Environment.get("device.pixelRatio"));
      },
      testQx: function testQx() {
        this.assertBoolean(false, "1");
        this.assertBoolean(false, "2");
        this.assertString(qx.core.Environment.get("qx.application"), "3");
        this.assertNumber(qx.core.Environment.get("qx.debug.dispose.level"), "5");
        this.assertBoolean(qx.core.Environment.get("qx.globalErrorHandling"), "6");
        this.assertBoolean(qx.core.Environment.get("qx.debug.io.remote"), "7");
        this.assertBoolean(qx.core.Environment.get("qx.debug.io.remote.data"), "8");
        this.assertBoolean(false, "9");
        this.assertNumber(0, "10");
        this.assertBoolean(true, "11");
        this.assertBoolean(false, "12");
        this.assertBoolean(true, "13");
        this.assertBoolean(qx.core.Environment.get("qx.mobile.nativescroll"), "15");
        this.assertBoolean(true, "17");
      },
      testAnimationTransformTransition: function testAnimationTransformTransition() {
        // smoke test... make sure the method is doing something
        qx.core.Environment.get("css.animation");
        qx.core.Environment.get("css.transform");
        qx.core.Environment.get("css.transition"); // 3d transform support

        this.assertBoolean(qx.core.Environment.get("css.transform.3d"));
      }
    }
  });
  qx.test.core.Environment.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * All widget used as scrollbars must implement this interface.
   */
  qx.Interface.define("qx.ui.core.scroll.IScrollBar", {
    events: {
      /** Fired if the user scroll */
      "scroll": "qx.event.type.Data",

      /** Fired as soon as the scroll animation ended. */
      "scrollAnimationEnd": 'qx.event.type.Event'
    },
    properties: {
      /**
       * The scroll bar orientation
       */
      orientation: {},

      /**
       * The maximum value (difference between available size and
       * content size).
       */
      maximum: {},

      /**
       * Position of the scrollbar (which means the scroll left/top of the
       * attached area's pane)
       *
       * Strictly validates according to {@link #maximum}.
       * Does not apply any correction to the incoming value. If you depend
       * on this, please use {@link #scrollTo} instead.
       */
      position: {},

      /**
       * Factor to apply to the width/height of the knob in relation
       * to the dimension of the underlying area.
       */
      knobFactor: {}
    },
    members: {
      /**
       * Scrolls to the given position.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param position {Integer} Scroll to this position. Must be greater zero.
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollTo: function scrollTo(position, duration) {
        this.assertNumber(position);
      },

      /**
       * Scrolls by the given offset.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param offset {Integer} Scroll by this offset
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollBy: function scrollBy(offset, duration) {
        this.assertNumber(offset);
      },

      /**
       * Scrolls by the given number of steps.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param steps {Integer} Number of steps
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollBySteps: function scrollBySteps(steps, duration) {
        this.assertNumber(steps);
      }
    }
  });
  qx.ui.core.scroll.IScrollBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.scroll.IScrollBar": {
        "require": true
      },
      "qx.ui.core.scroll.ScrollSlider": {},
      "qx.ui.form.RepeatButton": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.layout.VBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The scroll bar widget, is a special slider, which is used in qooxdoo instead
   * of the native browser scroll bars.
   *
   * Scroll bars are used by the {@link qx.ui.container.Scroll} container. Usually
   * a scroll bar is not used directly.
   *
   * @childControl slider {qx.ui.core.scroll.ScrollSlider} scroll slider component
   * @childControl button-begin {qx.ui.form.RepeatButton} button to scroll to top
   * @childControl button-end {qx.ui.form.RepeatButton} button to scroll to bottom
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var scrollBar = new qx.ui.core.scroll.ScrollBar("horizontal");
   *   scrollBar.set({
   *     maximum: 500
   *   })
   *   this.getRoot().add(scrollBar);
   * </pre>
   *
   * This example creates a horizontal scroll bar with a maximum value of 500.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/scrollbar.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.core.scroll.ScrollBar", {
    extend: qx.ui.core.Widget,
    implement: qx.ui.core.scroll.IScrollBar,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param orientation {String?"horizontal"} The initial scroll bar orientation
     */
    construct: function construct(orientation) {
      qx.ui.core.Widget.constructor.call(this); // Create child controls

      this._createChildControl("button-begin");

      this._createChildControl("slider").addListener("resize", this._onResizeSlider, this);

      this._createChildControl("button-end"); // Configure orientation


      if (orientation != null) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      } // prevent drag & drop on scrolling


      this.addListener("track", function (e) {
        e.stopPropagation();
      }, this);
    },
    events: {
      /** Change event for the value. */
      "scrollAnimationEnd": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "scrollbar"
      },

      /**
       * The scroll bar orientation
       */
      orientation: {
        check: ["horizontal", "vertical"],
        init: "horizontal",
        apply: "_applyOrientation"
      },

      /**
       * The maximum value (difference between available size and
       * content size).
       */
      maximum: {
        check: "PositiveInteger",
        apply: "_applyMaximum",
        init: 100
      },

      /**
       * Position of the scrollbar (which means the scroll left/top of the
       * attached area's pane)
       *
       * Strictly validates according to {@link #maximum}.
       * Does not apply any correction to the incoming value. If you depend
       * on this, please use {@link #scrollTo} instead.
       */
      position: {
        check: "qx.lang.Type.isNumber(value)&&value>=0&&value<=this.getMaximum()",
        init: 0,
        apply: "_applyPosition",
        event: "scroll"
      },

      /**
       * Step size for each tap on the up/down or left/right buttons.
       */
      singleStep: {
        check: "Integer",
        init: 20
      },

      /**
       * The amount to increment on each event. Typically corresponds
       * to the user pressing <code>PageUp</code> or <code>PageDown</code>.
       */
      pageStep: {
        check: "Integer",
        init: 10,
        apply: "_applyPageStep"
      },

      /**
       * Factor to apply to the width/height of the knob in relation
       * to the dimension of the underlying area.
       */
      knobFactor: {
        check: "PositiveNumber",
        apply: "_applyKnobFactor",
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __offset__P_396_0: 2,
      __originalMinSize__P_396_1: 0,
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var hint = qx.ui.core.scroll.ScrollBar.prototype._computeSizeHint.base.call(this);

        if (this.getOrientation() === "horizontal") {
          this.__originalMinSize__P_396_1 = hint.minWidth;
          hint.minWidth = 0;
        } else {
          this.__originalMinSize__P_396_1 = hint.minHeight;
          hint.minHeight = 0;
        }

        return hint;
      },
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        var changes = qx.ui.core.scroll.ScrollBar.prototype.renderLayout.base.call(this, left, top, width, height);
        var horizontal = this.getOrientation() === "horizontal";

        if (this.__originalMinSize__P_396_1 >= (horizontal ? width : height)) {
          this.getChildControl("button-begin").setVisibility("hidden");
          this.getChildControl("button-end").setVisibility("hidden");
        } else {
          this.getChildControl("button-begin").setVisibility("visible");
          this.getChildControl("button-end").setVisibility("visible");
        }

        return changes;
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "slider":
            control = new qx.ui.core.scroll.ScrollSlider();
            control.setPageStep(100);
            control.setFocusable(false);
            control.addListener("changeValue", this._onChangeSliderValue, this);
            control.addListener("slideAnimationEnd", this._onSlideAnimationEnd, this);

            this._add(control, {
              flex: 1
            });

            break;

          case "button-begin":
            // Top/Left Button
            control = new qx.ui.form.RepeatButton();
            control.setFocusable(false);
            control.addListener("execute", this._onExecuteBegin, this);

            this._add(control);

            break;

          case "button-end":
            // Bottom/Right Button
            control = new qx.ui.form.RepeatButton();
            control.setFocusable(false);
            control.addListener("execute", this._onExecuteEnd, this);

            this._add(control);

            break;
        }

        return control || qx.ui.core.scroll.ScrollBar.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyMaximum: function _applyMaximum(value) {
        this.getChildControl("slider").setMaximum(value);
      },
      // property apply
      _applyPosition: function _applyPosition(value) {
        this.getChildControl("slider").setValue(value);
      },
      // property apply
      _applyKnobFactor: function _applyKnobFactor(value) {
        this.getChildControl("slider").setKnobFactor(value);
      },
      // property apply
      _applyPageStep: function _applyPageStep(value) {
        this.getChildControl("slider").setPageStep(value);
      },
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        // Dispose old layout
        var oldLayout = this._getLayout();

        if (oldLayout) {
          oldLayout.dispose();
        } // Reconfigure


        if (value === "horizontal") {
          this._setLayout(new qx.ui.layout.HBox());

          this.setAllowStretchX(true);
          this.setAllowStretchY(false);
          this.replaceState("vertical", "horizontal");
          this.getChildControl("button-begin").replaceState("up", "left");
          this.getChildControl("button-end").replaceState("down", "right");
        } else {
          this._setLayout(new qx.ui.layout.VBox());

          this.setAllowStretchX(false);
          this.setAllowStretchY(true);
          this.replaceState("horizontal", "vertical");
          this.getChildControl("button-begin").replaceState("left", "up");
          this.getChildControl("button-end").replaceState("right", "down");
        } // Sync slider orientation


        this.getChildControl("slider").setOrientation(value);
      },

      /*
      ---------------------------------------------------------------------------
        METHOD REDIRECTION TO SLIDER
      ---------------------------------------------------------------------------
      */

      /**
       * Scrolls to the given position.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param position {Integer} Scroll to this position. Must be greater zero.
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollTo: function scrollTo(position, duration) {
        this.getChildControl("slider").slideTo(position, duration);
      },

      /**
       * Scrolls by the given offset.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param offset {Integer} Scroll by this offset
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollBy: function scrollBy(offset, duration) {
        this.getChildControl("slider").slideBy(offset, duration);
      },

      /**
       * Scrolls by the given number of steps.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param steps {Integer} Number of steps
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollBySteps: function scrollBySteps(steps, duration) {
        var size = this.getSingleStep();
        this.getChildControl("slider").slideBy(steps * size, duration);
      },

      /**
       * Updates the position property considering the minimum and maximum values.
       * @param position {Number} The new position.
       */
      updatePosition: function updatePosition(position) {
        this.getChildControl("slider").updatePosition(position);
      },

      /**
       * If a scroll animation is running, it will be stopped.
       */
      stopScrollAnimation: function stopScrollAnimation() {
        this.getChildControl("slider").stopSlideAnimation();
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENER
      ---------------------------------------------------------------------------
      */

      /**
       * Executed when the up/left button is executed (pressed)
       *
       * @param e {qx.event.type.Event} Execute event of the button
       */
      _onExecuteBegin: function _onExecuteBegin(e) {
        this.scrollBy(-this.getSingleStep(), 50);
      },

      /**
       * Executed when the down/right button is executed (pressed)
       *
       * @param e {qx.event.type.Event} Execute event of the button
       */
      _onExecuteEnd: function _onExecuteEnd(e) {
        this.scrollBy(this.getSingleStep(), 50);
      },

      /**
       * Change listener for slider animation end.
       */
      _onSlideAnimationEnd: function _onSlideAnimationEnd() {
        this.fireEvent("scrollAnimationEnd");
      },

      /**
       * Change listener for slider value changes.
       *
       * @param e {qx.event.type.Data} The change event object
       */
      _onChangeSliderValue: function _onChangeSliderValue(e) {
        this.setPosition(e.getData());
      },

      /**
       * Hide the knob of the slider if the slidebar is too small or show it
       * otherwise.
       *
       * @param e {qx.event.type.Data} event object
       */
      _onResizeSlider: function _onResizeSlider(e) {
        var knob = this.getChildControl("slider").getChildControl("knob");
        var knobHint = knob.getSizeHint();
        var hideKnob = false;
        var sliderSize = this.getChildControl("slider").getInnerSize();

        if (this.getOrientation() == "vertical") {
          if (sliderSize.height < knobHint.minHeight + this.__offset__P_396_0) {
            hideKnob = true;
          }
        } else {
          if (sliderSize.width < knobHint.minWidth + this.__offset__P_396_0) {
            hideKnob = true;
          }
        }

        if (hideKnob) {
          knob.exclude();
        } else {
          knob.show();
        }
      }
    }
  });
  qx.ui.core.scroll.ScrollBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which use a numeric value as their
   * primary data type like a spinner.
   */
  qx.Interface.define("qx.ui.form.INumberForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {Number|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {Number|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.INumberForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all widgets which deal with ranges. The spinner is a good
   * example for a range using widget.
   */
  qx.Interface.define("qx.ui.form.IRange", {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        MINIMUM PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Set the minimum value of the range.
       *
       * @param min {Number} The minimum.
       */
      setMinimum: function setMinimum(min) {
        return arguments.length == 1;
      },

      /**
       * Return the current set minimum of the range.
       *
       * @return {Number} The current set minimum.
       */
      getMinimum: function getMinimum() {},

      /*
      ---------------------------------------------------------------------------
        MAXIMUM PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Set the maximum value of the range.
       *
       * @param max {Number} The maximum.
       */
      setMaximum: function setMaximum(max) {
        return arguments.length == 1;
      },

      /**
       * Return the current set maximum of the range.
       *
       * @return {Number} The current set maximum.
       */
      getMaximum: function getMaximum() {},

      /*
      ---------------------------------------------------------------------------
        SINGLESTEP PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the value for single steps in the range.
       *
       * @param step {Number} The value of the step.
       */
      setSingleStep: function setSingleStep(step) {
        return arguments.length == 1;
      },

      /**
       * Returns the value which will be stepped in a single step in the range.
       *
       * @return {Number} The current value for single steps.
       */
      getSingleStep: function getSingleStep() {},

      /*
      ---------------------------------------------------------------------------
        PAGESTEP PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the value for page steps in the range.
       *
       * @param step {Number} The value of the step.
       */
      setPageStep: function setPageStep(step) {
        return arguments.length == 1;
      },

      /**
       * Returns the value which will be stepped in a page step in the range.
       *
       * @return {Number} The current value for page steps.
       */
      getPageStep: function getPageStep() {}
    }
  });
  qx.ui.form.IRange.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.locale.Manager": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Mixin handling the valid and required properties for the form widgets.
   */
  qx.Mixin.define("qx.ui.form.MForm", {
    construct: function construct() {
      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this.__onChangeLocale__P_416_0, this);
      }
    },
    properties: {
      /**
       * Flag signaling if a widget is valid. If a widget is invalid, an invalid
       * state will be set.
       */
      valid: {
        check: "Boolean",
        init: true,
        apply: "_applyValid",
        event: "changeValid"
      },

      /**
       * Flag signaling if a widget is required.
       */
      required: {
        check: "Boolean",
        init: false,
        event: "changeRequired"
      },

      /**
       * Message which is shown in an invalid tooltip.
       */
      invalidMessage: {
        check: "String",
        init: "",
        event: "changeInvalidMessage"
      },

      /**
       * Message which is shown in an invalid tooltip if the {@link #required} is
       * set to true.
       */
      requiredInvalidMessage: {
        check: "String",
        nullable: true,
        event: "changeInvalidMessage"
      }
    },
    members: {
      // apply method
      _applyValid: function _applyValid(value, old) {
        value ? this.removeState("invalid") : this.addState("invalid");
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      __onChangeLocale__P_416_0: function __onChangeLocale__P_416_0(e) {
        // invalid message
        var invalidMessage = this.getInvalidMessage();

        if (invalidMessage && invalidMessage.translate) {
          this.setInvalidMessage(invalidMessage.translate());
        } // required invalid message


        var requiredInvalidMessage = this.getRequiredInvalidMessage();

        if (requiredInvalidMessage && requiredInvalidMessage.translate) {
          this.setRequiredInvalidMessage(requiredInvalidMessage.translate());
        }
      }
    },
    destruct: function destruct() {
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this.__onChangeLocale__P_416_0, this);
      }
    }
  });
  qx.ui.form.MForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.INumberForm": {
        "require": true
      },
      "qx.ui.form.IRange": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.layout.Canvas": {
        "construct": true
      },
      "qx.theme.manager.Decoration": {},
      "qx.bom.element.Location": {},
      "qx.event.Timer": {},
      "qx.bom.AnimationFrame": {},
      "qx.event.type.Data": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The Slider widget provides a vertical or horizontal slider.
   *
   * The Slider is the classic widget for controlling a bounded value.
   * It lets the user move a slider handle along a horizontal or vertical
   * groove and translates the handle's position into an integer value
   * within the defined range.
   *
   * The Slider has very few of its own functions.
   * The most useful functions are slideTo() to set the slider directly to some
   * value; setSingleStep(), setPageStep() to set the steps; and setMinimum()
   * and setMaximum() to define the range of the slider.
   *
   * A slider accepts focus on Tab and provides both a mouse wheel and
   * a keyboard interface. The keyboard interface is the following:
   *
   * * Left/Right move a horizontal slider by one single step.
   * * Up/Down move a vertical slider by one single step.
   * * PageUp moves up one page.
   * * PageDown moves down one page.
   * * Home moves to the start (minimum).
   * * End moves to the end (maximum).
   *
   * Here are the main properties of the class:
   *
   * # <code>value</code>: The bounded integer that {@link qx.ui.form.INumberForm}
   * maintains.
   * # <code>minimum</code>: The lowest possible value.
   * # <code>maximum</code>: The highest possible value.
   * # <code>singleStep</code>: The smaller of two natural steps that an abstract
   * sliders provides and typically corresponds to the user pressing an arrow key.
   * # <code>pageStep</code>: The larger of two natural steps that an abstract
   * slider provides and typically corresponds to the user pressing PageUp or
   * PageDown.
   *
   * @childControl knob {qx.ui.core.Widget} knob to set the value of the slider
   */
  qx.Class.define("qx.ui.form.Slider", {
    extend: qx.ui.core.Widget,
    implement: [qx.ui.form.IForm, qx.ui.form.INumberForm, qx.ui.form.IRange],
    include: [qx.ui.form.MForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param orientation {String?"horizontal"} Configure the
     * {@link #orientation} property
     */
    construct: function construct(orientation) {
      qx.ui.core.Widget.constructor.call(this); // Force canvas layout

      this._setLayout(new qx.ui.layout.Canvas()); // Add listeners


      this.addListener("keypress", this._onKeyPress);
      this.addListener("roll", this._onRoll);
      this.addListener("pointerdown", this._onPointerDown);
      this.addListener("pointerup", this._onPointerUp);
      this.addListener("losecapture", this._onPointerUp);
      this.addListener("resize", this._onUpdate); // Stop events

      this.addListener("contextmenu", this._onStopEvent);
      this.addListener("tap", this._onStopEvent);
      this.addListener("dbltap", this._onStopEvent); // Initialize orientation

      if (orientation != null) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Change event for the value.
       */
      changeValue: 'qx.event.type.Data',

      /** Fired as soon as the slide animation ended. */
      slideAnimationEnd: 'qx.event.type.Event'
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "slider"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /** Whether the slider is horizontal or vertical. */
      orientation: {
        check: ["horizontal", "vertical"],
        init: "horizontal",
        apply: "_applyOrientation"
      },

      /**
       * The current slider value.
       *
       * Strictly validates according to {@link #minimum} and {@link #maximum}.
       * Do not apply any value correction to the incoming value. If you depend
       * on this, please use {@link #slideTo} instead.
       */
      value: {
        check: "typeof value==='number'&&value>=this.getMinimum()&&value<=this.getMaximum()",
        init: 0,
        apply: "_applyValue",
        nullable: true
      },

      /**
       * The minimum slider value (may be negative). This value must be smaller
       * than {@link #maximum}.
       */
      minimum: {
        check: "Integer",
        init: 0,
        apply: "_applyMinimum",
        event: "changeMinimum"
      },

      /**
       * The maximum slider value (may be negative). This value must be larger
       * than {@link #minimum}.
       */
      maximum: {
        check: "Integer",
        init: 100,
        apply: "_applyMaximum",
        event: "changeMaximum"
      },

      /**
       * The amount to increment on each event. Typically corresponds
       * to the user pressing an arrow key.
       */
      singleStep: {
        check: "Integer",
        init: 1
      },

      /**
       * The amount to increment on each event. Typically corresponds
       * to the user pressing <code>PageUp</code> or <code>PageDown</code>.
       */
      pageStep: {
        check: "Integer",
        init: 10
      },

      /**
       * Factor to apply to the width/height of the knob in relation
       * to the dimension of the underlying area.
       */
      knobFactor: {
        check: "Number",
        apply: "_applyKnobFactor",
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __sliderLocation__P_423_0: null,
      __knobLocation__P_423_1: null,
      __knobSize__P_423_2: null,
      __dragMode__P_423_3: null,
      __dragOffset__P_423_4: null,
      __trackingMode__P_423_5: null,
      __trackingDirection__P_423_6: null,
      __trackingEnd__P_423_7: null,
      __timer__P_423_8: null,
      // event delay stuff during drag
      __dragTimer__P_423_9: null,
      __lastValueEvent__P_423_10: null,
      __dragValue__P_423_11: null,
      __scrollAnimationframe__P_423_12: null,
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        invalid: true
      },
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        qx.ui.form.Slider.prototype.renderLayout.base.call(this, left, top, width, height); // make sure the layout engine does not override the knob position

        this._updateKnobPosition();
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "knob":
            control = new qx.ui.core.Widget();
            control.addListener("resize", this._onUpdate, this);
            control.addListener("pointerover", this._onPointerOver);
            control.addListener("pointerout", this._onPointerOut);

            this._add(control);

            break;
        }

        return control || qx.ui.form.Slider.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for pointerover events at the knob child control.
       *
       * Adds the 'hovered' state
       *
       * @param e {qx.event.type.Pointer} Incoming pointer event
       */
      _onPointerOver: function _onPointerOver(e) {
        this.addState("hovered");
      },

      /**
       * Event handler for pointerout events at the knob child control.
       *
       * Removes the 'hovered' state
       *
       * @param e {qx.event.type.Pointer} Incoming pointer event
       */
      _onPointerOut: function _onPointerOut(e) {
        this.removeState("hovered");
      },

      /**
       * Listener of roll event
       *
       * @param e {qx.event.type.Roll} Incoming event object
       */
      _onRoll: function _onRoll(e) {
        // only wheel
        if (e.getPointerType() != "wheel") {
          return;
        }

        var axis = this.getOrientation() === "horizontal" ? "x" : "y";
        var delta = e.getDelta()[axis];
        var direction = delta > 0 ? 1 : delta < 0 ? -1 : 0;
        this.slideBy(direction * this.getSingleStep());
        e.stop();
      },

      /**
       * Event handler for keypress events.
       *
       * Adds support for arrow keys, page up, page down, home and end keys.
       *
       * @param e {qx.event.type.KeySequence} Incoming keypress event
       */
      _onKeyPress: function _onKeyPress(e) {
        var isHorizontal = this.getOrientation() === "horizontal";
        var backward = isHorizontal ? "Left" : "Up";
        var forward = isHorizontal ? "Right" : "Down";

        switch (e.getKeyIdentifier()) {
          case forward:
            this.slideForward();
            break;

          case backward:
            this.slideBack();
            break;

          case "PageDown":
            this.slidePageForward(100);
            break;

          case "PageUp":
            this.slidePageBack(100);
            break;

          case "Home":
            this.slideToBegin(200);
            break;

          case "End":
            this.slideToEnd(200);
            break;

          default:
            return;
        } // Stop processed events


        e.stop();
      },

      /**
       * Listener of pointerdown event. Initializes drag or tracking mode.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onPointerDown: function _onPointerDown(e) {
        // this can happen if the user releases the button while dragging outside
        // of the browser viewport
        if (this.__dragMode__P_423_3) {
          return;
        }

        var isHorizontal = this.__isHorizontal__P_423_13;
        var knob = this.getChildControl("knob");
        var locationProperty = isHorizontal ? "left" : "top";
        var cursorLocation = isHorizontal ? e.getDocumentLeft() : e.getDocumentTop();
        var decorator = this.getDecorator();
        decorator = qx.theme.manager.Decoration.getInstance().resolve(decorator);

        if (isHorizontal) {
          var decoratorPadding = decorator ? decorator.getInsets().left : 0;
          var padding = (this.getPaddingLeft() || 0) + decoratorPadding;
        } else {
          var decoratorPadding = decorator ? decorator.getInsets().top : 0;
          var padding = (this.getPaddingTop() || 0) + decoratorPadding;
        }

        var sliderLocation = this.__sliderLocation__P_423_0 = qx.bom.element.Location.get(this.getContentElement().getDomElement())[locationProperty];
        sliderLocation += padding;
        var knobLocation = this.__knobLocation__P_423_1 = qx.bom.element.Location.get(knob.getContentElement().getDomElement())[locationProperty];

        if (e.getTarget() === knob) {
          // Switch into drag mode
          this.__dragMode__P_423_3 = true;

          if (!this.__dragTimer__P_423_9) {
            // create a timer to fire delayed dragging events if dragging stops.
            this.__dragTimer__P_423_9 = new qx.event.Timer(100);

            this.__dragTimer__P_423_9.addListener("interval", this._fireValue, this);
          }

          this.__dragTimer__P_423_9.start(); // Compute dragOffset (includes both: inner position of the widget and
          // cursor position on knob)


          this.__dragOffset__P_423_4 = cursorLocation + sliderLocation - knobLocation; // add state

          knob.addState("pressed");
        } else {
          // Switch into tracking mode
          this.__trackingMode__P_423_5 = true; // Detect tracking direction

          this.__trackingDirection__P_423_6 = cursorLocation <= knobLocation ? -1 : 1; // Compute end value

          this.__computeTrackingEnd__P_423_14(e); // Directly call interval method once


          this._onInterval(); // Initialize timer (when needed)


          if (!this.__timer__P_423_8) {
            this.__timer__P_423_8 = new qx.event.Timer(100);

            this.__timer__P_423_8.addListener("interval", this._onInterval, this);
          } // Start timer


          this.__timer__P_423_8.start();
        } // Register move listener


        this.addListener("pointermove", this._onPointerMove); // Activate capturing

        this.capture(); // Stop event

        e.stopPropagation();
      },

      /**
       * Listener of pointerup event. Used for cleanup of previously
       * initialized modes.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onPointerUp: function _onPointerUp(e) {
        if (this.__dragMode__P_423_3) {
          // Release capture mode
          this.releaseCapture(); // Cleanup status flags

          delete this.__dragMode__P_423_3; // as we come out of drag mode, make
          // sure content gets synced

          this.__dragTimer__P_423_9.stop();

          this._fireValue();

          delete this.__dragOffset__P_423_4; // remove state

          this.getChildControl("knob").removeState("pressed"); // it's necessary to check whether the cursor is over the knob widget to be able to
          // to decide whether to remove the 'hovered' state.

          if (e.getType() === "pointerup") {
            var deltaSlider;
            var deltaPosition;
            var positionSlider;

            if (this.__isHorizontal__P_423_13) {
              deltaSlider = e.getDocumentLeft() - (this._valueToPosition(this.getValue()) + this.__sliderLocation__P_423_0);
              positionSlider = qx.bom.element.Location.get(this.getContentElement().getDomElement())["top"];
              deltaPosition = e.getDocumentTop() - (positionSlider + this.getChildControl("knob").getBounds().top);
            } else {
              deltaSlider = e.getDocumentTop() - (this._valueToPosition(this.getValue()) + this.__sliderLocation__P_423_0);
              positionSlider = qx.bom.element.Location.get(this.getContentElement().getDomElement())["left"];
              deltaPosition = e.getDocumentLeft() - (positionSlider + this.getChildControl("knob").getBounds().left);
            }

            if (deltaPosition < 0 || deltaPosition > this.__knobSize__P_423_2 || deltaSlider < 0 || deltaSlider > this.__knobSize__P_423_2) {
              this.getChildControl("knob").removeState("hovered");
            }
          }
        } else if (this.__trackingMode__P_423_5) {
          // Stop timer interval
          this.__timer__P_423_8.stop(); // Release capture mode


          this.releaseCapture(); // Cleanup status flags

          delete this.__trackingMode__P_423_5;
          delete this.__trackingDirection__P_423_6;
          delete this.__trackingEnd__P_423_7;
        } // Remove move listener again


        this.removeListener("pointermove", this._onPointerMove); // Stop event

        if (e.getType() === "pointerup") {
          e.stopPropagation();
        }
      },

      /**
       * Listener of pointermove event for the knob. Only used in drag mode.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onPointerMove: function _onPointerMove(e) {
        if (this.__dragMode__P_423_3) {
          var dragStop = this.__isHorizontal__P_423_13 ? e.getDocumentLeft() : e.getDocumentTop();
          var position = dragStop - this.__dragOffset__P_423_4;
          this.slideTo(this._positionToValue(position));
        } else if (this.__trackingMode__P_423_5) {
          // Update tracking end on pointermove
          this.__computeTrackingEnd__P_423_14(e);
        } // Stop event


        e.stopPropagation();
      },

      /**
       * Listener of interval event by the internal timer. Only used
       * in tracking sequences.
       *
       * @param e {qx.event.type.Event} Incoming event object
       */
      _onInterval: function _onInterval(e) {
        // Compute new value
        var value = this.getValue() + this.__trackingDirection__P_423_6 * this.getPageStep(); // Limit value

        if (value < this.getMinimum()) {
          value = this.getMinimum();
        } else if (value > this.getMaximum()) {
          value = this.getMaximum();
        } // Stop at tracking position (where the pointer is pressed down)


        var slideBack = this.__trackingDirection__P_423_6 == -1;

        if (slideBack && value <= this.__trackingEnd__P_423_7 || !slideBack && value >= this.__trackingEnd__P_423_7) {
          value = this.__trackingEnd__P_423_7;
        } // Finally slide to the desired position


        this.slideTo(value);
      },

      /**
       * Listener of resize event for both the slider itself and the knob.
       *
       * @param e {qx.event.type.Data} Incoming event object
       */
      _onUpdate: function _onUpdate(e) {
        // Update sliding space
        var availSize = this.getInnerSize();
        var knobSize = this.getChildControl("knob").getBounds();
        var sizeProperty = this.__isHorizontal__P_423_13 ? "width" : "height"; // Sync knob size

        this._updateKnobSize(); // Store knob size


        this.__slidingSpace__P_423_15 = availSize[sizeProperty] - knobSize[sizeProperty];
        this.__knobSize__P_423_2 = knobSize[sizeProperty]; // Update knob position (sliding space must be updated first)

        this._updateKnobPosition();
      },

      /*
      ---------------------------------------------------------------------------
        UTILS
      ---------------------------------------------------------------------------
      */

      /** @type {Boolean} Whether the slider is laid out horizontally */
      __isHorizontal__P_423_13: false,

      /**
       * @type {Integer} Available space for knob to slide on, computed on resize of
       * the widget
       */
      __slidingSpace__P_423_15: 0,

      /**
       * Computes the value where the tracking should end depending on
       * the current pointer position.
       *
       * @param e {qx.event.type.Pointer} Incoming pointer event
       */
      __computeTrackingEnd__P_423_14: function __computeTrackingEnd__P_423_14(e) {
        var isHorizontal = this.__isHorizontal__P_423_13;
        var cursorLocation = isHorizontal ? e.getDocumentLeft() : e.getDocumentTop();
        var sliderLocation = this.__sliderLocation__P_423_0;
        var knobLocation = this.__knobLocation__P_423_1;
        var knobSize = this.__knobSize__P_423_2; // Compute relative position

        var position = cursorLocation - sliderLocation;

        if (cursorLocation >= knobLocation) {
          position -= knobSize;
        } // Compute stop value


        var value = this._positionToValue(position);

        var min = this.getMinimum();
        var max = this.getMaximum();

        if (value < min) {
          value = min;
        } else if (value > max) {
          value = max;
        } else {
          var old = this.getValue();
          var step = this.getPageStep();
          var method = this.__trackingDirection__P_423_6 < 0 ? "floor" : "ceil"; // Fix to page step

          value = old + Math[method]((value - old) / step) * step;
        } // Store value when undefined, otherwise only when it follows the
        // current direction e.g. goes up or down


        if (this.__trackingEnd__P_423_7 == null || this.__trackingDirection__P_423_6 == -1 && value <= this.__trackingEnd__P_423_7 || this.__trackingDirection__P_423_6 == 1 && value >= this.__trackingEnd__P_423_7) {
          this.__trackingEnd__P_423_7 = value;
        }
      },

      /**
       * Converts the given position to a value.
       *
       * Does not respect single or page step.
       *
       * @param position {Integer} Position to use
       * @return {Integer} Resulting value (rounded)
       */
      _positionToValue: function _positionToValue(position) {
        // Reading available space
        var avail = this.__slidingSpace__P_423_15; // Protect undefined value (before initial resize) and division by zero

        if (avail == null || avail == 0) {
          return 0;
        } // Compute and limit percent


        var percent = position / avail;

        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        } // Compute range


        var range = this.getMaximum() - this.getMinimum(); // Compute value

        return this.getMinimum() + Math.round(range * percent);
      },

      /**
       * Converts the given value to a position to place
       * the knob to.
       *
       * @param value {Integer} Value to use
       * @return {Integer} Computed position (rounded)
       */
      _valueToPosition: function _valueToPosition(value) {
        // Reading available space
        var avail = this.__slidingSpace__P_423_15;

        if (avail == null) {
          return 0;
        } // Computing range


        var range = this.getMaximum() - this.getMinimum(); // Protect division by zero

        if (range == 0) {
          return 0;
        } // Translating value to distance from minimum


        var value = value - this.getMinimum(); // Compute and limit percent

        var percent = value / range;

        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        } // Compute position from available space and percent


        return Math.round(avail * percent);
      },

      /**
       * Updates the knob position following the currently configured
       * value. Useful on reflows where the dimensions of the slider
       * itself have been modified.
       *
       */
      _updateKnobPosition: function _updateKnobPosition() {
        this._setKnobPosition(this._valueToPosition(this.getValue()));
      },

      /**
       * Moves the knob to the given position.
       *
       * @param position {Integer} Any valid position (needs to be
       *   greater or equal than zero)
       */
      _setKnobPosition: function _setKnobPosition(position) {
        // Use the DOM Element to prevent unnecessary layout recalculations
        var knob = this.getChildControl("knob");
        var dec = this.getDecorator();
        dec = qx.theme.manager.Decoration.getInstance().resolve(dec);
        var content = knob.getContentElement();

        if (this.__isHorizontal__P_423_13) {
          if (dec && dec.getPadding()) {
            position += dec.getPadding().left;
          }

          position += this.getPaddingLeft() || 0;
          content.setStyle("left", position + "px", true);
        } else {
          if (dec && dec.getPadding()) {
            position += dec.getPadding().top;
          }

          position += this.getPaddingTop() || 0;
          content.setStyle("top", position + "px", true);
        }
      },

      /**
       * Reconfigures the size of the knob depending on
       * the optionally defined {@link #knobFactor}.
       *
       */
      _updateKnobSize: function _updateKnobSize() {
        // Compute knob size
        var knobFactor = this.getKnobFactor();

        if (knobFactor == null) {
          return;
        } // Ignore when not rendered yet


        var avail = this.getInnerSize();

        if (avail == null) {
          return;
        } // Read size property


        if (this.__isHorizontal__P_423_13) {
          this.getChildControl("knob").setWidth(Math.round(knobFactor * avail.width));
        } else {
          this.getChildControl("knob").setHeight(Math.round(knobFactor * avail.height));
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDE METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Slides backward to the minimum value
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slideToBegin: function slideToBegin(duration) {
        this.slideTo(this.getMinimum(), duration);
      },

      /**
       * Slides forward to the maximum value
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slideToEnd: function slideToEnd(duration) {
        this.slideTo(this.getMaximum(), duration);
      },

      /**
       * Slides forward (right or bottom depending on orientation)
       *
       */
      slideForward: function slideForward() {
        this.slideBy(this.getSingleStep());
      },

      /**
       * Slides backward (to left or top depending on orientation)
       *
       */
      slideBack: function slideBack() {
        this.slideBy(-this.getSingleStep());
      },

      /**
       * Slides a page forward (to right or bottom depending on orientation)
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slidePageForward: function slidePageForward(duration) {
        this.slideBy(this.getPageStep(), duration);
      },

      /**
       * Slides a page backward (to left or top depending on orientation)
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slidePageBack: function slidePageBack(duration) {
        this.slideBy(-this.getPageStep(), duration);
      },

      /**
       * Slides by the given offset.
       *
       * This method works with the value, not with the coordinate.
       *
       * @param offset {Integer} Offset to scroll by
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slideBy: function slideBy(offset, duration) {
        this.slideTo(this.getValue() + offset, duration);
      },

      /**
       * Slides to the given value
       *
       * This method works with the value, not with the coordinate.
       *
       * @param value {Integer} Scroll to a value between the defined
       *   minimum and maximum.
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slideTo: function slideTo(value, duration) {
        this.stopSlideAnimation();

        if (duration) {
          this.__animateTo__P_423_16(value, duration);
        } else {
          this.updatePosition(value);
        }
      },

      /**
       * Updates the position property considering the minimum and maximum values.
       * @param value {Number} The new position.
       */
      updatePosition: function updatePosition(value) {
        this.setValue(this.__normalizeValue__P_423_17(value));
      },

      /**
       * In case a slide animation is currently running, it will be stopped.
       * If not, the method does nothing.
       */
      stopSlideAnimation: function stopSlideAnimation() {
        if (this.__scrollAnimationframe__P_423_12) {
          this.__scrollAnimationframe__P_423_12.cancelSequence();

          this.__scrollAnimationframe__P_423_12 = null;
        }
      },

      /**
       * Internal helper to normalize the given value concerning the minimum
       * and maximum value.
       * @param value {Number} The value to normalize.
       * @return {Number} The normalized value.
       */
      __normalizeValue__P_423_17: function __normalizeValue__P_423_17(value) {
        // Bring into allowed range or fix to single step grid
        if (value < this.getMinimum()) {
          value = this.getMinimum();
        } else if (value > this.getMaximum()) {
          value = this.getMaximum();
        } else {
          value = this.getMinimum() + Math.round((value - this.getMinimum()) / this.getSingleStep()) * this.getSingleStep();
        }

        return value;
      },

      /**
       * Animation helper which takes care of the animated slide.
       * @param to {Number} The target value.
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      __animateTo__P_423_16: function __animateTo__P_423_16(to, duration) {
        to = this.__normalizeValue__P_423_17(to);
        var from = this.getValue();
        this.__scrollAnimationframe__P_423_12 = new qx.bom.AnimationFrame();

        this.__scrollAnimationframe__P_423_12.on("frame", function (timePassed) {
          this.setValue(parseInt(timePassed / duration * (to - from) + from));
        }, this);

        this.__scrollAnimationframe__P_423_12.on("end", function () {
          this.setValue(to);
          this.__scrollAnimationframe__P_423_12 = null;
          this.fireEvent("slideAnimationEnd");
        }, this);

        this.__scrollAnimationframe__P_423_12.startSequence(duration);
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        var knob = this.getChildControl("knob"); // Update private flag for faster access

        this.__isHorizontal__P_423_13 = value === "horizontal"; // Toggle states and knob layout

        if (this.__isHorizontal__P_423_13) {
          this.removeState("vertical");
          knob.removeState("vertical");
          this.addState("horizontal");
          knob.addState("horizontal");
          knob.setLayoutProperties({
            top: 0,
            right: null,
            bottom: 0
          });
        } else {
          this.removeState("horizontal");
          knob.removeState("horizontal");
          this.addState("vertical");
          knob.addState("vertical");
          knob.setLayoutProperties({
            right: 0,
            bottom: null,
            left: 0
          });
        } // Sync knob position


        this._updateKnobPosition();
      },
      // property apply
      _applyKnobFactor: function _applyKnobFactor(value, old) {
        if (value != null) {
          this._updateKnobSize();
        } else {
          if (this.__isHorizontal__P_423_13) {
            this.getChildControl("knob").resetWidth();
          } else {
            this.getChildControl("knob").resetHeight();
          }
        }
      },
      // property apply
      _applyValue: function _applyValue(value, old) {
        if (value != null) {
          this._updateKnobPosition();

          if (this.__dragMode__P_423_3) {
            this.__dragValue__P_423_11 = [value, old];
          } else {
            this.fireEvent("changeValue", qx.event.type.Data, [value, old]);
          }
        } else {
          this.resetValue();
        }
      },

      /**
       * Helper for applyValue which fires the changeValue event.
       */
      _fireValue: function _fireValue() {
        if (!this.__dragValue__P_423_11) {
          return;
        }

        var tmp = this.__dragValue__P_423_11;
        this.__dragValue__P_423_11 = null;
        this.fireEvent("changeValue", qx.event.type.Data, tmp);
      },
      // property apply
      _applyMinimum: function _applyMinimum(value, old) {
        if (this.getValue() < value) {
          this.setValue(value);
        }

        this._updateKnobPosition();
      },
      // property apply
      _applyMaximum: function _applyMaximum(value, old) {
        if (this.getValue() > value) {
          this.setValue(value);
        }

        this._updateKnobPosition();
      }
    }
  });
  qx.ui.form.Slider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Slider": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Minimal modified version of the {@link qx.ui.form.Slider} to be
   * used by {@link qx.ui.core.scroll.ScrollBar}.
   *
   * @internal
   */
  qx.Class.define("qx.ui.core.scroll.ScrollSlider", {
    extend: qx.ui.form.Slider,
    // overridden
    construct: function construct(orientation) {
      qx.ui.form.Slider.constructor.call(this, orientation); // Remove roll/keypress events

      this.removeListener("keypress", this._onKeyPress);
      this.removeListener("roll", this._onRoll);
    },
    members: {
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "knob":
            control = qx.ui.core.scroll.ScrollSlider.prototype._createChildControlImpl.base.call(this, id);
            control.addListener("dblclick", function (e) {
              e.stopPropagation();
            });
        }

        return control || qx.ui.core.scroll.ScrollSlider.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden
      getSizeHint: function getSizeHint(compute) {
        // get the original size hint
        var hint = qx.ui.core.scroll.ScrollSlider.prototype.getSizeHint.base.call(this); // set the width or height to 0 depending on the orientation.
        // this is necessary to prevent the ScrollSlider to change the size
        // hint of its parent, which can cause errors on outer flex layouts
        // [BUG #3279]

        if (this.getOrientation() === "horizontal") {
          hint.width = 0;
        } else {
          hint.height = 0;
        }

        return hint;
      }
    }
  });
  qx.ui.core.scroll.ScrollSlider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which are executable in some way. This
   * could be a button for example.
   */
  qx.Interface.define("qx.ui.form.IExecutable", {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the widget is executed. Sets the "data" property of the
       * event to the object that issued the command.
       */
      "execute": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        COMMAND PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Set the command of this executable.
       *
       * @param command {qx.ui.command.Command} The command.
       */
      setCommand: function setCommand(command) {
        return arguments.length == 1;
      },

      /**
       * Return the current set command of this executable.
       *
       * @return {qx.ui.command.Command} The current set command.
       */
      getCommand: function getCommand() {},

      /**
       * Fire the "execute" event on the command.
       */
      execute: function execute() {}
    }
  });
  qx.ui.form.IExecutable.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.basic.Atom": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A Button widget which supports various states and allows it to be used
   * via the mouse, touch, pen and the keyboard.
   *
   * If the user presses the button by clicking on it, or the <code>Enter</code> or
   * <code>Space</code> keys, the button fires an {@link qx.ui.core.MExecutable#execute} event.
   *
   * If the {@link qx.ui.core.MExecutable#command} property is set, the
   * command is executed as well.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.form.Button("Hello World");
   *
   *   button.addListener("execute", function(e) {
   *     alert("Button was clicked");
   *   }, this);
   *
   *   this.getRoot().add(button);
   * </pre>
   *
   * This example creates a button with the label "Hello World" and attaches an
   * event listener to the {@link #execute} event.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/button.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.form.Button", {
    extend: qx.ui.basic.Atom,
    include: [qx.ui.core.MExecutable],
    implement: [qx.ui.form.IExecutable],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} label of the atom
     * @param icon {String?null} Icon URL of the atom
     * @param command {qx.ui.command.Command?null} Command instance to connect with
     */
    construct: function construct(label, icon, command) {
      qx.ui.basic.Atom.constructor.call(this, label, icon);

      if (command != null) {
        this.setCommand(command);
      } // Add listeners


      this.addListener("pointerover", this._onPointerOver);
      this.addListener("pointerout", this._onPointerOut);
      this.addListener("pointerdown", this._onPointerDown);
      this.addListener("pointerup", this._onPointerUp);
      this.addListener("tap", this._onTap);
      this.addListener("keydown", this._onKeyDown);
      this.addListener("keyup", this._onKeyUp); // Stop events

      this.addListener("dblclick", function (e) {
        e.stopPropagation();
      });
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "button"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        hovered: true,
        pressed: true,
        disabled: true
      },

      /*
      ---------------------------------------------------------------------------
        USER API
      ---------------------------------------------------------------------------
      */

      /**
       * Manually press the button
       */
      press: function press() {
        if (this.hasState("abandoned")) {
          return;
        }

        this.addState("pressed");
      },

      /**
       * Manually release the button
       */
      release: function release() {
        if (this.hasState("pressed")) {
          this.removeState("pressed");
        }
      },

      /**
       * Completely reset the button (remove all states)
       */
      reset: function reset() {
        this.removeState("pressed");
        this.removeState("abandoned");
        this.removeState("hovered");
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Listener method for "pointerover" event
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Mouse event
       */
      _onPointerOver: function _onPointerOver(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
          this.addState("pressed");
        }

        this.addState("hovered");
      },

      /**
       * Listener method for "pointerout" event
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" and removes "pressed" state (if "pressed" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Mouse event
       */
      _onPointerOut: function _onPointerOut(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        this.removeState("hovered");

        if (this.hasState("pressed")) {
          this.removeState("pressed");
          this.addState("abandoned");
        }
      },

      /**
       * Listener method for "pointerdown" event
       * <ul>
       * <li>Removes "abandoned" state</li>
       * <li>Adds "pressed" state</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Mouse event
       */
      _onPointerDown: function _onPointerDown(e) {
        if (!e.isLeftPressed()) {
          return;
        }

        e.stopPropagation(); // Activate capturing if the button get a pointerout while
        // the button is pressed.

        this.capture();
        this.removeState("abandoned");
        this.addState("pressed");
      },

      /**
       * Listener method for "pointerup" event
       * <ul>
       * <li>Removes "pressed" state (if set)</li>
       * <li>Removes "abandoned" state (if set)</li>
       * <li>Adds "hovered" state (if "abandoned" state is not set)</li>
       *</ul>
       *
       * @param e {qx.event.type.Pointer} Mouse event
       */
      _onPointerUp: function _onPointerUp(e) {
        this.releaseCapture(); // We must remove the states before executing the command
        // because in cases were the window lost the focus while
        // executing we get the capture phase back (mouseout).

        var hasPressed = this.hasState("pressed");
        var hasAbandoned = this.hasState("abandoned");

        if (hasPressed) {
          this.removeState("pressed");
        }

        if (hasAbandoned) {
          this.removeState("abandoned");
        }

        e.stopPropagation();
      },

      /**
       * Listener method for "tap" event which stops the propagation.
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onTap: function _onTap(e) {
        // "execute" is fired here so that the button can be dragged
        // without executing it (e.g. in a TabBar with overflow)
        this.execute();
        e.stopPropagation();
      },

      /**
       * Listener method for "keydown" event.<br/>
       * Removes "abandoned" and adds "pressed" state
       * for the keys "Enter" or "Space"
       *
       * @param e {Event} Key event
       */
      _onKeyDown: function _onKeyDown(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            this.removeState("abandoned");
            this.addState("pressed");
            e.stopPropagation();
        }
      },

      /**
       * Listener method for "keyup" event.<br/>
       * Removes "abandoned" and "pressed" state (if "pressed" state is set)
       * for the keys "Enter" or "Space"
       *
       * @param e {Event} Key event
       */
      _onKeyUp: function _onKeyUp(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            if (this.hasState("pressed")) {
              this.removeState("abandoned");
              this.removeState("pressed");
              this.execute();
              e.stopPropagation();
            }

        }
      }
    }
  });
  qx.ui.form.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Button": {
        "construct": true,
        "require": true
      },
      "qx.event.AcceleratingTimer": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The RepeatButton is a special button, which fires repeatedly {@link #execute}
   * events, while a button is pressed on the button. The initial delay
   * and the interval time can be set using the properties {@link #firstInterval}
   * and {@link #interval}. The {@link #execute} events will be fired in a shorter
   * amount of time if a button is hold, until the min {@link #minTimer}
   * is reached. The {@link #timerDecrease} property sets the amount of milliseconds
   * which will decreased after every firing.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.form.RepeatButton("Hello World");
   *
   *   button.addListener("execute", function(e) {
   *     alert("Button is executed");
   *   }, this);
   *
   *   this.getRoot.add(button);
   * </pre>
   *
   * This example creates a button with the label "Hello World" and attaches an
   * event listener to the {@link #execute} event.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/repeatbutton.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.form.RepeatButton", {
    extend: qx.ui.form.Button,

    /**
     * @param label {String} Label to use
     * @param icon {String?null} Icon to use
     */
    construct: function construct(label, icon) {
      qx.ui.form.Button.constructor.call(this, label, icon); // create the timer and add the listener

      this.__timer__P_420_0 = new qx.event.AcceleratingTimer();

      this.__timer__P_420_0.addListener("interval", this._onInterval, this);
    },
    events: {
      /**
       * This event gets dispatched with every interval. The timer gets executed
       * as long as the user holds down a button.
       */
      "execute": "qx.event.type.Event",

      /**
       * This event gets dispatched when the button is pressed.
       */
      "press": "qx.event.type.Event",

      /**
       * This event gets dispatched when the button is released.
       */
      "release": "qx.event.type.Event"
    },
    properties: {
      /**
       * Interval used after the first run of the timer. Usually a smaller value
       * than the "firstInterval" property value to get a faster reaction.
       */
      interval: {
        check: "Integer",
        init: 100
      },

      /**
       * Interval used for the first run of the timer. Usually a greater value
       * than the "interval" property value to a little delayed reaction at the first
       * time.
       */
      firstInterval: {
        check: "Integer",
        init: 500
      },

      /** This configures the minimum value for the timer interval. */
      minTimer: {
        check: "Integer",
        init: 20
      },

      /** Decrease of the timer on each interval (for the next interval) until minTimer reached. */
      timerDecrease: {
        check: "Integer",
        init: 2
      }
    },
    members: {
      __executed__P_420_1: null,
      __timer__P_420_0: null,

      /**
       * Calling this function is like a tap from the user on the
       * button with all consequences.
       * <span style='color: red'>Be sure to call the {@link #release} function.</span>
       *
       */
      press: function press() {
        // only if the button is enabled
        if (this.isEnabled()) {
          // if the state pressed must be applied (first call)
          if (!this.hasState("pressed")) {
            // start the timer
            this.__startInternalTimer__P_420_2();
          } // set the states


          this.removeState("abandoned");
          this.addState("pressed");
        }
      },

      /**
       * Calling this function is like a release from the user on the
       * button with all consequences.
       * Usually the {@link #release} function will be called before the call of
       * this function.
       *
       * @param fireExecuteEvent {Boolean?true} flag which signals, if an event should be fired
       */
      release: function release(fireExecuteEvent) {
        // only if the button is enabled
        if (!this.isEnabled()) {
          return;
        } // only if the button is pressed


        if (this.hasState("pressed")) {
          // if the button has not been executed
          if (!this.__executed__P_420_1) {
            this.execute();
          }
        } // remove button states


        this.removeState("pressed");
        this.removeState("abandoned"); // stop the repeat timer and therefore the execution

        this.__stopInternalTimer__P_420_3();
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.form.RepeatButton.prototype._applyEnabled.base.call(this, value, old);

        if (!value) {
          if (this.isCapturing()) {
            // also release capture because out event is missing on iOS
            this.releaseCapture();
          } // remove button states


          this.removeState("pressed");
          this.removeState("abandoned"); // stop the repeat timer and therefore the execution

          this.__stopInternalTimer__P_420_3();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Listener method for "pointerover" event
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onPointerOver: function _onPointerOver(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
          this.addState("pressed");

          this.__timer__P_420_0.start();
        }

        this.addState("hovered");
      },

      /**
       * Listener method for "pointerout" event
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" and removes "pressed" state (if "pressed" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onPointerOut: function _onPointerOut(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        this.removeState("hovered");

        if (this.hasState("pressed")) {
          this.removeState("pressed");
          this.addState("abandoned");

          this.__timer__P_420_0.stop();
        }
      },

      /**
       * Callback method for the "pointerdown" method.
       *
       * Sets the interval of the timer (value of firstInterval property) and
       * starts the timer. Additionally removes the state "abandoned" and adds the
       * state "pressed".
       *
       * @param e {qx.event.type.Pointer} pointerdown event
       */
      _onPointerDown: function _onPointerDown(e) {
        if (!e.isLeftPressed()) {
          return;
        } // Activate capturing if the button get a pointerout while
        // the button is pressed.


        this.capture();

        this.__startInternalTimer__P_420_2();

        e.stopPropagation();
      },

      /**
       * Callback method for the "pointerup" event.
       *
       * Handles the case that the user is releasing a button
       * before the timer interval method got executed. This way the
       * "execute" method get executed at least one time.
       *
       * @param e {qx.event.type.Pointer} pointerup event
       */
      _onPointerUp: function _onPointerUp(e) {
        this.releaseCapture();

        if (!this.hasState("abandoned")) {
          this.addState("hovered");

          if (this.hasState("pressed") && !this.__executed__P_420_1) {
            this.execute();
          }
        }

        this.__stopInternalTimer__P_420_3();

        e.stopPropagation();
      },
      // Nothing to do, 'execute' is already fired by _onPointerUp.
      _onTap: function _onTap(e) {},

      /**
       * Listener method for "keyup" event.
       *
       * Removes "abandoned" and "pressed" state (if "pressed" state is set)
       * for the keys "Enter" or "Space" and stops the internal timer
       * (same like pointer up).
       *
       * @param e {Event} Key event
       */
      _onKeyUp: function _onKeyUp(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            if (this.hasState("pressed")) {
              if (!this.__executed__P_420_1) {
                this.execute();
              }

              this.removeState("pressed");
              this.removeState("abandoned");
              e.stopPropagation();

              this.__stopInternalTimer__P_420_3();
            }

        }
      },

      /**
       * Listener method for "keydown" event.
       *
       * Removes "abandoned" and adds "pressed" state
       * for the keys "Enter" or "Space". It also starts
       * the internal timer (same like pointerdown).
       *
       * @param e {Event} Key event
       */
      _onKeyDown: function _onKeyDown(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            this.removeState("abandoned");
            this.addState("pressed");
            e.stopPropagation();

            this.__startInternalTimer__P_420_2();

        }
      },

      /**
       * Callback for the interval event.
       *
       * Stops the timer and starts it with a new interval
       * (value of the "interval" property - value of the "timerDecrease" property).
       * Dispatches the "execute" event.
       *
       * @param e {qx.event.type.Event} interval event
       */
      _onInterval: function _onInterval(e) {
        this.__executed__P_420_1 = true;
        this.fireEvent("execute");
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL TIMER
      ---------------------------------------------------------------------------
      */

      /**
       * Starts the internal timer which causes firing of execution
       * events in an interval. It also presses the button.
       *
       */
      __startInternalTimer__P_420_2: function __startInternalTimer__P_420_2() {
        this.fireEvent("press");
        this.__executed__P_420_1 = false;

        this.__timer__P_420_0.set({
          interval: this.getInterval(),
          firstInterval: this.getFirstInterval(),
          minimum: this.getMinTimer(),
          decrease: this.getTimerDecrease()
        }).start();

        this.removeState("abandoned");
        this.addState("pressed");
      },

      /**
       * Stops the internal timer and releases the button.
       *
       */
      __stopInternalTimer__P_420_3: function __stopInternalTimer__P_420_3() {
        this.fireEvent("release");

        this.__timer__P_420_0.stop();

        this.removeState("abandoned");
        this.removeState("pressed");
      }
    },

    /*
      *****************************************************************************
         DESTRUCTOR
      *****************************************************************************
      */
    destruct: function destruct() {
      this._disposeObjects("__timer__P_420_0");
    }
  });
  qx.ui.form.RepeatButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  qx.Class.define("qx.test.core.EventEmitterDummy", {
    extend: qx.core.Object,
    events: {
      "plain": "qx.event.type.Event",
      "error": "qx.__12345__",
      "data": "qx.event.type.Data",
      "eventName": "qx.event.type.Data"
    }
  });
  qx.test.core.EventEmitterDummy.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.core.InheritanceDummy", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.children = [];
    },
    properties: {
      enabled: {
        inheritable: true
      },
      width_: {
        inheritable: true,
        themeable: true
      },
      height_: {
        inheritable: true,
        themeable: true
      },
      left_: {
        inheritable: true,
        themeable: true
      },
      top_: {
        inheritable: true,
        themeable: true
      }
    },
    members: {
      add: function add(child) {
        this.children.push(child);
        child.parent = this;
        child.$$refreshInheritables();
      },
      _getChildren: function _getChildren() {
        return this.children;
      },
      getLayoutParent: function getLayoutParent() {
        return this.parent;
      }
    }
  });
  qx.test.core.InheritanceDummy.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.core.Object": {},
      "qx.core.IDisposable": {},
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 Zenesis Ltd http://www.zenesis.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com)
  
   ************************************************************************ */
  qx.Class.define("qx.test.core.MemoryManagement", {
    extend: qx.dev.unit.TestCase,
    members: {
      testEnvSetting: function testEnvSetting() {
        var ClassDisposable = qx.Class.define(null, {
          extend: qx.core.Object,
          implement: [qx.core.IDisposable]
        });
        var ClassNotDisposable = qx.Class.define(null, {
          extend: qx.core.Object
        });
        this.assertTrue(true);
        var objDisposable = new ClassDisposable();
        var objNotDisposable = new ClassNotDisposable();
        this.assertIdentical(objDisposable, qx.core.ObjectRegistry.fromHashCode(objDisposable.toHashCode()));
        this.assertNull(qx.core.ObjectRegistry.fromHashCode(objNotDisposable.toHashCode()));
      }
    }
  });
  qx.test.core.MemoryManagement.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.core.Object": {},
      "qx.test.core.EventEmitterDummy": {},
      "qx.log.Logger": {},
      "qx.event.type.Event": {},
      "qx.event.type.Data": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.Single.getInstance, qx.test.Single)
   */
  qx.Class.define("qx.test.core.Object", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    events: {
      "test": "qx.event.type.Event",
      "test2": "qx.event.type.Event"
    },
    members: {
      testHasListener: function testHasListener() {
        var listener = function listener() {};

        this.assertFalse(this.hasListener("testHasListener", false));
        this.assertFalse(this.hasListener("testHasListener2", false));
        this.addListener("testHasListener", listener, this, false);
        this.assertTrue(this.hasListener("testHasListener", false));
        this.assertFalse(this.hasListener("testHasListener2", false));
        this.addListener("testHasListener2", listener, this, false);
        this.assertTrue(this.hasListener("testHasListener", false));
        this.assertTrue(this.hasListener("testHasListener2", false));
        this.removeListener("testHasListener", listener, this, false);
        this.removeListener("testHasListener2", listener, this, false);
        this.assertFalse(this.hasListener("testHasListener", false));
        this.assertFalse(this.hasListener("testHasListener2", false));
      },
      testAddListener: function testAddListener() {
        var listener = function listener() {};

        this.addListener("testAddListener", listener, this, false);
        this.assertTrue(this.hasListener("testAddListener", false));
        this.removeListener("testAddListener", listener, this, false);
        this.assertFalse(this.hasListener("testAddListener", false));
      },
      testAddListenerOnce: function testAddListenerOnce() {
        var listener = function listener() {};

        this.addListenerOnce("testAddListenerOnce", listener, this, false);
        this.assertTrue(this.hasListener("testAddListenerOnce", false));
        this.removeListener("testAddListenerOnce", listener, this, false);
        this.assertFalse(this.hasListener("testAddListenerOnce", false));
      },
      testAddListenerOnceWithSameListener: function testAddListenerOnceWithSameListener() {
        var called = 0;

        var listener = function listener() {
          // debugger;
          called++;
        };

        this.addListenerOnce("test", listener);
        this.addListenerOnce("test2", listener);
        this.fireEvent("test");
        this.assertEquals(1, called);
        this.fireEvent("test");
        this.assertEquals(1, called);
      },
      testAddListenerOnceWithDifferentContext: function testAddListenerOnceWithDifferentContext() {
        var called = 0;

        var listener = function listener() {
          // debugger;
          called++;
        };

        var context1 = {
          name: "context1"
        };
        var context2 = {
          name: "context2"
        };
        this.addListenerOnce("test", listener, context1);
        this.addListenerOnce("test", listener, context2);
        this.fireEvent("test");
        this.assertEquals(2, called);
      },
      testRemoveListenerById: function testRemoveListenerById() {
        var id = this.addListener("testRemoveListenerById", function () {}, this, false);
        this.assertTrue(this.hasListener("testRemoveListenerById", false));
        this.removeListenerById(id);
        this.assertFalse(this.hasListener("testRemoveListenerById", false));
      },
      testRemoveListenerOnceById: function testRemoveListenerOnceById() {
        var id = this.addListenerOnce("testRemoveListenerOnceById", function () {}, this, false);
        this.assertTrue(this.hasListener("testRemoveListenerOnceById", false));
        this.removeListenerById(id);
        this.assertFalse(this.hasListener("testRemoveListenerOnceById", false));
      },
      testUserData: function testUserData() {
        var o = new qx.core.Object();
        this.assertNull(o.getUserData("foo"));
        o.setUserData("foo", "bar");
        this.assertEquals("bar", o.getUserData("foo"));
        this.assertNull(o.getUserData("bar"));
        o.dispose();
      },
      testRemoveListenerByIdAsync: function testRemoveListenerByIdAsync() {
        var executed = false;
        var id = this.addListener("testRemoveListenerByIdAsync", function () {
          executed = true;
        }, this);
        this.removeListenerById(id);
        this.fireEvent("testRemoveListenerByIdAsync");
        var self = this;
        window.setTimeout(function () {
          self.resume(function () {
            this.assertFalse(executed, "Event has been executed.");
          }, self);
        }, 3000);
        this.wait();
      },
      testFireDataEvent: function testFireDataEvent() {
        var self = this;
        var data = [];
        data.push({
          value: "a",
          old: "b"
        });
        data.push({
          value: "a",
          old: ""
        });
        data.push({
          value: 1,
          old: 0
        });
        data.push({
          value: 12,
          old: -123
        });
        data.push({
          value: true,
          old: false
        });
        data.push({
          value: false,
          old: true
        });
        data.push({
          value: /^a/,
          old: null
        });
        data.push({
          value: ["a"],
          old: []
        });
        var emitter = new qx.test.core.EventEmitterDummy();

        for (var i = 0; i < data.length; i++) {
          this.assertEventFired(emitter, "eventName", function () {
            emitter.fireDataEvent("eventName", data[i].value, data[i].old);
          }, function (e) {
            self.assertEquals(data[i].value, e.getData());
            self.assertEquals(data[i].old, e.getOldData());
          });
        }

        emitter.dispose();
      },
      testFireEventTypeCheck: function testFireEventTypeCheck() {
        if (!this.isDebugOn()) {
          return;
        }

        var emitter = new qx.test.core.EventEmitterDummy();
        emitter.addListener("plain", function () {});
        emitter.addListener("error", function () {});
        emitter.addListener("data", function () {}); // store error logger

        var oldError = qx.log.Logger.error;
        var called = 0;

        qx.log.Logger.error = function () {
          called += 1;
        };

        emitter.fireEvent("plain", qx.event.type.Event);
        this.assertEquals(0, called);
        emitter.fireEvent("error", qx.event.type.Event);
        this.assertEquals(1, called);
        emitter.fireEvent("data", qx.event.type.Event);
        this.assertEquals(2, called);
        emitter.fireEvent("data", qx.event.type.Data);
        this.assertEquals(2, called);
        qx.log.Logger.error = oldError;
        emitter.dispose();
      },
      testDisposeObject: function testDisposeObject() {
        // regular object dispose
        var o = new qx.core.Object();
        o.o = new qx.core.Object();

        o._disposeObjects("o");

        this.assertNull(o.o); // check if a dispose of not existent object works

        o._disposeObjects("x"); // object dispose with a singleton


        qx.Class.define("qx.test.Single", {
          extend: qx.core.Object,
          type: "singleton"
        });
        o.dispose();
        var o = new qx.core.Object();
        o.s = qx.test.Single.getInstance();
        this.assertException(function () {
          o._disposeObjects("s");
        });
        qx.Class.undefine("qx.test.Single");
        o.dispose();
      },
      testDisposeBindingWithChain: function testDisposeBindingWithChain() {
        // object dispose with a singleton
        qx.Class.define("qx.test.Single", {
          extend: qx.core.Object,
          properties: {
            a: {
              event: "changeA",
              nullable: true
            }
          }
        });
        var o = new qx.test.Single();
        var o2 = new qx.test.Single();
        var o3 = new qx.test.Single();
        o.bind("a.a", o2, "a");
        o.setA(o3);
        this.assertEquals(1, o.getBindings().length);
        o.dispose();
        this.assertEquals(0, o.getBindings().length);
        this.assertEventNotFired(o2, "changeA", function () {
          o3.setA("affe");
        });
        o2.dispose();
        o3.dispose();
        qx.Class.undefine("qx.test.Single");
      },
      testDisposeBindingWithSelfChain: function testDisposeBindingWithSelfChain() {
        // object dispose with a singleton
        qx.Class.define("qx.test.Single", {
          extend: qx.core.Object,
          properties: {
            a: {
              event: "changeA",
              nullable: true
            },
            b: {
              event: "changeB",
              nullable: true,
              apply: "applyB"
            }
          },
          members: {
            applyB: function applyB() {},
            init: function init() {
              this.bind("a.a", this, "b");
            }
          }
        });
        var o = new qx.test.Single();
        var o2 = new qx.test.Single();
        var spy = this.spy(o, "applyB");
        o.init();
        o.setA(o2);
        this.assertEquals(1, o.getBindings().length);
        o.dispose();
        o2.setA("affe");
        this.assertEquals(0, o.getBindings().length);
        this.assertCalledOnce(spy);
        o2.dispose();
        qx.Class.undefine("qx.test.Single");
      },
      testDisposeBinding: function testDisposeBinding() {
        // object dispose with a singleton
        qx.Class.define("qx.test.Single", {
          extend: qx.core.Object,
          properties: {
            a: {
              event: "changeA",
              nullable: true
            },
            b: {
              event: "changeB",
              nullable: true
            }
          }
        });
        var o = new qx.test.Single();
        var o2 = new qx.test.Single();
        o.bind("a", o2, "a");
        o.bind("a", o, "b");
        o2.bind("a", o, "a");
        this.assertEquals(3, o.getBindings().length);
        this.assertEquals(2, o2.getBindings().length);
        o.dispose();
        o2.dispose();
        qx.Class.undefine("qx.test.Single");
        this.assertEquals(0, o.getBindings().length);
        this.assertEquals(0, o2.getBindings().length);
      },
      testDisposeSingletonObject: function testDisposeSingletonObject() {
        // object dispose with a singleton and an object
        qx.Class.define("qx.test.Single", {
          extend: qx.core.Object,
          type: "singleton"
        });
        var o = new qx.core.Object();
        o.o = new qx.core.Object();
        o.s = qx.test.Single.getInstance();

        o._disposeSingletonObjects("o", "s");

        this.assertTrue(o.o == null);
        this.assertTrue(o.s == null);
        qx.Class.undefine("qx.test.Single");
        o.dispose();
      },

      /**
       * @ignore(qx.test.MyClass)
       */
      testIsPropertyInitialized: function testIsPropertyInitialized() {
        qx.Class.define("qx.test.MyClass", {
          extend: qx.core.Object,
          properties: {
            a: {},
            b: {
              init: false
            }
          }
        });
        var o = new qx.test.MyClass();
        this.assertFalse(o.isPropertyInitialized("a"));
        o.setA(false);
        this.assertTrue(o.isPropertyInitialized("a"));
        this.assertTrue(o.isPropertyInitialized("b"));
        qx.Class.undefine("qx.test.MyClass");
        o.dispose();
      }
    }
  });
  qx.test.core.Object.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.core.Object": {},
      "qx.ui.form.TextField": {},
      "qx.core.Id": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Zenesis Limited, http://www.zenesis.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
  
  ************************************************************************ */

  /**
   * @ignore(demo.MyClass)
   */
  qx.Class.define("qx.test.core.ObjectId", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      testGetObject: function testGetObject() {
        var clazz = qx.Class.define("demo.MyClass", {
          extend: qx.core.Object,
          members: {
            _createQxObjectImpl: function _createQxObjectImpl(id) {
              switch (id) {
                case "txt":
                  return new qx.ui.form.TextField();
              }

              return demo.MyClass.prototype._createQxObjectImpl.base.call(this, id);
            }
          }
        });
        var obj = new demo.MyClass();
        var Id = qx.core.Id.getInstance();
        Id.register(obj, "test");
        var txt = obj.getQxObject("txt");
        this.assertTrue(txt === obj.getQxObject("txt"));
        this.assertTrue(txt.getQxObjectId() === "txt");
        this.assertTrue(Id.getQxObject("test") === obj);
        this.assertTrue(Id.getQxObject("test/txt") === txt);
        obj.removeOwnedQxObject(txt);
        var txt2 = obj.getQxObject("txt");
        this.assertTrue(txt !== txt2);
        this.assertTrue(txt2 === obj.getQxObject("txt"));
        txt.setQxObjectId("txt-orig");
        obj.addOwnedQxObject(txt);
        this.assertTrue(txt === obj.getQxObject("txt-orig"));
        var obj2 = new demo.MyClass();
        obj2.addOwnedQxObject(txt);
        this.assertTrue(obj.getQxObject("txt-orig") === undefined);
        this.assertTrue(obj2.getQxObject("txt-orig") === txt);
        Id.unregister("test");
        this.assertTrue(!Id.getQxObject("test"));
      }
    }
  });
  qx.test.core.ObjectId.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IStringForm": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.theme.manager.Color": {},
      "qx.ui.style.Stylesheet": {
        "defer": "runtime"
      },
      "qx.bom.client.Css": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true,
        "defer": "runtime"
      },
      "qx.html.Input": {},
      "qx.util.ResourceManager": {},
      "qx.theme.manager.Font": {},
      "qx.bom.webfonts.WebFont": {},
      "qx.bom.Font": {},
      "qx.html.Element": {},
      "qx.bom.Label": {},
      "qx.ui.core.queue.Layout": {},
      "qx.lang.Type": {},
      "qx.event.type.Data": {},
      "qx.html.Label": {},
      "qx.bom.Stylesheet": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "engine.version": {
          "className": "qx.bom.client.Engine"
        },
        "css.placeholder": {
          "construct": true,
          "className": "qx.bom.client.Css"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        },
        "browser.version": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This is a basic form field with common functionality for
   * {@link TextArea} and {@link TextField}.
   *
   * On every keystroke the value is synchronized with the
   * value of the textfield. Value changes can be monitored by listening to the
   * {@link #input} or {@link #changeValue} events, respectively.
   */
  qx.Class.define("qx.ui.form.AbstractField", {
    extend: qx.ui.core.Widget,
    implement: [qx.ui.form.IStringForm, qx.ui.form.IForm],
    include: [qx.ui.form.MForm],
    type: "abstract",
    statics: {
      /** Stylesheet needed to style the native placeholder element. */
      __stylesheet__P_410_0: null,

      /**
       * Adds the CSS rules needed to style the native placeholder element.
       */
      __addPlaceholderRules__P_410_1: function __addPlaceholderRules__P_410_1() {
        var engine = qx.core.Environment.get("engine.name");
        var browser = qx.core.Environment.get("browser.name");
        var colorManager = qx.theme.manager.Color.getInstance();
        var color = colorManager.resolve("text-placeholder");
        var selector;

        if (engine == "gecko") {
          // see https://developer.mozilla.org/de/docs/CSS/:-moz-placeholder for details
          if (parseFloat(qx.core.Environment.get("engine.version")) >= 19) {
            selector = "input::-moz-placeholder, textarea::-moz-placeholder";
          } else {
            selector = "input:-moz-placeholder, textarea:-moz-placeholder";
          }

          qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color + " !important");
        } else if (engine == "webkit" && browser != "edge") {
          selector = "input.qx-placeholder-color::-webkit-input-placeholder, textarea.qx-placeholder-color::-webkit-input-placeholder";
          qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color);
        } else if (engine == "mshtml" || browser == "edge") {
          var separator = browser == "edge" ? "::" : ":";
          selector = ["input.qx-placeholder-color", "-ms-input-placeholder, textarea.qx-placeholder-color", "-ms-input-placeholder"].join(separator);
          qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color + " !important");
        }
      }
    },

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {String} initial text value of the input field ({@link #setValue}).
     */
    construct: function construct(value) {
      qx.ui.core.Widget.constructor.call(this); // shortcut for placeholder feature detection

      this.__useQxPlaceholder__P_410_2 = !qx.core.Environment.get("css.placeholder");

      if (value != null) {
        this.setValue(value);
      }

      this.getContentElement().addListener("change", this._onChangeContent, this); // use qooxdoo placeholder if no native placeholder is supported

      if (this.__useQxPlaceholder__P_410_2) {
        // assign the placeholder text after the appearance has been applied
        this.addListener("syncAppearance", this._syncPlaceholder, this);
      } else {
        // add rules for native placeholder color
        qx.ui.form.AbstractField.__addPlaceholderRules__P_410_1(); // add a class to the input to restrict the placeholder color


        this.getContentElement().addClass("qx-placeholder-color");
      } // translation support


      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * The event is fired on every keystroke modifying the value of the field.
       *
       * The method {@link qx.event.type.Data#getData} returns the
       * current value of the text field.
       */
      "input": "qx.event.type.Data",

      /**
       * The event is fired each time the text field looses focus and the
       * text field values has changed.
       *
       * If you change {@link #liveUpdate} to true, the changeValue event will
       * be fired after every keystroke and not only after every focus loss. In
       * that mode, the changeValue event is equal to the {@link #input} event.
       *
       * The method {@link qx.event.type.Data#getData} returns the
       * current text value of the field.
       */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Alignment of the text
       */
      textAlign: {
        check: ["left", "center", "right"],
        nullable: true,
        themeable: true,
        apply: "_applyTextAlign"
      },

      /** Whether the field is read only */
      readOnly: {
        check: "Boolean",
        apply: "_applyReadOnly",
        event: "changeReadOnly",
        init: false
      },
      // overridden
      selectable: {
        refine: true,
        init: true
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /** Maximal number of characters that can be entered in the TextArea. */
      maxLength: {
        apply: "_applyMaxLength",
        check: "PositiveInteger",
        init: Infinity
      },

      /**
       * Whether the {@link #changeValue} event should be fired on every key
       * input. If set to true, the changeValue event is equal to the
       * {@link #input} event.
       */
      liveUpdate: {
        check: "Boolean",
        init: false
      },

      /**
       * Fire a {@link #changeValue} event whenever the content of the
       * field matches the given regular expression. Accepts both regular
       * expression objects as well as strings for input.
       */
      liveUpdateOnRxMatch: {
        check: "RegExp",
        transform: "_string2RegExp",
        init: null
      },

      /**
       * String value which will be shown as a hint if the field is all of:
       * unset, unfocused and enabled. Set to null to not show a placeholder
       * text.
       */
      placeholder: {
        check: "String",
        nullable: true,
        apply: "_applyPlaceholder"
      },

      /**
       * RegExp responsible for filtering the value of the textfield. the RegExp
       * gives the range of valid values.
       * Note: The regexp specified is applied to each character in turn, 
       * NOT to the entire string. So only regular expressions matching a 
       * single character make sense in the context.
       * The following example only allows digits in the textfield.
       * <pre class='javascript'>field.setFilter(/[0-9]/);</pre>
       */
      filter: {
        check: "RegExp",
        nullable: true,
        init: null
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __nullValue__P_410_3: true,
      _placeholder: null,
      __oldValue__P_410_4: null,
      __oldInputValue__P_410_5: null,
      __useQxPlaceholder__P_410_2: true,
      __font__P_410_6: null,
      __webfontListenerId__P_410_7: null,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      getFocusElement: function getFocusElement() {
        var el = this.getContentElement();

        if (el) {
          return el;
        }
      },

      /**
       * Creates the input element. Derived classes may override this
       * method, to create different input elements.
       *
       * @return {qx.html.Input} a new input element.
       */
      _createInputElement: function _createInputElement() {
        return new qx.html.Input("text");
      },
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        var updateInsets = this._updateInsets;
        var changes = qx.ui.form.AbstractField.prototype.renderLayout.base.call(this, left, top, width, height); // Directly return if superclass has detected that no
        // changes needs to be applied

        if (!changes) {
          return;
        }

        var inner = changes.size || updateInsets;
        var pixel = "px";

        if (inner || changes.local || changes.margin) {
          var innerWidth = width;
          var innerHeight = height;
        }

        var input = this.getContentElement(); // we don't need to update positions on native placeholders

        if (updateInsets && this.__useQxPlaceholder__P_410_2) {
          if (this.__useQxPlaceholder__P_410_2) {
            var insets = this.getInsets();

            this._getPlaceholderElement().setStyles({
              paddingTop: insets.top + pixel,
              paddingRight: insets.right + pixel,
              paddingBottom: insets.bottom + pixel,
              paddingLeft: insets.left + pixel
            });
          }
        }

        if (inner || changes.margin) {
          // we don't need to update dimensions on native placeholders
          if (this.__useQxPlaceholder__P_410_2) {
            var insets = this.getInsets();

            this._getPlaceholderElement().setStyles({
              "width": innerWidth - insets.left - insets.right + pixel,
              "height": innerHeight - insets.top - insets.bottom + pixel
            });
          }

          input.setStyles({
            "width": innerWidth + pixel,
            "height": innerHeight + pixel
          });

          this._renderContentElement(innerHeight, input);
        }

        if (changes.position) {
          if (this.__useQxPlaceholder__P_410_2) {
            this._getPlaceholderElement().setStyles({
              "left": left + pixel,
              "top": top + pixel
            });
          }
        }
      },

      /**
       * Hook into {@link qx.ui.form.AbstractField#renderLayout} method.
       * Called after the contentElement has a width and an innerWidth.
       *
       * Note: This was introduced to fix BUG#1585
       *
       * @param innerHeight {Integer} The inner height of the element.
       * @param element {Element} The element.
       */
      _renderContentElement: function _renderContentElement(innerHeight, element) {//use it in child classes
      },
      // overridden
      _createContentElement: function _createContentElement() {
        // create and add the input element
        var el = this._createInputElement(); // initialize the html input


        el.setSelectable(this.getSelectable());
        el.setEnabled(this.getEnabled()); // Add listener for input event

        el.addListener("input", this._onHtmlInput, this); // Disable HTML5 spell checking

        el.setAttribute("spellcheck", "false");
        el.addClass("qx-abstract-field"); // IE8 in standard mode needs some extra love here to receive events.

        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") == 8) {
          el.setStyles({
            backgroundImage: "url(" + qx.util.ResourceManager.getInstance().toUri("qx/static/blank.gif") + ")"
          });
        }

        return el;
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.form.AbstractField.prototype._applyEnabled.base.call(this, value, old);

        this.getContentElement().setEnabled(value);

        if (this.__useQxPlaceholder__P_410_2) {
          if (value) {
            this._showPlaceholder();
          } else {
            this._removePlaceholder();
          }
        } else {
          var input = this.getContentElement(); // remove the placeholder on disabled input elements

          input.setAttribute("placeholder", value ? this.getPlaceholder() : "");
        }
      },
      // default text sizes

      /**
       * @lint ignoreReferenceField(__textSize)
       */
      __textSize__P_410_8: {
        width: 16,
        height: 16
      },
      // overridden
      _getContentHint: function _getContentHint() {
        return {
          width: this.__textSize__P_410_8.width * 10,
          height: this.__textSize__P_410_8.height || 16
        };
      },
      // overridden
      _applyFont: function _applyFont(value, old) {
        if (old && this.__font__P_410_6 && this.__webfontListenerId__P_410_7) {
          this.__font__P_410_6.removeListenerById(this.__webfontListenerId__P_410_7);

          this.__webfontListenerId__P_410_7 = null;
        } // Apply


        var styles;

        if (value) {
          this.__font__P_410_6 = qx.theme.manager.Font.getInstance().resolve(value);

          if (this.__font__P_410_6 instanceof qx.bom.webfonts.WebFont) {
            this.__webfontListenerId__P_410_7 = this.__font__P_410_6.addListener("changeStatus", this._onWebFontStatusChange, this);
          }

          styles = this.__font__P_410_6.getStyles();
        } else {
          styles = qx.bom.Font.getDefaultStyles();
        } // check if text color already set - if so this local value has higher priority


        if (this.getTextColor() != null) {
          delete styles["color"];
        } // apply the font to the content element
        // IE 8 - 10 (but not 11 Preview) will ignore the lineHeight value
        // unless it's applied directly.


        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 11) {
          qx.html.Element.flush();
          this.getContentElement().setStyles(styles, true);
        } else {
          this.getContentElement().setStyles(styles);
        } // the font will adjust automatically on native placeholders


        if (this.__useQxPlaceholder__P_410_2) {
          // don't apply the color to the placeholder
          delete styles["color"]; // apply the font to the placeholder

          this._getPlaceholderElement().setStyles(styles);
        } // Compute text size


        if (value) {
          this.__textSize__P_410_8 = qx.bom.Label.getTextSize("A", styles);
        } else {
          delete this.__textSize__P_410_8;
        } // Update layout


        qx.ui.core.queue.Layout.add(this);
      },
      // overridden
      _applyTextColor: function _applyTextColor(value, old) {
        if (value) {
          this.getContentElement().setStyle("color", qx.theme.manager.Color.getInstance().resolve(value));
        } else {
          this.getContentElement().removeStyle("color");
        }
      },
      // property apply
      _applyMaxLength: function _applyMaxLength(value, old) {
        if (value) {
          this.getContentElement().setAttribute("maxLength", value);
        } else {
          this.getContentElement().removeAttribute("maxLength");
        }
      },
      // property transform
      _string2RegExp: function _string2RegExp(value, old) {
        if (qx.lang.Type.isString(value)) {
          value = new RegExp(value);
        }

        return value;
      },
      // overridden
      tabFocus: function tabFocus() {
        qx.ui.form.AbstractField.prototype.tabFocus.base.call(this);
        this.selectAllText();
      },

      /**
       * Returns the text size.
       * @return {Map} The text size.
       */
      _getTextSize: function _getTextSize() {
        return this.__textSize__P_410_8;
      },

      /*
      ---------------------------------------------------------------------------
        EVENTS
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for native input events. Redirects the event
       * to the widget. Also checks for the filter and max length.
       *
       * @param e {qx.event.type.Data} Input event
       */
      _onHtmlInput: function _onHtmlInput(e) {
        var value = e.getData();
        var fireEvents = true;
        this.__nullValue__P_410_3 = false; // value unchanged; Firefox fires "input" when pressing ESC [BUG #5309]

        if (this.__oldInputValue__P_410_5 && this.__oldInputValue__P_410_5 === value) {
          fireEvents = false;
        } // check for the filter


        if (this.getFilter() != null) {
          var filteredValue = this._validateInput(value);

          if (filteredValue != value) {
            fireEvents = this.__oldInputValue__P_410_5 !== filteredValue;
            value = filteredValue;
            this.getContentElement().setValue(value);
          }
        } // fire the events, if necessary


        if (fireEvents) {
          // store the old input value
          this.fireDataEvent("input", value, this.__oldInputValue__P_410_5);
          this.__oldInputValue__P_410_5 = value; // check for the live change event

          if (this.getLiveUpdate()) {
            this.__fireChangeValueEvent__P_410_9(value);
          } // check for the liveUpdateOnRxMatch change event
          else {
              var fireRx = this.getLiveUpdateOnRxMatch();

              if (fireRx && value.match(fireRx)) {
                this.__fireChangeValueEvent__P_410_9(value);
              }
            }
        }
      },

      /**
       * Triggers text size recalculation after a web font was loaded
       *
       * @param ev {qx.event.type.Data} "changeStatus" event
       */
      _onWebFontStatusChange: function _onWebFontStatusChange(ev) {
        if (ev.getData().valid === true) {
          var styles = this.__font__P_410_6.getStyles();

          this.__textSize__P_410_8 = qx.bom.Label.getTextSize("A", styles);
          qx.ui.core.queue.Layout.add(this);
        }
      },

      /**
       * Handles the firing of the changeValue event including the local cache
       * for sending the old value in the event.
       *
       * @param value {String} The new value.
       */
      __fireChangeValueEvent__P_410_9: function __fireChangeValueEvent__P_410_9(value) {
        var old = this.__oldValue__P_410_4;
        this.__oldValue__P_410_4 = value;

        if (old != value) {
          this.fireNonBubblingEvent("changeValue", qx.event.type.Data, [value, old]);
        }
      },

      /*
      ---------------------------------------------------------------------------
        TEXTFIELD VALUE API
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the value of the textfield to the given value.
       *
       * @param value {String} The new value
       */
      setValue: function setValue(value) {
        if (this.isDisposed()) {
          return null;
        } // handle null values


        if (value === null) {
          // just do nothing if null is already set
          if (this.__nullValue__P_410_3) {
            return value;
          }

          value = "";
          this.__nullValue__P_410_3 = true;
        } else {
          this.__nullValue__P_410_3 = false; // native placeholders will be removed by the browser

          if (this.__useQxPlaceholder__P_410_2) {
            this._removePlaceholder();
          }
        }

        if (qx.lang.Type.isString(value)) {
          var elem = this.getContentElement();

          if (elem.getValue() != value) {
            var oldValue = elem.getValue();
            elem.setValue(value);
            var data = this.__nullValue__P_410_3 ? null : value;
            this.__oldValue__P_410_4 = oldValue;

            this.__fireChangeValueEvent__P_410_9(data); // reset the input value on setValue calls [BUG #6892]


            this.__oldInputValue__P_410_5 = this.__oldValue__P_410_4;
          } // native placeholders will be shown by the browser


          if (this.__useQxPlaceholder__P_410_2) {
            this._showPlaceholder();
          }

          return value;
        }

        throw new Error("Invalid value type: " + value);
      },

      /**
       * Returns the current value of the textfield.
       *
       * @return {String|null} The current value
       */
      getValue: function getValue() {
        return this.isDisposed() || this.__nullValue__P_410_3 ? null : this.getContentElement().getValue();
      },

      /**
       * Resets the value to the default
       */
      resetValue: function resetValue() {
        this.setValue(null);
      },

      /**
       * Event listener for change event of content element
       *
       * @param e {qx.event.type.Data} Incoming change event
       */
      _onChangeContent: function _onChangeContent(e) {
        this.__nullValue__P_410_3 = e.getData() === null;

        this.__fireChangeValueEvent__P_410_9(e.getData());
      },

      /*
      ---------------------------------------------------------------------------
        TEXTFIELD SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the current selection.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @return {String|null}
       */
      getTextSelection: function getTextSelection() {
        return this.getContentElement().getTextSelection();
      },

      /**
       * Returns the current selection length.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @return {Integer|null}
       */
      getTextSelectionLength: function getTextSelectionLength() {
        return this.getContentElement().getTextSelectionLength();
      },

      /**
       * Returns the start of the text selection
       *
       * @return {Integer|null} Start of selection or null if not available
       */
      getTextSelectionStart: function getTextSelectionStart() {
        return this.getContentElement().getTextSelectionStart();
      },

      /**
       * Returns the end of the text selection
       *
       * @return {Integer|null} End of selection or null if not available
       */
      getTextSelectionEnd: function getTextSelectionEnd() {
        return this.getContentElement().getTextSelectionEnd();
      },

      /**
       * Set the selection to the given start and end (zero-based).
       * If no end value is given the selection will extend to the
       * end of the textfield's content.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @param start {Integer} start of the selection (zero-based)
       * @param end {Integer} end of the selection
       */
      setTextSelection: function setTextSelection(start, end) {
        this.getContentElement().setTextSelection(start, end);
      },

      /**
       * Clears the current selection.
       * This method only works if the widget is already created and
       * added to the document.
       *
       */
      clearTextSelection: function clearTextSelection() {
        this.getContentElement().clearTextSelection();
      },

      /**
       * Selects the whole content
       *
       */
      selectAllText: function selectAllText() {
        this.setTextSelection(0);
      },

      /*
      ---------------------------------------------------------------------------
        PLACEHOLDER HELPERS
      ---------------------------------------------------------------------------
      */
      // overridden
      setLayoutParent: function setLayoutParent(parent) {
        qx.ui.form.AbstractField.prototype.setLayoutParent.base.call(this, parent);

        if (this.__useQxPlaceholder__P_410_2) {
          if (parent) {
            this.getLayoutParent().getContentElement().add(this._getPlaceholderElement());
          } else {
            var placeholder = this._getPlaceholderElement();

            placeholder.getParent().remove(placeholder);
          }
        }
      },

      /**
       * Helper to show the placeholder text in the field. It checks for all
       * states and possible conditions and shows the placeholder only if allowed.
       */
      _showPlaceholder: function _showPlaceholder() {
        var fieldValue = this.getValue() || "";
        var placeholder = this.getPlaceholder();

        if (placeholder != null && fieldValue == "" && !this.hasState("focused") && !this.hasState("disabled")) {
          if (this.hasState("showingPlaceholder")) {
            this._syncPlaceholder();
          } else {
            // the placeholder will be set as soon as the appearance is applied
            this.addState("showingPlaceholder");
          }
        }
      },

      /**
       * Remove the fake placeholder
       */
      _onPointerDownPlaceholder: function _onPointerDownPlaceholder() {
        window.setTimeout(function () {
          this.focus();
        }.bind(this), 0);
      },

      /**
       * Helper to remove the placeholder. Deletes the placeholder text from the
       * field and removes the state.
       */
      _removePlaceholder: function _removePlaceholder() {
        if (this.hasState("showingPlaceholder")) {
          if (this.__useQxPlaceholder__P_410_2) {
            this._getPlaceholderElement().setStyle("visibility", "hidden");
          }

          this.removeState("showingPlaceholder");
        }
      },

      /**
       * Updates the placeholder text with the DOM
       */
      _syncPlaceholder: function _syncPlaceholder() {
        if (this.hasState("showingPlaceholder") && this.__useQxPlaceholder__P_410_2) {
          this._getPlaceholderElement().setStyle("visibility", "visible");
        }
      },

      /**
       * Returns the placeholder label and creates it if necessary.
       */
      _getPlaceholderElement: function _getPlaceholderElement() {
        if (this._placeholder == null) {
          // create the placeholder
          this._placeholder = new qx.html.Label();
          var colorManager = qx.theme.manager.Color.getInstance();

          this._placeholder.setStyles({
            "zIndex": 11,
            "position": "absolute",
            "color": colorManager.resolve("text-placeholder"),
            "whiteSpace": "normal",
            // enable wrap by default
            "cursor": "text",
            "visibility": "hidden"
          });

          this._placeholder.addListener("pointerdown", this._onPointerDownPlaceholder, this);
        }

        return this._placeholder;
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale: function _onChangeLocale(e) {
        var content = this.getPlaceholder();

        if (content && content.translate) {
          this.setPlaceholder(content.translate());
        }
      },
      // overridden
      _onChangeTheme: function _onChangeTheme() {
        qx.ui.form.AbstractField.prototype._onChangeTheme.base.call(this);

        if (this._placeholder) {
          // delete the placeholder element because it uses a theme dependent color
          this._placeholder.dispose();

          this._placeholder = null;
        }

        if (!this.__useQxPlaceholder__P_410_2 && qx.ui.form.AbstractField.__stylesheet__P_410_0) {
          qx.bom.Stylesheet.removeSheet(qx.ui.form.AbstractField.__stylesheet__P_410_0);
          qx.ui.form.AbstractField.__stylesheet__P_410_0 = null;

          qx.ui.form.AbstractField.__addPlaceholderRules__P_410_1();
        }
      },

      /**
       * Validates the the input value.
       * 
       * @param value {Object} The value to check
       * @returns The checked value
       */
      _validateInput: function _validateInput(value) {
        var filteredValue = value;
        var filter = this.getFilter(); // If no filter is set return just the value

        if (filter !== null) {
          filteredValue = "";
          var index = value.search(filter);
          var processedValue = value;

          while (index >= 0 && processedValue.length > 0) {
            filteredValue = filteredValue + processedValue.charAt(index);
            processedValue = processedValue.substring(index + 1, processedValue.length);
            index = processedValue.search(filter);
          }
        }

        return filteredValue;
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyPlaceholder: function _applyPlaceholder(value, old) {
        if (this.__useQxPlaceholder__P_410_2) {
          this._getPlaceholderElement().setValue(value);

          if (value != null) {
            this.addListener("focusin", this._removePlaceholder, this);
            this.addListener("focusout", this._showPlaceholder, this);

            this._showPlaceholder();
          } else {
            this.removeListener("focusin", this._removePlaceholder, this);
            this.removeListener("focusout", this._showPlaceholder, this);

            this._removePlaceholder();
          }
        } else {
          // only apply if the widget is enabled
          if (this.getEnabled()) {
            this.getContentElement().setAttribute("placeholder", value);

            if (qx.core.Environment.get("browser.name") === "firefox" && parseFloat(qx.core.Environment.get("browser.version")) < 36 && this.getContentElement().getNodeName() === "textarea" && !this.getContentElement().getDomElement()) {
              /* qx Bug #8870: Firefox 35 will not display a text area's
                 placeholder text if the attribute is set before the
                 element is added to the DOM. This is fixed in FF 36. */
              this.addListenerOnce("appear", function () {
                this.getContentElement().getDomElement().removeAttribute("placeholder");
                this.getContentElement().getDomElement().setAttribute("placeholder", value);
              }, this);
            }
          }
        }
      },
      // property apply
      _applyTextAlign: function _applyTextAlign(value, old) {
        this.getContentElement().setStyle("textAlign", value);
      },
      // property apply
      _applyReadOnly: function _applyReadOnly(value, old) {
        var element = this.getContentElement();
        element.setAttribute("readOnly", value);

        if (value) {
          this.addState("readonly");
          this.setFocusable(false);
        } else {
          this.removeState("readonly");
          this.setFocusable(true);
        }
      }
    },
    defer: function defer(statics) {
      var css = "border: none;padding: 0;margin: 0;display : block;background : transparent;outline: none;appearance: none;position: absolute;autoComplete: off;resize: none;border-radius: 0;";
      qx.ui.style.Stylesheet.getInstance().addRule(".qx-abstract-field", css);
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this._placeholder) {
        this._placeholder.removeListener("pointerdown", this._onPointerDownPlaceholder, this);

        var parent = this._placeholder.getParent();

        if (parent) {
          parent.remove(this._placeholder);
        }

        this._placeholder.dispose();
      }

      this._placeholder = this.__font__P_410_6 = null;
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }

      if (this.__font__P_410_6 && this.__webfontListenerId__P_410_7) {
        this.__font__P_410_6.removeListenerById(this.__webfontListenerId__P_410_7);
      }

      this.getContentElement().removeListener("input", this._onHtmlInput, this);
    }
  });
  qx.ui.form.AbstractField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.AbstractField": {
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.bom.client.Device": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "engine.version": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        },
        "device.type": {
          "className": "qx.bom.client.Device"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */

  /**
   * The TextField is a single-line text input field.
   */
  qx.Class.define("qx.ui.form.TextField", {
    extend: qx.ui.form.AbstractField,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "textfield"
      },
      // overridden
      allowGrowY: {
        refine: true,
        init: false
      },
      // overridden
      allowShrinkY: {
        refine: true,
        init: false
      }
    },
    members: {
      // overridden
      _renderContentElement: function _renderContentElement(innerHeight, element) {
        if (qx.core.Environment.get("engine.name") == "mshtml" && (parseInt(qx.core.Environment.get("engine.version"), 10) < 9 || qx.core.Environment.get("browser.documentmode") < 9)) {
          element.setStyles({
            "line-height": innerHeight + 'px'
          });
        }
      },
      // overridden
      _createContentElement: function _createContentElement() {
        var el = qx.ui.form.TextField.prototype._createContentElement.base.call(this);

        var deviceType = qx.core.Environment.get("device.type");

        if (deviceType == "tablet" || deviceType == "mobile") {
          el.addListener("keypress", this._onKeyPress, this);
        }

        return el;
      },

      /**
      * Close the virtual keyboard if the Enter key is pressed.
      * @param evt {qx.event.type.KeySequence} the keypress event.
      */
      _onKeyPress: function _onKeyPress(evt) {
        // On return
        if (evt.getKeyIdentifier() == "Enter") {
          if (this.isFocusable()) {
            this.blur();
          } else {
            // When the text field is not focusable, blur() will raise an exception on
            // touch devices and the virtual keyboard is not closed. To work around this
            // issue, we're enabling the focus just for the blur() call.
            this.setFocusable(true);
            this.blur();
            this.setFocusable(false);
          }
        }
      }
    },
    destruct: function destruct() {
      this.getContentElement().removeListener("keypress", this._onKeyPress, this);
    }
  });
  qx.ui.form.TextField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.core.Property": {},
      "qx.test.core.PropertyHelper": {},
      "qx.test.core.InheritanceDummy": {},
      "qx.core.Object": {
        "construct": true
      },
      "qx.Interface": {},
      "qx.data.Array": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @ignore(qx.Node, qx.test.A, qx.test.B, qx.test.clName, qx.test.IForm)
   * @ignore(qx.TestProperty, qx.Super)
   */
  qx.Class.define("qx.test.core.Property", {
    extend: qx.dev.unit.TestCase,
    members: {
      testBasic: function testBasic() {
        this.assertNotUndefined(qx.core.Property); // Check instance

        var inst = new qx.test.core.PropertyHelper();
        this.assertNotUndefined(inst, "instance"); // Public setter/getter etc.

        this.assertFunction(inst.setPublicProp, "public setter");
        this.assertFunction(inst.getPublicProp, "public getter");
        this.assertFunction(inst.resetPublicProp, "public reset");
        this.assertUndefined(inst.togglePublicProp, "public toggler");
        this.assertUndefined(inst.setThemedPublicProp, "public themed"); // Boolean property

        this.assertFunction(inst.toggleBooleanProp, "boolean toggler");
        inst.dispose();
      },
      testBuiltinTypes: function testBuiltinTypes() {
        this.assertNotUndefined(qx.core.Property); // Check instance

        var inst = new qx.test.core.PropertyHelper();
        this.assertNotUndefined(inst, "instance"); // Type checks: String

        this.assertIdentical("Hello", inst.setStringProp("Hello"), "string property, set");
        this.assertIdentical("Hello", inst.getStringProp(), "string property, get"); // Type checks: Boolean, true

        this.assertIdentical(true, inst.setBooleanProp(true), "boolean property, set");
        this.assertIdentical(true, inst.getBooleanProp(), "boolean property, get"); // Type checks: Boolean, false

        this.assertIdentical(false, inst.setBooleanProp(false), "boolean property, set");
        this.assertIdentical(false, inst.getBooleanProp(), "boolean property, get"); // Type checks: Number, int

        this.assertIdentical(3, inst.setNumberProp(3), "number property, set");
        this.assertIdentical(3, inst.getNumberProp(), "number property, get"); // Type checks: Number, float

        this.assertIdentical(3.14, inst.setNumberProp(3.14), "number property, set");
        this.assertIdentical(3.14, inst.getNumberProp(), "number property, get"); // Type checks: Object, inline

        var obj = {};
        this.assertIdentical(obj, inst.setObjectProp(obj), "object property, set");
        this.assertIdentical(obj, inst.getObjectProp(), "object property, get"); // Type checks: Object, new

        var obj = new Object();
        this.assertIdentical(obj, inst.setObjectProp(obj), "object property, set");
        this.assertIdentical(obj, inst.getObjectProp(), "object property, get"); // Type checks: Array, inline

        var arr = [];
        this.assertIdentical(arr, inst.setArrayProp(arr), "array property, set");
        this.assertIdentical(arr, inst.getArrayProp(), "array property, get"); // Type checks: Array, new

        var arr = new Array();
        this.assertIdentical(arr, inst.setArrayProp(arr), "array property, set");
        this.assertIdentical(arr, inst.getArrayProp(), "array property, get");
        inst.dispose();
      },
      testInheritance: function testInheritance() {
        this.assertNotUndefined(qx.core.Property);
        var pa = new qx.test.core.InheritanceDummy();
        var ch1 = new qx.test.core.InheritanceDummy();
        var ch2 = new qx.test.core.InheritanceDummy();
        var ch3 = new qx.test.core.InheritanceDummy();
        var chh1 = new qx.test.core.InheritanceDummy();
        var chh2 = new qx.test.core.InheritanceDummy();
        var chh3 = new qx.test.core.InheritanceDummy();
        pa.add(ch1);
        pa.add(ch2);
        pa.add(ch3);
        ch2.add(chh1);
        ch2.add(chh2);
        ch2.add(chh3); // Simple: Only inheritance, no local values

        this.assertTrue(pa.setEnabled(true), "a1");
        this.assertTrue(pa.getEnabled(), "a2");
        this.assertTrue(ch1.getEnabled(), "a3");
        this.assertTrue(ch2.getEnabled(), "a4");
        this.assertTrue(ch3.getEnabled(), "a5");
        this.assertTrue(chh1.getEnabled(), "a6");
        this.assertTrue(chh2.getEnabled(), "a7");
        this.assertTrue(chh3.getEnabled(), "a8"); // Enabling local value

        this.assertFalse(ch2.setEnabled(false), "b1");
        this.assertFalse(ch2.getEnabled(), "b2");
        this.assertFalse(chh1.getEnabled(), "b3");
        this.assertFalse(chh2.getEnabled(), "b4");
        this.assertFalse(chh3.getEnabled(), "b5"); // Reset local value

        ch2.resetEnabled();
        this.assertTrue(ch2.getEnabled(), "c2");
        this.assertTrue(chh1.getEnabled(), "c3");
        this.assertTrue(chh2.getEnabled(), "c4");
        this.assertTrue(chh3.getEnabled(), "c5");
        pa.dispose();
        ch1.dispose();
        ch2.dispose();
        ch3.dispose();
        chh1.dispose();
        chh2.dispose();
        chh3.dispose();
      },
      testParent: function testParent() {
        var pa = new qx.test.core.InheritanceDummy();
        var ch1 = new qx.test.core.InheritanceDummy();
        var ch2 = new qx.test.core.InheritanceDummy();
        var ch3 = new qx.test.core.InheritanceDummy();
        this.assertIdentical(pa.getEnabled(), null, "d1");
        this.assertIdentical(ch1.getEnabled(), null, "d2");
        this.assertIdentical(ch2.getEnabled(), null, "d3");
        this.assertIdentical(ch3.getEnabled(), null, "d4");
        pa.add(ch1);
        this.assertTrue(pa.setEnabled(true), "a1"); // ch1 gets enabled, too

        this.assertFalse(ch3.setEnabled(false), "a2");
        this.assertTrue(pa.getEnabled(), "b1");
        this.assertTrue(ch1.getEnabled(), "b2");
        this.assertIdentical(ch2.getEnabled(), null, "b3");
        this.assertFalse(ch3.getEnabled(), "b4");
        pa.add(ch2); // make ch2 enabled_ through inheritance

        pa.add(ch3); // keep ch2 disabled, user value has higher priority

        this.assertTrue(pa.getEnabled(), "c1");
        this.assertTrue(ch1.getEnabled(), "c2");
        this.assertTrue(ch2.getEnabled(), "c3");
        this.assertFalse(ch3.getEnabled(), "c4");
        pa.dispose();
        ch1.dispose();
        ch2.dispose();
        ch3.dispose();
      },
      testMultiValues: function testMultiValues() {
        this.assertNotUndefined(qx.core.Property); // Check instance

        var inst = new qx.test.core.PropertyHelper();
        this.assertNotUndefined(inst, "instance"); // Check init value

        this.assertIdentical(inst.getInitProp(), "foo", "a1");
        this.assertIdentical(inst.setInitProp("hello"), "hello", "a2");
        this.assertIdentical(inst.getInitProp(), "hello", "a3");
        this.assertIdentical(inst.resetInitProp(), undefined, "a4");
        this.assertIdentical(inst.getInitProp(), "foo", "a5"); // Check null value

        this.assertIdentical(inst.getNullProp(), "bar", "b1");
        this.assertIdentical(inst.setNullProp("hello"), "hello", "b2");
        this.assertIdentical(inst.getNullProp(), "hello", "b3");
        this.assertIdentical(inst.setNullProp(null), null, "b4");
        this.assertIdentical(inst.getNullProp(), null, "b5");
        this.assertIdentical(inst.resetNullProp(), undefined, "b6");
        this.assertIdentical(inst.getNullProp(), "bar", "b7"); // Check appearance value

        this.assertIdentical(inst.setThemedAppearanceProp("black"), "black", "c1");
        this.assertIdentical(inst.getAppearanceProp(), "black", "c2");
        this.assertIdentical(inst.setAppearanceProp("white"), "white", "c3");
        this.assertIdentical(inst.getAppearanceProp(), "white", "c4");
        this.assertIdentical(inst.resetAppearanceProp(), undefined, "c5");
        this.assertIdentical(inst.getAppearanceProp(), "black", "c6"); // No prop

        this.assertIdentical(inst.getNoProp(), null, "c1");
        inst.dispose();
      },
      testInitApply: function testInitApply() {
        var inst = new qx.test.core.PropertyHelper();
        this.assertNotUndefined(inst, "instance");
        this.assertUndefined(inst.lastApply);
        inst.setInitApplyProp1("juhu"); //set to init value

        this.assertJsonEquals(["juhu", "juhu"], inst.lastApply);
        inst.lastApply = undefined;
        inst.setInitApplyProp1("juhu"); // set to same value

        this.assertUndefined(inst.lastApply); // apply must not be called

        inst.lastApply = undefined;
        inst.setInitApplyProp1("kinners"); // set to new value

        this.assertJsonEquals(["kinners", "juhu"], inst.lastApply);
        inst.lastApply = undefined;
        this.assertUndefined(inst.lastApply);
        inst.setInitApplyProp2(null); //set to init value

        this.assertJsonEquals([null, null], inst.lastApply);
        inst.lastApply = undefined;
        inst.dispose();
      },
      testInit: function testInit() {
        // now test the init functions
        var self = this;
        var inst = new qx.test.core.PropertyHelper(function (inst) {
          inst.initInitApplyProp1();
          self.assertJsonEquals(["juhu", null], inst.lastApply);
          inst.lastApply = undefined;
          inst.initInitApplyProp2();
          self.assertJsonEquals([null, null], inst.lastApply);
          inst.lastApply = undefined;
        });
        this.assertNotUndefined(inst, "instance");
        inst.dispose();
      },
      testDefinesThanSubClassWithInterface: function testDefinesThanSubClassWithInterface() {
        // see bug #2162 for details
        delete qx.test.A;
        delete qx.test.B;
        delete qx.test.IForm;
        qx.Class.define("qx.test.A", {
          extend: qx.core.Object,
          properties: {
            enabled: {}
          }
        });
        var a = new qx.test.A();
        qx.Interface.define("qx.test.IForm", {
          members: {
            setEnabled: function setEnabled(value) {}
          }
        });
        qx.Class.define("qx.test.B", {
          extend: qx.test.A,
          implement: qx.test.IForm
        });
        var b = new qx.test.B();
        b.setEnabled(true);
        a.dispose();
        b.dispose();
      },
      testPropertyNamedClassname: function testPropertyNamedClassname() {
        qx.Class.define("qx.test.clName", {
          extend: qx.core.Object,
          properties: {
            classname: {}
          }
        });
        delete qx.test.clName;
      },
      testWrongPropertyDefinitions: function testWrongPropertyDefinitions() {
        {
          // class config maps must be separately defined to not produce compiler errors
          // date
          this.assertException(function () {
            var config = {
              extend: qx.core.Object,
              properties: new Date()
            };
            qx.Class.define("qx.test.clName", config);
          }, Error, new RegExp(".*Invalid.*"), "123");
          delete qx.test.clName; // array

          this.assertException(function () {
            var config = {
              extend: qx.core.Object,
              properties: [1, 2, 3]
            };
            qx.Class.define("qx.test.clName", config);
          }, Error, new RegExp(".*Invalid.*"), "123");
          delete qx.test.clName; // qooxdoo class

          var o = new qx.core.Object();
          this.assertException(function () {
            var config = {
              extend: qx.core.Object,
              properties: o
            };
            qx.Class.define("qx.test.clName", config);
          }, Error, new RegExp(".*Invalid.*"), "123");
          delete qx.test.clName;
          o.dispose(); // RegExp

          this.assertException(function () {
            var config = {
              extend: qx.core.Object,
              properties: new RegExp()
            };
            qx.Class.define("qx.test.clName", config);
          }, Error, new RegExp(".*Invalid.*"), "123");
          delete qx.test.clName; // null

          this.assertException(function () {
            var config = {
              extend: qx.core.Object,
              properties: null
            };
            qx.Class.define("qx.test.clName", config);
          }, Error, new RegExp(".*Invalid.*"), "123");
          delete qx.test.clName; // boolean

          this.assertException(function () {
            var config = {
              extend: qx.core.Object,
              properties: true
            };
            qx.Class.define("qx.test.clName", config);
          }, Error, new RegExp(".*Invalid.*"), "123");
          delete qx.test.clName; // number

          this.assertException(function () {
            var config = {
              extend: qx.core.Object,
              properties: 123
            };
            qx.Class.define("qx.test.clName", config);
          }, Error, new RegExp(".*Invalid.*"), "123");
          delete qx.test.clName;
        }
      },
      testRecursive: function testRecursive() {
        qx.Class.define("qx.Node", {
          extend: qx.core.Object,
          construct: function construct() {
            this._min = 0;
          },
          properties: {
            value: {
              apply: "applyValue"
            }
          },
          members: {
            applyValue: function applyValue(value, old) {
              if (value < this._min) {
                this.setValue(this._min);
              }
            }
          }
        });
        var root = new qx.Node();
        root.setValue(100);
        this.assertEquals(100, root.getValue());
        root.setValue(-100);
        this.assertEquals(0, root.getValue());
        root.dispose();
      },
      testEventWithInitOldData: function testEventWithInitOldData() {
        qx.Class.define("qx.TestProperty", {
          extend: qx.core.Object,
          properties: {
            prop: {
              check: "Boolean",
              init: false,
              event: "changeProp"
            }
          }
        });
        var object = new qx.TestProperty(); // test for the default (false)

        this.assertFalse(object.getProp()); // check for the event

        var self = this;
        this.assertEventFired(object, "changeProp", function () {
          object.setProp(true);
        }, function (e) {
          self.assertTrue(e.getData(), "Wrong data in the event!");
          self.assertFalse(e.getOldData(), "Wrong old data in the event!");
        }, "Change event not fired!");
        object.dispose();
      },
      testEventWithoutInitOldData: function testEventWithoutInitOldData() {
        qx.Class.define("qx.TestProperty", {
          extend: qx.core.Object,
          properties: {
            prop: {
              check: "Boolean",
              nullable: true,
              event: "changeProp"
            }
          }
        });
        var object = new qx.TestProperty(); // test for the default (false)

        this.assertNull(object.getProp()); // check for the event

        var self = this;
        this.assertEventFired(object, "changeProp", function () {
          object.setProp(true);
        }, function (e) {
          self.assertTrue(e.getData(), "Wrong data in the event!");
          self.assertNull(e.getOldData(), "Wrong old data in the event!");
        }, "Change event not fired!");
        object.dispose();
      },
      testEventWithInitAndInheritableOldData: function testEventWithInitAndInheritableOldData() {
        qx.Class.define("qx.TestProperty", {
          extend: qx.core.Object,
          properties: {
            prop: {
              check: "Boolean",
              init: false,
              inheritable: true,
              event: "changeProp"
            }
          }
        });
        var object = new qx.TestProperty(); // test for the default (false)

        this.assertFalse(object.getProp()); // check for the event

        var self = this;
        this.assertEventFired(object, "changeProp", function () {
          object.setProp(true);
        }, function (e) {
          self.assertTrue(e.getData(), "Wrong data in the event!");
          self.assertFalse(e.getOldData(), "Wrong old data in the event!");
        }, "Change event not fired!");
        object.dispose();
      },
      testEventWithoutInitAndInheritableOldData: function testEventWithoutInitAndInheritableOldData() {
        qx.Class.define("qx.TestProperty", {
          extend: qx.core.Object,
          properties: {
            prop: {
              check: "Boolean",
              nullable: true,
              inheritable: true,
              event: "changeProp"
            }
          }
        });
        var object = new qx.TestProperty(); // test for the default (false)

        this.assertNull(object.getProp()); // check for the event

        var self = this;
        this.assertEventFired(object, "changeProp", function () {
          object.setProp(true);
        }, function (e) {
          self.assertTrue(e.getData(), "Wrong data in the event!");
          self.assertNull(e.getOldData(), "Wrong old data in the event!");
        }, "Change event not fired!");
        object.dispose();
      },

      /*
      ---------------------------------------------------------------------------
         IS-EQUAL OVERRIDE TEST
      ---------------------------------------------------------------------------
      */

      /**
       * Check whether the (numeric) value is negative zero (-0)
       *
       * @param value {number} Value to check
       * @return {Boolean} whether the value is <code>-0</code>
       */
      __isNegativeZero__P_227_0: function __isNegativeZero__P_227_0(value) {
        return value === 0 && 1 / value < 0; // 1/-0 => -Infinity
      },

      /**
       * Check whether the (numeric) value is positive zero (+0)
       *
       * @param value {number} Value to check
       * @return {Boolean} whether the value is <code>+0</code>
       */
      __isPositiveZero__P_227_1: function __isPositiveZero__P_227_1(value) {
        return value === 0 && 1 / value > 0; // 1/+0 => +Infinity
      },
      testWrongIsEqualDefinitions: function testWrongIsEqualDefinitions() {
        {
          var re = new RegExp("Invalid type for 'isEqual'.*");
          var o = new qx.core.Object();
          [new Date(), // date
          [1, 2, 3], // array
          {}, // object
          o, // qooxdoo class
          new RegExp(), // RegExp
          null, // null
          true, false, // boolean
          123 // number
          ].forEach(function (isEqualTestValue, i) {
            var msg = "case[" + i + "] (" + String(isEqualTestValue) + ")";
            this.assertException(function () {
              qx.Class.define("qx.TestProperty", {
                extend: qx.core.Object,
                properties: {
                  prop: {
                    check: "Number",
                    isEqual: isEqualTestValue
                  }
                }
              });
              new qx.TestProperty().set({
                prop: 0
              });
            }, Error, re, msg);
            delete qx.TestProperty;
          }, this);
          o.dispose();
        } // end-if (qx.core.Environment.get("qx.debug"))
      },
      testIsEqualInline: function testIsEqualInline() {
        qx.Class.define("qx.TestProperty", {
          extend: qx.core.Object,
          properties: {
            prop: {
              check: "Number",
              nullable: true,
              event: "changeProp",
              isEqual: "Object.is(a, b)"
            }
          }
        });
        var object = new qx.TestProperty();
        object.setProp(0); // initialize with +0
        //
        // check for the event
        //

        var self = this; // No change expected

        this.assertEventNotFired(object, "changeProp", function () {
          object.setProp(0);
          object.setProp(+0);
        }, function (e) {}, "'changeProp' event fired!"); // Change expected

        this.assertEventFired(object, "changeProp", function () {
          object.setProp(-0);
        }, function (e) {
          var isNegativeZero = self.__isNegativeZero__P_227_0(e.getData());

          var isPositiveZero = self.__isPositiveZero__P_227_1(e.getOldData());

          self.assertTrue(isNegativeZero, "Wrong data in the event!");
          self.assertTrue(isPositiveZero, "Wrong old data in the event!");
        }, "Change event not fired!"); // @todo: check 'apply' and 'transform', too

        object.dispose();
      },
      testIsEqualFunction: function testIsEqualFunction() {
        qx.Class.define("qx.TestProperty", {
          extend: qx.core.Object,
          properties: {
            prop: {
              check: "Number",
              nullable: true,
              event: "changeProp",
              isEqual: function isEqual(x, y) {
                return Object.is(x, y);
              }
            }
          }
        });
        var object = new qx.TestProperty();
        object.setProp(0); // initialize with +0
        //
        // check for the event
        //

        var self = this; // No change expected

        this.assertEventNotFired(object, "changeProp", function () {
          object.setProp(0);
          object.setProp(+0);
        }, function (e) {}, "'changeProp' event fired!"); // Change expected

        this.assertEventFired(object, "changeProp", function () {
          object.setProp(-0);
        }, function (e) {
          var isNegativeZero = self.__isNegativeZero__P_227_0(e.getData());

          var isPositiveZero = self.__isPositiveZero__P_227_1(e.getOldData());

          self.assertTrue(isNegativeZero, "Wrong data in the event!");
          self.assertTrue(isPositiveZero, "Wrong old data in the event!");
        }, "Change event not fired!"); // @todo: check 'apply' and 'transform', too

        object.dispose();
      },
      testIsEqualMember: function testIsEqualMember() {
        qx.Class.define("qx.TestProperty", {
          extend: qx.core.Object,
          properties: {
            prop: {
              check: "Number",
              nullable: true,
              event: "changeProp",
              isEqual: "__fooBar__P_227_2"
            }
          },
          members: {
            __fooBar__P_227_2: function __fooBar__P_227_2(foo, bar) {
              return Object.is(foo, bar);
            }
          }
        });
        var object = new qx.TestProperty();
        object.setProp(0); // initialize with +0
        //
        // check for the event
        //

        var self = this; // No change expected

        this.assertEventNotFired(object, "changeProp", function () {
          object.setProp(0);
          object.setProp(+0);
        }, function (e) {}, "'changeProp' event fired!"); // Change expected

        this.assertEventFired(object, "changeProp", function () {
          object.setProp(-0);
        }, function (e) {
          var isNegativeZero = self.__isNegativeZero__P_227_0(e.getData());

          var isPositiveZero = self.__isPositiveZero__P_227_1(e.getOldData());

          self.assertTrue(isNegativeZero, "Wrong data in the event!");
          self.assertTrue(isPositiveZero, "Wrong old data in the event!");
        }, "Change event not fired!"); // @todo: check 'apply' and 'transform', too

        object.dispose();
      },
      testIsEqualInlineContext: function testIsEqualInlineContext() {
        var context, object;
        qx.Class.define("qx.TestProperty", {
          extend: qx.core.Object,
          properties: {
            prop: {
              check: "Number",
              nullable: true,
              event: "changeProp",
              isEqual: "(this.__checkCtx(a,b))"
            }
          },
          members: {
            __checkCtx__P_227_3: function __checkCtx__P_227_3(foo, bar) {
              context = this;
            }
          }
        });
        object = new qx.TestProperty().set({
          prop: 4711
        });
        this.assertIdentical(object, context);
        object.dispose();
      },
      testIsEqualFunctionContext: function testIsEqualFunctionContext() {
        var context, object;
        qx.Class.define("qx.TestProperty", {
          extend: qx.core.Object,
          properties: {
            prop: {
              check: "Number",
              nullable: true,
              event: "changeProp",
              isEqual: function isEqual(x, y) {
                context = this;
              }
            }
          }
        });
        object = new qx.TestProperty().set({
          prop: 4711
        });
        this.assertIdentical(object, context);
        object.dispose();
      },
      testIsEqualMemberContext: function testIsEqualMemberContext() {
        var context, object;
        qx.Class.define("qx.TestProperty", {
          extend: qx.core.Object,
          properties: {
            prop: {
              check: "Number",
              nullable: true,
              event: "changeProp",
              isEqual: "__checkCtx__P_227_3"
            }
          },
          members: {
            __checkCtx__P_227_3: function __checkCtx__P_227_3(foo, bar) {
              context = this;
            }
          }
        });
        object = new qx.TestProperty().set({
          prop: 4711
        });
        this.assertIdentical(object, context);
        object.dispose();
      },
      testIsEqualBaseClassMember: function testIsEqualBaseClassMember() {
        var context, object;
        qx.Class.define("qx.Super", {
          extend: qx.core.Object,
          members: {
            __checkCtx__P_227_3: function __checkCtx__P_227_3(foo, bar) {
              context = this;
            }
          }
        });
        qx.Class.define("qx.TestProperty", {
          extend: qx.Super,
          properties: {
            prop: {
              check: "Number",
              nullable: true,
              event: "changeProp",
              isEqual: "__checkCtx__P_227_3"
            }
          }
        });
        object = new qx.TestProperty().set({
          prop: 4711
        });
        this.assertIdentical(object, context);
        object.dispose();
      },
      testTransform: function testTransform() {
        qx.Class.define("qx.TestProperty", {
          extend: qx.core.Object,
          construct: function construct() {
            qx.core.Object.constructor.call(this);
            this.initPropTwo(new qx.data.Array());
          },
          properties: {
            prop: {
              check: "qx.data.Array",
              nullable: true,
              event: "changeProp",
              transform: "__transform__P_227_4"
            },
            propTwo: {
              check: "qx.data.Array",
              nullable: true,
              event: "changePropTwo",
              transform: "__transform__P_227_4",
              deferredInit: true
            }
          },
          members: {
            __transform__P_227_4: function __transform__P_227_4(value, oldValue) {
              if (oldValue === undefined) return value;
              if (!value) oldValue.removeAll();else oldValue.replace(value);
              return oldValue;
            }
          }
        });
        var object = new qx.TestProperty();
        var arr = new qx.data.Array();
        object.setProp(arr);
        this.assertIdentical(arr, object.getProp());
        arr.push("1");
        var arr2 = new qx.data.Array();
        arr2.push("2");
        arr2.push("3");
        object.setProp(arr2);
        this.assertIdentical(arr, object.getProp());
        this.assertArrayEquals(["2", "3"], arr.toArray());
        var savePropTwo = object.getPropTwo();
        object.setPropTwo(arr2);
        this.assertIdentical(savePropTwo, object.getPropTwo());
        this.assertArrayEquals(["2", "3"], savePropTwo.toArray());
      }
    }
  });
  qx.test.core.Property.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.core.PropertyHelper", {
    extend: qx.core.Object,
    construct: function construct(delegate) {
      qx.core.Object.constructor.call(this);

      if (delegate) {
        delegate(this);
      }
    },
    properties: {
      // protection
      publicProp: {
        nullable: true
      },
      // types
      stringProp: {
        check: "String",
        nullable: true
      },
      booleanProp: {
        check: "Boolean",
        nullable: true
      },
      numberProp: {
        check: "Number",
        nullable: true
      },
      objectProp: {
        check: "Object",
        nullable: true
      },
      arrayProp: {
        check: "Array",
        nullable: true
      },
      mapProp: {
        check: "Map",
        nullable: true
      },
      // multi values
      noProp: {
        check: "String",
        nullable: true
      },
      initProp: {
        init: "foo"
      },
      initApplyProp1: {
        check: "String",
        init: "juhu",
        apply: "_applyInitApplyProp"
      },
      initApplyProp2: {
        check: "String",
        init: null,
        nullable: true,
        apply: "_applyInitApplyProp"
      },
      nullProp: {
        init: "bar",
        nullable: true
      },
      appearanceProp: {
        themeable: true,
        nullable: true
      },
      fullProp: {
        init: 100,
        themeable: true
      }
    },
    members: {
      _applyInitApplyProp: function _applyInitApplyProp(value, old) {
        this.lastApply = [value, old];
      }
    }
  });
  qx.test.core.PropertyHelper.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.core.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @ignore(qx.Event)
   */
  qx.Class.define("qx.test.core.Target", {
    extend: qx.dev.unit.TestCase,
    members: {
      testEvents: function testEvents() {
        qx.Class.define("qx.Event", {
          extend: qx.core.Object,
          events: {
            "click": "qx.event.type.Event"
          }
        });
        var target = new qx.Event();
        target.addListener("click", function () {});
        target.dispose();
      }
    }
  });
  qx.test.core.Target.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "construct": true,
        "require": true
      },
      "qx.core.Object": {},
      "qx.util.Validate": {},
      "qx.core.ValidationError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @ignore(qx.Model)
   */
  qx.Class.define("qx.test.core.Validation", {
    extend: qx.dev.unit.TestCase,
    construct: function construct() {
      qx.dev.unit.TestCase.constructor.call(this);
      qx.Class.define("qx.Model", {
        extend: qx.core.Object,
        properties: {
          custom: {
            init: "Some String",
            check: "String",
            validate: "__validateCustom__P_228_0"
          },
          number: {
            init: 18,
            validate: qx.util.Validate.number()
          },
          range: {
            init: 1.80,
            validate: qx.util.Validate.range(1, 2)
          },
          array: {
            init: "male",
            validate: qx.util.Validate.inArray(["male", "female"])
          },
          email: {
            init: "martin.wittemann@1und1.de",
            validate: qx.util.Validate.email()
          },
          string: {
            init: "Some String!",
            validate: qx.util.Validate.string()
          },
          url: {
            init: "http://www.1und1.de",
            validate: qx.util.Validate.url()
          },
          color: {
            init: "black",
            validate: qx.util.Validate.color()
          },
          regExp: {
            init: "test",
            validate: qx.util.Validate.regExp(/^abc/)
          }
        },
        members: {
          __validateCustom__P_228_0: function __validateCustom__P_228_0(value) {
            // if the length is lower than 4
            if (value.length < 4) {
              throw new qx.core.ValidationError("Validation Error: String must be longer than three characters. (" + value + ")");
            }
          }
        }
      });
      this.__model__P_228_1 = new qx.Model();
    },
    members: {
      testNumber: function testNumber() {
        var model = this.__model__P_228_1; // test for some false inputs

        this.assertException(function () {
          model.setNumber("test");
        }, qx.core.ValidationError, null, "A String is no number.");
        this.assertException(function () {
          model.setNumber(new Date());
        }, qx.core.ValidationError, null, "A Date is no number.");
        this.assertException(function () {
          model.setNumber(this);
        }, qx.core.ValidationError, null, "this is no number."); // test an positive integer

        model.setNumber(12);
        this.assertEquals(12, model.getNumber()); // test an negative integer

        model.setNumber(-20);
        this.assertEquals(-20, model.getNumber()); // test an float

        model.setNumber(12.15);
        this.assertEquals(12.15, model.getNumber());
      },
      testEmail: function testEmail() {
        var model = this.__model__P_228_1; // test some wrong addresses

        this.assertException(function () {
          model.setEmail("test");
        }, qx.core.ValidationError, null, "test is a mailadress?");
        this.assertException(function () {
          model.setEmail("@affe.de");
        }, qx.core.ValidationError, null, "@affe.de is never a mailadress!");
        this.assertException(function () {
          model.setEmail("hans@@wurst.de");
        }, qx.core.ValidationError, null, "Are two @ allowed?");
        this.assertException(function () {
          model.setEmail("m@a.d");
        }, qx.core.ValidationError, null, "m@a.d?"); // test some working addresses

        model.setEmail("affe@zoo.de");
        this.assertEquals("affe@zoo.de", model.getEmail(), "affe@zoo.de should work!");
        model.setEmail("mensch@db.info");
        this.assertEquals("mensch@db.info", model.getEmail(), "mensch@db.info should work!");
        model.setEmail("ichbineinelangemailadresse@undhabeinelangedomainnochdazu.de");
        this.assertEquals("ichbineinelangemailadresse@undhabeinelangedomainnochdazu.de", model.getEmail(), "ichbineinelangemailadresse@undhabeinelangedomainnochdazu.de should work!");
      },
      testString: function testString() {
        var model = this.__model__P_228_1; // test some wrong inputs

        this.assertException(function () {
          model.setString(1);
        }, qx.core.ValidationError, null, "A number is not a string!");
        this.assertException(function () {
          model.setString(this);
        }, qx.core.ValidationError, null, "This test is not a string!");
        this.assertException(function () {
          model.setString(true);
        }, qx.core.ValidationError, null, "A boolean is not a string!");
        this.assertException(function () {
          model.setString(new Date());
        }, qx.core.ValidationError, null, "A Date-Object is not a string!"); // Test some working inputs

        model.setString("affe@zoo.de");
        this.assertEquals("affe@zoo.de", model.getString(), "affe@zoo.de as string should work!");
        model.setString("");
        this.assertEquals("", model.getString(), "An empty string should work!");
      },
      testUrl: function testUrl() {
        var model = this.__model__P_228_1; // test some wrong inputs

        this.assertException(function () {
          model.setUrl(1);
        }, qx.core.ValidationError, null, "A number is not an url!");
        this.assertException(function () {
          model.setUrl(false);
        }, qx.core.ValidationError, null, "A boolean is not an url!");
        this.assertException(function () {
          model.setUrl("i am an url");
        }, qx.core.ValidationError, null, "'i am an url' as a string is not an url!");
        this.assertException(function () {
          model.setUrl("http:/iamaurl");
        }, qx.core.ValidationError, null, "'http://iamaurl' is not an url!"); // Test some working inputs

        model.setUrl("http://www.1und1.de");
        this.assertEquals("http://www.1und1.de", model.getUrl(), "http://www.1und1.de as string should work!");
        model.setUrl("http://web.de");
        this.assertEquals("http://web.de", model.getUrl(), "http://web.de as string should work!");
        model.setUrl("http://www.apple.com/de/");
        this.assertEquals("http://www.apple.com/de/", model.getUrl(), "http://www.apple.com/de/ as string should work!");
        model.setUrl("http://www.fake.url:8080/de/1546");
        this.assertEquals("http://www.fake.url:8080/de/1546", model.getUrl(), "http://www.fake.url:8080/de/1546 as string should work!");
      },
      testColor: function testColor() {
        var model = this.__model__P_228_1; // test some wrong inputs

        this.assertException(function () {
          model.setColor(1);
        }, qx.core.ValidationError, null, "A number is not a color!");
        this.assertException(function () {
          model.setColor("");
        }, qx.core.ValidationError, null, "A empty string is not a color!");
        this.assertException(function () {
          model.setColor("FFFFFF");
        }, qx.core.ValidationError, null, "FFFFFF (missing #) is not a color!");
        this.assertException(function () {
          model.setColor("bluecolor");
        }, qx.core.ValidationError, null, "'bluecolor' is not a color!");
        this.assertException(function () {
          model.setColor("#FFFFGG");
        }, qx.core.ValidationError, null, "#FFFFGG is not a color!"); // Test some working inputs

        model.setColor("black");
        this.assertEquals("black", model.getColor(), "black is a css color");
        model.setColor("#000000");
        this.assertEquals("#000000", model.getColor(), "#000000 is a RGB color");
        model.setColor("#FFFFFF");
        this.assertEquals("#FFFFFF", model.getColor(), "#FFFFFF is a css color");
      },
      testRange: function testRange() {
        var model = this.__model__P_228_1; // test some wrong inputs (Rage defined from 1 to 2 including both)

        this.assertException(function () {
          model.setRange(0.999999999);
        }, qx.core.ValidationError, null, "A 0.999999999 is not between 1 and 2.");
        this.assertException(function () {
          model.setRange(2.000000001);
        }, qx.core.ValidationError, null, "A 2.000000001 is not between 1 and 2."); // Test some working inputs

        model.setRange(1);
        this.assertEquals(1, model.getRange(), "1 is in the range of 1 and 2.");
        model.setRange(2);
        this.assertEquals(2, model.getRange(), "2 is in the range of 1 and 2.");
        model.setRange(1.5);
        this.assertEquals(1.5, model.getRange(), "1.5 is in the range of 1 and 2.");
      },
      testInArray: function testInArray() {
        var model = this.__model__P_228_1; // test some wrong inputs (allowed are male and female)

        this.assertException(function () {
          model.setArray(0.999999999);
        }, qx.core.ValidationError, null, "A 0.999999999 is not in ['male', 'female']");
        this.assertException(function () {
          model.setArray("malle");
        }, qx.core.ValidationError, null, "'malle' is not in ['male', 'female']");
        this.assertException(function () {
          model.setArray("");
        }, qx.core.ValidationError, null, "A empty string is not in ['male', 'female']"); // Test some working inputs

        model.setArray("male");
        this.assertEquals("male", model.getArray(), "male is in!");
        model.setArray("female");
        this.assertEquals("female", model.getArray(), "female is in!");
      },
      testCustom: function testCustom() {
        var model = this.__model__P_228_1; // test some wrong inputs (String must be longer than 3)

        this.assertException(function () {
          model.setCustom("");
        }, qx.core.ValidationError, null, "'' is too short");
        this.assertException(function () {
          model.setCustom("1");
        }, qx.core.ValidationError, null, "'1' is too short");
        this.assertException(function () {
          model.setCustom("12");
        }, qx.core.ValidationError, null, "'12' is too short");
        this.assertException(function () {
          model.setCustom("123");
        }, qx.core.ValidationError, null, "'123' is too short"); // Test some working inputs

        model.setCustom("male");
        this.assertEquals("male", model.getCustom(), "male is long enough!");
      },
      testRegExp: function testRegExp() {
        var model = this.__model__P_228_1; // test some wrong inputs (Only digits)

        this.assertException(function () {
          model.setRegExp("AFFE!");
        }, qx.core.ValidationError, null, "'AFFE!' does not fit /[0-9]*/.");
        this.assertException(function () {
          model.setRegExp("_dfds_");
        }, qx.core.ValidationError, null, "_dfds_ does not fit /[0-9]*/.");
        this.assertException(function () {
          model.setRegExp("$%&!&/%");
        }, qx.core.ValidationError, null, "$%&!&/% does not fit /[0-9]*/."); // Test some working inputs

        model.setRegExp("abc");
        this.assertEquals("abc", model.getRegExp(), "abc fits!");
        model.setRegExp("abcdefg");
        this.assertEquals("abcdefg", model.getRegExp(), "abcdefg fits!");
      }
    }
  });
  qx.test.core.Validation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.locale.Manager": {},
      "qx.core.ValidationError": {},
      "qx.util.ColorUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */

  /**
   * This static class contains a set of default validators.
   * These validators are listed twice
   * <ul>
   *   <li>number</li>
   *   <li>email</li>
   *   <li>string</li>
   *   <li>url</li>
   *   <li>color</li>
   * </ul>
   * All these validators don't need an input so the listed function just return a
   * method fitting for the use in the property system.
   * The methods with the check prefix are the returned methods and can be used in
   * other contexts without the property system.
   *
   * There are three more validators
   * <ul>
   *   <li>range</li>
   *   <li>inArray</li>
   *   <li>regExp</li>
   * </ul>
   * These methods do need some addition parameters to specify the validator. So
   * there is no check function which you can use in other contexts because the
   * check function for the validation is created based on the given parameter.
   *
   * *Example usage for a property*
   *
   * <code>validate: qx.util.Validate.number()</code>
   * <br>
   * <code>validate: qx.util.Validate.range(0, 100)</code>
   *
   * Because the methods without the check prefix return a validation method,
   * the function must be called at the property definition. So don't forget the
   * ending brackets for those methods without parameters!
   * For the correct usage, take an additional look at the documentation of the
   * {@link qx.core.Property} class.
   */
  qx.Class.define("qx.util.Validate", {
    statics: {
      /**
       * Returns the function that checks for a number.
       *
       * @param errorMessage {String?null} Custom error message.
       * @return {Function} The {@link #checkNumber} Function.
       */
      number: function number(errorMessage) {
        return function (value) {
          qx.util.Validate.checkNumber(value, null, errorMessage);
        };
      },

      /**
       * The function checks the incoming value to see if it is a number.
       * If not, an ValidationError will be thrown.
       * If you want to use the number check in a property definition,
       * use the {@link #number} method.
       *
       * @param value {var} The value to check.
       * @param formItem {qx.ui.form.IForm} The form item to check if used in a
       *   {@link qx.ui.form.Form}.
       * @param errorMessage {String?undefined} Custom error message.
       * @throws {qx.core.ValidationError} If the value parameter is not a
       *    finite number
       */
      checkNumber: function checkNumber(value, formItem, errorMessage) {
        errorMessage = errorMessage || qx.locale.Manager.tr("%1 is not a number.", value);

        if (typeof value !== "number" && !(value instanceof Number) || !isFinite(value)) {
          throw new qx.core.ValidationError("Validation Error", errorMessage);
        }
      },

      /**
       * Returns the function that checks for an email address.
       *
       * @param errorMessage {String?null} Custom error message.
       * @return {Function} The {@link #checkEmail} Function.
       */
      email: function email(errorMessage) {
        return function (value) {
          qx.util.Validate.checkEmail(value, null, errorMessage);
        };
      },

      /**
       * The function checks the incoming value to see if it is an email address.
       * If not, an ValidationError will be thrown.
       * If you want to use the email check in a property definition,
       * use the {@link #email} method.
       *
       * @param value {var} The value to check.
       * @param formItem {qx.ui.form.IForm} The form item to check if used in a
       *   {@link qx.ui.form.Form}.
       * @param errorMessage {String?null} Custom error message.
       * @throws {qx.core.ValidationError} If the value parameter is not
       *    a valid email address.
       */
      checkEmail: function checkEmail(value, formItem, errorMessage) {
        errorMessage = errorMessage || qx.locale.Manager.tr("'%1' is not an email address.", value || "");
        var reg = /^([A-Za-z0-9_\-.+])+@([A-Za-z0-9_\-.])+\.([A-Za-z]{2,})$/;

        if (reg.test(value) === false) {
          throw new qx.core.ValidationError("Validation Error", errorMessage);
        }
      },

      /**
       * Returns the function that checks for a string.
       *
       * @param errorMessage {String?null} Custom error message.
       * @return {Function} The {@link #checkString} Function.
       */
      string: function string(errorMessage) {
        return function (value) {
          qx.util.Validate.checkString(value, null, errorMessage);
        };
      },

      /**
       * The function checks the incoming value to see if it is a string.
       * If not, an ValidationError will be thrown.
       * If you want to use the string check in a property definition,
       * use the {@link #string} method.
       *
       * @param value {var} The value to check.
       * @param formItem {qx.ui.form.IForm} The form item to check if used in a
       *   {@link qx.ui.form.Form}.
       * @param errorMessage {String?null} Custom error message.
       * @throws {qx.core.ValidationError} If the value parameter is not a string.
       */
      checkString: function checkString(value, formItem, errorMessage) {
        errorMessage = errorMessage || qx.locale.Manager.tr("%1 is not a string.", value);

        if (typeof value !== "string" && !(value instanceof String)) {
          throw new qx.core.ValidationError("Validation Error", errorMessage);
        }
      },

      /**
       * Returns the function that checks for an url.
       *
       * @param errorMessage {String?null} Custom error message.
       * @return {Function} The {@link #checkUrl} Function.
       */
      url: function url(errorMessage) {
        return function (value) {
          qx.util.Validate.checkUrl(value, null, errorMessage);
        };
      },

      /**
       * The function checks the incoming value to see if it is an url.
       * If not, an ValidationError will be thrown.
       * If you want to use the url check in a property definition,
       * use the {@link #url} method.
       *
       * @param value {var} The value to check.
       * @param formItem {qx.ui.form.IForm} The form item to check if used in a
       *   {@link qx.ui.form.Form}.
       * @param errorMessage {String?null} Custom error message.
       * @throws {qx.core.ValidationError} If the value parameter is not an url.
       */
      checkUrl: function checkUrl(value, formItem, errorMessage) {
        errorMessage = errorMessage || qx.locale.Manager.tr("%1 is not an url.", value);
        var reg = /([A-Za-z0-9])+:\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;

        if (!reg.test(value)) {
          throw new qx.core.ValidationError("Validation Error", errorMessage);
        }
      },

      /**
       * Returns the function that checks for a color.
       *
       * @param errorMessage {String?null} Custom error message.
       * @return {Function} The {@link #checkColor} Function.
       */
      color: function color(errorMessage) {
        return function (value) {
          qx.util.Validate.checkColor(value, null, errorMessage);
        };
      },

      /**
       * The function checks the incoming value to see if it is a color.
       * If not, an ValidationError will be thrown. The check itself will be
       * delegated to the {@link qx.util.ColorUtil#stringToRgb} method.
       * If you want to use the color check in a property definition,
       * use the {@link #color} method.
       *
       * @param value {var} The value to check.
       * @param formItem {qx.ui.form.IForm} The form item to check if used in a
       *   {@link qx.ui.form.Form}.
       * @param errorMessage {String?null} Custom error message.
       * @throws {qx.core.ValidationError} If the value parameter is not a color.
       */
      checkColor: function checkColor(value, formItem, errorMessage) {
        try {
          qx.util.ColorUtil.stringToRgb(value);
        } catch (e) {
          var message = errorMessage || qx.locale.Manager.tr("%1 is not a color! %2", value, e);
          throw new qx.core.ValidationError("Validation Error", message);
        }
      },

      /**
       * Returns a function that checks if the number is in the given range.
       * The range includes the border values.
       * A range from 1 to 2 accepts the values 1 equally as everything up to 2
       * including the 2.
       * If the value given to the returned function is out of the range, a
       * ValidationError will be thrown.
       *
       * @param from {Number} The lower border of the range.
       * @param to {Number} The upper border of the range.
       * @param errorMessage {String?null} Custom error message.
       * @return {Function} A function taking one parameter (value).
       */
      range: function range(from, to, errorMessage) {
        return function (value) {
          var message = errorMessage || qx.locale.Manager.tr("%1 is not in the range from [%2, %3].", value, from, to);

          if (value < from || value > to) {
            throw new qx.core.ValidationError("Validation Error", message);
          }
        };
      },

      /**
       * Returns a function that checks if the given value is in the array.
       * If the value given to the returned function is not in the array, a
       * ValidationError will be thrown.
       *
       * @param array {Array} The array holding the possibilities.
       * @param errorMessage {String?null} Custom error message.
       * @return {Function} A function taking one parameter (value).
       */
      inArray: function inArray(array, errorMessage) {
        return function (value) {
          var message = errorMessage || qx.locale.Manager.tr("%1 is not in %2", value, array);

          if (array.indexOf(value) === -1) {
            throw new qx.core.ValidationError("Validation Error", message);
          }
        };
      },

      /**
       * Returns a function that checks if the given value fits the RegExp.
       * For testing, the function uses the RegExp.test function.
       * If the value given to the returned function does not fit the RegExp, a
       * ValidationError will be thrown.
       * incoming
       * @param reg {RegExp} The RegExp for the check.
       * @param errorMessage {String?null} Custom error message.
       * @return {Function} A function taking one parameter (value).
       */
      regExp: function regExp(reg, errorMessage) {
        return function (value) {
          var message = errorMessage || qx.locale.Manager.tr("%1 does not fit %2.", value, reg);

          if (!reg.test(value)) {
            throw new qx.core.ValidationError("Validation Error", message);
          }
        };
      }
    }
  });
  qx.util.Validate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.data.Array": {},
      "qx.data.marshal.Json": {},
      "qx.core.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.data.DataArray", {
    extend: qx.dev.unit.TestCase,
    members: {
      __a__P_229_0: null,
      setUp: function setUp() {
        this.__a__P_229_0 = new qx.data.Array("one", "two", "three");
      },
      tearDown: function tearDown() {
        this.__a__P_229_0.dispose();
      },
      testConstructor: function testConstructor() {
        // create empty array
        var a = new qx.data.Array();
        this.assertEquals(0, a.length, "Length does not fit an an empty array!");
        a.dispose(); // create an array with a length

        a = new qx.data.Array(10);
        this.assertEquals(10, a.length, "Length does not fit an an empty array!");
        a.dispose(); // create an array with only elements

        a = new qx.data.Array("one", "two", "three");
        this.assertEquals(3, a.length, "Length does not fit an an empty array!");
        a.dispose();
        a = new qx.data.Array(1, 2, 3);
        this.assertEquals(3, a.length, "Length does not fit an an empty array!");
        a.dispose(); // create an array with an given native array

        var newArray = ["one", "two", "three"];
        a = new qx.data.Array(newArray);
        this.assertEquals(3, a.length, "Length does not fit an an empty array!");
        a.dispose(); // test some wrong inputs

        this.assertException(function () {
          new qx.data.Array(true);
        }, Error, null, "Boolean not supported!");
        this.assertException(function () {
          new qx.data.Array({});
        }, Error, null, "Objects not supported!");
        this.assertException(function () {
          new qx.data.Array(function () {});
        }, Error, null, "Functions not supported!");
      },
      testGetItem: function testGetItem() {
        // check the getvalue function
        this.assertEquals("one", this.__a__P_229_0.getItem(0), "IndexAt does not work at position 0");
        this.assertEquals("two", this.__a__P_229_0.getItem(1), "IndexAt does not work at position 1");
        this.assertEquals("three", this.__a__P_229_0.getItem(2), "IndexAt does not work at position 2"); // try some wrong inputs

        this.assertUndefined(this.__a__P_229_0.getItem(-1), "There should be no element at -1");
        this.assertUndefined(this.__a__P_229_0.getItem(3), "There should be no element at 3");
      },
      testSetItem: function testSetItem() {
        this.__a__P_229_0.setItem(0, "eins");

        this.assertEquals("eins", this.__a__P_229_0.getItem(0), "IndexAt does not work at position 0");

        this.__a__P_229_0.setItem(3, "drei");

        this.assertEquals("drei", this.__a__P_229_0.getItem(3), "IndexAt does not work at position 0");
      },
      testJoin: function testJoin() {
        this.assertEquals("one, two, three", this.__a__P_229_0.join(", "), "Join does not work");
      },
      testReverse: function testReverse() {
        this.__a__P_229_0.reverse();

        this.assertEquals("one", this.__a__P_229_0.getItem(2), "Reverse does not work"); // test for the event

        var a = new qx.data.Array(1, 2, 3);
        var self = this;
        this.assertEventFired(a, "change", function () {
          a.reverse();
        }, function (e) {
          self.assertEquals(0, e.getData().start, "Wrong start index in the event.");
          self.assertEquals(2, e.getData().end, "Wrong end index in the event.");
          self.assertEquals("order", e.getData().type, "Wrong type in the event.");
        }, "Change event not fired!");
        a.dispose();
      },
      testSort: function testSort() {
        this.__a__P_229_0.sort();

        this.assertEquals("one three two", this.__a__P_229_0.join(" "), "Simple sort does not work");

        this.__a__P_229_0.sort(function (a, b) {
          return a > b ? -1 : 1;
        });

        this.assertEquals("two three one", this.__a__P_229_0.join(" "), "Own sort does not work"); // test for the event

        var a = new qx.data.Array(2, 7, 5);
        var self = this;
        this.assertEventFired(a, "change", function () {
          a.sort();
        }, function (e) {
          self.assertEquals(0, e.getData().start, "Wrong start index in the event.");
          self.assertEquals(2, e.getData().end, "Wrong end index in the event.");
          self.assertEquals("order", e.getData().type, "Wrong type in the event.");
        }, "Change event not fired!");
        a.dispose();
      },
      testConcat: function testConcat() {
        var b = this.__a__P_229_0.concat(["four", "five"]);

        this.assertEquals("one two three four five", b.join(" "), "Concat does not work");
        b.dispose();

        var b = this.__a__P_229_0.concat(new qx.data.Array(["four", "five"]));

        this.assertEquals("one two three four five", b.join(" "), "Concat does not work");
        b.dispose();
      },
      testSlice: function testSlice() {
        var slice = this.__a__P_229_0.slice(0, 1);

        this.assertEquals("one", slice.getItem(0), "Slice does not work");
        slice.dispose();
        slice = this.__a__P_229_0.slice(1, 2);
        this.assertEquals("two", slice.getItem(0), "Slice does not work");
        slice.dispose();
        slice = this.__a__P_229_0.slice(0, 2);
        this.assertEquals("one", slice.getItem(0), "Slice does not work");
        slice.dispose();
        slice = this.__a__P_229_0.slice(0, 2);
        this.assertEquals("two", slice.getItem(1), "Slice does not work");
        slice.dispose();
      },
      testReplace: function testReplace() {
        var numFired = 0;

        var id = this.__a__P_229_0.addListener("change", function () {
          numFired++;
        });

        this.__a__P_229_0.replace(["one", "two", "three"]);

        this.assertEquals(0, numFired);

        this.__a__P_229_0.replace(["one", "three"]);

        this.assertEquals(1, numFired);
        this.assertArrayEquals(["one", "three"], this.__a__P_229_0.toArray());

        this.__a__P_229_0.replace(new qx.data.Array(["two", "four"]));

        this.assertEquals(2, numFired);
        this.assertArrayEquals(["two", "four"], this.__a__P_229_0.toArray());

        this.__a__P_229_0.removeListenerById(id);
      },
      testPop: function testPop() {
        this.assertEquals("three", this.__a__P_229_0.pop(), "Pop does not work.");
        this.assertEquals(2, this.__a__P_229_0.length, "Wrong length after pop");
        this.assertEquals("two", this.__a__P_229_0.pop(), "Pop does not work.");
        this.assertEquals("one", this.__a__P_229_0.pop(), "Pop does not work.");
        this.assertEquals(0, this.__a__P_229_0.length, "Wrong length after pop");
      },
      testPush: function testPush() {
        this.assertEquals(4, this.__a__P_229_0.push("four"), "Push does not give the right length back.");
        this.assertEquals("one two three four", this.__a__P_229_0.join(" "), "Single push does not work.");
        this.assertEquals(4, this.__a__P_229_0.length, "Single push does not work.");

        this.__a__P_229_0.dispose();

        this.__a__P_229_0 = new qx.data.Array();

        this.__a__P_229_0.push(1, 2, 3);

        this.assertEquals("1 2 3", this.__a__P_229_0.join(" "), "Multiple push does not work.");
      },
      testShift: function testShift() {
        this.assertEquals("one", this.__a__P_229_0.shift(), "Shift does not work.");
        this.assertEquals("two three", this.__a__P_229_0.join(" "), "Shift does not work.");
        this.assertEquals("two", this.__a__P_229_0.shift(), "Shift does not work.");
        this.assertEquals(1, this.__a__P_229_0.length, "Shift does not work.");
      },
      testShiftWithEventPropagation: function testShiftWithEventPropagation() {
        var data = {
          "bar": [1, 2, 3, 4, 5]
        };
        var model = qx.data.marshal.Json.createModel(data, true);
        this.assertEquals(1, model.getBar().shift());
        model.dispose();
      },
      testUnshift: function testUnshift() {
        this.assertEquals(4, this.__a__P_229_0.unshift("zero"), "Unshift does not return the proper length.");
        this.assertEquals("zero one two three", this.__a__P_229_0.join(" "), "Unshift does not work!");
        this.assertEquals(6, this.__a__P_229_0.unshift("-2", "-1"), "Unshift does not return the proper length.");
        this.assertEquals("-2 -1 zero one two three", this.__a__P_229_0.join(" "), "Unshift does not work!");
      },
      testSplice: function testSplice() {
        var a = new qx.data.Array(1, 2, 3, 4, 5, 6, 7, 8);
        var splice = a.splice(4, a.length - 1);
        this.assertEquals("5 6 7 8", splice.join(" "), "Splice does not work");
        splice.dispose();
        this.assertEquals("1 2 3 4", a.join(" "), "Splice does not work");
        splice = a.splice(1, 2);
        this.assertEquals("2 3", splice.join(" "), "Splice does not work");
        splice.dispose();
        this.assertEquals("1 4", a.join(" "), "Splice does not work");
        a.dispose();
        var a = new qx.data.Array(1, 2, 3, 4, 5);
        splice = a.splice(2, 0, "a", "b");
        this.assertEquals("", splice.join(" "), "Splice does not work");
        splice.dispose();
        this.assertEquals("1 2 a b 3 4 5", a.join(" "), "Splice does not work");
        splice = a.splice(2, 2, "c", 3);
        this.assertEquals("a b", splice.join(" "), "Splice does not work");
        splice.dispose();
        this.assertEquals("1 2 c 3 3 4 5", a.join(" "), "Splice does not work");
        splice = a.splice(1);
        this.assertInstance(splice, qx.data.Array, "Wrong return type");
        splice.dispose();
        a.dispose();
      },
      testToArray: function testToArray() {
        this.assertEquals("one two three", this.__a__P_229_0.toArray().join(" "), "toArray does not work!");
        this.assertInstance(this.__a__P_229_0.toArray(), Array, "toArray does not work!");
      },
      testLengthEvent: function testLengthEvent() {
        var self = this; // test for the event

        var a = new qx.data.Array(1, 2, 3);
        this.assertEventFired(a, "changeLength", function () {
          a.pop();
        }, function (e) {
          self.assertEquals(2, e.getData());
          self.assertEquals(3, e.getOldData());
        }, "ChangeLength event not fired!");
        a.dispose();
      },
      testToString: function testToString() {
        this.assertEquals(this.__a__P_229_0.toArray().toString(), this.__a__P_229_0.toString(), "toString does not work!");
      },
      testContains: function testContains() {
        this.assertTrue(this.__a__P_229_0.contains("one"), "contains does not work!");
        this.assertTrue(this.__a__P_229_0.contains("two"), "contains does not work!");
        this.assertTrue(this.__a__P_229_0.contains("three"), "contains does not work!");
      },
      testIndexOf: function testIndexOf() {
        this.assertEquals(0, this.__a__P_229_0.indexOf("one"), "indexOf does not work!");
        this.assertEquals(1, this.__a__P_229_0.indexOf("two"), "indexOf does not work!");
        this.assertEquals(2, this.__a__P_229_0.indexOf("three"), "indexOf does not work!");
      },
      testLastIndexOf: function testLastIndexOf() {
        this.__a__P_229_0.push("one");

        this.__a__P_229_0.push("two");

        this.__a__P_229_0.push("three");

        this.assertEquals(3, this.__a__P_229_0.lastIndexOf("one"), "lastIndexOf does not work!");
        this.assertEquals(4, this.__a__P_229_0.lastIndexOf("two"), "lastIndexOf does not work!");
        this.assertEquals(5, this.__a__P_229_0.lastIndexOf("three"), "lastIndexOf does not work!");
      },
      testCopy: function testCopy(attribute) {
        var a = this.__a__P_229_0.copy(); // change the original array


        this.__a__P_229_0.setItem(0, "0");

        this.__a__P_229_0.setItem(1, "1");

        this.__a__P_229_0.setItem(2, "2"); // check the value


        this.assertEquals("one", a.getItem(0), "Copy does not work");
        this.assertEquals("two", a.getItem(1), "Copy does not work");
        this.assertEquals("three", a.getItem(2), "Copy does not work");
        a.dispose();
      },
      testInsertAt: function testInsertAt() {
        this.__a__P_229_0.insertAt(1, "eins");

        this.__a__P_229_0.insertAt(3, "drei"); // check the value


        this.assertEquals("one", this.__a__P_229_0.getItem(0), "insertAt does not work");
        this.assertEquals("eins", this.__a__P_229_0.getItem(1), "insertAt does not work");
        this.assertEquals("two", this.__a__P_229_0.getItem(2), "insertAt does not work");
        this.assertEquals("drei", this.__a__P_229_0.getItem(3), "insertAt does not work");
        this.assertEquals("three", this.__a__P_229_0.getItem(4), "insertAt does not work");
      },
      testInsertBefore: function testInsertBefore() {
        this.__a__P_229_0.insertBefore("two", "eins");

        this.__a__P_229_0.insertBefore("three", "drei"); // check the value


        this.assertEquals("one", this.__a__P_229_0.getItem(0), "insertBefore does not work");
        this.assertEquals("eins", this.__a__P_229_0.getItem(1), "insertBefore does not work");
        this.assertEquals("two", this.__a__P_229_0.getItem(2), "insertBefore does not work");
        this.assertEquals("drei", this.__a__P_229_0.getItem(3), "insertBefore does not work");
        this.assertEquals("three", this.__a__P_229_0.getItem(4), "insertBefore does not work");
      },
      testInsertAfter: function testInsertAfter() {
        this.__a__P_229_0.insertAfter("one", "eins");

        this.__a__P_229_0.insertAfter("two", "drei"); // check the value


        this.assertEquals("one", this.__a__P_229_0.getItem(0), "insertAfter does not work");
        this.assertEquals("eins", this.__a__P_229_0.getItem(1), "insertAfter does not work");
        this.assertEquals("two", this.__a__P_229_0.getItem(2), "insertAfter does not work");
        this.assertEquals("drei", this.__a__P_229_0.getItem(3), "insertAfter does not work");
        this.assertEquals("three", this.__a__P_229_0.getItem(4), "insertAfter does not work");
      },
      testRemoveAt: function testRemoveAt() {
        var removed = this.__a__P_229_0.removeAt(1); // check the value


        this.assertEquals("two", removed, "no return type");
        this.assertEquals("one", this.__a__P_229_0.getItem(0), "removeAt does not work");
        this.assertEquals("three", this.__a__P_229_0.getItem(1), "removeAt does not work");
      },
      testRemoveAll: function testRemoveAll() {
        var self = this;
        this.assertEventFired(self.__a__P_229_0, "changeLength", function () {
          self.__a__P_229_0.removeAll();
        }, function (e) {
          self.assertEquals(0, self.__a__P_229_0.getLength(), "length not 0");
        }, "Change event not fired!");

        this.__a__P_229_0.push("a");

        this.__a__P_229_0.push("b");

        this.assertEventFired(self.__a__P_229_0, "change", function () {
          var removed = self.__a__P_229_0.removeAll();

          self.assertEquals(2, removed.length);
          self.assertEquals("a", removed[0]);
          self.assertEquals("b", removed[1]);
        }, function (e) {
          self.assertEquals(0, e.getData().start, "Wrong start index in the event.");
          self.assertEquals(1, e.getData().end, "Wrong end index in the event.");
          self.assertEquals("remove", e.getData().type, "Wrong type in the event.");
          self.assertEquals("a", e.getData().removed[0]);
          self.assertEquals("b", e.getData().removed[1]);
        }, "Change event not fired!");
        this.assertEquals(0, this.__a__P_229_0.length, "RemoveAll does not work.");
      },
      testAppend: function testAppend() {
        var dArray = new qx.data.Array("4", "5");

        this.__a__P_229_0.append(dArray.toArray()); // check the value


        this.assertEquals("one", this.__a__P_229_0.getItem(0), "append does not work");
        this.assertEquals("two", this.__a__P_229_0.getItem(1), "append does not work");
        this.assertEquals("three", this.__a__P_229_0.getItem(2), "append does not work");
        this.assertEquals("4", this.__a__P_229_0.getItem(3), "append does not work");
        this.assertEquals("5", this.__a__P_229_0.getItem(4), "append does not work");
        dArray.dispose(); // check if qx arrays work

        dArray = new qx.data.Array(["sechs"]);

        this.__a__P_229_0.append(dArray);

        this.assertEquals("sechs", this.__a__P_229_0.getItem(5), "append does not work");
        dArray.dispose();
      },
      testExclude: function testExclude() {
        var tmp = new qx.data.Array(["one", "two", "three", "four", "five"]);
        tmp.exclude(["two", "four"]);
        this.assertArrayEquals(tmp.toArray(), ["one", "three", "five"]);
        var tmp = new qx.data.Array(["one", "two", "three", "four", "five"]);
        tmp.exclude(new qx.data.Array(["one", "three", "five"]));
        this.assertArrayEquals(tmp.toArray(), ["two", "four"]);
      },
      testRemove: function testRemove() {
        this.__a__P_229_0.remove("two"); // check the value


        this.assertEquals("one", this.__a__P_229_0.getItem(0), "removeAt does not work");
        this.assertEquals("three", this.__a__P_229_0.getItem(1), "removeAt does not work");
      },
      testEquals: function testEquals() {
        var a = new qx.data.Array("one", "two", "three");
        this.assertTrue(this.__a__P_229_0.equals(a), "equals does not work.");
        a.dispose();
        this.assertTrue(this.__a__P_229_0.equals(["one", "two", "three"]), "equals does not work.");
      },
      testSum: function testSum() {
        var a = new qx.data.Array(1, 2, 3);
        this.assertEquals(6, a.sum(), "sum does not work.");
        a.dispose();
      },
      testMax: function testMax() {
        var a = new qx.data.Array(1, 2, 3);
        this.assertEquals(3, a.max(), "max does not work.");
        a.dispose();
      },
      testMin: function testMin() {
        var a = new qx.data.Array(1, 2, -3);
        this.assertEquals(-3, a.min(), "min does not work.");
        a.dispose();
      },
      testPopEvent: function testPopEvent() {
        // test for the event
        var a = new qx.data.Array(1, 2, 3);
        var self = this;
        this.assertEventFired(a, "change", function () {
          a.pop();
        }, function (e) {
          self.assertEquals(1, e.getData().start, "Wrong start index in the event.");
          self.assertEquals(1, e.getData().end, "Wrong end index in the event.");
          self.assertEquals("remove", e.getData().type, "Wrong type in the event.");
          self.assertEquals(3, e.getData().removed[0], "Wrong removed array in the event.");
        }, "Change event not fired!");
        a.dispose();
      },
      testPushEvent: function testPushEvent() {
        // test for the event
        var a = new qx.data.Array(1, 2, 3);
        var self = this;
        this.assertEventFired(a, "change", function () {
          a.push(4);
        }, function (e) {
          self.assertEquals(3, e.getData().start, "Wrong start index in the event.");
          self.assertEquals(3, e.getData().end, "Wrong end index in the event.");
          self.assertEquals("add", e.getData().type, "Wrong type in the event.");
          self.assertEquals(4, e.getData().added[0], "Wrong item array in the event.");
        }, "Change event not fired!");
        a.dispose();
      },
      testAppendEvent: function testAppendEvent() {
        // test for the event
        var a = new qx.data.Array(1, 2, 3);
        var self = this;
        this.assertEventFired(a, "change", function () {
          a.append([4, 5]);
        }, function (e) {
          self.assertEquals(3, e.getData().start, "Wrong start index in the event.");
          self.assertEquals(4, e.getData().end, "Wrong end index in the event.");
          self.assertEquals("add", e.getData().type, "Wrong type in the event.");
          self.assertEquals(4, e.getData().added[0], "Wrong item array in the event.");
          self.assertEquals(5, e.getData().added[1], "Wrong item array in the event.");
        }, "Change event not fired!");
        a.dispose();
      },
      testShiftEvent: function testShiftEvent() {
        // test for the event
        var a = new qx.data.Array(1, 2, 3);
        var self = this;
        this.assertEventFired(a, "change", function () {
          a.shift();
        }, function (e) {
          self.assertEquals(0, e.getData().start, "Wrong start index in the event.");
          self.assertEquals(1, e.getData().end, "Wrong end index in the event.");
          self.assertEquals("remove", e.getData().type, "Wrong type in the event.");
          self.assertEquals(1, e.getData().removed[0], "Wrong item in the event.");
        }, "Change event not fired!");
        a.dispose();
      },
      testUnshiftEvent: function testUnshiftEvent() {
        // test for the event
        var a = new qx.data.Array(1, 2, 3);
        var self = this;
        this.assertEventFired(a, "change", function () {
          a.unshift(0);
        }, function (e) {
          self.assertEquals(0, e.getData().start, "Wrong start index in the event.");
          self.assertEquals(3, e.getData().end, "Wrong end index in the event.");
          self.assertEquals("add", e.getData().type, "Wrong type in the event.");
          self.assertEquals(0, e.getData().added[0], "Wrong item in the event.");
        }, "Change event not fired!");
        a.dispose();
      },
      testSpliceEvent: function testSpliceEvent() {
        // test for the event (remove)
        var a = new qx.data.Array("a", "b", "c", "d", "e");
        var self = this;
        this.assertEventFired(a, "change", function () {
          a.splice(1, 2).dispose();
        }, function (e) {
          self.assertEquals(1, e.getData().start, "Wrong start index in the event (remove).");
          self.assertEquals(2, e.getData().end, "Wrong end index in the event (remove).");
          self.assertEquals("remove", e.getData().type, "Wrong type in the event (remove).");
          self.assertEquals("b", e.getData().removed[0], "Wrong item in the event (remove).");
          self.assertEquals("c", e.getData().removed[1], "Wrong item in the event (remove).");
          self.assertEquals(2, e.getData().removed.length, "Wrong item in the event (remove).");
          self.assertEquals(0, e.getData().added.length, "Wrong item in the event (remove).");
        }, "Change event not fired!");
        a.dispose(); // test for the event (add)

        a = new qx.data.Array("a", "b", "c");
        this.assertEventFired(a, "change", function () {
          a.splice(0, 0, "x").dispose();
        }, function (e) {
          self.assertEquals(0, e.getData().start, "Wrong start index in the event. (add)");
          self.assertEquals(1, e.getData().end, "Wrong end index in the event. (add)");
          self.assertEquals("add", e.getData().type, "Wrong type in the event. (add)");
          self.assertEquals("x", e.getData().added[0], "Wrong items in the event. (add)");
          self.assertEquals(1, e.getData().added.length, "Wrong amount of items in the event. (add)");
          self.assertEquals(0, e.getData().removed.length, "Wrong amount of items in the event. (add)");
        }, "Change event not fired!");
        a.dispose(); // test for the event (add/remove)

        a = new qx.data.Array("a", "b", "c");
        this.assertEventFired(a, "change", function () {
          a.splice(0, 1, "x").dispose();
        }, function (e) {
          self.assertEquals(0, e.getData().start, "Wrong start index in the event. (add/remove)");
          self.assertEquals(0, e.getData().end, "Wrong end index in the event. (add/remove)");
          self.assertEquals("add/remove", e.getData().type, "Wrong type in the event. (add/remove)");
          self.assertEquals("x", e.getData().added[0], "Wrong items in the event. (add/remove)");
          self.assertEquals(1, e.getData().added.length, "Wrong amount of items in the event. (add/remove)");
          self.assertEquals("a", e.getData().removed[0], "Wrong items in the event. (add/remove)");
          self.assertEquals(1, e.getData().removed.length, "Wrong amount of items in the event. (add/remove)");
        }, "Change event not fired!");
        a.dispose(); // test for the event (add/remove) in replace

        a = new qx.data.Array("a", "b", "c");
        this.assertEventFired(a, "change", function () {
          a.splice(0, 3, "x", "y", "z").dispose();
        }, function (e) {
          self.assertEquals(0, e.getData().start, "Wrong start index in the event. (replace)");
          self.assertEquals(2, e.getData().end, "Wrong end index in the event. (replace)");
          self.assertEquals("add/remove", e.getData().type, "Wrong type in the event. (replace)");
          self.assertEquals("x", e.getData().added[0], "Wrong items in the event. (replace)");
          self.assertEquals("y", e.getData().added[1], "Wrong items in the event. (replace)");
          self.assertEquals("z", e.getData().added[2], "Wrong items in the event. (replace)");
          self.assertEquals(3, e.getData().added.length, "Wrong amount of items in the event. (replace)");
          self.assertEquals("a", e.getData().removed[0], "Wrong items in the event. (replace)");
          self.assertEquals("b", e.getData().removed[1], "Wrong items in the event. (replace)");
          self.assertEquals("c", e.getData().removed[2], "Wrong items in the event. (replace)");
          self.assertEquals(3, e.getData().removed.length, "Wrong amount of items in the event. (replace)");
        }, "Change event not fired!");
        a.dispose();
      },
      testSpliceBubbleEvent: function testSpliceBubbleEvent() {
        // test for the event (remove)
        var a = new qx.data.Array("a", "b", "c", "d", "e");
        var self = this;
        this.assertEventFired(a, "changeBubble", function () {
          a.splice(1, 2).dispose();
        }, function (e) {
          var data = e.getData();
          self.assertEquals(0, data.value.length, "Wrong amount of item(s) added in the bubble event (remove).");
          self.assertEquals(2, data.old.length, "Wrong amount of item(s) removed in the bubble event (remove).");
          self.assertEquals("1-2", data.name, "Wrong name in the bubble event (remove).");
        }, "changeBubble event not fired!");
        a.dispose(); // test for the event (add)

        a = new qx.data.Array("a", "b", "c");
        this.assertEventFired(a, "changeBubble", function () {
          a.splice(0, 0, "x").dispose();
        }, function (e) {
          var data = e.getData();
          self.assertEquals(1, data.value.length, "Wrong amount of item(s) added in the bubble event (add).");
          self.assertEquals(0, data.old.length, "Wrong amount of item(s) removed in the bubble event (add).");
          self.assertEquals("0", data.name, "Wrong name in the bubble event (add).");
        }, "changeBubble event not fired!");
        a.dispose(); // test for the event (add/remove)

        a = new qx.data.Array("a", "b", "c");
        this.assertEventFired(a, "changeBubble", function () {
          a.splice(0, 1, "x").dispose();
        }, function (e) {
          var data = e.getData();
          self.assertEquals(1, data.value.length, "Wrong amount of item(s) added in the bubble event (add/remove).");
          self.assertEquals(1, data.old.length, "Wrong amount of item(s) removed in the bubble event (add/remove).");
          self.assertEquals("0", data.name, "Wrong name in the bubble event (add/remove).");
        }, "changeBubble event not fired!");
        a.dispose();
      },
      testSpliceEventNoChange: function testSpliceEventNoChange() {
        var a = new qx.data.Array(1, 2, 3);
        this.assertEventNotFired(a, "change", function () {
          a.splice(0, 0).dispose();
        }, "Change event fired!");
        a.dispose();
      },
      testSpliceEventEqualContent: function testSpliceEventEqualContent() {
        var a = new qx.data.Array(1, 2, 3);
        this.assertEventNotFired(a, "change", function () {
          a.splice(0, 2, 1, 2).dispose();
        }, "Change event fired!");
        a.dispose();
      },
      testSpliceBubbleEventNoChange: function testSpliceBubbleEventNoChange() {
        var a = new qx.data.Array(1, 2, 3);
        this.assertEventNotFired(a, "changeBubble", function () {
          a.splice(0, 0).dispose();
        }, "Change bubble event fired!");
        a.dispose();
      },
      testSpliceBubbleEventEqualContent: function testSpliceBubbleEventEqualContent() {
        var a = new qx.data.Array(1, 2, 3);
        this.assertEventNotFired(a, "changeBubble", function () {
          a.splice(0, 2, 1, 2).dispose();
        }, "Change bubble event fired!");
        a.dispose();
      },
      testSetItemEvent: function testSetItemEvent() {
        // test for the event
        var a = new qx.data.Array(1, 2, 3);
        var self = this;
        this.assertEventFired(a, "change", function () {
          a.setItem(0, 4);
        }, function (e) {
          self.assertEquals(0, e.getData().start, "Wrong start index in the event.");
          self.assertEquals(0, e.getData().end, "Wrong end index in the event.");
          self.assertEquals("add/remove", e.getData().type, "Wrong type in the event.");
          self.assertEquals(4, e.getData().added[0], "Wrong item in the event.");
          self.assertEquals(1, e.getData().added.length, "Wrong item in the event.");
          self.assertEquals(1, e.getData().removed[0], "Wrong item in the event.");
          self.assertEquals(1, e.getData().removed.length, "Wrong item in the event.");
        }, "Change event not fired!"); // set the same thing again and check if we get a second event

        this.assertEventNotFired(a, "change", function () {
          a.setItem(0, 4);
        }, "Change event fired!");
        a.dispose();
      },
      testForEach: function testForEach() {
        var self = this;
        var i = 0;
        var thisContext = {};
        var handlerCalled = false;

        var forEachHandler = function forEachHandler(item, index, array) {
          handlerCalled = true; // check for the context

          self.assertEquals(this, thisContext); // check the parameter

          self.assertEquals(i, index);
          self.assertEquals(self.__a__P_229_0, array); // check the tree items

          if (i == 0) {
            i++;
            self.assertEquals("one", item);
            return;
          } else if (i == 1) {
            i++;
            self.assertEquals("two", item);
            return;
          } else if (i == 2) {
            i++;
            self.assertEquals("three", item);
            return;
          } // something went wrong!


          throw new Error("Wrong call in the handler.");
        }; // invoke the forEach


        this.__a__P_229_0.forEach(forEachHandler, thisContext); // check if the handlers has been called


        this.assertTrue(handlerCalled);
      },
      testNotAutoDisposeItems: function testNotAutoDisposeItems() {
        var o = new qx.core.Object();

        this.__a__P_229_0.push(o);

        this.__a__P_229_0.dispose();

        this.assertFalse(o.isDisposed());
        o.dispose();
      },
      testAutoDisposeItems: function testAutoDisposeItems() {
        var o = new qx.core.Object();

        this.__a__P_229_0.push(o);

        this.__a__P_229_0.setAutoDisposeItems(true);

        this.__a__P_229_0.dispose();

        this.assertTrue(o.isDisposed());
      },
      testFilter: function testFilter() {
        var self = this;

        var b = this.__a__P_229_0.filter(function (item, index, array) {
          self.assertEquals(self, this);
          self.assertString(item);
          self.assertNumber(index);
          self.assertEquals(self.__a__P_229_0.toArray(), array);
          return item == "one" || item == "three";
        }, this);

        this.assertEquals(2, b.length);
        this.assertEquals("one", b.getItem(0));
        this.assertEquals("three", b.getItem(1));
        b.dispose();
      },
      testMap: function testMap() {
        var self = this;

        var b = this.__a__P_229_0.map(function (item, index, array) {
          self.assertEquals(self, this);
          self.assertString(item);
          self.assertNumber(index);
          self.assertEquals(self.__a__P_229_0.toArray(), array);
          return item + "!";
        }, this);

        this.assertEquals(3, b.length);
        this.assertEquals("one!", b.getItem(0));
        this.assertEquals("two!", b.getItem(1));
        this.assertEquals("three!", b.getItem(2));
        b.dispose();
      },
      testSome: function testSome() {
        var self = this;
        this.assertTrue(this.__a__P_229_0.some(function (item, index, array) {
          self.assertEquals(self, this);
          self.assertString(item);
          self.assertNumber(index);
          self.assertEquals(self.__a__P_229_0.toArray(), array);
          return item == "one";
        }, this));
        this.assertFalse(this.__a__P_229_0.some(function (item, index, array) {
          return item == "xxx";
        }, this));
      },
      testEvery: function testEvery() {
        var self = this;
        this.assertTrue(this.__a__P_229_0.every(function (item, index, array) {
          self.assertEquals(self, this);
          self.assertString(item);
          self.assertNumber(index);
          self.assertEquals(self.__a__P_229_0.toArray(), array);
          return ["one", "two", "three"].indexOf(item) >= 0;
        }, this));
        this.assertFalse(this.__a__P_229_0.every(function (item, index, array) {
          return item == "one";
        }, this));
      },
      testReduce: function testReduce() {
        var self = this;

        var reduced = this.__a__P_229_0.reduce(function (previousValue, currentValue, index, array) {
          self.assertString(previousValue);
          self.assertString(currentValue);
          self.assertNumber(index);
          self.assertEquals(self.__a__P_229_0.toArray(), array);
          return previousValue + currentValue;
        }, "---");

        this.assertEquals("---onetwothree", reduced);
      },
      testReduceRight: function testReduceRight() {
        var self = this;

        var reduced = this.__a__P_229_0.reduceRight(function (previousValue, currentValue, index, array) {
          self.assertString(previousValue);
          self.assertString(currentValue);
          self.assertNumber(index);
          self.assertEquals(self.__a__P_229_0.toArray(), array);
          return previousValue + currentValue;
        }, "---");

        this.assertEquals("---threetwoone", reduced);
      }
    }
  });
  qx.test.data.DataArray.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.data.marshal.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.data.DataArrayWithChangeBubble", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      testObject: null,
      array: null,
      setUp: function setUp() {
        var testObject = {
          name: "test",
          data: ["A", "B", "C"]
        };
        this.testObject = qx.data.marshal.Json.createModel(testObject, true);
        this.array = this.testObject.getData();
      },
      tearDown: function tearDown() {
        this.array.dispose();
        this.testObject.dispose();
        this.array = this.testObject = null;
      },
      testRootArray: function testRootArray() {
        var m = [{
          b: 10
        }];
        m = qx.data.marshal.Json.createModel(m, true);
        var self = this;
        this.assertEventFired(m, "changeBubble", function () {
          m.getItem(0).setB("affee");
        }, function (e) {
          self.assertEquals("[0].b", e.getData().name);
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(m.getItem(0), e.getData().item);
        });
        m.dispose();
      },
      testAppend: function testAppend() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A", "B", "C", "D", "E", "F"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["D", "E", "F"], e.getData().value);
          that.assertEquals("data[3-5]", e.getData().name);
          that.assertArrayEquals([], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.append(["D", "E", "F"]);
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A", "B", "C", "D", "E", "F"], this.array.toArray(), "Changes are not applied!");
      },
      testAppendOne: function testAppendOne() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A", "B", "C", "D"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["D"], e.getData().value);
          that.assertEquals("data[3]", e.getData().name);
          that.assertArrayEquals([], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.append(["D"]);
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A", "B", "C", "D"], this.array.toArray(), "Changes are not applied!");
      },
      testBubbleAfterAppend: function testBubbleAfterAppend() {
        var that = this;
        var model = qx.data.marshal.Json.createModel([{
          a: "0"
        }, {
          a: "1"
        }], true);

        var handler = function handler(e) {
          // check the data
          that.assertEquals("affe", e.getData().value);
          that.assertEquals("[3].a", e.getData().name, "Indexing is wrong!");
        };

        var spy = this.spy(handler);
        var moreModel = qx.data.marshal.Json.createModel([{
          a: "2"
        }, {
          a: "3"
        }], true);
        model.append(moreModel);
        model.addListener("changeBubble", spy, this);
        model.getItem(3).setA("affe");
        this.assertCalledOnce(spy);
        this.assertEquals(4, model.length, "Length of the model is wrong!");
      },
      testInsertAfter: function testInsertAfter() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A", "B", "BB", "C"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["BB"], e.getData().value);
          that.assertEquals("data[2]", e.getData().name);
          that.assertArrayEquals([], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.insertAfter("B", "BB");
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A", "B", "BB", "C"], this.array.toArray(), "Changes are not applied!");
      },
      testInsertAt: function testInsertAt() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A", "B", "BB", "C"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["BB"], e.getData().value);
          that.assertEquals("data[2]", e.getData().name);
          that.assertArrayEquals([], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.insertAt(2, "BB");
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A", "B", "BB", "C"], this.array.toArray(), "Changes are not applied!");
      },
      testInsertBefore: function testInsertBefore() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A", "B", "BB", "C"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["BB"], e.getData().value);
          that.assertEquals("data[2]", e.getData().name);
          that.assertArrayEquals([], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.insertBefore("C", "BB");
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A", "B", "BB", "C"], this.array.toArray(), "Changes are not applied!");
      },
      testPop: function testPop() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A", "B"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals([], e.getData().value);
          that.assertEquals("data[2]", e.getData().name);
          that.assertArrayEquals(["C"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.pop();
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A", "B"], this.array.toArray(), "Changes are not applied!");
      },
      testPush: function testPush() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A", "B", "C", "D"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["D"], e.getData().value);
          that.assertEquals("data[3]", e.getData().name);
          that.assertArrayEquals([], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.push("D");
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A", "B", "C", "D"], this.array.toArray(), "Changes are not applied!");
      },
      testRemove: function testRemove() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A", "C"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals([], e.getData().value);
          that.assertEquals("data[1]", e.getData().name);
          that.assertArrayEquals(["B"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.remove("B");
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A", "C"], this.array.toArray(), "Changes are not applied!");
      },
      testRemoveAll: function testRemoveAll() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals([], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals([], e.getData().value);
          that.assertEquals("data[0-2]", e.getData().name);
          that.assertArrayEquals(["A", "B", "C"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.removeAll();
        this.assertCalledOnce(spy);
        this.assertArrayEquals([], this.array.toArray(), "Changes are not applied!");
      },
      testRemoveAt: function testRemoveAt() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A", "C"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals([], e.getData().value);
          that.assertEquals("data[1]", e.getData().name);
          that.assertArrayEquals(["B"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.removeAt(1);
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A", "C"], this.array.toArray(), "Changes are not applied!");
      },
      testReverse: function testReverse() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["C", "B", "A"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["C", "B", "A"], e.getData().value);
          that.assertEquals("data[0-2]", e.getData().name);
          that.assertArrayEquals(["A", "B", "C"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.reverse();
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["C", "B", "A"], this.array.toArray(), "Changes are not applied!");
      },
      testSetItem: function testSetItem() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A", "BB", "C"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["BB"], e.getData().value);
          that.assertEquals("data[1]", e.getData().name);
          that.assertArrayEquals(["B"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.setItem(1, "BB");
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A", "BB", "C"], this.array.toArray(), "Changes are not applied!");
      },
      testShift: function testShift() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["B", "C"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals([], e.getData().value);
          that.assertEquals("data[0]", e.getData().name);
          that.assertArrayEquals(["A"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.shift();
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["B", "C"], this.array.toArray(), "Changes are not applied!");
      },
      testSort: function testSort() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["C", "B", "A"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["C", "B", "A"], e.getData().value);
          that.assertEquals("data[0-2]", e.getData().name);
          that.assertArrayEquals(["A", "B", "C"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.sort(function (a, b) {
          return a < b ? 1 : a > b ? -1 : 0;
        });
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["C", "B", "A"], this.array.toArray(), "Changes are not applied!");
      },
      testSortSecondTime: function testSortSecondTime() {
        var that = this;
        var changeBubbleExecutionCounter = 0;

        var handler = function handler(e) {
          that.assertEquals(0, changeBubbleExecutionCounter, "Handler was fired more than one times.");
          that.assertArrayEquals(["C", "B", "A"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["C", "B", "A"], e.getData().value);
          that.assertEquals("data[0-2]", e.getData().name);
          that.assertArrayEquals(["A", "B", "C"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
          changeBubbleExecutionCounter++;
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.sort(function (a, b) {
          return a < b ? 1 : a > b ? -1 : 0;
        });
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["C", "B", "A"], this.array.toArray(), "Changes are not applied!"); // Sort array second time with same method

        this.array.sort(function (a, b) {
          return a < b ? 1 : a > b ? -1 : 0;
        });
      },
      testSplice: function testSplice() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A", "B", "D", "E", "F"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["D", "E", "F"], e.getData().value);
          that.assertEquals("data[2-4]", e.getData().name);
          that.assertArrayEquals(["C"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.splice(2, 3, "D", "E", "F").dispose();
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A", "B", "D", "E", "F"], this.array.toArray(), "Changes are not applied!");
      },
      testSpliceRemoveOnly: function testSpliceRemoveOnly() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["A"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals([], e.getData().value);
          that.assertEquals("data[1-2]", e.getData().name);
          that.assertArrayEquals(["B", "C"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.splice(1, 2).dispose();
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["A"], this.array.toArray(), "Changes are not applied!");
      },
      testUnshift: function testUnshift() {
        var that = this;

        var handler = function handler(e) {
          that.assertArrayEquals(["D", "A", "B", "C"], that.array.toArray(), "Changes are not applied when handler is executed!"); // check the data

          that.assertArrayEquals(["D"], e.getData().value);
          that.assertEquals("data[0]", e.getData().name);
          that.assertArrayEquals(["A"], e.getData().old);
          that.assertEquals(that.array, e.getData().item);
        };

        var spy = this.spy(handler);
        this.testObject.addListener("changeBubble", spy, this);
        this.array.unshift("D");
        this.assertCalledOnce(spy);
        this.assertArrayEquals(["D", "A", "B", "C"], this.array.toArray(), "Changes are not applied!");
      },
      testShiftAndSet: function testShiftAndSet() {
        // [BUG #6406]
        var model = qx.data.marshal.Json.createModel([{
          foo: "one"
        }, {
          foo: "two"
        }, {
          foo: "three"
        }], true); // first do a shift operation

        model.shift();
        var that = this;

        var handler = function handler(e) {
          // check the data
          that.assertEquals("zwei", e.getData().value);
          that.assertEquals("[0].foo", e.getData().name);
          that.assertEquals("two", e.getData().old);
        };

        var spy = this.spy(handler);
        model.addListener("changeBubble", spy, this);
        model.getItem(0).setFoo("zwei");
      },
      testReverseAndSet: function testReverseAndSet() {
        // [BUG #6406]
        var model = qx.data.marshal.Json.createModel([{
          foo: "one"
        }, {
          foo: "two"
        }, {
          foo: "three"
        }], true); // first do a shift operation

        model.reverse();
        var that = this;

        var handler = function handler(e) {
          // check the data
          that.assertEquals("drei", e.getData().value);
          that.assertEquals("[0].foo", e.getData().name);
          that.assertEquals("three", e.getData().old);
        };

        var spy = this.spy(handler);
        model.addListener("changeBubble", spy, this);
        model.getItem(0).setFoo("drei");
      },
      testUnshiftAndSet: function testUnshiftAndSet() {
        // [BUG #6406]
        var model = qx.data.marshal.Json.createModel([{
          foo: "one"
        }, {
          foo: "two"
        }, {
          foo: "three"
        }], true); // first do a shift operation

        model.unshift(qx.data.marshal.Json.createModel({
          foo: "zero"
        }, true));
        var that = this;

        var handler = function handler(e) {
          // check the data
          that.assertEquals("eins", e.getData().value);
          that.assertEquals("[1].foo", e.getData().name);
          that.assertEquals("one", e.getData().old);
        };

        var spy = this.spy(handler);
        model.addListener("changeBubble", spy, this);
        model.getItem(1).setFoo("eins");
      },
      testSortAndSet: function testSortAndSet() {
        // [BUG #6406]
        var model = qx.data.marshal.Json.createModel([{
          foo: "one",
          n: 1
        }, {
          foo: "two",
          n: 2
        }, {
          foo: "three",
          n: 0
        }], true); // sort by number

        model.sort(function (a, b) {
          return a.getN() < b.getN() ? -1 : a.getN() > b.getN() ? 1 : 0;
        });
        var that = this;

        var handler = function handler(e) {
          // check the data
          that.assertEquals("drei", e.getData().value);
          that.assertEquals("[0].foo", e.getData().name);
          that.assertEquals("three", e.getData().old);
        };

        var spy = this.spy(handler);
        model.addListener("changeBubble", spy, this);
        model.getItem(0).setFoo("drei");
      },
      testSpliceAndSet: function testSpliceAndSet() {
        // [BUG #6406]
        var model = qx.data.marshal.Json.createModel([{
          foo: "one"
        }, {
          foo: "two"
        }, {
          foo: "three"
        }], true); // first do a shift operation

        model.splice(0, 0, qx.data.marshal.Json.createModel({
          foo: "zero"
        }, true));
        var that = this;

        var handler = function handler(e) {
          // check the data
          that.assertEquals("eins", e.getData().value);
          that.assertEquals("[1].foo", e.getData().name);
          that.assertEquals("one", e.getData().old);
        };

        var spy = this.spy(handler);
        model.addListener("changeBubble", spy, this);
        model.getItem(1).setFoo("eins");
      }
    }
  });
  qx.test.data.DataArrayWithChangeBubble.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.form.Form": {},
      "qx.ui.form.TextField": {},
      "qx.ui.form.CheckBox": {},
      "qx.data.marshal.Json": {},
      "qx.data.controller.Form": {},
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.ListItem": {},
      "qx.ui.form.List": {},
      "qx.data.controller.List": {},
      "qx.ui.form.Spinner": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.data.controller.Form", {
    extend: qx.dev.unit.TestCase,
    members: {
      __form__P_230_0: null,
      __tf1__P_230_1: null,
      __tf2__P_230_2: null,
      __cb__P_230_3: null,
      __model__P_230_4: null,
      setUp: function setUp() {
        // create the objects
        this.__form__P_230_0 = new qx.ui.form.Form();
        this.__tf1__P_230_1 = new qx.ui.form.TextField();
        this.__tf2__P_230_2 = new qx.ui.form.TextField("init");
        this.__cb__P_230_3 = new qx.ui.form.CheckBox();
        this.__model__P_230_4 = qx.data.marshal.Json.createModel({
          tf1: null,
          tf2: null,
          cb: null
        }); // build the form

        this.__form__P_230_0.add(this.__tf1__P_230_1, "label1", null, "tf1");

        this.__form__P_230_0.add(this.__tf2__P_230_2, "label2", null, "tf2");

        this.__form__P_230_0.add(this.__cb__P_230_3, "label3", null, "cb");
      },
      tearDown: function tearDown() {
        this.__form__P_230_0.dispose();

        this.__model__P_230_4.dispose();

        this.__tf1__P_230_1.dispose();

        this.__tf2__P_230_2.destroy();

        this.__cb__P_230_3.destroy();
      },
      testSetModelNull: function testSetModelNull() {
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0); // set some values

        this.__tf1__P_230_1.setValue("1111");

        this.__tf2__P_230_2.setValue("2222");

        this.__cb__P_230_3.setValue(true); // set model to null


        c.setModel(null); // all values should be null as well

        this.assertNull(this.__tf1__P_230_1.getValue());
        this.assertNull(this.__tf2__P_230_2.getValue());
        this.assertFalse(this.__cb__P_230_3.getValue());
        c.dispose();
      },
      testInitialResetter: function testInitialResetter() {
        // create the controller which set the initial values and
        // saves them for resetting
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0);

        this.__tf2__P_230_2.setValue("affe");

        this.__form__P_230_0.reset();

        this.assertEquals(null, this.__tf2__P_230_2.getValue());
        c.dispose();
      },
      testUnidirectionalDeep: function testUnidirectionalDeep() {
        this.__form__P_230_0.dispose();

        this.__form__P_230_0 = new qx.ui.form.Form();

        this.__form__P_230_0.add(this.__tf1__P_230_1, "label1", null, "a.tf1");

        this.__form__P_230_0.add(this.__tf2__P_230_2, "label2", null, "a.tf2"); // just create the controller


        var c = new qx.data.controller.Form(null, this.__form__P_230_0, true);
        var model = c.createModel(); // check if the binding from the model to the view works

        model.getA().setTf1("affe");
        this.assertEquals("affe", this.__tf1__P_230_1.getValue()); // check if the other direction does not work

        this.__tf2__P_230_2.setValue("affee");

        this.assertEquals("init", model.getA().getTf2()); // use the commit method

        c.updateModel();
        this.assertEquals("affee", model.getA().getTf2()); // destroy the controller

        c.dispose();
        model.dispose();
      },
      testUnidirectionalSelectionOptions: function testUnidirectionalSelectionOptions() {
        // just create the controller
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0, true);
        var sb = new qx.ui.form.SelectBox();
        var i1 = new qx.ui.form.ListItem("a").set({
          model: "a"
        });
        var i2 = new qx.ui.form.ListItem("b").set({
          model: "b"
        });
        sb.add(i1);
        sb.add(i2);

        this.__form__P_230_0.add(sb, "Sb");

        c.setModel(null);
        c.addBindingOptions("Sb", {
          converter: function converter(data) {
            return data && data.substr(0, 1);
          }
        }, {
          converter: function converter(data) {
            return data + "-item";
          }
        });
        var m = c.createModel(); // check that the init value is set

        this.assertEquals("a-item", m.getSb());
        sb.setSelection([i2]);
        this.assertEquals("a-item", m.getSb());
        c.updateModel();
        this.assertEquals("b-item", m.getSb()); // destroy

        sb.dispose();
        c.dispose();
        m.dispose();
      },
      testUnidirectionalOptions: function testUnidirectionalOptions() {
        // just create the controller
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0, true);
        c.addBindingOptions("tf1", {
          converter: function converter(data) {
            return data && data.substr(0, data.length - 1);
          }
        }, {
          converter: function converter(data) {
            return data + "a";
          }
        }); // check if the other direction does not work

        this.__tf1__P_230_1.setValue("affe");

        this.assertEquals(null, this.__model__P_230_4.getTf1()); // use the commit method

        c.updateModel();
        this.assertEquals("affea", this.__model__P_230_4.getTf1()); // destroy the controller

        c.dispose();
      },
      testUnidirectionalSelection: function testUnidirectionalSelection() {
        // just create the controller
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0, true);
        var sb = new qx.ui.form.SelectBox();
        var i1 = new qx.ui.form.ListItem("a").set({
          model: "a"
        });
        var i2 = new qx.ui.form.ListItem("b").set({
          model: "b"
        });
        sb.add(i1);
        sb.add(i2);

        this.__form__P_230_0.add(sb, "Sb");

        var m = c.createModel(); // check that the init value is set

        this.assertEquals("a", m.getSb());
        sb.setSelection([i2]);
        this.assertEquals("a", m.getSb());
        c.updateModel();
        this.assertEquals("b", m.getSb()); // destroy

        sb.dispose();
        c.dispose();
        m.dispose();
      },
      testUnidirectional: function testUnidirectional() {
        // just create the controller
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0, true); // check if the binding from the model to the view works

        this.__model__P_230_4.setTf1("affe");

        this.assertEquals("affe", this.__tf1__P_230_1.getValue()); // check if the other direction does not work

        this.__tf2__P_230_2.setValue("affee");

        this.assertEquals(null, this.__model__P_230_4.getTf2()); // use the commit method

        c.updateModel();
        this.assertEquals("affee", this.__model__P_230_4.getTf2()); // destroy the controller

        c.dispose();
      },
      testCreateEmpty: function testCreateEmpty() {
        // just create the controller
        var c = new qx.data.controller.Form(); // check the defaults for the properties

        this.assertNull(c.getModel());
        this.assertNull(c.getTarget()); // destroy the controller

        c.dispose();
      },
      testCreateWithModel: function testCreateWithModel() {
        // just create the controller
        var c = new qx.data.controller.Form(this.__model__P_230_4); // check for the properties

        this.assertEquals(this.__model__P_230_4, c.getModel());
        this.assertNull(c.getTarget()); // destroy the objects

        c.dispose();
      },
      testCreateWithForm: function testCreateWithForm() {
        // just create the controller
        var c = new qx.data.controller.Form(null, this.__form__P_230_0); // check for the properties

        this.assertEquals(this.__form__P_230_0, c.getTarget());
        this.assertNull(c.getModel()); // destroy the objects

        c.dispose();
      },
      testCreateWithBoth: function testCreateWithBoth() {
        // just create the controller
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0); // check for the properties

        this.assertEquals(this.__form__P_230_0, c.getTarget());
        this.assertEquals(this.__model__P_230_4, c.getModel()); // destroy the objects

        c.dispose();
      },
      testBindingCreate: function testBindingCreate() {
        // create the controller
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0); // set values in the form

        this.__tf1__P_230_1.setValue("1");

        this.__tf2__P_230_2.setValue("2");

        this.__cb__P_230_3.setValue(true); // check the binding


        this.assertEquals(this.__tf1__P_230_1.getValue(), this.__model__P_230_4.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), this.__model__P_230_4.getTf2());
        this.assertEquals(this.__cb__P_230_3.getValue(), this.__model__P_230_4.getCb()); // change the values

        this.__tf1__P_230_1.setValue("11");

        this.__tf2__P_230_2.setValue("21");

        this.__cb__P_230_3.setValue(false); // check the binding


        this.assertEquals(this.__tf1__P_230_1.getValue(), this.__model__P_230_4.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), this.__model__P_230_4.getTf2());
        this.assertEquals(this.__cb__P_230_3.getValue(), this.__model__P_230_4.getCb()); // change the data in the model

        this.__model__P_230_4.setTf1("a");

        this.__model__P_230_4.setTf2("b");

        this.__model__P_230_4.setCb(true); // check the binding


        this.assertEquals(this.__tf1__P_230_1.getValue(), this.__model__P_230_4.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), this.__model__P_230_4.getTf2());
        this.assertEquals(this.__cb__P_230_3.getValue(), this.__model__P_230_4.getCb()); // destroy the objects

        c.dispose();
      },
      testBindingChangeModel: function testBindingChangeModel() {
        // create the controller
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0); // set values in the form

        this.__tf1__P_230_1.setValue("1");

        this.__tf2__P_230_2.setValue("2");

        this.__cb__P_230_3.setValue(true); // check the binding


        this.assertEquals(this.__tf1__P_230_1.getValue(), this.__model__P_230_4.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), this.__model__P_230_4.getTf2());
        this.assertEquals(this.__cb__P_230_3.getValue(), this.__model__P_230_4.getCb());
        var model2 = qx.data.marshal.Json.createModel({
          tf1: null,
          tf2: null,
          cb: null
        });
        c.setModel(model2); // set values in the form

        this.__tf1__P_230_1.setValue("11");

        this.__tf2__P_230_2.setValue("22");

        this.__cb__P_230_3.setValue(false); // check the new model


        this.assertEquals(this.__tf1__P_230_1.getValue(), model2.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), model2.getTf2());
        this.assertEquals(this.__cb__P_230_3.getValue(), model2.getCb()); // check the old model

        this.assertEquals("1", this.__model__P_230_4.getTf1());
        this.assertEquals("2", this.__model__P_230_4.getTf2());
        this.assertEquals(true, this.__model__P_230_4.getCb());
        model2.dispose();
        c.dispose();
      },
      testBindingChangeForm: function testBindingChangeForm() {
        // create the controller
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0); // set values in the form

        this.__tf1__P_230_1.setValue("1");

        this.__tf2__P_230_2.setValue("2");

        this.__cb__P_230_3.setValue(true); // check the binding


        this.assertEquals(this.__tf1__P_230_1.getValue(), this.__model__P_230_4.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), this.__model__P_230_4.getTf2());
        this.assertEquals(this.__cb__P_230_3.getValue(), this.__model__P_230_4.getCb()); // create a new form

        var form = new qx.ui.form.Form();
        var tf1 = new qx.ui.form.TextField();
        var tf2 = new qx.ui.form.TextField("init");
        var cb = new qx.ui.form.CheckBox();
        form.add(tf1, "tf1");
        form.add(tf2, "tf2");
        form.add(cb, "cb");
        c.setTarget(form); // set the values in the new form

        tf1.setValue("11");
        tf2.setValue("22");
        cb.setValue(false); // check the binding

        this.assertEquals(tf1.getValue(), this.__model__P_230_4.getTf1());
        this.assertEquals(tf2.getValue(), this.__model__P_230_4.getTf2());
        this.assertEquals(cb.getValue(), this.__model__P_230_4.getCb()); // check the old from

        this.assertEquals(this.__tf1__P_230_1.getValue(), "1");
        this.assertEquals(this.__tf2__P_230_2.getValue(), "2");
        this.assertEquals(this.__cb__P_230_3.getValue(), true);
        form.dispose();
        tf1.destroy();
        tf2.destroy();
        cb.destroy();
        c.dispose();
      },
      testBindingDeep: function testBindingDeep() {
        // a - b - cb
        // |   \
        // tf1  c
        //       \
        //        tf2
        var data = {
          a: {
            tf1: null
          },
          b: {
            c: {
              tf2: null
            }
          },
          cb: null
        };
        var model = qx.data.marshal.Json.createModel(data); // create the form

        var form = new qx.ui.form.Form();
        var tf1 = new qx.ui.form.TextField();
        var tf2 = new qx.ui.form.TextField();
        var cb = new qx.ui.form.CheckBox(); // add the form incl. deep binding instructions

        form.add(tf1, "label1", null, "a.tf1");
        form.add(tf2, "label2", null, "b.c.tf2");
        form.add(cb, "label3", null, "cb"); // create the controller

        var c = new qx.data.controller.Form(model, form); // set the values in the model

        model.getA().setTf1("1");
        model.getB().getC().setTf2("2");
        model.setCb(true); // check the binding

        this.assertEquals(tf1.getValue(), model.getA().getTf1());
        this.assertEquals(tf2.getValue(), model.getB().getC().getTf2());
        this.assertEquals(cb.getValue(), model.getCb()); // set the values in the form items

        tf1.setValue("11");
        tf2.setValue("22");
        cb.setValue(false); // check the binding

        this.assertEquals(tf1.getValue(), model.getA().getTf1());
        this.assertEquals(tf2.getValue(), model.getB().getC().getTf2());
        this.assertEquals(cb.getValue(), model.getCb());
        c.dispose();
        model.dispose();
        form.dispose();
        tf1.destroy();
        tf2.destroy();
        cb.destroy();
      },
      testBindingModelSelection: function testBindingModelSelection() {
        // create a select box
        var selectBox = new qx.ui.form.SelectBox();
        var i1 = new qx.ui.form.ListItem("a");
        i1.setModel("1");
        var i2 = new qx.ui.form.ListItem("b");
        i2.setModel("2");
        selectBox.add(i1);
        selectBox.add(i2); // add the selectBox to the form

        this.__form__P_230_0.add(selectBox, "sb");

        var model = qx.data.marshal.Json.createModel({
          tf1: null,
          tf2: null,
          cb: null,
          sb: null
        }); // create the controller

        var c = new qx.data.controller.Form(model, this.__form__P_230_0); // set the selection

        selectBox.setSelection([i1]); // check the selection

        this.assertEquals(selectBox.getSelection()[0].getModel(), model.getSb()); // set the model

        model.setSb("2"); // check the selection

        this.assertEquals(selectBox.getSelection()[0].getModel(), model.getSb());
        c.dispose();
        model.dispose();
        i2.destroy();
        i1.destroy();
        selectBox.destroy();
      },
      testModelCreation: function testModelCreation() {
        // set some initial values in the form
        this.__tf1__P_230_1.setValue("A");

        this.__tf2__P_230_2.setValue("B");

        this.__cb__P_230_3.setValue(true); // create the controller


        var c = new qx.data.controller.Form(null, this.__form__P_230_0);
        c.addBindingOptions("tf1", {
          converter: function converter(data) {
            return data && data.substr(0, 1);
          }
        }, {
          converter: function converter(data) {
            return data + "-";
          }
        });
        var model = c.createModel(); // check if the model and the form still have the initial value

        this.assertEquals("A", this.__tf1__P_230_1.getValue());
        this.assertEquals("B", this.__tf2__P_230_2.getValue());
        this.assertTrue(this.__cb__P_230_3.getValue());
        this.assertEquals("A-", model.getTf1());
        this.assertEquals("B", model.getTf2());
        this.assertTrue(model.getCb()); // set values in the form

        this.__tf1__P_230_1.setValue("1");

        this.__tf2__P_230_2.setValue("2");

        this.__cb__P_230_3.setValue(true); // check the binding


        this.assertEquals(this.__tf1__P_230_1.getValue() + "-", model.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), model.getTf2());
        this.assertEquals(this.__cb__P_230_3.getValue(), model.getCb()); // change the values

        this.__tf1__P_230_1.setValue("11");

        this.__tf2__P_230_2.setValue("21");

        this.__cb__P_230_3.setValue(false); // check the binding


        this.assertEquals(this.__tf1__P_230_1.getValue() + "-", model.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), model.getTf2());
        this.assertEquals(this.__cb__P_230_3.getValue(), model.getCb()); // change the data in the model

        this.__model__P_230_4.setTf1("a");

        this.__model__P_230_4.setTf2("b");

        this.__model__P_230_4.setCb(true); // check the binding


        this.assertEquals(this.__tf1__P_230_1.getValue() + "-", model.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), model.getTf2());
        this.assertEquals(this.__cb__P_230_3.getValue(), model.getCb()); // destroy the objects

        c.dispose();
        model.dispose();
      },
      testModelCreationDeep: function testModelCreationDeep() {
        var form = new qx.ui.form.Form();
        var tf1 = new qx.ui.form.TextField("A");
        var tf2 = new qx.ui.form.TextField("B");
        form.add(tf1, null, null, "a.b1");
        form.add(tf2, null, null, "a.b2.c");
        var controller = new qx.data.controller.Form(null, form);
        var model = controller.createModel(true); // check if the creation worked

        this.assertEquals("A", model.getA().getB1());
        this.assertEquals("B", model.getA().getB2().getC());
        model.dispose();
        controller.dispose();
        tf1.destroy();
        tf2.destroy();
        form.dispose();
      },
      testModelCreationWithList: function testModelCreationWithList() {
        var form = new qx.ui.form.Form();
        var list = new qx.ui.form.List();
        var i1 = new qx.ui.form.ListItem("A");
        var i2 = new qx.ui.form.ListItem("B");
        list.add(i1);
        list.add(i2);
        i1.setModel("A");
        i2.setModel("B");
        list.setSelection([]);
        form.add(list, "list");
        var controller = new qx.data.controller.Form(null, form);
        var model = controller.createModel(); // check if the creation worked

        this.assertNull(model.getList());
        list.setSelection([i1]);
        this.assertEquals("A", model.getList());
        model.dispose();
        controller.dispose();
        list.destroy();
        i1.destroy();
        i2.destroy();
        form.dispose();
      },
      testModelCreationSpecialCaracter: function testModelCreationSpecialCaracter() {
        var form = new qx.ui.form.Form();
        var tf1 = new qx.ui.form.TextField("A");
        form.add(tf1, "a&b-c+d*e/f|g!h i.,:?;!~+-*/%{}()[]<>=^&|@/\\");
        var controller = new qx.data.controller.Form(null, form);
        var model = controller.createModel(true); // check if the creation worked

        this.assertEquals("A", model.getAbcdefghi());
        model.dispose();
        controller.dispose();
        tf1.destroy();
        form.dispose();
      },
      testModelCreationWithListController: function testModelCreationWithListController() {
        // create a select box
        var selectBox = new qx.ui.form.SelectBox();
        var listModel = qx.data.marshal.Json.createModel([{
          name: "a"
        }, {
          name: "b"
        }]);
        var listController = new qx.data.controller.List(listModel, selectBox, "name"); // add the selectBox to the form

        this.__form__P_230_0.add(selectBox, "sb"); // select something which is not the default selection


        listController.getSelection().setItem(0, listModel.getItem(1)); // create the controller

        var c = new qx.data.controller.Form(null, this.__form__P_230_0);
        var model = c.createModel(); // check the init value of the model selection

        this.assertEquals(listModel.getItem(1), model.getSb()); // set the selection

        listController.getSelection().setItem(0, listModel.getItem(0)); // check the selection

        this.assertEquals(selectBox.getSelection()[0].getModel(), model.getSb()); // set the model

        model.setSb(listModel.getItem(1)); // check the selection

        this.assertEquals(selectBox.getSelection()[0].getModel(), model.getSb());
        c.dispose();
        listController.dispose();
        listModel.dispose();
        model.dispose();
        selectBox.destroy();
      },
      testModelCreationWithModelSelection: function testModelCreationWithModelSelection() {
        // create a select box
        var selectBox = new qx.ui.form.SelectBox();
        var i1 = new qx.ui.form.ListItem("a");
        i1.setModel("1");
        var i2 = new qx.ui.form.ListItem("b");
        i2.setModel("2");
        selectBox.add(i1);
        selectBox.add(i2);
        selectBox.setSelection([i1]); // add the selectBox to the form

        this.__form__P_230_0.add(selectBox, "sb"); // select something which is not the default selection


        selectBox.setSelection([i2]); // create the controller

        var c = new qx.data.controller.Form(null, this.__form__P_230_0);
        var model = c.createModel(); // check the init value of the model selection

        this.assertEquals("2", model.getSb()); // set the selection

        selectBox.setSelection([i1]); // check the selection

        this.assertEquals(selectBox.getSelection()[0].getModel(), model.getSb()); // set the model

        model.setSb("2"); // check the selection

        this.assertEquals(selectBox.getSelection()[0].getModel(), model.getSb());
        c.dispose();
        model.dispose();
        i2.destroy();
        i1.destroy();
        selectBox.destroy();
      },
      testRemoveTarget: function testRemoveTarget() {
        // create a select box
        var selectBox = new qx.ui.form.SelectBox();
        var i1 = new qx.ui.form.ListItem("a");
        i1.setModel("1");
        var i2 = new qx.ui.form.ListItem("b");
        i2.setModel("2");
        selectBox.add(i1);
        selectBox.add(i2); // add the selectBox to the form

        this.__form__P_230_0.add(selectBox, "sb");

        this.__form__P_230_0.add(this.__tf1__P_230_1, "tf1");

        var model = qx.data.marshal.Json.createModel({
          tf1: null,
          tf2: null,
          cb: null,
          sb: null
        }); // create the controller

        var c = new qx.data.controller.Form(model, this.__form__P_230_0); // set the selection

        selectBox.setSelection([i1]); // check the selection

        this.assertEquals(selectBox.getSelection()[0].getModel(), model.getSb()); // set the model

        model.setSb("2"); // check the selection

        this.assertEquals(selectBox.getSelection()[0].getModel(), model.getSb()); // check the textfield

        this.assertEquals(this.__tf1__P_230_1.getValue(), model.getTf1()); // change the values

        this.__tf1__P_230_1.setValue("11"); // check the binding


        this.assertEquals(this.__tf1__P_230_1.getValue(), model.getTf1()); // change the data in the model

        model.setTf1("a"); // check the binding

        this.assertEquals(this.__tf1__P_230_1.getValue(), model.getTf1()); // remove the target

        c.setTarget(null); // change the values in the model

        model.setTf1("affe");
        model.setSb("1"); // check the form items

        this.assertEquals("a", this.__tf1__P_230_1.getValue());
        this.assertEquals("2", selectBox.getSelection()[0].getModel()); // change the values in the items

        this.__tf1__P_230_1.setValue("viele affen");

        selectBox.setSelection([i1]); // check the model

        this.assertEquals("affe", model.getTf1());
        this.assertEquals("1", model.getSb());
        c.dispose();
        model.dispose();
        i2.destroy();
        i1.destroy();
        selectBox.destroy();
      },
      testOptions: function testOptions() {
        // create the controller
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0); // add the options

        var tf2model = {
          converter: function converter(data) {
            return "X" + data;
          }
        };
        var model2tf = {
          converter: function converter(data) {
            return data && data.substring(1);
          }
        };
        c.addBindingOptions("tf1", model2tf, tf2model); // set values in the form

        this.__tf1__P_230_1.setValue("1");

        this.__tf2__P_230_2.setValue("2"); // check the binding


        this.assertEquals("X" + this.__tf1__P_230_1.getValue(), this.__model__P_230_4.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), this.__model__P_230_4.getTf2()); // change the values

        this.__tf1__P_230_1.setValue("11");

        this.__tf2__P_230_2.setValue("21"); // check the binding


        this.assertEquals("X" + this.__tf1__P_230_1.getValue(), this.__model__P_230_4.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), this.__model__P_230_4.getTf2()); // change the data in the model

        this.__model__P_230_4.setTf1("Xa");

        this.__model__P_230_4.setTf2("b"); // check the binding


        this.assertEquals(this.__tf1__P_230_1.getValue(), this.__model__P_230_4.getTf1().substring(1));
        this.assertEquals(this.__tf2__P_230_2.getValue(), this.__model__P_230_4.getTf2()); // destroy the objects

        c.dispose();
      },
      testConnectionWithListControllerSelection: function testConnectionWithListControllerSelection() {
        // generate fake data
        var data = [{
          name: "a",
          age: 1
        }, {
          name: "b",
          age: 2
        }, {
          name: "c",
          age: 3
        }];
        var model = qx.data.marshal.Json.createModel(data); // list

        var list = new qx.ui.form.List();
        var listController = new qx.data.controller.List(model, list, "name"); // form

        var form = new qx.ui.form.Form();
        var tf = new qx.ui.form.TextField();
        var sp = new qx.ui.form.Spinner();
        form.add(tf, "Name", null, "name");
        form.add(sp, "Age", null, "age");
        var formController = new qx.data.controller.Form(null, form); // connection

        listController.bind("selection[0]", formController, "model"); // select the first item

        var listItems = list.getSelectables();
        list.setSelection([listItems[0]]); // check if the model is still the same

        this.assertEquals("a", model.getItem(0).getName());
        this.assertEquals("b", model.getItem(1).getName());
        this.assertEquals("c", model.getItem(2).getName());
        this.assertEquals(1, model.getItem(0).getAge());
        this.assertEquals(2, model.getItem(1).getAge());
        this.assertEquals(3, model.getItem(2).getAge()); // select the second item

        var listItems = list.getSelectables();
        list.setSelection([listItems[1]]); // check if the model is still the same

        this.assertEquals("a", model.getItem(0).getName());
        this.assertEquals("b", model.getItem(1).getName());
        this.assertEquals("c", model.getItem(2).getName());
        this.assertEquals(1, model.getItem(0).getAge());
        this.assertEquals(2, model.getItem(1).getAge());
        this.assertEquals(3, model.getItem(2).getAge()); // select the first item again

        var listItems = list.getSelectables();
        list.setSelection([listItems[0]]); // check if the model is still the same

        this.assertEquals("a", model.getItem(0).getName());
        this.assertEquals("b", model.getItem(1).getName());
        this.assertEquals("c", model.getItem(2).getName());
        this.assertEquals(1, model.getItem(0).getAge());
        this.assertEquals(2, model.getItem(1).getAge());
        this.assertEquals(3, model.getItem(2).getAge());

        for (var i = 0; i < model.length; i++) {
          model.getItem(i).dispose();
        }

        model.dispose();
        list.dispose();
        listController.dispose();
        form.dispose();
        formController.dispose();
        tf.dispose();
        sp.dispose();
      },
      testDispose: function testDispose() {
        // just create the controller
        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0); // destroy the objects

        c.dispose(); // check if the bindings has been removed

        this.__model__P_230_4.setTf1("AFFE");

        this.assertNotEquals("AFFE", this.__tf1__P_230_1.getValue());
      },
      testBindingCreateMissingOne: function testBindingCreateMissingOne() {
        // add an unknown item
        var tf = new qx.ui.form.TextField();

        this.__form__P_230_0.add(tf, "Unknown"); // create the controller


        var c = new qx.data.controller.Form(this.__model__P_230_4, this.__form__P_230_0); // set values in the form

        this.__tf1__P_230_1.setValue("1");

        this.__tf2__P_230_2.setValue("2");

        this.__cb__P_230_3.setValue(true); // check the binding


        this.assertEquals(this.__tf1__P_230_1.getValue(), this.__model__P_230_4.getTf1());
        this.assertEquals(this.__tf2__P_230_2.getValue(), this.__model__P_230_4.getTf2());
        this.assertEquals(this.__cb__P_230_3.getValue(), this.__model__P_230_4.getCb()); // destroy the objects

        tf.destroy();
        c.dispose();
      }
    }
  });
  qx.test.data.controller.Form.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.validation.Manager": {},
      "qx.ui.form.Resetter": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The form object is responsible for managing form items. For that, it takes
   * advantage of two existing qooxdoo classes.
   * The {@link qx.ui.form.Resetter} is used for resetting and the
   * {@link qx.ui.form.validation.Manager} is used for all validation purposes.
   *
   * The view code can be found in the used renderer ({@link qx.ui.form.renderer}).
   */
  qx.Class.define("qx.ui.form.Form", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__groups__P_413_0 = [];
      this._buttons = [];
      this._buttonOptions = [];
      this._validationManager = this._createValidationManager();
      this._resetter = this._createResetter();
    },
    events: {
      /** Fired as soon as something changes in the form.*/
      "change": "qx.event.type.Event"
    },
    members: {
      __groups__P_413_0: null,
      _validationManager: null,
      _groupCounter: 0,
      _buttons: null,
      _buttonOptions: null,
      _resetter: null,

      /*
      ---------------------------------------------------------------------------
         ADD
      ---------------------------------------------------------------------------
      */

      /**
       * Adds a form item to the form including its internal
       * {@link qx.ui.form.validation.Manager} and {@link qx.ui.form.Resetter}.
       *
       * *Hint:* The order of all add calls represent the order in the layout.
       *
       * @param item {qx.ui.form.IForm} A supported form item.
       * @param label {String} The string, which should be used as label.
       * @param validator {Function | qx.ui.form.validation.AsyncValidator ? null}
       *   The validator which is used by the validation
       *   {@link qx.ui.form.validation.Manager}.
       * @param name {String?null} The name which is used by the data binding
       *   controller {@link qx.data.controller.Form}.
       * @param validatorContext {var?null} The context of the validator.
       * @param options {Map?null} An additional map containing custom data which
       *   will be available in your form renderer specific to the added item.
       */
      add: function add(item, label, validator, name, validatorContext, options) {
        if (this.__isFirstAdd__P_413_1()) {
          this.__groups__P_413_0.push({
            title: null,
            items: [],
            labels: [],
            names: [],
            options: [],
            headerOptions: {}
          });
        } // save the given arguments


        this.__groups__P_413_0[this._groupCounter].items.push(item);

        this.__groups__P_413_0[this._groupCounter].labels.push(label);

        this.__groups__P_413_0[this._groupCounter].options.push(options); // if no name is given, use the label without not working character


        if (name == null) {
          name = label.replace(/\s+|&|-|\+|\*|\/|\||!|\.|,|:|\?|;|~|%|\{|\}|\(|\)|\[|\]|<|>|=|\^|@|\\/g, "");
        }

        this.__groups__P_413_0[this._groupCounter].names.push(name); // add the item to the validation manager


        this._validationManager.add(item, validator, validatorContext); // add the item to the reset manager


        this._resetter.add(item); // fire the change event


        this.fireEvent("change");
      },

      /**
       * Adds a group header to the form.
       *
       * *Hint:* The order of all add calls represent the order in the layout.
       *
       * @param title {String} The title of the group header.
       * @param options {Map?null} A special set of custom data which will be
       *   given to the renderer.
       */
      addGroupHeader: function addGroupHeader(title, options) {
        if (!this.__isFirstAdd__P_413_1()) {
          this._groupCounter++;
        }

        this.__groups__P_413_0.push({
          title: title,
          items: [],
          labels: [],
          names: [],
          options: [],
          headerOptions: options
        }); // fire the change event


        this.fireEvent("change");
      },

      /**
       * Adds a button to the form.
       *
       * *Hint:* The order of all add calls represent the order in the layout.
       *
       * @param button {qx.ui.form.Button} The button to add.
       * @param options {Map?null} An additional map containing custom data which
       *   will be available in your form renderer specific to the added button.
       */
      addButton: function addButton(button, options) {
        this._buttons.push(button);

        this._buttonOptions.push(options || null); // fire the change event


        this.fireEvent("change");
      },

      /**
       * Returns whether something has already been added.
       *
       * @return {Boolean} true, if nothing has been added jet.
       */
      __isFirstAdd__P_413_1: function __isFirstAdd__P_413_1() {
        return this.__groups__P_413_0.length === 0;
      },

      /*
      ---------------------------------------------------------------------------
         REMOVE
      ---------------------------------------------------------------------------
      */

      /**
       * Removes the given item from the form.
       *
       * @param item {qx.ui.form.IForm} A supported form item.
       * @return {Boolean} <code>true</code>, if the item could be removed.
       */
      remove: function remove(item) {
        for (var i = 0; i < this.__groups__P_413_0.length; i++) {
          var group = this.__groups__P_413_0[i];

          for (var j = 0; j < group.items.length; j++) {
            var storedItem = group.items[j];

            if (storedItem === item) {
              // remove all stored data
              group.items.splice(j, 1);
              group.labels.splice(j, 1);
              group.names.splice(j, 1);
              group.options.splice(j, 1); // remove the item to the validation manager

              this._validationManager.remove(item); // remove the item to the reset manager


              this._resetter.remove(item); // fire the change event


              this.fireEvent("change");
              return true;
            }
          }
        }

        return false;
      },

      /**
       * Removes the given group header from the form. All items in the group will be moved to
       * another group (usually the previous group). If there is more than one group with
       * the same title, only the first group will be removed.
       *
       * @param title {String} The title.
       * @return {Boolean} <code>true</code>, if the header could be removed.
       */
      removeGroupHeader: function removeGroupHeader(title) {
        for (var i = 0; i < this.__groups__P_413_0.length; i++) {
          var group = this.__groups__P_413_0[i];

          if (group.title === title) {
            var targetGroup; // if it's the first group

            if (i == 0) {
              // if it's the only group
              if (this.__groups__P_413_0.length == 1) {
                // remove the title and the header options
                group.title = null;
                group.headerOptions = {}; // fire the change event

                this.fireEvent("change");
                return true;
              } else {
                // add to the next
                targetGroup = this.__groups__P_413_0[i + 1];
              }
            } else {
              // add to the previous group
              targetGroup = this.__groups__P_413_0[i - 1];
            } // copy the data over


            targetGroup.items = targetGroup.items.concat(group.items);
            targetGroup.labels = targetGroup.labels.concat(group.labels);
            targetGroup.names = targetGroup.names.concat(group.names);
            targetGroup.options = targetGroup.options.concat(group.options); // delete the group

            this.__groups__P_413_0.splice(i, 1);

            this._groupCounter--; // fire the change event

            this.fireEvent("change");
            return true;
          }
        }

        return false;
      },

      /**
       * Removes the given button from the form.
       *
       * @param button {qx.ui.form.Button} The button to remove.
       * @return {Boolean} <code>true</code>, if the button could be removed.
       */
      removeButton: function removeButton(button) {
        for (var i = 0; i < this._buttons.length; i++) {
          var storedButton = this._buttons[i];

          if (storedButton === button) {
            this._buttons.splice(i, 1);

            this._buttonOptions.splice(i, 1); // fire the change event


            this.fireEvent("change");
            return true;
          }
        }

        return false;
      },

      /**
       * Returns all added items as a map.
       *
       * @return {Map} A map containing for every item an entry with its name.
       */
      getItems: function getItems() {
        var items = {}; // go threw all groups

        for (var i = 0; i < this.__groups__P_413_0.length; i++) {
          var group = this.__groups__P_413_0[i]; // get all items

          for (var j = 0; j < group.names.length; j++) {
            var name = group.names[j];
            items[name] = group.items[j];
          }
        }

        return items;
      },

      /**
       * Return an item by name.
       *
       * @param name {string} Item name.
       * @return {qx.ui.form.IForm|null} The form item or null.
       */
      getItem: function getItem(name) {
        for (var i = 0; i < this.__groups__P_413_0.length; i++) {
          var group = this.__groups__P_413_0[i];

          for (var j = 0; j < group.names.length; j++) {
            if (group.names[j] === name) {
              return group.items[j];
            }
          }
        }

        return null;
      },

      /*
      ---------------------------------------------------------------------------
         RESET SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Resets the form. This means reseting all form items and the validation.
       */
      reset: function reset() {
        this._resetter.reset();

        this._validationManager.reset();
      },

      /**
       * Redefines the values used for resetting. It calls
       * {@link qx.ui.form.Resetter#redefine} to get that.
       */
      redefineResetter: function redefineResetter() {
        this._resetter.redefine();
      },

      /**
       * Redefines the value used for resetting of the given item. It calls
       * {@link qx.ui.form.Resetter#redefineItem} to get that.
       *
       * @param item {qx.ui.core.Widget} The item to redefine.
       */
      redefineResetterItem: function redefineResetterItem(item) {
        this._resetter.redefineItem(item);
      },

      /*
      ---------------------------------------------------------------------------
         VALIDATION
      ---------------------------------------------------------------------------
      */

      /**
       * Validates the form using the
       * {@link qx.ui.form.validation.Manager#validate} method.
       *
       * @return {Boolean | null} The validation result.
       */
      validate: function validate() {
        return this._validationManager.validate();
      },

      /**
       * Returns the internally used validation manager. If you want to do some
       * enhanced validation tasks, you need to use the validation manager.
       *
       * @return {qx.ui.form.validation.Manager} The used manager.
       */
      getValidationManager: function getValidationManager() {
        return this._validationManager;
      },

      /*
      ---------------------------------------------------------------------------
         RENDERER SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Accessor method for the renderer which returns all added items in a
       * array containing a map of all items:
       * {title: title, items: [], labels: [], names: []}
       *
       * @return {Array} An array containing all necessary data for the renderer.
       * @internal
       */
      getGroups: function getGroups() {
        return this.__groups__P_413_0;
      },

      /**
       * Accessor method for the renderer which returns all added buttons in an
       * array.
       * @return {Array} An array containing all added buttons.
       * @internal
       */
      getButtons: function getButtons() {
        return this._buttons;
      },

      /**
       * Accessor method for the renderer which returns all added options for
       * the buttons in an array.
       * @return {Array} An array containing all added options for the buttons.
       * @internal
       */
      getButtonOptions: function getButtonOptions() {
        return this._buttonOptions;
      },

      /*
      ---------------------------------------------------------------------------
         INTERNAL
      ---------------------------------------------------------------------------
      */

      /**
       * Creates and returns the used validation manager.
       *
       * @return {qx.ui.form.validation.Manager} The validation manager.
       */
      _createValidationManager: function _createValidationManager() {
        return new qx.ui.form.validation.Manager();
      },

      /**
       * Creates and returns the used resetter.
       *
       * @return {qx.ui.form.Resetter} the resetter class.
       */
      _createResetter: function _createResetter() {
        return new qx.ui.form.Resetter();
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      // holding references to widgets --> must set to null
      this.__groups__P_413_0 = this._buttons = this._buttonOptions = null;

      this._validationManager.dispose();

      this._resetter.dispose();
    }
  });
  qx.ui.form.Form.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which have boolean as their primary
   * data type like a checkbox.
   */
  qx.Interface.define("qx.ui.form.IBooleanForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {Boolean|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {Boolean|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.IBooleanForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.RadioGroup": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Each object, which should be managed by a {@link RadioGroup} have to
   * implement this interface.
   */
  qx.Interface.define("qx.ui.form.IRadioItem", {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the item was checked or unchecked */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Set whether the item is checked
       *
       * @param value {Boolean} whether the item should be checked
       */
      setValue: function setValue(value) {},

      /**
       * Get whether the item is checked
       *
       * @return {Boolean} whether the item it checked
       */
      getValue: function getValue() {},

      /**
       * Set the radiogroup, which manages this item
       *
       * @param value {qx.ui.form.RadioGroup} The radiogroup, which should
       *     manage the item.
       */
      setGroup: function setGroup(value) {
        this.assertInstance(value, qx.ui.form.RadioGroup);
      },

      /**
       * Get the radiogroup, which manages this item
       *
       * @return {qx.ui.form.RadioGroup} The radiogroup, which manages the item.
       */
      getGroup: function getGroup() {}
    }
  });
  qx.ui.form.IRadioItem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.basic.Atom": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * A toggle Button widget
   *
   * If the user presses the button by tapping on it pressing the enter or
   * space key, the button toggles between the pressed an not pressed states.
   */
  qx.Class.define("qx.ui.form.ToggleButton", {
    extend: qx.ui.basic.Atom,
    include: [qx.ui.core.MExecutable],
    implement: [qx.ui.form.IBooleanForm, qx.ui.form.IExecutable, qx.ui.form.IRadioItem],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Creates a ToggleButton.
     *
     * @param label {String} The text on the button.
     * @param icon {String} An URI to the icon of the button.
     */
    construct: function construct(label, icon) {
      qx.ui.basic.Atom.constructor.call(this, label, icon); // register pointer events

      this.addListener("pointerover", this._onPointerOver);
      this.addListener("pointerout", this._onPointerOut);
      this.addListener("pointerdown", this._onPointerDown);
      this.addListener("pointerup", this._onPointerUp); // register keyboard events

      this.addListener("keydown", this._onKeyDown);
      this.addListener("keyup", this._onKeyUp); // register execute event

      this.addListener("execute", this._onExecute, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "toggle-button"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /** The value of the widget. True, if the widget is checked. */
      value: {
        check: "Boolean",
        nullable: true,
        event: "changeValue",
        apply: "_applyValue",
        init: false
      },

      /** The assigned qx.ui.form.RadioGroup which handles the switching between registered buttons. */
      group: {
        check: "qx.ui.form.RadioGroup",
        nullable: true,
        apply: "_applyGroup"
      },

      /**
      * Whether the button has a third state. Use this for tri-state checkboxes.
      *
      * When enabled, the value null of the property value stands for "undetermined",
      * while true is mapped to "enabled" and false to "disabled" as usual. Note
      * that the value property is set to false initially.
      *
      */
      triState: {
        check: "Boolean",
        apply: "_applyTriState",
        nullable: true,
        init: null
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** The assigned {@link qx.ui.form.RadioGroup} which handles the switching between registered buttons */
      _applyGroup: function _applyGroup(value, old) {
        if (old) {
          old.remove(this);
        }

        if (value) {
          value.add(this);
        }
      },

      /**
       * Changes the state of the button dependent on the checked value.
       *
       * @param value {Boolean} Current value
       * @param old {Boolean} Previous value
       */
      _applyValue: function _applyValue(value, old) {
        value ? this.addState("checked") : this.removeState("checked");

        if (this.isTriState()) {
          if (value === null) {
            this.addState("undetermined");
          } else if (old === null) {
            this.removeState("undetermined");
          }
        }
      },

      /**
      * Apply value property when triState property is modified.
      *
      * @param value {Boolean} Current value
      * @param old {Boolean} Previous value
      */
      _applyTriState: function _applyTriState(value, old) {
        this._applyValue(this.getValue());
      },

      /**
       * Handler for the execute event.
       *
       * @param e {qx.event.type.Event} The execute event.
       */
      _onExecute: function _onExecute(e) {
        this.toggleValue();
      },

      /**
       * Listener method for "pointerover" event.
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onPointerOver: function _onPointerOver(e) {
        if (e.getTarget() !== this) {
          return;
        }

        this.addState("hovered");

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
          this.addState("pressed");
        }
      },

      /**
       * Listener method for "pointerout" event.
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" state (if "pressed" state is set)</li>
       * <li>Removes "pressed" state (if "pressed" state is set and button is not checked)
       * </ul>
       *
       * @param e {qx.event.type.Pointer} pointer event
       */
      _onPointerOut: function _onPointerOut(e) {
        if (e.getTarget() !== this) {
          return;
        }

        this.removeState("hovered");

        if (this.hasState("pressed")) {
          if (!this.getValue()) {
            this.removeState("pressed");
          }

          this.addState("abandoned");
        }
      },

      /**
       * Listener method for "pointerdown" event.
       * <ul>
       * <li>Activates capturing</li>
       * <li>Removes "abandoned" state</li>
       * <li>Adds "pressed" state</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} pointer event
       */
      _onPointerDown: function _onPointerDown(e) {
        if (!e.isLeftPressed()) {
          return;
        } // Activate capturing if the button get a pointerout while
        // the button is pressed.


        this.capture();
        this.removeState("abandoned");
        this.addState("pressed");
        e.stopPropagation();
      },

      /**
       * Listener method for "pointerup" event.
       * <ul>
       * <li>Releases capturing</li>
       * <li>Removes "pressed" state (if not "abandoned" state is set and "pressed" state is set)</li>
       * <li>Removes "abandoned" state (if set)</li>
       * <li>Toggles {@link #value} (if state "abandoned" is not set and state "pressed" is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} pointer event
       */
      _onPointerUp: function _onPointerUp(e) {
        this.releaseCapture();

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
        } else if (this.hasState("pressed")) {
          this.execute();
        }

        this.removeState("pressed");
        e.stopPropagation();
      },

      /**
       * Listener method for "keydown" event.<br/>
       * Removes "abandoned" and adds "pressed" state
       * for the keys "Enter" or "Space"
       *
       * @param e {Event} Key event
       */
      _onKeyDown: function _onKeyDown(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            this.removeState("abandoned");
            this.addState("pressed");
            e.stopPropagation();
        }
      },

      /**
       * Listener method for "keyup" event.<br/>
       * Removes "abandoned" and "pressed" state (if "pressed" state is set)
       * for the keys "Enter" or "Space". It also toggles the {@link #value} property.
       *
       * @param e {Event} Key event
       */
      _onKeyUp: function _onKeyUp(e) {
        if (!this.hasState("pressed")) {
          return;
        }

        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            this.removeState("abandoned");
            this.execute();
            this.removeState("pressed");
            e.stopPropagation();
        }
      }
    }
  });
  qx.ui.form.ToggleButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.ToggleButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A check box widget with an optional label.
   */
  qx.Class.define("qx.ui.form.CheckBox", {
    extend: qx.ui.form.ToggleButton,
    include: [qx.ui.form.MForm, qx.ui.form.MModelProperty],
    implement: [qx.ui.form.IForm, qx.ui.form.IModel],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String?null} An optional label for the check box.
     */
    construct: function construct(label) {
      {
        this.assertArgumentsCount(arguments, 0, 1);
      }
      qx.ui.form.ToggleButton.constructor.call(this, label); // Initialize the checkbox to a valid value (the default is null which
      // is invalid)

      this.setValue(false);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "checkbox"
      },
      // overridden
      allowGrowX: {
        refine: true,
        init: false
      }
    },
    members: {
      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        invalid: true,
        focused: true,
        undetermined: true,
        checked: true,
        hovered: true
      },

      /**
       * overridden (from MExecutable to keep the icon out of the binding)
       * @lint ignoreReferenceField(_bindableProperties)
       */
      _bindableProperties: ["enabled", "label", "toolTipText", "value", "menu"]
    }
  });
  qx.ui.form.CheckBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This mixin redirects all children handling methods to a child widget of the
   * including class. This is e.g. used in {@link qx.ui.window.Window} to add
   * child widgets directly to the window pane.
   *
   * The including class must implement the method <code>getChildrenContainer</code>,
   * which has to return the widget, to which the child widgets should be added.
   */
  qx.Mixin.define("qx.ui.core.MRemoteChildrenHandling", {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Forward the call with the given function name to the children container
       *
       * @param functionName {String} name of the method to forward
       * @param a1 {var?} first argument of the method to call
       * @param a2 {var?} second argument of the method to call
       * @param a3 {var?} third argument of the method to call
       * @return {var} The return value of the forward method
       */
      __forward__P_384_0: function __forward__P_384_0(functionName, a1, a2, a3) {
        var container = this.getChildrenContainer();

        if (container === this) {
          functionName = "_" + functionName;
        }

        return container[functionName](a1, a2, a3);
      },

      /**
       * Returns the children list
       *
       * @return {qx.ui.core.LayoutItem[]} The children array (Arrays are
       *   reference types, please do not modify them in-place)
       */
      getChildren: function getChildren() {
        return this.__forward__P_384_0("getChildren");
      },

      /**
       * Whether the widget contains children.
       *
       * @return {Boolean} Returns <code>true</code> when the widget has children.
       */
      hasChildren: function hasChildren() {
        return this.__forward__P_384_0("hasChildren");
      },

      /**
       * Adds a new child widget.
       *
       * The supported keys of the layout options map depend on the layout manager
       * used to position the widget. The options are documented in the class
       * documentation of each layout manager {@link qx.ui.layout}.
       *
       * @param child {qx.ui.core.LayoutItem} the item to add.
       * @param options {Map?null} Optional layout data for item.
       * @return {qx.ui.core.Widget} This object (for chaining support)
       */
      add: function add(child, options) {
        return this.__forward__P_384_0("add", child, options);
      },

      /**
       * Remove the given child item.
       *
       * @param child {qx.ui.core.LayoutItem} the item to remove
       * @return {qx.ui.core.Widget} This object (for chaining support)
       */
      remove: function remove(child) {
        return this.__forward__P_384_0("remove", child);
      },

      /**
       * Remove all children.
       * @return {Array} An array containing the removed children.
       */
      removeAll: function removeAll() {
        return this.__forward__P_384_0("removeAll");
      },

      /**
       * Returns the index position of the given item if it is
       * a child item. Otherwise it returns <code>-1</code>.
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {qx.ui.core.LayoutItem} the item to query for
       * @return {Integer} The index position or <code>-1</code> when
       *   the given item is no child of this layout.
       */
      indexOf: function indexOf(child) {
        return this.__forward__P_384_0("indexOf", child);
      },

      /**
       * Add a child at the specified index
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {qx.ui.core.LayoutItem} item to add
       * @param index {Integer} Index, at which the item will be inserted
       * @param options {Map?null} Optional layout data for item.
       */
      addAt: function addAt(child, index, options) {
        this.__forward__P_384_0("addAt", child, index, options);
      },

      /**
       * Add an item before another already inserted item
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {qx.ui.core.LayoutItem} item to add
       * @param before {qx.ui.core.LayoutItem} item before the new item will be inserted.
       * @param options {Map?null} Optional layout data for item.
       */
      addBefore: function addBefore(child, before, options) {
        this.__forward__P_384_0("addBefore", child, before, options);
      },

      /**
       * Add an item after another already inserted item
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {qx.ui.core.LayoutItem} item to add
       * @param after {qx.ui.core.LayoutItem} item, after which the new item will be inserted
       * @param options {Map?null} Optional layout data for item.
       */
      addAfter: function addAfter(child, after, options) {
        this.__forward__P_384_0("addAfter", child, after, options);
      },

      /**
       * Remove the item at the specified index.
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param index {Integer} Index of the item to remove.
       * @return {qx.ui.core.LayoutItem} The removed item
       */
      removeAt: function removeAt(index) {
        return this.__forward__P_384_0("removeAt", index);
      }
    }
  });
  qx.ui.core.MRemoteChildrenHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.form.List": {},
      "qx.ui.popup.Popup": {},
      "qx.ui.layout.VBox": {},
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Basic class for a selectbox like lists. Basically supports a popup
   * with a list and the whole children management.
   *
   * @childControl list {qx.ui.form.List} list component of the selectbox
   * @childControl popup {qx.ui.popup.Popup} popup which shows the list
   *
   */
  qx.Class.define("qx.ui.form.AbstractSelectBox", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.form.MForm],
    implement: [qx.ui.form.IForm],
    type: "abstract",

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // set the layout

      var layout = new qx.ui.layout.HBox();

      this._setLayout(layout);

      layout.setAlignY("middle"); // Register listeners

      this.addListener("keypress", this._onKeyPress);
      this.addListener("blur", this._onBlur, this); // register the resize listener

      this.addListener("resize", this._onResize, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 120
      },

      /**
       * The maximum height of the list popup. Setting this value to
       * <code>null</code> will set cause the list to be auto-sized.
       */
      maxListHeight: {
        check: "Number",
        apply: "_applyMaxListHeight",
        nullable: true,
        init: 200
      },

      /**
       * Formatter which format the value from the selected <code>ListItem</code>.
       * Uses the default formatter {@link #_defaultFormat}.
       */
      format: {
        check: "Function",
        init: function init(item) {
          return this._defaultFormat(item);
        },
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "list":
            control = new qx.ui.form.List().set({
              focusable: false,
              keepFocus: true,
              height: null,
              width: null,
              maxHeight: this.getMaxListHeight(),
              selectionMode: "one",
              quickSelection: true
            });
            control.addListener("changeSelection", this._onListChangeSelection, this);
            control.addListener("pointerdown", this._onListPointerDown, this);
            control.getChildControl("pane").addListener("tap", this.close, this);
            break;

          case "popup":
            control = new qx.ui.popup.Popup(new qx.ui.layout.VBox());
            control.setAutoHide(false);
            control.setKeepActive(true);
            control.add(this.getChildControl("list"));
            control.addListener("changeVisibility", this._onPopupChangeVisibility, this);
            break;
        }

        return control || qx.ui.form.AbstractSelectBox.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyMaxListHeight: function _applyMaxListHeight(value, old) {
        this.getChildControl("list").setMaxHeight(value);
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the list widget.
       * @return {qx.ui.form.List} the list
       */
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("list");
      },

      /*
      ---------------------------------------------------------------------------
        LIST STUFF
      ---------------------------------------------------------------------------
      */

      /**
       * Shows the list popup.
       */
      open: function open() {
        var popup = this.getChildControl("popup");
        popup.placeToWidget(this, true);
        popup.show();
      },

      /**
       * Hides the list popup.
       */
      close: function close() {
        this.getChildControl("popup").hide();
      },

      /**
       * Toggles the popup's visibility.
       */
      toggle: function toggle() {
        var isListOpen = this.getChildControl("popup").isVisible();

        if (isListOpen) {
          this.close();
        } else {
          this.open();
        }
      },

      /*
      ---------------------------------------------------------------------------
        FORMAT HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Return the formatted label text from the <code>ListItem</code>.
       * The formatter removes all HTML tags and converts all HTML entities
       * to string characters when the rich property is <code>true</code>.
       *
       * @param item {qx.ui.form.ListItem} The list item to format.
       * @return {String} The formatted text.
       */
      _defaultFormat: function _defaultFormat(item) {
        var valueLabel = item ? item.getLabel() : "";
        var rich = item ? item.getRich() : false;

        if (rich) {
          valueLabel = valueLabel.replace(/<[^>]+?>/g, "");
          valueLabel = qx.bom.String.unescape(valueLabel);
        }

        return valueLabel;
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Handler for the blur event of the current widget.
       *
       * @param e {qx.event.type.Focus} The blur event.
       */
      _onBlur: function _onBlur(e) {
        this.close();
      },

      /**
       * Reacts on special keys and forwards other key events to the list widget.
       *
       * @param e {qx.event.type.KeySequence} Keypress event
       */
      _onKeyPress: function _onKeyPress(e) {
        // get the key identifier
        var identifier = e.getKeyIdentifier();
        var listPopup = this.getChildControl("popup"); // disabled pageUp and pageDown keys

        if (listPopup.isHidden() && (identifier == "PageDown" || identifier == "PageUp")) {
          e.stopPropagation();
        } // hide the list always on escape
        else if (!listPopup.isHidden() && identifier == "Escape") {
            this.close();
            e.stop();
          } // forward the rest of the events to the list
          else {
              this.getChildControl("list").handleKeyPress(e);
            }
      },

      /**
       * Updates list minimum size.
       *
       * @param e {qx.event.type.Data} Data event
       */
      _onResize: function _onResize(e) {
        this.getChildControl("popup").setMinWidth(e.getData().width);
      },

      /**
       * Syncs the own property from the list change
       *
       * @param e {qx.event.type.Data} Data Event
       */
      _onListChangeSelection: function _onListChangeSelection(e) {
        throw new Error("Abstract method: _onListChangeSelection()");
      },

      /**
       * Redirects pointerdown event from the list to this widget.
       *
       * @param e {qx.event.type.Pointer} Pointer Event
       */
      _onListPointerDown: function _onListPointerDown(e) {
        throw new Error("Abstract method: _onListPointerDown()");
      },

      /**
       * Redirects changeVisibility event from the list to this widget.
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onPopupChangeVisibility: function _onPopupChangeVisibility(e) {
        e.getData() == "visible" ? this.addState("popupOpen") : this.removeState("popupOpen");
      }
    }
  });
  qx.ui.form.AbstractSelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.ui.core.SingleSelectionManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * This mixin links all methods to manage the single selection.
   *
   * The class which includes the mixin has to implements two methods:
   *
   * <ul>
   * <li><code>_getItems</code>, this method has to return a <code>Array</code>
   *    of <code>qx.ui.core.Widget</code> that should be managed from the manager.
   * </li>
   * <li><code>_isAllowEmptySelection</code>, this method has to return a
   *    <code>Boolean</code> value for allowing empty selection or not.
   * </li>
   * </ul>
   */
  qx.Mixin.define("qx.ui.core.MSingleSelectionHandling", {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data",

      /** Fires after the selection was modified */
      "changeSelection": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.core.SingleSelectionManager} the single selection manager */
      __manager__P_386_0: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * setValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @param item {null|qx.ui.core.Widget} Item to set as selected value.
       * @returns {null|TypeError} The status of this operation.
       */
      setValue: function setValue(item) {
        if (null === item) {
          this.resetSelection();
          return null;
        }

        if (item instanceof qx.ui.core.Widget) {
          this.__getManager__P_386_1().setSelected(item);

          return null;
        } else {
          return new TypeError("Given argument is not null or a {qx.ui.core.Widget}.");
        }
      },

      /**
       * getValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @returns {null|qx.ui.core.Widget} The currently selected widget or null if there is none.
       */
      getValue: function getValue() {
        return this.__getManager__P_386_1().getSelected() || null;
      },

      /**
       * resetValue implements part of the {@link qx.ui.form.IField} interface.
       */
      resetValue: function resetValue() {
        this.__getManager__P_386_1().resetSelected();
      },

      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {qx.ui.core.Widget[]} List of items.
       */
      getSelection: function getSelection() {
        var selected = this.__getManager__P_386_1().getSelected();

        if (selected) {
          return [selected];
        } else {
          return [];
        }
      },

      /**
       * Replaces current selection with the given items.
       *
       * @param items {qx.ui.core.Widget[]} Items to select.
       * @throws {Error} if one of the items is not a child element and if
       *    items contains more than one elements.
       */
      setSelection: function setSelection(items) {
        switch (items.length) {
          case 0:
            this.resetSelection();
            break;

          case 1:
            this.__getManager__P_386_1().setSelected(items[0]);

            break;

          default:
            throw new Error("Could only select one item, but the selection array contains " + items.length + " items!");
        }
      },

      /**
       * Clears the whole selection at once.
       */
      resetSelection: function resetSelection() {
        this.__getManager__P_386_1().resetSelected();
      },

      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {qx.ui.core.Widget} Any valid selectable item.
       * @return {Boolean} Whether the item is selected.
       * @throws {Error} if one of the items is not a child element.
       */
      isSelected: function isSelected(item) {
        return this.__getManager__P_386_1().isSelected(item);
      },

      /**
       * Whether the selection is empty.
       *
       * @return {Boolean} Whether the selection is empty.
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__getManager__P_386_1().isSelectionEmpty();
      },

      /**
       * Returns all elements which are selectable.
       *
       * @param all {Boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       * @return {qx.ui.core.Widget[]} The contained items.
       */
      getSelectables: function getSelectables(all) {
        return this.__getManager__P_386_1().getSelectables(all);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for <code>changeSelected</code> event on single
       * selection manager.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      _onChangeSelected: function _onChangeSelected(e) {
        var newValue = e.getData();
        var oldValue = e.getOldData();
        this.fireDataEvent("changeValue", newValue, oldValue);
        newValue == null ? newValue = [] : newValue = [newValue];
        oldValue == null ? oldValue = [] : oldValue = [oldValue];
        this.fireDataEvent("changeSelection", newValue, oldValue);
      },

      /**
       * Return the selection manager if it is already exists, otherwise creates
       * the manager.
       *
       * @return {qx.ui.core.SingleSelectionManager} Single selection manager.
       */
      __getManager__P_386_1: function __getManager__P_386_1() {
        if (this.__manager__P_386_0 == null) {
          var that = this;
          this.__manager__P_386_0 = new qx.ui.core.SingleSelectionManager({
            getItems: function getItems() {
              return that._getItems();
            },
            isItemSelectable: function isItemSelectable(item) {
              if (that._isItemSelectable) {
                return that._isItemSelectable(item);
              } else {
                return item.isVisible();
              }
            }
          });

          this.__manager__P_386_0.addListener("changeSelected", this._onChangeSelected, this);
        }

        this.__manager__P_386_0.setAllowEmptySelection(this._isAllowEmptySelection());

        return this.__manager__P_386_0;
      }
    },

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__manager__P_386_0");
    }
  });
  qx.ui.core.MSingleSelectionHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This mixin offers the selection of the model properties.
   * It can only be included if the object including it implements the
   * {@link qx.ui.core.ISingleSelection} interface and the selectables implement
   * the {@link qx.ui.form.IModel} interface.
   */
  qx.Mixin.define("qx.ui.form.MModelSelection", {
    construct: function construct() {
      // create the selection array
      this.__modelSelection__P_417_0 = new qx.data.Array(); // listen to the changes

      this.__modelSelection__P_417_0.addListener("change", this.__onModelSelectionArrayChange__P_417_1, this);

      this.addListener("changeSelection", this.__onModelSelectionChange__P_417_2, this);
    },
    events: {
      /**
       * Pseudo event. It will never be fired because the array itself can not
       * be changed. But the event description is needed for the data binding.
       */
      changeModelSelection: "qx.event.type.Data"
    },
    members: {
      __modelSelection__P_417_0: null,
      __inSelectionChange__P_417_3: false,

      /**
       * Handler for the selection change of the including class e.g. SelectBox,
       * List, ...
       * It sets the new modelSelection via {@link #setModelSelection}.
       */
      __onModelSelectionChange__P_417_2: function __onModelSelectionChange__P_417_2() {
        if (this.__inSelectionChange__P_417_3) {
          return;
        }

        var data = this.getSelection(); // create the array with the modes inside

        var modelSelection = [];

        for (var i = 0; i < data.length; i++) {
          var item = data[i]; // fallback if getModel is not implemented

          var model = item.getModel ? item.getModel() : null;

          if (model !== null) {
            modelSelection.push(model);
          }
        }

        try {
          this.setModelSelection(modelSelection);
        } catch (e) {
          throw new Error("Could not set the model selection. Maybe your models are not unique? " + e);
        }
      },

      /**
       * Listener for the change of the internal model selection data array.
       */
      __onModelSelectionArrayChange__P_417_1: function __onModelSelectionArrayChange__P_417_1() {
        this.__inSelectionChange__P_417_3 = true;
        var selectables = this.getSelectables(true);
        var itemSelection = [];

        var modelSelection = this.__modelSelection__P_417_0.toArray();

        for (var i = 0; i < modelSelection.length; i++) {
          var model = modelSelection[i];

          for (var j = 0; j < selectables.length; j++) {
            var selectable = selectables[j]; // fallback if getModel is not implemented

            var selectableModel = selectable.getModel ? selectable.getModel() : null;

            if (model === selectableModel) {
              itemSelection.push(selectable);
              break;
            }
          }
        }

        this.setSelection(itemSelection);
        this.__inSelectionChange__P_417_3 = false; // check if the setting has worked

        var currentSelection = this.getSelection();

        if (!qx.lang.Array.equals(currentSelection, itemSelection)) {
          // if not, set the actual selection
          this.__onModelSelectionChange__P_417_2();
        }
      },

      /**
       * Returns always an array of the models of the selected items. If no
       * item is selected or no model is given, the array will be empty.
       *
       * *CAREFUL!* The model selection can only work if every item item in the
       * selection providing widget has a model property!
       *
       * @return {qx.data.Array} An array of the models of the selected items.
       */
      getModelSelection: function getModelSelection() {
        return this.__modelSelection__P_417_0;
      },

      /**
       * Takes the given models in the array and searches for the corresponding
       * selectables. If an selectable does have that model attached, it will be
       * selected.
       *
       * *Attention:* This method can have a time complexity of O(n^2)!
       *
       * *CAREFUL!* The model selection can only work if every item item in the
       * selection providing widget has a model property!
       *
       * @param modelSelection {Array} An array of models, which should be
       *   selected.
       */
      setModelSelection: function setModelSelection(modelSelection) {
        // check for null values
        if (!modelSelection) {
          this.__modelSelection__P_417_0.removeAll();

          return;
        }

        {
          this.assertArray(modelSelection, "Please use an array as parameter.");
        } // add the first two parameter

        modelSelection.unshift(this.__modelSelection__P_417_0.getLength()); // remove index

        modelSelection.unshift(0); // start index

        var returnArray = this.__modelSelection__P_417_0.splice.apply(this.__modelSelection__P_417_0, modelSelection);

        returnArray.dispose();
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__modelSelection__P_417_0");
    }
  });
  qx.ui.form.MModelSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.AbstractSelectBox": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.ISingleSelection": {
        "require": true
      },
      "qx.ui.form.IModelSelection": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.core.MSingleSelectionHandling": {
        "require": true
      },
      "qx.ui.form.MModelSelection": {
        "require": true
      },
      "qx.ui.core.Spacer": {},
      "qx.ui.basic.Atom": {},
      "qx.ui.basic.Image": {},
      "qx.bom.Viewport": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A form widget which allows a single selection. Looks somewhat like
   * a normal button, but opens a list of items to select when tapping on it.
   *
   * Keep in mind that the SelectBox widget has always a selected item (due to the
   * single selection mode). Right after adding the first item a <code>changeSelection</code>
   * event is fired.
   *
   * <pre class='javascript'>
   * var selectBox = new qx.ui.form.SelectBox();
   *
   * selectBox.addListener("changeSelection", function(e) {
   *   // ...
   * });
   *
   * // now the 'changeSelection' event is fired
   * selectBox.add(new qx.ui.form.ListItem("Item 1"));
   * </pre>
   *
   * @childControl spacer {qx.ui.core.Spacer} flexible spacer widget
   * @childControl atom {qx.ui.basic.Atom} shows the text and icon of the content
   * @childControl arrow {qx.ui.basic.Image} shows the arrow to open the popup
   */
  qx.Class.define("qx.ui.form.SelectBox", {
    extend: qx.ui.form.AbstractSelectBox,
    implement: [qx.ui.core.ISingleSelection, qx.ui.form.IModelSelection, qx.ui.form.IField],
    include: [qx.ui.core.MSingleSelectionHandling, qx.ui.form.MModelSelection],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.form.AbstractSelectBox.constructor.call(this);

      this._createChildControl("atom");

      this._createChildControl("spacer");

      this._createChildControl("arrow"); // Register listener


      this.addListener("pointerover", this._onPointerOver, this);
      this.addListener("pointerout", this._onPointerOut, this);
      this.addListener("tap", this._onTap, this);
      this.addListener("keyinput", this._onKeyInput, this);
      this.addListener("changeSelection", this.__onChangeSelection__P_422_0, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "selectbox"
      },
      rich: {
        init: false,
        check: "Boolean",
        apply: "_applyRich"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.form.ListItem} instance */
      __preSelectedItem__P_422_1: null,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      _applyRich: function _applyRich(value, oldValue) {
        this.getChildControl("atom").setRich(value);
      },
      // overridden
      _defaultFormat: function _defaultFormat(item) {
        if (item) {
          if (typeof item.isRich == "function" && item.isRich()) {
            this.setRich(true);
          }

          return item.getLabel();
        }

        return null;
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "spacer":
            control = new qx.ui.core.Spacer();

            this._add(control, {
              flex: 1
            });

            break;

          case "atom":
            control = new qx.ui.basic.Atom(" ");
            control.setCenter(false);
            control.setAnonymous(true);

            this._add(control, {
              flex: 1
            });

            break;

          case "arrow":
            control = new qx.ui.basic.Image();
            control.setAnonymous(true);

            this._add(control);

            break;
        }

        return control || qx.ui.form.SelectBox.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS FOR SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the list items for the selection.
       *
       * @return {qx.ui.form.ListItem[]} List items to select.
       */
      _getItems: function _getItems() {
        return this.getChildrenContainer().getChildren();
      },

      /**
       * Returns if the selection could be empty or not.
       *
       * @return {Boolean} <code>true</code> If selection could be empty,
       *    <code>false</code> otherwise.
       */
      _isAllowEmptySelection: function _isAllowEmptySelection() {
        return this.getChildrenContainer().getSelectionMode() !== "one";
      },

      /**
       * Event handler for <code>changeSelection</code>.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      __onChangeSelection__P_422_0: function __onChangeSelection__P_422_0(e) {
        var listItem = e.getData()[0];
        var list = this.getChildControl("list");

        if (list.getSelection()[0] != listItem) {
          if (listItem) {
            list.setSelection([listItem]);
          } else {
            list.resetSelection();
          }
        }

        this.__updateIcon__P_422_2();

        this.__updateLabel__P_422_3();
      },

      /**
       * Sets the icon inside the list to match the selected ListItem.
       */
      __updateIcon__P_422_2: function __updateIcon__P_422_2() {
        var listItem = this.getChildControl("list").getSelection()[0];
        var atom = this.getChildControl("atom");
        var icon = listItem ? listItem.getIcon() : "";
        icon == null ? atom.resetIcon() : atom.setIcon(icon);
      },

      /**
       * Sets the label inside the list to match the selected ListItem.
       */
      __updateLabel__P_422_3: function __updateLabel__P_422_3() {
        var listItem = this.getChildControl("list").getSelection()[0];
        var atom = this.getChildControl("atom");
        var label = listItem ? listItem.getLabel() : "";
        var format = this.getFormat();

        if (format != null && listItem) {
          label = format.call(this, listItem);
        } // check for translation


        if (label && label.translate) {
          label = label.translate();
        }

        label == null ? atom.resetLabel() : atom.setLabel(label);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Listener method for "pointerover" event
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onPointerOver: function _onPointerOver(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
          this.addState("pressed");
        }

        this.addState("hovered");
      },

      /**
       * Listener method for "pointerout" event
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" and removes "pressed" state (if "pressed" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onPointerOut: function _onPointerOut(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        this.removeState("hovered");

        if (this.hasState("pressed")) {
          this.removeState("pressed");
          this.addState("abandoned");
        }
      },

      /**
       * Toggles the popup's visibility.
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onTap: function _onTap(e) {
        this.toggle();
      },
      // overridden
      _onKeyPress: function _onKeyPress(e) {
        var iden = e.getKeyIdentifier();

        if (iden == "Enter" || iden == "Space") {
          // Apply pre-selected item (translate quick selection to real selection)
          if (this.__preSelectedItem__P_422_1) {
            this.setSelection([this.__preSelectedItem__P_422_1]);
            this.__preSelectedItem__P_422_1 = null;
          }

          this.toggle();
        } else {
          qx.ui.form.SelectBox.prototype._onKeyPress.base.call(this, e);
        }
      },

      /**
       * Forwards key event to list widget.
       *
       * @param e {qx.event.type.KeyInput} Key event
       */
      _onKeyInput: function _onKeyInput(e) {
        // clone the event and re-calibrate the event
        var clone = e.clone();
        clone.setTarget(this._list);
        clone.setBubbles(false); // forward it to the list

        this.getChildControl("list").dispatchEvent(clone);
      },
      // overridden
      _onListPointerDown: function _onListPointerDown(e) {
        // Apply pre-selected item (translate quick selection to real selection)
        if (this.__preSelectedItem__P_422_1) {
          this.setSelection([this.__preSelectedItem__P_422_1]);
          this.__preSelectedItem__P_422_1 = null;
        }
      },
      // overridden
      _onListChangeSelection: function _onListChangeSelection(e) {
        var current = e.getData();
        var old = e.getOldData(); // Remove old listeners for icon and label changes.

        if (old && old.length > 0) {
          old[0].removeListener("changeIcon", this.__updateIcon__P_422_2, this);
          old[0].removeListener("changeLabel", this.__updateLabel__P_422_3, this);
        }

        if (current.length > 0) {
          // Ignore quick context (e.g. pointerover)
          // and configure the new value when closing the popup afterwards
          var popup = this.getChildControl("popup");
          var list = this.getChildControl("list");
          var context = list.getSelectionContext();

          if (popup.isVisible() && (context == "quick" || context == "key")) {
            this.__preSelectedItem__P_422_1 = current[0];
          } else {
            this.setSelection([current[0]]);
            this.__preSelectedItem__P_422_1 = null;
          } // Add listeners for icon and label changes


          current[0].addListener("changeIcon", this.__updateIcon__P_422_2, this);
          current[0].addListener("changeLabel", this.__updateLabel__P_422_3, this);
        } else {
          this.resetSelection();
        }
      },
      // overridden
      _onPopupChangeVisibility: function _onPopupChangeVisibility(e) {
        qx.ui.form.SelectBox.prototype._onPopupChangeVisibility.base.call(this, e); // Synchronize the current selection to the list selection
        // when the popup is closed. The list selection may be invalid
        // because of the quick selection handling which is not
        // directly applied to the selectbox


        var popup = this.getChildControl("popup");

        if (!popup.isVisible()) {
          var list = this.getChildControl("list"); // check if the list has any children before selecting

          if (list.hasChildren()) {
            list.setSelection(this.getSelection());
          }
        } else {
          // ensure that the list is never bigger that the max list height and
          // the available space in the viewport
          var distance = popup.getLayoutLocation(this);
          var viewPortHeight = qx.bom.Viewport.getHeight(); // distance to the bottom and top borders of the viewport

          var toTop = distance.top;
          var toBottom = viewPortHeight - distance.bottom;
          var availableHeigth = toTop > toBottom ? toTop : toBottom;
          var maxListHeight = this.getMaxListHeight();
          var list = this.getChildControl("list");

          if (maxListHeight == null || maxListHeight > availableHeigth) {
            list.setMaxHeight(availableHeigth);
          } else if (maxListHeight < availableHeigth) {
            list.setMaxHeight(maxListHeight);
          }
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__preSelectedItem__P_422_1 = null;
    }
  });
  qx.ui.form.SelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Mixin holding the handler for roll event. Please
   * keep in mind that the including widget has to have the scroll bars
   * implemented as child controls named <code>scrollbar-x</code> and
   * <code>scrollbar-y</code> to get the handler working. Also, you have to
   * attach the listener yourself.
   */
  qx.Mixin.define("qx.ui.core.scroll.MRoll", {
    members: {
      _cancelRoll: null,

      /**
       * Responsible for adding the event listener needed for scroll handling.
       */
      _addRollHandling: function _addRollHandling() {
        this.addListener("roll", this._onRoll, this);
        this.addListener("pointerdown", this._onPointerDownForRoll, this);
      },

      /**
       * Responsible for removing the event listener needed for scroll handling.
       */
      _removeRollHandling: function _removeRollHandling() {
        this.removeListener("roll", this._onRoll, this);
        this.removeListener("pointerdown", this._onPointerDownForRoll, this);
      },

      /**
       * Handler for the pointerdown event which simply stops the momentum scrolling.
       *
       * @param e {qx.event.type.Pointer} pointerdown event
       */
      _onPointerDownForRoll: function _onPointerDownForRoll(e) {
        this._cancelRoll = e.getPointerId();
      },

      /**
       * Roll event handler
       *
       * @param e {qx.event.type.Roll} Roll event
       */
      _onRoll: function _onRoll(e) {
        // only wheel and touch
        if (e.getPointerType() == "mouse") {
          return;
        }

        if (this._cancelRoll && e.getMomentum()) {
          e.stopMomentum();
          this._cancelRoll = null;
          return;
        }

        this._cancelRoll = null;

        var showX = this._isChildControlVisible("scrollbar-x");

        var showY = this._isChildControlVisible("scrollbar-y");

        var scrollbarY = showY ? this.getChildControl("scrollbar-y", true) : null;
        var scrollbarX = showX ? this.getChildControl("scrollbar-x", true) : null;
        var deltaY = e.getDelta().y;
        var deltaX = e.getDelta().x;
        var endY = !showY;
        var endX = !showX; // y case

        if (scrollbarY) {
          if (deltaY !== 0) {
            scrollbarY.scrollBy(parseInt(deltaY, 10));
          }

          var position = scrollbarY.getPosition();
          var max = scrollbarY.getMaximum(); // pass the event to the parent if the scrollbar is at an edge

          if (deltaY < 0 && position <= 0 || deltaY > 0 && position >= max) {
            endY = true;
          }
        } // x case


        if (scrollbarX) {
          if (deltaX !== 0) {
            scrollbarX.scrollBy(parseInt(deltaX, 10));
          }

          var position = scrollbarX.getPosition();
          var max = scrollbarX.getMaximum(); // pass the event to the parent if the scrollbar is at an edge

          if (deltaX < 0 && position <= 0 || deltaX > 0 && position >= max) {
            endX = true;
          }
        }

        if (endX && endY) {
          e.stopMomentum();
        } // pass the event to the parent if both scrollbars are at the end


        if (!endY && deltaX === 0 || !endX && deltaY === 0 || (!endX || !endY) && deltaX !== 0 && deltaY !== 0) {
          // Stop bubbling and native event only if a scrollbar is visible
          e.stop();
        }
      }
    }
  });
  qx.ui.core.scroll.MRoll.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.DragDropScrolling": {
        "construct": true
      },
      "qx.Class": {},
      "qx.ui.core.scroll.MScrollBarFactory": {},
      "qx.ui.core.Widget": {},
      "qx.event.Timer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /**
   * Provides scrolling ability during drag session to the widget.
   */
  qx.Mixin.define("qx.ui.core.MDragDropScrolling", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      var widget = this;

      if (this instanceof qx.ui.core.DragDropScrolling) {
        widget = this._getWidget();
      }

      widget.addListener("drag", this.__onDrag__P_379_0, this);
      widget.addListener("dragend", this.__onDragend__P_379_1, this);
      this.__xDirs__P_379_2 = ["left", "right"];
      this.__yDirs__P_379_3 = ["top", "bottom"];
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The threshold for the x-axis (in pixel) to activate scrolling at the edges. */
      dragScrollThresholdX: {
        check: "Integer",
        init: 30
      },

      /** The threshold for the y-axis (in pixel) to activate scrolling at the edges. */
      dragScrollThresholdY: {
        check: "Integer",
        init: 30
      },

      /** The factor for slowing down the scrolling. */
      dragScrollSlowDownFactor: {
        check: "Float",
        init: 0.1
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __dragScrollTimer__P_379_4: null,
      __xDirs__P_379_2: null,
      __yDirs__P_379_3: null,

      /**
       * Finds the first scrollable parent (in the parent chain).
       *
       * @param widget {qx.ui.core.LayoutItem} The widget to start from.
       * @return {qx.ui.core.Widget} A scrollable widget.
       */
      _findScrollableParent: function _findScrollableParent(widget) {
        var cur = widget;

        if (cur === null) {
          return null;
        }

        while (cur.getLayoutParent()) {
          cur = cur.getLayoutParent();

          if (this._isScrollable(cur)) {
            return cur;
          }
        }

        return null;
      },

      /**
       * Whether the widget is scrollable.
       *
       * @param widget {qx.ui.core.Widget} The widget to check.
       * @return {Boolean} Whether the widget is scrollable.
       */
      _isScrollable: function _isScrollable(widget) {
        return qx.Class.hasMixin(widget.constructor, qx.ui.core.scroll.MScrollBarFactory);
      },

      /**
       * Gets the bounds of the given scrollable.
       *
       * @param scrollable {qx.ui.core.Widget} Scrollable which has scrollbar child controls.
       * @return {Map} A map with all four bounds (e.g. {"left":0, "top":20, "right":0, "bottom":80}).
       */
      _getBounds: function _getBounds(scrollable) {
        var bounds = scrollable.getContentLocation(); // the scrollable may dictate a nested widget for more precise bounds

        if (scrollable.getScrollAreaContainer) {
          bounds = scrollable.getScrollAreaContainer().getContentLocation();
        }

        return bounds;
      },

      /**
       * Gets the edge type or null if the pointer isn't within one of the thresholds.
       *
       * @param diff {Map} Difference map with all for edgeTypes.
       * @param thresholdX {Number} x-axis threshold.
       * @param thresholdY {Number} y-axis threshold.
       * @return {String} One of the four edgeTypes ('left', 'right', 'top', 'bottom').
       */
      _getEdgeType: function _getEdgeType(diff, thresholdX, thresholdY) {
        if (diff.left * -1 <= thresholdX && diff.left < 0) {
          return "left";
        } else if (diff.top * -1 <= thresholdY && diff.top < 0) {
          return "top";
        } else if (diff.right <= thresholdX && diff.right > 0) {
          return "right";
        } else if (diff.bottom <= thresholdY && diff.bottom > 0) {
          return "bottom";
        } else {
          return null;
        }
      },

      /**
       * Gets the axis ('x' or 'y') by the edge type.
       *
       * @param edgeType {String} One of the four edgeTypes ('left', 'right', 'top', 'bottom').
       * @throws {Error} If edgeType is not one of the distinct four ones.
       * @return {String} Returns 'y' or 'x'.
       */
      _getAxis: function _getAxis(edgeType) {
        if (this.__xDirs__P_379_2.indexOf(edgeType) !== -1) {
          return "x";
        } else if (this.__yDirs__P_379_3.indexOf(edgeType) !== -1) {
          return "y";
        } else {
          throw new Error("Invalid edge type given (" + edgeType + "). Must be: 'left', 'right', 'top' or 'bottom'");
        }
      },

      /**
       * Gets the threshold amount by edge type.
       *
       * @param edgeType {String} One of the four edgeTypes ('left', 'right', 'top', 'bottom').
       * @return {Number} The threshold of the x or y axis.
       */
      _getThresholdByEdgeType: function _getThresholdByEdgeType(edgeType) {
        if (this.__xDirs__P_379_2.indexOf(edgeType) !== -1) {
          return this.getDragScrollThresholdX();
        } else if (this.__yDirs__P_379_3.indexOf(edgeType) !== -1) {
          return this.getDragScrollThresholdY();
        }
      },

      /**
       * Whether the scrollbar is visible.
       *
       * @param scrollable {qx.ui.core.Widget} Scrollable which has scrollbar child controls.
       * @param axis {String} Can be 'y' or 'x'.
       * @return {Boolean} Whether the scrollbar is visible.
       */
      _isScrollbarVisible: function _isScrollbarVisible(scrollable, axis) {
        if (scrollable && scrollable._isChildControlVisible) {
          return scrollable._isChildControlVisible("scrollbar-" + axis);
        } else {
          return false;
        }
      },

      /**
       * Whether the scrollbar is exceeding it's maximum position.
       *
       * @param scrollbar {qx.ui.core.scroll.IScrollBar} Scrollbar to check.
       * @param axis {String} Can be 'y' or 'x'.
       * @param amount {Number} Amount to scroll which may be negative.
       * @return {Boolean} Whether the amount will exceed the scrollbar max position.
       */
      _isScrollbarExceedingMaxPos: function _isScrollbarExceedingMaxPos(scrollbar, axis, amount) {
        var newPos = 0;

        if (!scrollbar) {
          return true;
        }

        newPos = scrollbar.getPosition() + amount;
        return newPos > scrollbar.getMaximum() || newPos < 0;
      },

      /**
       * Calculates the threshold exceedance (which may be negative).
       *
       * @param diff {Number} Difference value of one edgeType.
       * @param threshold {Number} x-axis or y-axis threshold.
       * @return {Number} Threshold exceedance amount (positive or negative).
       */
      _calculateThresholdExceedance: function _calculateThresholdExceedance(diff, threshold) {
        var amount = threshold - Math.abs(diff);
        return diff < 0 ? amount * -1 : amount;
      },

      /**
       * Calculates the scroll amount (which may be negative).
       * The amount is influenced by the scrollbar size (bigger = faster)
       * the exceedanceAmount (bigger = faster) and the slowDownFactor.
       *
       * @param scrollbarSize {Number} Size of the scrollbar.
       * @param exceedanceAmount {Number} Threshold exceedance amount (positive or negative).
       * @return {Number} Scroll amount (positive or negative).
       */
      _calculateScrollAmount: function _calculateScrollAmount(scrollbarSize, exceedanceAmount) {
        return Math.floor(scrollbarSize / 100 * exceedanceAmount * this.getDragScrollSlowDownFactor());
      },

      /**
       * Scrolls the given scrollable on the given axis for the given amount.
       *
       * @param scrollable {qx.ui.core.Widget} Scrollable which has scrollbar child controls.
       * @param axis {String} Can be 'y' or 'x'.
       * @param exceedanceAmount {Number} Threshold exceedance amount (positive or negative).
       */
      _scrollBy: function _scrollBy(scrollable, axis, exceedanceAmount) {
        var scrollbar = scrollable.getChildControl("scrollbar-" + axis, true);

        if (!scrollbar) {
          return;
        }

        var bounds = scrollbar.getBounds(),
            scrollbarSize = axis === "x" ? bounds.width : bounds.height,
            amount = this._calculateScrollAmount(scrollbarSize, exceedanceAmount);

        if (this._isScrollbarExceedingMaxPos(scrollbar, axis, amount)) {
          this.__dragScrollTimer__P_379_4.stop();
        }

        scrollbar.scrollBy(amount);
      },

      /*
      ---------------------------------------------------------------------------
      EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the drag event.
       *
       * @param e {qx.event.type.Drag} The drag event instance.
       */
      __onDrag__P_379_0: function __onDrag__P_379_0(e) {
        if (this.__dragScrollTimer__P_379_4) {
          // stop last scroll action
          this.__dragScrollTimer__P_379_4.stop();
        }

        var target;

        if (e.getOriginalTarget() instanceof qx.ui.core.Widget) {
          target = e.getOriginalTarget();
        } else {
          target = qx.ui.core.Widget.getWidgetByElement(e.getOriginalTarget());
        }

        if (!target) {
          return;
        }

        var scrollable;

        if (this._isScrollable(target)) {
          scrollable = target;
        } else {
          scrollable = this._findScrollableParent(target);
        }

        while (scrollable) {
          var bounds = this._getBounds(scrollable),
              xPos = e.getDocumentLeft(),
              yPos = e.getDocumentTop(),
              diff = {
            "left": bounds.left - xPos,
            "right": bounds.right - xPos,
            "top": bounds.top - yPos,
            "bottom": bounds.bottom - yPos
          },
              edgeType = null,
              axis = "",
              exceedanceAmount = 0;

          edgeType = this._getEdgeType(diff, this.getDragScrollThresholdX(), this.getDragScrollThresholdY());

          if (!edgeType) {
            scrollable = this._findScrollableParent(scrollable);
            continue;
          }

          axis = this._getAxis(edgeType);

          if (this._isScrollbarVisible(scrollable, axis)) {
            exceedanceAmount = this._calculateThresholdExceedance(diff[edgeType], this._getThresholdByEdgeType(edgeType));

            if (this.__dragScrollTimer__P_379_4) {
              this.__dragScrollTimer__P_379_4.dispose();
            }

            this.__dragScrollTimer__P_379_4 = new qx.event.Timer(50);

            this.__dragScrollTimer__P_379_4.addListener("interval", function (scrollable, axis, amount) {
              this._scrollBy(scrollable, axis, amount);
            }.bind(this, scrollable, axis, exceedanceAmount));

            this.__dragScrollTimer__P_379_4.start();

            e.stopPropagation();
            return;
          } else {
            scrollable = this._findScrollableParent(scrollable);
          }
        }
      },

      /**
       * Event handler for the dragend event.
       *
       * @param e {qx.event.type.Drag} The drag event instance.
       */
      __onDragend__P_379_1: function __onDragend__P_379_1(e) {
        if (this.__dragScrollTimer__P_379_4) {
          this.__dragScrollTimer__P_379_4.stop();
        }
      }
    },
    destruct: function destruct() {
      if (this.__dragScrollTimer__P_379_4) {
        this.__dragScrollTimer__P_379_4.dispose();
      }
    }
  });
  qx.ui.core.MDragDropScrolling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MDragDropScrolling": {
        "require": true
      },
      "qx.core.Init": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Mustafa Sak (msak)
  
  ************************************************************************ */

  /**
   * Provides scrolling ability during drag session to the widget.
   */
  qx.Class.define("qx.ui.core.DragDropScrolling", {
    extend: qx.core.Object,
    include: [qx.ui.core.MDragDropScrolling],
    construct: function construct(widget) {
      qx.core.Object.constructor.call(this);
      this._widget = widget;
    },
    members: {
      _widget: null,

      /**
       * Returns the root widget whose children will have scroll on drag session
       * behavior. Widget was set on constructor or will be application root by
       * default.
       *
       * @return {qx.ui.core.Widget} The root widget whose children will have
       * scroll on drag session
       */
      _getWidget: function _getWidget() {
        return this._widget || qx.core.Init.getApplication().getRoot();
      }
    }
  });
  qx.ui.core.DragDropScrolling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.scroll.MScrollBarFactory": {
        "require": true
      },
      "qx.ui.core.scroll.MRoll": {
        "require": true
      },
      "qx.ui.core.MDragDropScrolling": {
        "require": true
      },
      "qx.bom.client.Scroll": {
        "construct": true
      },
      "qx.ui.layout.Canvas": {
        "construct": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.core.scroll.ScrollPane": {},
      "qx.ui.core.queue.Manager": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "os.scrollBarOverlayed": {
          "construct": true,
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The ScrollArea provides a container widget with on demand scroll bars
   * if the content size exceeds the size of the container.
   *
   * @childControl pane {qx.ui.core.scroll.ScrollPane} pane which holds the content to scroll
   * @childControl scrollbar-x {qx.ui.core.scroll.ScrollBar?qx.ui.core.scroll.NativeScrollBar} horizontal scrollbar
   * @childControl scrollbar-y {qx.ui.core.scroll.ScrollBar?qx.ui.core.scroll.NativeScrollBar} vertical scrollbar
   * @childControl corner {qx.ui.core.Widget} corner where no scrollbar is shown
   */
  qx.Class.define("qx.ui.core.scroll.AbstractScrollArea", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.scroll.MScrollBarFactory, qx.ui.core.scroll.MRoll, qx.ui.core.MDragDropScrolling],
    type: "abstract",

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * The default width which is used for the width of the scroll bar if
       * overlaid.
       */
      DEFAULT_SCROLLBAR_WIDTH: 14
    },

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this);

      if (qx.core.Environment.get("os.scrollBarOverlayed")) {
        // use a plain canvas to overlay the scroll bars
        this._setLayout(new qx.ui.layout.Canvas());
      } else {
        // Create 'fixed' grid layout
        var grid = new qx.ui.layout.Grid();
        grid.setColumnFlex(0, 1);
        grid.setRowFlex(0, 1);

        this._setLayout(grid);
      } // since the scroll container disregards the min size of the scrollbars
      // we have to set the min size of the scroll area to ensure that the
      // scrollbars always have an usable size.


      var size = qx.ui.core.scroll.AbstractScrollArea.DEFAULT_SCROLLBAR_WIDTH * 2 + 14;
      this.set({
        minHeight: size,
        minWidth: size
      }); // Roll listener for scrolling

      this._addRollHandling();
    },
    events: {
      /** Fired as soon as the scroll animation in X direction ends. */
      scrollAnimationXEnd: 'qx.event.type.Event',

      /** Fired as soon as the scroll animation in Y direction ends. */
      scrollAnimationYEnd: 'qx.event.type.Event'
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "scrollarea"
      },

      /**
       * The policy, when the horizontal scrollbar should be shown.
       * <ul>
       *   <li><b>auto</b>: Show scrollbar on demand</li>
       *   <li><b>on</b>: Always show the scrollbar</li>
       *   <li><b>off</b>: Never show the scrollbar</li>
       * </ul>
       */
      scrollbarX: {
        check: ["auto", "on", "off"],
        init: "auto",
        themeable: true,
        apply: "_computeScrollbars"
      },

      /**
       * The policy, when the horizontal scrollbar should be shown.
       * <ul>
       *   <li><b>auto</b>: Show scrollbar on demand</li>
       *   <li><b>on</b>: Always show the scrollbar</li>
       *   <li><b>off</b>: Never show the scrollbar</li>
       * </ul>
       */
      scrollbarY: {
        check: ["auto", "on", "off"],
        init: "auto",
        themeable: true,
        apply: "_computeScrollbars"
      },

      /**
       * Group property, to set the overflow of both scroll bars.
       */
      scrollbar: {
        group: ["scrollbarX", "scrollbarY"]
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        CHILD CONTROL SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "pane":
            control = new qx.ui.core.scroll.ScrollPane();
            control.addListener("update", this._computeScrollbars, this);
            control.addListener("scrollX", this._onScrollPaneX, this);
            control.addListener("scrollY", this._onScrollPaneY, this);

            if (qx.core.Environment.get("os.scrollBarOverlayed")) {
              this._add(control, {
                edge: 0
              });
            } else {
              this._add(control, {
                row: 0,
                column: 0
              });
            }

            break;

          case "scrollbar-x":
            control = this._createScrollBar("horizontal");
            control.setMinWidth(0);
            control.exclude();
            control.addListener("scroll", this._onScrollBarX, this);
            control.addListener("changeVisibility", this._onChangeScrollbarXVisibility, this);
            control.addListener("scrollAnimationEnd", this._onScrollAnimationEnd.bind(this, "X"));

            if (qx.core.Environment.get("os.scrollBarOverlayed")) {
              control.setMinHeight(qx.ui.core.scroll.AbstractScrollArea.DEFAULT_SCROLLBAR_WIDTH);

              this._add(control, {
                bottom: 0,
                right: 0,
                left: 0
              });
            } else {
              this._add(control, {
                row: 1,
                column: 0
              });
            }

            break;

          case "scrollbar-y":
            control = this._createScrollBar("vertical");
            control.setMinHeight(0);
            control.exclude();
            control.addListener("scroll", this._onScrollBarY, this);
            control.addListener("changeVisibility", this._onChangeScrollbarYVisibility, this);
            control.addListener("scrollAnimationEnd", this._onScrollAnimationEnd.bind(this, "Y"));

            if (qx.core.Environment.get("os.scrollBarOverlayed")) {
              control.setMinWidth(qx.ui.core.scroll.AbstractScrollArea.DEFAULT_SCROLLBAR_WIDTH);

              this._add(control, {
                right: 0,
                bottom: 0,
                top: 0
              });
            } else {
              this._add(control, {
                row: 0,
                column: 1
              });
            }

            break;

          case "corner":
            control = new qx.ui.core.Widget();
            control.setWidth(0);
            control.setHeight(0);
            control.exclude();

            if (!qx.core.Environment.get("os.scrollBarOverlayed")) {
              // only add for non overlayed scroll bars
              this._add(control, {
                row: 1,
                column: 1
              });
            }

            break;
        }

        return control || qx.ui.core.scroll.AbstractScrollArea.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        PANE SIZE
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the dimensions of the pane.
       *
       * @return {Map|null} The pane dimension in pixel. Contains
       *    the keys <code>width</code> and <code>height</code>.
       */
      getPaneSize: function getPaneSize() {
        return this.getChildControl("pane").getInnerSize();
      },

      /*
      ---------------------------------------------------------------------------
        ITEM LOCATION SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the top offset of the given item in relation to the
       * inner height of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Top offset
       */
      getItemTop: function getItemTop(item) {
        return this.getChildControl("pane").getItemTop(item);
      },

      /**
       * Returns the top offset of the end of the given item in relation to the
       * inner height of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Top offset
       */
      getItemBottom: function getItemBottom(item) {
        return this.getChildControl("pane").getItemBottom(item);
      },

      /**
       * Returns the left offset of the given item in relation to the
       * inner width of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Top offset
       */
      getItemLeft: function getItemLeft(item) {
        return this.getChildControl("pane").getItemLeft(item);
      },

      /**
       * Returns the left offset of the end of the given item in relation to the
       * inner width of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Right offset
       */
      getItemRight: function getItemRight(item) {
        return this.getChildControl("pane").getItemRight(item);
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Scrolls the element's content to the given left coordinate
       *
       * @param value {Integer} The vertical position to scroll to.
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollToX: function scrollToX(value, duration) {
        // First flush queue before scroll
        qx.ui.core.queue.Manager.flush();
        this.getChildControl("scrollbar-x").scrollTo(value, duration);
      },

      /**
       * Scrolls the element's content by the given left offset
       *
       * @param value {Integer} The vertical position to scroll to.
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollByX: function scrollByX(value, duration) {
        // First flush queue before scroll
        qx.ui.core.queue.Manager.flush();
        this.getChildControl("scrollbar-x").scrollBy(value, duration);
      },

      /**
       * Returns the scroll left position of the content
       *
       * @return {Integer} Horizontal scroll position
       */
      getScrollX: function getScrollX() {
        var scrollbar = this.getChildControl("scrollbar-x", true);
        return scrollbar ? scrollbar.getPosition() : 0;
      },

      /**
       * Scrolls the element's content to the given top coordinate
       *
       * @param value {Integer} The horizontal position to scroll to.
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollToY: function scrollToY(value, duration) {
        // First flush queue before scroll
        qx.ui.core.queue.Manager.flush();
        this.getChildControl("scrollbar-y").scrollTo(value, duration);
      },

      /**
       * Scrolls the element's content by the given top offset
       *
       * @param value {Integer} The horizontal position to scroll to.
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollByY: function scrollByY(value, duration) {
        // First flush queue before scroll
        qx.ui.core.queue.Manager.flush();
        this.getChildControl("scrollbar-y").scrollBy(value, duration);
      },

      /**
       * Returns the scroll top position of the content
       *
       * @return {Integer} Vertical scroll position
       */
      getScrollY: function getScrollY() {
        var scrollbar = this.getChildControl("scrollbar-y", true);
        return scrollbar ? scrollbar.getPosition() : 0;
      },

      /**
       * In case a scroll animation is currently running in X direction,
       * it will be stopped. If not, the method does nothing.
       */
      stopScrollAnimationX: function stopScrollAnimationX() {
        var scrollbar = this.getChildControl("scrollbar-x", true);

        if (scrollbar) {
          scrollbar.stopScrollAnimation();
        }
      },

      /**
       * In case a scroll animation is currently running in X direction,
       * it will be stopped. If not, the method does nothing.
       */
      stopScrollAnimationY: function stopScrollAnimationY() {
        var scrollbar = this.getChildControl("scrollbar-y", true);

        if (scrollbar) {
          scrollbar.stopScrollAnimation();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the scroll animation end event for both scroll bars.
       *
       * @param direction {String} Either "X" or "Y".
       */
      _onScrollAnimationEnd: function _onScrollAnimationEnd(direction) {
        this.fireEvent("scrollAnimation" + direction + "End");
      },

      /**
       * Event handler for the scroll event of the horizontal scrollbar
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollBarX: function _onScrollBarX(e) {
        this.getChildControl("pane").scrollToX(e.getData());
      },

      /**
       * Event handler for the scroll event of the vertical scrollbar
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollBarY: function _onScrollBarY(e) {
        this.getChildControl("pane").scrollToY(e.getData());
      },

      /**
       * Event handler for the horizontal scroll event of the pane
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollPaneX: function _onScrollPaneX(e) {
        var scrollbar = this.getChildControl("scrollbar-x");

        if (scrollbar) {
          scrollbar.updatePosition(e.getData());
        }
      },

      /**
       * Event handler for the vertical scroll event of the pane
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollPaneY: function _onScrollPaneY(e) {
        var scrollbar = this.getChildControl("scrollbar-y");

        if (scrollbar) {
          scrollbar.updatePosition(e.getData());
        }
      },

      /**
       * Event handler for visibility changes of horizontal scrollbar.
       *
       * @param e {qx.event.type.Event} Property change event
       */
      _onChangeScrollbarXVisibility: function _onChangeScrollbarXVisibility(e) {
        var showX = this._isChildControlVisible("scrollbar-x");

        var showY = this._isChildControlVisible("scrollbar-y");

        if (!showX) {
          this.scrollToX(0);
        }

        showX && showY ? this._showChildControl("corner") : this._excludeChildControl("corner");
      },

      /**
       * Event handler for visibility changes of horizontal scrollbar.
       *
       * @param e {qx.event.type.Event} Property change event
       */
      _onChangeScrollbarYVisibility: function _onChangeScrollbarYVisibility(e) {
        var showX = this._isChildControlVisible("scrollbar-x");

        var showY = this._isChildControlVisible("scrollbar-y");

        if (!showY) {
          this.scrollToY(0);
        }

        showX && showY ? this._showChildControl("corner") : this._excludeChildControl("corner");
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Computes the visibility state for scrollbars.
       *
       */
      _computeScrollbars: function _computeScrollbars() {
        var pane = this.getChildControl("pane");
        var content = pane.getChildren()[0];

        if (!content) {
          this._excludeChildControl("scrollbar-x");

          this._excludeChildControl("scrollbar-y");

          return;
        }

        var innerSize = this.getInnerSize();
        var paneSize = pane.getInnerSize();
        var scrollSize = pane.getScrollSize(); // if the widget has not yet been rendered, return and try again in the
        // resize event

        if (!paneSize || !scrollSize) {
          return;
        }

        var scrollbarX = this.getScrollbarX();
        var scrollbarY = this.getScrollbarY();

        if (scrollbarX === "auto" && scrollbarY === "auto") {
          // Check if the container is big enough to show
          // the full content.
          var showX = scrollSize.width > innerSize.width;
          var showY = scrollSize.height > innerSize.height; // Dependency check
          // We need a special intelligence here when only one
          // of the autosized axis requires a scrollbar
          // This scrollbar may then influence the need
          // for the other one as well.

          if ((showX || showY) && !(showX && showY)) {
            if (showX) {
              showY = scrollSize.height > paneSize.height;
            } else if (showY) {
              showX = scrollSize.width > paneSize.width;
            }
          }
        } else {
          var showX = scrollbarX === "on";
          var showY = scrollbarY === "on"; // Check auto values afterwards with already
          // corrected client dimensions

          if (scrollSize.width > (showX ? paneSize.width : innerSize.width) && scrollbarX === "auto") {
            showX = true;
          }

          if (scrollSize.height > (showX ? paneSize.height : innerSize.height) && scrollbarY === "auto") {
            showY = true;
          }
        } // Update scrollbars


        if (showX) {
          var barX = this.getChildControl("scrollbar-x");
          barX.show();
          barX.setMaximum(Math.max(0, scrollSize.width - paneSize.width));
          barX.setKnobFactor(scrollSize.width === 0 ? 0 : paneSize.width / scrollSize.width);
        } else {
          this._excludeChildControl("scrollbar-x");
        }

        if (showY) {
          var barY = this.getChildControl("scrollbar-y");
          barY.show();
          barY.setMaximum(Math.max(0, scrollSize.height - paneSize.height));
          barY.setKnobFactor(scrollSize.height === 0 ? 0 : paneSize.height / scrollSize.height);
        } else {
          this._excludeChildControl("scrollbar-y");
        }
      }
    }
  });
  qx.ui.core.scroll.AbstractScrollArea.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * This mixin links all methods to manage the multi selection from the
   * internal selection manager to the widget.
   */
  qx.Mixin.define("qx.ui.core.MMultiSelectionHandling", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      // Create selection manager
      var clazz = this.SELECTION_MANAGER;
      var manager = this.__manager__P_382_0 = new clazz(this); // Add widget event listeners

      this.addListener("pointerdown", manager.handlePointerDown, manager);
      this.addListener("tap", manager.handleTap, manager);
      this.addListener("pointerover", manager.handlePointerOver, manager);
      this.addListener("pointermove", manager.handlePointerMove, manager);
      this.addListener("losecapture", manager.handleLoseCapture, manager);
      this.addListener("keypress", manager.handleKeyPress, manager);
      this.addListener("addItem", manager.handleAddItem, manager);
      this.addListener("removeItem", manager.handleRemoveItem, manager); // Add manager listeners

      manager.addListener("changeSelection", this._onSelectionChange, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data",

      /** Fires after the selection was modified */
      "changeSelection": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The selection mode to use.
       *
       * For further details please have a look at:
       * {@link qx.ui.core.selection.Abstract#mode}
       */
      selectionMode: {
        check: ["single", "multi", "additive", "one"],
        init: "single",
        apply: "_applySelectionMode"
      },

      /**
       * Enable drag selection (multi selection of items through
       * dragging the pointer in pressed states).
       *
       * Only possible for the selection modes <code>multi</code> and <code>additive</code>
       */
      dragSelection: {
        check: "Boolean",
        init: false,
        apply: "_applyDragSelection"
      },

      /**
       * Enable quick selection mode, where no tap is needed to change the selection.
       *
       * Only possible for the modes <code>single</code> and <code>one</code>.
       */
      quickSelection: {
        check: "Boolean",
        init: false,
        apply: "_applyQuickSelection"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.core.selection.Abstract} The selection manager */
      __manager__P_382_0: null,

      /** @type {Boolean} used to control recursion in onSelectionChange */
      __inOnSelectionChange__P_382_1: false,

      /*
      ---------------------------------------------------------------------------
        USER API
      ---------------------------------------------------------------------------
      */

      /**
       * setValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @param items {null|qx.ui.core.Widget[]} Items to select.
       * @returns {null|TypeError} The status of this operation.
       */
      setValue: function setValue(items) {
        if (null === items) {
          this.__manager__P_382_0.clearSelection();

          return null;
        }

        {
          for (var i = 0, l = items.length; i < l; i++) {
            if (!(items[i] instanceof qx.ui.core.Widget)) {
              return new TypeError("Some items in provided argument are not widgets");
            }
          }
        }

        try {
          this.setSelection(items);
          return null;
        } catch (e) {
          return e;
        }
      },

      /**
       * getValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @returns {qx.ui.core.Widget[]} The selected widgets or null if there are none.
       */
      getValue: function getValue() {
        return this.__manager__P_382_0.getSelection();
      },

      /**
       * resetValue implements part of the {@link qx.ui.form.IField} interface.
       */
      resetValue: function resetValue() {
        this.__manager__P_382_0.clearSelection();
      },

      /**
       * Selects all items of the managed object.
       */
      selectAll: function selectAll() {
        this.__manager__P_382_0.selectAll();
      },

      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {qx.ui.core.Widget} Any valid selectable item.
       * @return {Boolean} Whether the item is selected.
       * @throws {Error} if the item is not a child element.
       */
      isSelected: function isSelected(item) {
        if (!qx.ui.core.Widget.contains(this, item)) {
          throw new Error("Could not test if " + item + " is selected, because it is not a child element!");
        }

        return this.__manager__P_382_0.isItemSelected(item);
      },

      /**
       * Adds the given item to the existing selection.
       *
       * Use {@link #setSelection} instead if you want to replace
       * the current selection.
       *
       * @param item {qx.ui.core.Widget} Any valid item.
       * @throws {Error} if the item is not a child element.
       */
      addToSelection: function addToSelection(item) {
        if (!qx.ui.core.Widget.contains(this, item)) {
          throw new Error("Could not add + " + item + " to selection, because it is not a child element!");
        }

        this.__manager__P_382_0.addItem(item);
      },

      /**
       * Removes the given item from the selection.
       *
       * Use {@link #resetSelection} when you want to clear
       * the whole selection at once.
       *
       * @param item {qx.ui.core.Widget} Any valid item
       * @throws {Error} if the item is not a child element.
       */
      removeFromSelection: function removeFromSelection(item) {
        if (!qx.ui.core.Widget.contains(this, item)) {
          throw new Error("Could not remove " + item + " from selection, because it is not a child element!");
        }

        this.__manager__P_382_0.removeItem(item);
      },

      /**
       * Selects an item range between two given items.
       *
       * @param begin {qx.ui.core.Widget} Item to start with
       * @param end {qx.ui.core.Widget} Item to end at
       */
      selectRange: function selectRange(begin, end) {
        this.__manager__P_382_0.selectItemRange(begin, end);
      },

      /**
       * Clears the whole selection at once. Also
       * resets the lead and anchor items and their
       * styles.
       */
      resetSelection: function resetSelection() {
        this.__manager__P_382_0.clearSelection();
      },

      /**
       * Replaces current selection with the given items.
       *
       * @param items {qx.ui.core.Widget[]} Items to select.
       * @throws {Error} if one of the items is not a child element and if
       *    the mode is set to <code>single</code> or <code>one</code> and
       *    the items contains more than one item.
       */
      setSelection: function setSelection(items) {
        // Block recursion so that when selection changes modelSelection, the modelSelection
        //  cannot change selection again; this is important because modelSelection does not
        //  necessarily match selection, for example when the item's model properties are
        //  null.
        if (this.__inOnSelectionChange__P_382_1) {
          return;
        }

        for (var i = 0; i < items.length; i++) {
          if (!qx.ui.core.Widget.contains(this, items[i])) {
            throw new Error("Could not select " + items[i] + ", because it is not a child element!");
          }
        }

        if (items.length === 0) {
          this.resetSelection();
        } else {
          var currentSelection = this.getSelection();

          if (!qx.lang.Array.equals(currentSelection, items)) {
            this.__manager__P_382_0.replaceSelection(items);
          }
        }
      },

      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {qx.ui.core.Widget[]} List of items.
       */
      getSelection: function getSelection() {
        return this.__manager__P_382_0.getSelection();
      },

      /**
       * Returns an array of currently selected items sorted
       * by their index in the container.
       *
       * @return {qx.ui.core.Widget[]} Sorted list of items
       */
      getSortedSelection: function getSortedSelection() {
        return this.__manager__P_382_0.getSortedSelection();
      },

      /**
       * Whether the selection is empty
       *
       * @return {Boolean} Whether the selection is empty
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__manager__P_382_0.isSelectionEmpty();
      },

      /**
       * Returns the last selection context.
       *
       * @return {String | null} One of <code>tap</code>, <code>quick</code>,
       *    <code>drag</code> or <code>key</code> or <code>null</code>.
       */
      getSelectionContext: function getSelectionContext() {
        return this.__manager__P_382_0.getSelectionContext();
      },

      /**
       * Returns the internal selection manager. Use this with
       * caution!
       *
       * @return {qx.ui.core.selection.Abstract} The selection manager
       */
      _getManager: function _getManager() {
        return this.__manager__P_382_0;
      },

      /**
       * Returns all elements which are selectable.
       *
       * @param all {Boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       * @return {qx.ui.core.Widget[]} The contained items.
       */
      getSelectables: function getSelectables(all) {
        return this.__manager__P_382_0.getSelectables(all);
      },

      /**
       * Invert the selection. Select the non selected and deselect the selected.
       */
      invertSelection: function invertSelection() {
        this.__manager__P_382_0.invertSelection();
      },

      /**
       * Returns the current lead item. Generally the item which was last modified
       * by the user (tapped on etc.)
       *
       * @return {qx.ui.core.Widget} The lead item or <code>null</code>
       */
      _getLeadItem: function _getLeadItem() {
        var mode = this.__manager__P_382_0.getMode();

        if (mode === "single" || mode === "one") {
          return this.__manager__P_382_0.getSelectedItem();
        } else {
          return this.__manager__P_382_0.getLeadItem();
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applySelectionMode: function _applySelectionMode(value, old) {
        this.__manager__P_382_0.setMode(value);
      },
      // property apply
      _applyDragSelection: function _applyDragSelection(value, old) {
        this.__manager__P_382_0.setDrag(value);
      },
      // property apply
      _applyQuickSelection: function _applyQuickSelection(value, old) {
        this.__manager__P_382_0.setQuick(value);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for <code>changeSelection</code> event on selection manager.
       *
       * @param e {qx.event.type.Data} Data event
       */
      _onSelectionChange: function _onSelectionChange(e) {
        if (this.__inOnSelectionChange__P_382_1) {
          return;
        }

        this.__inOnSelectionChange__P_382_1 = true;

        try {
          this.fireDataEvent("changeSelection", e.getData(), e.getOldData());
          this.fireDataEvent("changeValue", e.getData(), e.getOldData());
        } finally {
          this.__inOnSelectionChange__P_382_1 = false;
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__manager__P_382_0");
    }
  });
  qx.ui.core.MMultiSelectionHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.lang.Object": {},
      "qx.bom.client.OperatingSystem": {},
      "qx.event.Timer": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "os.name": {
          "className": "qx.bom.client.OperatingSystem"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Generic selection manager to bring rich desktop like selection behavior
   * to widgets and low-level interactive controls.
   *
   * The selection handling supports both Shift and Ctrl/Meta modifies like
   * known from native applications.
   */
  qx.Class.define("qx.ui.core.selection.Abstract", {
    type: "abstract",
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this); // {Map} Internal selection storage

      this.__selection__P_398_0 = {};
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fires after the selection was modified. Contains the selection under the data property. */
      "changeSelection": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Selects the selection mode to use.
       *
       * * single: One or no element is selected
       * * multi: Multi items could be selected. Also allows empty selections.
       * * additive: Easy Web-2.0 selection mode. Allows multiple selections without modifier keys.
       * * one: If possible always exactly one item is selected
       */
      mode: {
        check: ["single", "multi", "additive", "one"],
        init: "single",
        apply: "_applyMode"
      },

      /**
       * Enable drag selection (multi selection of items through
       * dragging the pointer in pressed states).
       *
       * Only possible for the modes <code>multi</code> and <code>additive</code>
       */
      drag: {
        check: "Boolean",
        init: false
      },

      /**
       * Enable quick selection mode, where no tap is needed to change the selection.
       *
       * Only possible for the modes <code>single</code> and <code>one</code>.
       */
      quick: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __scrollStepX__P_398_1: 0,
      __scrollStepY__P_398_2: 0,
      __scrollTimer__P_398_3: null,
      __frameScroll__P_398_4: null,
      __lastRelX__P_398_5: null,
      __lastRelY__P_398_6: null,
      __frameLocation__P_398_7: null,
      __dragStartX__P_398_8: null,
      __dragStartY__P_398_9: null,
      __inCapture__P_398_10: null,
      __pointerX__P_398_11: null,
      __pointerY__P_398_12: null,
      __moveDirectionX__P_398_13: null,
      __moveDirectionY__P_398_14: null,
      __selectionModified__P_398_15: null,
      __selectionContext__P_398_16: null,
      __leadItem__P_398_17: null,
      __selection__P_398_0: null,
      __anchorItem__P_398_18: null,
      __pointerDownOnSelected__P_398_19: null,
      // A flag that signals an user interaction, which means the selection change
      // was triggered by pointer or keyboard [BUG #3344]
      _userInteraction: false,
      __oldScrollTop__P_398_20: null,

      /*
      ---------------------------------------------------------------------------
        USER APIS
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the selection context. One of <code>tap</code>,
       * <code>quick</code>, <code>drag</code> or <code>key</code> or
       * <code>null</code>.
       *
       * @return {String} One of <code>tap</code>, <code>quick</code>,
       *    <code>drag</code> or <code>key</code> or <code>null</code>
       */
      getSelectionContext: function getSelectionContext() {
        return this.__selectionContext__P_398_16;
      },

      /**
       * Selects all items of the managed object.
       *
       */
      selectAll: function selectAll() {
        var mode = this.getMode();

        if (mode == "single" || mode == "one") {
          throw new Error("Can not select all items in selection mode: " + mode);
        }

        this._selectAllItems();

        this._fireChange();
      },

      /**
       * Selects the given item. Replaces current selection
       * completely with the new item.
       *
       * Use {@link #addItem} instead if you want to add new
       * items to an existing selection.
       *
       * @param item {Object} Any valid item
       */
      selectItem: function selectItem(item) {
        this._setSelectedItem(item);

        var mode = this.getMode();

        if (mode !== "single" && mode !== "one") {
          this._setLeadItem(item);

          this._setAnchorItem(item);
        }

        this._scrollItemIntoView(item);

        this._fireChange();
      },

      /**
       * Adds the given item to the existing selection.
       *
       * Use {@link #selectItem} instead if you want to replace
       * the current selection.
       *
       * @param item {Object} Any valid item
       */
      addItem: function addItem(item) {
        var mode = this.getMode();

        if (mode === "single" || mode === "one") {
          this._setSelectedItem(item);
        } else {
          if (this._getAnchorItem() == null) {
            this._setAnchorItem(item);
          }

          this._setLeadItem(item);

          this._addToSelection(item);
        }

        this._scrollItemIntoView(item);

        this._fireChange();
      },

      /**
       * Removes the given item from the selection.
       *
       * Use {@link #clearSelection} when you want to clear
       * the whole selection at once.
       *
       * @param item {Object} Any valid item
       */
      removeItem: function removeItem(item) {
        this._removeFromSelection(item);

        if (this.getMode() === "one" && this.isSelectionEmpty()) {
          var selected = this._applyDefaultSelection(); // Do not fire any event in this case.


          if (selected == item) {
            return;
          }
        }

        if (this.getLeadItem() == item) {
          this._setLeadItem(null);
        }

        if (this._getAnchorItem() == item) {
          this._setAnchorItem(null);
        }

        this._fireChange();
      },

      /**
       * Selects an item range between two given items.
       *
       * @param begin {Object} Item to start with
       * @param end {Object} Item to end at
       */
      selectItemRange: function selectItemRange(begin, end) {
        var mode = this.getMode();

        if (mode == "single" || mode == "one") {
          throw new Error("Can not select multiple items in selection mode: " + mode);
        }

        this._selectItemRange(begin, end);

        this._setAnchorItem(begin);

        this._setLeadItem(end);

        this._scrollItemIntoView(end);

        this._fireChange();
      },

      /**
       * Clears the whole selection at once. Also
       * resets the lead and anchor items and their
       * styles.
       *
       */
      clearSelection: function clearSelection() {
        if (this.getMode() == "one") {
          var selected = this._applyDefaultSelection(true);

          if (selected != null) {
            return;
          }
        }

        this._clearSelection();

        this._setLeadItem(null);

        this._setAnchorItem(null);

        this._fireChange();
      },

      /**
       * Replaces current selection with given array of items.
       *
       * Please note that in single selection scenarios it is more
       * efficient to directly use {@link #selectItem}.
       *
       * @param items {Array} Items to select
       */
      replaceSelection: function replaceSelection(items) {
        var mode = this.getMode();

        if (mode == "one" || mode === "single") {
          if (items.length > 1) {
            throw new Error("Could not select more than one items in mode: " + mode + "!");
          }

          if (items.length == 1) {
            this.selectItem(items[0]);
          } else {
            this.clearSelection();
          }

          return;
        } else {
          this._replaceMultiSelection(items);
        }
      },

      /**
       * Get the selected item. This method does only work in <code>single</code>
       * selection mode.
       *
       * @return {Object} The selected item.
       */
      getSelectedItem: function getSelectedItem() {
        var mode = this.getMode();

        if (mode === "single" || mode === "one") {
          var result = this._getSelectedItem();

          return result != undefined ? result : null;
        }

        throw new Error("The method getSelectedItem() is only supported in 'single' and 'one' selection mode!");
      },

      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {Object[]} List of items.
       */
      getSelection: function getSelection() {
        return Object.values(this.__selection__P_398_0);
      },

      /**
       * Returns the selection sorted by the index in the
       * container of the selection (the assigned widget)
       *
       * @return {Object[]} Sorted list of items
       */
      getSortedSelection: function getSortedSelection() {
        var children = this.getSelectables();
        var sel = Object.values(this.__selection__P_398_0);
        sel.sort(function (a, b) {
          return children.indexOf(a) - children.indexOf(b);
        });
        return sel;
      },

      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {var} Any valid selectable item
       * @return {Boolean} Whether the item is selected
       */
      isItemSelected: function isItemSelected(item) {
        var hash = this._selectableToHashCode(item);

        return this.__selection__P_398_0[hash] !== undefined;
      },

      /**
       * Whether the selection is empty
       *
       * @return {Boolean} Whether the selection is empty
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return qx.lang.Object.isEmpty(this.__selection__P_398_0);
      },

      /**
       * Invert the selection. Select the non selected and deselect the selected.
       */
      invertSelection: function invertSelection() {
        var mode = this.getMode();

        if (mode === "single" || mode === "one") {
          throw new Error("The method invertSelection() is only supported in 'multi' and 'additive' selection mode!");
        }

        var selectables = this.getSelectables();

        for (var i = 0; i < selectables.length; i++) {
          this._toggleInSelection(selectables[i]);
        }

        this._fireChange();
      },

      /*
      ---------------------------------------------------------------------------
        LEAD/ANCHOR SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the lead item. Generally the item which was last modified
       * by the user (tapped on etc.)
       *
       * @param value {Object} Any valid item or <code>null</code>
       */
      _setLeadItem: function _setLeadItem(value) {
        var old = this.__leadItem__P_398_17;

        if (old !== null) {
          this._styleSelectable(old, "lead", false);
        }

        if (value !== null) {
          this._styleSelectable(value, "lead", true);
        }

        this.__leadItem__P_398_17 = value;
      },

      /**
       * Returns the current lead item. Generally the item which was last modified
       * by the user (tapped on etc.)
       *
       * @return {Object} The lead item or <code>null</code>
       */
      getLeadItem: function getLeadItem() {
        return this.__leadItem__P_398_17;
      },

      /**
       * Sets the anchor item. This is the item which is the starting
       * point for all range selections. Normally this is the item which was
       * tapped on the last time without any modifier keys pressed.
       *
       * @param value {Object} Any valid item or <code>null</code>
       */
      _setAnchorItem: function _setAnchorItem(value) {
        var old = this.__anchorItem__P_398_18;

        if (old != null) {
          this._styleSelectable(old, "anchor", false);
        }

        if (value != null) {
          this._styleSelectable(value, "anchor", true);
        }

        this.__anchorItem__P_398_18 = value;
      },

      /**
       * Returns the current anchor item. This is the item which is the starting
       * point for all range selections. Normally this is the item which was
       * tapped on the last time without any modifier keys pressed.
       *
       * @return {Object} The anchor item or <code>null</code>
       */
      _getAnchorItem: function _getAnchorItem() {
        return this.__anchorItem__P_398_18 !== null ? this.__anchorItem__P_398_18 : null;
      },

      /*
      ---------------------------------------------------------------------------
        BASIC SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Whether the given item is selectable.
       *
       * @param item {var} Any item
       * @return {Boolean} <code>true</code> when the item is selectable
       */
      _isSelectable: function _isSelectable(item) {
        throw new Error("Abstract method call: _isSelectable()");
      },

      /**
       * Finds the selectable instance from a pointer event
       *
       * @param event {qx.event.type.Pointer} The pointer event
       * @return {Object|null} The resulting selectable
       */
      _getSelectableFromPointerEvent: function _getSelectableFromPointerEvent(event) {
        var target = event.getTarget(); // check for target (may be null when leaving the viewport) [BUG #4378]

        if (target && this._isSelectable(target)) {
          return target;
        }

        return null;
      },

      /**
       * Returns an unique hashcode for the given item.
       *
       * @param item {var} Any item
       * @return {String} A valid hashcode
       */
      _selectableToHashCode: function _selectableToHashCode(item) {
        throw new Error("Abstract method call: _selectableToHashCode()");
      },

      /**
       * Updates the style (appearance) of the given item.
       *
       * @param item {var} Item to modify
       * @param type {String} Any of <code>selected</code>, <code>anchor</code> or <code>lead</code>
       * @param enabled {Boolean} Whether the given style should be added or removed.
       */
      _styleSelectable: function _styleSelectable(item, type, enabled) {
        throw new Error("Abstract method call: _styleSelectable()");
      },

      /**
       * Enables capturing of the container.
       *
       */
      _capture: function _capture() {
        throw new Error("Abstract method call: _capture()");
      },

      /**
       * Releases capturing of the container
       *
       */
      _releaseCapture: function _releaseCapture() {
        throw new Error("Abstract method call: _releaseCapture()");
      },

      /*
      ---------------------------------------------------------------------------
        DIMENSION AND LOCATION
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the location of the container
       *
       * @return {Map} Map with the keys <code>top</code>, <code>right</code>,
       *    <code>bottom</code> and <code>left</code>.
       */
      _getLocation: function _getLocation() {
        throw new Error("Abstract method call: _getLocation()");
      },

      /**
       * Returns the dimension of the container (available scrolling space).
       *
       * @return {Map} Map with the keys <code>width</code> and <code>height</code>.
       */
      _getDimension: function _getDimension() {
        throw new Error("Abstract method call: _getDimension()");
      },

      /**
       * Returns the relative (to the container) horizontal location of the given item.
       *
       * @param item {var} Any item
       * @return {Map} A map with the keys <code>left</code> and <code>right</code>.
       */
      _getSelectableLocationX: function _getSelectableLocationX(item) {
        throw new Error("Abstract method call: _getSelectableLocationX()");
      },

      /**
       * Returns the relative (to the container) horizontal location of the given item.
       *
       * @param item {var} Any item
       * @return {Map} A map with the keys <code>top</code> and <code>bottom</code>.
       */
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        throw new Error("Abstract method call: _getSelectableLocationY()");
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the scroll position of the container.
       *
       * @return {Map} Map with the keys <code>left</code> and <code>top</code>.
       */
      _getScroll: function _getScroll() {
        throw new Error("Abstract method call: _getScroll()");
      },

      /**
       * Scrolls by the given offset
       *
       * @param xoff {Integer} Horizontal offset to scroll by
       * @param yoff {Integer} Vertical offset to scroll by
       */
      _scrollBy: function _scrollBy(xoff, yoff) {
        throw new Error("Abstract method call: _scrollBy()");
      },

      /**
       * Scrolls the given item into the view (make it visible)
       *
       * @param item {var} Any item
       */
      _scrollItemIntoView: function _scrollItemIntoView(item) {
        throw new Error("Abstract method call: _scrollItemIntoView()");
      },

      /*
      ---------------------------------------------------------------------------
        QUERY SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Returns all selectable items of the container.
       *
       * @param all {Boolean} true for all selectables, false for the
        *   selectables the user can interactively select
       * @return {Array} A list of items
       */
      getSelectables: function getSelectables(all) {
        throw new Error("Abstract method call: getSelectables()");
      },

      /**
       * Returns all selectable items between the two given items.
       *
       * The items could be given in any order.
       *
       * @param item1 {var} First item
       * @param item2 {var} Second item
       * @return {Array} List of items
       */
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        throw new Error("Abstract method call: _getSelectableRange()");
      },

      /**
       * Returns the first selectable item.
       *
       * @return {var} The first selectable item
       */
      _getFirstSelectable: function _getFirstSelectable() {
        throw new Error("Abstract method call: _getFirstSelectable()");
      },

      /**
       * Returns the last selectable item.
       *
       * @return {var} The last selectable item
       */
      _getLastSelectable: function _getLastSelectable() {
        throw new Error("Abstract method call: _getLastSelectable()");
      },

      /**
       * Returns a selectable item which is related to the given
       * <code>item</code> through the value of <code>relation</code>.
       *
       * @param item {var} Any item
       * @param relation {String} A valid relation: <code>above</code>,
       *    <code>right</code>, <code>under</code> or <code>left</code>
       * @return {var} The related item
       */
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        throw new Error("Abstract method call: _getRelatedSelectable()");
      },

      /**
       * Returns the item which should be selected on pageUp/pageDown.
       *
       * May also scroll to the needed position.
       *
       * @param lead {var} The current lead item
       * @param up {Boolean?false} Which page key was pressed:
       *   <code>up</code> or <code>down</code>.
       */
      _getPage: function _getPage(lead, up) {
        throw new Error("Abstract method call: _getPage()");
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyMode: function _applyMode(value, old) {
        this._setLeadItem(null);

        this._setAnchorItem(null);

        this._clearSelection(); // Mode "one" requires one selected item


        if (value === "one") {
          this._applyDefaultSelection(true);
        }

        this._fireChange();
      },

      /*
      ---------------------------------------------------------------------------
        POINTER SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * This method should be connected to the <code>pointerover</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.Pointer} A valid pointer event
       */
      handlePointerOver: function handlePointerOver(event) {
        // All browsers (except Opera) fire a native "mouseover" event when a scroll appears
        // by keyboard interaction. We have to ignore the event to avoid a selection for
        // "pointerover" (quick selection). For more details see [BUG #4225]
        if (this.__oldScrollTop__P_398_20 != null && this.__oldScrollTop__P_398_20 != this._getScroll().top) {
          this.__oldScrollTop__P_398_20 = null;
          return;
        } // quick select should only work on mouse events


        if (event.getPointerType() != "mouse") {
          return;
        } // this is a method invoked by an user interaction, so be careful to
        // set / clear the mark this._userInteraction [BUG #3344]


        this._userInteraction = true;

        if (!this.getQuick()) {
          this._userInteraction = false;
          return;
        }

        var mode = this.getMode();

        if (mode !== "one" && mode !== "single") {
          this._userInteraction = false;
          return;
        }

        var item = this._getSelectableFromPointerEvent(event);

        if (item === null) {
          this._userInteraction = false;
          return;
        }

        this._setSelectedItem(item); // Be sure that item is in view
        // This does not feel good when pointerover is used
        // this._scrollItemIntoView(item);
        // Fire change event as needed


        this._fireChange("quick");

        this._userInteraction = false;
      },

      /**
       * This method should be connected to the <code>pointerdown</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.Pointer} A valid pointer event
       */
      handlePointerDown: function handlePointerDown(event) {
        // this is a method invoked by an user interaction, so be careful to
        // set / clear the mark this._userInteraction [BUG #3344]
        this._userInteraction = true;

        var item = this._getSelectableFromPointerEvent(event);

        if (item === null) {
          this._userInteraction = false;
          return;
        } // Read in keyboard modifiers


        var isCtrlPressed = event.isCtrlPressed() || qx.core.Environment.get("os.name") == "osx" && event.isMetaPressed();
        var isShiftPressed = event.isShiftPressed(); // tapping on selected items deselect on pointerup, not on pointerdown

        if (this.isItemSelected(item) && !isShiftPressed && !isCtrlPressed && !this.getDrag()) {
          this.__pointerDownOnSelected__P_398_19 = item;
          this._userInteraction = false;
          return;
        } else {
          this.__pointerDownOnSelected__P_398_19 = null;
        } // Be sure that item is in view


        this._scrollItemIntoView(item); // Drag selection


        var mode = this.getMode();

        if (this.getDrag() && mode !== "single" && mode !== "one" && !isShiftPressed && !isCtrlPressed && event.getPointerType() == "mouse") {
          this._setAnchorItem(item);

          this._setLeadItem(item); // Cache location/scroll data


          this.__frameLocation__P_398_7 = this._getLocation();
          this.__frameScroll__P_398_4 = this._getScroll(); // Store position at start

          this.__dragStartX__P_398_8 = event.getDocumentLeft() + this.__frameScroll__P_398_4.left;
          this.__dragStartY__P_398_9 = event.getDocumentTop() + this.__frameScroll__P_398_4.top; // Switch to capture mode

          this.__inCapture__P_398_10 = true;

          this._capture();
        } // Fire change event as needed


        this._fireChange("tap");

        this._userInteraction = false;
      },

      /**
       * This method should be connected to the <code>tap</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.Tap} A valid pointer event
       */
      handleTap: function handleTap(event) {
        // this is a method invoked by an user interaction, so be careful to
        // set / clear the mark this._userInteraction [BUG #3344]
        this._userInteraction = true; // Read in keyboard modifiers

        var isCtrlPressed = event.isCtrlPressed() || qx.core.Environment.get("os.name") == "osx" && event.isMetaPressed();
        var isShiftPressed = event.isShiftPressed();

        if (!isCtrlPressed && !isShiftPressed && this.__pointerDownOnSelected__P_398_19 != null) {
          this._userInteraction = false;

          var item = this._getSelectableFromPointerEvent(event);

          if (item === null || !this.isItemSelected(item)) {
            return;
          }
        }

        var item = this._getSelectableFromPointerEvent(event);

        if (item === null) {
          this._userInteraction = false;
          return;
        } // Action depends on selected mode


        switch (this.getMode()) {
          case "single":
          case "one":
            this._setSelectedItem(item);

            break;

          case "additive":
            this._setLeadItem(item);

            this._setAnchorItem(item);

            this._toggleInSelection(item);

            break;

          case "multi":
            // Update lead item
            this._setLeadItem(item); // Create/Update range selection


            if (isShiftPressed) {
              var anchor = this._getAnchorItem();

              if (anchor === null) {
                anchor = this._getFirstSelectable();

                this._setAnchorItem(anchor);
              }

              this._selectItemRange(anchor, item, isCtrlPressed);
            } // Toggle in selection
            else if (isCtrlPressed) {
                this._setAnchorItem(item);

                this._toggleInSelection(item);
              } // Replace current selection
              else {
                  this._setAnchorItem(item);

                  this._setSelectedItem(item);
                }

            break;
        } // Cleanup operation


        this._userInteraction = false;

        this._cleanup();
      },

      /**
       * This method should be connected to the <code>losecapture</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.Pointer} A valid pointer event
       */
      handleLoseCapture: function handleLoseCapture(event) {
        this._cleanup();
      },

      /**
       * This method should be connected to the <code>pointermove</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.Pointer} A valid pointer event
       */
      handlePointerMove: function handlePointerMove(event) {
        // Only relevant when capturing is enabled
        if (!this.__inCapture__P_398_10) {
          return;
        } // Update pointer position cache


        this.__pointerX__P_398_11 = event.getDocumentLeft();
        this.__pointerY__P_398_12 = event.getDocumentTop(); // this is a method invoked by an user interaction, so be careful to
        // set / clear the mark this._userInteraction [BUG #3344]

        this._userInteraction = true; // Detect move directions

        var dragX = this.__pointerX__P_398_11 + this.__frameScroll__P_398_4.left;

        if (dragX > this.__dragStartX__P_398_8) {
          this.__moveDirectionX__P_398_13 = 1;
        } else if (dragX < this.__dragStartX__P_398_8) {
          this.__moveDirectionX__P_398_13 = -1;
        } else {
          this.__moveDirectionX__P_398_13 = 0;
        }

        var dragY = this.__pointerY__P_398_12 + this.__frameScroll__P_398_4.top;

        if (dragY > this.__dragStartY__P_398_9) {
          this.__moveDirectionY__P_398_14 = 1;
        } else if (dragY < this.__dragStartY__P_398_9) {
          this.__moveDirectionY__P_398_14 = -1;
        } else {
          this.__moveDirectionY__P_398_14 = 0;
        } // Update scroll steps


        var location = this.__frameLocation__P_398_7;

        if (this.__pointerX__P_398_11 < location.left) {
          this.__scrollStepX__P_398_1 = this.__pointerX__P_398_11 - location.left;
        } else if (this.__pointerX__P_398_11 > location.right) {
          this.__scrollStepX__P_398_1 = this.__pointerX__P_398_11 - location.right;
        } else {
          this.__scrollStepX__P_398_1 = 0;
        }

        if (this.__pointerY__P_398_12 < location.top) {
          this.__scrollStepY__P_398_2 = this.__pointerY__P_398_12 - location.top;
        } else if (this.__pointerY__P_398_12 > location.bottom) {
          this.__scrollStepY__P_398_2 = this.__pointerY__P_398_12 - location.bottom;
        } else {
          this.__scrollStepY__P_398_2 = 0;
        } // Dynamically create required timer instance


        if (!this.__scrollTimer__P_398_3) {
          this.__scrollTimer__P_398_3 = new qx.event.Timer(100);

          this.__scrollTimer__P_398_3.addListener("interval", this._onInterval, this);
        } // Start interval


        this.__scrollTimer__P_398_3.start(); // Auto select based on new cursor position


        this._autoSelect();

        event.stopPropagation();
        this._userInteraction = false;
      },

      /**
       * This method should be connected to the <code>addItem</code> event
       * of the managed object.
       *
       * @param e {qx.event.type.Data} The event object
       */
      handleAddItem: function handleAddItem(e) {
        var item = e.getData();

        if (this.getMode() === "one" && this.isSelectionEmpty()) {
          this.addItem(item);
        }
      },

      /**
       * This method should be connected to the <code>removeItem</code> event
       * of the managed object.
       *
       * @param e {qx.event.type.Data} The event object
       */
      handleRemoveItem: function handleRemoveItem(e) {
        this.removeItem(e.getData());
      },

      /*
      ---------------------------------------------------------------------------
        POINTER SUPPORT INTERNALS
      ---------------------------------------------------------------------------
      */

      /**
       * Stops all timers, release capture etc. to cleanup drag selection
       */
      _cleanup: function _cleanup() {
        if (!this.getDrag() && this.__inCapture__P_398_10) {
          return;
        } // Fire change event if needed


        if (this.__selectionModified__P_398_15) {
          this._fireChange("tap");
        } // Remove flags


        delete this.__inCapture__P_398_10;
        delete this.__lastRelX__P_398_5;
        delete this.__lastRelY__P_398_6; // Stop capturing

        this._releaseCapture(); // Stop timer


        if (this.__scrollTimer__P_398_3) {
          this.__scrollTimer__P_398_3.stop();
        }
      },

      /**
       * Event listener for timer used by drag selection
       *
       * @param e {qx.event.type.Event} Timer event
       */
      _onInterval: function _onInterval(e) {
        // Scroll by defined block size
        this._scrollBy(this.__scrollStepX__P_398_1, this.__scrollStepY__P_398_2); // Update scroll cache


        this.__frameScroll__P_398_4 = this._getScroll(); // Auto select based on new scroll position and cursor

        this._autoSelect();
      },

      /**
       * Automatically selects items based on the pointer movement during a drag selection
       */
      _autoSelect: function _autoSelect() {
        var inner = this._getDimension(); // Get current relative Y position and compare it with previous one


        var relX = Math.max(0, Math.min(this.__pointerX__P_398_11 - this.__frameLocation__P_398_7.left, inner.width)) + this.__frameScroll__P_398_4.left;

        var relY = Math.max(0, Math.min(this.__pointerY__P_398_12 - this.__frameLocation__P_398_7.top, inner.height)) + this.__frameScroll__P_398_4.top; // Compare old and new relative coordinates (for performance reasons)


        if (this.__lastRelX__P_398_5 === relX && this.__lastRelY__P_398_6 === relY) {
          return;
        }

        this.__lastRelX__P_398_5 = relX;
        this.__lastRelY__P_398_6 = relY; // Cache anchor

        var anchor = this._getAnchorItem();

        var lead = anchor; // Process X-coordinate

        var moveX = this.__moveDirectionX__P_398_13;
        var nextX, locationX;

        while (moveX !== 0) {
          // Find next item to process depending on current scroll direction
          nextX = moveX > 0 ? this._getRelatedSelectable(lead, "right") : this._getRelatedSelectable(lead, "left"); // May be null (e.g. first/last item)

          if (nextX !== null) {
            locationX = this._getSelectableLocationX(nextX); // Continue when the item is in the visible area

            if (moveX > 0 && locationX.left <= relX || moveX < 0 && locationX.right >= relX) {
              lead = nextX;
              continue;
            }
          } // Otherwise break


          break;
        } // Process Y-coordinate


        var moveY = this.__moveDirectionY__P_398_14;
        var nextY, locationY;

        while (moveY !== 0) {
          // Find next item to process depending on current scroll direction
          nextY = moveY > 0 ? this._getRelatedSelectable(lead, "under") : this._getRelatedSelectable(lead, "above"); // May be null (e.g. first/last item)

          if (nextY !== null) {
            locationY = this._getSelectableLocationY(nextY); // Continue when the item is in the visible area

            if (moveY > 0 && locationY.top <= relY || moveY < 0 && locationY.bottom >= relY) {
              lead = nextY;
              continue;
            }
          } // Otherwise break


          break;
        } // Differenciate between the two supported modes


        var mode = this.getMode();

        if (mode === "multi") {
          // Replace current selection with new range
          this._selectItemRange(anchor, lead);
        } else if (mode === "additive") {
          // Behavior depends on the fact whether the
          // anchor item is selected or not
          if (this.isItemSelected(anchor)) {
            this._selectItemRange(anchor, lead, true);
          } else {
            this._deselectItemRange(anchor, lead);
          } // Improve performance. This mode does not rely
          // on full ranges as it always extend the old
          // selection/deselection.


          this._setAnchorItem(lead);
        } // Fire change event as needed


        this._fireChange("drag");
      },

      /*
      ---------------------------------------------------------------------------
        KEYBOARD SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * @type {Map} All supported navigation keys
       *
       * @lint ignoreReferenceField(__navigationKeys)
       */
      __navigationKeys__P_398_21: {
        Home: 1,
        Down: 1,
        Right: 1,
        PageDown: 1,
        End: 1,
        Up: 1,
        Left: 1,
        PageUp: 1
      },

      /**
       * This method should be connected to the <code>keypress</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.KeySequence} A valid key sequence event
       */
      handleKeyPress: function handleKeyPress(event) {
        // this is a method invoked by an user interaction, so be careful to
        // set / clear the mark this._userInteraction [BUG #3344]
        this._userInteraction = true;
        var current, next;
        var key = event.getKeyIdentifier();
        var mode = this.getMode(); // Support both control keys on Mac

        var isCtrlPressed = event.isCtrlPressed() || qx.core.Environment.get("os.name") == "osx" && event.isMetaPressed();
        var isShiftPressed = event.isShiftPressed();
        var consumed = false;

        if (key === "A" && isCtrlPressed) {
          if (mode !== "single" && mode !== "one") {
            this._selectAllItems();

            consumed = true;
          }
        } else if (key === "Escape") {
          if (mode !== "single" && mode !== "one") {
            this._clearSelection();

            consumed = true;
          }
        } else if (key === "Space") {
          var lead = this.getLeadItem();

          if (lead != null && !isShiftPressed) {
            if (isCtrlPressed || mode === "additive") {
              this._toggleInSelection(lead);
            } else {
              this._setSelectedItem(lead);
            }

            consumed = true;
          }
        } else if (this.__navigationKeys__P_398_21[key]) {
          consumed = true;

          if (mode === "single" || mode == "one") {
            current = this._getSelectedItem();
          } else {
            current = this.getLeadItem();
          }

          if (current !== null) {
            switch (key) {
              case "Home":
                next = this._getFirstSelectable();
                break;

              case "End":
                next = this._getLastSelectable();
                break;

              case "Up":
                next = this._getRelatedSelectable(current, "above");
                break;

              case "Down":
                next = this._getRelatedSelectable(current, "under");
                break;

              case "Left":
                next = this._getRelatedSelectable(current, "left");
                break;

              case "Right":
                next = this._getRelatedSelectable(current, "right");
                break;

              case "PageUp":
                next = this._getPage(current, true);
                break;

              case "PageDown":
                next = this._getPage(current, false);
                break;
            }
          } else {
            switch (key) {
              case "Home":
              case "Down":
              case "Right":
              case "PageDown":
                next = this._getFirstSelectable();
                break;

              case "End":
              case "Up":
              case "Left":
              case "PageUp":
                next = this._getLastSelectable();
                break;
            }
          } // Process result


          if (next !== null) {
            switch (mode) {
              case "single":
              case "one":
                this._setSelectedItem(next);

                break;

              case "additive":
                this._setLeadItem(next);

                break;

              case "multi":
                if (isShiftPressed) {
                  var anchor = this._getAnchorItem();

                  if (anchor === null) {
                    this._setAnchorItem(anchor = this._getFirstSelectable());
                  }

                  this._setLeadItem(next);

                  this._selectItemRange(anchor, next, isCtrlPressed);
                } else {
                  this._setAnchorItem(next);

                  this._setLeadItem(next);

                  if (!isCtrlPressed) {
                    this._setSelectedItem(next);
                  }
                }

                break;
            }

            this.__oldScrollTop__P_398_20 = this._getScroll().top;

            this._scrollItemIntoView(next);
          }
        }

        if (consumed) {
          // Stop processed events
          event.stop(); // Fire change event as needed

          this._fireChange("key");
        }

        this._userInteraction = false;
      },

      /*
      ---------------------------------------------------------------------------
        SUPPORT FOR ITEM RANGES
      ---------------------------------------------------------------------------
      */

      /**
       * Adds all items to the selection
       */
      _selectAllItems: function _selectAllItems() {
        var range = this.getSelectables();

        for (var i = 0, l = range.length; i < l; i++) {
          this._addToSelection(range[i]);
        }
      },

      /**
       * Clears current selection
       */
      _clearSelection: function _clearSelection() {
        var selection = this.__selection__P_398_0;

        for (var hash in selection) {
          this._removeFromSelection(selection[hash]);
        }

        this.__selection__P_398_0 = {};
      },

      /**
       * Select a range from <code>item1</code> to <code>item2</code>.
       *
       * @param item1 {Object} Start with this item
       * @param item2 {Object} End with this item
       * @param extend {Boolean?false} Whether the current
       *    selection should be replaced or extended.
       */
      _selectItemRange: function _selectItemRange(item1, item2, extend) {
        var range = this._getSelectableRange(item1, item2); // Remove items which are not in the detected range


        if (!extend) {
          var selected = this.__selection__P_398_0;

          var mapped = this.__rangeToMap__P_398_22(range);

          for (var hash in selected) {
            if (!mapped[hash]) {
              this._removeFromSelection(selected[hash]);
            }
          }
        } // Add new items to the selection


        for (var i = 0, l = range.length; i < l; i++) {
          this._addToSelection(range[i]);
        }
      },

      /**
       * Deselect all items between <code>item1</code> and <code>item2</code>.
       *
       * @param item1 {Object} Start with this item
       * @param item2 {Object} End with this item
       */
      _deselectItemRange: function _deselectItemRange(item1, item2) {
        var range = this._getSelectableRange(item1, item2);

        for (var i = 0, l = range.length; i < l; i++) {
          this._removeFromSelection(range[i]);
        }
      },

      /**
       * Internal method to convert a range to a map of hash
       * codes for faster lookup during selection compare routines.
       *
       * @param range {Array} List of selectable items
       */
      __rangeToMap__P_398_22: function __rangeToMap__P_398_22(range) {
        var mapped = {};
        var item;

        for (var i = 0, l = range.length; i < l; i++) {
          item = range[i];
          mapped[this._selectableToHashCode(item)] = item;
        }

        return mapped;
      },

      /*
      ---------------------------------------------------------------------------
        SINGLE ITEM QUERY AND MODIFICATION
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the first selected item. Only makes sense
       * when using manager in single selection mode.
       *
       * @return {var} The selected item (or <code>null</code>)
       */
      _getSelectedItem: function _getSelectedItem() {
        for (var hash in this.__selection__P_398_0) {
          return this.__selection__P_398_0[hash];
        }

        return null;
      },

      /**
       * Replace current selection with given item.
       *
       * @param item {var} Any valid selectable item
       */
      _setSelectedItem: function _setSelectedItem(item) {
        if (this._isSelectable(item)) {
          // If already selected try to find out if this is the only item
          var current = this.__selection__P_398_0;

          var hash = this._selectableToHashCode(item);

          if (!current[hash] || current.length >= 2) {
            this._clearSelection();

            this._addToSelection(item);
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        MODIFY ITEM SELECTION
      ---------------------------------------------------------------------------
      */

      /**
       * Adds an item to the current selection.
       *
       * @param item {Object} Any item
       */
      _addToSelection: function _addToSelection(item) {
        var hash = this._selectableToHashCode(item);

        if (this.__selection__P_398_0[hash] == null && this._isSelectable(item)) {
          this.__selection__P_398_0[hash] = item;

          this._styleSelectable(item, "selected", true);

          this.__selectionModified__P_398_15 = true;
        }
      },

      /**
       * Toggles the item e.g. remove it when already selected
       * or select it when currently not.
       *
       * @param item {Object} Any item
       */
      _toggleInSelection: function _toggleInSelection(item) {
        var hash = this._selectableToHashCode(item);

        if (this.__selection__P_398_0[hash] == null) {
          this.__selection__P_398_0[hash] = item;

          this._styleSelectable(item, "selected", true);
        } else {
          delete this.__selection__P_398_0[hash];

          this._styleSelectable(item, "selected", false);
        }

        this.__selectionModified__P_398_15 = true;
      },

      /**
       * Removes the given item from the current selection.
       *
       * @param item {Object} Any item
       */
      _removeFromSelection: function _removeFromSelection(item) {
        var hash = this._selectableToHashCode(item);

        if (this.__selection__P_398_0[hash] != null) {
          delete this.__selection__P_398_0[hash];

          this._styleSelectable(item, "selected", false);

          this.__selectionModified__P_398_15 = true;
        }
      },

      /**
       * Replaces current selection with items from given array.
       *
       * @param items {Array} List of items to select
       */
      _replaceMultiSelection: function _replaceMultiSelection(items) {
        if (items.length === 0) {
          this.clearSelection();
          return;
        }

        var modified = false; // Build map from hash codes and filter non-selectables

        var selectable, hash;
        var incoming = {};

        for (var i = 0, l = items.length; i < l; i++) {
          selectable = items[i];

          if (this._isSelectable(selectable)) {
            hash = this._selectableToHashCode(selectable);
            incoming[hash] = selectable;
          }
        } // Remember last


        var first = items[0];
        var last = selectable; // Clear old entries from map

        var current = this.__selection__P_398_0;

        for (var hash in current) {
          if (incoming[hash]) {
            // Reduce map to make next loop faster
            delete incoming[hash];
          } else {
            // update internal map
            selectable = current[hash];
            delete current[hash]; // apply styling

            this._styleSelectable(selectable, "selected", false); // remember that the selection has been modified


            modified = true;
          }
        } // Add remaining selectables to selection


        for (var hash in incoming) {
          // update internal map
          selectable = current[hash] = incoming[hash]; // apply styling

          this._styleSelectable(selectable, "selected", true); // remember that the selection has been modified


          modified = true;
        } // Do not do anything if selection is equal to previous one


        if (!modified) {
          return false;
        } // Scroll last incoming item into view


        this._scrollItemIntoView(last); // Reset anchor and lead item


        this._setLeadItem(first);

        this._setAnchorItem(first); // Finally fire change event


        this.__selectionModified__P_398_15 = true;

        this._fireChange();
      },

      /**
       * Fires the selection change event if the selection has
       * been modified.
       *
       * @param context {String} One of <code>tap</code>, <code>quick</code>,
       *    <code>drag</code> or <code>key</code> or <code>null</code>
       */
      _fireChange: function _fireChange(context) {
        if (this.__selectionModified__P_398_15) {
          // Store context
          this.__selectionContext__P_398_16 = context || null; // Fire data event which contains the current selection

          this.fireDataEvent("changeSelection", this.getSelection());
          delete this.__selectionModified__P_398_15;
        }
      },

      /**
       * Applies the default selection. The default item is the first item.
       *
       * @param force {Boolean} Whether the default selection should be forced.
       *
       * @return {var} The selected item.
       */
      _applyDefaultSelection: function _applyDefaultSelection(force) {
        if (force === true || this.getMode() === "one" && this.isSelectionEmpty()) {
          var first = this._getFirstSelectable();

          if (first != null) {
            this.selectItem(first);
          }

          return first;
        }

        return null;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__scrollTimer__P_398_3");

      this.__selection__P_398_0 = this.__pointerDownOnSelected__P_398_19 = this.__anchorItem__P_398_18 = null;
      this.__leadItem__P_398_17 = null;
    }
  });
  qx.ui.core.selection.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.selection.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.bom.element.Location": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * A selection manager, which handles the selection in widgets.
   */
  qx.Class.define("qx.ui.core.selection.Widget", {
    extend: qx.ui.core.selection.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param widget {qx.ui.core.Widget} The widget to connect to
     */
    construct: function construct(widget) {
      qx.ui.core.selection.Abstract.constructor.call(this);
      this.__widget__P_399_0 = widget;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __widget__P_399_0: null,

      /*
      ---------------------------------------------------------------------------
        BASIC SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _isSelectable: function _isSelectable(item) {
        return this._isItemSelectable(item) && item.getLayoutParent() === this.__widget__P_399_0;
      },
      // overridden
      _selectableToHashCode: function _selectableToHashCode(item) {
        return item.toHashCode();
      },
      // overridden
      _styleSelectable: function _styleSelectable(item, type, enabled) {
        enabled ? item.addState(type) : item.removeState(type);
      },
      // overridden
      _capture: function _capture() {
        this.__widget__P_399_0.capture();
      },
      // overridden
      _releaseCapture: function _releaseCapture() {
        this.__widget__P_399_0.releaseCapture();
      },

      /**
       * Helper to return the selectability of the item concerning the
       * user interaction.
       *
       * @param item {qx.ui.core.Widget} The item to check.
       * @return {Boolean} true, if the item is selectable.
       */
      _isItemSelectable: function _isItemSelectable(item) {
        if (this._userInteraction) {
          return item.isVisible() && item.isEnabled();
        } else {
          return item.isVisible();
        }
      },

      /**
       * Returns the connected widget.
       * @return {qx.ui.core.Widget} The widget
       */
      _getWidget: function _getWidget() {
        return this.__widget__P_399_0;
      },

      /*
      ---------------------------------------------------------------------------
        DIMENSION AND LOCATION
      ---------------------------------------------------------------------------
      */
      // overridden
      _getLocation: function _getLocation() {
        var elem = this.__widget__P_399_0.getContentElement().getDomElement();

        return elem ? qx.bom.element.Location.get(elem) : null;
      },
      // overridden
      _getDimension: function _getDimension() {
        return this.__widget__P_399_0.getInnerSize();
      },
      // overridden
      _getSelectableLocationX: function _getSelectableLocationX(item) {
        var computed = item.getBounds();

        if (computed) {
          return {
            left: computed.left,
            right: computed.left + computed.width
          };
        }
      },
      // overridden
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        var computed = item.getBounds();

        if (computed) {
          return {
            top: computed.top,
            bottom: computed.top + computed.height
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _getScroll: function _getScroll() {
        return {
          left: 0,
          top: 0
        };
      },
      // overridden
      _scrollBy: function _scrollBy(xoff, yoff) {// empty implementation
      },
      // overridden
      _scrollItemIntoView: function _scrollItemIntoView(item) {
        this.__widget__P_399_0.scrollChildIntoView(item);
      },

      /*
      ---------------------------------------------------------------------------
        QUERY SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      getSelectables: function getSelectables(all) {
        // if only the user selectables should be returned
        var oldUserInteraction = false;

        if (!all) {
          oldUserInteraction = this._userInteraction;
          this._userInteraction = true;
        }

        var children = this.__widget__P_399_0.getChildren();

        var result = [];
        var child;

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (this._isItemSelectable(child)) {
            result.push(child);
          }
        } // reset to the former user interaction state


        this._userInteraction = oldUserInteraction;
        return result;
      },
      // overridden
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        // Fast path for identical items
        if (item1 === item2) {
          return [item1];
        } // Iterate over children and collect all items
        // between the given two (including them)


        var children = this.__widget__P_399_0.getChildren();

        var result = [];
        var active = false;
        var child;

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (child === item1 || child === item2) {
            if (active) {
              result.push(child);
              break;
            } else {
              active = true;
            }
          }

          if (active && this._isItemSelectable(child)) {
            result.push(child);
          }
        }

        return result;
      },
      // overridden
      _getFirstSelectable: function _getFirstSelectable() {
        var children = this.__widget__P_399_0.getChildren();

        for (var i = 0, l = children.length; i < l; i++) {
          if (this._isItemSelectable(children[i])) {
            return children[i];
          }
        }

        return null;
      },
      // overridden
      _getLastSelectable: function _getLastSelectable() {
        var children = this.__widget__P_399_0.getChildren();

        for (var i = children.length - 1; i > 0; i--) {
          if (this._isItemSelectable(children[i])) {
            return children[i];
          }
        }

        return null;
      },
      // overridden
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        var vertical = this.__widget__P_399_0.getOrientation() === "vertical";

        var children = this.__widget__P_399_0.getChildren();

        var index = children.indexOf(item);
        var sibling;

        if (vertical && relation === "above" || !vertical && relation === "left") {
          for (var i = index - 1; i >= 0; i--) {
            sibling = children[i];

            if (this._isItemSelectable(sibling)) {
              return sibling;
            }
          }
        } else if (vertical && relation === "under" || !vertical && relation === "right") {
          for (var i = index + 1; i < children.length; i++) {
            sibling = children[i];

            if (this._isItemSelectable(sibling)) {
              return sibling;
            }
          }
        }

        return null;
      },
      // overridden
      _getPage: function _getPage(lead, up) {
        if (up) {
          return this._getFirstSelectable();
        } else {
          return this._getLastSelectable();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__widget__P_399_0 = null;
    }
  });
  qx.ui.core.selection.Widget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.selection.Widget": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * A selection manager, which handles the selection in widgets extending
   * {@link qx.ui.core.scroll.AbstractScrollArea}.
   */
  qx.Class.define("qx.ui.core.selection.ScrollArea", {
    extend: qx.ui.core.selection.Widget,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        BASIC SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _isSelectable: function _isSelectable(item) {
        return this._isItemSelectable(item) && item.getLayoutParent() === this._getWidget().getChildrenContainer();
      },

      /*
      ---------------------------------------------------------------------------
        DIMENSION AND LOCATION
      ---------------------------------------------------------------------------
      */
      // overridden
      _getDimension: function _getDimension() {
        return this._getWidget().getPaneSize();
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _getScroll: function _getScroll() {
        var widget = this._getWidget();

        return {
          left: widget.getScrollX(),
          top: widget.getScrollY()
        };
      },
      // overridden
      _scrollBy: function _scrollBy(xoff, yoff) {
        var widget = this._getWidget();

        widget.scrollByX(xoff);
        widget.scrollByY(yoff);
      },

      /*
      ---------------------------------------------------------------------------
        QUERY SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _getPage: function _getPage(lead, up) {
        var selectables = this.getSelectables();
        var length = selectables.length;
        var start = selectables.indexOf(lead); // Given lead is not a selectable?!?

        if (start === -1) {
          throw new Error("Invalid lead item: " + lead);
        }

        var widget = this._getWidget();

        var scrollTop = widget.getScrollY();
        var innerHeight = widget.getInnerSize().height;
        var top, bottom, found;

        if (up) {
          var min = scrollTop;
          var i = start; // Loop required to scroll pages up dynamically

          while (1) {
            // Iterate through all selectables from start
            for (; i >= 0; i--) {
              top = widget.getItemTop(selectables[i]); // This item is out of the visible block

              if (top < min) {
                // Use previous one
                found = i;
                break;
              }
            } // Nothing found. Return first item.


            if (found == null) {
              var first = this._getFirstSelectable();

              return first == lead ? null : first;
            } // Found item, but is identical to start or even before start item
            // Update min position and try on previous page


            if (found >= start) {
              // Reduce min by the distance of the lead item to the visible
              // bottom edge. This is needed instead of a simple subtraction
              // of the inner height to keep the last lead visible on page key
              // presses. This is the behavior of native toolkits as well.
              min -= innerHeight + scrollTop - widget.getItemBottom(lead);
              found = null;
              continue;
            } // Return selectable


            return selectables[found];
          }
        } else {
          var max = innerHeight + scrollTop;
          var i = start; // Loop required to scroll pages down dynamically

          while (1) {
            // Iterate through all selectables from start
            for (; i < length; i++) {
              bottom = widget.getItemBottom(selectables[i]); // This item is out of the visible block

              if (bottom > max) {
                // Use next one
                found = i;
                break;
              }
            } // Nothing found. Return last item.


            if (found == null) {
              var last = this._getLastSelectable();

              return last == lead ? null : last;
            } // Found item, but is identical to start or even before start item
            // Update max position and try on next page


            if (found <= start) {
              // Extend max by the distance of the lead item to the visible
              // top edge. This is needed instead of a simple addition
              // of the inner height to keep the last lead visible on page key
              // presses. This is the behavior of native toolkits as well.
              max += widget.getItemTop(lead) - scrollTop;
              found = null;
              continue;
            } // Return selectable


            return selectables[found];
          }
        }
      }
    }
  });
  qx.ui.core.selection.ScrollArea.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.lang.Object": {},
      "qx.ui.layout.Util": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The grid layout manager arranges the items in a two dimensional
   * grid. Widgets can be placed into the grid's cells and may span multiple rows
   * and columns.
   *
   * *Features*
   *
   * * Flex values for rows and columns
   * * Minimal and maximal column and row sizes
   * * Manually setting of column and row sizes
   * * Horizontal and vertical alignment
   * * Horizontal and vertical spacing
   * * Column and row spans
   * * Auto-sizing
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>row</strong> <em>(Integer)</em>: The row of the cell the
   *   widget should occupy. Each cell can only containing one widget. This layout
   *   property is mandatory.
   * </li>
   * <li><strong>column</strong> <em>(Integer)</em>: The column of the cell the
   *   widget should occupy. Each cell can only containing one widget. This layout
   *   property is mandatory.
   * </li>
   * <li><strong>rowSpan</strong> <em>(Integer)</em>: The number of rows, the
   *   widget should span, starting from the row specified in the <code>row</code>
   *   property. The cells in the spanned rows must be empty as well.
   * </li>
   * <li><strong>colSpan</strong> <em>(Integer)</em>: The number of columns, the
   *   widget should span, starting from the column specified in the <code>column</code>
   *   property. The cells in the spanned columns must be empty as well.
   * </li>
   * </ul>
   *
   * *Example*
   *
   * Here is a little example of how to use the grid layout.
   *
   * <pre class="javascript">
   * var layout = new qx.ui.layout.Grid();
   * layout.setRowFlex(0, 1); // make row 0 flexible
   * layout.setColumnWidth(1, 200); // set with of column 1 to 200 pixel
   *
   * var container = new qx.ui.container.Composite(layout);
   * container.add(new qx.ui.core.Widget(), {row: 0, column: 0});
   * container.add(new qx.ui.core.Widget(), {row: 0, column: 1});
   * container.add(new qx.ui.core.Widget(), {row: 1, column: 0, rowSpan: 2});
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='https://qooxdoo.org/documentation/#/desktop/layout/grid.md'>
   * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.
   */
  qx.Class.define("qx.ui.layout.Grid", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param spacingX {Integer?0} The horizontal spacing between grid cells.
     *     Sets {@link #spacingX}.
     * @param spacingY {Integer?0} The vertical spacing between grid cells.
     *     Sets {@link #spacingY}.
     */
    construct: function construct(spacingX, spacingY) {
      qx.ui.layout.Abstract.constructor.call(this);
      this.__rowData__P_436_0 = [];
      this.__colData__P_436_1 = [];

      if (spacingX) {
        this.setSpacingX(spacingX);
      }

      if (spacingY) {
        this.setSpacingY(spacingY);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The horizontal spacing between grid cells.
       */
      spacingX: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /**
       * The vertical spacing between grid cells.
       */
      spacingY: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /**
       * Allow growing of spanning cells' widths beyond the accumulated widths of the columns.
       * The default behavior (init value false) is that the width of the spanning cell is
       * determined by the accumulated width of the columns (plus spacing).
       * Setting this property to true lets the cell width grow as needed to show
       * the widget in the spanning cell, which also enlarges the width of the spanned columns.
       */
      allowGrowSpannedCellWidth: {
        check: "Boolean",
        init: false,
        apply: "_applyLayoutChange"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {Array} 2D array of grid cell data */
      __grid__P_436_2: null,
      __rowData__P_436_0: null,
      __colData__P_436_1: null,
      __colSpans__P_436_3: null,
      __rowSpans__P_436_4: null,
      __maxRowIndex__P_436_5: null,
      __maxColIndex__P_436_6: null,

      /** @type {Array} cached row heights */
      __rowHeights__P_436_7: null,

      /** @type {Array} cached column widths */
      __colWidths__P_436_8: null,
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        var layoutProperties = {
          "row": 1,
          "column": 1,
          "rowSpan": 1,
          "colSpan": 1
        };
        this.assert(layoutProperties[name] == 1, "The property '" + name + "' is not supported by the Grid layout!");
        this.assertInteger(value);
        this.assert(value >= 0, "Value must be positive");
      },

      /**
       * Rebuild the internal representation of the grid
       */
      __buildGrid__P_436_9: function __buildGrid__P_436_9() {
        var grid = [];
        var colSpans = [];
        var rowSpans = [];
        var maxRowIndex = -1;
        var maxColIndex = -1;

        var children = this._getLayoutChildren();

        for (var i = 0, l = children.length; i < l; i++) {
          var child = children[i];
          var props = child.getLayoutProperties();
          var row = props.row;
          var column = props.column;
          props.colSpan = props.colSpan || 1;
          props.rowSpan = props.rowSpan || 1; // validate arguments

          if (row == null || column == null) {
            throw new Error("The layout properties 'row' and 'column' of the child widget '" + child + "' must be defined!");
          }

          if (grid[row] && grid[row][column]) {
            throw new Error("Cannot add widget '" + child + "'!. " + "There is already a widget '" + grid[row][column] + "' in this cell (" + row + ", " + column + ") for '" + this + "'");
          }

          for (var x = column; x < column + props.colSpan; x++) {
            for (var y = row; y < row + props.rowSpan; y++) {
              if (grid[y] == undefined) {
                grid[y] = [];
              }

              grid[y][x] = child;
              maxColIndex = Math.max(maxColIndex, x);
              maxRowIndex = Math.max(maxRowIndex, y);
            }
          }

          if (props.rowSpan > 1) {
            rowSpans.push(child);
          }

          if (props.colSpan > 1) {
            colSpans.push(child);
          }
        } // make sure all columns are defined so that accessing the grid using
        // this.__grid[column][row] will never raise an exception


        for (var y = 0; y <= maxRowIndex; y++) {
          if (grid[y] == undefined) {
            grid[y] = [];
          }
        }

        this.__grid__P_436_2 = grid;
        this.__colSpans__P_436_3 = colSpans;
        this.__rowSpans__P_436_4 = rowSpans;
        this.__maxRowIndex__P_436_5 = maxRowIndex;
        this.__maxColIndex__P_436_6 = maxColIndex;
        this.__rowHeights__P_436_7 = null;
        this.__colWidths__P_436_8 = null; // Clear invalidation marker

        delete this._invalidChildrenCache;
      },

      /**
       * Stores data for a grid row
       *
       * @param row {Integer} The row index
       * @param key {String} The key under which the data should be stored
       * @param value {var} data to store
       */
      _setRowData: function _setRowData(row, key, value) {
        var rowData = this.__rowData__P_436_0[row];

        if (!rowData) {
          this.__rowData__P_436_0[row] = {};
          this.__rowData__P_436_0[row][key] = value;
        } else {
          rowData[key] = value;
        }
      },

      /**
       * Stores data for a grid column
       *
       * @param column {Integer} The column index
       * @param key {String} The key under which the data should be stored
       * @param value {var} data to store
       */
      _setColumnData: function _setColumnData(column, key, value) {
        var colData = this.__colData__P_436_1[column];

        if (!colData) {
          this.__colData__P_436_1[column] = {};
          this.__colData__P_436_1[column][key] = value;
        } else {
          colData[key] = value;
        }
      },

      /**
       * Shortcut to set both horizontal and vertical spacing between grid cells
       * to the same value.
       *
       * @param spacing {Integer} new horizontal and vertical spacing
       * @return {qx.ui.layout.Grid} This object (for chaining support).
       */
      setSpacing: function setSpacing(spacing) {
        this.setSpacingY(spacing);
        this.setSpacingX(spacing);
        return this;
      },

      /**
       * Set the default cell alignment for a column. This alignment can be
       * overridden on a per cell basis by setting the cell's content widget's
       * <code>alignX</code> and <code>alignY</code> properties.
       *
       * If on a grid cell both row and a column alignment is set, the horizontal
       * alignment is taken from the column and the vertical alignment is taken
       * from the row.
       *
       * @param column {Integer} Column index
       * @param hAlign {String} The horizontal alignment. Valid values are
       *    "left", "center" and "right".
       * @param vAlign {String} The vertical alignment. Valid values are
       *    "top", "middle", "bottom"
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnAlign: function setColumnAlign(column, hAlign, vAlign) {
        {
          this.assertInteger(column, "Invalid parameter 'column'");
          this.assertInArray(hAlign, ["left", "center", "right"]);
          this.assertInArray(vAlign, ["top", "middle", "bottom"]);
        }

        this._setColumnData(column, "hAlign", hAlign);

        this._setColumnData(column, "vAlign", vAlign);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get a map of the column's alignment.
       *
       * @param column {Integer} The column index
       * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>
       *     containing the vertical and horizontal column alignment.
       */
      getColumnAlign: function getColumnAlign(column) {
        var colData = this.__colData__P_436_1[column] || {};
        return {
          vAlign: colData.vAlign || "top",
          hAlign: colData.hAlign || "left"
        };
      },

      /**
       * Set the default cell alignment for a row. This alignment can be
       * overridden on a per cell basis by setting the cell's content widget's
       * <code>alignX</code> and <code>alignY</code> properties.
       *
       * If on a grid cell both row and a column alignment is set, the horizontal
       * alignment is taken from the column and the vertical alignment is taken
       * from the row.
       *
       * @param row {Integer} Row index
       * @param hAlign {String} The horizontal alignment. Valid values are
       *    "left", "center" and "right".
       * @param vAlign {String} The vertical alignment. Valid values are
       *    "top", "middle", "bottom"
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowAlign: function setRowAlign(row, hAlign, vAlign) {
        {
          this.assertInteger(row, "Invalid parameter 'row'");
          this.assertInArray(hAlign, ["left", "center", "right"]);
          this.assertInArray(vAlign, ["top", "middle", "bottom"]);
        }

        this._setRowData(row, "hAlign", hAlign);

        this._setRowData(row, "vAlign", vAlign);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get a map of the row's alignment.
       *
       * @param row {Integer} The Row index
       * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>
       *     containing the vertical and horizontal row alignment.
       */
      getRowAlign: function getRowAlign(row) {
        var rowData = this.__rowData__P_436_0[row] || {};
        return {
          vAlign: rowData.vAlign || "top",
          hAlign: rowData.hAlign || "left"
        };
      },

      /**
       * Get the widget located in the cell. If a the cell is empty or the widget
       * has a {@link qx.ui.core.Widget#visibility} value of <code>exclude</code>,
       * <code>null</code> is returned.
       *
       * @param row {Integer} The cell's row index
       * @param column {Integer} The cell's column index
       * @return {qx.ui.core.Widget|null}The cell's widget. The value may be null.
       */
      getCellWidget: function getCellWidget(row, column) {
        if (this._invalidChildrenCache) {
          this.__buildGrid__P_436_9();
        }

        var row = this.__grid__P_436_2[row] || {};
        return row[column] || null;
      },

      /**
       * Get the number of rows in the grid layout.
       *
       * @return {Integer} The number of rows in the layout
       */
      getRowCount: function getRowCount() {
        if (this._invalidChildrenCache) {
          this.__buildGrid__P_436_9();
        }

        return this.__maxRowIndex__P_436_5 + 1;
      },

      /**
       * Get the number of columns in the grid layout.
       *
       * @return {Integer} The number of columns in the layout
       */
      getColumnCount: function getColumnCount() {
        if (this._invalidChildrenCache) {
          this.__buildGrid__P_436_9();
        }

        return this.__maxColIndex__P_436_6 + 1;
      },

      /**
       * Get a map of the cell's alignment. For vertical alignment the row alignment
       * takes precedence over the column alignment. For horizontal alignment it is
       * the over way round. If an alignment is set on the cell widget using
       * {@link qx.ui.core.LayoutItem#setLayoutProperties}, this alignment takes
       * always precedence over row or column alignment.
       *
       * @param row {Integer} The cell's row index
       * @param column {Integer} The cell's column index
       * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>
       *     containing the vertical and horizontal cell alignment.
       */
      getCellAlign: function getCellAlign(row, column) {
        var vAlign = "top";
        var hAlign = "left";
        var rowData = this.__rowData__P_436_0[row];
        var colData = this.__colData__P_436_1[column];
        var widget = this.__grid__P_436_2[row][column];

        if (widget) {
          var widgetProps = {
            vAlign: widget.getAlignY(),
            hAlign: widget.getAlignX()
          };
        } else {
          widgetProps = {};
        } // compute vAlign
        // precedence : widget -> row -> column


        if (widgetProps.vAlign) {
          vAlign = widgetProps.vAlign;
        } else if (rowData && rowData.vAlign) {
          vAlign = rowData.vAlign;
        } else if (colData && colData.vAlign) {
          vAlign = colData.vAlign;
        } // compute hAlign
        // precedence : widget -> column -> row


        if (widgetProps.hAlign) {
          hAlign = widgetProps.hAlign;
        } else if (colData && colData.hAlign) {
          hAlign = colData.hAlign;
        } else if (rowData && rowData.hAlign) {
          hAlign = rowData.hAlign;
        }

        return {
          vAlign: vAlign,
          hAlign: hAlign
        };
      },

      /**
       * Set the flex value for a grid column.
       * By default the column flex value is <code>0</code>.
       *
       * @param column {Integer} The column index
       * @param flex {Integer} The column's flex value
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnFlex: function setColumnFlex(column, flex) {
        this._setColumnData(column, "flex", flex);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the flex value of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's flex value
       */
      getColumnFlex: function getColumnFlex(column) {
        var colData = this.__colData__P_436_1[column] || {};
        return colData.flex !== undefined ? colData.flex : 0;
      },

      /**
       * Set the flex value for a grid row.
       * By default the row flex value is <code>0</code>.
       *
       * @param row {Integer} The row index
       * @param flex {Integer} The row's flex value
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowFlex: function setRowFlex(row, flex) {
        this._setRowData(row, "flex", flex);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the flex value of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's flex value
       */
      getRowFlex: function getRowFlex(row) {
        var rowData = this.__rowData__P_436_0[row] || {};
        var rowFlex = rowData.flex !== undefined ? rowData.flex : 0;
        return rowFlex;
      },

      /**
       * Set the maximum width of a grid column.
       * The default value is <code>Infinity</code>.
       *
       * @param column {Integer} The column index
       * @param maxWidth {Integer} The column's maximum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnMaxWidth: function setColumnMaxWidth(column, maxWidth) {
        this._setColumnData(column, "maxWidth", maxWidth);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the maximum width of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's maximum width
       */
      getColumnMaxWidth: function getColumnMaxWidth(column) {
        var colData = this.__colData__P_436_1[column] || {};
        return colData.maxWidth !== undefined ? colData.maxWidth : Infinity;
      },

      /**
       * Set the preferred width of a grid column.
       * The default value is <code>Infinity</code>.
       *
       * @param column {Integer} The column index
       * @param width {Integer} The column's width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnWidth: function setColumnWidth(column, width) {
        this._setColumnData(column, "width", width);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the preferred width of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's width
       */
      getColumnWidth: function getColumnWidth(column) {
        var colData = this.__colData__P_436_1[column] || {};
        return colData.width !== undefined ? colData.width : null;
      },

      /**
       * Set the minimum width of a grid column.
       * The default value is <code>0</code>.
       *
       * @param column {Integer} The column index
       * @param minWidth {Integer} The column's minimum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnMinWidth: function setColumnMinWidth(column, minWidth) {
        this._setColumnData(column, "minWidth", minWidth);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the minimum width of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's minimum width
       */
      getColumnMinWidth: function getColumnMinWidth(column) {
        var colData = this.__colData__P_436_1[column] || {};
        return colData.minWidth || 0;
      },

      /**
       * Set the maximum height of a grid row.
       * The default value is <code>Infinity</code>.
       *
       * @param row {Integer} The row index
       * @param maxHeight {Integer} The row's maximum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowMaxHeight: function setRowMaxHeight(row, maxHeight) {
        this._setRowData(row, "maxHeight", maxHeight);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the maximum height of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's maximum width
       */
      getRowMaxHeight: function getRowMaxHeight(row) {
        var rowData = this.__rowData__P_436_0[row] || {};
        return rowData.maxHeight || Infinity;
      },

      /**
       * Set the preferred height of a grid row.
       * The default value is <code>Infinity</code>.
       *
       * @param row {Integer} The row index
       * @param height {Integer} The row's width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowHeight: function setRowHeight(row, height) {
        this._setRowData(row, "height", height);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the preferred height of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's width
       */
      getRowHeight: function getRowHeight(row) {
        var rowData = this.__rowData__P_436_0[row] || {};
        return rowData.height !== undefined ? rowData.height : null;
      },

      /**
       * Set the minimum height of a grid row.
       * The default value is <code>0</code>.
       *
       * @param row {Integer} The row index
       * @param minHeight {Integer} The row's minimum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowMinHeight: function setRowMinHeight(row, minHeight) {
        this._setRowData(row, "minHeight", minHeight);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the minimum height of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's minimum width
       */
      getRowMinHeight: function getRowMinHeight(row) {
        var rowData = this.__rowData__P_436_0[row] || {};
        return rowData.minHeight || 0;
      },

      /**
       * Computes the widget's size hint including the widget's margins
       *
       * @param widget {qx.ui.core.LayoutItem} The widget to get the size for
       * @return {Map} a size hint map
       */
      _getOuterSize: function _getOuterSize(widget) {
        var hint = widget.getSizeHint();
        var hMargins = widget.getMarginLeft() + widget.getMarginRight();
        var vMargins = widget.getMarginTop() + widget.getMarginBottom();
        var outerSize = {
          height: hint.height + vMargins,
          width: hint.width + hMargins,
          minHeight: hint.minHeight + vMargins,
          minWidth: hint.minWidth + hMargins,
          maxHeight: hint.maxHeight + vMargins,
          maxWidth: hint.maxWidth + hMargins
        };
        return outerSize;
      },

      /**
       * Check whether all row spans fit with their preferred height into the
       * preferred row heights. If there is not enough space, the preferred
       * row sizes are increased. The distribution respects the flex and max
       * values of the rows.
       *
       *  The same is true for the min sizes.
       *
       *  The height array is modified in place.
       *
       * @param rowHeights {Map[]} The current row height array as computed by
       *     {@link #_getRowHeights}.
       */
      _fixHeightsRowSpan: function _fixHeightsRowSpan(rowHeights) {
        var vSpacing = this.getSpacingY();

        for (var i = 0, l = this.__rowSpans__P_436_4.length; i < l; i++) {
          var widget = this.__rowSpans__P_436_4[i];

          var hint = this._getOuterSize(widget);

          var widgetProps = widget.getLayoutProperties();
          var widgetRow = widgetProps.row;
          var prefSpanHeight = vSpacing * (widgetProps.rowSpan - 1);
          var minSpanHeight = prefSpanHeight;
          var rowFlexes = {};

          for (var j = 0; j < widgetProps.rowSpan; j++) {
            var row = widgetProps.row + j;
            var rowHeight = rowHeights[row];
            var rowFlex = this.getRowFlex(row);

            if (rowFlex > 0) {
              // compute flex array for the preferred height
              rowFlexes[row] = {
                min: rowHeight.minHeight,
                value: rowHeight.height,
                max: rowHeight.maxHeight,
                flex: rowFlex
              };
            }

            prefSpanHeight += rowHeight.height;
            minSpanHeight += rowHeight.minHeight;
          } // If there is not enough space for the preferred size
          // increment the preferred row sizes.


          if (prefSpanHeight < hint.height) {
            if (!qx.lang.Object.isEmpty(rowFlexes)) {
              var rowIncrements = qx.ui.layout.Util.computeFlexOffsets(rowFlexes, hint.height, prefSpanHeight);

              for (var k = 0; k < widgetProps.rowSpan; k++) {
                var offset = rowIncrements[widgetRow + k] ? rowIncrements[widgetRow + k].offset : 0;
                rowHeights[widgetRow + k].height += offset;
              } // row is too small and we have no flex value set

            } else {
              var totalSpacing = vSpacing * (widgetProps.rowSpan - 1);
              var availableHeight = hint.height - totalSpacing; // get the row height which every child would need to share the
              // available hight equally

              var avgRowHeight = Math.floor(availableHeight / widgetProps.rowSpan); // get the hight already used and the number of children which do
              // not have at least that avg row height

              var usedHeight = 0;
              var rowsNeedAddition = 0;

              for (var k = 0; k < widgetProps.rowSpan; k++) {
                var currentHeight = rowHeights[widgetRow + k].height;
                usedHeight += currentHeight;

                if (currentHeight < avgRowHeight) {
                  rowsNeedAddition++;
                }
              } // the difference of available and used needs to be shared among
              // those not having the min size


              var additionalRowHeight = Math.floor((availableHeight - usedHeight) / rowsNeedAddition); // add the extra height to the too small children

              for (var k = 0; k < widgetProps.rowSpan; k++) {
                if (rowHeights[widgetRow + k].height < avgRowHeight) {
                  rowHeights[widgetRow + k].height += additionalRowHeight;
                }
              }
            }
          } // If there is not enough space for the min size
          // increment the min row sizes.


          if (minSpanHeight < hint.minHeight) {
            var rowIncrements = qx.ui.layout.Util.computeFlexOffsets(rowFlexes, hint.minHeight, minSpanHeight);

            for (var j = 0; j < widgetProps.rowSpan; j++) {
              var offset = rowIncrements[widgetRow + j] ? rowIncrements[widgetRow + j].offset : 0;
              rowHeights[widgetRow + j].minHeight += offset;
            }
          }
        }
      },

      /**
       * Check whether all col spans fit with their preferred width into the
       * preferred column widths. If there is not enough space the preferred
       * column sizes are increased. The distribution respects the flex and max
       * values of the columns.
       *
       *  The same is true for the min sizes.
       *
       *  The width array is modified in place.
       *
       * @param colWidths {Map[]} The current column width array as computed by
       *     {@link #_getColWidths}.
       */
      _fixWidthsColSpan: function _fixWidthsColSpan(colWidths) {
        var hSpacing = this.getSpacingX();

        var colSpans = this._getColSpans();

        for (var i = 0, l = colSpans.length; i < l; i++) {
          var widget = colSpans[i];

          var hint = this._getOuterSize(widget);

          var widgetProps = widget.getLayoutProperties();
          var widgetColumn = widgetProps.column;
          var prefSpanWidth = hSpacing * (widgetProps.colSpan - 1);
          var minSpanWidth = prefSpanWidth;
          var colFlexes = {};
          var offset;

          for (var j = 0; j < widgetProps.colSpan; j++) {
            var col = widgetProps.column + j;
            var colWidth = colWidths[col];
            var colFlex = this.getColumnFlex(col); // compute flex array for the preferred width

            if (colFlex > 0) {
              colFlexes[col] = {
                min: colWidth.minWidth,
                value: colWidth.width,
                max: colWidth.maxWidth,
                flex: colFlex
              };
            }

            prefSpanWidth += colWidth.width;
            minSpanWidth += colWidth.minWidth;
          } // If there is not enough space for the preferred size
          // increment the preferred column sizes.


          if (prefSpanWidth < hint.width) {
            // Do not adapt column widths to the width
            // of the spanning cell if allowGrowSpannedCellWidth property
            // is set to false
            // See https://github.com/qooxdoo/qooxdoo/issues/9871
            if (!this.getAllowGrowSpannedCellWidth() || !qx.lang.Object.isEmpty(colFlexes)) {
              var colIncrements = qx.ui.layout.Util.computeFlexOffsets(colFlexes, hint.width, prefSpanWidth);

              for (var j = 0; j < widgetProps.colSpan; j++) {
                offset = colIncrements[widgetColumn + j] ? colIncrements[widgetColumn + j].offset : 0;
                colWidths[widgetColumn + j].width += offset;
              } // col is too small and we have no flex value set

            } else {
              var totalSpacing = hSpacing * (widgetProps.colSpan - 1);
              var availableWidth = hint.width - totalSpacing; // get the col width which every child would need to share the
              // available width equally

              var avgColWidth = Math.floor(availableWidth / widgetProps.colSpan); // get the width already used and the number of children which do
              // not have at least that avg col width

              var usedWidth = 0;
              var colsNeedAddition = 0;

              for (var k = 0; k < widgetProps.colSpan; k++) {
                var currentWidth = colWidths[widgetColumn + k].width;
                usedWidth += currentWidth;

                if (currentWidth < avgColWidth) {
                  colsNeedAddition++;
                }
              } // the difference of available and used needs to be shared among
              // those not having the min size


              var additionalColWidth = Math.floor((availableWidth - usedWidth) / colsNeedAddition); // add the extra width to the too small children

              for (var k = 0; k < widgetProps.colSpan; k++) {
                if (colWidths[widgetColumn + k].width < avgColWidth) {
                  colWidths[widgetColumn + k].width += additionalColWidth;
                }
              }
            }
          } // If there is not enough space for the min size
          // increment the min column sizes.


          if (minSpanWidth < hint.minWidth) {
            var colIncrements = qx.ui.layout.Util.computeFlexOffsets(colFlexes, hint.minWidth, minSpanWidth);

            for (var j = 0; j < widgetProps.colSpan; j++) {
              offset = colIncrements[widgetColumn + j] ? colIncrements[widgetColumn + j].offset : 0;
              colWidths[widgetColumn + j].minWidth += offset;
            }
          }
        }
      },

      /**
       * Compute the min/pref/max row heights.
       *
       * @return {Map[]} An array containing height information for each row. The
       *     entries have the keys <code>minHeight</code>, <code>maxHeight</code> and
       *     <code>height</code>.
       */
      _getRowHeights: function _getRowHeights() {
        if (this.__rowHeights__P_436_7 != null) {
          return this.__rowHeights__P_436_7;
        }

        var rowHeights = [];
        var maxRowIndex = this.__maxRowIndex__P_436_5;
        var maxColIndex = this.__maxColIndex__P_436_6;

        for (var row = 0; row <= maxRowIndex; row++) {
          var minHeight = 0;
          var height = 0;
          var maxHeight = 0;

          for (var col = 0; col <= maxColIndex; col++) {
            var widget = this.__grid__P_436_2[row][col];

            if (!widget) {
              continue;
            } // ignore rows with row spans at this place
            // these rows will be taken into account later


            var widgetRowSpan = widget.getLayoutProperties().rowSpan || 0;

            if (widgetRowSpan > 1) {
              continue;
            }

            var cellSize = this._getOuterSize(widget);

            if (this.getRowFlex(row) > 0) {
              minHeight = Math.max(minHeight, cellSize.minHeight);
            } else {
              minHeight = Math.max(minHeight, cellSize.height);
            }

            height = Math.max(height, cellSize.height);
          }

          var minHeight = Math.max(minHeight, this.getRowMinHeight(row));
          var maxHeight = this.getRowMaxHeight(row);

          if (this.getRowHeight(row) !== null) {
            var height = this.getRowHeight(row);
          } else {
            var height = Math.max(minHeight, Math.min(height, maxHeight));
          }

          rowHeights[row] = {
            minHeight: minHeight,
            height: height,
            maxHeight: maxHeight
          };
        }

        if (this.__rowSpans__P_436_4.length > 0) {
          this._fixHeightsRowSpan(rowHeights);
        }

        this.__rowHeights__P_436_7 = rowHeights;
        return rowHeights;
      },

      /**
       * Compute the min/pref/max column widths.
       *
       * @return {Map[]} An array containing width information for each column. The
       *     entries have the keys <code>minWidth</code>, <code>maxWidth</code> and
       *     <code>width</code>.
       */
      _getColWidths: function _getColWidths() {
        if (this.__colWidths__P_436_8 != null) {
          return this.__colWidths__P_436_8;
        }

        var colWidths = [];
        var maxColIndex = this.__maxColIndex__P_436_6;
        var maxRowIndex = this.__maxRowIndex__P_436_5;

        for (var col = 0; col <= maxColIndex; col++) {
          var width = 0;
          var minWidth = 0;
          var maxWidth = Infinity;

          for (var row = 0; row <= maxRowIndex; row++) {
            var widget = this.__grid__P_436_2[row][col];

            if (!widget) {
              continue;
            } // ignore columns with col spans at this place
            // these columns will be taken into account later


            var widgetColSpan = widget.getLayoutProperties().colSpan || 0;

            if (widgetColSpan > 1) {
              continue;
            }

            var cellSize = this._getOuterSize(widget);

            minWidth = Math.max(minWidth, cellSize.minWidth);
            width = Math.max(width, cellSize.width);
          }

          minWidth = Math.max(minWidth, this.getColumnMinWidth(col));
          maxWidth = this.getColumnMaxWidth(col);

          if (this.getColumnWidth(col) !== null) {
            var width = this.getColumnWidth(col);
          } else {
            var width = Math.max(minWidth, Math.min(width, maxWidth));
          }

          colWidths[col] = {
            minWidth: minWidth,
            width: width,
            maxWidth: maxWidth
          };
        }

        if (this._getColSpans().length > 0) {
          this._fixWidthsColSpan(colWidths);
        }

        this.__colWidths__P_436_8 = colWidths;
        return colWidths;
      },

      /**
       * Computes for each column by how many pixels it must grow or shrink, taking
       * the column flex values and min/max widths into account.
       *
       * @param width {Integer} The grid width
       * @return {Integer[]} Sparse array of offsets to add to each column width. If
       *     an array entry is empty nothing should be added to the column.
       */
      _getColumnFlexOffsets: function _getColumnFlexOffsets(width) {
        var hint = this.getSizeHint();
        var diff = width - hint.width;

        if (diff == 0) {
          return {};
        } // collect all flexible children


        var colWidths = this._getColWidths();

        var flexibles = {};

        for (var i = 0, l = colWidths.length; i < l; i++) {
          var col = colWidths[i];
          var colFlex = this.getColumnFlex(i);

          if (colFlex <= 0 || col.width == col.maxWidth && diff > 0 || col.width == col.minWidth && diff < 0) {
            continue;
          }

          flexibles[i] = {
            min: col.minWidth,
            value: col.width,
            max: col.maxWidth,
            flex: colFlex
          };
        }

        return qx.ui.layout.Util.computeFlexOffsets(flexibles, width, hint.width);
      },

      /**
       * Computes for each row by how many pixels it must grow or shrink, taking
       * the row flex values and min/max heights into account.
       *
       * @param height {Integer} The grid height
       * @return {Integer[]} Sparse array of offsets to add to each row height. If
       *     an array entry is empty nothing should be added to the row.
       */
      _getRowFlexOffsets: function _getRowFlexOffsets(height) {
        var hint = this.getSizeHint();
        var diff = height - hint.height;

        if (diff == 0) {
          return {};
        } // collect all flexible children


        var rowHeights = this._getRowHeights();

        var flexibles = {};

        for (var i = 0, l = rowHeights.length; i < l; i++) {
          var row = rowHeights[i];
          var rowFlex = this.getRowFlex(i);

          if (rowFlex <= 0 || row.height == row.maxHeight && diff > 0 || row.height == row.minHeight && diff < 0) {
            continue;
          }

          flexibles[i] = {
            min: row.minHeight,
            value: row.height,
            max: row.maxHeight,
            flex: rowFlex
          };
        }

        return qx.ui.layout.Util.computeFlexOffsets(flexibles, height, hint.height);
      },

      /**
       * Returns the internal private __colSpans array in order
       * have a protected getter which can be used other methods
       * to make them overridable
       *
       * @return {Array} the __colSpans array
       */
      _getColSpans: function _getColSpans() {
        return this.__colSpans__P_436_3;
      },
      // overridden
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        if (this._invalidChildrenCache) {
          this.__buildGrid__P_436_9();
        }

        var Util = qx.ui.layout.Util;
        var hSpacing = this.getSpacingX();
        var vSpacing = this.getSpacingY(); // calculate column widths

        var prefWidths = this._getColWidths();

        var colStretchOffsets = this._getColumnFlexOffsets(availWidth);

        var colWidths = [];
        var maxColIndex = this.__maxColIndex__P_436_6;
        var maxRowIndex = this.__maxRowIndex__P_436_5;
        var offset;

        for (var col = 0; col <= maxColIndex; col++) {
          offset = colStretchOffsets[col] ? colStretchOffsets[col].offset : 0;
          colWidths[col] = prefWidths[col].width + offset;
        } // calculate row heights


        var prefHeights = this._getRowHeights();

        var rowStretchOffsets = this._getRowFlexOffsets(availHeight);

        var rowHeights = [];

        for (var row = 0; row <= maxRowIndex; row++) {
          offset = rowStretchOffsets[row] ? rowStretchOffsets[row].offset : 0;
          rowHeights[row] = prefHeights[row].height + offset;
        } // do the layout


        var left = 0;

        for (var col = 0; col <= maxColIndex; col++) {
          var top = 0;

          for (var row = 0; row <= maxRowIndex; row++) {
            var widget = this.__grid__P_436_2[row][col]; // ignore empty cells

            if (!widget) {
              top += rowHeights[row] + vSpacing;
              continue;
            }

            var widgetProps = widget.getLayoutProperties(); // ignore cells, which have cell spanning but are not the origin
            // of the widget

            if (widgetProps.row !== row || widgetProps.column !== col) {
              top += rowHeights[row] + vSpacing;
              continue;
            } // compute sizes width including cell spanning


            var spanWidth = hSpacing * (widgetProps.colSpan - 1);

            for (var i = 0; i < widgetProps.colSpan; i++) {
              spanWidth += colWidths[col + i];
            }

            var spanHeight = vSpacing * (widgetProps.rowSpan - 1);

            for (var i = 0; i < widgetProps.rowSpan; i++) {
              spanHeight += rowHeights[row + i];
            }

            var cellHint = widget.getSizeHint();
            var marginTop = widget.getMarginTop();
            var marginLeft = widget.getMarginLeft();
            var marginBottom = widget.getMarginBottom();
            var marginRight = widget.getMarginRight();
            var cellWidth = Math.max(cellHint.minWidth, Math.min(spanWidth - marginLeft - marginRight, cellHint.maxWidth));
            var cellHeight = Math.max(cellHint.minHeight, Math.min(spanHeight - marginTop - marginBottom, cellHint.maxHeight));
            var cellAlign = this.getCellAlign(row, col);
            var cellLeft = left + Util.computeHorizontalAlignOffset(cellAlign.hAlign, cellWidth, spanWidth, marginLeft, marginRight);
            var cellTop = top + Util.computeVerticalAlignOffset(cellAlign.vAlign, cellHeight, spanHeight, marginTop, marginBottom);
            widget.renderLayout(cellLeft + padding.left, cellTop + padding.top, cellWidth, cellHeight);
            top += rowHeights[row] + vSpacing;
          }

          left += colWidths[col] + hSpacing;
        }
      },
      // overridden
      invalidateLayoutCache: function invalidateLayoutCache() {
        qx.ui.layout.Grid.prototype.invalidateLayoutCache.base.call(this);
        this.__colWidths__P_436_8 = null;
        this.__rowHeights__P_436_7 = null;
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        if (this._invalidChildrenCache) {
          this.__buildGrid__P_436_9();
        } // calculate col widths


        var colWidths = this._getColWidths();

        var minWidth = 0,
            width = 0;

        for (var i = 0, l = colWidths.length; i < l; i++) {
          var col = colWidths[i];

          if (this.getColumnFlex(i) > 0) {
            minWidth += col.minWidth;
          } else {
            minWidth += col.width;
          }

          width += col.width;
        } // calculate row heights


        var rowHeights = this._getRowHeights();

        var minHeight = 0,
            height = 0;

        for (var i = 0, l = rowHeights.length; i < l; i++) {
          var row = rowHeights[i];

          if (this.getRowFlex(i) > 0) {
            minHeight += row.minHeight;
          } else {
            minHeight += row.height;
          }

          height += row.height;
        }

        var spacingX = this.getSpacingX() * (colWidths.length - 1);
        var spacingY = this.getSpacingY() * (rowHeights.length - 1);
        var hint = {
          minWidth: minWidth + spacingX,
          width: width + spacingX,
          minHeight: minHeight + spacingY,
          height: height + spacingY
        };
        return hint;
      }
    },

    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__grid__P_436_2 = this.__rowData__P_436_0 = this.__colData__P_436_1 = this.__colSpans__P_436_3 = this.__rowSpans__P_436_4 = this.__colWidths__P_436_8 = this.__rowHeights__P_436_7 = null;
    }
  });
  qx.ui.layout.Grid.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.scroll.AbstractScrollArea": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.IMultiSelection": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IModelSelection": {
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.core.MMultiSelectionHandling": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelSelection": {
        "require": true
      },
      "qx.ui.core.selection.ScrollArea": {
        "require": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.layout.VBox": {},
      "qx.bom.element.Attribute": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A list of items. Displays an automatically scrolling list for all
   * added {@link qx.ui.form.ListItem} instances. Supports various
   * selection options: single, multi, ...
   */
  qx.Class.define("qx.ui.form.List", {
    extend: qx.ui.core.scroll.AbstractScrollArea,
    implement: [qx.ui.core.IMultiSelection, qx.ui.form.IForm, qx.ui.form.IField, qx.ui.form.IModelSelection],
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.core.MMultiSelectionHandling, qx.ui.form.MForm, qx.ui.form.MModelSelection],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param horizontal {Boolean?false} Whether the list should be horizontal.
     */
    construct: function construct(horizontal) {
      qx.ui.core.scroll.AbstractScrollArea.constructor.call(this); // Create content

      this.__content__P_415_0 = this._createListItemContainer(); // Used to fire item add/remove events

      this.__content__P_415_0.addListener("addChildWidget", this._onAddChild, this);

      this.__content__P_415_0.addListener("removeChildWidget", this._onRemoveChild, this); // Add to scrollpane


      this.getChildControl("pane").add(this.__content__P_415_0); // Apply orientation

      if (horizontal) {
        this.setOrientation("horizontal");
      } else {
        this.initOrientation();
      } // Add keypress listener


      this.addListener("keypress", this._onKeyPress);
      this.addListener("keyinput", this._onKeyInput); // initialize the search string

      this.__pressedString__P_415_1 = "";
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * This event is fired after a list item was added to the list. The
       * {@link qx.event.type.Data#getData} method of the event returns the
       * added item.
       */
      addItem: "qx.event.type.Data",

      /**
       * This event is fired after a list item has been removed from the list.
       * The {@link qx.event.type.Data#getData} method of the event returns the
       * removed item.
       */
      removeItem: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "list"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 100
      },
      // overridden
      height: {
        refine: true,
        init: 200
      },

      /**
       * Whether the list should be rendered horizontal or vertical.
       */
      orientation: {
        check: ["horizontal", "vertical"],
        init: "vertical",
        apply: "_applyOrientation"
      },

      /** Spacing between the items */
      spacing: {
        check: "Integer",
        init: 0,
        apply: "_applySpacing",
        themeable: true
      },

      /** Controls whether the inline-find feature is activated or not */
      enableInlineFind: {
        check: "Boolean",
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __pressedString__P_415_1: null,
      __lastKeyPress__P_415_2: null,

      /** @type {qx.ui.core.Widget} The children container */
      __content__P_415_0: null,

      /** @type {Class} Pointer to the selection manager to use */
      SELECTION_MANAGER: qx.ui.core.selection.ScrollArea,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      getChildrenContainer: function getChildrenContainer() {
        return this.__content__P_415_0;
      },

      /**
       * Handle child widget adds on the content pane
       *
       * @param e {qx.event.type.Data} the event instance
       */
      _onAddChild: function _onAddChild(e) {
        this.fireDataEvent("addItem", e.getData());
      },

      /**
       * Handle child widget removes on the content pane
       *
       * @param e {qx.event.type.Data} the event instance
       */
      _onRemoveChild: function _onRemoveChild(e) {
        this.fireDataEvent("removeItem", e.getData());
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Used to route external <code>keypress</code> events to the list
       * handling (in fact the manager of the list)
       *
       * @param e {qx.event.type.KeySequence} KeyPress event
       */
      handleKeyPress: function handleKeyPress(e) {
        if (!this._onKeyPress(e)) {
          this._getManager().handleKeyPress(e);
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROTECTED API
      ---------------------------------------------------------------------------
      */

      /**
       * This container holds the list item widgets.
       *
       * @return {qx.ui.container.Composite} Container for the list item widgets
       */
      _createListItemContainer: function _createListItemContainer() {
        return new qx.ui.container.Composite();
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        var content = this.__content__P_415_0; // save old layout for disposal

        var oldLayout = content.getLayout(); // Create new layout

        var horizontal = value === "horizontal";
        var layout = horizontal ? new qx.ui.layout.HBox() : new qx.ui.layout.VBox(); // Configure content

        content.setLayout(layout);
        content.setAllowGrowX(!horizontal);
        content.setAllowGrowY(horizontal); // Configure spacing

        this._applySpacing(this.getSpacing()); // dispose old layout


        if (oldLayout) {
          oldLayout.dispose();
        }
      },
      // property apply
      _applySpacing: function _applySpacing(value, old) {
        this.__content__P_415_0.getLayout().setSpacing(value);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for <code>keypress</code> events.
       *
       * @param e {qx.event.type.KeySequence} KeyPress event
       * @return {Boolean} Whether the event was processed
       */
      _onKeyPress: function _onKeyPress(e) {
        // Execute action on press <ENTER>
        if (e.getKeyIdentifier() == "Enter" && !e.isAltPressed()) {
          var items = this.getSelection();

          for (var i = 0; i < items.length; i++) {
            items[i].fireEvent("action");
          }

          return true;
        }

        return false;
      },

      /*
      ---------------------------------------------------------------------------
        FIND SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Handles the inline find - if enabled
       *
       * @param e {qx.event.type.KeyInput} key input event
       */
      _onKeyInput: function _onKeyInput(e) {
        // do nothing if the find is disabled
        if (!this.getEnableInlineFind()) {
          return;
        } // Only useful in single or one selection mode


        var mode = this.getSelectionMode();

        if (!(mode === "single" || mode === "one")) {
          return;
        } // Reset string after a second of non pressed key


        if (new Date().valueOf() - this.__lastKeyPress__P_415_2 > 1000) {
          this.__pressedString__P_415_1 = "";
        } // Combine keys the user pressed to a string


        this.__pressedString__P_415_1 += e.getChar(); // Find matching item

        var matchedItem = this.findItemByLabelFuzzy(this.__pressedString__P_415_1); // if an item was found, select it

        if (matchedItem) {
          this.setSelection([matchedItem]);
        } // Store timestamp


        this.__lastKeyPress__P_415_2 = new Date().valueOf();
      },

      /**
       * Takes the given string and tries to find a ListItem
       * which starts with this string. The search is not case sensitive and the
       * first found ListItem will be returned. If there could not be found any
       * qualifying list item, null will be returned.
       *
       * @param search {String} The text with which the label of the ListItem should start with
       * @return {qx.ui.form.ListItem} The found ListItem or null
       */
      findItemByLabelFuzzy: function findItemByLabelFuzzy(search) {
        // lower case search text
        search = search.toLowerCase(); // get all items of the list

        var items = this.getChildren(); // go threw all items

        for (var i = 0, l = items.length; i < l; i++) {
          // get the label of the current item
          var currentLabel = items[i].getLabel(); // if the label fits with the search text (ignore case, begins with)

          if (currentLabel && currentLabel.toLowerCase().indexOf(search) == 0) {
            // just return the first found element
            return items[i];
          }
        } // if no element was found, return null


        return null;
      },

      /**
       * Find an item by its {@link qx.ui.basic.Atom#getLabel}.
       *
       * @param search {String} A label or any item
       * @param ignoreCase {Boolean?true} description
       * @return {qx.ui.form.ListItem} The found ListItem or null
       */
      findItem: function findItem(search, ignoreCase) {
        // lowercase search
        if (ignoreCase !== false) {
          search = search.toLowerCase();
        }

        ; // get all items of the list

        var items = this.getChildren();
        var item; // go through all items

        for (var i = 0, l = items.length; i < l; i++) {
          item = items[i]; // get the content of the label; text content when rich

          var label;

          if (item.isRich()) {
            var control = item.getChildControl("label", true);

            if (control) {
              var labelNode = control.getContentElement().getDomElement();

              if (labelNode) {
                label = qx.bom.element.Attribute.get(labelNode, "text");
              }
            }
          } else {
            label = item.getLabel();
          }

          if (label != null) {
            if (label.translate) {
              label = label.translate();
            }

            if (ignoreCase !== false) {
              label = label.toLowerCase();
            }

            if (label.toString() == search.toString()) {
              return item;
            }
          }
        }

        return null;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__content__P_415_0");
    }
  });
  qx.ui.form.List.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This mixin defines the <code>contentPadding</code> property, which is used
   * by widgets like the window or group box, which must have a property, which
   * defines the padding of an inner pane.
   *
   * The including class must implement the method
   * <code>_getContentPaddingTarget</code>, which must return the widget on which
   * the padding should be applied.
   */
  qx.Mixin.define("qx.ui.core.MContentPadding", {
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Top padding of the content pane */
      contentPaddingTop: {
        check: "Integer",
        init: 0,
        apply: "_applyContentPadding",
        themeable: true
      },

      /** Right padding of the content pane */
      contentPaddingRight: {
        check: "Integer",
        init: 0,
        apply: "_applyContentPadding",
        themeable: true
      },

      /** Bottom padding of the content pane */
      contentPaddingBottom: {
        check: "Integer",
        init: 0,
        apply: "_applyContentPadding",
        themeable: true
      },

      /** Left padding of the content pane */
      contentPaddingLeft: {
        check: "Integer",
        init: 0,
        apply: "_applyContentPadding",
        themeable: true
      },

      /**
       * The 'contentPadding' property is a shorthand property for setting 'contentPaddingTop',
       * 'contentPaddingRight', 'contentPaddingBottom' and 'contentPaddingLeft'
       * at the same time.
       *
       * If four values are specified they apply to top, right, bottom and left respectively.
       * If there is only one value, it applies to all sides, if there are two or three,
       * the missing values are taken from the opposite side.
       */
      contentPadding: {
        group: ["contentPaddingTop", "contentPaddingRight", "contentPaddingBottom", "contentPaddingLeft"],
        mode: "shorthand",
        themeable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * @type {Map} Maps property names of content padding to the setter of the padding
       *
       * @lint ignoreReferenceField(__contentPaddingSetter)
       */
      __contentPaddingSetter__P_378_0: {
        contentPaddingTop: "setPaddingTop",
        contentPaddingRight: "setPaddingRight",
        contentPaddingBottom: "setPaddingBottom",
        contentPaddingLeft: "setPaddingLeft"
      },

      /**
       * @type {Map} Maps property names of content padding to the themed setter of the padding
       *
       * @lint ignoreReferenceField(__contentPaddingThemedSetter)
       */
      __contentPaddingThemedSetter__P_378_1: {
        contentPaddingTop: "setThemedPaddingTop",
        contentPaddingRight: "setThemedPaddingRight",
        contentPaddingBottom: "setThemedPaddingBottom",
        contentPaddingLeft: "setThemedPaddingLeft"
      },

      /**
       * @type {Map} Maps property names of content padding to the resetter of the padding
       *
       * @lint ignoreReferenceField(__contentPaddingResetter)
       */
      __contentPaddingResetter__P_378_2: {
        contentPaddingTop: "resetPaddingTop",
        contentPaddingRight: "resetPaddingRight",
        contentPaddingBottom: "resetPaddingBottom",
        contentPaddingLeft: "resetPaddingLeft"
      },
      // property apply
      _applyContentPadding: function _applyContentPadding(value, old, name, variant) {
        var target = this._getContentPaddingTarget();

        if (value == null) {
          var resetter = this.__contentPaddingResetter__P_378_2[name];
          target[resetter]();
        } else {
          // forward the themed sates if case the apply was invoked by a theme
          if (variant == "setThemed" || variant == "resetThemed") {
            var setter = this.__contentPaddingThemedSetter__P_378_1[name];
            target[setter](value);
          } else {
            var setter = this.__contentPaddingSetter__P_378_0[name];
            target[setter](value);
          }
        }
      }
    }
  });
  qx.ui.core.MContentPadding.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.INumberForm": {
        "require": true
      },
      "qx.ui.form.IRange": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.event.type.Focus": {
        "construct": true
      },
      "qx.ui.form.TextField": {},
      "qx.ui.form.RepeatButton": {},
      "qx.locale.Number": {},
      "qx.lang.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A *spinner* is a control that allows you to adjust a numerical value,
   * typically within an allowed range. An obvious example would be to specify the
   * month of a year as a number in the range 1 - 12.
   *
   * To do so, a spinner encompasses a field to display the current value (a
   * textfield) and controls such as up and down buttons to change that value. The
   * current value can also be changed by editing the display field directly, or
   * using mouse wheel and cursor keys.
   *
   * An optional {@link #numberFormat} property allows you to control the format of
   * how a value can be entered and will be displayed.
   *
   * A brief, but non-trivial example:
   *
   * <pre class='javascript'>
   * var s = new qx.ui.form.Spinner();
   * s.set({
   *   maximum: 3000,
   *   minimum: -3000
   * });
   * var nf = new qx.util.format.NumberFormat();
   * nf.setMaximumFractionDigits(2);
   * s.setNumberFormat(nf);
   * </pre>
   *
   * A spinner instance without any further properties specified in the
   * constructor or a subsequent *set* command will appear with default
   * values and behaviour.
   *
   * @childControl textfield {qx.ui.form.TextField} holds the current value of the spinner
   * @childControl upbutton {qx.ui.form.Button} button to increase the value
   * @childControl downbutton {qx.ui.form.Button} button to decrease the value
   *
   */
  qx.Class.define("qx.ui.form.Spinner", {
    extend: qx.ui.core.Widget,
    implement: [qx.ui.form.INumberForm, qx.ui.form.IRange, qx.ui.form.IForm],
    include: [qx.ui.core.MContentPadding, qx.ui.form.MForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param min {Number} Minimum value
     * @param value {Number} Current value
     * @param max {Number} Maximum value
     */
    construct: function construct(min, value, max) {
      qx.ui.core.Widget.constructor.call(this); // MAIN LAYOUT

      var layout = new qx.ui.layout.Grid();
      layout.setColumnFlex(0, 1);
      layout.setRowFlex(0, 1);
      layout.setRowFlex(1, 1);

      this._setLayout(layout); // EVENTS


      this.addListener("keydown", this._onKeyDown, this);
      this.addListener("keyup", this._onKeyUp, this);
      this.addListener("roll", this._onRoll, this);
      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      } // CREATE CONTROLS

      var textField = this._createChildControl("textfield");

      this._createChildControl("upbutton");

      this._createChildControl("downbutton"); // INITIALIZATION


      if (min != null) {
        this.setMinimum(min);
      }

      if (max != null) {
        this.setMaximum(max);
      }

      if (value !== undefined) {
        this.setValue(value);
      } else {
        this.initValue();
      } // forward the focusin and focusout events to the textfield. The textfield
      // is not focusable so the events need to be forwarded manually.


      this.addListener("focusin", function (e) {
        textField.fireNonBubblingEvent("focusin", qx.event.type.Focus);
      }, this);
      this.addListener("focusout", function (e) {
        textField.fireNonBubblingEvent("focusout", qx.event.type.Focus);
      }, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "spinner"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /** The amount to increment on each event (keypress or pointerdown) */
      singleStep: {
        check: "Number",
        init: 1
      },

      /** The amount to increment on each pageup/pagedown keypress */
      pageStep: {
        check: "Number",
        init: 10
      },

      /** minimal value of the Range object */
      minimum: {
        check: "Number",
        apply: "_applyMinimum",
        init: 0,
        event: "changeMinimum"
      },

      /** The value of the spinner. */
      value: {
        check: "this._checkValue(value)",
        nullable: true,
        apply: "_applyValue",
        init: 0,
        event: "changeValue"
      },

      /** maximal value of the Range object */
      maximum: {
        check: "Number",
        apply: "_applyMaximum",
        init: 100,
        event: "changeMaximum"
      },

      /** whether the value should wrap around */
      wrap: {
        check: "Boolean",
        init: false,
        apply: "_applyWrap"
      },

      /** Controls whether the textfield of the spinner is editable or not */
      editable: {
        check: "Boolean",
        init: true,
        apply: "_applyEditable"
      },

      /** Controls the display of the number in the textfield */
      numberFormat: {
        check: "qx.util.format.NumberFormat",
        apply: "_applyNumberFormat",
        nullable: true
      },
      // overridden
      allowShrinkY: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** Saved last value in case invalid text is entered */
      __lastValidValue__P_424_0: null,

      /** Whether the page-up button has been pressed */
      __pageUpMode__P_424_1: false,

      /** Whether the page-down button has been pressed */
      __pageDownMode__P_424_2: false,

      /*
      ---------------------------------------------------------------------------
        WIDGET INTERNALS
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "textfield":
            control = new qx.ui.form.TextField();
            control.setFilter(this._getFilterRegExp());
            control.addState("inner");
            control.setWidth(40);
            control.setFocusable(false);
            control.addListener("changeValue", this._onTextChange, this);

            this._add(control, {
              column: 0,
              row: 0,
              rowSpan: 2
            });

            break;

          case "upbutton":
            control = new qx.ui.form.RepeatButton();
            control.addState("inner");
            control.setFocusable(false);
            control.addListener("execute", this._countUp, this);

            this._add(control, {
              column: 1,
              row: 0
            });

            break;

          case "downbutton":
            control = new qx.ui.form.RepeatButton();
            control.addState("inner");
            control.setFocusable(false);
            control.addListener("execute", this._countDown, this);

            this._add(control, {
              column: 1,
              row: 1
            });

            break;
        }

        return control || qx.ui.form.Spinner.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Returns the regular expression used as the text field's filter
       *
       * @return {RegExp} The filter RegExp.
       */
      _getFilterRegExp: function _getFilterRegExp() {
        var decimalSeparator, groupSeparator, locale;

        if (this.getNumberFormat() !== null) {
          locale = this.getNumberFormat().getLocale();
        } else {
          locale = qx.locale.Manager.getInstance().getLocale();
        }

        decimalSeparator = qx.locale.Number.getDecimalSeparator(locale);
        groupSeparator = qx.locale.Number.getGroupSeparator(locale);
        var prefix = "";
        var postfix = "";

        if (this.getNumberFormat() !== null) {
          prefix = this.getNumberFormat().getPrefix() || "";
          postfix = this.getNumberFormat().getPostfix() || "";
        }

        var filterRegExp = new RegExp("[0-9" + qx.lang.String.escapeRegexpChars(decimalSeparator) + qx.lang.String.escapeRegexpChars(groupSeparator) + qx.lang.String.escapeRegexpChars(prefix) + qx.lang.String.escapeRegexpChars(postfix) + "\-]");
        return filterRegExp;
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        invalid: true
      },
      // overridden
      tabFocus: function tabFocus() {
        var field = this.getChildControl("textfield");
        field.getFocusElement().focus();
        field.selectAllText();
      },

      /*
      ---------------------------------------------------------------------------
        APPLY METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Apply routine for the minimum property.
       *
       * It sets the value of the spinner to the maximum of the current spinner
       * value and the given min property value.
       *
       * @param value {Number} The new value of the min property
       * @param old {Number} The old value of the min property
       */
      _applyMinimum: function _applyMinimum(value, old) {
        if (this.getMaximum() < value) {
          this.setMaximum(value);
        }

        if (this.getValue() < value) {
          this.setValue(value);
        } else {
          this._updateButtons();
        }
      },

      /**
       * Apply routine for the maximum property.
       *
       * It sets the value of the spinner to the minimum of the current spinner
       * value and the given max property value.
       *
       * @param value {Number} The new value of the max property
       * @param old {Number} The old value of the max property
       */
      _applyMaximum: function _applyMaximum(value, old) {
        if (this.getMinimum() > value) {
          this.setMinimum(value);
        }

        if (this.getValue() > value) {
          this.setValue(value);
        } else {
          this._updateButtons();
        }
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.form.Spinner.prototype._applyEnabled.base.call(this, value, old);

        this._updateButtons();
      },

      /**
       * Check whether the value being applied is allowed.
       *
       * If you override this to change the allowed type, you will also
       * want to override {@link #_applyValue}, {@link #_applyMinimum},
       * {@link #_applyMaximum}, {@link #_countUp}, {@link #_countDown}, and
       * {@link #_onTextChange} methods as those cater specifically to numeric
       * values.
       *
       * @param value {var}
       *   The value being set
       * @return {Boolean}
       *   <i>true</i> if the value is allowed;
       *   <i>false> otherwise.
       */
      _checkValue: function _checkValue(value) {
        return typeof value === "number" && value >= this.getMinimum() && value <= this.getMaximum();
      },

      /**
       * Apply routine for the value property.
       *
       * It disables / enables the buttons and handles the wrap around.
       *
       * @param value {Number} The new value of the spinner
       * @param old {Number} The former value of the spinner
       */
      _applyValue: function _applyValue(value, old) {
        var textField = this.getChildControl("textfield");

        this._updateButtons(); // save the last valid value of the spinner


        this.__lastValidValue__P_424_0 = value; // write the value of the spinner to the textfield

        if (value !== null) {
          if (this.getNumberFormat()) {
            textField.setValue(this.getNumberFormat().format(value));
          } else {
            textField.setValue(value + "");
          }
        } else {
          textField.setValue("");
        }
      },

      /**
       * Apply routine for the editable property.<br/>
       * It sets the textfield of the spinner to not read only.
       *
       * @param value {Boolean} The new value of the editable property
       * @param old {Boolean} The former value of the editable property
       */
      _applyEditable: function _applyEditable(value, old) {
        var textField = this.getChildControl("textfield");

        if (textField) {
          textField.setReadOnly(!value);
        }
      },

      /**
       * Apply routine for the wrap property.<br/>
       * Enables all buttons if the wrapping is enabled.
       *
       * @param value {Boolean} The new value of the wrap property
       * @param old {Boolean} The former value of the wrap property
       */
      _applyWrap: function _applyWrap(value, old) {
        this._updateButtons();
      },

      /**
       * Apply routine for the numberFormat property.<br/>
       * When setting a number format, the display of the
       * value in the text-field will be changed immediately.
       *
       * @param value {Boolean} The new value of the numberFormat property
       * @param old {Boolean} The former value of the numberFormat property
       */
      _applyNumberFormat: function _applyNumberFormat(value, old) {
        var textField = this.getChildControl("textfield");
        textField.setFilter(this._getFilterRegExp());

        if (old) {
          old.removeListener("changeNumberFormat", this._onChangeNumberFormat, this);
        }

        var numberFormat = this.getNumberFormat();

        if (numberFormat !== null) {
          numberFormat.addListener("changeNumberFormat", this._onChangeNumberFormat, this);
        }

        this._applyValue(this.__lastValidValue__P_424_0, undefined);
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getChildControl("textfield");
      },

      /**
       * Checks the min and max values, disables / enables the
       * buttons and handles the wrap around.
       */
      _updateButtons: function _updateButtons() {
        var upButton = this.getChildControl("upbutton");
        var downButton = this.getChildControl("downbutton");
        var value = this.getValue();

        if (!this.getEnabled()) {
          // If Spinner is disabled -> disable buttons
          upButton.setEnabled(false);
          downButton.setEnabled(false);
        } else {
          if (this.getWrap()) {
            // If wraped -> always enable buttons
            upButton.setEnabled(true);
            downButton.setEnabled(true);
          } else {
            // check max value
            if (value !== null && value < this.getMaximum()) {
              upButton.setEnabled(true);
            } else {
              upButton.setEnabled(false);
            } // check min value


            if (value !== null && value > this.getMinimum()) {
              downButton.setEnabled(true);
            } else {
              downButton.setEnabled(false);
            }
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        KEY EVENT-HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Callback for "keyDown" event.<br/>
       * Controls the interval mode ("single" or "page")
       * and the interval increase by detecting "Up"/"Down"
       * and "PageUp"/"PageDown" keys.<br/>
       * The corresponding button will be pressed.
       *
       * @param e {qx.event.type.KeySequence} keyDown event
       */
      _onKeyDown: function _onKeyDown(e) {
        switch (e.getKeyIdentifier()) {
          case "PageUp":
            // mark that the spinner is in page mode and process further
            this.__pageUpMode__P_424_1 = true;

          case "Up":
            this.getChildControl("upbutton").press();
            break;

          case "PageDown":
            // mark that the spinner is in page mode and process further
            this.__pageDownMode__P_424_2 = true;

          case "Down":
            this.getChildControl("downbutton").press();
            break;

          default:
            // Do not stop unused events
            return;
        }

        e.stopPropagation();
        e.preventDefault();
      },

      /**
       * Callback for "keyUp" event.<br/>
       * Detecting "Up"/"Down" and "PageUp"/"PageDown" keys.<br/>
       * Releases the button and disabled the page mode, if necessary.
       *
       * @param e {qx.event.type.KeySequence} keyUp event
       */
      _onKeyUp: function _onKeyUp(e) {
        switch (e.getKeyIdentifier()) {
          case "PageUp":
            this.getChildControl("upbutton").release();
            this.__pageUpMode__P_424_1 = false;
            break;

          case "Up":
            this.getChildControl("upbutton").release();
            break;

          case "PageDown":
            this.getChildControl("downbutton").release();
            this.__pageDownMode__P_424_2 = false;
            break;

          case "Down":
            this.getChildControl("downbutton").release();
            break;
        }
      },

      /*
      ---------------------------------------------------------------------------
        OTHER EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Callback method for the "roll" event.<br/>
       * Increments or decrements the value of the spinner.
       *
       * @param e {qx.event.type.Roll} roll event
       */
      _onRoll: function _onRoll(e) {
        // only wheel
        if (e.getPointerType() != "wheel") {
          return;
        }

        var delta = e.getDelta().y;

        if (delta < 0) {
          this._countUp();
        } else if (delta > 0) {
          this._countDown();
        }

        e.stop();
      },

      /**
       * Callback method for the "change" event of the textfield.
       *
       * @param e {qx.event.type.Event} text change event or blur event
       */
      _onTextChange: function _onTextChange(e) {
        var textField = this.getChildControl("textfield");
        var value; // if a number format is set

        if (this.getNumberFormat()) {
          // try to parse the current number using the number format
          try {
            value = this.getNumberFormat().parse(textField.getValue());
          } catch (ex) {// otherwise, process further
          }
        }

        if (value === undefined) {
          // try to parse the number as a float
          value = parseFloat(textField.getValue());
        } // if the result is a number


        if (!isNaN(value)) {
          // Fix value if invalid
          if (value > this.getMaximum()) {
            value = this.getMaximum();
          } else if (value < this.getMinimum()) {
            value = this.getMinimum();
          } // If value is the same than before, call directly _applyValue()


          if (value === this.__lastValidValue__P_424_0) {
            this._applyValue(this.__lastValidValue__P_424_0);
          } else {
            this.setValue(value);
          }
        } else {
          // otherwise, reset the last valid value
          this._applyValue(this.__lastValidValue__P_424_0, undefined);
        }
      },

      /**
       * Callback method for the locale Manager's "changeLocale" event.
       *
       * @param ev {qx.event.type.Event} locale change event
       */
      _onChangeLocale: function _onChangeLocale(ev) {
        if (this.getNumberFormat() !== null) {
          this.setNumberFormat(this.getNumberFormat());
          var textfield = this.getChildControl("textfield");
          textfield.setFilter(this._getFilterRegExp());
          textfield.setValue(this.getNumberFormat().format(this.getValue()));
        }
      },

      /**
       * Callback method for the number format's "changeNumberFormat" event.
       *
       * @param ev {qx.event.type.Event} number format change event
       */
      _onChangeNumberFormat: function _onChangeNumberFormat(ev) {
        var textfield = this.getChildControl("textfield");
        textfield.setFilter(this._getFilterRegExp());
        textfield.setValue(this.getNumberFormat().format(this.getValue()));
      },

      /*
      ---------------------------------------------------------------------------
        INTERVAL HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Checks if the spinner is in page mode and counts either the single
       * or page Step up.
       *
       */
      _countUp: function _countUp() {
        if (this.__pageUpMode__P_424_1) {
          var newValue = this.getValue() + this.getPageStep();
        } else {
          var newValue = this.getValue() + this.getSingleStep();
        } // handle the case where wrapping is enabled


        if (this.getWrap()) {
          if (newValue > this.getMaximum()) {
            var diff = this.getMaximum() - newValue;
            newValue = this.getMinimum() - diff - 1;
          }
        }

        this.gotoValue(newValue);
      },

      /**
       * Checks if the spinner is in page mode and counts either the single
       * or page Step down.
       *
       */
      _countDown: function _countDown() {
        if (this.__pageDownMode__P_424_2) {
          var newValue = this.getValue() - this.getPageStep();
        } else {
          var newValue = this.getValue() - this.getSingleStep();
        } // handle the case where wrapping is enabled


        if (this.getWrap()) {
          if (newValue < this.getMinimum()) {
            var diff = this.getMinimum() + newValue;
            newValue = this.getMaximum() + diff + 1;
          }
        }

        this.gotoValue(newValue);
      },

      /**
       * Normalizes the incoming value to be in the valid range and
       * applies it to the {@link #value} afterwards.
       *
       * @param value {Number} Any number
       * @return {Number} The normalized number
       */
      gotoValue: function gotoValue(value) {
        return this.setValue(Math.min(this.getMaximum(), Math.max(this.getMinimum(), value)));
      },
      // overridden
      focus: function focus() {
        qx.ui.form.Spinner.prototype.focus.base.call(this);
        this.getChildControl("textfield").getFocusElement().focus();
      }
    },
    destruct: function destruct() {
      var nf = this.getNumberFormat();

      if (nf) {
        nf.removeListener("changeNumberFormat", this._onChangeNumberFormat, this);
      }

      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
    }
  });
  qx.ui.form.Spinner.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.lang.Type": {},
      "qx.lang.Object": {},
      "qx.core.ValidationError": {},
      "qx.type.BaseError": {},
      "qx.ui.form.validation.AsyncValidator": {},
      "qx.ui.form.IForm": {},
      "qx.ui.core.ISingleSelection": {},
      "qx.data.controller.ISelection": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This validation manager is responsible for validation of forms.
   *
   * @ignore(qx.ui.tooltip)
   * @ignore(qx.ui.tooltip.Manager.*)
   */
  qx.Class.define("qx.ui.form.validation.Manager", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this); // storage for all form items

      this.__formItems__P_432_0 = []; // storage for all results of async validation calls

      this.__asyncResults__P_432_1 = {}; // set the default required field message

      this.setRequiredFieldMessage(qx.locale.Manager.tr("This field is required"));
    },
    events: {
      /**
       * Change event for the valid state.
       */
      "changeValid": "qx.event.type.Data",

      /**
       * Signals that the validation is done. This is not needed on synchronous
       * validation (validation is done right after the call) but very important
       * in the case an asynchronous validator will be used.
       */
      "complete": "qx.event.type.Event"
    },
    properties: {
      /**
       * The validator of the form itself. You can set a function (for
       * synchronous validation) or a {@link qx.ui.form.validation.AsyncValidator}.
       * In both cases, the function can have all added form items as first
       * argument and the manager as a second argument. The manager should be used
       * to set the {@link #invalidMessage}.
       *
       * Keep in mind that the validator is optional if you don't need the
       * validation in the context of the whole form.
       * @type {Function | AsyncValidator}
       */
      validator: {
        check: "value instanceof Function || qx.Class.isSubClassOf(value.constructor, qx.ui.form.validation.AsyncValidator)",
        init: null,
        nullable: true
      },

      /**
       * The invalid message should store the message why the form validation
       * failed. It will be added to the array returned by
       * {@link #getInvalidMessages}.
       */
      invalidMessage: {
        check: "String",
        init: ""
      },

      /**
       * This message will be shown if a required field is empty and no individual
       * {@link qx.ui.form.MForm#requiredInvalidMessage} is given.
       */
      requiredFieldMessage: {
        check: "String",
        init: ""
      },

      /**
       * The context for the form validation.
       */
      context: {
        nullable: true
      }
    },
    members: {
      __formItems__P_432_0: null,
      __valid__P_432_2: null,
      __asyncResults__P_432_1: null,
      __syncValid__P_432_3: null,

      /**
       * Add a form item to the validation manager.
       *
       * The form item has to implement at least two interfaces:
       * <ol>
       *   <li>The {@link qx.ui.form.IForm} Interface</li>
       *   <li>One of the following interfaces:
       *     <ul>
       *       <li>{@link qx.ui.form.IBooleanForm}</li>
       *       <li>{@link qx.ui.form.IColorForm}</li>
       *       <li>{@link qx.ui.form.IDateForm}</li>
       *       <li>{@link qx.ui.form.INumberForm}</li>
       *       <li>{@link qx.ui.form.IStringForm}</li>
       *     </ul>
       *   </li>
       * </ol>
       * The validator can be a synchronous or asynchronous validator. In
       * both cases the validator can either returns a boolean or fire an
       * {@link qx.core.ValidationError}. For synchronous validation, a plain
       * JavaScript function should be used. For all asynchronous validations,
       * a {@link qx.ui.form.validation.AsyncValidator} is needed to wrap the
       * plain function.
       *
       * @param formItem {qx.ui.core.Widget} The form item to add.
       * @param validator {Function | qx.ui.form.validation.AsyncValidator}
       *   The validator.
       * @param context {var?null} The context of the validator.
       */
      add: function add(formItem, validator, context) {
        // check for the form API
        if (!this.__supportsInvalid__P_432_4(formItem)) {
          throw new Error("Added widget not supported.");
        } // check for the data type


        if (this.__supportsSingleSelection__P_432_5(formItem) && !formItem.getValue) {
          // check for a validator
          if (validator != null) {
            throw new Error("Widgets supporting selection can only be validated in the form validator");
          }
        }

        var dataEntry = {
          item: formItem,
          validator: validator,
          valid: null,
          context: context
        };

        this.__formItems__P_432_0.push(dataEntry);
      },

      /**
       * Remove a form item from the validation manager.
       *
       * @param formItem {qx.ui.core.Widget} The form item to remove.
       * @return {qx.ui.core.Widget?null} The removed form item or
       *  <code>null</code> if the item could not be found.
       */
      remove: function remove(formItem) {
        var items = this.__formItems__P_432_0;

        for (var i = 0, len = items.length; i < len; i++) {
          if (formItem === items[i].item) {
            items.splice(i, 1);
            return formItem;
          }
        }

        return null;
      },

      /**
       * Returns registered form items from the validation manager.
       *
       * @return {Array} The form items which will be validated.
       */
      getItems: function getItems() {
        var items = [];

        for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
          items.push(this.__formItems__P_432_0[i].item);
        }

        ;
        return items;
      },

      /**
       * Invokes the validation. If only synchronous validators are set, the
       * result of the whole validation is available at the end of the method
       * and can be returned. If an asynchronous validator is set, the result
       * is still unknown at the end of this method so nothing will be returned.
       * In both cases, a {@link #complete} event will be fired if the validation
       * has ended. The result of the validation can then be accessed with the
       * {@link #getValid} method.
       *
       * @return {Boolean|undefined} The validation result, if available.
       */
      validate: function validate() {
        var valid = true;
        this.__syncValid__P_432_3 = true; // collaboration of all synchronous validations

        var items = []; // check all validators for the added form items

        for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
          var formItem = this.__formItems__P_432_0[i].item;
          var validator = this.__formItems__P_432_0[i].validator; // store the items in case of form validation

          items.push(formItem); // ignore all form items without a validator

          if (validator == null) {
            // check for the required property
            var validatorResult = this._validateRequired(formItem);

            valid = valid && validatorResult;
            this.__syncValid__P_432_3 = validatorResult && this.__syncValid__P_432_3;
            continue;
          }

          var validatorResult = this._validateItem(this.__formItems__P_432_0[i], formItem.getValue()); // keep that order to ensure that null is returned on async cases


          valid = validatorResult && valid;

          if (validatorResult != null) {
            this.__syncValid__P_432_3 = validatorResult && this.__syncValid__P_432_3;
          }
        } // check the form validator (be sure to invoke it even if the form
        // items are already false, so keep the order!)


        var formValid = this.__validateForm__P_432_6(items);

        if (qx.lang.Type.isBoolean(formValid)) {
          this.__syncValid__P_432_3 = formValid && this.__syncValid__P_432_3;
        }

        valid = formValid && valid;

        this._setValid(valid);

        if (qx.lang.Object.isEmpty(this.__asyncResults__P_432_1)) {
          this.fireEvent("complete");
        }

        return valid;
      },

      /**
       * Checks if the form item is required. If so, the value is checked
       * and the result will be returned. If the form item is not required, true
       * will be returned.
       *
       * @param formItem {qx.ui.core.Widget} The form item to check.
       * @return {var} Validation result
       */
      _validateRequired: function _validateRequired(formItem) {
        if (formItem.getRequired()) {
          var validatorResult; // if its a widget supporting the selection

          if (this.__supportsSingleSelection__P_432_5(formItem)) {
            validatorResult = !!formItem.getSelection()[0];
          } else if (this.__supportsDataBindingSelection__P_432_7(formItem)) {
            validatorResult = formItem.getSelection().getLength() > 0;
          } else {
            var value = formItem.getValue();
            validatorResult = !!value || value === 0;
          }

          formItem.setValid(validatorResult);
          var individualMessage = formItem.getRequiredInvalidMessage();
          var message = individualMessage ? individualMessage : this.getRequiredFieldMessage();
          formItem.setInvalidMessage(message);
          return validatorResult;
        }

        return true;
      },

      /**
       * Validates a form item. This method handles the differences of
       * synchronous and asynchronous validation and returns the result of the
       * validation if possible (synchronous cases). If the validation is
       * asynchronous, null will be returned.
       *
       * @param dataEntry {Object} The map stored in {@link #add}
       * @param value {var} The currently set value
       * @return {Boolean|null} Validation result or <code>null</code> for async
       * validation
       */
      _validateItem: function _validateItem(dataEntry, value) {
        var formItem = dataEntry.item;
        var context = dataEntry.context;
        var validator = dataEntry.validator; // check for asynchronous validation

        if (this.__isAsyncValidator__P_432_8(validator)) {
          // used to check if all async validations are done
          this.__asyncResults__P_432_1[formItem.toHashCode()] = null;
          validator.validate(formItem, formItem.getValue(), this, context);
          return null;
        }

        var validatorResult = null;

        try {
          var validatorResult = validator.call(context || this, value, formItem);

          if (validatorResult === undefined) {
            validatorResult = true;
          }
        } catch (e) {
          if (e instanceof qx.core.ValidationError) {
            validatorResult = false;

            if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {
              var invalidMessage = e.message;
            } else {
              var invalidMessage = e.getComment();
            }

            formItem.setInvalidMessage(invalidMessage);
          } else {
            throw e;
          }
        }

        formItem.setValid(validatorResult);
        dataEntry.valid = validatorResult;
        return validatorResult;
      },

      /**
       * Validates the form. It checks for asynchronous validation and handles
       * the differences to synchronous validation. If no form validator is given,
       * true will be returned. If a synchronous validator is given, the
       * validation result will be returned. In asynchronous cases, null will be
       * returned cause the result is not available.
       *
       * @param items {qx.ui.core.Widget[]} An array of all form items.
       * @return {Boolean|null} description
       */
      __validateForm__P_432_6: function __validateForm__P_432_6(items) {
        var formValidator = this.getValidator();
        var context = this.getContext() || this;

        if (formValidator == null) {
          return true;
        } // reset the invalidMessage


        this.setInvalidMessage("");

        if (this.__isAsyncValidator__P_432_8(formValidator)) {
          this.__asyncResults__P_432_1[this.toHashCode()] = null;
          formValidator.validateForm(items, this, context);
          return null;
        }

        try {
          var formValid = formValidator.call(context, items, this);

          if (formValid === undefined) {
            formValid = true;
          }
        } catch (e) {
          if (e instanceof qx.core.ValidationError) {
            formValid = false;

            if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {
              var invalidMessage = e.message;
            } else {
              var invalidMessage = e.getComment();
            }

            this.setInvalidMessage(invalidMessage);
          } else {
            throw e;
          }
        }

        return formValid;
      },

      /**
       * Helper function which checks, if the given validator is synchronous
       * or asynchronous.
       *
       * @param validator {Function|qx.ui.form.validation.AsyncValidator}
       *   The validator to check.
       * @return {Boolean} True, if the given validator is asynchronous.
       */
      __isAsyncValidator__P_432_8: function __isAsyncValidator__P_432_8(validator) {
        var async = false;

        if (!qx.lang.Type.isFunction(validator)) {
          async = qx.Class.isSubClassOf(validator.constructor, qx.ui.form.validation.AsyncValidator);
        }

        return async;
      },

      /**
       * Returns true, if the given item implements the {@link qx.ui.form.IForm}
       * interface.
       *
       * @param formItem {qx.core.Object} The item to check.
       * @return {Boolean} true, if the given item implements the
       *   necessary interface.
       */
      __supportsInvalid__P_432_4: function __supportsInvalid__P_432_4(formItem) {
        var clazz = formItem.constructor;
        return qx.Class.hasInterface(clazz, qx.ui.form.IForm);
      },

      /**
       * Returns true, if the given item implements the
       * {@link qx.ui.core.ISingleSelection} interface.
       *
       * @param formItem {qx.core.Object} The item to check.
       * @return {Boolean} true, if the given item implements the
       *   necessary interface.
       */
      __supportsSingleSelection__P_432_5: function __supportsSingleSelection__P_432_5(formItem) {
        var clazz = formItem.constructor;
        return qx.Class.hasInterface(clazz, qx.ui.core.ISingleSelection);
      },

      /**
       * Returns true, if the given item implements the
       * {@link qx.data.controller.ISelection} interface.
       *
       * @param formItem {qx.core.Object} The item to check.
       * @return {Boolean} true, if the given item implements the
       *   necessary interface.
       */
      __supportsDataBindingSelection__P_432_7: function __supportsDataBindingSelection__P_432_7(formItem) {
        var clazz = formItem.constructor;
        return qx.Class.hasInterface(clazz, qx.data.controller.ISelection);
      },

      /**
       * Sets the valid state of the manager. It generates the event if
       * necessary and stores the new value.
       *
       * @param value {Boolean|null} The new valid state of the manager.
       */
      _setValid: function _setValid(value) {
        this._showToolTip(value);

        var oldValue = this.__valid__P_432_2;
        this.__valid__P_432_2 = value; // check for the change event

        if (oldValue != value) {
          this.fireDataEvent("changeValid", value, oldValue);
        }
      },

      /**
       * Responsible for showing a tooltip in case the validation is done for
       * widgets based on qx.ui.core.Widget.
       * @param valid {Boolean} <code>false</code>, if the tooltip should be shown
       */
      _showToolTip: function _showToolTip(valid) {
        // ignore if we don't have a tooltip manager e.g. mobile apps
        if (!qx.ui.tooltip || !qx.ui.tooltip.Manager) {
          return;
        }

        var tooltip = qx.ui.tooltip.Manager.getInstance().getSharedErrorTooltip();

        if (!valid) {
          var firstInvalid;

          for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
            var item = this.__formItems__P_432_0[i].item;

            if (!item.isValid()) {
              firstInvalid = item; // only for desktop widgets

              if (!item.getContentLocation) {
                return;
              } // only consider items on the screen


              if (item.isSeeable() === false) {
                continue;
              }

              tooltip.setLabel(item.getInvalidMessage());

              if (tooltip.getPlaceMethod() == "mouse") {
                var location = item.getContentLocation();
                var top = location.top - tooltip.getOffsetTop();
                tooltip.placeToPoint({
                  left: location.right,
                  top: top
                });
              } else {
                tooltip.placeToWidget(item);
              }

              tooltip.show();
              return;
            }
          }
        } else {
          tooltip.exclude();
        }
      },

      /**
       * Returns the valid state of the manager.
       *
       * @return {Boolean|null} The valid state of the manager.
       */
      getValid: function getValid() {
        return this.__valid__P_432_2;
      },

      /**
       * Returns the valid state of the manager.
       *
       * @return {Boolean|null} The valid state of the manager.
       */
      isValid: function isValid() {
        return this.getValid();
      },

      /**
       * Returns an array of all invalid messages of the invalid form items and
       * the form manager itself.
       *
       * @return {String[]} All invalid messages.
       */
      getInvalidMessages: function getInvalidMessages() {
        var messages = []; // combine the messages of all form items

        for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
          var formItem = this.__formItems__P_432_0[i].item;

          if (!formItem.getValid()) {
            messages.push(formItem.getInvalidMessage());
          }
        } // add the forms fail message


        if (this.getInvalidMessage() != "") {
          messages.push(this.getInvalidMessage());
        }

        return messages;
      },

      /**
       * Selects invalid form items
       *
       * @return {Array} invalid form items
       */
      getInvalidFormItems: function getInvalidFormItems() {
        var res = [];

        for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
          var formItem = this.__formItems__P_432_0[i].item;

          if (!formItem.getValid()) {
            res.push(formItem);
          }
        }

        return res;
      },

      /**
       * Resets the validator.
       */
      reset: function reset() {
        // reset all form items
        for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
          var dataEntry = this.__formItems__P_432_0[i]; // set the field to valid

          dataEntry.item.setValid(true);
        } // set the manager to its initial valid value


        this.__valid__P_432_2 = null;

        this._showToolTip(true);
      },

      /**
       * Internal helper method to set the given item to valid for asynchronous
       * validation calls. This indirection is used to determinate if the
       * validation process is completed or if other asynchronous validators
       * are still validating. {@link #__checkValidationComplete} checks if the
       * validation is complete and will be called at the end of this method.
       *
       * @param formItem {qx.ui.core.Widget} The form item to set the valid state.
       * @param valid {Boolean} The valid state for the form item.
       *
       * @internal
       */
      setItemValid: function setItemValid(formItem, valid) {
        // store the result
        this.__asyncResults__P_432_1[formItem.toHashCode()] = valid;
        formItem.setValid(valid);

        this.__checkValidationComplete__P_432_9();
      },

      /**
       * Internal helper method to set the form manager to valid for asynchronous
       * validation calls. This indirection is used to determinate if the
       * validation process is completed or if other asynchronous validators
       * are still validating. {@link #__checkValidationComplete} checks if the
       * validation is complete and will be called at the end of this method.
       *
       * @param valid {Boolean} The valid state for the form manager.
       *
       * @internal
       */
      setFormValid: function setFormValid(valid) {
        this.__asyncResults__P_432_1[this.toHashCode()] = valid;

        this.__checkValidationComplete__P_432_9();
      },

      /**
       * Checks if all asynchronous validators have validated so the result
       * is final and the {@link #complete} event can be fired. If that's not
       * the case, nothing will happen in the method.
       */
      __checkValidationComplete__P_432_9: function __checkValidationComplete__P_432_9() {
        var valid = this.__syncValid__P_432_3; // check if all async validators are done

        for (var hash in this.__asyncResults__P_432_1) {
          var currentResult = this.__asyncResults__P_432_1[hash];
          valid = currentResult && valid; // the validation is not done so just do nothing

          if (currentResult == null) {
            return;
          }
        } // set the actual valid state of the manager


        this._setValid(valid); // reset the results


        this.__asyncResults__P_432_1 = {}; // fire the complete event (no entry in the results with null)

        this.fireEvent("complete");
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._showToolTip(true);

      this.__formItems__P_432_0 = null;
    }
  });
  qx.ui.form.validation.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
       2017 Martijn Evers, The Netherlands
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Martijn Evers (mever)
  
  ************************************************************************ */

  /**
   * The resetter is responsible for managing a set of fields and resetting these
   * fields on a {@link #reset} call. It can handle all form field implementing IField.
   */
  qx.Class.define("qx.ui.form.Resetter", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__items__P_421_0 = [];
    },
    members: {
      __items__P_421_0: null,

      /**
       * Adding a field to the resetter will get its current value and store
       * it for resetting.
       *
       * @param field {qx.ui.form.IField} The field which should be added.
       * @throws {TypeError} When given argument is not a field.
       */
      add: function add(field) {
        this.__typeCheck__P_421_1(field);

        this.__items__P_421_0.push({
          item: field,
          init: field.getValue()
        });
      },

      /**
       * Removes a field from the resetter.
       *
       * @param field {qx.ui.form.IField} The field which should be removed.
       * @throws {TypeError} When given argument is not a field.
       * @return {Boolean} <code>true</code>, if the field has been removed.
       */
      remove: function remove(field) {
        this.__typeCheck__P_421_1(field);

        for (var i = 0; i < this.__items__P_421_0.length; i++) {
          var storedItem = this.__items__P_421_0[i];

          if (storedItem.item === field) {
            this.__items__P_421_0.splice(i, 1);

            return true;
          }
        }

        return false;
      },

      /**
       * Resets all added fields to their initial value. The initial value
       * is the value in the widget during the {@link #add}.
       *
       * @return {null|Error} Returns an error when some fields could not be reset.
       */
      reset: function reset() {
        var dataEntry,
            e,
            errors = [];

        for (var i = 0; i < this.__items__P_421_0.length; i++) {
          dataEntry = this.__items__P_421_0[i];
          e = dataEntry.item.setValue(dataEntry.init);

          if (e && e instanceof Error) {
            errors.push(e);
          }
        }

        if (errors.length) {
          return new Error(errors.join(', '));
        } else {
          return null;
        }
      },

      /**
       * Resets a single given field. The field has to be added to the resetter
       * instance before. Otherwise, an error is thrown.
       *
       * @param field {qx.ui.form.IField} The field, which should be reset.
       * @throws {TypeError} When given argument is not a field.
       * @return {null|Error} Returns an error when the field value could not be set.
       */
      resetItem: function resetItem(field) {
        this.__typeCheck__P_421_1(field);

        for (var i = 0; i < this.__items__P_421_0.length; i++) {
          var dataEntry = this.__items__P_421_0[i];

          if (dataEntry.item === field) {
            return field.setValue(dataEntry.init);
          }
        }

        throw new Error("The given field has not been added.");
      },

      /**
       * Takes the current values of all added fields and uses these values as
       * init values for resetting.
       */
      redefine: function redefine() {
        // go threw all added items
        for (var i = 0; i < this.__items__P_421_0.length; i++) {
          var item = this.__items__P_421_0[i].item; // set the new init value for the item

          this.__items__P_421_0[i].init = item.getValue();
        }
      },

      /**
       * Takes the current value of the given field and stores this value as init
       * value for resetting.
       *
       * @param field {qx.ui.form.IField} The field to redefine.
       * @throws {TypeError} When given argument is not a field.
       */
      redefineItem: function redefineItem(field) {
        this.__typeCheck__P_421_1(field); // get the data entry


        var dataEntry;

        for (var i = 0; i < this.__items__P_421_0.length; i++) {
          if (this.__items__P_421_0[i].item === field) {
            dataEntry = this.__items__P_421_0[i];
            dataEntry.init = dataEntry.item.getValue();
            return;
          }
        }

        throw new Error("The given field has not been added.");
      },

      /**
       * Assert when given argument is not a field.
       *
       * @param field {qx.ui.form.IField|var} Any argument that should be a field.
       * @throws {TypeError} When given argument is not a field.
       * @private
       */
      __typeCheck__P_421_1: function __typeCheck__P_421_1(field) {
        if (!qx.Class.hasInterface(field.constructor, qx.ui.form.IField)) {
          throw new TypeError("Field " + field + " not supported for resetting.");
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      // holding references to widgets --> must set to null
      this.__items__P_421_0 = null;
    }
  });
  qx.ui.form.Resetter.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.ISingleSelection": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModelSelection": {
        "require": true
      },
      "qx.ui.core.MSingleSelectionHandling": {
        "require": true
      },
      "qx.ui.form.MModelSelection": {
        "require": true
      },
      "qx.lang.String": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The radio group handles a collection of items from which only one item
   * can be selected. Selection another item will deselect the previously selected
   * item.
   *
   * This class is e.g. used to create radio groups or {@link qx.ui.form.RadioButton}
   * or {@link qx.ui.toolbar.RadioButton} instances.
   *
   * We also offer a widget for the same purpose which uses this class. So if
   * you like to act with a widget instead of a pure logic coupling of the
   * widgets, take a look at the {@link qx.ui.form.RadioButtonGroup} widget.
   */
  qx.Class.define("qx.ui.form.RadioGroup", {
    extend: qx.core.Object,
    implement: [qx.ui.core.ISingleSelection, qx.ui.form.IField, qx.ui.form.IForm, qx.ui.form.IModelSelection],
    include: [qx.ui.core.MSingleSelectionHandling, qx.ui.form.MModelSelection],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param varargs {qx.core.Object} A variable number of items, which are
     *     initially added to the radio group, the first item will be selected.
     */
    construct: function construct(varargs) {
      qx.core.Object.constructor.call(this); // create item array

      this.__items__P_419_0 = []; // add listener before call add!!!

      this.addListener("changeSelection", this.__onChangeSelection__P_419_1, this);

      if (varargs != null) {
        this.add.apply(this, arguments);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The property name in each of the added widgets that is grouped
       */
      groupedProperty: {
        check: "String",
        apply: "_applyGroupedProperty",
        event: "changeGroupedProperty",
        init: "value"
      },

      /**
       * The property name in each of the added widgets that is informed of the
       * RadioGroup object it is a member of
       */
      groupProperty: {
        check: "String",
        event: "changeGroupProperty",
        init: "group"
      },

      /**
       * Whether the radio group is enabled
       */
      enabled: {
        check: "Boolean",
        apply: "_applyEnabled",
        event: "changeEnabled",
        init: true
      },

      /**
       * Whether the selection should wrap around. This means that the successor of
       * the last item is the first item.
       */
      wrap: {
        check: "Boolean",
        init: true
      },

      /**
       * If is set to <code>true</code> the selection could be empty,
       * otherwise is always one <code>RadioButton</code> selected.
       */
      allowEmptySelection: {
        check: "Boolean",
        init: false,
        apply: "_applyAllowEmptySelection"
      },

      /**
       * Flag signaling if the group at all is valid. All children will have the
       * same state.
       */
      valid: {
        check: "Boolean",
        init: true,
        apply: "_applyValid",
        event: "changeValid"
      },

      /**
       * Flag signaling if the group is required.
       */
      required: {
        check: "Boolean",
        init: false,
        event: "changeRequired"
      },

      /**
       * Message which is shown in an invalid tooltip.
       */
      invalidMessage: {
        check: "String",
        init: "",
        event: "changeInvalidMessage",
        apply: "_applyInvalidMessage"
      },

      /**
       * Message which is shown in an invalid tooltip if the {@link #required} is
       * set to true.
       */
      requiredInvalidMessage: {
        check: "String",
        nullable: true,
        event: "changeInvalidMessage"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.form.IRadioItem[]} The items of the radio group */
      __items__P_419_0: null,

      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */

      /**
       * Get all managed items
       *
       * @return {qx.ui.form.IRadioItem[]} All managed items.
       */
      getItems: function getItems() {
        return this.__items__P_419_0;
      },

      /*
      ---------------------------------------------------------------------------
        REGISTRY
      ---------------------------------------------------------------------------
      */

      /**
       * Add the passed items to the radio group.
       *
       * @param varargs {qx.ui.form.IRadioItem} A variable number of items to add.
       */
      add: function add(varargs) {
        var items = this.__items__P_419_0;
        var item;
        var groupedProperty = this.getGroupedProperty();
        var groupedPropertyUp = qx.lang.String.firstUp(groupedProperty);

        for (var i = 0, l = arguments.length; i < l; i++) {
          item = arguments[i];

          if (items.includes(item)) {
            continue;
          } // Register listeners


          item.addListener("change" + groupedPropertyUp, this._onItemChangeChecked, this); // Push RadioButton to array

          items.push(item); // Inform radio button about new group

          item.set(this.getGroupProperty(), this); // Need to update internal value?

          if (item.get(groupedProperty)) {
            this.setSelection([item]);
          }
        } // Select first item when only one is registered


        if (!this.isAllowEmptySelection() && items.length > 0 && !this.getSelection()[0]) {
          this.setSelection([items[0]]);
        }
      },

      /**
       * Remove an item from the radio group.
       *
       * @param item {qx.ui.form.IRadioItem} The item to remove.
       */
      remove: function remove(item) {
        var items = this.__items__P_419_0;
        var groupedProperty = this.getGroupedProperty();
        var groupedPropertyUp = qx.lang.String.firstUp(groupedProperty);

        if (items.includes(item)) {
          // Remove RadioButton from array
          qx.lang.Array.remove(items, item); // Inform radio button about new group

          if (item.get(this.getGroupProperty()) === this) {
            item.reset(this.getGroupProperty());
          } // Deregister listeners


          item.removeListener("change" + groupedPropertyUp, this._onItemChangeChecked, this); // if the radio was checked, set internal selection to null

          if (item.get(groupedProperty)) {
            this.resetSelection();
          }
        }
      },

      /**
       * Returns an array containing the group's items.
       *
       * @return {qx.ui.form.IRadioItem[]} The item array
       */
      getChildren: function getChildren() {
        return this.__items__P_419_0;
      },

      /*
      ---------------------------------------------------------------------------
        LISTENER FOR ITEM CHANGES
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for <code>changeValue</code> event of every managed item.
       *
       * @param e {qx.event.type.Data} Data event
       */
      _onItemChangeChecked: function _onItemChangeChecked(e) {
        var item = e.getTarget();
        var groupedProperty = this.getGroupedProperty();

        if (item.get(groupedProperty)) {
          this.setSelection([item]);
        } else if (this.getSelection()[0] == item) {
          this.resetSelection();
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyGroupedProperty: function _applyGroupedProperty(value, old) {
        var item;
        var oldFirstUp = qx.lang.String.firstUp(old);
        var newFirstUp = qx.lang.String.firstUp(value);

        for (var i = 0; i < this.__items__P_419_0.length; i++) {
          item = this.__items__P_419_0[i]; // remove the listener for the old change event

          item.removeListener("change" + oldFirstUp, this._onItemChangeChecked, this); // add the listener for the new change event

          item.removeListener("change" + newFirstUp, this._onItemChangeChecked, this);
        }
      },
      // property apply
      _applyInvalidMessage: function _applyInvalidMessage(value, old) {
        for (var i = 0; i < this.__items__P_419_0.length; i++) {
          this.__items__P_419_0[i].setInvalidMessage(value);
        }
      },
      // property apply
      _applyValid: function _applyValid(value, old) {
        for (var i = 0; i < this.__items__P_419_0.length; i++) {
          this.__items__P_419_0[i].setValid(value);
        }
      },
      // property apply
      _applyEnabled: function _applyEnabled(value, old) {
        var items = this.__items__P_419_0;

        if (value == null) {
          for (var i = 0, l = items.length; i < l; i++) {
            items[i].resetEnabled();
          }
        } else {
          for (var i = 0, l = items.length; i < l; i++) {
            items[i].setEnabled(value);
          }
        }
      },
      // property apply
      _applyAllowEmptySelection: function _applyAllowEmptySelection(value, old) {
        if (!value && this.isSelectionEmpty()) {
          this.resetSelection();
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION
      ---------------------------------------------------------------------------
      */

      /**
       * Select the item following the given item.
       */
      selectNext: function selectNext() {
        var item = this.getSelection()[0];
        var items = this.__items__P_419_0;
        var index = items.indexOf(item);

        if (index == -1) {
          return;
        }

        var i = 0;
        var length = items.length; // Find next enabled item

        if (this.getWrap()) {
          index = (index + 1) % length;
        } else {
          index = Math.min(index + 1, length - 1);
        }

        while (i < length && !items[index].getEnabled()) {
          index = (index + 1) % length;
          i++;
        }

        this.setSelection([items[index]]);
      },

      /**
       * Select the item previous the given item.
       */
      selectPrevious: function selectPrevious() {
        var item = this.getSelection()[0];
        var items = this.__items__P_419_0;
        var index = items.indexOf(item);

        if (index == -1) {
          return;
        }

        var i = 0;
        var length = items.length; // Find previous enabled item

        if (this.getWrap()) {
          index = (index - 1 + length) % length;
        } else {
          index = Math.max(index - 1, 0);
        }

        while (i < length && !items[index].getEnabled()) {
          index = (index - 1 + length) % length;
          i++;
        }

        this.setSelection([items[index]]);
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS FOR SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the items for the selection.
       *
       * @return {qx.ui.form.IRadioItem[]} Items to select.
       */
      _getItems: function _getItems() {
        return this.getItems();
      },

      /**
       * Returns if the selection could be empty or not.
       *
       * @return {Boolean} <code>true</code> If selection could be empty,
       *    <code>false</code> otherwise.
       */
      _isAllowEmptySelection: function _isAllowEmptySelection() {
        return this.isAllowEmptySelection();
      },

      /**
       * Returns whether the item is selectable. In opposite to the default
       * implementation (which checks for visible items) every radio button
       * which is part of the group is selected even if it is currently not visible.
       *
       * @param item {qx.ui.form.IRadioItem} The item to check if its selectable.
       * @return {Boolean} <code>true</code> if the item is part of the radio group
       *    <code>false</code> otherwise.
       */
      _isItemSelectable: function _isItemSelectable(item) {
        return this.__items__P_419_0.indexOf(item) != -1;
      },

      /**
       * Event handler for <code>changeSelection</code>.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      __onChangeSelection__P_419_1: function __onChangeSelection__P_419_1(e) {
        var value = e.getData()[0];
        var old = e.getOldData()[0];
        var groupedProperty = this.getGroupedProperty();

        if (old) {
          old.set(groupedProperty, false);
        }

        if (value) {
          value.set(groupedProperty, true);
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeArray("__items__P_419_0");
    }
  });
  qx.ui.form.RadioGroup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      },
      "qx.ui.core.ISingleSelectionProvider": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Responsible for the single selection management.
   *
   * The class manage a list of {@link qx.ui.core.Widget} which are returned from
   * {@link qx.ui.core.ISingleSelectionProvider#getItems}.
   *
   * @internal
   */
  qx.Class.define("qx.ui.core.SingleSelectionManager", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Construct the single selection manager.
     *
     * @param selectionProvider {qx.ui.core.ISingleSelectionProvider} The provider
     * for selection.
     */
    construct: function construct(selectionProvider) {
      qx.core.Object.constructor.call(this);
      {
        qx.core.Assert.assertInterface(selectionProvider, qx.ui.core.ISingleSelectionProvider, "Invalid selectionProvider!");
      }
      this.__selectionProvider__P_387_0 = selectionProvider;
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fires after the selection was modified */
      "changeSelected": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * If the value is <code>true</code> the manager allows an empty selection,
       * otherwise the first selectable element returned from the
       * <code>qx.ui.core.ISingleSelectionProvider</code> will be selected.
       */
      allowEmptySelection: {
        check: "Boolean",
        init: true,
        apply: "__applyAllowEmptySelection__P_387_1"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.core.Widget} The selected widget. */
      __selected__P_387_2: null,

      /** @type {qx.ui.core.ISingleSelectionProvider} The provider for selection management */
      __selectionProvider__P_387_0: null,

      /*
      ---------------------------------------------------------------------------
         PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the current selected element.
       *
       * @return {qx.ui.core.Widget | null} The current selected widget or
       *    <code>null</code> if the selection is empty.
       */
      getSelected: function getSelected() {
        return this.__selected__P_387_2;
      },

      /**
       * Selects the passed element.
       *
       * @param item {qx.ui.core.Widget} Element to select.
       * @throws {Error} if the element is not a child element.
       */
      setSelected: function setSelected(item) {
        if (!this.__isChildElement__P_387_3(item)) {
          throw new Error("Could not select " + item + ", because it is not a child element!");
        }

        this.__setSelected__P_387_4(item);
      },

      /**
       * Reset the current selection. If {@link #allowEmptySelection} is set to
       * <code>true</code> the first element will be selected.
       */
      resetSelected: function resetSelected() {
        this.__setSelected__P_387_4(null);
      },

      /**
       * Return <code>true</code> if the passed element is selected.
       *
       * @param item {qx.ui.core.Widget} Element to check if selected.
       * @return {Boolean} <code>true</code> if passed element is selected,
       *    <code>false</code> otherwise.
       * @throws {Error} if the element is not a child element.
       */
      isSelected: function isSelected(item) {
        if (!this.__isChildElement__P_387_3(item)) {
          throw new Error("Could not check if " + item + " is selected," + " because it is not a child element!");
        }

        return this.__selected__P_387_2 === item;
      },

      /**
       * Returns <code>true</code> if selection is empty.
       *
       * @return {Boolean} <code>true</code> if selection is empty,
       *    <code>false</code> otherwise.
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__selected__P_387_2 == null;
      },

      /**
       * Returns all elements which are selectable.
       *
       * @param all {Boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       * @return {qx.ui.core.Widget[]} The contained items.
       */
      getSelectables: function getSelectables(all) {
        var items = this.__selectionProvider__P_387_0.getItems();

        var result = [];

        for (var i = 0; i < items.length; i++) {
          if (this.__selectionProvider__P_387_0.isItemSelectable(items[i])) {
            result.push(items[i]);
          }
        } // in case of an user selectable list, remove the enabled items


        if (!all) {
          for (var i = result.length - 1; i >= 0; i--) {
            if (!result[i].getEnabled()) {
              result.splice(i, 1);
            }
          }

          ;
        }

        return result;
      },

      /*
      ---------------------------------------------------------------------------
         APPLY METHODS
      ---------------------------------------------------------------------------
      */
      // apply method
      __applyAllowEmptySelection__P_387_1: function __applyAllowEmptySelection__P_387_1(value, old) {
        if (!value) {
          this.__setSelected__P_387_4(this.__selected__P_387_2);
        }
      },

      /*
      ---------------------------------------------------------------------------
         HELPERS
      ---------------------------------------------------------------------------
      */

      /**
       * Set selected element.
       *
       * If passes value is <code>null</code>, the selection will be reseted.
       *
       * @param item {qx.ui.core.Widget | null} element to select, or
       *    <code>null</code> to reset selection.
       */
      __setSelected__P_387_4: function __setSelected__P_387_4(item) {
        var oldSelected = this.__selected__P_387_2;
        var newSelected = item;

        if (newSelected != null && oldSelected === newSelected) {
          return;
        }

        if (!this.isAllowEmptySelection() && newSelected == null) {
          var firstElement = this.getSelectables(true)[0];

          if (firstElement) {
            newSelected = firstElement;
          }
        }

        this.__selected__P_387_2 = newSelected;
        this.fireDataEvent("changeSelected", newSelected, oldSelected);
      },

      /**
       * Checks if passed element is a child element.
       *
       * @param item {qx.ui.core.Widget} Element to check if child element.
       * @return {Boolean} <code>true</code> if element is child element,
       *    <code>false</code> otherwise.
       */
      __isChildElement__P_387_3: function __isChildElement__P_387_3(item) {
        var items = this.__selectionProvider__P_387_0.getItems();

        for (var i = 0; i < items.length; i++) {
          if (items[i] === item) {
            return true;
          }
        }

        return false;
      }
    },

    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct: function destruct() {
      if (this.__selectionProvider__P_387_0.toHashCode) {
        this._disposeObjects("__selectionProvider__P_387_0");
      } else {
        this.__selectionProvider__P_387_0 = null;
      }

      this._disposeObjects("__selected__P_387_2");
    }
  });
  qx.ui.core.SingleSelectionManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This class is responsible for validation in all asynchronous cases and
   * should always be used with {@link qx.ui.form.validation.Manager}.
   *
   *
   * It acts like a wrapper for asynchronous validation functions. These
   * validation function must be set in the constructor. The form manager will
   * invoke the validation and the validator function will be called with two
   * arguments:
   * <ul>
   *  <li>asyncValidator: A reference to the corresponding validator.</li>
   *  <li>value: The value of the assigned input field.</li>
   * </ul>
   * These two parameters are needed to set the validation status of the current
   * validator. {@link #setValid} is responsible for doing that.
   *
   *
   * *Warning:* Instances of this class can only be used with one input
   * field at a time. Multi usage is not supported!
   *
   * *Warning:* Calling {@link #setValid} synchronously does not work. If you
   * have an synchronous validator, please check
   * {@link qx.ui.form.validation.Manager#add}. If you have both cases, you have
   * to wrap the synchronous call in a timeout to make it asynchronous.
   */
  qx.Class.define("qx.ui.form.validation.AsyncValidator", {
    extend: qx.core.Object,

    /**
     * @param validator {Function} The validator function, which has to be
     *   asynchronous.
     */
    construct: function construct(validator) {
      qx.core.Object.constructor.call(this); // save the validator function

      this.__validatorFunction__P_431_0 = validator;
    },
    members: {
      __validatorFunction__P_431_0: null,
      __item__P_431_1: null,
      __manager__P_431_2: null,
      __usedForForm__P_431_3: null,

      /**
       * The validate function should only be called by
       * {@link qx.ui.form.validation.Manager}.
       *
       * It stores the given information and calls the validation function set in
       * the constructor. The method is used for form fields only. Validating a
       * form itself will be invokes with {@link #validateForm}.
       *
       * @param item {qx.ui.core.Widget} The form item which should be validated.
       * @param value {var} The value of the form item.
       * @param manager {qx.ui.form.validation.Manager} A reference to the form
       *   manager.
       * @param context {var?null} The context of the validator.
       *
       * @internal
       */
      validate: function validate(item, value, manager, context) {
        // mark as item validator
        this.__usedForForm__P_431_3 = false; // store the item and the manager

        this.__item__P_431_1 = item;
        this.__manager__P_431_2 = manager; // invoke the user set validator function

        this.__validatorFunction__P_431_0.call(context || this, this, value);
      },

      /**
       * The validateForm function should only be called by
       * {@link qx.ui.form.validation.Manager}.
       *
       * It stores the given information and calls the validation function set in
       * the constructor. The method is used for forms only. Validating a
       * form item will be invokes with {@link #validate}.
       *
       * @param items {qx.ui.core.Widget[]} All form items of the form manager.
       * @param manager {qx.ui.form.validation.Manager} A reference to the form
       *   manager.
       * @param context {var?null} The context of the validator.
       *
       * @internal
       */
      validateForm: function validateForm(items, manager, context) {
        this.__usedForForm__P_431_3 = true;
        this.__manager__P_431_2 = manager;

        this.__validatorFunction__P_431_0.call(context, items, this);
      },

      /**
       * This method should be called within the asynchronous callback to tell the
       * validator the result of the validation.
       *
       * @param valid {Boolean} The boolean state of the validation.
       * @param message {String?} The invalidMessage of the validation.
       */
      setValid: function setValid(valid, message) {
        // valid processing
        if (this.__usedForForm__P_431_3) {
          // message processing
          if (message !== undefined) {
            this.__manager__P_431_2.setInvalidMessage(message);
          }

          this.__manager__P_431_2.setFormValid(valid);
        } else {
          // message processing
          if (message !== undefined) {
            this.__item__P_431_1.setInvalidMessage(message);
          }

          this.__manager__P_431_2.setItemValid(this.__item__P_431_1, valid);
        }
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this.__manager__P_431_2 = this.__item__P_431_1 = null;
    }
  });
  qx.ui.form.validation.AsyncValidator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Defines the callback for the single selection manager.
   *
   * @internal
   */
  qx.Interface.define("qx.ui.core.ISingleSelectionProvider", {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the elements which are part of the selection.
       *
       * @return {qx.ui.core.Widget[]} The widgets for the selection.
       */
      getItems: function getItems() {},

      /**
       * Returns whether the given item is selectable.
       *
       * @param item {qx.ui.core.Widget} The item to be checked
       * @return {Boolean} Whether the given item is selectable
       */
      isItemSelectable: function isItemSelectable(item) {}
    }
  });
  qx.ui.core.ISingleSelectionProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.ui.form.IArrayForm": {},
      "qx.ui.form.IForm": {},
      "qx.ui.form.MForm": {},
      "qx.data.controller.Form": {},
      "qx.ui.form.Form": {},
      "qx.data.marshal.Json": {},
      "qx.ui.form.TextField": {},
      "qx.util.DisposeUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 Martijn Evers, The Netherlands
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martijn Evers (mever)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.data.controller.fixture.ArrayField, qx.test.data.controller.fixture.ModelField)
   */
  qx.Class.define("qx.test.data.controller.FormWithArrayAndModel", {
    extend: qx.dev.unit.TestCase,
    members: {
      /** @type {qx.test.data.controller.fixture.ArrayField} */
      __arrayField__P_231_0: null,

      /** @type {qx.test.data.controller.fixture.ModelField} */
      __modelField__P_231_1: null,

      /** @type {qx.ui.form.Form} */
      __form__P_231_2: null,

      /** @type {qx.core.Object} */
      __model__P_231_3: null,
      setUp: function setUp() {
        // imagine me being a table like widget containing two columns (e.g. an miniature todo-list)
        qx.Class.define("qx.test.data.controller.fixture.ArrayField", {
          extend: qx.ui.core.Widget,
          implement: [qx.ui.form.IArrayForm, qx.ui.form.IForm],
          include: [qx.ui.form.MForm],
          events: {
            changeValue: "qx.event.type.Data"
          },
          members: {
            /** @type {qx.data.Array|null} */
            __value__P_231_4: null,

            /**
             * @param value {qx.data.Array|null}
             */
            setValue: function setValue(value) {
              var oldValue = this.__value__P_231_4;
              this.__value__P_231_4 = value;
              this.fireDataEvent("changeValue", value, oldValue);
            },

            /**
             * @return {qx.data.Array|null}
             */
            getValue: function getValue() {
              return this.__value__P_231_4;
            },
            resetValue: function resetValue() {
              this.__value__P_231_4 = null;
            }
          }
        }); // imagine me being a multi-field widget (e.g. address form embedded in user form)

        qx.Class.define("qx.test.data.controller.fixture.ModelField", {
          extend: qx.data.controller.Form,
          implement: [qx.ui.form.IArrayForm, qx.ui.form.IForm],
          include: [qx.ui.form.MForm],
          events: {
            changeValue: "qx.event.type.Data",
            // implement IForm interface
            changeEnabled: "qx.event.type.Data"
          },
          members: {
            // implement IForm interface
            setEnabled: function setEnabled() {},
            getEnabled: function getEnabled() {
              return true;
            },

            /**
             * @param value {qx.core.Object|null}
             */
            setValue: function setValue(value) {
              this.setModel(value);
            },

            /**
             * @return {qx.core.Object|null}
             */
            getValue: function getValue() {
              return this.getModel();
            },
            resetValue: function resetValue() {
              this.resetModel();
            },
            // overwritten
            _applyModel: function _applyModel(value, old) {
              qx.test.data.controller.fixture.ModelField.prototype._applyModel.base.call(this, value, old);

              this.fireDataEvent("changeValue", value, old);
            }
          }
        });
        this.__arrayField__P_231_0 = new qx.test.data.controller.fixture.ArrayField();
        this.__modelField__P_231_1 = new qx.test.data.controller.fixture.ModelField();
        this.__form__P_231_2 = new qx.ui.form.Form();

        this.__form__P_231_2.add(this.__arrayField__P_231_0, "One", null, "f1");

        this.__form__P_231_2.add(this.__modelField__P_231_1, "Two", null, "f2");

        this.__model__P_231_3 = qx.data.marshal.Json.createModel({
          f1: null,
          f2: null,
          f3: null
        });
      },
      tearDown: function tearDown() {
        this._disposeObjects("__arrayField__P_231_0", "__modelField__P_231_1", "__form__P_231_2", "__model__P_231_3");

        qx.Class.undefine("qx.test.data.controller.fixture.ArrayField");
        qx.Class.undefine("qx.test.data.controller.fixture.ModelField");
      },

      /**
       * Reusable address form.
       *
       * @return {qx.ui.form.Form} Address form.
       */
      __makeAddressForm__P_231_5: function __makeAddressForm__P_231_5() {
        var houseNr = new qx.ui.form.TextField();
        var streetName = new qx.ui.form.TextField();
        var addressForm = new qx.ui.form.Form();
        addressForm.add(houseNr, "houseNr");
        addressForm.add(streetName, "streetName");
        qx.util.DisposeUtil.disposeTriggeredBy(houseNr, addressForm);
        qx.util.DisposeUtil.disposeTriggeredBy(streetName, addressForm);
        return addressForm;
      },
      "test self update: array": function testSelfUpdateArray() {
        var arr = qx.data.marshal.Json.createModel([{
          c1: "1a1",
          c2: "1a2"
        }, {
          c1: "1b1",
          c2: "1b2"
        }]);
        arr.setAutoDisposeItems(true);

        this.__arrayField__P_231_0.setValue(arr); // sync form and model, model (null) takes preference over form (arr)


        var ctrl = new qx.data.controller.Form(this.__model__P_231_3, this.__form__P_231_2, true);
        this.assertNull(this.__arrayField__P_231_0.getValue());
        this.assertNull(this.__model__P_231_3.getF1()); // user changes field and hits ok button

        this.__arrayField__P_231_0.setValue(arr);

        ctrl.updateModel();
        this.assertIdentical(arr, this.__model__P_231_3.getF1());
        ctrl.dispose();
        arr.dispose();
      },
      "test self update: model": function testSelfUpdateModel() {
        var addressForm = this.__makeAddressForm__P_231_5();

        this.__modelField__P_231_1.setTarget(addressForm);

        var ctrl = new qx.data.controller.Form(this.__model__P_231_3, this.__form__P_231_2, true);
        this.assertNull(this.__arrayField__P_231_0.getValue());
        this.assertNull(this.__modelField__P_231_1.getValue()); // let's make an address for this user (this.__model being a user now ;) )

        this.__modelField__P_231_1.createModel(false);

        addressForm.getItem("houseNr").setValue("42");
        addressForm.getItem("streetName").setValue("Nowhere Ln");
        ctrl.updateModel(); // imagine f2 now being a user address

        this.assertIdentical("42", this.__model__P_231_3.getF2().getHouseNr());
        this.assertIdentical("Nowhere Ln", this.__model__P_231_3.getF2().getStreetName());
        ctrl.dispose();
        addressForm.dispose();
      },
      "test updating view": function testUpdatingView() {
        var arr = qx.data.marshal.Json.createModel([{
          c1: "2a1",
          c2: "2a2"
        }, {
          c1: "2b1",
          c2: "2b2"
        }]);
        arr.setAutoDisposeItems(true);

        this.__arrayField__P_231_0.setValue(arr); // sync form and model, model (null) takes preference over form (arr)


        var ctrl = new qx.data.controller.Form(this.__model__P_231_3, this.__form__P_231_2);
        this.assertNull(this.__arrayField__P_231_0.getValue());
        this.assertNull(this.__model__P_231_3.getF1()); // user changes field and hits ok button

        this.__arrayField__P_231_0.setValue(arr);

        this.assertIdentical(arr, this.__model__P_231_3.getF1());
        ctrl.dispose();
        arr.dispose();
      },
      "test updating model: array field": function testUpdatingModelArrayField() {
        var arr = qx.data.marshal.Json.createModel([{
          c1: "2a1",
          c2: "2a2"
        }, {
          c1: "2b1",
          c2: "2b2"
        }]);
        arr.setAutoDisposeItems(true);
        var ctrl = new qx.data.controller.Form(this.__model__P_231_3, this.__form__P_231_2); // change model, view should follow

        this.__model__P_231_3.setF1(arr);

        this.assertIdentical(arr, this.__arrayField__P_231_0.getValue());
        ctrl.dispose();
        arr.dispose();
      },
      "test updating model: model field": function testUpdatingModelModelField() {
        var addressForm = this.__makeAddressForm__P_231_5();

        this.__modelField__P_231_1.setTarget(addressForm);

        var ctrl = new qx.data.controller.Form(this.__model__P_231_3, this.__form__P_231_2);
        this.assertNull(this.__arrayField__P_231_0.getValue());
        this.assertNull(this.__modelField__P_231_1.getValue());

        this.__modelField__P_231_1.createModel(false);

        this.assertIdentical(this.__modelField__P_231_1.getModel(), this.__model__P_231_3.getF2());
        ctrl.dispose();
        addressForm.dispose();
      }
    }
  });
  qx.test.data.controller.FormWithArrayAndModel.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 Martijn Evers, The Netherlands
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martijn Evers (mever)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which have arrays as their primary data type.
   */
  qx.Interface.define("qx.ui.form.IArrayForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {qx.data.Array|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {qx.data.Array|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.IArrayForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.io.ImageLoader": {},
      "qx.ui.form.List": {},
      "qx.data.Array": {},
      "qx.data.controller.List": {},
      "qx.ui.form.SelectBox": {},
      "qx.data.marshal.Json": {},
      "qx.ui.form.ComboBox": {},
      "qx.ui.basic.Label": {},
      "qx.ui.form.CheckBox": {},
      "qx.core.Object": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @ignore(qx.demo.Kid, qx.demo.Parent)
   */
  qx.Class.define("qx.test.data.controller.List", {
    extend: qx.test.ui.LayoutTestCase,
    include: qx.dev.unit.MMock,
    members: {
      __list__P_232_0: null,
      __controller__P_232_1: null,
      __data__P_232_2: null,
      __model__P_232_3: null,
      setUp: function setUp() {
        // prevent the icon load error with this stub
        this.stub(qx.io.ImageLoader, "load");
        this.__list__P_232_0 = new qx.ui.form.List();
      },
      tearDown: function tearDown() {
        this.__controller__P_232_1 ? this.__controller__P_232_1.dispose() : null;
        this.__model__P_232_3 ? this.__model__P_232_3.dispose() : null;

        for (var i = 0; i < this.__list__P_232_0.getChildren().length; i++) {
          this.__list__P_232_0.getChildren()[i].destroy();
        }

        this.__list__P_232_0.destroy();

        this.flush();
        this.__controller__P_232_1 = null;
        this.__model__P_232_3 = null;
        this.__data__P_232_2 = null;
        qx.test.data.controller.List.prototype.tearDown.base.call(this); // clear the stub

        this.getSandbox().restore();
      },
      __setUpString__P_232_4: function __setUpString__P_232_4(attribute) {
        this.__data__P_232_2 = ["a", "b", "c", "d", "e"]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2); // create the controller

        this.__controller__P_232_1 = new qx.data.controller.List(this.__model__P_232_3, this.__list__P_232_0);
      },
      testChangeSelectionOnPush: function testChangeSelectionOnPush() {
        var selectBox = new qx.ui.form.SelectBox();
        var model = new qx.data.Array(["a", "b", "c"]);
        var controller = new qx.data.controller.List(model, selectBox);
        var change = false;
        controller.getSelection().addListener("change", function () {
          change = true;
        });
        model.push("d");
        this.wait(function () {
          this.assertFalse(change, "Change event has been fired.");
          selectBox.destroy();
          model.dispose();
          controller.dispose();
        }, 200, this);
      },
      testNumberModel: function testNumberModel() {
        var selectBox = new qx.ui.form.SelectBox();
        var model = qx.data.marshal.Json.createModel([1, 0]);
        var controller = new qx.data.controller.List(model, selectBox);
        controller.getSelection().push(0);
        this.assertEquals(1, controller.getSelection().length);
        this.assertEquals(0, controller.getSelection().getItem(0));
        selectBox.destroy();
        model.dispose();
        controller.dispose();
      },
      testModelChangeCombobox: function testModelChangeCombobox() {
        var model2 = new qx.data.Array(["A", "B"]);
        var box = new qx.ui.form.ComboBox();
        var controller = new qx.data.controller.List(this.__model__P_232_3, box); // change the model

        controller.setModel(model2);
        this.assertEquals("A", box.getChildControl("list").getChildren()[0].getLabel());
        this.assertEquals("B", box.getChildControl("list").getChildren()[1].getLabel());
        model2.dispose();
        box.dispose();
        controller.dispose();
      },
      testStringArray: function testStringArray() {
        this.__setUpString__P_232_4(); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        }
      },
      testEmptyList: function testEmptyList() {
        this.__setUpString__P_232_4();

        this.__controller__P_232_1.setModel(null); // check that the list is empty


        this.assertEquals(0, this.__list__P_232_0.getChildren().length);
      },
      testStringElementRemove: function testStringElementRemove() {
        this.__setUpString__P_232_4(); // remove the last elements


        this.__data__P_232_2.shift();

        this.__model__P_232_3.shift(); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        } // check the length


        this.assertEquals(this.__data__P_232_2.length, this.__list__P_232_0.getChildren().length, "Wrong length!");
      },
      testStringElementAdd: function testStringElementAdd() {
        this.__setUpString__P_232_4(); // remove the last elements


        this.__data__P_232_2.unshift("A");

        this.__model__P_232_3.unshift("A"); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        } // check the length


        this.assertEquals(this.__data__P_232_2.length, this.__list__P_232_0.getChildren().length, "Wrong length!");
      },
      testChangeElement: function testChangeElement() {
        this.__setUpString__P_232_4(); // change one element


        this.__data__P_232_2[0] = "A";

        this.__model__P_232_3.setItem(0, "A"); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        }
      },
      testChangeModelSmaller: function testChangeModelSmaller() {
        this.__setUpString__P_232_4();

        this.__model__P_232_3.dispose(); // change one element


        this.__data__P_232_2 = ["f", "g", "h", "i"];
        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2);

        this.__controller__P_232_1.setModel(this.__model__P_232_3); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        } // check the length


        this.assertEquals(this.__data__P_232_2.length, this.__list__P_232_0.getChildren().length, "Wrong length!");
      },
      testChangeModelBigger: function testChangeModelBigger() {
        this.__setUpString__P_232_4();

        this.__model__P_232_3.dispose(); // change one element


        this.__data__P_232_2 = ["f", "g", "h", "i", "j", "k"];
        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2);

        this.__controller__P_232_1.setModel(this.__model__P_232_3); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        } // check the length


        this.assertEquals(this.__data__P_232_2.length, this.__list__P_232_0.getChildren().length, "Wrong length!");
      },
      testChangeTarget: function testChangeTarget() {
        this.__setUpString__P_232_4();

        var list = new qx.ui.form.List(); // change the target

        this.__controller__P_232_1.setTarget(list); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = list.getChildren()[i].getLabel();
          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        } // check the length of the old list


        this.assertEquals(0, this.__list__P_232_0.getChildren().length, "Wrong length!");
        list.dispose();
      },
      testReverse: function testReverse() {
        this.__setUpString__P_232_4(); // reverse the datas


        this.__data__P_232_2.reverse();

        this.__model__P_232_3.reverse(); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        }
      },
      testBooleanArray: function testBooleanArray() {
        this.__data__P_232_2 = [true, false, false]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2); // create the controller

        this.__controller__P_232_1 = new qx.data.controller.List(this.__model__P_232_3, this.__list__P_232_0);
        var checkArray = ["true", "false", "false"]; // check the binding

        for (var i = 0; i < checkArray.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(checkArray[i], label, "Boolean-Binding " + i + " is wrong!");
        }
      },
      testNumberArray: function testNumberArray() {
        this.__data__P_232_2 = [10, 20, -1, 50]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2); // create the controller

        this.__controller__P_232_1 = new qx.data.controller.List(this.__model__P_232_3, this.__list__P_232_0);
        var checkArray = ["10", "20", "-1", "50"]; // check the binding

        for (var i = 0; i < checkArray.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(checkArray[i], label, "Boolean-Binding " + i + " is wrong!");
        }
      },
      testSelectBox: function testSelectBox() {
        this.__data__P_232_2 = ["10", "20", "-1", "50"]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2); // create the controller

        var box = new qx.ui.form.SelectBox();
        this.__controller__P_232_1 = new qx.data.controller.List(this.__model__P_232_3, box); // check the binding

        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = box.getChildren()[i].getLabel();
          this.assertEquals(this.__data__P_232_2[i], label, "SelectBox-Binding " + i + " is wrong!");
        }

        box.dispose();
      },
      testComboBox: function testComboBox() {
        this.__data__P_232_2 = ["10", "20", "-1", "50"]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2); // create the controller

        var box = new qx.ui.form.ComboBox();
        this.__controller__P_232_1 = new qx.data.controller.List(this.__model__P_232_3, box); // check the binding

        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = box.getChildren()[i].getLabel();
          this.assertEquals(this.__data__P_232_2[i], label, "ComboBox-Binding " + i + " is wrong!");
        }

        box.dispose();
      },
      testResetSelectionSingle: function testResetSelectionSingle() {
        this.__setUpString__P_232_4();

        var box = new qx.ui.form.SelectBox();

        this.__controller__P_232_1.setTarget(box);

        var model = new qx.data.Array(["x", "y", "z"]);

        this.__controller__P_232_1.getSelection().push("b"); // change the model (should reset the selection)


        this.__controller__P_232_1.setModel(model); // first element should be selected because its a select box


        this.wait(100, function () {
          this.assertEquals("x", this.__controller__P_232_1.getSelection().getItem(0));
          model.dispose();
          box.destroy();
        }, this);
      },
      testSelectionSingle: function testSelectionSingle() {
        this.__setUpString__P_232_4(); // select the first object


        this.__list__P_232_0.addToSelection(this.__list__P_232_0.getChildren()[0]); // test the selection


        this.assertEquals(this.__model__P_232_3.getItem(0), this.__controller__P_232_1.getSelection().getItem(0), "Selection does not work."); // test for the length

        this.assertEquals(1, this.__controller__P_232_1.getSelection().length, "Selection length is wrong."); // select the second object

        this.__list__P_232_0.addToSelection(this.__list__P_232_0.getChildren()[1]); // test the selection


        this.assertEquals(this.__model__P_232_3.getItem(1), this.__controller__P_232_1.getSelection().getItem(0), "Selection does not work."); // test for the length

        this.assertEquals(1, this.__controller__P_232_1.getSelection().length, "Selection length is wrong.");
      },
      testSelectionSingleRemoveFirst: function testSelectionSingleRemoveFirst() {
        this.__setUpString__P_232_4();

        var model = this.__model__P_232_3;

        this.__list__P_232_0.setSelectionMode("one");

        var selection = this.__controller__P_232_1.getSelection();

        this.assertEquals(model.getItem(0), this.__list__P_232_0.getSelection()[0].getModel());
        this.assertEventFired(selection, "change", function () {
          model.removeAt(0);
        });
      },
      testSelectionMultiple: function testSelectionMultiple() {
        this.__setUpString__P_232_4(); // select the second and third object


        this.__list__P_232_0.setSelectionMode("multi");

        this.__list__P_232_0.addToSelection(this.__list__P_232_0.getChildren()[1]);

        this.__list__P_232_0.addToSelection(this.__list__P_232_0.getChildren()[2]); // test the selection


        this.assertEquals(this.__model__P_232_3.getItem(1), this.__controller__P_232_1.getSelection().getItem(0), "Selection does not work.");
        this.assertEquals(this.__model__P_232_3.getItem(2), this.__controller__P_232_1.getSelection().getItem(1), "Selection does not work."); // test for the selection length

        this.assertEquals(2, this.__controller__P_232_1.getSelection().length, "Selection length is wrong.");
      },
      testSelectionBackSingle: function testSelectionBackSingle() {
        this.__setUpString__P_232_4(); // add the first element to the selection


        this.__controller__P_232_1.getSelection().push(this.__model__P_232_3.getItem(0)); // test the selection


        this.assertEquals(this.__model__P_232_3.getItem(0), this.__controller__P_232_1.getSelection().getItem(0), "addToSelection does not work.");
      },
      testSelectionBackMultiple: function testSelectionBackMultiple() {
        this.__setUpString__P_232_4(); // select the second and third object


        this.__list__P_232_0.setSelectionMode("multi"); // add the some elements to the selection


        this.__controller__P_232_1.getSelection().push(this.__model__P_232_3.getItem(1));

        this.__controller__P_232_1.getSelection().push(this.__model__P_232_3.getItem(2)); // test the selection


        this.assertEquals(this.__model__P_232_3.getItem(1), this.__controller__P_232_1.getSelection().getItem(0), "addToSelection does not work.");
        this.assertEquals(this.__model__P_232_3.getItem(2), this.__controller__P_232_1.getSelection().getItem(1), "addToSelection does not work.");
      },
      testSelectionArrayChange: function testSelectionArrayChange() {
        this.__setUpString__P_232_4(); // set a new selection array


        this.__controller__P_232_1.setSelection(new qx.data.Array([this.__model__P_232_3.getItem(0)])); // test the selection


        this.assertEquals(this.__model__P_232_3.getItem(0), this.__list__P_232_0.getSelection()[0].getLabel(), "Change the selection array does not work.");

        this.__controller__P_232_1.getSelection().dispose();
      },
      testSelectionArrayChangeItem: function testSelectionArrayChangeItem() {
        this.__setUpString__P_232_4(); // set the selection in the array


        this.__controller__P_232_1.getSelection().push(this.__model__P_232_3.getItem(0)); // test the selection


        this.assertEquals(this.__model__P_232_3.getItem(0), this.__list__P_232_0.getSelection()[0].getLabel(), "Change the selection array does not work.");
      },
      testSelectionArrayReverse: function testSelectionArrayReverse() {
        this.__setUpString__P_232_4(); // set the selection in the array


        this.__controller__P_232_1.getSelection().push(this.__model__P_232_3.getItem(0)); // test the selection


        this.assertEquals(this.__model__P_232_3.getItem(0), this.__list__P_232_0.getSelection()[0].getLabel(), "Change the selection array does not work."); // reverse the model

        this.__model__P_232_3.reverse(); // test the selection (the selection is async in that case)


        var self = this;
        this.wait(100, function () {
          self.assertEquals(self.__model__P_232_3.getItem(self.__model__P_232_3.getLength() - 1), self.__list__P_232_0.getSelection()[0].getLabel(), "Can not handle reverse.");
        });
      },
      testSelectionAfterDelete: function testSelectionAfterDelete() {
        this.__setUpString__P_232_4(); // add b to the selection


        this.__controller__P_232_1.getSelection().push("b"); // remove the first element of the controller 'a'


        this.__model__P_232_3.shift(); // check if the selected item in the list is "b"


        this.assertTrue(this.__controller__P_232_1.getSelection().contains("b"), "Selection array wrong!"); // selection updates work with the widget pool and can be async

        this.wait(100, function () {
          this.assertEquals("b", this.__list__P_232_0.getSelection()[0].getLabel(), "Remove from selection does not work!");
        }, this);
      },
      testSelectionAfterDeleteEmpty: function testSelectionAfterDeleteEmpty() {
        this.__setUpString__P_232_4(); // add c to the selection


        this.__controller__P_232_1.getSelection().push("c"); // remove the c


        this.__model__P_232_3.splice(2, 1); // selection updates work with the widget pool and can be async


        this.wait(100, function () {
          // check if the selection is empty
          this.assertEquals(0, this.__controller__P_232_1.getSelection().length, "Remove from selection does not work!");
        }, this);
      },
      testResetBug: function testResetBug() {
        this.__setUpString__P_232_4(); // create the test label


        var label = new qx.ui.basic.Label();

        this.__controller__P_232_1.bind("selection[0]", label, "value"); // add stuff to the selection


        this.__controller__P_232_1.getSelection().push("c"); // remove the first element of the controller 'a'


        this.__model__P_232_3.shift();

        this.__model__P_232_3.shift(); // check for the label


        this.assertEquals("c", label.getValue(), "Label has not the right value."); // remove the selected element

        this.__model__P_232_3.shift(); // check for null


        var self = this;
        this.wait(100, function () {
          self.assertNull(label.getValue(), "Label does still contain something!");
        }, this);
      },
      testDates: function testDates() {
        this.__data__P_232_2 = [new Date(0), new Date(100)]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2); // create the controller

        this.__controller__P_232_1 = new qx.data.controller.List(this.__model__P_232_3, this.__list__P_232_0); // check the binding

        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i].toString(), label, "Date-Binding " + i + " is wrong!");
        }
      },
      testConversionLabel: function testConversionLabel() {
        this.__setUpString__P_232_4(); // create the options map with the converter


        var options = {};

        options.converter = function (data) {
          return data + " Converted";
        };

        this.__controller__P_232_1.setLabelOptions(options); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i] + " Converted", label, "Binding " + i + " is wrong!");
        }
      },
      testOnUpdateLabel: function testOnUpdateLabel() {
        this.__data__P_232_2 = ["a", "b", "c", "d", "e"]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2); // create the options map with the converter

        var options = {};
        var flag = false;

        options.onUpdate = function () {
          flag = true;
        }; // create the controller


        this.__controller__P_232_1 = new qx.data.controller.List(this.__model__P_232_3, this.__list__P_232_0);

        this.__controller__P_232_1.setLabelOptions(options); // change something to invoke a change of a binding


        this.__data__P_232_2.pop();

        this.__model__P_232_3.pop(); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        } // check if the flag is set


        this.assertTrue(flag, "onUpdate not executed");
      },
      testSelectBoxSelectionSingle: function testSelectBoxSelectionSingle() {
        this.__data__P_232_2 = ["10", "20", "-1", "50"]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2); // create the controller

        var box = new qx.ui.form.SelectBox();
        this.__controller__P_232_1 = new qx.data.controller.List(this.__model__P_232_3, box); // add 10 to the selection

        this.__controller__P_232_1.getSelection().push("10"); // check for the Selection


        this.assertEquals("10", box.getSelection()[0].getLabel(), "Wrong selection");
        box.dispose();
      },
      testSelectionWithModelChange: function testSelectionWithModelChange() {
        this.__setUpString__P_232_4(); // select the first object


        this.__list__P_232_0.addToSelection(this.__list__P_232_0.getChildren()[0]); // test the selection


        this.assertEquals(this.__model__P_232_3.getItem(0), this.__controller__P_232_1.getSelection().getItem(0), "Selection does not work."); // change the model

        this.__controller__P_232_1.setModel(new qx.data.Array(["x", "y", "z"])); // test for an empty selection


        this.assertEquals(0, this.__controller__P_232_1.getSelection().length, "Selection is not empty."); // select an item

        this.__controller__P_232_1.getSelection().push("x"); // test for the selection


        this.assertEquals("x", this.__controller__P_232_1.getSelection().getItem(0), "Selection is wrong.");

        this.__controller__P_232_1.getModel().dispose();
      },
      testSelectionWithModelChangeSelectBox: function testSelectionWithModelChangeSelectBox() {
        this.__data__P_232_2 = ["a", "b", "c", "d", "e"]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2);
        var selectBox = new qx.ui.form.SelectBox(); // create the controller

        this.__controller__P_232_1 = new qx.data.controller.List(this.__model__P_232_3, selectBox); // first object is selected (one selection mode)
        // test the selection

        this.assertEquals(this.__model__P_232_3.getItem(0), selectBox.getSelection()[0].getModel());
        this.assertEquals(this.__model__P_232_3.getItem(0), this.__controller__P_232_1.getSelection().getItem(0), "Selection does not work."); // change the model

        this.__controller__P_232_1.setModel(new qx.data.Array(["x", "y", "z"])); // select an item


        this.__controller__P_232_1.getSelection().push("y"); // test for the selection


        this.assertEquals(1, this.__controller__P_232_1.getSelection().length, "Selection has a wrong length.");
        this.assertEquals("y", this.__controller__P_232_1.getSelection().getItem(0), "Selection is wrong.");

        this.__controller__P_232_1.setModel(new qx.data.Array(["1", "2", "3"]));

        this.__controller__P_232_1.addListener("changeSelection", function () {
          this.resume(function () {
            // test for the first selected item (one selection)
            this.assertEquals(1, this.__controller__P_232_1.getSelection().length, "Selection has a wrong length.");
            this.assertEquals("1", this.__controller__P_232_1.getSelection().getItem(0), "Selection does not work.");
            selectBox.dispose();
          }, this);
        }, this);

        this.wait();
      },
      testFilterApply: function testFilterApply() {
        this.__setUpString__P_232_4();

        var delegate = {};

        delegate.filter = function (data) {
          return data == "b" || data == "c" || data == "d";
        };

        this.__controller__P_232_1.setDelegate(delegate); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length - 2; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i + 1], label, "Binding " + i + " is wrong!");
        }
      },
      testFilterChange: function testFilterChange() {
        this.__setUpString__P_232_4();

        var delegate1 = {};

        delegate1.filter = function (data) {
          return data == "b" || data == "c" || data == "d";
        };

        var delegate2 = {};

        delegate2.filter = function (data) {
          return data == "a" || data == "b" || data == "c";
        };

        this.__controller__P_232_1.setDelegate(delegate1);

        this.__controller__P_232_1.setDelegate(delegate2); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length - 2; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        }
      },
      testFilterChangeModel: function testFilterChangeModel() {
        this.__setUpString__P_232_4();

        var delegate = {};

        delegate.filter = function (data) {
          return data == "B" || data == "C" || data == "D";
        };

        this.__controller__P_232_1.setDelegate(delegate); // check for the right length


        this.assertEquals(0, this.__list__P_232_0.getChildren().length, "Some list items created.");
        var model = new qx.data.Array("A", "B", "C", "D", "E");

        this.__controller__P_232_1.setModel(model); // check the length


        this.assertEquals(3, this.__list__P_232_0.getChildren().length, "Wrong number of list items"); // check the labels

        this.assertEquals("B", this.__list__P_232_0.getChildren()[0].getLabel(), "Binding is wrong!");
        this.assertEquals("C", this.__list__P_232_0.getChildren()[1].getLabel(), "Binding is wrong!");
        this.assertEquals("D", this.__list__P_232_0.getChildren()[2].getLabel(), "Binding is wrong!");
        model.dispose();
      },
      testFilterReverseModel: function testFilterReverseModel() {
        this.__setUpString__P_232_4();

        var delegate = {};

        delegate.filter = function (data) {
          return data == "a" || data == "b" || data == "c";
        };

        this.__controller__P_232_1.setDelegate(delegate); // check for the right length


        this.assertEquals(3, this.__list__P_232_0.getChildren().length, "Some list items created."); // check the labels

        this.assertEquals("a", this.__list__P_232_0.getChildren()[0].getLabel(), "Binding is wrong!");
        this.assertEquals("b", this.__list__P_232_0.getChildren()[1].getLabel(), "Binding is wrong!");
        this.assertEquals("c", this.__list__P_232_0.getChildren()[2].getLabel(), "Binding is wrong!"); // reverse the order of the model

        this.__model__P_232_3.reverse(); // check for the right length


        this.assertEquals(3, this.__list__P_232_0.getChildren().length, "Some list items created."); // check the labels

        this.assertEquals("c", this.__list__P_232_0.getChildren()[0].getLabel(), "Binding is wrong!");
        this.assertEquals("b", this.__list__P_232_0.getChildren()[1].getLabel(), "Binding is wrong!");
        this.assertEquals("a", this.__list__P_232_0.getChildren()[2].getLabel(), "Binding is wrong!");
      },
      testFilterRemove: function testFilterRemove() {
        this.__setUpString__P_232_4();

        var delegate = {};

        delegate.filter = function (data) {
          return data == "a" || data == "b" || data == "c";
        };

        this.__controller__P_232_1.setDelegate(delegate); // check for the right length


        this.assertEquals(3, this.__list__P_232_0.getChildren().length, "Some list items created."); // check the labels

        this.assertEquals("a", this.__list__P_232_0.getChildren()[0].getLabel(), "Binding is wrong!");
        this.assertEquals("b", this.__list__P_232_0.getChildren()[1].getLabel(), "Binding is wrong!");
        this.assertEquals("c", this.__list__P_232_0.getChildren()[2].getLabel(), "Binding is wrong!"); // remove the filter

        this.__controller__P_232_1.setDelegate(null); // check for the right length


        this.assertEquals(5, this.__list__P_232_0.getChildren().length, "Some list items created."); // check the labels

        this.assertEquals("a", this.__list__P_232_0.getChildren()[0].getLabel(), "Binding is wrong!");
        this.assertEquals("b", this.__list__P_232_0.getChildren()[1].getLabel(), "Binding is wrong!");
        this.assertEquals("c", this.__list__P_232_0.getChildren()[2].getLabel(), "Binding is wrong!");
        this.assertEquals("d", this.__list__P_232_0.getChildren()[3].getLabel(), "Binding is wrong!");
        this.assertEquals("e", this.__list__P_232_0.getChildren()[4].getLabel(), "Binding is wrong!");
      },
      testFilterChangeTarget: function testFilterChangeTarget() {
        this.__setUpString__P_232_4();

        var list = new qx.ui.form.List();
        var delegate = {};

        delegate.filter = function (data) {
          return data == "b" || data == "d";
        };

        this.__controller__P_232_1.setDelegate(delegate); // check the length of the first list


        this.assertEquals(2, this.__list__P_232_0.getChildren().length, "Wrong number of list items"); // change the target

        this.__controller__P_232_1.setTarget(null); // check if everything is cleaned up


        this.assertEquals(0, this.__list__P_232_0.getChildren().length, "Wrong number of list items"); // set the new target

        this.__controller__P_232_1.setTarget(list); // check the new target


        this.assertEquals(2, list.getChildren().length, "Wrong number of list items");
        this.assertEquals("b", list.getChildren()[0].getLabel(), "Binding is wrong!");
        this.assertEquals("d", list.getChildren()[1].getLabel(), "Binding is wrong!");

        this.__controller__P_232_1.dispose();

        list.dispose();
      },
      testFilterWithSelection: function testFilterWithSelection() {
        this.__setUpString__P_232_4();

        var delegate = {};

        delegate.filter = function (data) {
          return data == "a" || data == "e";
        };

        this.__controller__P_232_1.setDelegate(delegate); // select the first object


        this.__list__P_232_0.addToSelection(this.__list__P_232_0.getChildren()[0]); // test the selection


        this.assertEquals(this.__model__P_232_3.getItem(0), this.__controller__P_232_1.getSelection().getItem(0), "Selection does not work."); // test for the length

        this.assertEquals(1, this.__controller__P_232_1.getSelection().length, "Selection length is wrong."); // select the second object

        this.__list__P_232_0.addToSelection(this.__list__P_232_0.getChildren()[1]); // test the selection


        this.assertEquals(this.__model__P_232_3.getItem(4), this.__controller__P_232_1.getSelection().getItem(0), "Selection does not work."); // test for the length

        this.assertEquals(1, this.__controller__P_232_1.getSelection().length, "Selection length is wrong.");
      },
      testFilterAfterSelection: function testFilterAfterSelection() {
        this.__setUpString__P_232_4(); // select the first object


        this.__list__P_232_0.addToSelection(this.__list__P_232_0.getChildren()[1]); // apply the filter


        var delegate = {};

        delegate.filter = function (data) {
          return data == "b" || data == "c" || data == "d";
        };

        this.__controller__P_232_1.setDelegate(delegate);

        this.assertEquals("b", this.__controller__P_232_1.getSelection().getItem(0), "Selection does not work.");
        this.assertEquals("b", this.__list__P_232_0.getSelection()[0].getLabel(), "Selection does not work.");
      },
      testDelegateLate: function testDelegateLate() {
        this.__setUpString__P_232_4(); // create the delegate


        var delegate = {};

        delegate.configureItem = function (item) {
          item.setRich(true);
        };

        this.__controller__P_232_1.setDelegate(delegate); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var item = this.__list__P_232_0.getChildren()[i];

          this.assertTrue(item.getRich(), "Delegate " + i + " is wrong!");
        }
      },
      testDelegateFirst: function testDelegateFirst() {
        this.__data__P_232_2 = ["a", "b", "c", "d", "e"]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2); // create the controller

        this.__controller__P_232_1 = new qx.data.controller.List(); // create the delegate

        var delegate = {};

        delegate.configureItem = function (item) {
          item.setRich(true);
        };

        this.__controller__P_232_1.setDelegate(delegate);

        this.__controller__P_232_1.setTarget(this.__list__P_232_0);

        this.__controller__P_232_1.setModel(this.__model__P_232_3); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var item = this.__list__P_232_0.getChildren()[i];

          this.assertTrue(item.getRich(), "Delegate " + i + " is wrong!");
        }
      },
      testDelegateBindItem: function testDelegateBindItem() {
        this.__data__P_232_2 = [true, true, false, true, false]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2);
        this.__controller__P_232_1 = new qx.data.controller.List();
        var delegate = {};

        delegate.createItem = function () {
          return new qx.ui.form.CheckBox();
        };

        delegate.bindItem = function (controller, item, id) {
          controller.bindProperty(null, "enabled", null, item, id);
        };

        this.__controller__P_232_1.setDelegate(delegate);

        this.__controller__P_232_1.setTarget(this.__list__P_232_0);

        this.__controller__P_232_1.setModel(this.__model__P_232_3); // check the binding
        // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          this.assertEquals("qx.ui.form.CheckBox", this.__list__P_232_0.getChildren()[i].classname);

          var label = this.__list__P_232_0.getChildren()[i].getEnabled();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        }
      },
      testDelegateBindItemLate: function testDelegateBindItemLate() {
        this.__data__P_232_2 = [true, true, false, true, false]; // create a new array

        this.__model__P_232_3 = new qx.data.Array(this.__data__P_232_2);
        this.__controller__P_232_1 = new qx.data.controller.List();

        this.__controller__P_232_1.setTarget(this.__list__P_232_0);

        this.__controller__P_232_1.setModel(this.__model__P_232_3);

        var delegate = {};

        delegate.createItem = function () {
          return new qx.ui.form.CheckBox();
        };

        delegate.bindItem = function (controller, item, id) {
          controller.bindProperty(null, "enabled", null, item, id);
        };

        this.__controller__P_232_1.setDelegate(delegate); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          this.assertEquals("qx.ui.form.CheckBox", this.__list__P_232_0.getChildren()[i].classname);

          var label = this.__list__P_232_0.getChildren()[i].getEnabled();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        }
      },
      testDelegateBindDefaultProperties: function testDelegateBindDefaultProperties() {
        this.__setUpString__P_232_4();

        this.__controller__P_232_1.setModel(null);

        var delegate = {};

        delegate.bindItem = function (controller, item, id) {
          controller.bindDefaultProperties(item, id);
        };

        this.__controller__P_232_1.setDelegate(delegate);

        this.__controller__P_232_1.setModel(this.__model__P_232_3); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_232_2[i], label, "Binding " + i + " is wrong!");
        }
      },
      testDelegateBindDefaultPropertiesLate: function testDelegateBindDefaultPropertiesLate() {
        this.__setUpString__P_232_4();

        var delegate = {};

        delegate.bindItem = function (controller, item, id) {
          controller.bindDefaultProperties(item, id);
        };

        this.__controller__P_232_1.setDelegate(delegate); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          this.__model__P_232_3.setItem(i, i + "");

          var label = this.__list__P_232_0.getChildren()[i].getLabel();

          this.assertEquals(i + "", label, "Binding " + i + " is wrong!");
        }
      },
      testSelectionSequence: function testSelectionSequence() {
        // "a", "b", "c", "d", "e"
        this.__setUpString__P_232_4();

        this.__list__P_232_0.setSelectionMode("multi");

        var selList = new qx.ui.form.List();
        var selController = new qx.data.controller.List(null, selList); // add the last two to the selection of the first list

        this.__list__P_232_0.addToSelection(this.__list__P_232_0.getChildren()[4]);

        this.__list__P_232_0.addToSelection(this.__list__P_232_0.getChildren()[3]); // special hack for chrome because his selection order is different


        selController.setModel(this.__controller__P_232_1.getSelection());
        var labels = [];

        for (var i = 0; i < selList.getChildren().length; i++) {
          labels.push(selList.getChildren()[i].getLabel());
        }

        ; // check if the second list is filled right

        this.assertNotEquals(-1, labels.indexOf("e"), "e is not in the selection list.");
        this.assertNotEquals(-1, labels.indexOf("d"), "d is not in the selection list.");
        selList.addToSelection(selList.getChildren()[1]);
        this.assertEquals(selList.getChildren()[1].getLabel(), selController.getSelection().getItem(0), "d not selected in the second list."); // remove the last element of the first list

        this.__model__P_232_3.pop();

        this.wait(100, function () {
          // is d still in the list?
          this.assertEquals("d", selList.getChildren()[0].getLabel(), "d is not in the selection list anymore."); // get rid of that old stuff

          this.flush();
          selList.dispose();
          selController.dispose();
        }, this);
      },
      testGetVisibleModels: function testGetVisibleModels() {
        this.__setUpString__P_232_4();

        var delegate = {};

        delegate.filter = function (data) {
          return data == "b" || data == "c" || data == "d";
        };

        this.__controller__P_232_1.setDelegate(delegate);

        var visibleModels = this.__controller__P_232_1.getVisibleModels();

        this.assertEquals(visibleModels.classname, "qx.data.Array");
        this.assertEquals(3, visibleModels.getLength());
        this.assertEquals("b", visibleModels.getItem(0));
        this.assertEquals("c", visibleModels.getItem(1));
        this.assertEquals("d", visibleModels.getItem(2));
        visibleModels.dispose();
      },
      testBindIconWithStringArray: function testBindIconWithStringArray() {
        this.__setUpString__P_232_4();

        this.__controller__P_232_1.setIconPath(""); // check the binding


        for (var i = 0; i < this.__data__P_232_2.length; i++) {
          var icon = this.__list__P_232_0.getChildren()[i].getIcon();

          this.assertEquals(this.__data__P_232_2[i], icon, "Binding " + i + " is wrong!");
        }
      },
      testScrollBySelection: function testScrollBySelection() {
        this.__setUpString__P_232_4(); // set a smal hight (list has to scroll)


        this.__list__P_232_0.setHeight(40);

        this.getRoot().add(this.__list__P_232_0);

        var selectables = this.__list__P_232_0.getSelectables(); // select the first item


        this.__list__P_232_0.setSelection([selectables[0]]); // scroll a bit down (scrollY is 40)


        this.__list__P_232_0.scrollByY(40); // select the current visible item


        this.__list__P_232_0.addToSelection(selectables[2]); // check that it has not been scrolled


        this.assertEquals(40, this.__list__P_232_0.getScrollY());
      },
      testScrollBySelectionMulti: function testScrollBySelectionMulti() {
        this.__setUpString__P_232_4(); // set a smal hight (list has to scroll)


        this.__list__P_232_0.setHeight(40);

        this.__list__P_232_0.setSelectionMode("multi");

        this.getRoot().add(this.__list__P_232_0);

        var selectables = this.__list__P_232_0.getSelectables(); // select the first item


        this.__list__P_232_0.setSelection([selectables[0]]); // scroll a bit down (scrollY is 40)


        this.__list__P_232_0.scrollByY(40); // select the current visible item


        this.__list__P_232_0.addToSelection(selectables[2]); // check that it has not been scrolled


        this.assertEquals(40, this.__list__P_232_0.getScrollY());
      },
      testBug1947: function testBug1947() {
        qx.Class.define("qx.demo.Kid", {
          extend: qx.core.Object,
          properties: {
            name: {
              check: "String",
              event: "changeName",
              init: null
            }
          }
        });
        var kid = new qx.demo.Kid();
        qx.Class.define("qx.demo.Parent", {
          extend: qx.core.Object,
          construct: function construct() {
            qx.core.Object.constructor.call(this);
            this.setKid(kid);
          },
          properties: {
            name: {
              check: "String",
              event: "changeName",
              init: null
            },
            kid: {
              check: "qx.demo.Kid",
              event: "changeKid"
            }
          }
        });
        var parentA = new qx.demo.Parent();
        parentA.setName("parentA");
        parentA.getKid().setName("kidA");
        var parentB = new qx.demo.Parent();
        parentB.setName("parentB");
        parentB.getKid().setName("kidB");
        var parents = new qx.data.Array();
        parents.push(parentA);
        parents.push(parentB);
        var list = new qx.ui.form.List();
        var ctrl = new qx.data.controller.List(parents, list, "name");
        var label = new qx.ui.basic.Label();
        label.setDecorator("main");
        ctrl.bind("selection[0].Kid.Name", label, "value");
        ctrl.getSelection().push(parentA);
        parentA.dispose();
        parentB.dispose();
        kid.dispose();
        list.dispose();
        ctrl.dispose();
        label.dispose();
        parents.dispose();
      },
      testBug1988: function testBug1988() {
        qx.Class.define("qx.demo.Kid", {
          extend: qx.core.Object,
          properties: {
            name: {
              check: "String",
              event: "changeName",
              init: null,
              nullable: true
            }
          }
        }); //var kid = new qx.demo.Kid();

        qx.Class.define("qx.demo.Parent", {
          extend: qx.core.Object,
          construct: function construct() {
            qx.core.Object.constructor.call(this);
            this.setKid(new qx.demo.Kid());
          },
          properties: {
            name: {
              check: "String",
              event: "changeName",
              init: null
            },
            kid: {
              check: "qx.demo.Kid",
              event: "changeKid"
            }
          }
        });
        var parentA = new qx.demo.Parent();
        parentA.setName("parentA");
        parentA.getKid().setName("kidA");
        var parentB = new qx.demo.Parent();
        parentB.setName("parentB"); //parentB.getKid().setName("kidB");

        var parents = new qx.data.Array();
        parents.push(parentA);
        parents.push(parentB);
        var list = new qx.ui.form.List();
        var ctrl = new qx.data.controller.List(parents, list, "name");
        var label = new qx.ui.basic.Label();
        ctrl.bind("selection[0].kid.name", label, "value"); // select the first child of the list

        list.addToSelection(list.getChildren()[0]); // check the label

        this.assertEquals("kidA", label.getValue(), "Wrong name in the label."); // select the second label

        list.addToSelection(list.getChildren()[1]);
        this.assertNull(label.getValue(), "Label has not been reseted.");
        parentA.getKid().dispose();
        parentA.dispose();
        parentB.getKid().dispose();
        parentB.dispose();
        list.dispose();
        ctrl.dispose();
        label.dispose();
        parents.dispose();
      },
      testSpliceAll: function testSpliceAll() {
        this.__setUpString__P_232_4();

        this.__model__P_232_3.splice(0, 5, "A", "B", "C", "D", "E");

        this.assertEquals("E", this.__list__P_232_0.getChildren()[4].getLabel());
      }
    }
  });
  qx.test.data.controller.List.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.AbstractSelectBox": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IStringForm": {
        "require": true
      },
      "qx.event.type.Focus": {
        "construct": true
      },
      "qx.ui.form.TextField": {},
      "qx.ui.form.Button": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Basically a text fields which allows a selection from a list of
   * preconfigured options. Allows custom user input. Public API is value
   * oriented.
   *
   * To work with selections without custom input the ideal candidates are
   * the {@link SelectBox} or the {@link RadioGroup}.
   *
   * @childControl textfield {qx.ui.form.TextField} textfield component of the combobox
   * @childControl button {qx.ui.form.Button} button to open the list popup
   * @childControl list {qx.ui.form.List} list inside the popup
   */
  qx.Class.define("qx.ui.form.ComboBox", {
    extend: qx.ui.form.AbstractSelectBox,
    implement: [qx.ui.form.IStringForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.form.AbstractSelectBox.constructor.call(this);

      var textField = this._createChildControl("textfield");

      this._createChildControl("button");

      this.addListener("tap", this._onTap); // forward the focusin and focusout events to the textfield. The textfield
      // is not focusable so the events need to be forwarded manually.

      this.addListener("focusin", function (e) {
        textField.fireNonBubblingEvent("focusin", qx.event.type.Focus);
      }, this);
      this.addListener("focusout", function (e) {
        textField.fireNonBubblingEvent("focusout", qx.event.type.Focus);
      }, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "combobox"
      },

      /**
       * String value which will be shown as a hint if the field is all of:
       * unset, unfocused and enabled. Set to null to not show a placeholder
       * text.
       */
      placeholder: {
        check: "String",
        nullable: true,
        apply: "_applyPlaceholder"
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Whenever the value is changed this event is fired
       *
       *  Event data: The new text value of the field.
       */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __preSelectedItem__P_411_0: null,
      __onInputId__P_411_1: null,
      // property apply
      _applyPlaceholder: function _applyPlaceholder(value, old) {
        this.getChildControl("textfield").setPlaceholder(value);
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "textfield":
            control = new qx.ui.form.TextField();
            control.setFocusable(false);
            control.addState("inner");
            control.addListener("changeValue", this._onTextFieldChangeValue, this);
            control.addListener("blur", this.close, this);

            this._add(control, {
              flex: 1
            });

            break;

          case "button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.setKeepActive(true);
            control.addState("inner");
            control.addListener("execute", this.toggle, this);

            this._add(control);

            break;

          case "list":
            // Get the list from the AbstractSelectBox
            control = qx.ui.form.ComboBox.prototype._createChildControlImpl.base.call(this, id); // Change selection mode

            control.setSelectionMode("single");
            break;
        }

        return control || qx.ui.form.ComboBox.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        invalid: true
      },
      // overridden
      tabFocus: function tabFocus() {
        var field = this.getChildControl("textfield");
        field.getFocusElement().focus();
        field.selectAllText();
      },
      // overridden
      focus: function focus() {
        qx.ui.form.ComboBox.prototype.focus.base.call(this);
        this.getChildControl("textfield").getFocusElement().focus();
      },
      // interface implementation
      setValue: function setValue(value) {
        var textfield = this.getChildControl("textfield");

        if (textfield.getValue() == value) {
          return;
        } // Apply to text field


        textfield.setValue(value);
      },
      // interface implementation
      getValue: function getValue() {
        return this.getChildControl("textfield").getValue();
      },
      // interface implementation
      resetValue: function resetValue() {
        this.getChildControl("textfield").setValue(null);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      // overridden
      _onKeyPress: function _onKeyPress(e) {
        var popup = this.getChildControl("popup");
        var iden = e.getKeyIdentifier();

        if (iden == "Down" && e.isAltPressed()) {
          this.getChildControl("button").addState("selected");
          this.toggle();
          e.stopPropagation();
        } else if (iden == "Enter") {
          if (popup.isVisible()) {
            this._setPreselectedItem();

            this.resetAllTextSelection();
            this.close();
            e.stop();
          }
        } else if (popup.isVisible()) {
          qx.ui.form.ComboBox.prototype._onKeyPress.base.call(this, e);
        }
      },

      /**
       * Toggles the popup's visibility.
       *
       * @param e {qx.event.type.Pointer} Pointer tap event
       */
      _onTap: function _onTap(e) {
        this.close();
      },
      // overridden
      _onListPointerDown: function _onListPointerDown(e) {
        this._setPreselectedItem();
      },

      /**
       * Apply pre-selected item
       */
      _setPreselectedItem: function _setPreselectedItem() {
        if (this.__preSelectedItem__P_411_0) {
          var label = this.__preSelectedItem__P_411_0.getLabel();

          if (this.getFormat() != null) {
            label = this.getFormat().call(this, this.__preSelectedItem__P_411_0);
          } // check for translation


          if (label && label.translate) {
            label = label.translate();
          }

          this.setValue(label);
          this.__preSelectedItem__P_411_0 = null;
        }
      },
      // overridden
      _onListChangeSelection: function _onListChangeSelection(e) {
        var current = e.getData();

        if (current.length > 0) {
          // Ignore quick context (e.g. pointerover)
          // and configure the new value when closing the popup afterwards
          var list = this.getChildControl("list");
          var ctx = list.getSelectionContext();

          if (ctx == "quick" || ctx == "key") {
            this.__preSelectedItem__P_411_0 = current[0];
          } else {
            var label = current[0].getLabel();

            if (this.getFormat() != null) {
              label = this.getFormat().call(this, current[0]);
            } // check for translation


            if (label && label.translate) {
              label = label.translate();
            }

            this.setValue(label);
            this.__preSelectedItem__P_411_0 = null;
          }
        }
      },
      // overridden
      _onPopupChangeVisibility: function _onPopupChangeVisibility(e) {
        qx.ui.form.ComboBox.prototype._onPopupChangeVisibility.base.call(this, e); // Synchronize the list with the current value on every
        // opening of the popup. This is useful because through
        // the quick selection mode, the list may keep an invalid
        // selection on close or the user may enter text while
        // the combobox is closed and reopen it afterwards.


        var popup = this.getChildControl("popup");

        if (popup.isVisible()) {
          var list = this.getChildControl("list");
          var value = this.getValue();
          var item = null;

          if (value) {
            item = list.findItem(value);
          }

          if (item) {
            list.setSelection([item]);
          } else {
            list.resetSelection();
          }
        } else {
          // When closing the popup text should selected and field should
          // have the focus. Identical to when reaching the field using the TAB key.
          //
          // Only focus if popup was visible before. Fixes [BUG #4453].
          if (e.getOldData() == "visible") {
            this.tabFocus();
          }
        } // In all cases: Remove focused state from button


        this.getChildControl("button").removeState("selected");
      },

      /**
       * Reacts on value changes of the text field and syncs the
       * value to the combobox.
       *
       * @param e {qx.event.type.Data} Change event
       */
      _onTextFieldChangeValue: function _onTextFieldChangeValue(e) {
        var value = e.getData();
        var list = this.getChildControl("list");

        if (value != null) {
          // Select item when possible
          var item = list.findItem(value, false);

          if (item) {
            list.setSelection([item]);
          } else {
            list.resetSelection();
          }
        } else {
          list.resetSelection();
        } // Fire event


        this.fireDataEvent("changeValue", value, e.getOldData());
      },

      /*
      ---------------------------------------------------------------------------
        TEXTFIELD SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the current selection.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @return {String|null}
       */
      getTextSelection: function getTextSelection() {
        return this.getChildControl("textfield").getTextSelection();
      },

      /**
       * Returns the current selection length.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @return {Integer|null}
       */
      getTextSelectionLength: function getTextSelectionLength() {
        return this.getChildControl("textfield").getTextSelectionLength();
      },

      /**
       * Set the selection to the given start and end (zero-based).
       * If no end value is given the selection will extend to the
       * end of the textfield's content.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @param start {Integer} start of the selection (zero-based)
       * @param end {Integer} end of the selection
       */
      setTextSelection: function setTextSelection(start, end) {
        this.getChildControl("textfield").setTextSelection(start, end);
      },

      /**
       * Clears the current selection.
       * This method only works if the widget is already created and
       * added to the document.
       *
       */
      clearTextSelection: function clearTextSelection() {
        this.getChildControl("textfield").clearTextSelection();
      },

      /**
       * Selects the whole content
       *
       */
      selectAllText: function selectAllText() {
        this.getChildControl("textfield").selectAllText();
      },

      /**
       * Clear any text selection, then select all text
       *
       */
      resetAllTextSelection: function resetAllTextSelection() {
        this.clearTextSelection();
        this.selectAllText();
      }
    }
  });
  qx.ui.form.ComboBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.ui.form.IModel": {},
      "qx.ui.form.MModelProperty": {},
      "qx.ui.form.List": {},
      "qx.data.Array": {},
      "qx.data.controller.List": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * @ignore(qx.test.ListItem)
   */
  qx.Class.define("qx.test.data.controller.ListReverse", {
    extend: qx.test.ui.LayoutTestCase,
    construct: function construct() {
      qx.test.ui.LayoutTestCase.constructor.call(this); // define a test class

      qx.Class.define("qx.test.ListItem", {
        extend: qx.ui.core.Widget,
        implement: [qx.ui.form.IModel],
        include: [qx.ui.form.MModelProperty],
        properties: {
          label: {
            check: "String",
            init: "label",
            event: "changeLabel"
          },
          icon: {
            check: "String",
            init: "icon",
            event: "changeIcon"
          },
          child: {
            check: "qx.test.ListItem",
            event: "changeChild",
            nullable: true
          },
          children: {
            event: "changeChildren",
            nullable: true
          }
        }
      });
    },
    members: {
      __list__P_233_0: null,
      __controller__P_233_1: null,
      __data__P_233_2: null,
      __model__P_233_3: null,
      __delegate__P_233_4: null,
      setUp: function setUp() {
        this.__list__P_233_0 = new qx.ui.form.List(); // create the model

        this.__data__P_233_2 = [];

        for (var i = 0; i < 5; i++) {
          this.__data__P_233_2.push("item" + i);
        } // create a new array


        this.__model__P_233_3 = new qx.data.Array(this.__data__P_233_2);
        this.__delegate__P_233_4 = {
          createItem: function createItem() {
            return new qx.test.ListItem();
          }
        };
        this.__controller__P_233_1 = new qx.data.controller.List();
      },
      tearDown: function tearDown() {
        this.flush();

        this.__controller__P_233_1.dispose();

        this.__controller__P_233_1 = null;

        this.__model__P_233_3.dispose();

        this.__model__P_233_3 = null;
        this.__data__P_233_2 = null;

        this.__list__P_233_0.dispose();
      },
      testStringListModel: function testStringListModel() {
        this.__delegate__P_233_4.bindItem = function (controller, item, id) {
          controller.bindDefaultProperties(item, id);
          controller.bindProperty("", "label", null, item, id);
          controller.bindPropertyReverse("", "label", null, item, id);
          controller.bindPropertyReverse("", "icon", null, item, id);
        };

        this.__controller__P_233_1.set({
          target: this.__list__P_233_0,
          delegate: this.__delegate__P_233_4,
          iconPath: "",
          model: this.__model__P_233_3
        }); // check for the binding model --> target


        var items = this.__list__P_233_0.getChildren();

        for (var i = 0; i < items.length; i++) {
          this.__model__P_233_3.setItem(i, "abc" + i);

          this.assertEquals("abc" + i, items[i].getLabel());
        }

        ; // check for the binding target(label) --> model

        for (var i = 0; i < items.length; i++) {
          items[i].setLabel("affe" + i);
          this.assertEquals(items[i].getLabel(), this.__model__P_233_3.getItem(i));
        } // check for the binding target(icon) --> model


        for (var i = 0; i < items.length; i++) {
          items[i].setIcon("AFFE" + i);
          this.assertEquals(items[i].getIcon(), this.__model__P_233_3.getItem(i));
        } // invoke a removing and setting of the bindings with the new bindItem


        this.__delegate__P_233_4.bindItem = function (controller, item, id) {
          controller.bindProperty("", "label", null, item, id);
        };

        this.__controller__P_233_1.update(); // check for the removed binding target(icon) --> model


        for (var i = 0; i < items.length; i++) {
          items[i].setIcon("123-" + i);
          this.assertEquals("AFFE" + i, this.__model__P_233_3.getItem(i));
        }
      },
      testStringListModelInitModelPrior: function testStringListModelInitModelPrior() {
        this.__delegate__P_233_4.bindItem = function (controller, item, id) {
          controller.bindProperty("", "icon", null, item, id);
          controller.bindPropertyReverse("", "icon", null, item, id);
        };

        this.__controller__P_233_1.set({
          target: this.__list__P_233_0,
          delegate: this.__delegate__P_233_4,
          iconPath: "",
          model: this.__model__P_233_3
        }); // check for the binding model --> target


        var items = this.__list__P_233_0.getChildren();

        for (var i = 0; i < items.length; i++) {
          this.assertEquals("item" + i, items[i].getIcon());
        }

        ;
      },
      testStringListModelInitTargetPrior: function testStringListModelInitTargetPrior() {
        this.__delegate__P_233_4.bindItem = function (controller, item, id) {
          controller.bindPropertyReverse("", "icon", null, item, id);
          controller.bindProperty("", "icon", null, item, id);
        };

        this.__controller__P_233_1.set({
          target: this.__list__P_233_0,
          delegate: this.__delegate__P_233_4,
          iconPath: "",
          model: this.__model__P_233_3
        }); // check for the binding model --> target


        var items = this.__list__P_233_0.getChildren();

        for (var i = 0; i < items.length; i++) {
          this.assertEquals("icon", items[i].getIcon());
        }

        ;
      },
      testStringListModelDeepTarget: function testStringListModelDeepTarget() {
        this.__delegate__P_233_4.bindItem = function (controller, item, id) {
          controller.bindProperty("", "child.label", null, item, id);
          controller.bindPropertyReverse("", "child.label", null, item, id);
        };

        this.__delegate__P_233_4.configureItem = function (item) {
          item.setChild(new qx.test.ListItem());
        };

        this.__controller__P_233_1.set({
          target: this.__list__P_233_0,
          delegate: this.__delegate__P_233_4,
          iconPath: "",
          model: this.__model__P_233_3
        }); // check for the binding model --> target


        var items = this.__list__P_233_0.getChildren();

        for (var i = 0; i < items.length; i++) {
          this.__model__P_233_3.setItem(i, "abc" + i);

          this.assertEquals("abc" + i, items[i].getChild().getLabel());
        }

        ; // check for the binding target(label) --> model

        for (var i = 0; i < items.length; i++) {
          items[i].getChild().setLabel("affe" + i);
          this.assertEquals(items[i].getChild().getLabel(), this.__model__P_233_3.getItem(i));
        } // get rid of the created items


        for (var i = 0; i < items.length; i++) {
          items[i].getChild().dispose();
          items[i].setChild(null);
        }

        ;
      },
      testStringListModelArrayTarget: function testStringListModelArrayTarget() {
        this.__delegate__P_233_4.bindItem = function (controller, item, id) {
          controller.bindProperty("", "children[0].label", null, item, id);
          controller.bindPropertyReverse("", "children[0].label", null, item, id);
        };

        this.__delegate__P_233_4.configureItem = function (item) {
          var childItems = new qx.data.Array(new qx.test.ListItem(), new qx.test.ListItem());
          item.setChildren(childItems);
        };

        this.__controller__P_233_1.set({
          target: this.__list__P_233_0,
          delegate: this.__delegate__P_233_4,
          iconPath: "",
          model: this.__model__P_233_3
        }); // check for the binding model --> target


        var items = this.__list__P_233_0.getChildren();

        for (var i = 0; i < items.length; i++) {
          this.__model__P_233_3.setItem(i, "abc" + i);

          this.assertEquals("abc" + i, items[i].getChildren().getItem(0).getLabel());
        }

        ; // check for the binding target(label) --> model

        for (var i = 0; i < items.length; i++) {
          items[i].getChildren().getItem(0).setLabel("affe" + i);
          this.assertEquals(items[i].getChildren().getItem(0).getLabel(), this.__model__P_233_3.getItem(i));
        } // check a change of the array order


        for (var i = 0; i < items.length; i++) {
          items[i].getChildren().reverse();
          this.assertEquals(items[i].getChildren().getItem(0).getLabel(), this.__model__P_233_3.getItem(i));
        } // get rid of the created items


        for (var i = 0; i < items.length; i++) {
          if (items[i].getChildren().getItem(0)) {
            items[i].getChildren().getItem(0).dispose();
          }

          items[i].getChildren().setItem(0, null);

          if (items[i].getChildren().getItem(1)) {
            items[i].getChildren().getItem(1).dispose();
          }

          items[i].getChildren().setItem(1, null);
          items[i].setChildren(null);
        }

        ;
      }
    }
  });
  qx.test.data.controller.ListReverse.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.test.ui.LayoutTestCase": {
        "construct": true,
        "require": true
      },
      "qx.core.Object": {
        "construct": true
      },
      "qx.ui.form.List": {},
      "qx.data.Array": {},
      "qx.data.controller.List": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.ListWithObject, qx.demo.Parent, qx.demo.Kid)
   */
  qx.Class.define("qx.test.data.controller.ListWithObjects", {
    extend: qx.test.ui.LayoutTestCase,
    construct: function construct() {
      qx.test.ui.LayoutTestCase.constructor.call(this); // define a test class

      qx.Class.define("qx.test.ListWithObject", {
        extend: qx.core.Object,
        properties: {
          name: {
            check: "String",
            event: "changeName"
          },
          icon: {
            check: "String",
            init: "Juhu",
            event: "changeIcon"
          }
        }
      });
    },
    members: {
      __list__P_234_0: null,
      __controller__P_234_1: null,
      __data__P_234_2: null,
      __model__P_234_3: null,
      setUp: function setUp() {
        this.__list__P_234_0 = new qx.ui.form.List(); // create the model

        this.__data__P_234_2 = [];

        for (var i = 0; i < 5; i++) {
          var obj = new qx.test.ListWithObject();
          obj.setName("name" + i);
          obj.setIcon("icon" + i);

          this.__data__P_234_2.push(obj);
        } // create a new array


        this.__model__P_234_3 = new qx.data.Array(this.__data__P_234_2);
      },
      tearDown: function tearDown() {
        this.flush();

        this.__controller__P_234_1.dispose();

        this.__controller__P_234_1 = null;

        this.__model__P_234_3.setAutoDisposeItems(true);

        this.__model__P_234_3.dispose();

        this.__model__P_234_3 = null;
        this.__data__P_234_2 = null;

        this.__list__P_234_0.dispose();
      },
      testRead: function testRead() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, this.__list__P_234_0, "name"); // check the binding

        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var label = this.__list__P_234_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_234_2[i].getName(), label, "Binding " + i + " is wrong!");
        }
      },
      testChangeLablePath: function testChangeLablePath() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, this.__list__P_234_0, "name"); // check the binding

        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var label = this.__list__P_234_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_234_2[i].getName(), label, "Binding " + i + " is wrong!");
        }

        this.__controller__P_234_1.setLabelPath("icon"); // check the binding again


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var label = this.__list__P_234_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_234_2[i].getIcon(), label, "Binding " + i + " is wrong!");
        }
      },
      testSelection: function testSelection() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, this.__list__P_234_0, "name"); // select the first object

        this.__list__P_234_0.addToSelection(this.__list__P_234_0.getChildren()[0]); // test the selection


        this.assertEquals(this.__model__P_234_3.getItem(0), this.__controller__P_234_1.getSelection().getItem(0), "Selection does not work."); // test for the length

        this.assertEquals(1, this.__controller__P_234_1.getSelection().length, "Selection length is wrong."); // select the second object

        this.__list__P_234_0.addToSelection(this.__list__P_234_0.getChildren()[1]); // test the selection


        this.assertEquals(this.__model__P_234_3.getItem(1), this.__controller__P_234_1.getSelection().getItem(0), "Selection does not work."); // test for the length

        this.assertEquals(1, this.__controller__P_234_1.getSelection().length, "Selection length is wrong.");
      },
      testSelectionBackMultiple: function testSelectionBackMultiple() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, this.__list__P_234_0, "name"); // select the second and third object

        this.__list__P_234_0.setSelectionMode("multi"); // add the some elements to the selection


        this.__controller__P_234_1.getSelection().push(this.__model__P_234_3.getItem(1));

        this.__controller__P_234_1.getSelection().push(this.__model__P_234_3.getItem(2)); // test the selection


        this.assertEquals(this.__model__P_234_3.getItem(1), this.__controller__P_234_1.getSelection().getItem(0), "addToSelection does not work.");
        this.assertEquals(this.__model__P_234_3.getItem(2), this.__controller__P_234_1.getSelection().getItem(1), "addToSelection does not work.");
      },
      testChangeModelSmaller: function testChangeModelSmaller() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, this.__list__P_234_0, "name"); // create the model

        this.__data__P_234_2 = [];

        for (var i = 0; i < 2; i++) {
          var obj = new qx.test.ListWithObject();
          obj.setName("name");
          obj.setIcon("icon");

          this.__data__P_234_2.push(obj);
        } // create a new array


        this.__model__P_234_3.setAutoDisposeItems(true);

        this.__model__P_234_3.dispose();

        this.__model__P_234_3 = new qx.data.Array(this.__data__P_234_2);

        this.__controller__P_234_1.setModel(this.__model__P_234_3); // check the binding


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var label = this.__list__P_234_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_234_2[i].getName(), label, "Binding " + i + " is wrong!");
        } // check the length


        this.assertEquals(this.__data__P_234_2.length, this.__list__P_234_0.getChildren().length, "Wrong length!");
      },
      testIcon: function testIcon() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, this.__list__P_234_0, "name");

        this.__controller__P_234_1.setIconPath("icon"); // check the label binding


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var label = this.__list__P_234_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_234_2[i].getName(), label, "Binding " + i + " is wrong!");
        } // check the icon binding


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var icon = this.__list__P_234_0.getChildren()[i].getIcon();

          this.assertEquals(this.__data__P_234_2[i].getIcon(), icon, "Binding " + i + " is wrong!");
        }
      },
      testChangeIconPath: function testChangeIconPath() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, this.__list__P_234_0, "name");

        this.__controller__P_234_1.setIconPath("icon"); // check the binding


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var icon = this.__list__P_234_0.getChildren()[i].getIcon();

          this.assertEquals(this.__data__P_234_2[i].getIcon(), icon, "Binding " + i + " is wrong!");
        }

        this.__controller__P_234_1.setIconPath("name"); // check the binding again


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var icon = this.__list__P_234_0.getChildren()[i].getIcon();

          this.assertEquals(this.__data__P_234_2[i].getName(), icon, "Binding " + i + " is wrong!");
        }
      },
      testConversionLabelAndIcon: function testConversionLabelAndIcon() {
        // create the label options
        var labelOptions = {
          converter: function converter(value) {
            return "Dr. " + value;
          }
        }; // create the icon options

        var iconOptions = {
          converter: function converter(value) {
            return value + ".png";
          }
        }; // create the controller

        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, this.__list__P_234_0, "name");

        this.__controller__P_234_1.setIconPath("icon");

        this.__controller__P_234_1.setLabelOptions(labelOptions);

        this.__controller__P_234_1.setIconOptions(iconOptions); // check the label binding


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var label = this.__list__P_234_0.getChildren()[i].getLabel();

          this.assertEquals("Dr. " + this.__data__P_234_2[i].getName(), label, "Binding " + i + " is wrong!");
        } // check the icon binding


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var icon = this.__list__P_234_0.getChildren()[i].getIcon();

          this.assertEquals(this.__data__P_234_2[i].getIcon() + ".png", icon, "Binding " + i + " is wrong!");
        }
      },
      testSetModelLate: function testSetModelLate() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(null, this.__list__P_234_0, "name");

        this.__controller__P_234_1.setModel(this.__model__P_234_3); // check the binding


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var label = this.__list__P_234_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_234_2[i].getName(), label, "Binding " + i + " is wrong!");
        }
      },
      testSetTargetLate: function testSetTargetLate() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, null, "name");

        this.__controller__P_234_1.setTarget(this.__list__P_234_0); // check the binding


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var label = this.__list__P_234_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_234_2[i].getName(), label, "Binding " + i + " is wrong!");
        }
      },
      testFilter: function testFilter() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, this.__list__P_234_0, "name");

        this.__controller__P_234_1.setIconPath("icon");

        var delegate = {};

        delegate.filter = function (data) {
          return data.getName() == "name2" ? true : false;
        }; // set the filter


        this.__controller__P_234_1.setDelegate(delegate); // check for the length


        this.assertEquals(1, this.__list__P_234_0.getChildren().length, "Too much list items."); // check the label binding

        var label = this.__list__P_234_0.getChildren()[0].getLabel();

        this.assertEquals("name2", label, "Label binding is wrong!"); // check the icon binding

        var icon = this.__list__P_234_0.getChildren()[0].getIcon();

        this.assertEquals("icon2", icon, "Icon binding is wrong!");
      },
      testOnUpdateLabel: function testOnUpdateLabel() {
        // create the options map with the converter
        var options = {};
        var flag = false;

        options.onUpdate = function () {
          flag = true;
        }; // create the controller


        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, this.__list__P_234_0, "name");

        this.__controller__P_234_1.setLabelOptions(options); // change something to invoke a change of a binding


        this.__data__P_234_2.pop().dispose();

        this.__model__P_234_3.pop().dispose(); // check the binding


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var label = this.__list__P_234_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_234_2[i].getName(), label, "Binding " + i + " is wrong!");
        } // check if the flag is set


        this.assertTrue(flag, "onUpdate not executed");
      },
      // [BUG #2088]
      testDeepSelection: function testDeepSelection() {
        qx.Class.define("qx.demo.Kid", {
          extend: qx.core.Object,
          properties: {
            name: {
              check: "String",
              event: "changeName",
              init: null
            }
          }
        });
        qx.Class.define("qx.demo.Parent", {
          extend: qx.core.Object,
          construct: function construct() {
            qx.core.Object.constructor.call(this);
            this.setKid(new qx.demo.Kid());
          },
          properties: {
            name: {
              check: "String",
              event: "changeName",
              init: null
            },
            kid: {
              check: "qx.demo.Kid",
              event: "changeKid"
            }
          }
        });
        var parentA = new qx.demo.Parent();
        parentA.setName("parentA");
        parentA.getKid().setName("kidA");
        var parentB = new qx.demo.Parent();
        parentB.setName("parentB");
        parentB.getKid().setName("kidB");
        var parentC = new qx.demo.Parent();
        parentC.setName("parentC");
        parentC.getKid().setName("kidC");
        var parents = new qx.data.Array();
        parents.push(parentA);
        parents.push(parentB);
        parents.push(parentC);
        this.__controller__P_234_1 = new qx.data.controller.List(parents, this.__list__P_234_0, "name");
        this.assertEquals(parentC.getName(), this.__list__P_234_0.getChildren()[2].getModel().getName(), "Wrong model stored before the splice.");
        var temp = parents.splice(parents.indexOf(parentB), 1);
        temp.getItem(0).getKid().dispose();
        temp.setAutoDisposeItems(true);
        temp.dispose();
        this.assertEquals("parentC", this.__list__P_234_0.getChildren()[1].getLabel(), "Wrong name of the parent.");
        this.assertEquals(parentC, this.__list__P_234_0.getChildren()[1].getModel(), "Wrong model stored after the splice."); // clean up

        for (var i = 0; i < parents.length; i++) {
          parents.getItem(i).getKid().dispose();
        }

        parents.setAutoDisposeItems(true);
        parents.dispose();
      },
      testModelProperty: function testModelProperty() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(null, this.__list__P_234_0, "name"); // filter only the first item

        var delegate = {};

        delegate.filter = function (data) {
          return data.getName() == "name0" || data.getName() == "name2" ? false : true;
        };

        delegate.bindItem = function (c, item, index) {
          c.bindProperty("", "model", null, item, index);
        }; // set the filter


        this.__controller__P_234_1.setDelegate(delegate);

        this.__controller__P_234_1.setModel(this.__model__P_234_3);

        this.assertEquals(3, this.__list__P_234_0.getChildren().length); // check the binding

        this.assertEquals(this.__model__P_234_3.getItem(1), this.__list__P_234_0.getChildren()[0].getModel());
        this.assertEquals(this.__model__P_234_3.getItem(3), this.__list__P_234_0.getChildren()[1].getModel());
        this.assertEquals(this.__model__P_234_3.getItem(4), this.__list__P_234_0.getChildren()[2].getModel()); // add another item

        var item = new qx.test.ListWithObject().set({
          name: "name5",
          icon: "icon5"
        });

        this.__model__P_234_3.push(item);

        this.assertEquals(this.__model__P_234_3.getItem(5), this.__list__P_234_0.getChildren()[3].getModel());
        item.dispose();
      },
      testModelPropertyBinding: function testModelPropertyBinding() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(null, this.__list__P_234_0, "name"); // filter only the first item

        var delegate = {};

        delegate.bindItem = function (c, item, index) {
          c.bindProperty("icon", "model", null, item, index);
        }; // set the filter


        this.__controller__P_234_1.setDelegate(delegate);

        this.__controller__P_234_1.setModel(this.__model__P_234_3); // test the right set model properties


        for (var i = 0; i < this.__list__P_234_0.getChildren().length; i++) {
          var child = this.__list__P_234_0.getChildren()[i];

          this.assertEquals("icon" + i, child.getModel());
        }

        ; // test selection

        this.__controller__P_234_1.getSelection().push("icon1");

        this.assertEquals("icon1", this.__list__P_234_0.getSelection()[0].getModel());
      },
      testModelInConverter: function testModelInConverter() {
        // create the controller
        this.__controller__P_234_1 = new qx.data.controller.List(this.__model__P_234_3, this.__list__P_234_0, "name");

        this.__controller__P_234_1.setLabelOptions({
          converter: function converter(value, model) {
            return model.getIcon();
          }
        }); // add a new object after the options are set


        var obj = new qx.test.ListWithObject();
        obj.setName("namex");
        obj.setIcon("iconx");

        this.__model__P_234_3.push(obj); // check the binding


        for (var i = 0; i < this.__data__P_234_2.length; i++) {
          var label = this.__list__P_234_0.getChildren()[i].getLabel();

          this.assertEquals(this.__data__P_234_2[i].getIcon(), label, "Binding " + i + " is wrong!");
        }

        var label = this.__list__P_234_0.getChildren()[this.__data__P_234_2.length].getLabel();

        this.assertEquals("iconx", label, "New binding is wrong!");
      }
    }
  });
  qx.test.data.controller.ListWithObjects.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.ui.basic.Label": {},
      "qx.ui.core.Widget": {},
      "qx.data.controller.Object": {},
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.ListItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.data.controller.Object", {
    extend: qx.dev.unit.TestCase,
    members: {
      __label1__P_235_0: null,
      __label2__P_235_1: null,
      __model__P_235_2: null,
      __controller__P_235_3: null,
      setUp: function setUp() {
        this.__label1__P_235_0 = new qx.ui.basic.Label();
        this.__label2__P_235_1 = new qx.ui.basic.Label();
        this.__model__P_235_2 = new qx.ui.core.Widget();
        this.__controller__P_235_3 = new qx.data.controller.Object(this.__model__P_235_2);
      },
      tearDown: function tearDown() {
        this.__model__P_235_2.dispose();

        this.__label2__P_235_1.dispose();

        this.__label1__P_235_0.dispose();

        this.__controller__P_235_3.dispose();
      },
      testOneToOne: function testOneToOne() {
        // Tie the label1s content to the zindex of the model
        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex"); // set a new zIndex to the model


        this.__model__P_235_2.setZIndex(10); // test for the binding


        this.assertEquals("10", this.__label1__P_235_0.getValue(), "Binding does not work!");
      },
      testOneToTwo: function testOneToTwo() {
        // Tie the label1s content to the zindex of the model
        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex"); // Tie the label2s content to the zindex of the model


        this.__controller__P_235_3.addTarget(this.__label2__P_235_1, "value", "zIndex"); // set a new zIndex to the model


        this.__model__P_235_2.setZIndex(10); // test for the binding


        this.assertEquals("10", this.__label1__P_235_0.getValue(), "Binding1 does not work!");
        this.assertEquals("10", this.__label2__P_235_1.getValue(), "Binding2 does not work!");
      },
      testChangeModel: function testChangeModel() {
        // Tie the labels content to the zindex of the model
        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex");

        this.__controller__P_235_3.addTarget(this.__label2__P_235_1, "value", "zIndex"); // set an old zIndex


        this.__model__P_235_2.setZIndex(10); // create a new model with a different zIndex


        var newModel = new qx.ui.core.Widget();
        newModel.setZIndex(20); // dispose the old model to check that the controller can handle that

        this.__model__P_235_2.dispose(); // set the new Model


        this.__controller__P_235_3.setModel(newModel); // test for the binding


        this.assertEquals("20", this.__label1__P_235_0.getValue(), "Binding1 does not work!");
        this.assertEquals("20", this.__label2__P_235_1.getValue(), "Binding2 does not work!");
        newModel.dispose();
      },
      testRemoveOneBinding: function testRemoveOneBinding() {
        // set a zIndex
        this.__model__P_235_2.setZIndex(20); // Tie the labels content to the zindex of the model


        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex");

        this.__controller__P_235_3.addTarget(this.__label2__P_235_1, "value", "zIndex"); // test for the binding


        this.assertEquals("20", this.__label1__P_235_0.getValue(), "Binding1 does not work!");
        this.assertEquals("20", this.__label2__P_235_1.getValue(), "Binding2 does not work!"); // remove one target

        this.__controller__P_235_3.removeTarget(this.__label1__P_235_0, "value", "zIndex"); // set a new zIndex


        this.__model__P_235_2.setZIndex(5); // test for the binding


        this.assertEquals("20", this.__label1__P_235_0.getValue(), "Binding1 has not been removed!");
        this.assertEquals("5", this.__label2__P_235_1.getValue(), "Binding2 has been removed!");
      },
      testRemoveUnexistantTarget: function testRemoveUnexistantTarget() {
        // test some cases
        this.__controller__P_235_3.removeTarget(this.__label1__P_235_0, "value", "zIndex");

        this.__controller__P_235_3.removeTarget(null, "AFFE", "AFFEN"); // set a target for testing


        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex"); // test the same cases again


        this.__controller__P_235_3.removeTarget(this.__label1__P_235_0, "value", "zIndex");

        this.__controller__P_235_3.removeTarget(null, "AFFE", "AFFEN");
      },
      testTowToTwo: function testTowToTwo() {
        // set up two links
        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex");

        this.__controller__P_235_3.addTarget(this.__label2__P_235_1, "value", "visibility"); // set the values


        this.__model__P_235_2.setZIndex(11);

        this.__model__P_235_2.setVisibility("visible"); // test for the binding


        this.assertEquals("11", this.__label1__P_235_0.getValue(), "Binding1 does not work!");
        this.assertEquals("visible", this.__label2__P_235_1.getValue(), "Binding2 does not work!"); // set new values

        this.__model__P_235_2.setZIndex(15);

        this.__model__P_235_2.setVisibility("hidden"); // test again for the binding


        this.assertEquals("15", this.__label1__P_235_0.getValue(), "Binding1 does not work!");
        this.assertEquals("hidden", this.__label2__P_235_1.getValue(), "Binding2 does not work!");
      },
      testOneToOneBi: function testOneToOneBi() {
        // Tie the label1s content to the zindex of the model
        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex", true); // set a new zIndex to the model


        this.__model__P_235_2.setZIndex(10); // test for the binding


        this.assertEquals("10", this.__label1__P_235_0.getValue(), "Binding does not work!"); // set a new content

        this.__label1__P_235_0.setValue("20"); // test the reverse binding


        this.assertEquals(20, this.__model__P_235_2.getZIndex(), "Reverse-Binding does not work!");
      },
      testOneToTwoBi: function testOneToTwoBi() {
        // Tie the label1s content to the zindex of the model
        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex", true); // Tie the label2s content to the zindex of the model


        this.__controller__P_235_3.addTarget(this.__label2__P_235_1, "value", "zIndex", true); // set a new zIndex to the model


        this.__model__P_235_2.setZIndex(10); // test for the binding


        this.assertEquals("10", this.__label1__P_235_0.getValue(), "Binding1 does not work!");
        this.assertEquals("10", this.__label2__P_235_1.getValue(), "Binding2 does not work!"); // change one label

        this.__label1__P_235_0.setValue("100"); // test for the binding


        this.assertEquals(100, this.__model__P_235_2.getZIndex(), "Reverse Binding does not work!");
        this.assertEquals("100", this.__label2__P_235_1.getValue(), "Binding2 does not work!"); // change the other label

        this.__label2__P_235_1.setValue("200"); // test for the binding


        this.assertEquals(200, this.__model__P_235_2.getZIndex(), "Reverse Binding does not work!");
        this.assertEquals("200", this.__label1__P_235_0.getValue(), "Binding1 does not work!");
      },
      testChangeModelBi: function testChangeModelBi() {
        // Tie the labels content to the zindex of the model
        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex", true);

        this.__controller__P_235_3.addTarget(this.__label2__P_235_1, "value", "zIndex", true); // set an old zIndex


        this.__model__P_235_2.setZIndex(10); // create a new model with a different zIndex


        var newModel = new qx.ui.core.Widget();
        newModel.setZIndex(20); // set the new Model

        this.__controller__P_235_3.setModel(newModel); // test for the binding


        this.assertEquals("20", this.__label1__P_235_0.getValue(), "Binding1 does not work!");
        this.assertEquals("20", this.__label2__P_235_1.getValue(), "Binding2 does not work!"); // set the zIndex in a label

        this.__label2__P_235_1.setValue("11"); // test for the bindings (working and should not work)


        this.assertEquals("11", this.__label1__P_235_0.getValue(), "Binding1 does not work!");
        this.assertEquals(11, newModel.getZIndex(), "Reverse-Binding does not work!");
        this.assertEquals(10, this.__model__P_235_2.getZIndex(), "Binding has not been removed.");
        newModel.dispose();
      },
      testConverting: function testConverting() {
        // create the options map
        var opt = {
          converter: function converter(value) {
            if (value > 10) {
              return "A";
            }

            return "B";
          }
        }; // Tie the labels content to the zindex of the model

        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex", false, opt); // set a zIndex and test it


        this.__model__P_235_2.setZIndex(11);

        this.assertEquals("A", this.__label1__P_235_0.getValue(), "Converter does not work!"); // set a zIndex and test it

        this.__model__P_235_2.setZIndex(5);

        this.assertEquals("B", this.__label1__P_235_0.getValue(), "Converter does not work!");
      },
      testConvertingBi: function testConvertingBi() {
        // create the options map for source to target
        var opt = {
          converter: function converter(value) {
            if (value > 10) {
              return "A";
            }

            return "B";
          }
        }; // create the options map for target to source

        var revOpt = {
          converter: function converter(value) {
            if (value == "A") {
              return 11;
            }

            return 10;
          }
        }; // Tie the labels content to the zindex of the model

        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex", true, opt, revOpt); // set a zIndex and test it


        this.__model__P_235_2.setZIndex(11);

        this.assertEquals("A", this.__label1__P_235_0.getValue(), "Converter does not work!"); // set a zIndex and test it

        this.__model__P_235_2.setZIndex(5);

        this.assertEquals("B", this.__label1__P_235_0.getValue(), "Converter does not work!"); // change the target and check the model

        this.__label1__P_235_0.setValue("A");

        this.assertEquals(11, this.__model__P_235_2.getZIndex(), "Back-Converter does not work!");

        this.__label1__P_235_0.setValue("B");

        this.assertEquals(10, this.__model__P_235_2.getZIndex(), "Back-Converter does not work!");
      },
      testChangeModelCon: function testChangeModelCon() {
        // create the options map
        var opt = {
          converter: function converter(value) {
            if (value > 10) {
              return "A";
            }

            return "B";
          }
        }; // Tie the labels content to the zindex of the model

        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex", false, opt);

        this.__controller__P_235_3.addTarget(this.__label2__P_235_1, "value", "zIndex", false, opt); // set an old zIndex


        this.__model__P_235_2.setZIndex(3); // create a new model with a different zIndex


        var newModel = new qx.ui.core.Widget();
        newModel.setZIndex(20); // set the new Model

        this.__controller__P_235_3.setModel(newModel); // test for the binding


        this.assertEquals("A", this.__label1__P_235_0.getValue(), "Binding1 does not work!");
        this.assertEquals("A", this.__label2__P_235_1.getValue(), "Binding2 does not work!");
        newModel.dispose();
      },
      testSetLateModel: function testSetLateModel() {
        this.__controller__P_235_3.dispose(); // create a blank controller


        this.__controller__P_235_3 = new qx.data.controller.Object(); // set the model

        this.__controller__P_235_3.setModel(this.__model__P_235_2); // Tie the label1s content to the zindex of the model


        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex"); // set a new zIndex to the model


        this.__model__P_235_2.setZIndex(10); // test for the binding


        this.assertEquals("10", this.__label1__P_235_0.getValue(), "Binding does not work!");
      },
      testSetModelNull: function testSetModelNull() {
        // Tie the label1s content to the zindex of the model
        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex");

        this.__label1__P_235_0.setValue("test"); // set the model of the controller to null and back


        this.__controller__P_235_3.setModel(null); // check if the values have been reseted


        this.assertNull(this.__label1__P_235_0.getValue());

        this.__controller__P_235_3.setModel(this.__model__P_235_2); // set a new zIndex to the model


        this.__model__P_235_2.setZIndex(10); // test for the binding


        this.assertEquals("10", this.__label1__P_235_0.getValue(), "Binding does not work!");
      },
      testCreateWithoutModel: function testCreateWithoutModel() {
        // create a new controller
        this.__controller__P_235_3.dispose();

        this.__controller__P_235_3 = new qx.data.controller.Object(); // Tie the label1s content to the zindex of the model

        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex"); // set a new zIndex to the model


        this.__model__P_235_2.setZIndex(10);

        this.__controller__P_235_3.setModel(this.__model__P_235_2); // test for the binding


        this.assertEquals("10", this.__label1__P_235_0.getValue(), "Binding does not work!");
      },
      testTargetArrayBi: function testTargetArrayBi() {
        var selectbox = new qx.ui.form.SelectBox();

        for (var i = 0; i < 10; i++) {
          selectbox.add(new qx.ui.form.ListItem("item " + i).set({
            model: i
          }));
        }

        this.__controller__P_235_3.addTarget(selectbox, "modelSelection[0]", "zIndex", true); // selectbox --> model


        selectbox.setSelection([selectbox.getSelectables()[6]]);
        this.assertEquals(6, this.__model__P_235_2.getZIndex()); // model --> selectbox

        this.__model__P_235_2.setZIndex(3);

        this.assertEquals(3, selectbox.getSelection()[0].getModel());
        selectbox.dispose();
      },
      testDispose: function testDispose() {
        // Tie the label1s content to the zindex of the model
        this.__controller__P_235_3.addTarget(this.__label1__P_235_0, "value", "zIndex", true); // create a common startbase


        this.__label1__P_235_0.setZIndex(7); // dispose the controller to remove the bindings


        this.__controller__P_235_3.dispose(); // set a new zIndex to the model


        this.__model__P_235_2.setZIndex(10); // test if the binding has been removed and reseted


        this.assertEquals(null, this.__label1__P_235_0.getValue(), "Binding does not work!"); // set a new content

        this.__label1__P_235_0.setValue("20"); // test the reverse binding


        this.assertEquals(10, this.__model__P_235_2.getZIndex(), "Reverse-Binding does not work!");
      }
    }
  });
  qx.test.data.controller.Object.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "construct": true,
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.core.Object": {
        "construct": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.io.ImageLoader": {},
      "qx.ui.tree.Tree": {},
      "qx.data.controller.Tree": {},
      "qx.ui.tree.TreeFolder": {},
      "qx.ui.core.queue.Dispose": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.MyTreeNode)
   * @ignore(qx.test.TreeEndNode)
   * @ignore(qx.test.TreeNode)
   */
  qx.Class.define("qx.test.data.controller.Tree", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    construct: function construct() {
      qx.dev.unit.TestCase.constructor.call(this); // define a test class

      qx.Class.define("qx.test.TreeNode", {
        extend: qx.core.Object,
        construct: function construct() {
          qx.core.Object.constructor.call(this);
          this.setChildren(new qx.data.Array());
          this.setAltChildren(new qx.data.Array());
        },
        properties: {
          children: {
            check: "qx.data.Array",
            event: "changeChild",
            nullable: true
          },
          altChildren: {
            check: "qx.data.Array",
            event: "changeChild",
            nullable: true
          },
          name: {
            check: "String",
            init: "root",
            event: "changeName"
          },
          name2: {
            check: "String",
            init: "root2",
            event: "changeName"
          },
          icon: {
            check: "String",
            event: "changeIcon",
            nullable: true
          },
          icon2: {
            check: "String",
            event: "changeIcon2",
            nullable: true
          },
          color: {
            check: "String",
            event: "changeColor",
            init: "green",
            nullable: true
          }
        },
        destruct: function destruct() {
          if (this.getChildren()) {
            this.getChildren().setAutoDisposeItems(true);
            this.getChildren().dispose();
          }

          if (this.getAltChildren()) {
            this.getAltChildren().setAutoDisposeItems(true);
            this.getAltChildren().dispose();
          }
        }
      });
    },
    members: {
      __tree__P_236_0: null,
      __model__P_236_1: null,
      __controller__P_236_2: null,
      __a__P_236_3: null,
      __b__P_236_4: null,
      __c__P_236_5: null,
      setUp: function setUp() {
        // prevent the icon load error with this stub
        this.stub(qx.io.ImageLoader, "load");
        this.__tree__P_236_0 = new qx.ui.tree.Tree(); // create a model
        //        this.__model
        //        /    |      \
        // this.__a  this.__b  this.__c

        this.__model__P_236_1 = new qx.test.TreeNode();
        this.__a__P_236_3 = new qx.test.TreeNode();

        this.__a__P_236_3.set({
          name: "a",
          name2: "a2",
          icon: "icon a",
          icon2: "icon a2",
          color: "red"
        });

        this.__b__P_236_4 = new qx.test.TreeNode();

        this.__b__P_236_4.set({
          name: "b",
          name2: "b2",
          icon: "icon b",
          icon2: "icon b2",
          color: "blue"
        });

        this.__c__P_236_5 = new qx.test.TreeNode();

        this.__c__P_236_5.set({
          name: "c",
          name2: "c2",
          icon: "icon c",
          icon2: "icon c2",
          color: "white"
        });

        this.__model__P_236_1.getChildren().push(this.__a__P_236_3, this.__b__P_236_4, this.__c__P_236_5);

        this.__model__P_236_1.getAltChildren().push(this.__c__P_236_5, this.__b__P_236_4, this.__a__P_236_3); // create the controller


        this.__controller__P_236_2 = new qx.data.controller.Tree(this.__model__P_236_1, this.__tree__P_236_0, "children", "name");

        this.__controller__P_236_2.setIconPath("icon");
      },
      tearDown: function tearDown() {
        this.__controller__P_236_2.dispose();

        this.__model__P_236_1.dispose();

        this.__tree__P_236_0.dispose(); // clear the stub


        this.getSandbox().restore();
      },
      testRemoveBindingsRecursive: function testRemoveBindingsRecursive() {
        // reform the model tree
        this.__model__P_236_1.getChildren().remove(this.__c__P_236_5);

        this.__a__P_236_3.getChildren().push(this.__c__P_236_5);

        var cFolder = this.__tree__P_236_0.getRoot().getChildren()[0].getChildren()[0];

        this.assertNotNull(cFolder, "Third node does not exist");
        this.assertEquals("c", cFolder.getLabel()); // remove the model node

        this.__a__P_236_3.getChildren().remove(this.__c__P_236_5); // check if its disposed and the bindings have been removed


        this.__c__P_236_5.setName("affe");

        this.assertEquals("c", cFolder.getLabel()); // destroy is async --> wait for it!

        this.wait(100, function () {
          this.assertTrue(cFolder.isDisposed());
        }, this);
      },
      testModelChange: function testModelChange() {
        // set model to null
        this.__controller__P_236_2.setModel(null); // set the same model again (forces the tree to redraw)


        this.__controller__P_236_2.setModel(this.__model__P_236_1);

        var d = new qx.test.TreeNode();
        d.setName("d");
        var model = this.__model__P_236_1; // add the new model

        this.wait(100, function () {
          model.getChildren().push(d);
        }); // d will be disposed by the model
      },
      testFolderCreation: function testFolderCreation() {
        // Test if the tree nodes exist
        this.assertNotNull(this.__tree__P_236_0.getRoot(), "Root node does not exist");
        this.assertNotNull(this.__tree__P_236_0.getRoot().getChildren()[0], "First node does not exist");
        this.assertNotNull(this.__tree__P_236_0.getRoot().getChildren()[1], "Second node does not exist");
        this.assertNotNull(this.__tree__P_236_0.getRoot().getChildren()[2], "Third node does not exist");
      },
      testFolderLabelInitial: function testFolderLabelInitial() {
        // check the initial Labels
        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testFolderLabelChangeName: function testFolderLabelChangeName() {
        // change the names
        this.__model__P_236_1.setName("ROOT");

        this.__a__P_236_3.setName("A");

        this.__b__P_236_4.setName("B");

        this.__c__P_236_5.setName("C"); // check the initial Labels


        this.assertEquals("ROOT", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("A", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("B", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("C", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testFolderLabelPropertyChange: function testFolderLabelPropertyChange() {
        // change the label path
        this.__controller__P_236_2.setLabelPath("name2"); // check the initial Labels


        this.assertEquals("root2", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a2", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b2", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c2", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testChildPush: function testChildPush() {
        var d = new qx.test.TreeNode();
        d.setName("d");

        var children = this.__model__P_236_1.getChildren();

        children.push(d); // Test if the tree nodes exist

        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
        this.assertEquals("d", this.__tree__P_236_0.getRoot().getChildren()[3].getLabel(), "New node has a wrong name");
      },
      testChildPop: function testChildPop() {
        var children = this.__model__P_236_1.getChildren();

        children.pop();
        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertUndefined(this.__tree__P_236_0.getRoot().getChildren()[2], "There is still a third node!");
      },
      testChildShift: function testChildShift() {
        var children = this.__model__P_236_1.getChildren();

        children.shift();
        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertUndefined(this.__tree__P_236_0.getRoot().getChildren()[2], "There is still a third node!");
      },
      testChildUnshift: function testChildUnshift() {
        var d = new qx.test.TreeNode();
        d.setName("d");

        var children = this.__model__P_236_1.getChildren();

        children.unshift(d); // Test if the tree nodes exist

        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("d", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[3].getLabel(), "Fourth node has a wrong name");
      },
      testTreeDeep: function testTreeDeep() {
        // remove all children
        this.__model__P_236_1.getChildren().pop();

        this.__model__P_236_1.getChildren().pop();

        this.__model__P_236_1.getChildren().pop(); // create a straight tree
        // this.__model
        //      \
        //    this.__a
        //        \
        //      this.__b
        //          \
        //        this.__c


        this.__model__P_236_1.getChildren().push(this.__a__P_236_3);

        this.__a__P_236_3.getChildren().push(this.__b__P_236_4);

        this.__b__P_236_4.getChildren().push(this.__c__P_236_5); // test for the model


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[0].getChildren()[0].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[0].getChildren()[0].getChildren()[0].getLabel(), "Third node has a wrong name");
      },
      testBig: function testBig() {
        // build up the model instances
        var aa = new qx.test.TreeNode();
        aa.setName("aa");
        var bb = new qx.test.TreeNode();
        bb.setName("bb");
        var cc = new qx.test.TreeNode();
        cc.setName("cc");
        var bbb = new qx.test.TreeNode();
        bbb.setName("bbb");
        var AA = new qx.test.TreeNode();
        AA.setName("AA"); // tie the model together
        //          this.__model
        //          /     |      \
        //   this.__a  this.__b  this.__c
        //     /  \        |         |
        //    aa  AA      bb        cc
        //                 |
        //                bbb

        bb.getChildren().push(bbb);

        this.__b__P_236_4.getChildren().push(bb);

        this.__a__P_236_3.getChildren().push(aa, AA);

        this.__c__P_236_5.getChildren().push(cc); // check the initial Labels
        // root layer


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name"); // first layer

        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "a node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "b node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "c node has a wrong name"); // second layer

        this.assertEquals("aa", this.__tree__P_236_0.getRoot().getChildren()[0].getChildren()[0].getLabel(), "aa node has a wrong name");
        this.assertEquals("AA", this.__tree__P_236_0.getRoot().getChildren()[0].getChildren()[1].getLabel(), "AA node has a wrong name");
        this.assertEquals("bb", this.__tree__P_236_0.getRoot().getChildren()[1].getChildren()[0].getLabel(), "bb node has a wrong name");
        this.assertEquals("cc", this.__tree__P_236_0.getRoot().getChildren()[2].getChildren()[0].getLabel(), "cc node has a wrong name"); // third layer

        this.assertEquals("bbb", this.__tree__P_236_0.getRoot().getChildren()[1].getChildren()[0].getChildren()[0].getLabel(), "bbb node has a wrong name");
      },
      testChildReverse: function testChildReverse() {
        // reverse the children
        this.__model__P_236_1.getChildren().reverse(); // check the labels


        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "Third node has a wrong name");
      },
      testChangeChildPath: function testChangeChildPath() {
        // change the child path
        this.__controller__P_236_2.setChildPath("altChildren"); // check the labels


        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testChangeTarget: function testChangeTarget() {
        // create a new tree
        var tree = new qx.ui.tree.Tree(); // set the new tree as target

        this.__controller__P_236_2.setTarget(tree); // check the new folders


        this.assertEquals("a", tree.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", tree.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", tree.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name"); // check if the old tree is empty

        this.assertNull(this.__tree__P_236_0.getRoot(), "Former tree is not empty.");
        tree.dispose();
      },
      testChangeModel: function testChangeModel() {
        // create a new model
        //     this.__model
        //        /    \
        // this.__a  this.__b
        var model = new qx.test.TreeNode();
        var a = new qx.test.TreeNode();
        a.setName("A");
        var b = new qx.test.TreeNode();
        b.setName("B");
        model.getChildren().push(a, b); // set the new model

        this.__controller__P_236_2.setModel(model); // check the folders


        this.assertEquals("A", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("B", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");

        this.__controller__P_236_2.setModel(null);

        model.dispose();
      },
      testIconPath: function testIconPath() {
        this.assertEquals(null, this.__tree__P_236_0.getRoot().getIcon(), "Root node has a wrong icon");
        this.assertEquals("icon a", this.__tree__P_236_0.getRoot().getChildren()[0].getIcon(), "First node has a wrong icon");
        this.assertEquals("icon b", this.__tree__P_236_0.getRoot().getChildren()[1].getIcon(), "Second node has a wrong icon");
        this.assertEquals("icon c", this.__tree__P_236_0.getRoot().getChildren()[2].getIcon(), "Third node has a wrong icon");
      },
      testIconPathChange: function testIconPathChange() {
        // change the icon path
        this.__controller__P_236_2.setIconPath("icon2"); // test the binding


        this.assertEquals(null, this.__tree__P_236_0.getRoot().getIcon(), "Root node has a wrong icon");
        this.assertEquals("icon a2", this.__tree__P_236_0.getRoot().getChildren()[0].getIcon(), "First node has a wrong icon");
        this.assertEquals("icon b2", this.__tree__P_236_0.getRoot().getChildren()[1].getIcon(), "Second node has a wrong icon");
        this.assertEquals("icon c2", this.__tree__P_236_0.getRoot().getChildren()[2].getIcon(), "Third node has a wrong icon");
      },
      testIconChange: function testIconChange() {
        // change the icon values
        this.__model__P_236_1.setIcon("AFFE");

        this.__a__P_236_3.setIcon("ICON A");

        this.__b__P_236_4.setIcon("ICON B");

        this.__c__P_236_5.setIcon("ICON C"); // test the new icon values


        this.assertEquals("AFFE", this.__tree__P_236_0.getRoot().getIcon(), "Root node has a wrong icon");
        this.assertEquals("ICON A", this.__tree__P_236_0.getRoot().getChildren()[0].getIcon(), "First node has a wrong icon");
        this.assertEquals("ICON B", this.__tree__P_236_0.getRoot().getChildren()[1].getIcon(), "Second node has a wrong icon");
        this.assertEquals("ICON C", this.__tree__P_236_0.getRoot().getChildren()[2].getIcon(), "Third node has a wrong icon");
      },
      testSelection: function testSelection() {
        // open the tree so that the selection can be done
        this.__tree__P_236_0.getRoot().setOpen(true); // select the first object


        this.__tree__P_236_0.addToSelection(this.__tree__P_236_0.getRoot().getChildren()[0]); // test the selection


        this.assertEquals(this.__a__P_236_3, this.__controller__P_236_2.getSelection().getItem(0), "Selection does not work."); // test for the length

        this.assertEquals(1, this.__controller__P_236_2.getSelection().length, "Selection length is wrong."); // select the second object

        this.__tree__P_236_0.addToSelection(this.__tree__P_236_0.getRoot().getChildren()[1]); // test the selection


        this.assertEquals(this.__b__P_236_4, this.__controller__P_236_2.getSelection().getItem(0), "Selection does not work."); // test for the length

        this.assertEquals(1, this.__controller__P_236_2.getSelection().length, "Selection length is wrong.");
      },
      testSelectionBackMultiple: function testSelectionBackMultiple() {
        // open the tree so that the selection can be done
        this.__tree__P_236_0.getRoot().setOpen(true); // select the second and third object


        this.__tree__P_236_0.setSelectionMode("multi"); // add the some elements to the selection


        this.__controller__P_236_2.getSelection().push(this.__a__P_236_3);

        this.__controller__P_236_2.getSelection().push(this.__b__P_236_4); // test the selection


        this.assertEquals(this.__a__P_236_3, this.__controller__P_236_2.getSelection().getItem(0), "Add to selection does not work.");
        this.assertEquals(this.__b__P_236_4, this.__controller__P_236_2.getSelection().getItem(1), "Add to selection does not work.");
      },
      testSelectionAfterDelete: function testSelectionAfterDelete() {
        // open the tree so that the selection can be done
        this.__tree__P_236_0.getRoot().setOpen(true); // add c to the selection


        this.__controller__P_236_2.getSelection().push(this.__c__P_236_5); // remove the c node


        var temp = this.__model__P_236_1.getChildren().splice(2, 1);

        temp.setAutoDisposeItems(true);
        temp.dispose(); // check if the selection is empty

        this.assertEquals(0, this.__controller__P_236_2.getSelection().length, "Remove from selection does not work!"); // add b to the selection

        this.__controller__P_236_2.getSelection().push(this.__b__P_236_4); // remove the first element of the controller 'this.__a'


        temp = this.__model__P_236_1.getChildren().shift();
        temp.dispose(); // check if the selected item in the list is "b"

        this.assertTrue(this.__controller__P_236_2.getSelection().contains(this.__b__P_236_4), "Selection array wrong!");
        this.assertEquals("b", this.__tree__P_236_0.getSelection()[0].getLabel(), "Remove from selection does not work!");
      },
      testSelectInvisible: function testSelectInvisible() {
        // add c to the selection
        this.__controller__P_236_2.getSelection().push(this.__c__P_236_5); // check if the selection worked


        this.assertEquals(1, this.__controller__P_236_2.getSelection().length, "Adding of an non visible element should not work.");
      },
      testLabelOptions: function testLabelOptions() {
        // create the options
        var options = {
          converter: function converter(data, model) {
            return data + model.getName2();
          }
        }; // create the controller

        this.__controller__P_236_2.dispose();

        this.__controller__P_236_2 = new qx.data.controller.Tree(this.__model__P_236_1, this.__tree__P_236_0, "children", "name");

        this.__controller__P_236_2.setLabelOptions(options); // test the converter


        this.assertEquals("rootroot2", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("aa2", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("bb2", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("cc2", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testIconOptions: function testIconOptions() {
        // create the options
        var options = {
          converter: function converter(data, model) {
            if (data != null) {
              return data + model.getName();
            }

            return null;
          }
        }; // create the controller

        this.__controller__P_236_2.dispose();

        this.__controller__P_236_2 = new qx.data.controller.Tree(this.__model__P_236_1, this.__tree__P_236_0, "children", "name");

        this.__controller__P_236_2.setIconPath("icon");

        this.__controller__P_236_2.setIconOptions(options); // test the converter


        this.assertNull(this.__tree__P_236_0.getRoot().getIcon(), "Root node has a wrong icon");
        this.assertEquals("icon aa", this.__tree__P_236_0.getRoot().getChildren()[0].getIcon(), "First node has a wrong icon");
        this.assertEquals("icon bb", this.__tree__P_236_0.getRoot().getChildren()[1].getIcon(), "Second node has a wrong icon");
        this.assertEquals("icon cc", this.__tree__P_236_0.getRoot().getChildren()[2].getIcon(), "Third node has a wrong icon");
      },
      testItemWithoutChildren: function testItemWithoutChildren() {
        // create new Object
        qx.Class.define("qx.test.TreeEndNode", {
          extend: qx.core.Object,
          properties: {
            name: {
              check: "String",
              init: "root",
              event: "changeName"
            },
            icon: {
              check: "String",
              event: "changeIcon",
              nullable: true
            }
          }
        });
        var endNode = new qx.test.TreeEndNode();
        endNode.setName("ENDE");

        this.__model__P_236_1.getChildren().push(endNode);

        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
        this.assertEquals("ENDE", this.__tree__P_236_0.getRoot().getChildren()[3].getLabel(), "Fourth node has a wrong name");
      },
      testSetLateModel: function testSetLateModel() {
        this.__controller__P_236_2.dispose(); // create the controller


        this.__controller__P_236_2 = new qx.data.controller.Tree(null, this.__tree__P_236_0, "children", "name");

        this.__controller__P_236_2.setModel(this.__model__P_236_1); // check the initial Labels


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testSetLateTarget: function testSetLateTarget() {
        this.__controller__P_236_2.dispose(); // create the controller


        this.__controller__P_236_2 = new qx.data.controller.Tree(this.__model__P_236_1, null, "children", "name");

        this.__controller__P_236_2.setTarget(this.__tree__P_236_0); // check the initial Labels


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testSetLateTargetAndModel: function testSetLateTargetAndModel() {
        this.__controller__P_236_2.dispose();

        this.__controller__P_236_2 = new qx.data.controller.Tree(null, null, "children", "name");

        this.__controller__P_236_2.setTarget(this.__tree__P_236_0);

        this.__controller__P_236_2.setModel(this.__model__P_236_1); // check the initial Labels


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name"); // redo the test and set the modeln and target in different order

        this.__controller__P_236_2.dispose();

        this.__controller__P_236_2 = new qx.data.controller.Tree(null, null, "children", "name");

        this.__controller__P_236_2.setModel(this.__model__P_236_1);

        this.__controller__P_236_2.setTarget(this.__tree__P_236_0); // check the initial Labels


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testSetLateChildPath: function testSetLateChildPath() {
        this.__controller__P_236_2.dispose();

        this.__controller__P_236_2 = new qx.data.controller.Tree(this.__model__P_236_1, this.__tree__P_236_0, null, "name");

        this.__controller__P_236_2.setChildPath("children"); // check the initial Labels


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testSetLateLabelPath: function testSetLateLabelPath() {
        this.__controller__P_236_2.dispose();

        this.__controller__P_236_2 = new qx.data.controller.Tree(this.__model__P_236_1, this.__tree__P_236_0, "children");

        this.__controller__P_236_2.setLabelPath("name"); // check the initial Labels


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testSetLateAll: function testSetLateAll() {
        this.__controller__P_236_2.dispose();

        this.__controller__P_236_2 = new qx.data.controller.Tree(); // set the needed properties

        this.__controller__P_236_2.setLabelPath("name");

        this.__controller__P_236_2.setChildPath("children");

        this.__controller__P_236_2.setModel(this.__model__P_236_1);

        this.__controller__P_236_2.setTarget(this.__tree__P_236_0); // check the initial Labels


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testDelegateConfigure: function testDelegateConfigure() {
        // create the delegate
        var delegate = new qx.core.Object();

        delegate.configureItem = function (item) {
          item.setUserData("a", true);
        };

        this.__controller__P_236_2.setDelegate(delegate); // check the initial Labels


        this.assertTrue(this.__tree__P_236_0.getRoot().getUserData("a"), "Delegation not working.");
        this.assertTrue(this.__tree__P_236_0.getRoot().getChildren()[0].getUserData("a"), "Delegation not working.");
        this.assertTrue(this.__tree__P_236_0.getRoot().getChildren()[1].getUserData("a"), "Delegation not working.");
        this.assertTrue(this.__tree__P_236_0.getRoot().getChildren()[2].getUserData("a"), "Delegation not working.");

        this.__controller__P_236_2.setDelegate(null);

        delegate.dispose();
      },
      testDelegateConfigureLate: function testDelegateConfigureLate() {
        // clear up the setup
        this.__controller__P_236_2.dispose();

        var controller = new qx.data.controller.Tree(null, this.__tree__P_236_0, "children", "name");
        var delegate = {
          configureItem: function configureItem(item) {
            item.setUserData("a", true);
          }
        };
        controller.setDelegate(delegate);
        controller.setModel(this.__model__P_236_1); // check the initial Labels

        this.assertTrue(this.__tree__P_236_0.getRoot().getUserData("a"), "Delegation not working.");
        this.assertTrue(this.__tree__P_236_0.getRoot().getChildren()[0].getUserData("a"), "Delegation not working.");
        this.assertTrue(this.__tree__P_236_0.getRoot().getChildren()[1].getUserData("a"), "Delegation not working.");
        this.assertTrue(this.__tree__P_236_0.getRoot().getChildren()[2].getUserData("a"), "Delegation not working.");
        controller.dispose();
      },
      testDelegateCreateLate: function testDelegateCreateLate() {
        var delegate = {
          createItem: function createItem() {
            var folder = new qx.ui.tree.TreeFolder();
            folder.setUserData("my", true);
            return folder;
          }
        };

        this.__controller__P_236_2.setDelegate(delegate); // check the initial Labels


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name"); // check if the folders are the self created folders

        this.assertTrue(this.__tree__P_236_0.getRoot().getUserData("my"), "Default folders found.");
        this.assertTrue(this.__tree__P_236_0.getRoot().getChildren()[0].getUserData("my"), "Default folders found.");
        this.assertTrue(this.__tree__P_236_0.getRoot().getChildren()[1].getUserData("my"), "Default folders found.");
        this.assertTrue(this.__tree__P_236_0.getRoot().getChildren()[2].getUserData("my"), "Default folders found.");
      },
      testDelegateCreateFirst: function testDelegateCreateFirst() {
        this.__controller__P_236_2.dispose();

        this.__controller__P_236_2 = new qx.data.controller.Tree();
        var delegate = {
          createItem: function createItem() {
            var folder = new qx.ui.tree.TreeFolder();
            folder.setUserData("my", true);
            return folder;
          }
        };
        var tree = new qx.ui.tree.Tree();

        this.__controller__P_236_2.setDelegate(delegate);

        this.__controller__P_236_2.setChildPath("children");

        this.__controller__P_236_2.setLabelPath("name");

        this.__controller__P_236_2.setModel(this.__model__P_236_1);

        this.__controller__P_236_2.setTarget(tree); // check the initial Labels


        this.assertEquals("root", tree.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", tree.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", tree.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", tree.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name"); // check if the folders are the self created folders

        this.assertTrue(tree.getRoot().getUserData("my"), "Default folders found.");
        this.assertTrue(tree.getRoot().getChildren()[0].getUserData("my"), "Default folders found.");
        this.assertTrue(tree.getRoot().getChildren()[1].getUserData("my"), "Default folders found.");
        this.assertTrue(tree.getRoot().getChildren()[2].getUserData("my"), "Default folders found.");
        tree.destroy();
      },
      testDelegateBindLate: function testDelegateBindLate() {
        var delegate = {
          bindItem: function bindItem(controller, item, id) {
            controller.bindDefaultProperties(item, id);
            controller.bindProperty("color", "textColor", null, item, id);
          }
        };

        this.__controller__P_236_2.setDelegate(delegate); // check the initial Labels


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name"); // check the names

        this.assertEquals("green", this.__tree__P_236_0.getRoot().getTextColor(), "Root node has a wrong name");
        this.assertEquals("red", this.__tree__P_236_0.getRoot().getChildren()[0].getTextColor(), "First node has a wrong name");
        this.assertEquals("blue", this.__tree__P_236_0.getRoot().getChildren()[1].getTextColor(), "Second node has a wrong name");
        this.assertEquals("white", this.__tree__P_236_0.getRoot().getChildren()[2].getTextColor(), "Third node has a wrong name");

        this.__model__P_236_1.setColor("black");

        this.assertEquals("black", this.__tree__P_236_0.getRoot().getTextColor(), "Root node has a wrong name");
      },
      testDelegateBindFirst: function testDelegateBindFirst() {
        var delegate = {
          bindItem: function bindItem(controller, item, id) {
            controller.bindDefaultProperties(item, id);
            controller.bindProperty("color", "textColor", null, item, id);
          }
        };
        var tree = new qx.ui.tree.Tree();

        this.__controller__P_236_2.setDelegate(delegate);

        this.__controller__P_236_2.setChildPath("children");

        this.__controller__P_236_2.setLabelPath("name");

        this.__controller__P_236_2.setModel(this.__model__P_236_1);

        this.__controller__P_236_2.setTarget(tree); // check the initial Labels


        this.assertEquals("root", tree.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", tree.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", tree.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", tree.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name"); // check the names

        this.assertEquals("green", tree.getRoot().getTextColor(), "Root node has a wrong name");
        this.assertEquals("red", tree.getRoot().getChildren()[0].getTextColor(), "First node has a wrong name");
        this.assertEquals("blue", tree.getRoot().getChildren()[1].getTextColor(), "Second node has a wrong name");
        this.assertEquals("white", tree.getRoot().getChildren()[2].getTextColor(), "Third node has a wrong name");

        this.__model__P_236_1.setColor("black");

        this.assertEquals("black", tree.getRoot().getTextColor(), "Root node has a wrong name");
        tree.dispose();
      },
      testDelegateBindPropertyReverse: function testDelegateBindPropertyReverse() {
        var delegate = {
          bindItem: function bindItem(controller, item, id) {
            controller.bindProperty("name", "appearance", null, item, id);
            controller.bindPropertyReverse("name", "appearance", null, item, id);
            controller.bindPropertyReverse("color", "backgroundColor", null, item, id);
          }
        };

        this.__controller__P_236_2.setDelegate(delegate); // check the initial Labels


        this.assertEquals("root", this.__tree__P_236_0.getRoot().getAppearance(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getAppearance(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getAppearance(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getAppearance(), "Third node has a wrong name"); // check the reverse binding

        this.__tree__P_236_0.getRoot().setAppearance("ROOT");

        this.assertEquals("ROOT", this.__model__P_236_1.getName(), "Reverse binding not ok!");

        this.__tree__P_236_0.getRoot().getChildren()[0].setBackgroundColor("#123456");

        this.assertEquals("#123456", this.__a__P_236_3.getColor(), "Reverse binding not ok!"); // invoke a removing and setting of the bindings with the new bindItem

        delegate.bindItem = function (controller, item, id) {
          controller.bindProperty("name", "appearance", null, item, id);
        };

        this.__controller__P_236_2.setDelegate(null);

        this.__controller__P_236_2.setDelegate(delegate);

        this.__tree__P_236_0.getRoot().setAppearance("123");

        this.assertEquals("ROOT", this.__model__P_236_1.getName(), "Removing not ok");

        this.__tree__P_236_0.getRoot().getChildren()[0].setBackgroundColor("#654321");

        this.assertEquals("#123456", this.__a__P_236_3.getColor(), "Removing not ok");
      },
      testDelegateAddItem: function testDelegateAddItem() {
        var a = new qx.test.TreeNode();
        a.setName("new"); // set a delegate

        this.__controller__P_236_2.setDelegate({
          createItem: function createItem() {
            return new qx.ui.tree.TreeFolder();
          }
        }); // flush the dispose queue


        qx.ui.core.queue.Dispose.flush(); // add the new model

        this.__model__P_236_1.getChildren().push(a);
      },
      testResetModel: function testResetModel() {
        this.__controller__P_236_2.resetModel();

        this.assertNull(this.__tree__P_236_0.getRoot(), "Tree is not empty.");
      },
      testChangeChildrenArray: function testChangeChildrenArray() {
        // create the new children array
        var children = new qx.data.Array();
        var a = new qx.test.TreeNode();
        a.setName("new");
        children.push(a);

        var oldChildren = this.__a__P_236_3.getChildren(); // change the children array
        //        this.__model
        //        /    |      \
        // this.__a  this.__b  this.__c
        //    |
        //   a


        this.__a__P_236_3.setChildren(children);

        oldChildren.dispose(); // Test if the tree nodes exist

        this.assertNotUndefined(this.__tree__P_236_0.getRoot(), "Root node does not exist");
        this.assertNotUndefined(this.__tree__P_236_0.getRoot().getChildren()[0], "First node does not exist");
        this.assertNotUndefined(this.__tree__P_236_0.getRoot().getChildren()[0].getChildren()[0], "New node does not exist"); // test if its the proper node

        this.assertEquals("new", this.__tree__P_236_0.getRoot().getChildren()[0].getChildren()[0].getLabel());
      },
      testInheritedChildren: function testInheritedChildren() {
        qx.Class.define("qx.test.MyTreeNode", {
          extend: qx.test.TreeNode
        }); // init (copy of setUp)

        this.__tree__P_236_0.dispose();

        this.__model__P_236_1.dispose();

        this.__a__P_236_3.dispose();

        this.__b__P_236_4.dispose();

        this.__c__P_236_5.dispose();

        this.__tree__P_236_0 = new qx.ui.tree.Tree(); // create a model
        //        this.__model
        //        /    |      \
        // this.__a  this.__b  this.__c

        this.__model__P_236_1 = new qx.test.MyTreeNode();
        this.__a__P_236_3 = new qx.test.MyTreeNode();

        this.__a__P_236_3.set({
          name: "a",
          name2: "a2",
          icon: "icon a",
          icon2: "icon a2",
          color: "red"
        });

        this.__b__P_236_4 = new qx.test.MyTreeNode();

        this.__b__P_236_4.set({
          name: "b",
          name2: "b2",
          icon: "icon b",
          icon2: "icon b2",
          color: "blue"
        });

        this.__c__P_236_5 = new qx.test.MyTreeNode();

        this.__c__P_236_5.set({
          name: "c",
          name2: "c2",
          icon: "icon c",
          icon2: "icon c2",
          color: "white"
        });

        this.__model__P_236_1.getChildren().push(this.__a__P_236_3, this.__b__P_236_4, this.__c__P_236_5);

        this.__model__P_236_1.getAltChildren().push(this.__c__P_236_5, this.__b__P_236_4, this.__a__P_236_3); // create the controller


        this.__controller__P_236_2.dispose();

        this.__controller__P_236_2 = new qx.data.controller.Tree(this.__model__P_236_1, this.__tree__P_236_0, "children", "name"); // check the initial Labels

        this.assertEquals("root", this.__tree__P_236_0.getRoot().getLabel(), "Root node has a wrong name");
        this.assertEquals("a", this.__tree__P_236_0.getRoot().getChildren()[0].getLabel(), "First node has a wrong name");
        this.assertEquals("b", this.__tree__P_236_0.getRoot().getChildren()[1].getLabel(), "Second node has a wrong name");
        this.assertEquals("c", this.__tree__P_236_0.getRoot().getChildren()[2].getLabel(), "Third node has a wrong name");
      },
      testRemoveEvents: function testRemoveEvents() {
        // BUG #3566
        var nodes = [];

        for (var i = 0; i < 50; ++i) {
          nodes[i] = new qx.test.TreeNode();

          if (i != 0) {
            nodes[parseInt(Math.random() * i, 10)].getChildren().push(nodes[i]);
          }
        }

        var tree = new qx.ui.tree.Tree();
        var controller = new qx.data.controller.Tree(nodes[0], tree, "children", "name");

        for (var i = 0; i < nodes.length; ++i) {
          nodes[i].getChildren().removeAll(); // THIS THROWS AN EXCEPTION ON 2ND ELEMENT...
        }

        controller.dispose();
        tree.dispose();

        for (var i = 0; i < nodes.length; ++i) {
          nodes[i].dispose();
        }
      },
      testBindItemDouble: function testBindItemDouble() {
        var delegate = {
          bindItem: function bindItem(controller, item, id) {
            controller.bindProperty("color", "textColor", null, item, id);
            controller.bindProperty("color", "textColor", null, item, id);
          }
        };
        var self = this;
        this.assertException(function () {
          self.__controller__P_236_2.setDelegate(delegate);
        }, Error, /textColor/.g);
      },
      testBindItemDoubleReverse: function testBindItemDoubleReverse() {
        var delegate = {
          bindItem: function bindItem(controller, item, id) {
            controller.bindPropertyReverse("color", "textColor", null, item, id);
            controller.bindPropertyReverse("color", "textColor", null, item, id);
          }
        };
        var self = this;
        this.assertException(function () {
          self.__controller__P_236_2.setDelegate(delegate);
        }, Error, /textColor/.g);
      }
    }
  });
  qx.test.data.controller.Tree.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.selection.ScrollArea": {
        "require": true
      },
      "qx.ui.tree.core.AbstractTreeItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Responsible for the selection management of the {@link qx.ui.tree.Tree}.
   *
   * @internal
   */
  qx.Class.define("qx.ui.tree.selection.SelectionManager", {
    extend: qx.ui.core.selection.ScrollArea,
    members: {
      // overridden
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        var computed = item.getBounds();

        if (computed) {
          var top = this._getWidget().getItemTop(item);

          return {
            top: top,
            bottom: top + computed.height
          };
        }
      },
      // overridden
      _isSelectable: function _isSelectable(item) {
        return this._isItemSelectable(item) && item instanceof qx.ui.tree.core.AbstractTreeItem;
      },
      // overridden
      _getSelectableFromPointerEvent: function _getSelectableFromPointerEvent(event) {
        return this._getWidget().getTreeItem(event.getTarget());
      },
      // overridden
      getSelectables: function getSelectables(all) {
        // if only the user selectables should be returned
        var oldUserInteraction = false;

        if (!all) {
          oldUserInteraction = this._userInteraction;
          this._userInteraction = true;
        }

        var widget = this._getWidget();

        var result = [];

        if (widget.getRoot() != null) {
          var items = widget.getRoot().getItems(true, !!all, widget.getHideRoot());

          for (var i = 0; i < items.length; i++) {
            if (this._isSelectable(items[i])) {
              result.push(items[i]);
            }
          }
        } // reset to the former user interaction state


        this._userInteraction = oldUserInteraction;
        return result;
      },
      // overridden
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        // Fast path for identical items
        if (item1 === item2) {
          return [item1];
        }

        var selectables = this.getSelectables();
        var item1Index = selectables.indexOf(item1);
        var item2Index = selectables.indexOf(item2);

        if (item1Index < 0 || item2Index < 0) {
          return [];
        }

        if (item1Index < item2Index) {
          return selectables.slice(item1Index, item2Index + 1);
        } else {
          return selectables.slice(item2Index, item1Index + 1);
        }
      },
      // overridden
      _getFirstSelectable: function _getFirstSelectable() {
        return this.getSelectables()[0] || null;
      },
      // overridden
      _getLastSelectable: function _getLastSelectable() {
        var selectables = this.getSelectables();

        if (selectables.length > 0) {
          return selectables[selectables.length - 1];
        } else {
          return null;
        }
      },
      // overridden
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        var widget = this._getWidget();

        var related = null;

        switch (relation) {
          case "above":
            related = widget.getPreviousNodeOf(item, false);
            break;

          case "under":
            related = widget.getNextNodeOf(item, false);
            break;

          case "left":
          case "right":
            break;
        }

        if (!related) {
          return null;
        }

        if (this._isSelectable(related)) {
          return related;
        } else {
          return this._getRelatedSelectable(related, relation);
        }
      }
    }
  });
  qx.ui.tree.selection.SelectionManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.scroll.AbstractScrollArea": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.IMultiSelection": {
        "require": true
      },
      "qx.ui.form.IModelSelection": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.core.MMultiSelectionHandling": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.ui.form.MModelSelection": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.tree.selection.SelectionManager": {
        "require": true
      },
      "qx.ui.tree.core.AbstractTreeItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Derrell Lipman (derrell)
       * Christian Hagendorn (chris_schmidt)
       * Daniel Wagner (d_wagner)
  
  ************************************************************************ */

  /**
   * The Tree class implements a tree widget, with collapsible and expandable
   * container nodes and terminal leaf nodes. You instantiate a Tree object and
   * then assign the tree a root folder using the {@link #root} property.
   *
   * If you don't want to show the root item, you can hide it with the
   * {@link #hideRoot} property.
   *
   * The handling of <b>selections</b> within a tree is somewhat distributed
   * between the root tree object and the attached {@link qx.ui.tree.selection.SelectionManager}.
   * To get the currently selected element of a tree use the tree {@link #getSelection}
   * method and tree {@link #setSelection} to set it. The TreeSelectionManager
   * handles more coarse-grained issues like providing {@link #selectAll} and
   * {@link #resetSelection} methods.
   */
  qx.Class.define("qx.ui.tree.Tree", {
    extend: qx.ui.core.scroll.AbstractScrollArea,
    implement: [qx.ui.core.IMultiSelection, qx.ui.form.IModelSelection, qx.ui.form.IField, qx.ui.form.IForm],
    include: [qx.ui.core.MMultiSelectionHandling, qx.ui.core.MContentPadding, qx.ui.form.MModelSelection, qx.ui.form.MForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.scroll.AbstractScrollArea.constructor.call(this);
      this.__content__P_528_0 = new qx.ui.container.Composite(new qx.ui.layout.VBox()).set({
        allowShrinkY: false,
        allowGrowX: true
      });
      this.getChildControl("pane").add(this.__content__P_528_0);
      this.initOpenMode();
      this.initRootOpenClose();
      this.addListener("changeSelection", this._onChangeSelection, this);
      this.addListener("keypress", this._onKeyPress, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * This event is fired after a tree item was added to the tree. The
       * {@link qx.event.type.Data#getData} method of the event returns the
       * added item.
       */
      addItem: "qx.event.type.Data",

      /**
       * This event is fired after a tree item has been removed from the tree.
       * The {@link qx.event.type.Data#getData} method of the event returns the
       * removed item.
       */
      removeItem: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Control whether tap or double tap should open or close the tapped
       * folder.
       */
      openMode: {
        check: ["tap", "dbltap", "none"],
        init: "dbltap",
        apply: "_applyOpenMode",
        event: "changeOpenMode",
        themeable: true
      },

      /**
       * The root tree item of the tree to display
       */
      root: {
        check: "qx.ui.tree.core.AbstractTreeItem",
        init: null,
        nullable: true,
        event: "changeRoot",
        apply: "_applyRoot"
      },

      /**
       * Hide the root (Tree) node.  This differs from the visibility property in
       * that this property hides *only* the root node, not the node's children.
       */
      hideRoot: {
        check: "Boolean",
        init: false,
        apply: "_applyHideRoot"
      },

      /**
       * Whether the Root should have an open/close button.  This may also be
       * used in conjunction with the hideNode property to provide for virtual root
       * nodes.  In the latter case, be very sure that the virtual root nodes are
       * expanded programmatically, since there will be no open/close button for the
       * user to open them.
       */
      rootOpenClose: {
        check: "Boolean",
        init: false,
        apply: "_applyRootOpenClose"
      },
      // overridden
      appearance: {
        refine: true,
        init: "tree"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __content__P_528_0: null,

      /** @type {Class} Pointer to the selection manager to use */
      SELECTION_MANAGER: qx.ui.tree.selection.SelectionManager,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */

      /**
       * Get the widget, which contains the root tree item. This widget must
       * have a vertical box layout.
       *
       * @return {qx.ui.core.Widget} the children container
       */
      getChildrenContainer: function getChildrenContainer() {
        return this.__content__P_528_0;
      },
      // property apply
      _applyRoot: function _applyRoot(value, old) {
        var container = this.getChildrenContainer();

        if (old && !old.isDisposed()) {
          container.remove(old);

          if (old.hasChildren()) {
            container.remove(old.getChildrenContainer());
          }
        }

        if (value) {
          container.add(value);

          if (value.hasChildren()) {
            container.add(value.getChildrenContainer());
          }

          value.setVisibility(this.getHideRoot() ? "excluded" : "visible");
          value.recursiveAddToWidgetQueue();
        }
      },
      // property apply
      _applyHideRoot: function _applyHideRoot(value, old) {
        var root = this.getRoot();

        if (!root) {
          return;
        }

        root.setVisibility(value ? "excluded" : "visible");
        root.recursiveAddToWidgetQueue();
      },
      // property apply
      _applyRootOpenClose: function _applyRootOpenClose(value, old) {
        var root = this.getRoot();

        if (!root) {
          return;
        }

        root.recursiveAddToWidgetQueue();
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.__content__P_528_0;
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION MANAGER API
      ---------------------------------------------------------------------------
      */

      /**
       * Get the tree item following the given item in the tree hierarchy.
       *
       * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the item after
       * @param invisible {Boolean?true} Whether invisible/closed tree items
       *     should be returned as well.
       *
       * @return {qx.ui.tree.core.AbstractTreeItem?null} The item after the given item. May be
       *     <code>null</code> if the item is the last item.
       */
      getNextNodeOf: function getNextNodeOf(treeItem, invisible) {
        if ((invisible !== false || treeItem.isOpen()) && treeItem.hasChildren()) {
          return treeItem.getChildren()[0];
        }

        while (treeItem) {
          var parent = treeItem.getParent();

          if (!parent) {
            return null;
          }

          var parentChildren = parent.getChildren();
          var index = parentChildren.indexOf(treeItem);

          if (index > -1 && index < parentChildren.length - 1) {
            return parentChildren[index + 1];
          }

          treeItem = parent;
        }

        return null;
      },

      /**
       * Get the tree item preceding the given item in the tree hierarchy.
       *
       * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the item before
       * @param invisible {Boolean?true} Whether invisible/closed tree items
       *     should be returned as well.
       *
       * @return {qx.ui.tree.core.AbstractTreeItem?null} The item before the given item. May be
       *     <code>null</code> if the given item is the tree's root.
       */
      getPreviousNodeOf: function getPreviousNodeOf(treeItem, invisible) {
        var parent = treeItem.getParent();

        if (!parent) {
          return null;
        }

        if (this.getHideRoot()) {
          if (parent == this.getRoot()) {
            if (parent.getChildren()[0] == treeItem) {
              return null;
            }
          }
        } else {
          if (treeItem == this.getRoot()) {
            return null;
          }
        }

        var parentChildren = parent.getChildren();
        var index = parentChildren.indexOf(treeItem);

        if (index > 0) {
          var folder = parentChildren[index - 1];

          while ((invisible !== false || folder.isOpen()) && folder.hasChildren()) {
            var children = folder.getChildren();
            folder = children[children.length - 1];
          }

          return folder;
        } else {
          return parent;
        }
      },

      /**
       * Get the tree item's next sibling.
       *
       * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the following
       * sibling of.
       *
       * @return {qx.ui.tree.core.AbstractTreeItem?null} The item following the given item. May be
       *     <code>null</code> if the given item is the last in it's nesting
       *     level.
       */
      getNextSiblingOf: function getNextSiblingOf(treeItem) {
        if (treeItem == this.getRoot()) {
          return null;
        }

        var parent = treeItem.getParent();
        var siblings = parent.getChildren();
        var index = siblings.indexOf(treeItem);

        if (index < siblings.length - 1) {
          return siblings[index + 1];
        }

        return null;
      },

      /**
       * Get the tree item's previous sibling.
       *
       * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the previous
       * sibling of.
       *
       * @return {qx.ui.tree.core.AbstractTreeItem?null} The item preceding the given item. May be
       *     <code>null</code> if the given item is the first in it's nesting
       *     level.
       */
      getPreviousSiblingOf: function getPreviousSiblingOf(treeItem) {
        if (treeItem == this.getRoot()) {
          return null;
        }

        var parent = treeItem.getParent();
        var siblings = parent.getChildren();
        var index = siblings.indexOf(treeItem);

        if (index > 0) {
          return siblings[index - 1];
        }

        return null;
      },

      /**
       * Returns all children of the tree.
       *
       * @param recursive {Boolean ? false} whether children of subfolder should be
       *     included
       * @param invisible {Boolean ? true} whether invisible children should be
       *     included
       * @return {qx.ui.tree.core.AbstractTreeItem[]} list of children
       */
      getItems: function getItems(recursive, invisible) {
        if (this.getRoot() != null) {
          return this.getRoot().getItems(recursive, invisible, this.getHideRoot());
        } else {
          return [];
        }
      },

      /**
       * Returns the tree's only "external" child, namely the root node.
       *
       * @return {qx.ui.tree.core.AbstractTreeItem[]} Array containing the root node
       */
      getChildren: function getChildren() {
        if (this.getRoot() != null) {
          return [this.getRoot()];
        } else {
          return [];
        }
      },

      /*
      ---------------------------------------------------------------------------
        POINTER EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the tree item, which contains the given widget.
       *
       * @param widget {qx.ui.core.Widget} The widget to get the containing tree
       *   item for.
       * @return {qx.ui.tree.core.AbstractTreeItem|null} The tree item containing the widget. If the
       *     widget is not inside of any tree item <code>null</code> is returned.
       */
      getTreeItem: function getTreeItem(widget) {
        while (widget) {
          if (widget == this) {
            return null;
          }

          if (widget instanceof qx.ui.tree.core.AbstractTreeItem) {
            return widget;
          }

          widget = widget.getLayoutParent();
        }

        return null;
      },
      // property apply
      _applyOpenMode: function _applyOpenMode(value, old) {
        if (old == "tap") {
          this.removeListener("tap", this._onOpen, this);
        } else if (old == "dbltap") {
          this.removeListener("dbltap", this._onOpen, this);
        }

        if (value == "tap") {
          this.addListener("tap", this._onOpen, this);
        } else if (value == "dbltap") {
          this.addListener("dbltap", this._onOpen, this);
        }
      },

      /**
       * Event handler for tap events, which could change a tree item's open
       * state.
       *
       * @param e {qx.event.type.Pointer} The tap event object
       */
      _onOpen: function _onOpen(e) {
        var treeItem = this.getTreeItem(e.getTarget());

        if (!treeItem || !treeItem.isOpenable()) {
          return;
        }

        treeItem.setOpen(!treeItem.isOpen());
        e.stopPropagation();
      },

      /**
       * Event handler for changeSelection events, which opens all parent folders
       * of the selected folders.
       *
       * @param e {qx.event.type.Data} The selection data event.
       */
      _onChangeSelection: function _onChangeSelection(e) {
        var selection = e.getData(); // for every selected folder

        for (var i = 0; i < selection.length; i++) {
          var folder = selection[i]; // go up all parents and open them

          while (folder.getParent() != null) {
            folder = folder.getParent();
            folder.setOpen(true);
          }
        }
      },

      /**
       * Event handler for key press events. Open and close the current selected
       * item on key left and right press. Jump to parent on key left if already
       * closed.
       *
       * @param e {qx.event.type.KeySequence} key event.
       */
      _onKeyPress: function _onKeyPress(e) {
        var item = this._getLeadItem();

        if (item !== null) {
          switch (e.getKeyIdentifier()) {
            case "Left":
              if (item.isOpenable() && item.isOpen()) {
                item.setOpen(false);
              } else if (item.getParent()) {
                this.setSelection([item.getParent()]);
              }

              break;

            case "Right":
              if (item.isOpenable() && !item.isOpen()) {
                item.setOpen(true);
              }

              break;

            case "Enter":
            case "Space":
              if (item.isOpenable()) {
                item.toggleOpen();
              }

              break;
          }
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__content__P_528_0");
    }
  });
  qx.ui.tree.Tree.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.data.marshal.Json": {},
      "qx.lang.String": {},
      "qx.locale.Manager": {},
      "qx.core.Object": {},
      "qx.data.marshal.MEventBubbling": {},
      "qx.data.Array": {},
      "qx.util.OOUtil": {},
      "qx.core.ValidationError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @asset(qx/test/*)
   *
   * @ignore(qx.data.model)
   * @ignore(qx.test.model.*)
   * @ignore(qx.Test)
   * @ignore(qx.test.Array)
   */
  qx.Class.define("qx.test.data.marshal.Json", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      __marshaler__P_237_0: null,
      __data__P_237_1: null,
      __propertyNames__P_237_2: null,
      setUp: function setUp() {
        this.__marshaler__P_237_0 = new qx.data.marshal.Json();
        this.__data__P_237_1 = {
          s: 'String',
          n: 12,
          b: true
        };
        this.__propertyNames__P_237_2 = ["s", "n", "b"];
      },
      tearDown: function tearDown() {
        this.__marshaler__P_237_0.dispose(); // remove the former created classes


        qx.data.model = {};

        for (var name in qx.Class.$$registry) {
          if (name.search("qx.data.model") != -1) {
            delete qx.Class.$$registry[name];
          }
        }
      },
      "test$$member": function test$$member() {
        var data = {
          $$a: "b"
        };

        this.__marshaler__P_237_0.toClass(data); // check if the class is defined


        this.assertTrue(qx.Class.isDefined('qx.data.model.$$a'), "Class not created.");
        var clazz = qx.Class.getByName('qx.data.model.$$a'); // check for the property

        for (var name in clazz.$$properties) {
          this.assertEquals("$$a", name, "Property $$a does have the wrong name.");
          this.assertEquals("change" + qx.lang.String.firstUp("$$a"), clazz.$$properties[name].event, "event has a wrong name.");
        }

        qx.Class.undefine('qx.data.model.$$a');
      },
      testLocalizedString: function testLocalizedString() {
        var str = qx.locale.Manager.tr("test one");
        var data = {
          a: str
        };

        this.__marshaler__P_237_0.toClass(data);

        var model = this.__marshaler__P_237_0.toModel(data);

        this.assertEquals(str, model.getA());
        model.dispose();
        qx.Class.undefine('qx.data.model.a');
      },
      testClassCreationSingle: function testClassCreationSingle() {
        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // check if the class is defined


        this.assertTrue(qx.Class.isDefined('qx.data.model.b|n|s'), "Class not created.");
        var clazz = qx.Class.getByName('qx.data.model.b|n|s'); // check for the properties

        var i = 0;

        for (var name in clazz.$$properties) {
          this.assertEquals(this.__propertyNames__P_237_2[i], name, "Property " + i + "does have the wrong name.");
          this.assertEquals("change" + qx.lang.String.firstUp(this.__propertyNames__P_237_2[i]), clazz.$$properties[name].event, "event has a wrong name.");
          i++;
        }
      },
      testClassCreationArray: function testClassCreationArray() {
        this.__data__P_237_1 = {
          a: ['a', 'b', 'c']
        };

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // check if the class is defined


        this.assertTrue(qx.Class.isDefined("qx.data.model.a"), "Class not created.");
        var clazz = qx.Class.getByName("qx.data.model.a"); // check for the property

        this.assertNotNull(clazz.$$properties.a, "Property does not exist.");
      },
      testClassCreationObject: function testClassCreationObject() {
        this.__data__P_237_1 = {
          a: {
            b: 'test'
          }
        };

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // check if the classes are defined


        this.assertTrue(qx.Class.isDefined("qx.data.model.a"), "Class not created.");
        this.assertTrue(qx.Class.isDefined("qx.data.model.b"), "Class not created.");
        var clazz = qx.Class.getByName("qx.data.model.a");
        var clazz2 = qx.Class.getByName("qx.data.model.b"); // check for the property

        this.assertNotNull(clazz.$$properties.a, "Property does not exist.");
        this.assertNotNull(clazz2.$$properties.b, "Property does not exist.");
      },
      testClassCreationArrayWithObject: function testClassCreationArrayWithObject() {
        this.__data__P_237_1 = {
          a: [{
            b: 'test'
          }, {
            b: 'test'
          }]
        };

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // check if the classes are defined


        this.assertTrue(qx.Class.isDefined("qx.data.model.a"), "Class not created.");
        this.assertTrue(qx.Class.isDefined("qx.data.model.b"), "Class not created.");
        var clazz = qx.Class.getByName("qx.data.model.a");
        var clazz2 = qx.Class.getByName("qx.data.model.b"); // check for the property

        this.assertNotNull(clazz.$$properties.a, "Property does not exist.");
        this.assertNotNull(clazz2.$$properties.b, "Property does not exist.");
      },
      testClassCreationAllSmoke: function testClassCreationAllSmoke() {
        this.__data__P_237_1 = {
          a: [{
            b: 'test',
            c: ['f', 'x', 'e']
          }, {
            b: 'test',
            affe: false
          }],
          t: {
            f: null,
            r: 152,
            q: true
          }
        };

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1);
      },
      testModelWithNumber: function testModelWithNumber() {
        this.__data__P_237_1 = {
          a: 10,
          b: -15,
          c: 10.5e10
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the model


        this.assertEquals(10, model.getA(), "getA does not work.");
        this.assertEquals(-15, model.getB(), "getB does not work.");
        this.assertEquals(10.5e10, model.getC(), "getC does not work.");
        model.dispose();
      },
      testModelWithBoolean: function testModelWithBoolean() {
        this.__data__P_237_1 = {
          a: true,
          b: false
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the model


        this.assertEquals(true, model.getA(), "getA does not work.");
        this.assertEquals(false, model.getB(), "getB does not work.");
        model.dispose();
      },
      testModelWithString: function testModelWithString() {
        this.__data__P_237_1 = {
          a: 'affe',
          b: 'AFFE'
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the model


        this.assertEquals("affe", model.getA(), "getA does not work.");
        this.assertEquals("AFFE", model.getB(), "getB does not work.");
        model.dispose();
      },
      testModelWithPrimitive: function testModelWithPrimitive() {
        this.__data__P_237_1 = {
          a: 'affe',
          b: true,
          c: 156
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the model


        this.assertEquals("affe", model.getA(), "getA does not work.");
        this.assertEquals(true, model.getB(), "getB does not work.");
        this.assertEquals(156, model.getC(), "getC does not work.");
        model.dispose();
      },
      testModelWithArrayPrimitive: function testModelWithArrayPrimitive() {
        this.__data__P_237_1 = {
          a: ['affe', 'affen', 'AFFE']
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the model


        var a = model.getA();
        this.assertNotNull(a, "Nothing stored in the property a.");
        this.assertEquals("qx.data.Array", a.classname, "Its not an data array.");
        this.assertEquals("affe", a.getItem(0), "Item 0 is wrong");
        this.assertEquals("affen", a.getItem(1), "Item 1 is wrong");
        this.assertEquals("AFFE", a.getItem(2), "Item 2 is wrong");
        model.dispose();
      },
      testModelWithArrayArray: function testModelWithArrayArray() {
        this.__data__P_237_1 = {
          a: [[true, false], [10, 15]]
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the model


        var a = model.getA();
        this.assertNotNull(a, "Nothing stored in the property a.");
        this.assertEquals("qx.data.Array", a.classname, "Its not an data array.");
        var a0 = a.getItem(0);
        this.assertEquals("qx.data.Array", a0.classname, "Its not an data array.");
        this.assertEquals(true, a0.getItem(0), "Item 0 is wrong");
        this.assertEquals(false, a0.getItem(1), "Item 1 is wrong");
        var a1 = a.getItem(1);
        this.assertEquals("qx.data.Array", a1.classname, "Its not an data array.");
        this.assertEquals(10, a1.getItem(0), "Item 0 is wrong");
        this.assertEquals(15, a1.getItem(1), "Item 1 is wrong");
        model.dispose();
      },
      testModelWithObjectPrimitive: function testModelWithObjectPrimitive() {
        this.__data__P_237_1 = {
          a: {
            b: true,
            bb: false
          },
          aa: {
            c: 15,
            cc: -89
          }
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the model


        var a = model.getA();
        this.assertNotNull(a, "Nothing stored in the property a.");
        this.assertEquals(true, a.getB(), "b is not set");
        this.assertEquals(false, a.getBb(), "bb is not set");
        var aa = model.getAa();
        this.assertNotNull(aa, "Nothing stored in the property a.");
        this.assertEquals(15, aa.getC(), "c is not set");
        this.assertEquals(-89, aa.getCc(), "cc is not set");
        model.dispose();
      },
      testModelWithObjectArray: function testModelWithObjectArray() {
        this.__data__P_237_1 = {
          a: {
            b: ['affe', 'AFFE']
          }
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the model


        var a = model.getA();
        this.assertNotNull(a, "Nothing stored in the property a.");
        var b = a.getB();
        this.assertNotNull(b, "Nothing stored in the property b.");
        this.assertEquals("qx.data.Array", b.classname, "b is not an data array");
        this.assertEquals("affe", b.getItem(0), "Item 0 is wrong.");
        this.assertEquals("AFFE", b.getItem(1), "Item 1 is wrong.");
        model.dispose();
      },
      testModelWithArrayObject: function testModelWithArrayObject() {
        this.__data__P_237_1 = {
          a: [{
            a: 15
          }, {
            a: true
          }]
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the model


        var a = model.getA();
        this.assertNotNull(a, "Nothing stored in the property a.");
        this.assertEquals("qx.data.Array", a.classname, "b is not an data array");
        this.assertEquals(15, a.getItem(0).getA(), "Item 0 is wrong.");
        this.assertEquals(true, a.getItem(1).getA(), "Item 1 is wrong."); // check if only one class is created and used

        this.assertEquals(model.classname, a.getItem(0).classname, "Differen classes");
        this.assertEquals(model.classname, a.getItem(1).classname, "Differen classes");
        this.assertEquals(a.getItem(0).classname, a.getItem(1).classname, "Differen classes");
        model.dispose();
      },
      testModelWithObjectObject: function testModelWithObjectObject() {
        this.__data__P_237_1 = {
          a: {
            a: {
              a: 'affe'
            }
          }
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the model


        this.assertEquals("affe", model.getA().getA().getA(), "No affe is there!");
        model.dispose();
      },
      testModelWithAllSmoke: function testModelWithAllSmoke() {
        this.__data__P_237_1 = {
          a: [{
            aa: ['affe'],
            ab: false,
            ac: []
          }, {}, true, 15, 'affe'],
          b: 'Affe',
          c: {
            ca: 156,
            cb: [null, null],
            cc: true
          }
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1);

        this.assertNotNull(model, "No model set.");
        model.dispose();
      },
      testBubbleEventsDepth1: function testBubbleEventsDepth1() {
        this.__data__P_237_1 = {
          a: 10,
          b: -15,
          c: 10.5e10
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1, true); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the event for a


        var self = this;
        this.assertEventFired(model, "changeBubble", function () {
          model.setA(0);
        }, function (e) {
          self.assertEquals(0, e.getData().value, "Not the right value in the event.");
          self.assertEquals(10, e.getData().old, "Not the right old value in the event.");
          self.assertEquals("a", e.getData().name, "Not the right name in the event.");
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(model, e.getData().item, "Not the right item in the event.");
        }, "Change event not fired!"); // check the event for b

        this.assertEventFired(model, "changeBubble", function () {
          model.setB(0);
        }, function (e) {
          self.assertEquals(0, e.getData().value, "Not the right value in the event.");
          self.assertEquals(-15, e.getData().old, "Not the right old value in the event.");
          self.assertEquals("b", e.getData().name, "Not the right name in the event.");
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(model, e.getData().item, "Not the right item in the event.");
        }, "Change event not fired!");
        model.dispose();
      },
      testBubbleEventsDepth2: function testBubbleEventsDepth2() {
        this.__data__P_237_1 = {
          a: {
            b: 10,
            c: 20
          }
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1, true); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the event for b


        var self = this;
        this.assertEventFired(model, "changeBubble", function () {
          model.getA().setB(0);
        }, function (e) {
          self.assertEquals(0, e.getData().value, "Not the right value in the event.");
          self.assertEquals(10, e.getData().old, "Not the right old value in the event.");
          self.assertEquals("a.b", e.getData().name, "Not the right name in the event.");
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(model.getA(), e.getData().item, "Not the right item in the event.");
        }, "Change event not fired!");
        model.getA().dispose(); // check the event for a

        this.assertEventFired(model, "changeBubble", function () {
          model.setA(true);
        }, function (e) {
          self.assertEquals(true, e.getData().value, "Not the right value in the event.");
          self.assertEquals("a", e.getData().name, "Not the right name in the event.");
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(model, e.getData().item, "Not the right item in the event.");
        }, "Change event not fired!");
        model.dispose();
      },
      testBubbleEventsDepth3: function testBubbleEventsDepth3() {
        this.__data__P_237_1 = {
          a: {
            b: {
              c: 10
            }
          }
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1, true); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the event for c


        var self = this;
        this.assertEventFired(model, "changeBubble", function () {
          model.getA().getB().setC(0);
        }, function (e) {
          self.assertEquals(0, e.getData().value, "Not the right value in the event.");
          self.assertEquals(10, e.getData().old, "Not the right old value in the event.");
          self.assertEquals("a.b.c", e.getData().name, "Not the right name in the event.");
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(model.getA().getB(), e.getData().item, "Not the right item in the event.");
        }, "Change event not fired!");
        model.dispose();
      },
      testBubbleEventsArrayDepth1: function testBubbleEventsArrayDepth1() {
        this.__data__P_237_1 = {
          a: [12, 23, 34]
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1, true); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the event for the first array element


        var self = this;
        this.assertEventFired(model, "changeBubble", function () {
          model.getA().setItem(0, 1);
        }, function (e) {
          self.assertEquals(1, e.getData().value, "Not the right value in the event.");
          self.assertEquals("a[0]", e.getData().name, "Not the right name in the event.");
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(model.getA(), e.getData().item, "Not the right item in the event.");
        }, "Change event not fired!");
        model.dispose();
      },
      testBubbleEventsArrayDepth2: function testBubbleEventsArrayDepth2() {
        this.__data__P_237_1 = {
          a: [{
            b: 10
          }, {
            b: 11
          }]
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1, true); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the event for the first array element


        var self = this;
        this.assertEventFired(model, "changeBubble", function () {
          model.getA().getItem(0).setB(0);
        }, function (e) {
          self.assertEquals(0, e.getData().value, "Not the right value in the event.");
          self.assertEquals("a[0].b", e.getData().name, "Not the right name in the event.");
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(model.getA().getItem(0), e.getData().item, "Not the right item in the event.");
        }, "Change event not fired!");
        model.dispose();
      },
      testBubbleEventsArrayDepthAlot: function testBubbleEventsArrayDepthAlot() {
        this.__data__P_237_1 = {
          a: [[[[{
            b: 10
          }]]]]
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1, true); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the event for the first array element


        var self = this;
        this.assertEventFired(model, "changeBubble", function () {
          model.getA().getItem(0).getItem(0).getItem(0).getItem(0).setB(0);
        }, function (e) {
          self.assertEquals(0, e.getData().value, "Not the right value in the event.");
          self.assertEquals("a[0][0][0][0].b", e.getData().name, "Not the right name in the event.");
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(model.getA().getItem(0).getItem(0).getItem(0).getItem(0), e.getData().item, "Not the right item in the event.");
        }, "Change event not fired!");
        model.dispose();
      },
      testBubbleEventsArrayDepthAlotMix: function testBubbleEventsArrayDepthAlotMix() {
        this.__data__P_237_1 = {
          a: [{
            b: [[{
              c: {
                d: [0, 1]
              }
            }]]
          }]
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1, true); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the event for the first array element


        var self = this;
        this.assertEventFired(model, "changeBubble", function () {
          model.getA().getItem(0).getB().getItem(0).getItem(0).getC().getD().setItem(1, 12);
        }, function (e) {
          self.assertEquals(12, e.getData().value, "Not the right value in the event.");
          self.assertEquals("a[0].b[0][0].c.d[1]", e.getData().name, "Not the right name in the event.");
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(model.getA().getItem(0).getB().getItem(0).getItem(0).getC().getD(), e.getData().item, "Not the right item in the event.");
        }, "Change event not fired!");
        model.dispose();
      },
      testBubbleEventsArrayLong: function testBubbleEventsArrayLong() {
        this.__data__P_237_1 = {
          a: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1, true); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the event for the first array element


        var self = this;
        this.assertEventFired(model, "changeBubble", function () {
          model.getA().setItem(10, "AFFE");
        }, function (e) {
          self.assertEquals("AFFE", e.getData().value, "Not the right value in the event.");
          self.assertEquals("a[10]", e.getData().name, "Not the right name in the event.");
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(model.getA(), e.getData().item, "Not the right item in the event.");
        }, "Change event not fired!");
        model.dispose();
      },
      testBubbleEventsArrayReorder: function testBubbleEventsArrayReorder() {
        this.__data__P_237_1 = {
          a: [11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        }; // first create the classes before setting the data

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1, true); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1);

        model.getA().sort(); // check the event for the first array element

        var self = this;
        this.assertEventFired(model, "changeBubble", function () {
          model.getA().setItem(0, "AFFE");
        }, function (e) {
          self.assertEquals("AFFE", e.getData().value, "Not the right value in the event.");
          self.assertEquals("a[0]", e.getData().name, "Not the right name in the event.");
          self.assertString(e.getData().name, "name is not a String.");
          self.assertEquals(model.getA(), e.getData().item, "Not the right item in the event.");
        }, "Change event not fired!");
        model.dispose();
      },
      testBubbleEventsWithRemove: function testBubbleEventsWithRemove() {
        qx.Class.define("qx.Test", {
          extend: qx.core.Object,
          include: qx.data.marshal.MEventBubbling,
          properties: {
            fonts: {
              "event": "changeFonts",
              "check": "qx.data.Array",
              "apply": "_applyEventPropagation"
            }
          }
        });
        var model = new qx.Test();
        var fonts = new qx.data.Array();
        model.setFonts(fonts);
        model.getFonts().push("one", "two", "three");
        model.addListener("changeBubble", function (e) {
          this.assertEquals("fonts[0-2]", e.getData().name, "Wrong name");
          this.assertString(e.getData().name, "name is not a String.");
          this.assertArrayEquals(["one", "two", "three"], e.getData().old, "Wrong old data");
          this.assertEquals(0, e.getData().value.length, "Wrong data");
        }, this); // remove all

        model.getFonts().removeAll();
        this.assertEquals(0, model.getFonts().length, "The remove did not work.");
        fonts.dispose();
        model.dispose();
      },
      "test model with and without bubble": function testModelWithAndWithoutBubble() {
        var data = {
          pi: 1
        }; // 1st create explicit *without* changeBubble

        var model1 = qx.data.marshal.Json.createModel(data, false); // 2nd create implicit *without* changeBubble

        var model2 = qx.data.marshal.Json.createModel(data); // 3rd create explicit *with* changeBubble

        var model3 = qx.data.marshal.Json.createModel(data, true); // 4th model is again *without* changeBubble
        //     (should nevertheless result in a model-class *with* changeBubble)

        var model4 = qx.data.marshal.Json.createModel(data, false); // Check whether the above assumptions are correct

        this.assertFalse(qx.util.OOUtil.supportsEvent(model1, "changeBubble"));
        this.assertFalse(qx.util.OOUtil.supportsEvent(model2, "changeBubble"));
        this.assertTrue(qx.util.OOUtil.supportsEvent(model3, "changeBubble"));
        this.assertTrue(qx.util.OOUtil.supportsEvent(model4, "changeBubble")); // Check if bubble event really fires for models 3 & 4

        [model3, model4].forEach(function (model) {
          this.assertEventFired(model, "changeBubble", function () {
            model.setPi(0);
          }, function (e) {
            var data = e.getData();
            this.assertEquals(0, data.value, "Not the right value in the event.");
            this.assertEquals(1, data.old, "Not the right old value in the event.");
            this.assertEquals("pi", data.name, "Not the right name in the event.");
            this.assertEquals(model, data.item, "Not the right item in the event.");
          }.bind(this), "Change event not fired!");
        }, this);
      },
      "test toClass() toModel() match/mismatch": function testToClassToModelMatchMismatch() {
        var data = {
          foo: "foo",
          bar: "bar"
        };
        var marshaler = new qx.data.marshal.Json(); //
        // toClass *without*, toModel *with* should FAIL!
        //

        marshaler.toClass(data, false);
        this.assertException(function () {
          marshaler.toModel(data, true);
        }, Error, "Class 'qx.data.model.bar|foo' found, but it does not support changeBubble event."); //
        // toClass *with*, toModel *without* should work
        //

        marshaler.toClass(data, true);
        marshaler.toModel(data, false); //
        // "auto"
        //

        var data2 = {
          foo2: "foo",
          bar2: "bar"
        };
        marshaler.toClass(data2); // implicit *without* (auto)

        marshaler.toModel(data2);
        marshaler.toModel(data2, false);
        this.assertException(function () {
          marshaler.toModel(data2, true);
        }, Error, "Class 'qx.data.model.bar2|foo2' found, but it does not support changeBubble event.");
      },
      testAddValidationRule: function testAddValidationRule() {
        var propertiesSaved;

        var valN = function valN(data) {
          if (data < 10) {
            throw new qx.core.ValidationError("NNN");
          }
        };

        var valS = function valS(data) {
          if (data.length > 10) {
            throw new qx.core.ValidationError("SSS");
          }
        };

        var delegate = {
          getValidationRule: function getValidationRule(properties, propertyName) {
            if (propertyName == "n") {
              return valN;
            } else if (propertyName == "s") {
              return valS;
            }

            propertiesSaved = properties;
          }
        };

        this.__marshaler__P_237_0.dispose();

        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1);

        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check for the right class hash


        this.assertEquals('b|n|s', propertiesSaved); // set working values

        model.setS("123456789");
        model.setN(20); // set not working values

        this.assertException(function () {
          model.setS("01234567890123456789");
        }, qx.core.ValidationError);
        this.assertException(function () {
          model.setN(1);
        }, qx.core.ValidationError);
        model.dispose();
      },
      testCustomValidator: function testCustomValidator() {
        var delegate = {
          getJsonHash: function getJsonHash(data, includeBubbleEvents) {
            return Object.keys(data).sort().map(function (name) {
              return qx.lang.String.firstUp(name);
            }).join('') + (includeBubbleEvents === true ? '#' : '');
          }
        };

        this.__marshaler__P_237_0.dispose();

        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);

        this.__marshaler__P_237_0.toClass({
          custom: 1,
          props: true
        });

        this.assertTrue(qx.Class.isDefined('qx.data.model.CustomProps'), "Class not created.");
      },
      testQooxdooObject: function testQooxdooObject() {
        var qxObject = new qx.core.Object();
        this.__data__P_237_1 = {
          a: {
            b: qxObject
          }
        };

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1); // set the data


        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1); // check the model


        this.assertEquals(qxObject, model.getA().getB(), "wrong qx object!");
        model.dispose();
      },
      testDisposeListModel: function testDisposeListModel() {
        var model = qx.data.marshal.Json.createModel([{
          name: "a"
        }]);
        var item = model.getItem(0);
        model.dispose();
        this.assertTrue(item.isDisposed());
      },
      testValidIdentifier: function testValidIdentifier() {
        // its a debug warning so only check on debug
        {
          var data = {
            "#affe": 1
          };
          this.assertException(function () {
            // just check if the creation worked
            qx.data.marshal.Json.createModel(data).dispose();
          }, null, "The key '#affe' is not a valid JavaScript identifier.", "1");
          data = {
            "1": 1,
            "true": false
          }; // just check if the creation worked

          qx.data.marshal.Json.createModel(data).dispose();
          data = {
            "''''": 1
          };
          this.assertException(function () {
            // just check if the creation worked
            qx.data.marshal.Json.createModel(data).dispose();
          }, null, "The key '''''' is not a valid JavaScript identifier.", "3");
          data = {
            "§AFFE": 1
          };
          this.assertException(function () {
            // just check if the creation worked
            qx.data.marshal.Json.createModel(data).dispose();
          }, null, "The key '§AFFE' is not a valid JavaScript identifier.", "4");
          data = {
            "ja!": 1
          };
          this.assertException(function () {
            // just check if the creation worked
            qx.data.marshal.Json.createModel(data).dispose();
          }, null, "The key 'ja!' is not a valid JavaScript identifier.", "5");
        }
      },

      /**
       * @ignore(qx.test.model)
       */
      testGetModelClass: function testGetModelClass() {
        qx.Class.define("qx.test.model.C", {
          extend: qx.core.Object,
          properties: {
            s: {
              event: "s"
            },
            b: {
              event: "b"
            },
            n: {
              event: "n"
            }
          }
        });
        var self = this;
        var delegate = {
          getModelClass: function getModelClass(properties) {
            self.assertEquals('b|n|s', properties);
            return qx.test.model.C;
          }
        };

        this.__marshaler__P_237_0.dispose();

        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1);

        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1);

        this.assertTrue(model instanceof qx.test.model.C);
        this.assertEquals("String", model.getS());
        this.assertEquals(12, model.getN());
        this.assertTrue(model.getB());
        model.dispose();
        qx.Class.undefine("qx.test.model.C");
      },
      testGetModelClassDepth: function testGetModelClassDepth() {
        var called = 0;
        var delegate = {
          getModelClass: function (properties, object, parentProperty, depth) {
            called++;

            if (properties == "a") {
              this.assertEquals(data, object);
              this.assertNull(parentProperty);
              this.assertEquals(0, depth);
            } else if (properties == "b") {
              this.assertEquals(data.a, object);
              this.assertEquals("a", parentProperty);
              this.assertEquals(1, depth);
            } else if (properties == "c") {
              this.assertEquals(data.a.b[0], object);
              this.assertEquals("b[0]", parentProperty);
              this.assertEquals(3, depth);
            } else {
              this.fail("Unknown property in the marshaler.");
            }
          }.bind(this)
        };

        this.__marshaler__P_237_0.dispose();

        var data = {
          a: {
            b: [{
              c: 1
            }]
          }
        };
        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);

        this.__marshaler__P_237_0.toClass(data);

        this.assertEquals(3, called);

        var model = this.__marshaler__P_237_0.toModel(data);

        this.assertEquals(6, called);
        model.dispose();
      },
      testGetModelClassIgnore: function testGetModelClassIgnore() {
        qx.Class.define("qx.test.model.C", {
          extend: qx.core.Object,
          properties: {
            b: {
              event: "b"
            }
          }
        });
        var self = this;
        var delegate = {
          getModelClass: function getModelClass(properties) {
            self.assertEquals('b|n|s', properties);
            return qx.test.model.C;
          }
        };

        this.__marshaler__P_237_0.dispose();

        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1);

        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1);

        this.assertTrue(model instanceof qx.test.model.C);
        this.assertUndefined(model.getS);
        this.assertUndefined(model.getN);
        this.assertTrue(model.getB());
        model.dispose();
        qx.Class.undefine("qx.test.model.C");
      },
      testGetModelSuperClass: function testGetModelSuperClass() {
        var called = 0;
        var delegate = {
          getModelSuperClass: function (properties, parentProperty, depth) {
            called++;

            if (properties == "a") {
              this.assertNull(parentProperty);
              this.assertEquals(0, depth);
            } else if (properties == "b") {
              this.assertEquals("a", parentProperty);
              this.assertEquals(1, depth);
            } else if (properties == "c") {
              this.assertEquals("b[0]", parentProperty);
              this.assertEquals(3, depth);
            } else {
              this.fail("Unknown property in the marshaler.");
            }
          }.bind(this)
        };

        this.__marshaler__P_237_0.dispose();

        var data = {
          a: {
            b: [{
              c: 1
            }]
          }
        };
        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);

        this.__marshaler__P_237_0.toClass(data);

        this.assertEquals(3, called);
      },
      testGetModelMixins: function testGetModelMixins() {
        var called = 0;
        var delegate = {
          getModelMixins: function (properties, parentProperty, depth) {
            called++;

            if (properties == "a") {
              this.assertNull(parentProperty);
              this.assertEquals(0, depth);
            } else if (properties == "b") {
              this.assertEquals("a", parentProperty);
              this.assertEquals(1, depth);
            } else if (properties == "c") {
              this.assertEquals("b[0]", parentProperty);
              this.assertEquals(3, depth);
            } else {
              this.fail("Unknown property in the marshaler.");
            }
          }.bind(this)
        };

        this.__marshaler__P_237_0.dispose();

        var data = {
          a: {
            b: [{
              c: 1
            }]
          }
        };
        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);

        this.__marshaler__P_237_0.toClass(data);

        this.assertEquals(3, called);
      },
      testGetPropertyMapping: function testGetPropertyMapping() {
        var delegate = {
          getPropertyMapping: function getPropertyMapping(property, properties) {
            return property + property + property;
          }
        };

        this.__marshaler__P_237_0.dispose();

        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);

        this.__marshaler__P_237_0.toClass(this.__data__P_237_1);

        var model = this.__marshaler__P_237_0.toModel(this.__data__P_237_1);

        this.assertEquals("String", model.getSss());
        this.assertEquals(12, model.getNnn());
        this.assertTrue(model.getBbb());
        model.dispose();
      },
      testIgnoreParent: function testIgnoreParent() {
        var called = 0;
        var delegate = {
          ignore: function (properties, parentProperty, depth) {
            called++;

            if (properties == "a") {
              this.assertNull(parentProperty);
              this.assertEquals(0, depth);
            } else if (properties == "b") {
              this.assertEquals("a", parentProperty);
              this.assertEquals(1, depth);
            } else if (properties == "c") {
              this.assertEquals("b[0]", parentProperty);
              this.assertEquals(3, depth);
            } else {
              this.fail("Unknown property in the marshaler.");
            }
          }.bind(this)
        };

        this.__marshaler__P_237_0.dispose();

        var data = {
          a: {
            b: [{
              c: 1
            }]
          }
        };
        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);

        this.__marshaler__P_237_0.toClass(data);

        this.assertEquals(3, called);
      },
      testIgnoreDepth: function testIgnoreDepth() {
        var delegate = {
          ignore: function ignore(properties, parentProperty, depth) {
            return depth >= 1;
          }
        };

        this.__marshaler__P_237_0.dispose();

        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);
        var data = {
          a: [0],
          b: {
            x: 1
          },
          c: {
            y: 2
          }
        };

        this.__marshaler__P_237_0.toClass(data);

        var model = this.__marshaler__P_237_0.toModel(data);

        this.assertEquals(0, model.getA()[0]);
        this.assertEquals(1, model.getB().x);
        this.assertEquals(2, model.getC().y);
        model.dispose();
      },
      testIgnoreProperties: function testIgnoreProperties() {
        var delegate = {
          ignore: function ignore(properties, parentProperty, depth) {
            return properties == "x";
          }
        };

        this.__marshaler__P_237_0.dispose();

        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);
        var data = {
          a: [],
          b: {
            x: 1
          },
          c: {
            y: 2
          }
        };

        this.__marshaler__P_237_0.toClass(data);

        var model = this.__marshaler__P_237_0.toModel(data);

        this.assertInstance(model.getA(), qx.data.Array);
        this.assertEquals(1, model.getB().x);
        this.assertInstance(model.getC(), qx.core.Object);
        this.assertEquals(2, model.getC().getY());
        model.dispose();
      },
      testBubbleSpliceRemoveAndAdd: function testBubbleSpliceRemoveAndAdd() {
        var data = [{
          label: "Desktop"
        }];
        var model = qx.data.marshal.Json.createModel(data, true);
        var spy = this.spy();
        model.addListener("changeBubble", spy);
        model.splice(1, 1, model.getItem(0));
        this.assertCalledOnce(spy);
        model.getItem(0).setLabel("pistole");
        this.assertCalledTwice(spy);
      },
      testGetArrayClassSimple: function testGetArrayClassSimple() {
        qx.Class.define("qx.test.Array", {
          extend: qx.data.Array
        });
        var delegate = {
          getArrayClass: function (parentProperty, depth) {
            this.assertNull(parentProperty);
            this.assertEquals(0, depth, "'depth' property is wrong");
            return qx.test.Array;
          }.bind(this)
        };

        this.__marshaler__P_237_0.dispose();

        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);
        var data = ["a", "b"];

        this.__marshaler__P_237_0.toClass(data);

        var model = this.__marshaler__P_237_0.toModel(data);

        this.assertInstance(model, qx.test.Array);
        model.dispose();
        qx.Class.undefine("qx.test.Array");
      },
      testGetArrayClassAdvanced: function testGetArrayClassAdvanced() {
        qx.Class.define("qx.test.Array", {
          extend: qx.data.Array
        });
        var called = 0;
        var delegate = {
          getArrayClass: function (parentProperty, depth) {
            called++;

            if (parentProperty == "a") {
              this.assertEquals(1, depth, "'depth' property is wrong");
              return null;
            } else if (parentProperty == "b") {
              this.assertEquals(1, depth, "'depth' property is wrong");
              return qx.test.Array;
            } else if (parentProperty == "e") {
              this.assertEquals(2, depth, "'depth' property is wrong");
              return qx.test.Array;
            } else if (parentProperty == "f") {
              this.assertEquals(2, depth, "'depth' property is wrong");
              return null;
            } else {
              this.fail("Unknown 'parentProperty' in the marshaler.");
            }
          }.bind(this)
        };

        this.__marshaler__P_237_0.dispose();

        this.__marshaler__P_237_0 = new qx.data.marshal.Json(delegate);
        var data = {
          a: [],
          b: [],
          c: {
            d: "d",
            e: [],
            f: []
          }
        };

        this.__marshaler__P_237_0.toClass(data);

        var model = this.__marshaler__P_237_0.toModel(data);

        this.assertInstance(model.getA(), qx.data.Array);
        this.assertInstance(model.getB(), qx.test.Array);
        this.assertInstance(model.getC().getE(), qx.test.Array);
        this.assertInstance(model.getC().getF(), qx.data.Array);
        this.assertEquals(4, called);
        model.dispose();
        qx.Class.undefine("qx.test.Array");
      }
    }
  });
  qx.test.data.marshal.Json.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "construct": true,
        "require": true
      },
      "qx.core.Object": {},
      "qx.data.Array": {
        "construct": true
      },
      "qx.test.data.singlevalue.TextFieldDummy": {},
      "qx.data.SingleValueBinding": {},
      "qx.log.Logger": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.data.singlevalue.Array_MultiBinding)
   */

  /**
   * Test-Class for testing the single value binding
   */
  qx.Class.define("qx.test.data.singlevalue.Array", {
    extend: qx.dev.unit.TestCase,
    construct: function construct() {
      qx.dev.unit.TestCase.constructor.call(this); // define a test class

      qx.Class.define("qx.test.data.singlevalue.Array_MultiBinding", {
        extend: qx.core.Object,
        construct: function construct() {
          this.setArray(new qx.data.Array(["one", "two", "three"]));
        },
        destruct: function destruct() {
          this.getArray().dispose();
          var children = this.getChildren();

          if (children != null) {
            children.dispose();
          }
        },
        properties: {
          child: {
            check: "qx.test.data.singlevalue.Array_MultiBinding",
            event: "changeChild",
            nullable: true
          },
          children: {
            check: "qx.data.Array",
            event: "changeChildren",
            nullable: true,
            init: null
          },
          name: {
            check: "String",
            event: "changeName",
            nullable: true
          },
          array: {
            init: null,
            event: "changeArray"
          }
        }
      });
    },
    members: {
      __a__P_238_0: null,
      __b1__P_238_1: null,
      __b2__P_238_2: null,
      __label__P_238_3: null,
      setUp: function setUp() {
        this.__a__P_238_0 = new qx.test.data.singlevalue.Array_MultiBinding().set({
          name: "a",
          children: new qx.data.Array()
        });
        this.__b1__P_238_1 = new qx.test.data.singlevalue.Array_MultiBinding().set({
          name: "b1",
          children: new qx.data.Array()
        });
        this.__b2__P_238_2 = new qx.test.data.singlevalue.Array_MultiBinding().set({
          name: "b2",
          children: new qx.data.Array()
        });
        this.__label__P_238_3 = new qx.test.data.singlevalue.TextFieldDummy(); // remove all bindings

        qx.data.SingleValueBinding.removeAllBindings();
      },
      tearDown: function tearDown() {
        this.__b1__P_238_1.dispose();

        this.__b2__P_238_2.dispose();

        this.__a__P_238_0.dispose();

        this.__label__P_238_3.dispose();
      },
      testChangeItem: function testChangeItem() {
        // bind the first element of the array
        qx.data.SingleValueBinding.bind(this.__a__P_238_0, "array[0]", this.__label__P_238_3, "value"); // check the binding

        this.assertEquals("one", this.__label__P_238_3.getValue(), "Array[0] binding does not work!"); // change the value

        this.__a__P_238_0.getArray().setItem(0, "ONE");

        this.assertEquals("ONE", this.__label__P_238_3.getValue(), "Array[0] binding does not work!");
      },
      testChangeArray: function testChangeArray() {
        // bind the first element of the array
        qx.data.SingleValueBinding.bind(this.__a__P_238_0, "array[0]", this.__label__P_238_3, "value"); // change the array itself

        this.__a__P_238_0.getArray().dispose();

        this.__a__P_238_0.setArray(new qx.data.Array(1, 2, 3));

        qx.log.Logger.debug(this.__a__P_238_0.getArray().getItem(0)); // check the binding

        this.assertEquals("1", this.__label__P_238_3.getValue(), "Changing the array does not work!");
      },
      testLast: function testLast() {
        // bind the last element
        qx.data.SingleValueBinding.bind(this.__a__P_238_0, "array[last]", this.__label__P_238_3, "value"); // check the binding

        this.assertEquals("three", this.__label__P_238_3.getValue(), "Array[last] binding does not work!"); // change the value

        this.__a__P_238_0.getArray().setItem(2, "THREE");

        this.assertEquals("THREE", this.__label__P_238_3.getValue(), "Array[last] binding does not work!");
      },
      testPushPop: function testPushPop() {
        // bind the last element
        qx.data.SingleValueBinding.bind(this.__a__P_238_0, "array[last]", this.__label__P_238_3, "value"); // check the binding

        this.assertEquals("three", this.__label__P_238_3.getValue(), "Array[last] binding does not work!"); // pop the last element

        this.__a__P_238_0.getArray().pop(); // check the binding


        this.assertEquals("two", this.__label__P_238_3.getValue(), "Array[last] binding does not work!"); // push a new element to the end

        this.__a__P_238_0.getArray().push("new"); // check the binding


        this.assertEquals("new", this.__label__P_238_3.getValue(), "Array[last] binding does not work!");
      },
      testShiftUnshift: function testShiftUnshift() {
        // bind the last element
        qx.data.SingleValueBinding.bind(this.__a__P_238_0, "array[0]", this.__label__P_238_3, "value"); // check the binding

        this.assertEquals("one", this.__label__P_238_3.getValue(), "Array[last] binding does not work!"); // pop the last element

        this.__a__P_238_0.getArray().shift(); // check the binding


        this.assertEquals("two", this.__label__P_238_3.getValue(), "Array[last] binding does not work!"); // push a new element to the end

        this.__a__P_238_0.getArray().unshift("new"); // check the binding


        this.assertEquals("new", this.__label__P_238_3.getValue(), "Array[last] binding does not work!");
      },
      testChildArray: function testChildArray() {
        // create the objects
        this.__a__P_238_0.setChild(this.__b1__P_238_1);

        this.__b1__P_238_1.getArray().dispose();

        this.__b1__P_238_1.setArray(new qx.data.Array("eins", "zwei", "drei"));

        this.__b2__P_238_2.getArray().dispose();

        this.__b2__P_238_2.setArray(new qx.data.Array("1", "2", "3")); // bind the last element


        qx.data.SingleValueBinding.bind(this.__a__P_238_0, "child.array[0]", this.__label__P_238_3, "value"); // check the binding

        this.assertEquals("eins", this.__label__P_238_3.getValue(), "child.array[0] binding does not work!"); // change the child

        this.__a__P_238_0.setChild(this.__b2__P_238_2); // check the binding


        this.assertEquals("1", this.__label__P_238_3.getValue(), "child.array[0] binding does not work!");

        this.__b1__P_238_1.getArray().dispose();

        this.__b2__P_238_2.getArray().dispose();
      },
      testChildren: function testChildren() {
        // create the objects
        this.__a__P_238_0.getChildren().push(this.__b1__P_238_1);

        this.__a__P_238_0.getChildren().push(this.__b2__P_238_2); // bind the element


        qx.data.SingleValueBinding.bind(this.__a__P_238_0, "children[0].name", this.__label__P_238_3, "value"); // check the binding

        this.assertEquals("b1", this.__label__P_238_3.getValue(), "children[0].name binding does not work!"); // remove the first element

        this.__a__P_238_0.getChildren().shift(); // check the binding


        this.assertEquals("b2", this.__label__P_238_3.getValue(), "children[0].name binding does not work!"); // change the name of b2

        this.__b2__P_238_2.setName("AFFE"); // check the binding


        this.assertEquals("AFFE", this.__label__P_238_3.getValue(), "children[0].name binding does not work!");
      },
      test2Arrays: function test2Arrays() {
        // create the objects
        this.__a__P_238_0.getChildren().push(this.__b1__P_238_1);

        this.__b1__P_238_1.getChildren().push(this.__b2__P_238_2); // bind the element


        qx.data.SingleValueBinding.bind(this.__a__P_238_0, "children[0].children[0].name", this.__label__P_238_3, "value"); // check the binding

        this.assertEquals("b2", this.__label__P_238_3.getValue(), "children[0].children[0].name binding does not work!"); // rename the last element

        this.__b2__P_238_2.setName("OHJE"); // check the binding


        this.assertEquals("OHJE", this.__label__P_238_3.getValue(), "children[0].name binding does not work!");
      },
      testSplice: function testSplice() {
        // bind the first element
        qx.data.SingleValueBinding.bind(this.__a__P_238_0, "array[0]", this.__label__P_238_3, "value"); // remove the first and add "eins" at position 0

        var array = this.__a__P_238_0.getArray().splice(0, 1, "eins"); // check the binding


        this.assertEquals("eins", this.__label__P_238_3.getValue(), "Array[last] binding does not work!");
        array.dispose();
      },
      testWrongInput: function testWrongInput() {
        var a = this.__a__P_238_0;
        var label = this.__label__P_238_3; // bind a senseless value

        this.assertException(function () {
          qx.data.SingleValueBinding.bind(a, "array[affe]", label, "value");
        }, Error, null, "Affe not an array value."); // bind empty array

        this.assertException(function () {
          qx.data.SingleValueBinding.bind(a, "array[]", label, "value");
        }, Error, null, "'' not an array value."); // bind 2 arrays

        this.assertException(function () {
          qx.data.SingleValueBinding.bind(a, "array[0][0]", label, "value");
        }, Error, null, "array[][] not an array value."); // bind an float

        this.assertException(function () {
          qx.data.SingleValueBinding.bind(a, "array[1.5]", label, "value");
        }, Error, null, "1.5 not an array value."); // bind strange value

        this.assertException(function () {
          qx.data.SingleValueBinding.bind(a, "array[[affe]]", label, "value");
        }, Error, null, "'[[affe]]' not an array value."); // test map in array

        this.assertException(function () {
          qx.data.SingleValueBinding.bind(a, "array[{name: 'a'}]", label, "value");
        }, Error, null, "'[affe]' not an array value."); // test null in the array

        this.assertException(function () {
          qx.data.SingleValueBinding.bind(a, "array[null]", label, "value");
        }, Error, null, "'null' not an array value.");
      },
      testLateBinding: function testLateBinding() {
        // create the precondition
        this.__a__P_238_0.getArray().dispose();

        this.__a__P_238_0.setArray(new qx.data.Array()); // bind the last element


        qx.data.SingleValueBinding.bind(this.__a__P_238_0, "array[last]", this.__label__P_238_3, "value"); // check the binding

        this.assertNull(this.__label__P_238_3.getValue(), "Late binding does not work!"); // set a value and check it

        this.__a__P_238_0.getArray().push("1");

        this.assertEquals("1", this.__label__P_238_3.getValue(), "Late binding does not work!"); // set another value and check it

        this.__a__P_238_0.getArray().push("2");

        this.assertEquals("2", this.__label__P_238_3.getValue(), "Late binding does not work!");
      },
      testRemoveArrayItem: function testRemoveArrayItem() {
        // bind the last element
        qx.data.SingleValueBinding.bind(this.__a__P_238_0, "array[last]", this.__label__P_238_3, "value"); // check the binding

        this.assertEquals("three", this.__label__P_238_3.getValue(), "Array[last] binding does not work!"); // pop all 3 elements

        this.__a__P_238_0.getArray().pop();

        this.__a__P_238_0.getArray().pop();

        this.__a__P_238_0.getArray().pop(); // check the binding


        this.assertNull(this.__label__P_238_3.getValue(), "Array[last] binding does not work!");
      },
      testBidirectional: function testBidirectional() {
        // two way binding
        // model.name <-- bind --> model.child.array[0]
        // create model: model.child.array
        var model = new qx.test.data.singlevalue.Array_MultiBinding();
        model.setChild(new qx.test.data.singlevalue.Array_MultiBinding()); // set up the two way binding

        model.bind("name", model, "child.array[0]");
        model.bind("child.array[0]", model, "name"); // set the value of the textfield

        model.setName("affe");
        this.assertEquals("affe", model.getChild().getArray().getItem(0), "affe not set in the model array."); // set the value in the model

        model.getChild().getArray().setItem(0, "stadtaffe");
        this.assertEquals("stadtaffe", model.getName(), "stadtaffe not set in the model."); // set the models name to null

        model.setName(null);
        this.assertEquals(null, model.getChild().getArray().getItem(0), "model array not reseted to initial."); // set the model array item to null

        model.getChild().getArray().setItem(0, null);
        this.assertEquals(null, model.getName(), "model not reseted.");
        model.getChild().dispose();
        model.dispose();
      },
      testDirect: function testDirect() {
        // bind the first element of the array
        qx.data.SingleValueBinding.bind(this.__a__P_238_0.getArray(), "[0]", this.__label__P_238_3, "value"); // check the binding

        this.assertEquals("one", this.__label__P_238_3.getValue(), "[0] binding does not work!"); // change the value

        this.__a__P_238_0.getArray().setItem(0, "ONE");

        this.assertEquals("ONE", this.__label__P_238_3.getValue(), "[0] binding does not work!");
      },
      testDirectTarget: function testDirectTarget() {
        this.__label__P_238_3.setValue("affe"); // bind the first element of the array


        qx.data.SingleValueBinding.bind(this.__label__P_238_3, "value", this.__a__P_238_0.getArray(), "[0]"); // check the binding

        this.assertEquals("affe", this.__a__P_238_0.getArray().getItem(0), "[0] binding does not work!"); // change the value

        this.__label__P_238_3.setValue("AFFE");

        this.assertEquals("AFFE", this.__a__P_238_0.getArray().getItem(0), "[0] binding does not work!");
      },
      testChildrenDirect: function testChildrenDirect() {
        // create the objects
        this.__a__P_238_0.getChildren().push(this.__b1__P_238_1);

        this.__a__P_238_0.getChildren().push(this.__b2__P_238_2); // bind the element


        qx.data.SingleValueBinding.bind(this.__a__P_238_0.getChildren(), "[0].name", this.__label__P_238_3, "value"); // check the binding

        this.assertEquals("b1", this.__label__P_238_3.getValue(), "[0].name binding does not work!"); // remove the first element

        this.__a__P_238_0.getChildren().shift(); // check the binding


        this.assertEquals("b2", this.__label__P_238_3.getValue(), "[0].name binding does not work!"); // change the name of b2

        this.__b2__P_238_2.setName("AFFE"); // check the binding


        this.assertEquals("AFFE", this.__label__P_238_3.getValue(), "[0].name binding does not work!");
      },
      testTargetChildren: function testTargetChildren() {
        // create the objects
        this.__a__P_238_0.getChildren().push(this.__b1__P_238_1);

        this.__a__P_238_0.getChildren().push(this.__b2__P_238_2); // bind the element


        this.__label__P_238_3.setValue("l");

        qx.data.SingleValueBinding.bind(this.__label__P_238_3, "value", this.__a__P_238_0.getChildren(), "[0].name"); // check the binding

        this.assertEquals("l", this.__a__P_238_0.getChildren().getItem(0).getName(), "[0].name binding does not work!"); // remove the first element

        this.__a__P_238_0.getChildren().shift(); // check the binding


        this.assertEquals("l", this.__a__P_238_0.getChildren().getItem(0).getName(), "[0].name binding does not work!");
      }
    }
  });
  qx.test.data.singlevalue.Array.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.data.singlevalue.TextFieldDummy", {
    extend: qx.core.Object,
    construct: function construct(value) {
      qx.core.Object.constructor.call(this);

      if (value != null) {
        this.setValue(value);
      }
    },
    properties: {
      appearance: {
        check: "String",
        event: "changeAppearance",
        init: ""
      },
      enabled: {
        check: "Boolean",
        event: "changeEnabled",
        init: true
      },
      zIndex: {
        check: "Integer",
        event: "changeZIndex",
        nullable: true
      },
      floatt: {
        event: "changeFloatt"
      },
      value: {
        check: "String",
        event: "changeValue",
        nullable: true
      },
      backgroundColor: {
        check: "String",
        event: "changeBackgroundColor",
        init: ""
      }
    }
  });
  qx.test.data.singlevalue.TextFieldDummy.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "construct": true,
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.core.Object": {},
      "qx.test.data.singlevalue.TextFieldDummy": {},
      "qx.data.Array": {},
      "qx.data.SingleValueBinding": {},
      "qx.data.marshal.Json": {},
      "qx.core.AssertionError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Test-Class for testing the single value binding
   *
   * @ignore(qx.test.MultiBinding)
   */
  qx.Class.define("qx.test.data.singlevalue.Deep", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock],
    construct: function construct() {
      qx.dev.unit.TestCase.constructor.call(this); // define a test class

      qx.Class.define("qx.test.MultiBinding", {
        extend: qx.core.Object,
        properties: {
          child: {
            check: "qx.test.MultiBinding",
            event: "changeChild",
            nullable: true
          },
          childWithout: {
            check: "qx.test.MultiBinding",
            nullable: true
          },
          name: {
            check: "String",
            nullable: true,
            init: "Juhu",
            event: "changeName"
          },
          array: {
            init: null,
            event: "changeArray"
          },
          lab: {
            event: "changeLable"
          }
        },
        destruct: function destruct() {
          if (this.getLab()) {
            this.getLab().dispose();
          }

          if (this.getArray()) {
            this.getArray().dispose();
          }
        }
      });
    },
    members: {
      __a__P_239_0: null,
      __b1__P_239_1: null,
      __b2__P_239_2: null,
      __label__P_239_3: null,
      setUp: function setUp() {
        this.__a__P_239_0 = new qx.test.MultiBinding().set({
          name: "a",
          lab: new qx.test.data.singlevalue.TextFieldDummy(""),
          array: new qx.data.Array(["one", "two", "three"])
        });
        this.__b1__P_239_1 = new qx.test.MultiBinding().set({
          name: "b1",
          lab: new qx.test.data.singlevalue.TextFieldDummy(""),
          array: new qx.data.Array(["one", "two", "three"])
        });
        this.__b2__P_239_2 = new qx.test.MultiBinding().set({
          name: "b2",
          lab: new qx.test.data.singlevalue.TextFieldDummy(""),
          array: new qx.data.Array(["one", "two", "three"])
        });
        this.__label__P_239_3 = new qx.test.data.singlevalue.TextFieldDummy(); // remove all bindings

        qx.data.SingleValueBinding.removeAllBindings();
      },
      tearDown: function tearDown() {
        this.__b1__P_239_1.dispose();

        this.__b2__P_239_2.dispose();

        this.__a__P_239_0.dispose();

        this.__label__P_239_3.dispose();
      },
      testConverterChainBroken: function testConverterChainBroken() {
        var m = qx.data.marshal.Json.createModel({
          a: {
            a: 1
          },
          b: 2
        });
        var called = 0;
        m.bind("a.a", m, "b", {
          converter: function converter(data) {
            called++;
            return 3;
          }
        }); // check the init values

        this.assertEquals(1, called);
        this.assertEquals(3, m.getB()); // set the binding leaf to null

        m.getA().setA(null);
        this.assertEquals(2, called);
        this.assertEquals(3, m.getB()); // set the binding root to null

        m.setA(null);
        this.assertEquals(3, called);
        this.assertEquals(3, m.getB());
        m.dispose();
      },
      testConverterChainBrokenInitialNull: function testConverterChainBrokenInitialNull() {
        var m = qx.data.marshal.Json.createModel({
          a: null
        });
        var t = qx.data.marshal.Json.createModel({
          a: null
        });
        var spy = this.spy(function () {
          return 123;
        });
        m.bind("a.b", t, "a", {
          converter: spy
        });
        this.assertCalledOnce(spy);
        this.assertCalledWith(spy, undefined, undefined, m, t);
        this.assertEquals(123, t.getA());
        m.dispose();
        t.dispose();
      },
      testDepthOf2: function testDepthOf2() {
        // create a hierarchy
        // a --> b1
        this.__a__P_239_0.setChild(this.__b1__P_239_1); // create the binding
        // a --> b1 --> label


        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "child.name", this.__label__P_239_3, "value"); // just set the name of the second component

        this.__b1__P_239_1.setName("B1");

        this.assertEquals("B1", this.__label__P_239_3.getValue(), "Deep binding does not work with updating the first parameter."); // change the second component
        // a --> b2 --> label

        this.__a__P_239_0.setChild(this.__b2__P_239_2);

        this.assertEquals("b2", this.__label__P_239_3.getValue(), "Deep binding does not work with updating the first parameter."); // check for the null value
        // a --> null

        this.__a__P_239_0.setChild(null);

        this.assertNull(this.__label__P_239_3.getValue(), "Binding does not work with null.");
      },
      testDepthOf3: function testDepthOf3(attribute) {
        // create a hierarchy
        var c1 = new qx.test.MultiBinding().set({
          name: "c1"
        });
        var c2 = new qx.test.MultiBinding().set({
          name: "c2"
        }); // a --> b1 --> c1 --> label
        //       b2 --> c2

        this.__a__P_239_0.setChild(this.__b1__P_239_1);

        this.__b1__P_239_1.setChild(c1);

        this.__b2__P_239_2.setChild(c2); // create the binding


        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "child.child.name", this.__label__P_239_3, "value"); // just set the name of the last component

        c1.setName("C1");
        this.assertEquals("C1", this.__label__P_239_3.getValue(), "Deep binding does not work with updating the third parameter."); // change the middle child
        // a --> b2 --> c2 --> label

        this.__a__P_239_0.setChild(this.__b2__P_239_2);

        this.assertEquals("c2", this.__label__P_239_3.getValue(), "Deep binding does not work with updating the second parameter."); // set the middle child to null
        // a --> null

        this.__a__P_239_0.setChild(null);

        this.assertNull(this.__label__P_239_3.getValue(), "Deep binding does not work with first null child."); // set only two childs
        // a --> b1 --> null

        this.__b1__P_239_1.setChild(null);

        this.__a__P_239_0.setChild(this.__b1__P_239_1);

        this.assertNull(this.__label__P_239_3.getValue(), "Deep binding does not work with second null child."); // set the childs in a row
        // a --> b1 --> c1 --> label

        this.__b1__P_239_1.setChild(c1);

        this.assertEquals("C1", this.__label__P_239_3.getValue(), "Deep binding does not work with updating the third parameter.");
      },
      testDepthOf5: function testDepthOf5(attribute) {
        // create a hierarchy
        var c = new qx.test.MultiBinding().set({
          name: "c"
        });
        var d = new qx.test.MultiBinding().set({
          name: "d"
        });
        var e = new qx.test.MultiBinding().set({
          name: "e"
        }); // a --> b1 --> c --> d --> e --> label

        this.__a__P_239_0.setChild(this.__b1__P_239_1);

        this.__b1__P_239_1.setChild(c);

        c.setChild(d);
        d.setChild(e); // create the binding

        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "child.child.child.child.name", this.__label__P_239_3, "value"); // test if the binding did work

        this.assertEquals("e", this.__label__P_239_3.getValue(), "Deep binding does not work with updating the third parameter.");
      },
      testWrongDeep: function testWrongDeep() {
        // create a hierarchy
        this.__a__P_239_0.setChild(this.__b1__P_239_1);

        var a = this.__a__P_239_0;
        var label = this.__label__P_239_3; // only in source version

        {
          // set a wrong first parameter in the chain
          this.assertException(function () {
            qx.data.SingleValueBinding.bind(a, "chiild.name", label, "value");
          }, qx.core.AssertionError, null, "Wrong property name."); // set a complete wrong chain

          this.assertException(function () {
            qx.data.SingleValueBinding.bind(a, "affe", label, "value");
          }, qx.core.AssertionError, null, "Wrong property name.");
        }
      },
      testSingle: function testSingle() {
        // set only one property in the chain
        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "name", this.__label__P_239_3, "value"); // chech the initial value

        this.assertEquals("a", this.__label__P_239_3.getValue(), "Single property names don't work!"); // check the binding

        this.__a__P_239_0.setName("A");

        this.assertEquals("A", this.__label__P_239_3.getValue(), "Single property names don't work!");
      },
      testDebug: function testDebug(attribute) {
        // build the structure
        this.__a__P_239_0.setChild(this.__b1__P_239_1); // bind the stuff together


        var id = qx.data.SingleValueBinding.bind(this.__a__P_239_0, "child.name", this.__label__P_239_3, "value"); // log this binding in the console

        qx.data.SingleValueBinding.showBindingInLog(this.__a__P_239_0, id);
      },
      testRemove: function testRemove() {
        // build the structure
        this.__a__P_239_0.setChild(this.__b1__P_239_1); // bind the stuff together


        var id = qx.data.SingleValueBinding.bind(this.__a__P_239_0, "child.name", this.__label__P_239_3, "value"); // check the binding

        this.__b1__P_239_1.setName("A");

        this.assertEquals("A", this.__label__P_239_3.getValue(), "Single property names don't work!"); // remove the binding

        qx.data.SingleValueBinding.removeBindingFromObject(this.__a__P_239_0, id); // check the binding again

        this.__a__P_239_0.setName("A2");

        this.assertEquals("A", this.__label__P_239_3.getValue(), "Removing does not work!"); // smoke Test for the remove

        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "child.name", this.__label__P_239_3, "value");
        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "child.name", this.__label__P_239_3, "value");
        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "child.name", this.__label__P_239_3, "value");
        qx.data.SingleValueBinding.removeAllBindings();
      },
      testArrayDeep: function testArrayDeep() {
        this.__a__P_239_0.getArray().dispose();

        this.__a__P_239_0.setArray(new qx.data.Array([this.__b1__P_239_1]));

        this.__b1__P_239_1.setChild(this.__b2__P_239_2);

        this.__b2__P_239_2.setChild(this.__b1__P_239_1);

        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "array[0].child.name", this.__label__P_239_3, "value");
        this.assertEquals("b2", this.__label__P_239_3.getValue(), "Deep binding does not work.");

        this.__a__P_239_0.getArray().pop();

        this.assertNull(this.__label__P_239_3.getValue(), "Deep binding does not work.");

        this.__a__P_239_0.getArray().push(this.__b2__P_239_2);

        this.assertEquals("b1", this.__label__P_239_3.getValue(), "Deep binding does not work.");

        this.__b1__P_239_1.setName("B1");

        this.assertEquals("B1", this.__label__P_239_3.getValue(), "Deep binding does not work.");
      },
      testDeepTarget: function testDeepTarget() {
        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "name", this.__b1__P_239_1, "lab.value");
        this.assertEquals("a", this.__b1__P_239_1.getLab().getValue(), "Deep binding on the target does not work.");
      },
      testDeepTarget2: function testDeepTarget2() {
        this.__b2__P_239_2.setChild(this.__b1__P_239_1);

        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "name", this.__b2__P_239_2, "child.lab.value");
        this.assertEquals("a", this.__b1__P_239_1.getLab().getValue(), "Deep binding on the target does not work.");
      },
      testDeepTargetNull: function testDeepTargetNull() {
        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "name", this.__b2__P_239_2, "child.lab.value");
        this.assertEquals("", this.__b1__P_239_1.getLab().getValue(), "Deep binding on the target does not work.");
      },
      testDeepTargetArray: function testDeepTargetArray() {
        this.__a__P_239_0.getArray().dispose();

        this.__a__P_239_0.setArray(new qx.data.Array([this.__b1__P_239_1]));

        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "name", this.__a__P_239_0, "array[0].lab.value");
        this.assertEquals("a", this.__b1__P_239_1.getLab().getValue(), "Deep binding on the target does not work.");
      },
      testDeepTargetArrayLast: function testDeepTargetArrayLast() {
        this.__a__P_239_0.getArray().dispose();

        this.__a__P_239_0.setArray(new qx.data.Array([this.__b1__P_239_1]));

        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "name", this.__a__P_239_0, "array[last].lab.value");
        this.assertEquals("a", this.__b1__P_239_1.getLab().getValue(), "Deep binding on the target does not work.");
      },
      testDeepTargetChange: function testDeepTargetChange() {
        var oldLabel = this.__b1__P_239_1.getLab();

        var newLabel = new qx.test.data.singlevalue.TextFieldDummy("x");
        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "name", this.__b1__P_239_1, "lab.value");

        this.__b1__P_239_1.setLab(newLabel);

        this.assertEquals("a", this.__b1__P_239_1.getLab().getValue());

        this.__a__P_239_0.setName("l");

        this.assertEquals("a", oldLabel.getValue());
        this.assertEquals("l", this.__b1__P_239_1.getLab().getValue());
        newLabel.dispose();
        oldLabel.dispose();
      },
      testDeepTargetChangeConverter: function testDeepTargetChangeConverter() {
        var oldLabel = this.__b1__P_239_1.getLab();

        var newLabel = new qx.test.data.singlevalue.TextFieldDummy("x");
        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "name", this.__b1__P_239_1, "lab.value", {
          converter: function converter(data) {
            return data + "...";
          }
        });

        this.__b1__P_239_1.setLab(newLabel);

        this.assertEquals("a...", this.__b1__P_239_1.getLab().getValue());

        this.__a__P_239_0.setName("l");

        this.assertEquals("a...", oldLabel.getValue());
        this.assertEquals("l...", this.__b1__P_239_1.getLab().getValue());
        newLabel.dispose();
        oldLabel.dispose();
      },
      testDeepTargetChange3: function testDeepTargetChange3() {
        // set up the target chain
        this.__a__P_239_0.setChild(this.__b1__P_239_1);

        this.__b1__P_239_1.setChild(this.__b2__P_239_2);

        this.__b2__P_239_2.setChild(this.__b1__P_239_1);

        qx.data.SingleValueBinding.bind(this.__label__P_239_3, "value", this.__a__P_239_0, "child.child.lab.value"); // check the default set

        this.__label__P_239_3.setValue("123");

        this.assertEquals("123", this.__b2__P_239_2.getLab().getValue()); // change the child of __a

        this.__a__P_239_0.setChild(this.__b2__P_239_2);

        this.assertEquals("123", this.__b1__P_239_1.getLab().getValue()); // set another label value

        this.__label__P_239_3.setValue("456");

        this.assertEquals("123", this.__b2__P_239_2.getLab().getValue());
        this.assertEquals("456", this.__b1__P_239_1.getLab().getValue());
      },
      testDeepTargetChange3Remove: function testDeepTargetChange3Remove() {
        // set up the target chain
        this.__a__P_239_0.setChild(this.__b1__P_239_1);

        this.__b1__P_239_1.setChild(this.__b2__P_239_2);

        this.__b2__P_239_2.setChild(this.__b1__P_239_1);

        var id = qx.data.SingleValueBinding.bind(this.__label__P_239_3, "value", this.__a__P_239_0, "child.child.lab.value"); // check the default set

        this.__label__P_239_3.setValue("123");

        this.assertEquals("123", this.__b2__P_239_2.getLab().getValue(), "0");
        qx.data.SingleValueBinding.removeBindingFromObject(this.__label__P_239_3, id); // change the child of __a

        this.__a__P_239_0.setChild(this.__b2__P_239_2);

        this.assertEquals("", this.__b1__P_239_1.getLab().getValue(), "listener still there"); // set another label value

        this.__label__P_239_3.setValue("456");

        this.assertEquals("123", this.__b2__P_239_2.getLab().getValue(), "1");
        this.assertEquals("", this.__b1__P_239_1.getLab().getValue(), "2");
      },
      testDeepTargetChangeArray: function testDeepTargetChangeArray() {
        qx.data.SingleValueBinding.bind(this.__label__P_239_3, "value", this.__a__P_239_0, "array[0]");

        this.__label__P_239_3.setValue("123");

        this.assertEquals("123", this.__a__P_239_0.getArray().getItem(0));
        var newArray = new qx.data.Array([0, 1, 0]);

        var oldArray = this.__a__P_239_0.getArray();

        this.__a__P_239_0.setArray(newArray);

        this.assertEquals("123", this.__a__P_239_0.getArray().getItem(0), "initial set");

        this.__label__P_239_3.setValue("456");

        this.assertEquals("456", newArray.getItem(0));
        this.assertEquals("123", oldArray.getItem(0));
        oldArray.dispose();
        newArray.dispose();
      },
      testDeepTargetChangeArrayLast: function testDeepTargetChangeArrayLast() {
        qx.data.SingleValueBinding.bind(this.__label__P_239_3, "value", this.__a__P_239_0, "array[last]");

        this.__label__P_239_3.setValue("123");

        this.assertEquals("123", this.__a__P_239_0.getArray().getItem(2));
        var newArray = new qx.data.Array([0, 1, 0]);

        var oldArray = this.__a__P_239_0.getArray();

        this.__a__P_239_0.setArray(newArray);

        this.assertEquals("123", this.__a__P_239_0.getArray().getItem(2), "initial set");

        this.__label__P_239_3.setValue("456");

        this.assertEquals("456", newArray.getItem(2));
        this.assertEquals("123", oldArray.getItem(2));
        oldArray.dispose();
        newArray.dispose();
      },
      testDeepTargetChange3Array: function testDeepTargetChange3Array() {
        // set up the target chain
        this.__a__P_239_0.setChild(this.__b1__P_239_1);

        this.__b1__P_239_1.setChild(this.__b2__P_239_2);

        this.__b2__P_239_2.setChild(this.__b1__P_239_1);

        qx.data.SingleValueBinding.bind(this.__label__P_239_3, "value", this.__a__P_239_0, "child.child.array[0]"); // check the default set

        this.__label__P_239_3.setValue("123");

        this.assertEquals("123", this.__b2__P_239_2.getArray().getItem(0)); // change the child of __a

        this.__a__P_239_0.setChild(this.__b2__P_239_2);

        this.assertEquals("123", this.__b1__P_239_1.getArray().getItem(0)); // set another label value

        this.__label__P_239_3.setValue("456");

        this.assertEquals("456", this.__b1__P_239_1.getArray().getItem(0));
        this.assertEquals("123", this.__b2__P_239_2.getArray().getItem(0), "binding still exists");
      },
      testDeepTargetChangeMiddleArray: function testDeepTargetChangeMiddleArray() {
        var oldArray = this.__a__P_239_0.getArray();

        var array = new qx.data.Array([this.__b1__P_239_1, this.__b2__P_239_2]);

        this.__a__P_239_0.setArray(array);

        oldArray.dispose();
        qx.data.SingleValueBinding.bind(this.__label__P_239_3, "value", this.__a__P_239_0, "array[0].lab.value");

        this.__label__P_239_3.setValue("123");

        this.assertEquals("123", this.__b1__P_239_1.getLab().getValue());
        array.reverse();
        this.assertEquals("123", this.__b2__P_239_2.getLab().getValue());

        this.__label__P_239_3.setValue("456");

        this.assertEquals("456", this.__b2__P_239_2.getLab().getValue());
        this.assertEquals("123", this.__b1__P_239_1.getLab().getValue());
      },
      testDeepTargetChangeMiddleArrayLast: function testDeepTargetChangeMiddleArrayLast() {
        var oldArray = this.__a__P_239_0.getArray();

        var array = new qx.data.Array([this.__b2__P_239_2, this.__b1__P_239_1]);

        this.__a__P_239_0.setArray(array);

        oldArray.dispose();
        qx.data.SingleValueBinding.bind(this.__label__P_239_3, "value", this.__a__P_239_0, "array[last].lab.value");

        this.__label__P_239_3.setValue("123");

        this.assertEquals("123", this.__b1__P_239_1.getLab().getValue());
        array.reverse();
        this.assertEquals("123", this.__b2__P_239_2.getLab().getValue());

        this.__label__P_239_3.setValue("456");

        this.assertEquals("456", this.__b2__P_239_2.getLab().getValue());
        this.assertEquals("123", this.__b1__P_239_1.getLab().getValue());
      },
      testDeepTargetChangeWithoutEvent: function testDeepTargetChangeWithoutEvent() {
        this.__a__P_239_0.setChildWithout(this.__b1__P_239_1);

        qx.data.SingleValueBinding.bind(this.__label__P_239_3, "value", this.__a__P_239_0, "childWithout.name");

        this.__label__P_239_3.setValue("123");

        this.assertEquals("123", this.__b1__P_239_1.getName());

        this.__a__P_239_0.setChildWithout(this.__b2__P_239_2);

        this.assertEquals("b2", this.__b2__P_239_2.getName());

        this.__label__P_239_3.setValue("456");

        this.assertEquals("456", this.__b2__P_239_2.getName());
        this.assertEquals("123", this.__b1__P_239_1.getName());
      },
      testDeepTargetChangeWithoutEvent3: function testDeepTargetChangeWithoutEvent3() {
        this.__a__P_239_0.setChild(this.__b1__P_239_1);

        this.__b1__P_239_1.setChildWithout(this.__b2__P_239_2);

        this.__b2__P_239_2.setChildWithout(this.__b1__P_239_1);

        qx.data.SingleValueBinding.bind(this.__label__P_239_3, "value", this.__a__P_239_0, "child.childWithout.name");

        this.__label__P_239_3.setValue("123");

        this.assertEquals("123", this.__b2__P_239_2.getName());

        this.__a__P_239_0.setChild(this.__b2__P_239_2);

        this.assertEquals("123", this.__b1__P_239_1.getName());

        this.__b2__P_239_2.setChildWithout(this.__a__P_239_0);

        this.assertEquals("a", this.__a__P_239_0.getName());

        this.__label__P_239_3.setValue("456");

        this.assertEquals("456", this.__a__P_239_0.getName());
        this.assertEquals("123", this.__b1__P_239_1.getName());
      },
      testDeepTargetChange3ResetNotNull: function testDeepTargetChange3ResetNotNull() {
        // set up the target chain
        this.__a__P_239_0.setChild(this.__b1__P_239_1);

        this.__b1__P_239_1.setChild(this.__b2__P_239_2);

        this.__b2__P_239_2.setChild(this.__b1__P_239_1);

        this.__a__P_239_0.setName(null);

        qx.data.SingleValueBinding.bind(this.__a__P_239_0, "name", this.__a__P_239_0, "child.child.name");
        this.assertEquals(this.__a__P_239_0.getName(), this.__b2__P_239_2.getName());

        this.__a__P_239_0.setName("nnnnn");

        this.assertEquals(this.__a__P_239_0.getName(), this.__b2__P_239_2.getName());

        this.__a__P_239_0.setName(null);

        this.assertEquals(this.__a__P_239_0.getName(), this.__b2__P_239_2.getName());
      },

      /**
       * Remove a deep binding that has a class in its binding that does not have a property in the chain.
       */
      testRemoveIncompleteBinding: function testRemoveIncompleteBinding() {
        var source = qx.data.marshal.Json.createModel({
          a: null
        });
        var a = qx.data.marshal.Json.createModel({}); // a class that does not contain a property with name "b"

        var target = qx.data.marshal.Json.createModel({
          result: null
        });

        try {
          source.bind('a.b', target, 'result');
          source.setA(a);
          source.removeAllBindings();
        } catch (e) {
          this.error(e);
          this.assertTrue(false, e.message);
        }

        source = qx.data.marshal.Json.createModel({
          a: null
        });
        source.setA(a);

        try {
          source.bind('a.b', target, 'result');
          source.removeAllBindings();
        } catch (e) {
          this.error(e);
          this.assertTrue(false, e.message);
        }
      }
    }
  });
  qx.test.data.singlevalue.Deep.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.data.marshal.Json": {},
      "qx.data.SingleValueBinding": {},
      "qx.data.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * testResolve-Class for testResolveing the single value binding
   */
  qx.Class.define("qx.test.data.singlevalue.Resolve", {
    extend: qx.dev.unit.TestCase,
    members: {
      testResolveDepth1: function testResolveDepth1() {
        var model = qx.data.marshal.Json.createModel({
          a: 12
        });
        this.assertEquals(12, qx.data.SingleValueBinding.resolvePropertyChain(model, "a"));
        model.dispose();
      },
      testResolveDepth2: function testResolveDepth2() {
        var model = qx.data.marshal.Json.createModel({
          a: {
            b: 12
          }
        });
        this.assertEquals(12, qx.data.SingleValueBinding.resolvePropertyChain(model, "a.b"));
        model.dispose();
      },
      testResolveDepthHuge: function testResolveDepthHuge() {
        var model = qx.data.marshal.Json.createModel({
          a: {
            b: {
              c: {
                d: {
                  e: {
                    f: 12
                  }
                }
              }
            }
          }
        });
        this.assertEquals(12, qx.data.SingleValueBinding.resolvePropertyChain(model, "a.b.c.d.e.f"));
        model.dispose();
      },
      testResolveArrayIndex: function testResolveArrayIndex() {
        var arr = new qx.data.Array([23]);
        this.assertEquals(23, qx.data.SingleValueBinding.resolvePropertyChain(arr, "[0]"));
      },
      testResolveWithArray: function testResolveWithArray() {
        var model = qx.data.marshal.Json.createModel({
          a: {
            b: [{
              c: 12
            }]
          }
        });
        this.assertEquals(12, qx.data.SingleValueBinding.resolvePropertyChain(model, "a.b[0].c"));
        model.dispose();
      },
      testResolveNestedArray: function testResolveNestedArray() {
        var model = qx.data.marshal.Json.createModel({
          a: [[23]]
        });
        this.assertEquals(23, qx.data.SingleValueBinding.resolvePropertyChain(model, "a[0][0]"));
        model.dispose();
      },
      testResolveNotExistant: function testResolveNotExistant() {
        var model = qx.data.marshal.Json.createModel({
          a: 12
        });
        this.assertException(function () {
          this.assertEquals(12, qx.data.SingleValueBinding.resolvePropertyChain(model, "b"));
        });
        model.dispose();
      }
    }
  });
  qx.test.data.singlevalue.Resolve.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.test.data.singlevalue.TextFieldDummy": {},
      "qx.data.SingleValueBinding": {},
      "qx.core.AssertionError": {},
      "qx.core.Object": {},
      "qx.util.Validate": {},
      "qx.data.Conversion": {},
      "qx.lang.Type": {},
      "qx.data.marshal.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Test-Class for testing the single value binding
   *
   * @ignore(qx.test.SVB)
   * @ignore(qx.test.TwoProperties)
   * @ignore(qx.Target)
   * @ignore(qx.Test)
   */
  qx.Class.define("qx.test.data.singlevalue.Simple", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MRequirements,
    members: {
      __a__P_240_0: null,
      __b__P_240_1: null,
      setUp: function setUp() {
        // create the widgets
        this.__a__P_240_0 = new qx.test.data.singlevalue.TextFieldDummy();
        this.__b__P_240_1 = new qx.test.data.singlevalue.TextFieldDummy();
      },
      tearDown: function tearDown() {
        qx.data.SingleValueBinding.removeAllBindingsForObject(this.__a__P_240_0);
        qx.data.SingleValueBinding.removeAllBindingsForObject(this.__b__P_240_1);

        this.__a__P_240_0.dispose();

        this.__b__P_240_1.dispose();
      },
      testStringPropertyBinding: function testStringPropertyBinding() {
        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", this.__b__P_240_1, "appearance");

        this.__a__P_240_0.setAppearance("affe");

        this.assertEquals("affe", this.__b__P_240_1.getAppearance(), "String binding does not work!");
        var affe = new qx.test.data.singlevalue.TextFieldDummy();
        affe.setAppearance("Jonny");
        qx.data.SingleValueBinding.bind(affe, "appearance", this.__b__P_240_1, "appearance");
        this.assertEquals("Jonny", this.__b__P_240_1.getAppearance(), "String binding does not work!");
        qx.data.SingleValueBinding.removeAllBindingsForObject(affe);
        affe.dispose();
      },
      testBooleanPropertyBinding: function testBooleanPropertyBinding() {
        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "enabled", this.__b__P_240_1, "enabled");

        this.__a__P_240_0.setEnabled(false);

        this.assertFalse(this.__b__P_240_1.getEnabled(), "Boolean binding does not work!");
      },
      testNumberPropertyBinding: function testNumberPropertyBinding() {
        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "zIndex", this.__b__P_240_1, "zIndex");

        this.__a__P_240_0.setZIndex(2456);

        this.assertEquals(2456, this.__b__P_240_1.getZIndex(), "Number binding does not work!");
      },
      testColorPropertyBinding: function testColorPropertyBinding() {
        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "backgroundColor", this.__b__P_240_1, "backgroundColor");

        this.__a__P_240_0.setBackgroundColor("red");

        this.assertEquals("red", this.__b__P_240_1.getBackgroundColor(), "Color binding does not work!");
      },
      testWrongPropertyNames: function testWrongPropertyNames() {
        {
          var a = this.__a__P_240_0;
          var b = this.__b__P_240_1; // only in source version

          {
            // wrong source
            this.assertException(function () {
              qx.data.SingleValueBinding.bind(a, "BacccccckgroundColor", b, "backgroundColor");
            }, qx.core.AssertionError, null, "Not a wrong property name? (source)");
          }
        }
      },
      testWrongEventType: function testWrongEventType() {
        {
          var a = this.__a__P_240_0;
          var b = this.__b__P_240_1; // only in source version

          {
            // wrong eventName
            this.assertException(function () {
              qx.data.SingleValueBinding.bind(a, "affe", b, "backgroundColor");
            }, null, null, "Not a wrong event name? (source)");
          }
        }
      },
      testDefaultConversion: function testDefaultConversion() {
        // String to number
        this.__a__P_240_0.setAppearance("0");

        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", this.__b__P_240_1, "zIndex");

        this.__a__P_240_0.setAppearance("4879");

        this.assertEquals(4879, this.__b__P_240_1.getZIndex(), "String --> Number does not work!"); // number to String

        this.__a__P_240_0.setZIndex(568);

        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "zIndex", this.__b__P_240_1, "appearance");

        this.__a__P_240_0.setZIndex(1234);

        this.assertEquals("1234", this.__b__P_240_1.getAppearance(), "Number --> String does not work!"); // boolean to string

        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "enabled", this.__b__P_240_1, "appearance");

        this.__a__P_240_0.setEnabled(true);

        this.assertEquals("true", this.__b__P_240_1.getAppearance(), "Boolean --> String does not work!"); // string to float

        var s = new qx.test.data.singlevalue.TextFieldDummy();
        s.setFloatt(0);
        qx.data.SingleValueBinding.bind(s, "floatt", this.__b__P_240_1, "appearance");
        s.setFloatt(13.5);
        this.assertEquals("13.5", this.__b__P_240_1.getAppearance(), "Float --> String does not work!");
        qx.data.SingleValueBinding.removeAllBindingsForObject(s);
        s.dispose();
      },
      testRemoveBinding: function testRemoveBinding() {
        // remove all bindings
        qx.data.SingleValueBinding.removeAllBindings(); // add a binding

        var id = qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", this.__b__P_240_1, "appearance"); // set and chech the name

        this.__a__P_240_0.setAppearance("hans");

        this.assertEquals("hans", this.__b__P_240_1.getAppearance(), "String binding does not work!"); // remove the binding

        qx.data.SingleValueBinding.removeBindingFromObject(this.__a__P_240_0, id); // set and chech the name

        this.__a__P_240_0.setAppearance("hans2");

        this.assertEquals("hans", this.__b__P_240_1.getAppearance(), "Did not remove the binding!"); // test if the binding is not listed anymore

        var bindings = qx.data.SingleValueBinding.getAllBindingsForObject(this.__a__P_240_0);
        this.assertEquals(0, bindings.length, "Binding still in the registry!"); // only in source version

        {
          // test wrong binding id
          var a = this.__a__P_240_0;
          this.assertException(function () {
            qx.data.SingleValueBinding.removeBindingFromObject(a, null);
          }, Error, null, "No exception thrown.");
        }
      },
      testGetAllBindingsForObject: function testGetAllBindingsForObject() {
        // remove all old bindings
        qx.data.SingleValueBinding.removeAllBindings(); // add two binding

        var id = qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", this.__b__P_240_1, "appearance");
        var id2 = qx.data.SingleValueBinding.bind(this.__a__P_240_0, "zIndex", this.__b__P_240_1, "zIndex"); // set and chech the binding

        this.__a__P_240_0.setAppearance("hans");

        this.assertEquals("hans", this.__b__P_240_1.getAppearance(), "String binding does not work!");

        this.__a__P_240_0.setZIndex(89);

        this.assertEquals(89, this.__b__P_240_1.getZIndex(), "Number binding does not work!"); // check the method

        var bindings = qx.data.SingleValueBinding.getAllBindingsForObject(this.__a__P_240_0);
        this.assertEquals(2, bindings.length, "There are more than 2 bindings!");
        this.assertEquals(id, bindings[0][0], "Binding 1 not in the array.");
        this.assertEquals(id2, bindings[1][0], "Binding 2 not in the array."); // check for a non existing binding

        var noBindings = qx.data.SingleValueBinding.getAllBindingsForObject(this);
        this.assertEquals(0, noBindings.length, "There are bindings for this?");
      },
      testRemoveAllBindingsForObject: function testRemoveAllBindingsForObject() {
        // add two bindings
        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", this.__b__P_240_1, "appearance");
        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "zIndex", this.__b__P_240_1, "zIndex"); // set and check the binding

        this.__a__P_240_0.setAppearance("hans");

        this.assertEquals("hans", this.__b__P_240_1.getAppearance(), "String binding does not work!");

        this.__a__P_240_0.setZIndex(89);

        this.assertEquals(89, this.__b__P_240_1.getZIndex(), "Number binding does not work!"); // remove the bindings at once

        qx.data.SingleValueBinding.removeAllBindingsForObject(this.__a__P_240_0); // set and check the binding

        this.__a__P_240_0.setAppearance("hans2");

        this.assertEquals("hans", this.__b__P_240_1.getAppearance(), "String binding not removed!");

        this.__a__P_240_0.setZIndex(892);

        this.assertEquals(89, this.__b__P_240_1.getZIndex(), "Number binding not removed!"); // check if they are internally removed

        var bindings = qx.data.SingleValueBinding.getAllBindingsForObject(this.__a__P_240_0);
        this.assertEquals(0, bindings.length, "Still bindings there!"); // check if a remove of an object without a binding works

        var o = new qx.core.Object();
        qx.data.SingleValueBinding.removeAllBindings();
        o.dispose(); // only test in the source version

        {
          // test for null object
          this.assertException(function () {
            qx.data.SingleValueBinding.removeAllBindingsForObject(null);
          }, qx.core.AssertionError, null, "Null is not possible!");
        }
      },
      testGetAllBindings: function testGetAllBindings() {
        // remove all bindings
        qx.data.SingleValueBinding.removeAllBindings(); // add three bindings

        var id1 = qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", this.__b__P_240_1, "appearance");
        var id2 = qx.data.SingleValueBinding.bind(this.__a__P_240_0, "zIndex", this.__b__P_240_1, "zIndex");
        var id3 = qx.data.SingleValueBinding.bind(this.__b__P_240_1, "zIndex", this.__a__P_240_0, "zIndex"); // get all bindings

        var allBindings = qx.data.SingleValueBinding.getAllBindings(); // check if only the added hashs are in the object

        var hashArray = [this.__a__P_240_0.toHashCode(), this.__b__P_240_1.toHashCode()];
        var i = 0;

        for (var hash in allBindings) {
          this.assertInArray(hash, hashArray, "This hash should be in!");
          i++;
        }

        this.assertEquals(2, i, "Too much or too less objects in the array!"); // check for the binding ids

        this.assertEquals(id1, allBindings[this.__a__P_240_0.toHashCode()][0][0], "This id should be in!");
        this.assertEquals(id2, allBindings[this.__a__P_240_0.toHashCode()][1][0], "This id should be in!");
        this.assertEquals(id3, allBindings[this.__b__P_240_1.toHashCode()][0][0], "This id should be in!"); // check for the length

        this.assertEquals(2, allBindings[this.__a__P_240_0.toHashCode()].length, "Not the right amount in the data!");
        this.assertEquals(1, allBindings[this.__b__P_240_1.toHashCode()].length, "Not the right amount in the data!");
      },
      testDebugStuff: function testDebugStuff() {
        // just a test if the method runs threw without an exception
        var id1 = qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", this.__b__P_240_1, "appearance");
        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "zIndex", this.__b__P_240_1, "zIndex");
        qx.data.SingleValueBinding.bind(this.__b__P_240_1, "appearance", this.__a__P_240_0, "appearance");
        qx.data.SingleValueBinding.bind(this.__b__P_240_1, "zIndex", this.__a__P_240_0, "zIndex"); // test the single log

        qx.data.SingleValueBinding.showBindingInLog(this.__a__P_240_0, id1); // test the all log

        qx.data.SingleValueBinding.showAllBindingsInLog();
      },
      testMixinSupport: function testMixinSupport() {
        // remove all bindings
        qx.data.SingleValueBinding.removeAllBindings(); // create a new Binding

        var id1 = this.__a__P_240_0.bind("appearance", this.__b__P_240_1, "appearance");

        this.__a__P_240_0.setAppearance("hulk");

        this.assertEquals("hulk", this.__b__P_240_1.getAppearance(), "String binding does not work!"); // remove the binding

        this.__a__P_240_0.removeBinding(id1);

        this.__a__P_240_0.setAppearance("hulk2");

        this.assertEquals("hulk", this.__b__P_240_1.getAppearance(), "Unbinding does not work!"); // add another two bindings

        var id1 = this.__a__P_240_0.bind("changeAppearance", this.__b__P_240_1, "appearance");

        var id2 = this.__a__P_240_0.bind("zIndex", this.__b__P_240_1, "zIndex"); // get the current bindings


        var bindings = this.__a__P_240_0.getBindings();

        this.assertEquals(id1, bindings[0][0], "First binding is not there.");
        this.assertEquals(id2, bindings[1][0], "Second binding is not there."); // remove all bindings

        this.__a__P_240_0.removeAllBindings();

        var bindings = this.__a__P_240_0.getBindings();

        this.assertEquals(0, bindings.length, "Still bindings there?");
      },
      testDebugListenerMessages: function testDebugListenerMessages() {
        // enable debugging
        qx.data.SingleValueBinding.DEBUG_ON = true; // just do some bindings and invoke the changes

        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", this.__b__P_240_1, "appearance");

        this.__a__P_240_0.setAppearance("affe");

        this.assertEquals("affe", this.__b__P_240_1.getAppearance(), "String binding does not work!");
        var affe = new qx.test.data.singlevalue.TextFieldDummy();
        affe.setAppearance("Jonny");
        qx.data.SingleValueBinding.bind(affe, "appearance", this.__b__P_240_1, "appearance");
        this.assertEquals("Jonny", this.__b__P_240_1.getAppearance(), "String binding does not work!");
        qx.data.SingleValueBinding.removeAllBindingsForObject(affe);
        affe.dispose();
      },
      testFallback: function testFallback() {
        // change + "name" binding
        this.__a__P_240_0.bind("value", this.__b__P_240_1, "value");

        this.__a__P_240_0.setValue("affe");

        this.assertEquals(this.__a__P_240_0.getValue(), this.__b__P_240_1.getValue(), "change event binding is not working."); // event binding

        this.__a__P_240_0.bind("changeZIndex", this.__b__P_240_1, "zIndex");

        this.__a__P_240_0.setZIndex(123);

        this.assertEquals(this.__a__P_240_0.getZIndex(), this.__b__P_240_1.getZIndex(), "Event binding is not working.");
      },
      testNullWithConverter: function testNullWithConverter() {
        // create a test class
        qx.Class.define("qx.Test", {
          extend: qx.core.Object,
          members: {
            __a__P_240_0: null,
            setA: function setA(data) {
              this.__a__P_240_0 = data;
            },
            getA: function getA() {
              return this.__a__P_240_0;
            }
          }
        });
        var t = new qx.Test(); // define the converter

        var options = {
          converter: function converter(data) {
            if (data == null) {
              return "affe";
            }

            return data + "";
          }
        }; // starting point

        this.__a__P_240_0.setZIndex(null);

        this.__a__P_240_0.bind("zIndex", t, "a", options);

        this.assertEquals("affe", t.getA(), "Converter will not be executed.");

        this.__a__P_240_0.setZIndex(10);

        this.assertEquals(this.__a__P_240_0.getZIndex() + "", t.getA(), "Wrong start binding."); // set the zIndex to null

        this.__a__P_240_0.setZIndex(null);

        this.assertEquals("affe", t.getA(), "Converter will not be executed.");
        t.dispose();
      },
      testCallbacksOnInitialSet: function testCallbacksOnInitialSet() {
        // create a test class
        qx.Class.define("qx.Target", {
          extend: qx.core.Object,
          properties: {
            value: {
              init: "Some String!",
              validate: qx.util.Validate.string()
            }
          }
        });
        var target = new qx.Target(); // some test flags

        var ok = false;
        var fail = false; // callback methods

        var that = this;
        var options = {
          onUpdate: function onUpdate(sourceObject, targetObject, value) {
            ok = true;
            that.assertEquals(sourceObject, that.__a__P_240_0, "Wrong source object.");
            that.assertEquals(targetObject, target, "Wrong target object.");
            that.assertEquals(value, "affe", "Wrong value.");
          },
          onSetFail: function onSetFail() {
            fail = true;
          }
        }; // set a valid initial value

        this.__a__P_240_0.setValue("affe");

        this.__a__P_240_0.bind("value", target, "value", options);

        this.assertEquals("affe", target.getValue(), "Binding not set anyway!");
        this.assertTrue(ok, "onUpdate not called.");
        this.assertFalse(fail, "onSetFail called?!"); // reset the checks

        this.__a__P_240_0.removeAllBindings();

        ok = false;
        fail = false; // set an invalid initial value

        this.__a__P_240_0.setZIndex(10);

        this.__a__P_240_0.bind("zIndex", target, "value", options);

        this.assertTrue(fail, "onSetFail not called.");
        this.assertFalse(ok, "onUpdate called?!");
        target.dispose();
      },
      testConversionClass: function testConversionClass() {
        qx.Class.define("qx.test.TwoProperties", {
          extend: qx.core.Object,
          properties: {
            a: {
              event: "changeA",
              nullable: true
            },
            b: {
              event: "changeB",
              nullable: true
            }
          }
        });
        var o = new qx.test.TwoProperties(); // number to string

        var id = qx.data.SingleValueBinding.bind(o, "a", o, "b", qx.data.Conversion.TOSTRINGOPTIONS);
        o.setA(10);
        this.assertEquals("10", o.getB(), "Number -> String");
        qx.data.SingleValueBinding.removeBindingFromObject(o, id); // boolean to string

        var id = qx.data.SingleValueBinding.bind(o, "a", o, "b", qx.data.Conversion.TOSTRINGOPTIONS);
        o.setA(true);
        this.assertEquals("true", o.getB(), "Boolean -> String");
        qx.data.SingleValueBinding.removeBindingFromObject(o, id); // date to string

        var id = qx.data.SingleValueBinding.bind(o, "a", o, "b", qx.data.Conversion.TOSTRINGOPTIONS);
        o.setA(new Date());
        this.assertTrue(qx.lang.Type.isString(o.getB()), "Date -> String");
        qx.data.SingleValueBinding.removeBindingFromObject(o, id); // string to number

        var id = qx.data.SingleValueBinding.bind(o, "a", o, "b", qx.data.Conversion.TONUMBEROPTIONS);
        o.setA("123");
        this.assertEquals(123, o.getB(), "String -> Number");
        qx.data.SingleValueBinding.removeBindingFromObject(o, id); // string to boolean

        var id = qx.data.SingleValueBinding.bind(o, "a", o, "b", qx.data.Conversion.TOBOOLEANOPTIONS);
        o.setA("123");
        this.assertEquals(true, o.getB(), "String -> Boolean");
        qx.data.SingleValueBinding.removeBindingFromObject(o, id); // number to boolean

        var id = qx.data.SingleValueBinding.bind(o, "a", o, "b", qx.data.Conversion.TOBOOLEANOPTIONS);
        o.setA(0);
        this.assertEquals(false, o.getB(), "Number -> Boolean");
        qx.data.SingleValueBinding.removeBindingFromObject(o, id);
        o.dispose();
      },
      testResetNotNull: function testResetNotNull() {
        qx.Class.define("qx.test.SVB", {
          extend: qx.core.Object,
          properties: {
            x: {
              nullable: true,
              init: "affe",
              event: "changeX"
            }
          }
        });
        var a = new qx.test.SVB();
        var b = new qx.test.SVB();
        a.bind("x", b, "x");
        a.setX("x");
        this.assertEquals(a.getX(), b.getX());
        a.setX(null);
        this.assertEquals(a.getX(), b.getX());
        qx.data.SingleValueBinding.removeAllBindingsForObject(a);
        qx.data.SingleValueBinding.removeAllBindingsForObject(b);
        a.dispose();
        b.dispose();
        qx.Class.undefine("qx.test.SVB");
      },
      testResetNotNullInit: function testResetNotNullInit() {
        qx.Class.define("qx.test.SVB", {
          extend: qx.core.Object,
          properties: {
            x: {
              nullable: true,
              init: "affe",
              event: "changeX"
            }
          }
        });
        var a = new qx.test.SVB();
        var b = new qx.test.SVB();
        a.setX(null);
        b.setX("x");
        qx.data.SingleValueBinding.bind(a, "x", b, "x");
        this.assertEquals(a.getX(), b.getX());
        qx.data.SingleValueBinding.removeAllBindingsForObject(a);
        qx.data.SingleValueBinding.removeAllBindingsForObject(b);
        a.dispose();
        b.dispose();
        qx.Class.undefine("qx.test.SVB");
      },
      testChangeEventMissing: function testChangeEventMissing() {
        qx.Class.define("qx.test.SVB", {
          extend: qx.core.Object,
          properties: {
            x: {
              nullable: true,
              init: "affe"
            }
          }
        });
        var a = new qx.test.SVB();
        var b = new qx.test.SVB();
        this.assertException(function () {
          qx.data.SingleValueBinding.bind(a, "x", b, "x");
        }, qx.core.AssertionError, "Binding property x of object qx.test.SVB");
        qx.data.SingleValueBinding.removeAllBindingsForObject(a);
        qx.data.SingleValueBinding.removeAllBindingsForObject(b);
        a.dispose();
        b.dispose();
        qx.Class.undefine("qx.test.SVB");
      },
      testConverterParam: function testConverterParam() {
        var self = this;
        var options = {
          converter: function converter(data, model, source, target) {
            // will be called twice (init and set)
            self.assertEquals(self.__a__P_240_0, source);
            self.assertEquals(self.__b__P_240_1, target);
            return data;
          }
        };
        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", this.__b__P_240_1, "appearance", options);

        this.__a__P_240_0.setAppearance("affe");

        this.assertEquals("affe", this.__b__P_240_1.getAppearance(), "String binding does not work!");
      },
      testWrongArguments: function testWrongArguments() {
        this.require(["qx.debug"]);

        this.assertException(function () {
          qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", this.__b__P_240_1, undefined);
        }, qx.core.AssertionError, "");
        this.assertException(function () {
          qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", undefined, "appearance");
        }, qx.core.AssertionError, "");
        this.assertException(function () {
          qx.data.SingleValueBinding.bind(this.__a__P_240_0, undefined, this.__b__P_240_1, "appearance");
        }, qx.core.AssertionError, "");
        this.assertException(function () {
          qx.data.SingleValueBinding.bind(undefined, "appearance", this.__b__P_240_1, "appearance");
        }, qx.core.AssertionError, "");
      },
      testRemoveRelatedBindings: function testRemoveRelatedBindings() {
        var c = new qx.test.data.singlevalue.TextFieldDummy(); // add three bindings

        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "appearance", this.__b__P_240_1, "appearance");
        qx.data.SingleValueBinding.bind(this.__a__P_240_0, "zIndex", this.__b__P_240_1, "zIndex");
        qx.data.SingleValueBinding.bind(this.__b__P_240_1, "zIndex", this.__a__P_240_0, "zIndex"); // add another binding to __a, which should not be affected

        qx.data.SingleValueBinding.bind(c, "appearance", this.__a__P_240_0, "appearance"); // add another binding to __b, which should not be affected

        qx.data.SingleValueBinding.bind(c, "appearance", this.__b__P_240_1, "appearance"); // check if the bindings are there

        var bindingsA = qx.data.SingleValueBinding.getAllBindingsForObject(this.__a__P_240_0);
        var bindingsB = qx.data.SingleValueBinding.getAllBindingsForObject(this.__b__P_240_1);
        this.assertEquals(4, bindingsA.length, "There are more than 4 bindings!");
        this.assertEquals(4, bindingsB.length, "There are more than 3 bindings!"); // remove related bindings between __a and __b, do not affect bindings to c

        qx.data.SingleValueBinding.removeRelatedBindings(this.__a__P_240_0, this.__b__P_240_1); // __a object should have one binding to object c

        bindingsA = qx.data.SingleValueBinding.getAllBindingsForObject(this.__a__P_240_0);
        this.assertEquals(1, bindingsA.length, "There must be one binding!");
        this.assertTrue(bindingsA[0][1] === c, "Source object of the binding must be object 'c'!"); // __b object should have one binding to object c

        bindingsB = qx.data.SingleValueBinding.getAllBindingsForObject(this.__b__P_240_1);
        this.assertEquals(1, bindingsB.length, "There must be one binding!");
        this.assertTrue(bindingsA[0][1] === c, "Source object of the binding must be object 'c'!");
      },
      testNonExistingSetup: function testNonExistingSetup() {
        var a = qx.data.marshal.Json.createModel({
          b: {},
          target: null
        });
        qx.data.SingleValueBinding.bind(a, "b.c", a, "target");
        this.assertNull(a.getTarget());
        a.setB(qx.data.marshal.Json.createModel({
          c: "txt"
        }));
        this.assertEquals("txt", a.getTarget());
      },
      testNonExistingSetupDeep: function testNonExistingSetupDeep() {
        var a = qx.data.marshal.Json.createModel({
          b: {
            c: {
              d: {
                e: {}
              }
            }
          },
          target: null
        });
        qx.data.SingleValueBinding.bind(a, "b.c.d.e.f", a, "target");
        this.assertNull(a.getTarget());
        a.getB().setC(qx.data.marshal.Json.createModel({
          d: {
            e: {
              f: "txt"
            }
          }
        }));
        this.assertEquals("txt", a.getTarget());
      },
      testNonExistingChange: function testNonExistingChange() {
        var a = qx.data.marshal.Json.createModel({
          b: {
            c: "txt"
          },
          bb: {},
          target: null
        });
        qx.data.SingleValueBinding.bind(a, "b.c", a, "target");
        this.assertEquals("txt", a.getTarget());
        a.setB(a.getBb());
        this.assertNull(a.getTarget());
      },
      testNonExistingChangeDeep: function testNonExistingChangeDeep() {
        var a = qx.data.marshal.Json.createModel({
          b: {
            c: {
              d: {
                e: {
                  f: "txt"
                }
              }
            }
          },
          target: null
        });
        qx.data.SingleValueBinding.bind(a, "b.c.d.e.f", a, "target");
        this.assertEquals("txt", a.getTarget());
        a.getB().setC(qx.data.marshal.Json.createModel({
          d: {
            e: {}
          }
        }));
        this.assertNull(a.getTarget());
        a.getB().setC(qx.data.marshal.Json.createModel({
          d: {}
        }));
        this.assertNull(a.getTarget());
      }
    }
  });
  qx.test.data.singlevalue.Simple.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.io.request.Xhr": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.data.store.Json": {},
      "qx.util.ResourceManager": {},
      "qx.util.AliasManager": {},
      "qx.core.Object": {},
      "qx.Mixin": {},
      "qx.event.Timer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /* ************************************************************************
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/*)
   * @ignore(qx.data.model, qx.test.O, qx.test.M, qx.test.M1, qx.test.M2)
   * @require(qx.io.request.Xhr)
   */
  qx.Class.define("qx.test.data.store.Json", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      __store__P_241_0: null,
      __data__P_241_1: null,
      __propertyNames__P_241_2: null,

      /**
       * @lint ignoreDeprecated(eval)
       */
      setUp: function setUp() {
        this.__store__P_241_0 = new qx.data.store.Json();
        this.__data__P_241_1 = eval("({s: 'String', n: 12, b: true})");
        this.__propertyNames__P_241_2 = ["s", "n", "b"];
        this.url = qx.util.ResourceManager.getInstance().toUri("qx/test/primitive.json");
      },
      setUpFakeRequest: function setUpFakeRequest() {
        var req = this.request = new qx.io.request.Xhr(this.url);

        req.send = req.setParser = function () {};

        req.dispose = qx.io.request.Xhr.prototype.dispose;
        this.stub(qx.io.request, "Xhr").returns(this.stub(req));
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();

        if (this.request) {
          // Restore manually (is unreachable from sandbox)
          if (typeof this.request.dispose.restore == "function") {
            this.request.dispose.restore();
          } // Dispose


          this.request.dispose();
        }

        this.__store__P_241_0.dispose(); // Remove the former created classes


        qx.data.model = {};

        for (var name in qx.Class.$$registry) {
          if (name.search("qx.data.model") != -1) {
            delete qx.Class.$$registry[name];
          }
        }
      },
      testConfigureNewTransportConstructor: function testConfigureNewTransportConstructor() {
        var store = new qx.data.store.Json(this.url, null, false);
        store.dispose();
      },
      testLoadUrl: function testLoadUrl() {
        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertEquals("String", model.getString(), "The model is not created how it should!");
          }, this);
        }, this);

        var url = this.url;

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testProgressStates: function testProgressStates() {
        var url = this.url,
            states = [];

        this.__store__P_241_0.addListener("changeState", function (evt) {
          var state = evt.getData();
          states.push(state);

          if (state == "completed") {
            this.resume(function () {
              var expected = ["configured", "sending", "receiving", "completed"];
              this.assertArrayEquals(expected, states);
            });
          }
        }, this);

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testLoadResource: function testLoadResource() {
        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertEquals("String", model.getString(), "The model is not created how it should!");
          }, this);
        }, this);

        var resource = "qx/test/primitive.json";

        this.__store__P_241_0.setUrl(resource);

        this.wait();
      },
      testParseErrorForResource: function testParseErrorForResource() {
        this.__store__P_241_0.addListener("parseError", function (ev) {
          this.resume(function () {
            this.assertString(ev.getData().response, "Parse error object does not contain response!");
            this.assertObject(ev.getData().error, "Parse error object does not contain parser exception!");
          }, this);
        }, this);

        var resource = "qx/test/failing.json";

        this.__store__P_241_0.setUrl(resource);

        this.wait();
      },
      testLoadAlias: function testLoadAlias() {
        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertEquals("String", model.getString(), "The model is not created how it should!");
            qx.util.AliasManager.getInstance().remove("testLoadResource");
          }, this);
        }, this); // invoke alias handling


        qx.util.AliasManager.getInstance().add("testLoadResource", "qx/test");
        var alias = "testLoadResource/primitive.json";

        this.__store__P_241_0.setUrl(alias);

        this.wait();
      },
      testDispose: function testDispose() {
        this.__store__P_241_0.setUrl(this.url);

        this.__store__P_241_0.dispose();
      },
      testWholePrimitive: function testWholePrimitive() {
        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertEquals("String", model.getString(), "The model is not created how it should!");
            this.assertEquals(12, model.getNumber(), "The model is not created how it should!");
            this.assertEquals(true, model.getBoolean(), "The model is not created how it should!");
            this.assertNull(model.getNull(), "The model is not created how it should!");
          }, this);
        }, this);

        var url = this.url;

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testWholeArray: function testWholeArray() {
        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertNotNull(model.getArray(), "The model is not created how it should!");
            this.assertEquals("qx.data.Array", model.getArray().classname, "Wrong array class.");
            this.assertEquals("a", model.getArray().getItem(0), "Wrong content of the array.");
            this.assertEquals("b", model.getArray().getItem(1), "Wrong content of the array.");
            this.assertEquals("c", model.getArray().getItem(2), "Wrong content of the array.");
          }, this);
        }, this);

        var url = qx.util.ResourceManager.getInstance().toUri("qx/test/array.json");

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testWholeObject: function testWholeObject() {
        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertNotNull(model.getO(), "The model is not created how it should!");
            this.assertEquals("a", model.getO().getA(), "Wrong content of the object.");
            this.assertEquals("b", model.getO().getB(), "Wrong content of the object.");
          }, this);
        }, this);

        var url = qx.util.ResourceManager.getInstance().toUri("qx/test/object.json");

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testOwnClassWith: function testOwnClassWith() {
        // define a test class
        qx.Class.define("qx.test.AB", {
          extend: qx.core.Object,
          properties: {
            a: {
              check: "String",
              event: "changeA"
            },
            b: {
              check: "String",
              event: "changeB"
            }
          }
        });
        var delegate = {
          getModelClass: function getModelClass(properties) {
            if (properties == 'a|b' || properties == 'a|b♥') {
              return qx.Class.getByName("qx.test.AB");
            }

            return null;
          }
        };
        this.__store__P_241_0 = new qx.data.store.Json(null, delegate);

        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertNotNull(model.getO(), "The model is not created how it should!");
            this.assertEquals("qx.test.AB", model.getO().classname, "Not the given class used!");
            this.assertEquals("a", model.getO().getA(), "Wrong content of the object.");
            this.assertEquals("b", model.getO().getB(), "Wrong content of the object.");
          }, this);
        }, this);

        var url = qx.util.ResourceManager.getInstance().toUri("qx/test/object.json");

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testOwnClassWithout: function testOwnClassWithout() {
        var delegate = {
          getModelClass: function getModelClass(properties) {
            return null;
          }
        };
        this.__store__P_241_0 = new qx.data.store.Json(null, delegate);

        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertNotNull(model.getO(), "The model is not created how it should!");
            this.assertEquals("a", model.getO().getA(), "Wrong content of the object.");
            this.assertEquals("b", model.getO().getB(), "Wrong content of the object.");
          }, this);
        }, this);

        var url = qx.util.ResourceManager.getInstance().toUri("qx/test/object.json");

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testOwnSuperclassWith: function testOwnSuperclassWith() {
        // define a test class
        qx.Class.define("qx.test.O", {
          extend: qx.core.Object
        });
        var delegate = {
          getModelSuperClass: function getModelSuperClass(properties) {
            return qx.test.O;
          }
        };
        this.__store__P_241_0 = new qx.data.store.Json(null, delegate);

        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertTrue(qx.Class.isSubClassOf(model.constructor, qx.test.O));
            this.assertNotNull(model.getO(), "The model is not created how it should!");
            this.assertTrue(qx.Class.isSubClassOf(model.getO().constructor, qx.test.O));
            this.assertEquals("a", model.getO().getA(), "Wrong content of the object.");
            this.assertEquals("b", model.getO().getB(), "Wrong content of the object.");
          }, this);
        }, this);

        var url = qx.util.ResourceManager.getInstance().toUri("qx/test/object.json");

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testOwnSuperclassWithout: function testOwnSuperclassWithout() {
        // define a test class
        qx.Class.define("qx.test.O", {
          extend: qx.core.Object
        });
        var delegate = {
          getModelSuperClass: function getModelSuperClass(properties) {
            return null;
          }
        };
        this.__store__P_241_0 = new qx.data.store.Json(null, delegate);

        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertNotNull(model.getO(), "The model is not created how it should!");
            this.assertEquals("a", model.getO().getA(), "Wrong content of the object.");
            this.assertEquals("b", model.getO().getB(), "Wrong content of the object.");
          }, this);
        }, this);

        var url = qx.util.ResourceManager.getInstance().toUri("qx/test/object.json");

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testOwnMixinWithout: function testOwnMixinWithout() {
        var delegate = {
          getModelMixins: function getModelMixins(properties) {
            return null;
          }
        };
        this.__store__P_241_0 = new qx.data.store.Json(null, delegate);

        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertNotNull(model.getO(), "The model is not created how it should!");
            this.assertEquals("a", model.getO().getA(), "Wrong content of the object.");
            this.assertEquals("b", model.getO().getB(), "Wrong content of the object.");
          }, this);
        }, this);

        var url = qx.util.ResourceManager.getInstance().toUri("qx/test/object.json");

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testOwnMixinWith: function testOwnMixinWith() {
        // define a test class
        qx.Mixin.define("qx.test.M", {
          members: {
            a: function a() {
              return true;
            }
          }
        });
        var delegate = {
          getModelMixins: function getModelMixins(properties) {
            return qx.test.M;
          }
        };
        this.__store__P_241_0 = new qx.data.store.Json(null, delegate);

        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertTrue(model.a(), "Mixin not included.");
            this.assertNotNull(model.getO(), "The model is not created how it should!");
            this.assertTrue(model.getO().a(), "Mixin not included.");
            this.assertEquals("a", model.getO().getA(), "Wrong content of the object.");
            this.assertEquals("b", model.getO().getB(), "Wrong content of the object.");
          }, this);
        }, this);

        var url = qx.util.ResourceManager.getInstance().toUri("qx/test/object.json");

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testOwnMixinWithMultiple: function testOwnMixinWithMultiple() {
        // define a test class
        qx.Mixin.define("qx.test.M1", {
          members: {
            a: function a() {
              return true;
            }
          }
        });
        qx.Mixin.define("qx.test.M2", {
          members: {
            b: function b() {
              return true;
            }
          }
        });
        var delegate = {
          getModelMixins: function getModelMixins(properties) {
            return [qx.test.M1, qx.test.M2];
          }
        };
        this.__store__P_241_0 = new qx.data.store.Json(null, delegate);

        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel();

            this.assertTrue(model.a(), "Mixin not included.");
            this.assertTrue(model.b(), "Mixin not included.");
            this.assertNotNull(model.getO(), "The model is not created how it should!");
            this.assertTrue(model.getO().a(), "Mixin not included.");
            this.assertEquals("a", model.getO().getA(), "Wrong content of the object.");
            this.assertEquals("b", model.getO().getB(), "Wrong content of the object.");
          }, this);
        }, this);

        var url = qx.util.ResourceManager.getInstance().toUri("qx/test/object.json");

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testManipulatePrimitive: function testManipulatePrimitive() {
        var delegate = {
          manipulateData: function manipulateData(data) {
            return data;
          }
        };
        this.spy(delegate, "manipulateData");

        this.__store__P_241_0.dispose();

        this.__store__P_241_0 = new qx.data.store.Json(null, delegate);

        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            this.assertCalled(delegate.manipulateData);
          }, this);
        }, this);

        var url = this.url;

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testConfigureRequestPrimitive: function testConfigureRequestPrimitive() {
        var delegate,
            self = this;
        delegate = {
          configureRequest: function configureRequest(request) {
            self.assertInstance(request, qx.io.request.Xhr);
          }
        };
        this.spy(delegate, "configureRequest");

        this.__store__P_241_0.dispose();

        this.__store__P_241_0 = new qx.data.store.Json(null, delegate);

        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            this.assertCalled(delegate.configureRequest);
          }, this);
        }, this);

        var url = this.url;

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testDisposeOldModel: function testDisposeOldModel() {
        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_241_0.getModel(); // check if the new model is not the old model


            this.assertNotEquals(fakeModel, model); // check if the old model has been disposed

            this.assertTrue(fakeModel.isDisposed());
          }, this);
        }, this); // set a fake model


        var fakeModel = new qx.core.Object();

        this.__store__P_241_0.setModel(fakeModel);

        var url = this.url;

        this.__store__P_241_0.setUrl(url);

        this.wait();
      },
      testDisposeRequest: function testDisposeRequest() {
        this.setUpFakeRequest();

        this.__store__P_241_0.setUrl(this.url);

        this.__store__P_241_0.dispose();

        this.assertCalled(this.request.dispose);
      },
      testDisposeRequestDone: function testDisposeRequestDone() {
        this.setUpFakeRequest();
        var url = this.url;

        this.__store__P_241_0.addListener("loaded", function () {
          this.resume(function () {
            this.__store__P_241_0.dispose();

            this.assertCalled(this.request.dispose);
          }, this);
        }, this);

        this.__store__P_241_0.setUrl(url);
      },
      testErrorEvent: function testErrorEvent() {
        this.__store__P_241_0.addListener("error", function (ev) {
          this.resume(function () {
            this.assertNotNull(ev);
          }, this);
        }, this);

        this.__store__P_241_0.setUrl("not-found");

        this.wait();
      },
      "test Internal Server Error": function testInternalServerError() {
        this.useFakeServer();
        var server = this.getServer();
        server.respondWith("GET", "/foo", [500, {
          "Content-Type": "application/json"
        }, "SERVER ERROR"]);

        this.__store__P_241_0.addListener("error", function (e) {
          this.resume(function () {
            this.assertTrue(e.getData().getPhase() == "statusError");
          });
        }, this);

        qx.event.Timer.once(function () {
          this.__store__P_241_0.setUrl("/foo");

          server.respond();
        }, this, 500);
        this.wait(1000);
      }
    }
  });
  qx.test.data.store.Json.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.data.store.Jsonp": {},
      "qx.util.ResourceManager": {},
      "qx.io.request.Jsonp": {},
      "qx.bom.client.Browser": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "browser.name": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   * @ignore(qx.data.model)
   *
   * @asset(qx/test/*)
   */
  qx.Class.define("qx.test.data.store.Jsonp", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements, qx.dev.unit.MMock],
    members: {
      __store__P_242_0: null,
      setUp: function setUp() {
        this.require(["php"]);

        this.__store__P_242_0 = new qx.data.store.Jsonp();
        this.url = qx.util.ResourceManager.getInstance().toUri("qx/test/jsonp_primitive.php");
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();

        this.__store__P_242_0.dispose();

        if (this.request) {
          // From prototype
          delete this.request.dispose; // Dispose

          this.request.dispose();
        } // remove the former created classes


        qx.data.model = {};

        for (var name in qx.Class.$$registry) {
          if (name.search("qx.data.model") != -1) {
            delete qx.Class.$$registry[name];
          }
        }
      },
      isLocal: function isLocal() {
        return window.location.protocol == "file:";
      },
      setUpFakeRequest: function setUpFakeRequest() {
        var req = this.request = new qx.io.request.Jsonp();

        req.send = req.dispose = function () {};

        this.stub(qx.io.request, "Jsonp").returns(this.stub(req));
      },
      testSetCallbackParam: function testSetCallbackParam() {
        this.setUpFakeRequest();
        var store = new qx.data.store.Jsonp();
        store.setCallbackParam("myCallback");
        store.setUrl("/url");
        this.assertCalledWith(this.request.setCallbackParam, "myCallback");
        store.dispose();
      },
      testSetCallbackName: function testSetCallbackName() {
        this.setUpFakeRequest();
        var store = new qx.data.store.Jsonp();
        store.setCallbackName("myCallback");
        store.setUrl("/url");
        this.assertCalledWith(this.request.setCallbackName, "myCallback");
        store.dispose();
      },
      testWholePrimitive: function testWholePrimitive() {
        this.__store__P_242_0.addListener("loaded", function () {
          this.resume(function () {
            var model = this.__store__P_242_0.getModel();

            this.assertEquals("String", model.getString(), "The model is not created how it should!");
            this.assertEquals(12, model.getNumber(), "The model is not created how it should!");
            this.assertEquals(true, model.getBoolean(), "The model is not created how it should!");
            this.assertNull(model.getNull(), "The model is not created how it should!");
          }, this);
        }, this);

        var url = this.url;

        this.__store__P_242_0.setUrl(url);

        this.wait();
      },
      testManipulatePrimitive: function testManipulatePrimitive() {
        var manipulated = false;
        var delegate = {
          manipulateData: function manipulateData(data) {
            manipulated = true;
            return data;
          }
        };
        var store = new qx.data.store.Jsonp(null, delegate, "callback");
        store.addListener("loaded", function () {
          this.resume(function () {
            this.assertTrue(manipulated);
          }, this);
        }, this);
        var url = this.url;
        store.setUrl(url);
        this.wait();
        store.dispose();
      },
      testConfigureRequestPrimitive: function testConfigureRequestPrimitive() {
        var delegate,
            self = this;
        delegate = {
          configureRequest: function configureRequest(request) {
            self.assertInstance(request, qx.io.request.Jsonp);
          }
        };
        this.spy(delegate, "configureRequest");
        var store = new qx.data.store.Jsonp(null, delegate, "callback");
        store.addListener("loaded", function () {
          this.resume(function () {
            this.assertCalled(delegate.configureRequest);
          }, this);
        }, this);
        var url = this.url;
        store.setUrl(url);
        this.wait();
      },
      testDisposeRequest: function testDisposeRequest() {
        this.setUpFakeRequest();
        var store = new qx.data.store.Jsonp(this.url);
        store.dispose();
        this.assertCalled(this.request.dispose);
      },
      testDisposeRequestDone: function testDisposeRequestDone() {
        this.setUpFakeRequest();
        var url = this.url;

        this.__store__P_242_0.addListener("loaded", function () {
          this.resume(function () {
            this.__store__P_242_0.dispose();

            this.assertCalled(this.request.dispose);
          }, this);
        }, this);

        this.__store__P_242_0.setUrl(url);
      },
      testErrorEvent: function testErrorEvent() {
        // do not test that for IE and Opera because of the missing
        // error handler for script tags
        if (!(qx.core.Environment.get("browser.name") == "ie") && !(qx.core.Environment.get("browser.name") == "opera")) {
          this.__store__P_242_0.addListener("error", function () {
            this.resume(function () {}, this);
          }, this);

          this.__store__P_242_0.setUrl("affe");

          this.wait();
        }
      }
    }
  });
  qx.test.data.store.Jsonp.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.bom.client.Html": {},
      "qx.bom.Storage": {},
      "qx.data.store.Offline": {},
      "qx.data.marshal.Json": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "html.storage.local": {
          "className": "qx.bom.client.Html"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.data.store.Offline", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements, qx.dev.unit.MMock],
    members: {
      __store__P_243_0: null,
      __testKey__P_243_1: "qx-unit-test",
      hasLocalStorage: function hasLocalStorage() {
        return qx.core.Environment.get("html.storage.local");
      },
      hasQxDebug: function hasQxDebug() {
        return true;
      },
      setUp: function setUp() {
        this.require(["localStorage"]);
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();

        if (this.__store__P_243_0) {
          this.__store__P_243_0.dispose();
        } // erase the data from the storages


        qx.bom.Storage.getLocal().removeItem(this.__testKey__P_243_1);
      },
      __initDefaultStore__P_243_2: function __initDefaultStore__P_243_2() {
        this.__store__P_243_0 = new qx.data.store.Offline(this.__testKey__P_243_1, "local");
      },
      __createDefaultModel__P_243_3: function __createDefaultModel__P_243_3() {
        return qx.data.marshal.Json.createModel({
          a: "a"
        }, true);
      },
      testCreate: function testCreate() {
        this.require(["qxDebug"]);

        var store;
        this.assertException(function () {
          store = new qx.data.store.Offline();
        }); // fallback for the storage is local

        store = new qx.data.store.Offline(this.__testKey__P_243_1);
        this.assertEquals(store._storage, qx.bom.Storage.getLocal());
        store.dispose(); // assert no exception

        this.__initDefaultStore__P_243_2();

        this.assertEquals(this.__testKey__P_243_1, this.__store__P_243_0.getKey());
      },
      testCreateWithDelegate: function testCreateWithDelegate() {
        var del = {};
        var spy = this.spy(qx.data.marshal, "Json");
        var store = new qx.data.store.Offline(this.__testKey__P_243_1, "local", del);
        this.assertCalledWith(spy, del);
        store.dispose();
      },
      testCheckEmptyModel: function testCheckEmptyModel() {
        this.__initDefaultStore__P_243_2();

        this.assertNull(this.__store__P_243_0.getModel());

        var model = this.__createDefaultModel__P_243_3();

        this.__store__P_243_0.setModel(model);

        this.__store__P_243_0.setModel(null);

        this.wait(1000, function () {
          this.assertNull(this.__store__P_243_0.getModel());
          model.dispose();
        }.bind(this));
      },
      testSetModel: function testSetModel() {
        this.__initDefaultStore__P_243_2();

        var model = this.__createDefaultModel__P_243_3();

        this.__store__P_243_0.setModel(model);

        this.wait(1000, function () {
          this.assertEquals("a", this.__store__P_243_0.getModel().getA());
          model.dispose();
        }.bind(this));
      },
      testSetModelDebounce: function testSetModelDebounce() {
        this.__initDefaultStore__P_243_2();

        var storeModelCallback = this.spy(this.__store__P_243_0._storage, "setItem");

        var model = this.__createDefaultModel__P_243_3();

        this.__store__P_243_0.setModel(model);

        model.setA('b');
        model.setA('c');
        this.wait(1000, function () {
          this.assertCalledOnce(storeModelCallback);
        }, this);
      },
      testChangeModel: function testChangeModel() {
        this.__initDefaultStore__P_243_2();

        var model = this.__createDefaultModel__P_243_3();

        this.__store__P_243_0.setModel(model);

        this.wait(1000, function () {
          this.assertEquals("a", this.__store__P_243_0.getModel().getA());
          model.setA("A");
          this.assertEquals("A", this.__store__P_243_0.getModel().getA());
          model.dispose();
        }.bind(this));
      },
      testModelWriteRead: function testModelWriteRead() {
        this.__initDefaultStore__P_243_2();

        var model = this.__createDefaultModel__P_243_3();

        this.__store__P_243_0.setModel(model);

        this.wait(1000, function () {
          this.assertEquals("a", this.__store__P_243_0.getModel().getA()); // dispose the store to test the load of the model

          this.__store__P_243_0.dispose();

          model.dispose();

          this.__initDefaultStore__P_243_2();

          this.assertNotNull(this.__store__P_243_0.getModel());
          this.assertEquals("a", this.__store__P_243_0.getModel().getA());
        }.bind(this));
      },
      testModelRead: function testModelRead() {
        this.stub(qx.bom.Storage.getLocal(), "getItem").returns({
          b: "b"
        });

        this.__initDefaultStore__P_243_2();

        this.assertNotUndefined(this.__store__P_243_0.getModel());
        this.assertFunction(this.__store__P_243_0.getModel().getB);
        this.assertEquals("b", this.__store__P_243_0.getModel().getB());
      },
      testUpdateModel: function testUpdateModel() {
        this.__initDefaultStore__P_243_2();

        var model = this.__createDefaultModel__P_243_3();

        this.__store__P_243_0.setModel(model);

        this.wait(1000, function () {
          this.assertEquals("a", this.__store__P_243_0.getModel().getA()); // dispose the store to test the load of the model

          this.__store__P_243_0.dispose();

          model.dispose();

          this.__initDefaultStore__P_243_2();

          this.assertNotNull(this.__store__P_243_0.getModel());

          this.__store__P_243_0.getModel().setA("b");

          this.wait(1000, function () {
            this.assertEquals("b", this.__store__P_243_0.getModel().getA(), "1"); // dispose the store to test the load of the model

            this.__store__P_243_0.dispose();

            this.__initDefaultStore__P_243_2();

            this.assertNotNull(this.__store__P_243_0.getModel());
            this.assertEquals("b", this.__store__P_243_0.getModel().getA(), "2");
          }.bind(this));
        }.bind(this));
      },
      testReplaceModel: function testReplaceModel() {
        this.__initDefaultStore__P_243_2();

        var model1 = this.__createDefaultModel__P_243_3();

        this.__store__P_243_0.setModel(model1);

        var model2 = qx.data.marshal.Json.createModel({
          x: "x"
        }, true);

        this.__store__P_243_0.setModel(model2);

        this.wait(1000, function () {
          this.__initDefaultStore__P_243_2();

          this.assertNotNull(this.__store__P_243_0.getModel());
          this.assertFunction(this.__store__P_243_0.getModel().getX);
          this.assertEquals("x", this.__store__P_243_0.getModel().getX()); // get rid of all the created stuff

          this.__store__P_243_0.dispose();

          model1.dispose();
          model2.dispose();
        }.bind(this));
      },
      testBigModel: function testBigModel() {
        var data = {
          a: [{
            b: 1,
            C: true
          }, 12.567, "a"]
        };
        var model = qx.data.marshal.Json.createModel(data, true);

        this.__initDefaultStore__P_243_2();

        this.__store__P_243_0.setModel(model);

        this.wait(1000, function () {
          this.assertEquals(1, this.__store__P_243_0.getModel().getA().getItem(0).getB());
          this.assertEquals(true, this.__store__P_243_0.getModel().getA().getItem(0).getC());
          this.assertEquals("a", this.__store__P_243_0.getModel().getA().getItem(2));
          model.dispose();
        }.bind(this));
      }
    }
  });
  qx.test.data.store.Offline.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.data.marshal.Json": {},
      "qx.data.store.Rest": {},
      "qx.io.rest.Resource": {},
      "qx.io.request.Xhr": {},
      "qx.io.request.AbstractRequest": {},
      "qx.core.AssertionError": {},
      "qx.dev.unit.RequirementError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  qx.Class.define("qx.test.data.store.Rest", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock, qx.dev.unit.MRequirements],
    members: {
      setUp: function setUp() {
        this.setUpDoubleRequest();
        var marshal = this.marshal = new qx.data.marshal.Json();
        marshal = this.shallowStub(marshal, qx.data.marshal.Json);
        this.injectStub(qx.data.marshal, "Json", marshal);
        marshal.toModel.returns({});
        this.setUpResource();
        this.store = new qx.data.store.Rest(this.res, "index");
      },
      setUpResource: function setUpResource() {
        this.res && this.res.dispose();
        var description = {
          "index": {
            method: "GET",
            url: "/photos"
          }
        };
        return this.res = new qx.io.rest.Resource(description);
      },
      setUpDoubleRequest: function setUpDoubleRequest() {
        var req = this.req = new qx.io.request.Xhr(),
            res = this.res; // Stub request methods, leave event system intact

        req = this.shallowStub(req, qx.io.request.AbstractRequest); // Not dispose stub yet

        this.stub(req, "dispose"); // Inject double and return

        this.injectStub(qx.io.request, "Xhr", req);
        return req;
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();
        this.req.dispose();
        this.marshal.dispose();
        this.res.dispose();
        this.store.dispose();
      },
      "test: construct with res and action name": function testConstructWithResAndActionName() {
        var store = this.store;
        this.assertIdentical(store.getResource(), this.res);
        this.assertIdentical(store.getActionName(), "index");
      },
      "test: construct throws with missing res": function testConstructThrowsWithMissingRes() {
        this.require(["debug"]);

        var store; // Unfortunately, qx.core.Property throws a generic error

        this.assertException(function () {
          store = new qx.data.store.Rest(null, "index");
        }, Error, /property res/);
        store && store.dispose();
      },
      "test: construct throws with erroneous res": function testConstructThrowsWithErroneousRes() {
        this.require(["debug"]);

        var store;
        this.assertException(function () {
          store = new qx.data.store.Rest({}, "index");
        }, qx.core.AssertionError);
        store && store.dispose();
      },
      "test: construct throws with missing action": function testConstructThrowsWithMissingAction() {
        this.require(["debug"]);

        var store,
            res = this.res;
        this.assertException(function () {
          store = new qx.data.store.Rest(res, null);
        }, Error, /property actionName/);
        store && store.dispose();
      },
      "test: add listener for actionSuccess to res": function testAddListenerForActionSuccessToRes() {
        var res = this.res,
            store;
        this.stub(res, "addListener");
        store = new qx.data.store.Rest(res, "index");
        this.assertCalled(res.addListener);
        store.dispose();
      },
      "test: marshal response": function testMarshalResponse() {
        var res = this.res,
            store = this.store,
            marshal = this.marshal,
            data = {
          "key": "value"
        };
        res.index();
        this.respond(data);
        this.assertCalledWith(marshal.toModel, data);
      },
      "test: populates model property with marshaled response": function testPopulatesModelPropertyWithMarshaledResponse() {
        // Do not stub marshal.Json
        qx.data.marshal.Json.restore();
        var res = this.setUpResource(),
            store = new qx.data.store.Rest(res, "index");
        res.index();
        this.respond({
          "name": "Affe"
        }); // this.assertEquals("Affe", store.getModel().getName());

        store.dispose();
      },
      "test: fires changeModel": function testFiresChangeModel() {
        // Do not stub marshal.Json
        qx.data.marshal.Json.restore();
        var res = this.setUpResource(),
            store = new qx.data.store.Rest(res, "index"),
            that = this;
        res.index();
        this.assertEventFired(store, "changeModel", function () {
          that.respond({
            "name": "Affe"
          });
        });
        store.dispose();
        res.dispose();
      },
      "test: configure request with delegate": function testConfigureRequestWithDelegate() {
        var res = this.res,
            req = this.req;
        var configureRequest = this.spy(function (req) {
          req.setUserData("affe", true);
        });
        var delegate = {
          configureRequest: configureRequest
        };
        var store = new qx.data.store.Rest(res, "index", delegate); // Configure before sending

        this.assertNotCalled(req.send);
        res.index();
        this.assertCalledWith(configureRequest, req);
        this.assertTrue(req.getUserData("affe"));
        this.assertCalled(req.send);
        store.dispose();
      },
      "test: manipulate data with delegate before marshaling": function testManipulateDataWithDelegateBeforeMarshaling() {
        var res = this.res,
            data = {
          "name": "Tiger"
        };
        var manipulateData = this.spy(function (data) {
          data.name = "Maus";
          return data;
        });
        var delegate = {
          manipulateData: manipulateData
        };
        var store = new qx.data.store.Rest(res, "index", delegate);
        res.index();
        this.respond(data);
        this.assertCalledWith(manipulateData, data);
        this.assertCalledWith(this.marshal.toModel, {
          "name": "Maus"
        });
        store.dispose();
      },
      hasDebug: function hasDebug() {
        return true;
      },
      // Fake response
      respond: function respond(response) {
        var req = this.req;
        response = response || "";
        req.getPhase.returns("success"); // Set parsed response

        req.getResponse.returns(response);
        req.fireEvent("success");
      },
      skip: function skip(msg) {
        throw new qx.dev.unit.RequirementError(null, msg);
      }
    }
  });
  qx.test.data.store.Rest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.test.io.MRemoteTest": {
        "require": true
      },
      "qx.io.rest.Resource": {},
      "qx.data.store.Rest": {},
      "qx.util.ResponseParser": {},
      "qx.ui.basic.Label": {},
      "qx.dev.unit.RequirementError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/primitive.json)
   */
  qx.Class.define("qx.test.data.store.RestWithRemote", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements, qx.test.io.MRemoteTest],
    members: {
      setUp: function setUp() {
        var url = this.getUrl("qx/test/primitive.json"),
            res = this.res = new qx.io.rest.Resource({
          index: {
            method: "GET",
            url: url
          }
        }),
            store = this.store = new qx.data.store.Rest(res, "index");
        res.configureRequest(function (req) {
          req.setParser(qx.util.ResponseParser.PARSER.json);
        });

        this.require(["http"]);
      },
      tearDown: function tearDown() {
        this.res.dispose();
        this.store.dispose();
      },
      "test: populate store with response of resource action": function testPopulateStoreWithResponseOfResourceAction() {
        var res = this.res,
            store = this.store;
        res.addListener("success", function () {
          this.resume(function () {
            this.assertEquals("String", store.getModel().getString());
          }, this);
        }, this);
        res.index();
        this.wait();
      },
      "test: bind model property": function testBindModelProperty() {
        var res = this.res,
            store = this.store,
            label = new qx.ui.basic.Label();
        res.addListener("success", function () {
          this.resume(function () {
            this.assertEquals("String", label.getValue());
          }, this);
        }, this);
        res.index();
        store.bind("model.string", label, "value");
        this.wait();
      },
      skip: function skip(msg) {
        throw new qx.dev.unit.RequirementError(null, msg);
      }
    }
  });
  qx.test.data.store.RestWithRemote.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.core.Object": {},
      "qx.dev.Debug": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */
  qx.Class.define("qx.test.dev.Debug", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      hasDisposeDebug: function hasDisposeDebug() {
        return false;
      },
      testDisposeProfilingCheckFunction: function testDisposeProfilingCheckFunction() {
        this.require(["disposeDebug"]);

        var n = new qx.core.Object();
        var ignoreHash = n.toHashCode();

        var checkFunction = function checkFunction(object) {
          if (object.toHashCode() == ignoreHash) {
            return false;
          }

          return true;
        };

        var o = new qx.core.Object(); // no need to call startDisposeProfiling - the Testrunner did that already

        var undisposed = qx.dev.Debug.stopDisposeProfiling(checkFunction);
        this.assertArray(undisposed);
        this.assertEquals(1, undisposed.length);
        this.assertEquals(o, undisposed[0].object);
        var stackOk = false;
        this.assertMatch(undisposed[0].stackTrace.join(" "), this.classname);
        n.dispose();
        o.dispose();
      }
    }
  });
  qx.test.dev.Debug.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.StackTrace": {},
      "qx.bom.client.EcmaScript": {},
      "qx.core.Assert": {},
      "qx.type.BaseError": {},
      "qx.core.GlobalError": {},
      "qx.core.WindowError": {},
      "qx.dev.unit.RequirementError": {},
      "qx.lang.Function": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "ecmascript.error.stacktrace": {
          "className": "qx.bom.client.EcmaScript"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */
  qx.Class.define("qx.test.dev.StackTrace", {
    extend: qx.dev.unit.TestCase,
    members: {
      tearDown: function tearDown() {
        qx.dev.StackTrace.FILENAME_TO_CLASSNAME = null;
        qx.dev.StackTrace.FORMAT_STACKTRACE = null;
      },
      testGetStackTraceFromError: function testGetStackTraceFromError() {
        if (!qx.core.Environment.get("ecmascript.error.stacktrace")) {
          this.skip("Test skipped since the client doesn't provide stack traces");
        }

        var trace = [];

        try {
          throw new Error("Expected exception");
        } catch (ex) {
          trace = qx.dev.StackTrace.getStackTraceFromError(ex);
        }

        qx.core.Assert.assertNotEquals(0, trace.length, "No stack trace information returned!");
      },
      testGetStackTraceFromErrorQx: function testGetStackTraceFromErrorQx() {
        if (!qx.core.Environment.get("ecmascript.error.stacktrace")) {
          this.skip("Test skipped since the client doesn't provide stack traces");
        }

        var qxErrorClasses = [qx.type.BaseError, qx.core.GlobalError, qx.core.WindowError, qx.dev.unit.RequirementError];

        for (var i = 0, l = qxErrorClasses.length; i < l; i++) {
          var cls = qxErrorClasses[i];
          var e;

          if (cls.toString().indexOf("GlobalError") > 0) {
            e = new cls(new Error());
          } else {
            e = new cls();
          }

          try {
            throw e;
          } catch (ex) {
            var trace = qx.dev.StackTrace.getStackTraceFromError(ex);
            this.assertNotIdentical(0, trace.length, "Didn't get stack trace from " + cls.toString());
          }
        }
      },
      testFilenameConverterDefault: function testFilenameConverterDefault() {
        var ex = new Error("Just a test");
        var stack = qx.dev.StackTrace.getStackTraceFromError(ex);

        for (var i = 0, l = stack.length; i < l; i++) {
          this.assertMatch(stack[i], /((?:test\.dev\.StackTrace)|(?:dev\.unit)|(?:testrunner\.js)|(?:tests\.js)|(?:qooxdoo-adapter\.js))/);
        }
      },
      testFilenameConverterCustom: function testFilenameConverterCustom() {
        var converter = function converter(fileName) {
          this.assertString(fileName);
          return "FOO";
        };

        qx.dev.StackTrace.FILENAME_TO_CLASSNAME = qx.lang.Function.bind(converter, this);
        var ex = new Error("Just a test");
        var stack = qx.dev.StackTrace.getStackTraceFromError(ex);

        for (var i = 0, l = stack.length; i < l; i++) {
          this.assertMatch(stack[i], /FOO/);
        }
      },
      testFormatStackTrace: function testFormatStackTrace() {
        var formatter = function formatter(trace) {
          this.assertArray(trace);

          for (var i = 0, l = trace.length; i < l; i++) {
            trace[i] = "BAR " + trace[i];
          }

          return trace;
        };

        qx.dev.StackTrace.FORMAT_STACKTRACE = qx.lang.Function.bind(formatter, this);
        var ex = new Error("Just a test");
        var stack = qx.dev.StackTrace.getStackTraceFromError(ex);

        for (var i = 0, l = stack.length; i < l; i++) {
          this.assertMatch(stack[i], /^BAR/);
        }
      }
    }
  });
  qx.test.dev.StackTrace.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.dev.unit.RequirementError": {},
      "qx.core.Environment": {}
    },
    "environment": {
      "provided": ["qx.test.requirement.syncTrue", "qx.test.requirement.syncFalse"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
  
  ************************************************************************ */
  qx.Class.define("qx.test.dev.unit.Requirements", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MRequirements],
    members: {
      hasFulfilledReq: function hasFulfilledReq() {
        return true;
      },
      hasUnfulfilledReq: function hasUnfulfilledReq() {
        return false;
      },
      testRequirementPass: function testRequirementPass() {
        try {
          this.require(["fulfilledReq"]);
        } catch (ex) {
          this.fail("Check for fulfilled requirement failed!");
        }
      },
      testRequirementFail: function testRequirementFail() {
        var self = this;
        this.assertException(function () {
          self.require(["fulfilledReq", "unfulfilledReq"]);
        }, qx.dev.unit.RequirementError);
      },
      testMissingCheck: function testMissingCheck() {
        var self = this;
        this.assertException(function () {
          self.require(["monkeyCheese"]);
        }, Error, /Unable to verify requirement/);
      },
      testEnvironmentPass: function testEnvironmentPass() {
        qx.core.Environment.add("qx.test.requirement.syncTrue", function () {
          return true;
        });

        try {
          this.require(["fulfilledReq", "qx.test.requirement.syncTrue"]);
        } catch (ex) {
          this.fail("Check for environment key failed!");
        }

        delete qx.core.Environment.getChecks()["qx.test.requirement.syncTrue"];
      },
      testEnvironmentFail: function testEnvironmentFail() {
        qx.core.Environment.add("qx.test.requirement.syncFalse", function () {
          return false;
        });
        var self = this;
        this.assertException(function () {
          self.require(["fulfilledReq", "qx.test.requirement.syncFalse"]);
        }, qx.dev.unit.RequirementError);
        delete qx.core.Environment.getChecks()["qx.test.requirement.syncFalse"];
      },
      testEnvironmentAsync: function testEnvironmentAsync() {
        qx.core.Environment.getAsyncChecks()["qx.test.requirement.async"] = function () {
          return false;
        };

        var self = this;
        this.assertException(function () {
          self.require(["qx.test.requirement.async"]);
        }, Error, /Asynchronous environment checks are not supported/);
        delete qx.core.Environment.getAsyncChecks()["qx.test.requirement.async"];
      }
      /* Disabled until we've come up with a solution for bug #5516
      testEnvironmentNonBoolean : function()
      {
        var self = this;
        this.assertException(function() {
          self.require(["browser.name"]);
        }, Error, /value is not boolean/);
      }
      */

    }
  });
  qx.test.dev.unit.Requirements.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.dev.unit.Sinon": {},
      "qx.core.Object": {},
      "qx.bom.client.Browser": {},
      "qx.bom.client.Transport": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "browser.version": {
          "className": "qx.bom.client.Browser"
        },
        "io.xhr": {
          "className": "qx.bom.client.Transport"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /**
   * @ignore(qx.test.PROP, qx.test.Affe, qx.test.Gibbon)
   */

  /**
   * Rudimentary tests to check that Sinon.JS is integrated correctly.
   *
   * Also serves as a collection of examples.
   */
  qx.Class.define("qx.test.dev.unit.Sinon", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock, qx.dev.unit.MRequirements],
    members: {
      sinon: null,

      /**
       * @ignore(qx.test.Animal)
       * @ignore(qx.test.Affe)
       * @ignore(qx.test.Gibbon)
       */
      setUp: function setUp() {
        this.sinon = qx.dev.unit.Sinon.getSinon();
        qx.Class.define("qx.test.Animal", {
          extend: qx.core.Object,
          members: {
            getKind: function getKind() {
              return "Animal";
            }
          }
        });
        qx.Class.define("qx.test.Affe", {
          extend: qx.test.Animal,
          members: {
            scratch: function scratch() {
              return true;
            }
          }
        });
        qx.Class.define("qx.test.Gibbon", {
          extend: qx.test.Affe,
          members: {
            climb: function climb() {
              return true;
            }
          }
        });
      },
      "test: get sinon": function testGetSinon() {
        var sinon = this.sinon;
        this.assertObject(sinon, "Sinon not found");
        this.assertFunction(sinon.spy, "No spy");
        this.assertFunction(sinon.stub, "No stub");
        this.assertFunction(sinon.mock, "No mock");
        this.assertFunction(sinon.useFakeTimers, "No fake timers");
        this.assertFunction(sinon.useFakeXMLHttpRequest, "No fake XHR");
      },
      "test: fail": function testFail() {
        var sinon = this.sinon;
        this.assertException(function () {
          sinon.fail();
        });
      },
      "test: spy": function testSpy() {
        var spy = this.sinon.spy();
        spy();
        this.assertTrue(spy.called);
      },
      "test: spy conveniently": function testSpyConveniently() {
        var spy = this.spy();
        spy();
        this.assertTrue(spy.called);
      },
      "test: stub": function testStub() {
        var whoami = this.sinon.stub();
        whoami.returns("Affe");
        this.assertEquals("Affe", whoami());
      },
      "test: stub conveniently": function testStubConveniently() {
        var whoami = this.stub();
        whoami.returns("Affe");
        this.assertEquals("Affe", whoami());
      },
      "test: stub property": function testStubProperty() {
        qx.test.PROP = false;
        this.stub(qx.test, "PROP", true);
        this.assertEquals(true, qx.test.PROP);
        qx.test.PROP = undefined;
      },
      "test: stub property in isolation": function testStubPropertyInIsolation() {
        qx.test.PROP = false;
        this.stub(qx.test, "PROP", true);
        this.getSandbox().restore();
        this.assertEquals(false, qx.test.PROP);
        qx.test.PROP = undefined;
      },
      "test: stub environment setting": function testStubEnvironmentSetting() {
        var setting = this.stub(qx.core.Environment, "get").withArgs("browser.name");
        setting.returns("My Browser");
        this.assertEquals("My Browser", qx.core.Environment.get("browser.name"));
      },
      "test: stub environment setting in isolation": function testStubEnvironmentSettingInIsolation() {
        var name = qx.core.Environment.get("browser.name"),
            version = qx.core.Environment.get("browser.version"),
            setting = this.stub(qx.core.Environment, "get").withArgs("browser.name");
        setting.returns("My Browser");
        this.getSandbox().restore();
        this.assertEquals(name, qx.core.Environment.get("browser.name"));
        this.assertEquals(version, qx.core.Environment.get("browser.version"));
      },
      "test: mock": function testMock() {
        var obj = {
          method: function method() {}
        };
        var mock = this.sinon.mock(obj);
        mock.expects("method").once();
        obj.method();
        mock.verify();
      },
      "test: mock verify throws": function testMockVerifyThrows() {
        var obj = {
          method: function method() {}
        };
        var mock = this.sinon.mock(obj);
        mock.expects("method").once();
        this.assertException(function () {
          mock.verify();
        });
      },
      "test: mock unexpected use throws": function testMockUnexpectedUseThrows() {
        var obj = {
          method: function method() {}
        };
        var mock = this.sinon.mock(obj);
        mock.expects("method").never();
        this.assertException(function () {
          obj.method();
        }, Error, /Unexpected call/);
      },
      "test: assert": function testAssert() {
        var spy = this.sinon.spy();
        spy();
        this.assertCalled(spy);
      },
      "test: fake XHR": function testFakeXHR() {
        this.require(["xhr"]);

        this.useFakeXMLHttpRequest();
        var nxhr = window.XMLHttpRequest;
        new nxhr();
        var req = this.getRequests()[0];
        this.assertFunction(nxhr.restore, "restore");
        this.assertFunction(req.open, "open");
        this.assertFunction(req.send, "send");
      },
      "test: fake server": function testFakeServer() {
        this.useFakeServer();
        var server = this.getServer();
        this.assertFunction(server.respond);
        this.assertFunction(server.respondWith);
      },
      "test: respond": function testRespond() {
        this.require(["xhr"]);

        this.useFakeServer();
        var nxhr = window.XMLHttpRequest,
            req = new nxhr(),
            server = this.getServer();
        server.respondWith("GET", "found", [200, {}, "FOUND"]);
        req.open("GET", "found");
        req.send();
        server.respond();
        this.assertEquals(200, req.status);
        this.assertEquals("FOUND", req.responseText);
      },
      "test: respond with invalid XML": function testRespondWithInvalidXML() {
        this.require(["xhr"]);

        this.useFakeXMLHttpRequest();
        var nxhr = window.XMLHttpRequest,
            req = new nxhr(),
            fakeReq = this.getRequests()[0];
        req.open();
        req.send();
        fakeReq.respond(200, {
          "Content-Type": "application/xml"
        }, "INVALID");
      },
      "test: sandbox and restore": function testSandboxAndRestore() {
        var func = function func() {};

        var obj = {
          "a": function a() {}
        };
        var spy = this.spy(func);
        var stub = this.stub(obj, "a");
        var xhr = this.useFakeXMLHttpRequest();
        var nxhr = window.XMLHttpRequest || window.ActiveXObject("Microsoft.XMLHTTP");
        this.getSandbox().restore();
        this.assertUndefined(func.called);
        this.assertUndefined(obj.a.called);
        this.assertUndefined(nxhr.restore);
      },
      "test: deep stub": function testDeepStub() {
        var obj = new qx.test.Affe();
        obj = this.deepStub(obj);
        obj.getKind();
        this.assertCalled(obj.getKind);
        obj.dispose();
      },
      "test: shallow stub": function testShallowStub() {
        var obj = new qx.test.Gibbon();
        obj = this.shallowStub(obj, qx.test.Affe);
        obj.climb();
        obj.scratch();
        this.assertCalled(obj.climb);
        this.assertCalled(obj.scratch); // Not stubbed

        this.assertEquals("Animal", obj.getKind(), "Must return original");
        this.assertUndefined(obj.getKind.called, "Must not be stubbed");
        obj.dispose();
      },
      "test: inject stub of original": function testInjectStubOfOriginal() {
        this.injectStub(qx.test, "Affe");
        var affe = new qx.test.Affe();
        affe.scratch.returns(false);
        this.assertFalse(affe.scratch());
        affe.dispose();
      },
      "test: inject stub of original and return": function testInjectStubOfOriginalAndReturn() {
        var stub = this.injectStub(qx.test, "Affe"),
            affe = new qx.test.Affe();
        stub.scratch.returns(false);
        this.assertFalse(affe.scratch());
        affe.dispose();
      },
      "test: inject custom stub": function testInjectCustomStub() {
        this.injectStub(qx.test, "Affe", this.stub({
          dance: function dance() {}
        }));
        var affe = new qx.test.Affe();
        affe.dance();
        this.assertCalled(affe.dance);
      },
      "test: inject custom stub and return": function testInjectCustomStubAndReturn() {
        var stub = this.injectStub(qx.test, "Affe", this.stub({
          dance: function dance() {}
        })),
            affe = new qx.test.Affe();
        affe.dance();
        this.assertCalled(stub.dance);
      },
      "test: reveal mock of original and return": function testRevealMockOfOriginalAndReturn() {
        var mock = this.revealMock(qx.test, "Affe"),
            affe = new qx.test.Affe();
        mock.expects("scratch").once();
        affe.scratch();
        mock.verify();
        affe.dispose();
      },
      "test: reveal mock of custom and return": function testRevealMockOfCustomAndReturn() {
        var mock = this.revealMock(qx.test, "Affe", {
          dance: function dance() {}
        }),
            affe = new qx.test.Affe();
        mock.expects("dance").once();
        affe.dance();
        mock.verify();
      },
      hasXhr: function hasXhr() {
        return qx.core.Environment.get("io.xhr") === "xhr";
      },
      tearDown: function tearDown() {
        this.getSandbox().restore();
        this.sinon = null;
        qx.Class.undefine("qx.test.Affe");
        qx.Class.undefine("qx.test.Animal");
        qx.Class.undefine("qx.test.Gibbon");
      }
    }
  });
  qx.test.dev.unit.Sinon.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
  
  ************************************************************************ */
  qx.Class.define("qx.test.dev.unit.TestCase", {
    extend: qx.dev.unit.TestCase,
    members: {
      testSkip: function testSkip() {
        this.skip();
        this.fail("Executed code after calling skip()!");
      },
      testResumeHandler: function testResumeHandler() {
        this.__do__P_244_0(this.resumeHandler(function (param) {
          this.assertEquals(param, "foo");
          return "bar";
        }, this));

        this.wait();
      },
      __do__P_244_0: function __do__P_244_0(callback) {
        window.setTimeout(this.__doSuccess__P_244_1.bind(this, callback), 0);
      },
      __doSuccess__P_244_1: function __doSuccess__P_244_1(callback) {
        var result = callback("foo");
        this.assertEquals(result, "bar");
      }
    }
  });
  qx.test.dev.unit.TestCase.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.element.Attribute": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /*******************************************************************************
   *
   * qooxdoo - the new era of web development
   *
   * http://qooxdoo.org
   *
   * Copyright: 2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
   *
   * License:
   *    MIT: https://opensource.org/licenses/MIT
   *    See the LICENSE file in the project's top-level directory for details.
   *
   * Authors: Fabian Jakobs (fjakobs)
   *
   ******************************************************************************/
  qx.Class.define("qx.test.dom.Element", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        var div = document.createElement("div");
        div.id = "el";
        this._el = div;
        document.body.appendChild(div);
      },
      tearDown: function tearDown() {
        document.body.removeChild(this._el);
      },
      testCreate: function testCreate() {
        var el = qx.dom.Element.create("div", {
          name: "juhu"
        }, window);
        this.assertElement(el);
        this.assertEquals("juhu", qx.bom.element.Attribute.get(el, "name"));
      },
      testEmpty: function testEmpty() {
        this._el.innerHTML = "Juhu";
        qx.dom.Element.empty(this._el);
        this.assertEquals("", this._el.innerHTML);
      }
    }
  });
  qx.test.dom.Element.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.element.Style": {},
      "qx.dom.Hierarchy": {},
      "qx.bom.Iframe": {},
      "qx.util.ResourceManager": {},
      "qx.util.Uri": {},
      "qx.event.Registration": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  qx.Class.define("qx.test.dom.Hierarchy", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.__renderedElement__P_245_0 = qx.dom.Element.create("div");
        document.body.appendChild(this.__renderedElement__P_245_0);
        this.__unRenderedElement__P_245_1 = qx.dom.Element.create("div");
        this.__notDisplayedElement__P_245_2 = qx.dom.Element.create("div");
        document.body.appendChild(this.__notDisplayedElement__P_245_2);
        qx.bom.element.Style.set(this.__notDisplayedElement__P_245_2, "display", "none");
        this.__childOfNotDisplayedElement__P_245_3 = qx.dom.Element.create("div");

        this.__notDisplayedElement__P_245_2.appendChild(this.__childOfNotDisplayedElement__P_245_3);
      },
      tearDown: function tearDown() {
        if (this.__childElement__P_245_4) {
          this.__renderedElement__P_245_0.removeChild(this.__childElement__P_245_4);

          this.__childElement__P_245_4 = null;
        }

        if (this.__siblingElement__P_245_5) {
          document.body.removeChild(this.__siblingElement__P_245_5);
          this.__siblingElement__P_245_5 = null;
        }

        document.body.removeChild(this.__renderedElement__P_245_0);
        this.__renderedElement__P_245_0 = null;
        this.__unRenderedElement__P_245_1 = null;
        document.body.removeChild(this.__notDisplayedElement__P_245_2);
        this.__notDisplayedElement__P_245_2 = null;

        if (this.__iframe__P_245_6) {
          document.body.removeChild(this.__iframe__P_245_6);
          this.__iframe__P_245_6 = null;
        }
      },
      testIsRendered: function testIsRendered() {
        this.assertTrue(qx.dom.Hierarchy.isRendered(this.__renderedElement__P_245_0));
        this.assertFalse(qx.dom.Hierarchy.isRendered(this.__unRenderedElement__P_245_1));
        this.assertTrue(qx.dom.Hierarchy.isRendered(this.__notDisplayedElement__P_245_2));
        this.assertTrue(qx.dom.Hierarchy.isRendered(this.__childOfNotDisplayedElement__P_245_3));
      },
      testIsRenderedIframe: function testIsRenderedIframe() {
        this.__iframe__P_245_6 = qx.bom.Iframe.create();
        var src = qx.util.ResourceManager.getInstance().toUri("qx/static/blank.html");
        src = qx.util.Uri.getAbsolute(src);
        qx.bom.Iframe.setSource(this.__iframe__P_245_6, src);
        document.body.appendChild(this.__iframe__P_245_6);
        qx.event.Registration.addListener(this.__iframe__P_245_6, "load", function (e) {
          this.resume(function () {
            this.assertTrue(qx.dom.Hierarchy.isRendered(this.__iframe__P_245_6));
          }, this);
        }, this);
        this.wait(10000);
      },
      testContains: function testContains() {
        this.assertTrue(qx.dom.Hierarchy.contains(document.body, this.__renderedElement__P_245_0));
        this.__childElement__P_245_4 = qx.dom.Element.create("div");

        this.__renderedElement__P_245_0.appendChild(this.__childElement__P_245_4);

        this.assertTrue(qx.dom.Hierarchy.contains(this.__renderedElement__P_245_0, this.__childElement__P_245_4));
        this.assertFalse(qx.dom.Hierarchy.contains(this.__childElement__P_245_4, this.__renderedElement__P_245_0));
        this.__siblingElement__P_245_5 = qx.dom.Element.create("div");
        document.body.appendChild(this.__siblingElement__P_245_5);
        this.assertFalse(qx.dom.Hierarchy.contains(this.__renderedElement__P_245_0, this.__siblingElement__P_245_5));
      },
      testGetCommonParent: function testGetCommonParent() {
        this.__siblingElement__P_245_5 = qx.dom.Element.create("div");
        document.body.appendChild(this.__siblingElement__P_245_5);
        this.assertEquals(document.body, qx.dom.Hierarchy.getCommonParent(this.__renderedElement__P_245_0, this.__siblingElement__P_245_5));
        this.__childElement__P_245_4 = qx.dom.Element.create("div");

        this.__renderedElement__P_245_0.appendChild(this.__childElement__P_245_4);

        this.assertEquals(this.__renderedElement__P_245_0, qx.dom.Hierarchy.getCommonParent(this.__renderedElement__P_245_0, this.__childElement__P_245_4));
      }
    }
  });
  qx.test.dom.Hierarchy.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dom.Node": {},
      "qx.xml.Document": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.dom.Node", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {},
      tearDown: function tearDown() {},
      testBlockNodes: function testBlockNodes() {
        var blockNodeList = ["body", "h1", "h2", "h3", "h4", "h5", "div", "blockquote", "hr", "form", "textarea", "fieldset", "iframe", "ul", "ol", "li", "dl", "dt", "dd", "p", "quote", "pre", "table", "thead", "tbody", "tfoot", "tr", "td", "th", "iframe", "address"];
        var blockElement;
        var blockElements = [];

        for (var i = 0, j = blockNodeList.length; i < j; i++) {
          blockElement = document.createElement(blockNodeList[i]);
          document.body.appendChild(blockElement);
          blockElements.push(blockElement);
          this.info("Testing node " + qx.dom.Node.getName(blockElement));
          this.assertTrue(qx.dom.Node.isBlockNode(blockElement));
        }

        for (var i = 0, j = blockElements.length; i < j; i++) {
          document.body.removeChild(blockElements[i]);
        }
      },
      testInlineNodes: function testInlineNodes() {
        var inlineNodeList = ["a", "span", "abbr", "acronym", "dfn", "object", "param", "em", "strong", "code", "b", "i", "tt", "samp", "kbd", "var", "big", "small", "br", "bdo", "cite", "del", "ins", "q", "sub", "sup", "img", "map"];
        var inlineElement;
        var inlineElements = [];

        for (var i = 0, j = inlineNodeList.length; i < j; i++) {
          inlineElement = document.createElement(inlineNodeList[i]);
          document.body.appendChild(inlineElement);
          inlineElements.push(inlineElement);
          this.info("Testing node " + qx.dom.Node.getName(inlineElement));
          this.assertFalse(qx.dom.Node.isBlockNode(inlineElement));
        }

        for (var i = 0, j = inlineElements.length; i < j; i++) {
          document.body.removeChild(inlineElements[i]);
        }
      },
      testTextNodes: function testTextNodes() {
        var blockElement = document.createElement("div");
        var blockElementText = document.createTextNode("schokobaer");
        blockElement.appendChild(blockElementText);
        var innerElement = document.createElement("span");
        blockElement.appendChild(innerElement);
        var innerTextNode = document.createTextNode("vanillebaer");
        innerElement.appendChild(innerTextNode);
        document.body.appendChild(blockElement);
        var data = "<Root><foo></foo></Root>";
        var xml = qx.xml.Document.fromString(data);
        var cdataElement = xml.createCDATASection("karamelbaer");
        xml.getElementsByTagName("foo")[0].appendChild(cdataElement);
        this.assertEquals("vanillebaer", qx.dom.Node.getText(innerTextNode), "Failed to get the right value for one text node.");
        this.assertEquals("schokobaervanillebaer", qx.dom.Node.getText(blockElement), "Failed to get the right value for text of an element.");
        this.assertEquals("karamelbaer", qx.dom.Node.getText(xml.getElementsByTagName("foo")[0].firstChild), "Failed to get the text of a CData text node.");
      },
      testGetWindow: function testGetWindow() {
        var rendered = document.createElement("div");
        document.body.appendChild(rendered);
        var unrendered = document.createElement("div");
        var text = document.createTextNode("affe");
        this.assertEquals(window, qx.dom.Node.getWindow(rendered));
        this.assertEquals(window, qx.dom.Node.getWindow(unrendered));
        this.assertEquals(window, qx.dom.Node.getWindow(text));
      }
    }
  });
  qx.test.dom.Node.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.test.event.MockBubblingHandler": {},
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.event.Registration": {},
      "qx.event.type.Event": {},
      "qx.core.AssertionError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @use(qx.test.event.MockBubblingHandler)
   */
  qx.Class.define("qx.test.event.Bubbling", {
    extend: qx.dev.unit.TestCase,
    events: {
      "nonBubble": "qx.event.type.Event"
    },
    members: {
      setUp: function setUp() {
        var root = qx.dom.Element.create("div", {
          id: "root"
        });
        document.body.appendChild(root); // root
        //   c_1
        //     c_1_1
        //   c_2

        root.innerHTML = "<div id='c_1'><div id='c_1_1'></div></div><div id='c_2'>";
        this.c_1 = document.getElementById("c_1");
        this.c_1_1 = document.getElementById("c_1_1");
        this.c_2 = document.getElementById("c_2");
      },
      tearDown: function tearDown() {
        var Reg = qx.event.Registration;
        Reg.removeAllListeners(this.c_1);
        Reg.removeAllListeners(this.c_1_1);
        Reg.removeAllListeners(this.c_2);
        document.body.removeChild(document.getElementById("root"));
      },
      testBubbling: function testBubbling() {
        var Reg = qx.event.Registration;
        var called;
        Reg.addListener(this.c_1, "bubble", function () {
          called.push("c_1a");
        }, this);
        Reg.addListener(this.c_1, "bubble", function () {
          called.push("c_1b");
        }, this);
        Reg.addListener(this.c_1_1, "bubble", function () {
          called.push("c_1_1a");
        }, this);
        Reg.addListener(this.c_1_1, "bubble", function () {
          called.push("c_1_1b");
        }, this);
        Reg.addListener(this.c_2, "bubble", function () {
          called.push("c_2a");
        }, this);
        Reg.addListener(this.c_2, "bubble", function () {
          called.push("c_2b");
        }, this); // fire event on c_1

        called = [];
        Reg.fireEvent(this.c_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_1a", "c_1b"], called); // fire event on c_1_1

        called = [];
        Reg.fireEvent(this.c_1_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_1_1a", "c_1_1b", "c_1a", "c_1b"], called); // fire event on c_2

        called = [];
        Reg.fireEvent(this.c_2, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_2a", "c_2b"], called);
      },
      testContext: function testContext() {
        var Reg = qx.event.Registration;
        var called;
        var contexts;
        Reg.addListener(this.c_1, "bubble", function () {
          called.push("c_1");
          contexts.push(this);
        });
        Reg.addListener(this.c_1_1, "bubble", function () {
          called.push("c_1_1a");
          contexts.push(this);
        });
        Reg.addListener(this.c_1_1, "bubble", function () {
          called.push("c_1_1b");
          contexts.push(this);
        }, this);
        called = [];
        contexts = [];
        Reg.fireEvent(this.c_1_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_1_1a", "c_1_1b", "c_1"], called);
        this.assertEquals(3, contexts.length);
        this.assertEquals(this.c_1_1, contexts[0]);
        this.assertEquals(this, contexts[1]);
        this.assertEquals(this.c_1, contexts[2]);
      },
      testCapture: function testCapture() {
        var Reg = qx.event.Registration;
        var called;
        Reg.addListener(this.c_1, "bubble", function () {
          called.push("c_1a");
        }, this, true);
        Reg.addListener(this.c_1, "bubble", function () {
          called.push("c_1b");
        }, this);
        Reg.addListener(this.c_1_1, "bubble", function () {
          called.push("c_1_1a");
        }, this, true);
        Reg.addListener(this.c_1_1, "bubble", function () {
          called.push("c_1_1b");
        }, this);
        Reg.addListener(this.c_2, "bubble", function () {
          called.push("c_2a");
        }, this, true);
        Reg.addListener(this.c_2, "bubble", function () {
          called.push("c_2b");
        }, this); // fire event on c_1

        called = [];
        Reg.fireEvent(this.c_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_1a", "c_1b"], called); // fire event on c_1_1

        called = [];
        Reg.fireEvent(this.c_1_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_1a", "c_1_1a", "c_1_1b", "c_1b"], called); // fire event on c_2

        called = [];
        Reg.fireEvent(this.c_2, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_2a", "c_2b"], called);
      },
      _stopPropagation: function _stopPropagation(e) {
        e.stopPropagation();
      },
      testStopPropagation: function testStopPropagation() {
        var Reg = qx.event.Registration;
        var called; // stop is first handler (capturing) -> handlers on the same level must be called

        Reg.addListener(this.c_1, "bubble", this._stopPropagation, this, true);
        Reg.addListener(this.c_1, "bubble", function () {
          called.push("c_1a");
        }, this, true);
        Reg.addListener(this.c_1, "bubble", function () {
          called.push("c_1b");
        }, this);
        Reg.addListener(this.c_1_1, "bubble", function () {
          called.push("c_1_1a");
        }, this, true);
        Reg.addListener(this.c_1_1, "bubble", function () {
          called.push("c_1_1b");
        }, this);
        Reg.addListener(this.c_2, "bubble", function () {
          called.push("c_2a");
        }, this, true);
        Reg.addListener(this.c_2, "bubble", function () {
          called.push("c_2b");
        }, this); // fire event on c_1

        called = [];
        Reg.fireEvent(this.c_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_1a"], called); // fire event on c_1_1

        called = [];
        Reg.fireEvent(this.c_1_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_1a"], called); // fire event on c_2

        called = [];
        Reg.fireEvent(this.c_2, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_2a", "c_2b"], called); // stop is on target (capturing)

        Reg.removeListener(this.c_1, "bubble", this._stopPropagation, this, true);
        Reg.addListener(this.c_1_1, "bubble", this._stopPropagation, this, true); // fire event on c_1

        called = [];
        Reg.fireEvent(this.c_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_1a", "c_1b"], called); // fire event on c_1_1

        called = [];
        Reg.fireEvent(this.c_1_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_1a", "c_1_1a"], called); // fire event on c_2

        called = [];
        Reg.fireEvent(this.c_2, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_2a", "c_2b"], called); // stop is on target (bubbling)

        Reg.removeListener(this.c_1_1, "bubble", this._stopPropagation, this, true);
        Reg.addListener(this.c_1_1, "bubble", this._stopPropagation, this, false); // fire event on c_1

        called = [];
        Reg.fireEvent(this.c_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_1a", "c_1b"], called); // fire event on c_1_1

        called = [];
        Reg.fireEvent(this.c_1_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_1a", "c_1_1a", "c_1_1b"], called); // fire event on c_2

        called = [];
        Reg.fireEvent(this.c_2, "bubble", qx.event.type.Event, [true, true]);
        this.assertJsonEquals(["c_2a", "c_2b"], called);
      },
      _preventDefault: function _preventDefault(e) {
        e.preventDefault();
      },
      testPreventDefault: function testPreventDefault() {
        var Reg = qx.event.Registration;
        var called; // baseline: no prevent default

        Reg.addListener(this.c_1, "bubble", function () {
          called.push("c_1a");
        }, this);
        Reg.addListener(this.c_1_1, "bubble", function () {
          called.push("c_1_1a");
        }, this);
        called = [];
        var prevent = Reg.fireEvent(this.c_1_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertTrue(prevent);
        this.assertJsonEquals(["c_1_1a", "c_1a"], called); // prevent default on parent

        Reg.addListener(this.c_1, "bubble", this._preventDefault, this);
        called = [];
        var prevent = Reg.fireEvent(this.c_1_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertFalse(prevent);
        this.assertJsonEquals(["c_1_1a", "c_1a"], called); // stop propagation before prevent default can be called

        Reg.addListener(this.c_1_1, "bubble", this._stopPropagation, this);
        called = [];
        var prevent = Reg.fireEvent(this.c_1_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertTrue(prevent);
        this.assertJsonEquals(["c_1_1a"], called);
        Reg.removeListener(this.c_1_1, "bubble", this._stopPropagation, this); // prevent default on target

        Reg.removeListener(this.c_1, "bubble", this._preventDefault, this);
        Reg.addListener(this.c_1_1, "bubble", this._preventDefault, this);
        called = [];
        var prevent = Reg.fireEvent(this.c_1_1, "bubble", qx.event.type.Event, [true, true]);
        this.assertFalse(prevent);
        this.assertJsonEquals(["c_1_1a", "c_1a"], called); // test on non bubbling events

        this.addListener("nonBubble", this._preventDefault, this);
        var prevent = Reg.fireEvent(this, "nonBubble", qx.event.type.Event, [false, true]);
        this.assertFalse(prevent);
        this.removeListener("nonBubble", this._preventDefault, this); // assert that non cancelable event raise an exception

        this.addListener("nonBubble", this._preventDefault, this);
        var self = this;

        if (this.isDebugOn()) {
          this.assertException(function () {
            Reg.fireEvent(self, "nonBubble", qx.event.type.Event, [false, false]);
          }, qx.core.AssertionError, "Cannot prevent default action on a non cancelable event.*");
        }

        ;
        this.removeListener("nonBubble", this._preventDefault, this); // fire event with no listener -> should never be prevented

        var prevent = Reg.fireEvent(this, "nonBubble", qx.event.type.Event, [false, true]);
        this.assertTrue(prevent);
      }
    }
  });
  qx.test.event.Bubbling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.event.IEventHandler": {
        "require": true
      },
      "qx.event.Registration": {
        "defer": "runtime",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.MockBubblingHandler", {
    extend: qx.core.Object,
    implement: qx.event.IEventHandler,
    statics: {
      /** @type {Integer} Priority of this handler */
      PRIORITY: qx.event.Registration.PRIORITY_LAST
    },
    members: {
      // interface implementation
      canHandleEvent: function canHandleEvent(target, type) {
        return target.nodeType !== undefined;
      },
      // interface implementation
      registerEvent: function registerEvent(target, type, capture) {},
      // interface implementation
      unregisterEvent: function unregisterEvent(target, type, capture) {}
    },
    defer: function defer(statics) {
      qx.event.Registration.addHandler(statics);
    }
  });
  qx.test.event.MockBubblingHandler.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.event.Emitter": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.Emitter", {
    extend: qx.dev.unit.TestCase,
    include: [qx.dev.unit.MMock, qx.dev.unit.MRequirements],
    members: {
      __ee__P_246_0: null,
      setUp: function setUp() {
        this.__ee__P_246_0 = new qx.event.Emitter();
      },
      testOnOff: function testOnOff() {
        var spy = this.spy();

        this.__ee__P_246_0.on("test", spy, this);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);
        this.assertCalledOn(spy, this);

        this.__ee__P_246_0.off("test", spy, this);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);
      },
      testOnOffById: function testOnOffById() {
        var spy = this.spy();

        var id = this.__ee__P_246_0.on("test", spy, this);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);

        this.__ee__P_246_0.offById(id);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);
      },
      testOffReturnId: function testOffReturnId() {
        var spy = this.spy();

        this.__ee__P_246_0.on("test", spy, this);

        var id = this.__ee__P_246_0.on("test2", spy, this);

        var returnId = this.__ee__P_246_0.off("test2", spy, this);

        this.assertEquals(id, returnId);
      },
      testAddRemove: function testAddRemove() {
        var spy = this.spy();

        this.__ee__P_246_0.addListener("test", spy, this);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);

        this.__ee__P_246_0.removeListener("test", spy, this);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);
      },

      /**
       * @lint ignoreDeprecated(alert, eval)
       */
      testAddAsyncFunction: function testAddAsyncFunction() {
        this.require(["asyncFunctions"]);

        var f = eval("f = async function(){};");

        this.__ee__P_246_0.addListener("test", f, this);

        this.__ee__P_246_0.emit("test");

        this.__ee__P_246_0.removeListener("test", f, this);

        this.__ee__P_246_0.emit("test");
      },
      testAddRemoveById: function testAddRemoveById() {
        var spy = this.spy();

        var id = this.__ee__P_246_0.addListener("test", spy, this);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);

        this.__ee__P_246_0.removeListenerById(id);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);
      },
      testOnTwoListeners: function testOnTwoListeners() {
        var spy1 = this.spy();
        var spy2 = this.spy();

        this.__ee__P_246_0.on("test", spy1);

        this.__ee__P_246_0.on("test", spy2);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy1);
        this.assertCalledOnce(spy2);

        this.__ee__P_246_0.off("test", spy1);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy1);
        this.assertCalledTwice(spy2);
      },
      testTwoEvents: function testTwoEvents() {
        var spy1 = this.spy();
        var spy2 = this.spy();

        this.__ee__P_246_0.on("test1", spy1);

        this.__ee__P_246_0.on("test2", spy2);

        this.__ee__P_246_0.emit("test1");

        this.assertCalledOnce(spy1);
        this.assertNotCalled(spy2);

        this.__ee__P_246_0.emit("test2");

        this.assertCalledOnce(spy1);
        this.assertCalledOnce(spy2);
      },
      testOnce: function testOnce() {
        var spy = this.spy();

        this.__ee__P_246_0.once("test", spy);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);
      },
      testAddListenerOnce: function testAddListenerOnce() {
        var spy = this.spy();

        this.__ee__P_246_0.addListenerOnce("test", spy);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);
      },
      testOnAny: function testOnAny() {
        var spy = this.spy();

        this.__ee__P_246_0.on("*", spy);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);

        this.__ee__P_246_0.emit("test2");

        this.assertCalledTwice(spy);
      },
      testAddListenerAny: function testAddListenerAny() {
        var spy = this.spy();

        this.__ee__P_246_0.addListener("*", spy);

        this.__ee__P_246_0.emit("test");

        this.assertCalledOnce(spy);

        this.__ee__P_246_0.emit("test2");

        this.assertCalledTwice(spy);
      },
      testEmitData: function testEmitData() {
        var spy = this.spy();

        this.__ee__P_246_0.on("test", spy);

        this.__ee__P_246_0.emit("test", 123);

        this.assertCalledWith(spy, 123);
      },
      testEmitOrder: function testEmitOrder() {
        var i = 0;

        this.__ee__P_246_0.on("test", function () {
          i++;
          this.assertEquals(1, i);
        }, this);

        this.__ee__P_246_0.on("test", function () {
          i++;
          this.assertEquals(2, i);
        }, this);

        this.__ee__P_246_0.emit("test");

        this.assertEquals(2, i);
      }
    }
  });
  qx.test.event.Emitter.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.event.GlobalError": {},
      "qx.core.WindowError": {},
      "qx.bom.client.Engine": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.globalErrorHandling": {
          "className": "qx.event.GlobalError"
        },
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.GlobalError", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MRequirements,
    members: {
      hasGlobalErrorHandling: function hasGlobalErrorHandling() {
        return !!qx.core.Environment.get("qx.globalErrorHandling");
      },
      hasNoGlobalErrorHandling: function hasNoGlobalErrorHandling() {
        return !this.hasGlobalErrorHandling();
      },
      setUp: function setUp() {
        this.errorHandler = qx.event.GlobalError;
        this.called = false;
        this.calledParams = [];
        this.errorHandler.setErrorHandler(this.onError, this);
      },
      tearDown: function tearDown() {
        this.errorHandler.setErrorHandler(null);

        if (window.onerror) {
          window.onerror = null;
        }
      },
      onError: function onError(ex) {
        this.assertEquals(1, arguments.length);
        this.called = true;
        this.calledParams.push(ex);
      },
      testObserveMethod: function testObserveMethod() {
        this.require(["GlobalErrorHandling"]);

        var fail = function fail() {
          throw new Error("fail");
        };

        var wrappedFail = this.errorHandler.observeMethod(fail);
        this.assertFalse(this.called);
        wrappedFail();
        this.assertTrue(this.called);
      },
      testDontWrapIfSettingIsOff: function testDontWrapIfSettingIsOff() {
        this.require(["NoGlobalErrorHandling"]);

        var fcn = function fcn() {};

        var wrapped = this.errorHandler.observeMethod(fcn);
        this.assertIdentical(fcn, wrapped);
      },
      testWrappedParameterAndReturnValue: function testWrappedParameterAndReturnValue() {
        this.require(["GlobalErrorHandling"]);

        var fcn = function fcn(a, b, c) {
          var args = [a, b, c];
          return args;
        };

        var wrapped = this.errorHandler.observeMethod(fcn);
        this.assertJsonEquals(fcn(1, "2", true), wrapped(1, "2", true));
      },
      testObserveMethodButNoHandler: function testObserveMethodButNoHandler() {
        this.require(["GlobalErrorHandling"]);

        var fail = function fail() {
          throw new Error("fail");
        };

        var wrappedFail = this.errorHandler.observeMethod(fail);
        this.errorHandler.setErrorHandler(null, null);
        this.assertException(wrappedFail);
        this.errorHandler.setErrorHandler(this.onError, this);
        wrappedFail();
      },
      testHandlerContext: function testHandlerContext() {
        this.require(["GlobalErrorHandling"]);

        var fail = function fail() {
          throw new Error("fail");
        };

        var self = null;

        var handler = function handler(ex) {
          self = this;
        };

        this.errorHandler.setErrorHandler(handler, this);
        var wrappedFail = this.errorHandler.observeMethod(fail);
        wrappedFail();
        this.assertEquals(this, self);
      },
      testHandleError: function testHandleError() {
        this.require(["GlobalErrorHandling"]);

        var error = new Error("New Error");
        this.errorHandler.handleError(error);
        this.assertTrue(this.called);
        this.assertEquals(error, this.calledParams[0]);
      },
      testOnWindowError: function testOnWindowError() {
        this.require(["GlobalErrorHandling"]); // reset the handler


        this.errorHandler.setErrorHandler(null);
        var wasHandled = false;

        var handler = function handler(ex) {
          this.resume(function () {
            wasHandled = true;
            this.assertInstance(ex, qx.core.WindowError);
            this.assertMatch(ex.toString(), "Doofer Fehler");
            this.assertString(ex.getUri());
            this.assertInteger(ex.getLineNumber()); // this.debug(ex.toString() + " at " + ex.getUri() + ":" + ex.getLineNumber());
          }, this);
        };

        this.errorHandler.setErrorHandler(handler, this); // callback is NOT wrapped!

        window.setTimeout(function () {
          throw new Error("Doofer Fehler");
        }, 0); // Opera and Webkit do not support window.onerror
        // make sure the test fails once they support it

        var self = this;
        window.setTimeout(function () {
          if (wasHandled) {
            return;
          }

          self.resume(function () {
            if (qx.core.Environment.get("engine.name") == "opera" || qx.core.Environment.get("engine.name") == "webkit") {
              this.warn("window.onerror is not supported by Opera and Webkit");
            } else {
              this.fail("window.onerror should be supported! Note: this test fails in IE if the debugger is active!");
            }
          }, self);
        }, 100);
        this.wait(500);
      },
      testOnWindowErrorWrapped: function testOnWindowErrorWrapped() {
        this.require(["GlobalErrorHandling"]); // reset error handler on startup


        this.errorHandler.setErrorHandler(null);
        var wasHandled = false;
        var wasNativeHandled = false;
        var self = this;
        var originalMsg = null;
        var originalUri = null;
        var originalLineNumber = null; // append a native onerror method

        window.onerror = function (msg, uri, lineNumber) {
          wasNativeHandled = true;
          self.assertMatch(msg, "Doofer Fehler");
          self.assertString(uri);
          self.assertInteger(lineNumber);
          originalMsg = msg;
          originalUri = uri;
          originalLineNumber = lineNumber;
        };

        var handler = function handler(ex) {
          this.resume(function () {
            wasHandled = true;
            this.assertTrue(wasNativeHandled, "native handler not called.");
            this.assertInstance(ex, qx.core.WindowError);
            this.assertEquals(originalMsg, ex.toString());
            this.assertEquals(originalUri, ex.getUri());
            this.assertEquals(originalLineNumber, ex.getLineNumber()); // this.debug(ex.toString() + " at " + ex.getUri() + ":" + ex.getLineNumber());
          }, this);
        };

        this.errorHandler.setErrorHandler(handler, this); // callback is NOT wrapped!

        window.setTimeout(function () {
          throw new Error("Doofer Fehler");
        }, 0); // Opera and Webkit do not support window.onerror
        // make sure the test fails once they support it

        var self = this;
        window.setTimeout(function () {
          if (wasHandled) {
            return;
          }

          self.resume(function () {
            if (qx.core.Environment.get("engine.name") == "opera" || qx.core.Environment.get("engine.name") == "webkit") {
              this.warn("window.onerror is not supported by Opera and Webkit");
            } else {
              this.fail("window.onerror should be supported! Note: this test fails in IE if the debugger is active!");
            }
          }, self);
        }, 100);
        this.wait(500);
      }
    }
  });
  qx.test.event.GlobalError.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MRequirements": {
        "require": true
      },
      "qx.event.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.GlobalEventMonitors", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MRequirements,
    events: {
      "test": "qx.event.type.Event"
    },
    members: {
      setUp: function setUp() {
        this.called = false;
      },
      tearDown: function tearDown() {
        qx.event.Manager.resetGlobalEventMonitors();
      },
      "test: add and call global event monitors": function testAddAndCallGlobalEventMonitors() {
        qx.event.Manager.addGlobalEventMonitor(function (target, event) {
          this.assertEquals(this, target);
          this.assertEquals("test", event.getType());
          this.called = true;
        }, this);
        this.fireEvent("test");
        this.assertTrue(this.called, "Monitor function was not called");
      },
      "test: remove global event monitor": function testRemoveGlobalEventMonitor() {
        this.value = false;

        var fn1 = function fn1() {
          this.value = true;
        };

        var fn2 = function fn2() {
          this.value = false;
        };

        qx.event.Manager.addGlobalEventMonitor(fn1, this);
        this.fireEvent("test");
        this.assertTrue(this.value, "Value should be true after adding fn1");
        qx.event.Manager.addGlobalEventMonitor(fn2, this);
        this.fireEvent("test");
        this.assertFalse(this.value, "Value should be false after adding fn2");
        qx.event.Manager.removeGlobalEventMonitor(fn2, this);
        this.fireEvent("test");
        this.assertTrue(this.value, "Value should be true after removing fn2");
      },
      "test: disallow event manipulation": function testDisallowEventManipulation() {
        var errorWasThrown = false;
        qx.event.Manager.addGlobalEventMonitor(function (target, event) {
          event.preventDefault();
        }, this);

        try {
          this.fireEvent("test");
        } catch (e) {
          errorWasThrown = true;
        }

        this.assertTrue(errorWasThrown, "No error was thrown after manipulating event object");
      }
    }
  });
  qx.test.event.GlobalEventMonitors.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.event.Messaging": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.Messaging", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      __m__P_247_0: null,
      setUp: function setUp() {
        this.__m__P_247_0 = new qx.event.Messaging();
      },
      testTwoChannels: function testTwoChannels() {
        var handlerGet = this.spy();
        var handlerPost = this.spy();
        var ctx = {
          a: 12
        };
        var data = {
          data: "test"
        };

        this.__m__P_247_0.on("GET", "/get", handlerGet, ctx);

        this.__m__P_247_0.emit("GET", "/get", null, data);

        this.assertCalledOnce(handlerGet);
        this.assertCalledOn(handlerGet, ctx);
        this.assertCalledWith(handlerGet, {
          customData: data,
          params: {},
          path: "/get"
        });
        this.assertNotCalled(handlerPost);

        this.__m__P_247_0.on("POST", "/post", handlerPost, ctx);

        this.__m__P_247_0.emit("POST", "/post", null, data);

        this.assertCalledOnce(handlerPost);
        this.assertCalledOn(handlerPost, ctx);
        this.assertCalledWith(handlerPost, {
          customData: data,
          params: {},
          path: "/post"
        });
        this.assertCalledOnce(handlerGet);
      },
      testGet: function testGet() {
        var handler = this.spy();
        var ctx = {
          a: 12
        };
        var data = {
          data: "test"
        };

        this.__m__P_247_0.on("get", "/", handler, ctx);

        this.__m__P_247_0.emit("get", "/", null, data);

        this.assertCalledOnce(handler);
        this.assertCalledOn(handler, ctx);
        this.assertCalledWith(handler, {
          customData: data,
          params: {},
          path: "/"
        });
      },
      testRegExp: function testRegExp() {
        var handler = this.spy();
        var ctx = {
          a: 12
        };
        var data = {
          data: "abcdef"
        };

        this.__m__P_247_0.on("xyz", /^xyz/g, handler, ctx);

        this.__m__P_247_0.emit("xyz", "xyzabc", null, data);

        this.__m__P_247_0.emit("xyz", "abcxyz", null, data);

        this.assertCalledOnce(handler);
        this.assertCalledOn(handler, ctx);
        this.assertCalledWith(handler, {
          customData: data,
          params: {},
          path: "xyzabc"
        });
      },
      testGetAll: function testGetAll() {
        var handler = this.spy();

        this.__m__P_247_0.on("a", /.*/, handler);

        this.__m__P_247_0.emit("a", "xyzabc");

        this.__m__P_247_0.emit("a", "abcxyz");

        this.assertCalledTwice(handler);
      },
      testAny: function testAny() {
        var handler = this.spy();

        this.__m__P_247_0.onAny(/.*/, handler);

        this.__m__P_247_0.emit("a", "xyzabc");

        this.__m__P_247_0.emit("b", "abcxyz");

        this.assertCalledTwice(handler);
      },
      testTwice: function testTwice() {
        var handler = this.spy();
        var ctx = {
          a: 12
        };
        var data = {
          data: "test"
        };

        this.__m__P_247_0.on("GET", "/", handler, ctx);

        this.__m__P_247_0.emit("GET", "/", null, data);

        this.__m__P_247_0.emit("GET", "/", null, data);

        this.assertCalledTwice(handler);
        this.assertCalledOn(handler, ctx);
        this.assertCalledWith(handler, {
          customData: data,
          params: {},
          path: "/"
        });
      },
      testParam: function testParam() {
        var handler = this.spy();
        var ctx = {
          a: 12
        };
        var data = {
          data: "test"
        };

        this.__m__P_247_0.on("POST", "/{id}/affe", handler, ctx);

        this.__m__P_247_0.emit("POST", "/123456/affe", data);

        this.assertCalledOnce(handler);
        this.assertCalledOn(handler, ctx);
        this.assertCalledWith(handler, {
          customData: undefined,
          params: {
            id: "123456",
            data: "test"
          },
          path: "/123456/affe"
        });
      },
      testMultipleParam: function testMultipleParam() {
        var handler = this.spy();
        var data = {
          data: "test"
        };

        this.__m__P_247_0.on("POST", "/{id}-{name}/affe", handler);

        this.__m__P_247_0.emit("POST", "/123456-xyz/affe", data);

        this.assertCalledOnce(handler);
        this.assertCalledWith(handler, {
          customData: undefined,
          params: {
            id: "123456",
            name: "xyz",
            data: "test"
          },
          path: "/123456-xyz/affe"
        });
      },
      testRemove: function testRemove() {
        var handler = this.spy();

        var id = this.__m__P_247_0.on("GET", "/", handler);

        this.__m__P_247_0.emit("GET", "/");

        this.assertCalledOnce(handler);

        this.__m__P_247_0.remove(id);

        this.__m__P_247_0.emit("GET", "/");

        this.assertCalledOnce(handler);
      },
      testHas: function testHas() {
        this.__m__P_247_0.on("GET", "/affe", function () {});

        this.__m__P_247_0.on("POST", "/affe", function () {});

        this.assertTrue(this.__m__P_247_0.has("GET", "/affe"));
        this.assertTrue(this.__m__P_247_0.has("POST", "/affe"));
        this.assertFalse(this.__m__P_247_0.has("get", "/affe"));
        this.assertFalse(this.__m__P_247_0.has("GET", "/banane"));
        this.assertFalse(this.__m__P_247_0.has("PUT", "/affe"));
        this.assertFalse(this.__m__P_247_0.has("banane", "/affe"));
      }
    }
  });
  qx.test.event.Messaging.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.event.IEventHandler": {
        "require": true
      },
      "qx.event.Registration": {
        "defer": "runtime",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This class provides qooxdoo object event support.
   */
  qx.Class.define("qx.test.event.MockHandler", {
    extend: qx.core.Object,
    implement: qx.event.IEventHandler,

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {Integer} Priority of this handler */
      PRIORITY: qx.event.Registration.PRIORITY_FIRST,

      /** @type {Map} Supported event types */
      SUPPORTED_TYPES: null,

      /** @type {Integer} Which target check to use */
      TARGET_CHECK: qx.event.IEventHandler.TARGET_OBJECT,

      /** @type {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE: false
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      calls: [],

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent: function canHandleEvent(target, type) {
        this.calls.push(["canHandleEvent", target, type]);
        return type.startsWith("$test");
      },
      // interface implementation
      registerEvent: function registerEvent(target, type, capture) {
        this.calls.push(["registerEvent", target, type, capture]);
      },
      // interface implementation
      unregisterEvent: function unregisterEvent(target, type, capture) {
        this.calls.push(["unregisterEvent", target, type, capture]);
      }
    },

    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer: function defer(statics) {
      qx.event.Registration.addHandler(statics);
    }
  });
  qx.test.event.MockHandler.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.event.Registration": {},
      "qx.test.event.MockHandler": {},
      "qx.event.type.Event": {},
      "qx.core.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * @ignore(Foo)
   */
  qx.Class.define("qx.test.event.Registration", {
    extend: qx.dev.unit.TestCase,
    events: {
      "$test": "qx.event.type.Event"
    },
    members: {
      testAddRemoveListener: function testAddRemoveListener() {
        var target = this;
        var type = "$test";
        var capture = false;
        var Reg = qx.event.Registration;
        var mgr = Reg.getManager(target);
        var handler = mgr.findHandler(target, type);
        this.assertInstance(handler, qx.test.event.MockHandler);
        var fired = [false, false];

        var listener1 = function listener1(e) {
          fired[0] = true;
        };

        var listener2 = function listener2(e) {
          fired[1] = true;
        }; // first add with this type/target


        handler.calls = [];
        Reg.addListener(target, type, listener1, this, capture);
        this.assertEquals(1, handler.calls.length);
        this.assertArrayEquals(["registerEvent", target, type, capture], handler.calls[0]);
        Reg.fireEvent(target, type, qx.event.type.Event, []);
        this.assertArrayEquals([true, false], fired); // second add with this type/target

        handler.calls = [];
        fired = [false, false];
        Reg.addListener(target, type, listener2, this, capture);
        this.assertEquals(0, handler.calls.length);
        Reg.fireEvent(target, type, qx.event.type.Event, []);
        this.assertArrayEquals([true, true], fired); // remove first handler

        handler.calls = [];
        fired = [false, false];
        Reg.removeListener(target, type, listener1, this, capture);
        this.assertEquals(0, handler.calls.length);
        Reg.fireEvent(target, type, qx.event.type.Event, []);
        this.assertArrayEquals([false, true], fired); // remove second handler

        handler.calls = [];
        fired = [false, false];
        Reg.removeListener(target, type, listener2, this, capture);
        this.assertEquals(1, handler.calls.length);
        this.assertArrayEquals(["unregisterEvent", target, type, capture], handler.calls[0]);
        Reg.fireEvent(target, type, qx.event.type.Event, []);
        this.assertArrayEquals([false, false], fired);
      },
      testAddRemoveListenerById: function testAddRemoveListenerById() {
        var target = this;
        var type = "$test";
        var capture = false;
        var Reg = qx.event.Registration;
        var mgr = Reg.getManager(target);
        var handler = mgr.findHandler(target, type);
        var fired = [false, false];

        var listener1 = function listener1(e) {
          fired[0] = true;
        };

        var listener2 = function listener2(e) {
          fired[1] = true;
        };

        var id1 = Reg.addListener(target, type, listener1, this, capture);
        this.assertNotNull(id1);
        var id2 = Reg.addListener(target, type, listener2, this, capture);
        this.assertNotNull(id2); // remove first handler

        handler.calls = [];
        fired = [false, false];
        Reg.removeListenerById(target, id1);
        this.assertEquals(0, handler.calls.length);
        Reg.fireEvent(target, type, qx.event.type.Event, []);
        this.assertArrayEquals([false, true], fired); // remove second handler

        handler.calls = [];
        fired = [false, false];
        Reg.removeListenerById(target, id2);
        this.assertEquals(1, handler.calls.length);
        this.assertArrayEquals(["unregisterEvent", target, type, capture], handler.calls[0]);
        Reg.fireEvent(target, type, qx.event.type.Event, []);
        this.assertArrayEquals([false, false], fired);
      },

      /**
       * @ignore(Foo)
       */
      "test addListenerOnce: same callback": function testAddListenerOnceSameCallback() {
        qx.Class.define("Foo", {
          extend: qx.core.Object,
          events: {
            "bar": "qx.event.type.Event"
          },
          members: {
            fireBar: function fireBar() {
              this.fireDataEvent("bar");
            }
          }
        });
        var f1 = new Foo();
        var f2 = new Foo();
        var called = {};
        called[f1.toHashCode()] = 0;
        called[f2.toHashCode()] = 0;

        var callback = function callback(e) {
          called[this.toHashCode()]++;
        };

        f1.addListenerOnce("bar", callback, f1);
        f2.addListenerOnce("bar", callback, f2);
        f1.fireBar();
        f2.fireBar();
        f1.fireBar();
        f2.fireBar();
        this.assertEquals(1, called[f1.toHashCode()]);
        this.assertEquals(1, called[f2.toHashCode()]);
      }
    }
  });
  qx.test.event.Registration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.event.GlobalError": {},
      "qx.event.Timer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.Timer", {
    extend: qx.dev.unit.TestCase,
    members: {
      tearDown: function tearDown() {
        qx.event.GlobalError.setErrorHandler(null);
      },
      testGlobalErrorHandling: function testGlobalErrorHandling() {
        var fail = function fail() {
          throw new Error("fail");
        };

        var onError = function onError() {
          this.resume(function () {});
        };

        qx.event.GlobalError.setErrorHandler(onError, this);
        qx.event.Timer.once(fail, this, 0);
        this.wait(100);
      },

      /**
       * Test if timer can be started and stopped.
       */
      testStartStop: function testStartStop() {
        var runCount = 0;
        var timer = new qx.event.Timer(50);
        timer.addListener('interval', function () {
          runCount++;

          if (runCount === 2) {
            timer.stop();
          }
        });
        timer.start(); // 250ms should be sufficient for exactly two runs of an 50ms timer. We
        // don't want to use a shorter interval, because cancellation of the timer
        // via stop() could then become unreliable (timer could fire a third time)

        this.wait(250, function () {
          this.assertFalse(runCount === 0, 'Timer did not fire interval event');
          this.assertFalse(runCount === 1, 'Timer did not fire interval event repeatedly, fired only once');
          this.assertIdentical(2, runCount, 'Timer fired more interval events than expected (could not be stopped after second run)');
        }.bind(this));
      },

      /**
       * Test if newly created timers don't start by default.
       */
      testNoStartByDefault: function testNoStartByDefault() {
        var runCount = 0;
        var timer = new qx.event.Timer(1);
        timer.addListener('interval', function () {
          runCount++;
        });
        this.wait(250, function () {
          // 250ms should be sufficient to detect an (unwanted) start of an 1ms timer
          this.assertIdentical(0, runCount, 'New timer did fire interval event without explicitly being started by calling start() or by setting enabled property to true');
        }.bind(this));
      },

      /**
       * Timer using static method once() should start automatically and fire
       * exactly a single time.
       */
      testStaticOnce: function testStaticOnce() {
        var runCount = 0;
        qx.event.Timer.once(function () {
          runCount++;
        }, this, 1);
        this.wait(250, function () {
          this.assertIdentical(1, runCount, 'Static method once() is expected to start automatically and to run exactly once');
        }.bind(this));
      }
    }
  });
  qx.test.event.Timer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.event.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2018 Zenesis Ltd, john.spackman@zenesis.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (johnspackman)
  
   ************************************************************************ */

  /**
   * @ignore(qx.Promise)
   */
  qx.Class.define("qx.test.event.Utils", {
    extend: qx.dev.unit.TestCase,
    members: {
      testQxPromiseNotDefined: function testQxPromiseNotDefined() {
        {
          this.assertTrue(true);
        }
      },
      testNoPromises: function testNoPromises() {
        var Utils = qx.event.Utils;
        var tracker = {};
        var str = "";
        var self = this;
        var finished = false;
        Utils.catch(tracker, function () {
          self.assertTrue(false);
        });
        Utils.then(tracker, function () {
          return str += "A";
        });
        Utils.then(tracker, function (value) {
          self.assertEquals("A", value);
          return str += "B";
        });
        Utils.then(tracker, function () {
          str += "C";
        });
        Utils.then(tracker, function () {
          self.assertEquals("ABC", str);
          finished = true;
        });
        this.assertTrue(finished);
      },
      testSomeDelayedPromises: function testSomeDelayedPromises() {
        {
          var Utils = qx.event.Utils;
          var tracker = {};
          var str = "";
          var self = this;
          Utils.then(tracker, function () {
            str += "A";
          });
          Utils.then(tracker, function () {
            return new qx.Promise(function (resolve) {
              setTimeout(function () {
                str += "B";
                resolve(str);
              }, 200);
            });
          });
          Utils.then(tracker, function (value) {
            self.assertEquals("AB", value);
            str += "C";
          });
          Utils.then(tracker, function () {
            self.assertEquals("ABC", str);
            self.resume();
          });
          self.wait();
        }
      },
      testSomeInstantPromises: function testSomeInstantPromises() {
        {
          var Utils = qx.event.Utils;
          var tracker = {};
          var str = "";
          var self = this;
          Utils.then(tracker, function () {
            str += "A";
          });
          Utils.then(tracker, function () {
            str += "B";
            return qx.Promise.resolve(str);
          });
          Utils.then(tracker, function (value) {
            self.assertEquals("AB", value);
            str += "C";
          });
          Utils.then(tracker, function () {
            self.assertEquals("ABC", str);
            self.resume();
          });
          self.wait();
        }
      },
      testSomeInstantPromises2: function testSomeInstantPromises2() {
        {
          var Utils = qx.event.Utils;
          var tracker = {};
          var str = "";
          var self = this;
          Utils.then(tracker, function () {
            str += "A";
          });
          Utils.then(tracker, function () {
            str += "B";
            return qx.Promise.resolve();
          });
          Utils.then(tracker, function () {
            return new qx.Promise(function (resolve) {
              setTimeout(function () {
                str += "C";
                resolve(str);
              }, 200);
            });
          });
          Utils.then(tracker, function (value) {
            self.assertEquals("ABC", value);
            self.assertEquals("ABC", str);
            self.resume();
          });
          self.wait();
        }
      },
      testSomeAbort: function testSomeAbort() {
        var Utils = qx.event.Utils;
        var tracker = {};
        var str = "";
        var self = this;
        var finished = false;
        Utils.then(tracker, function () {
          str += "A";
        });
        Utils.then(tracker, function () {
          return Utils.ABORT;
        });
        Utils.then(tracker, function () {
          str += "C";
        });
        Utils.then(tracker, function () {
          self.assertTrue(false);
        });
        Utils.catch(tracker, function () {
          self.assertEquals("A", str);
          finished = true;
        });
        this.assertTrue(finished);
      },
      testSomeReject: function testSomeReject() {
        {
          var Utils = qx.event.Utils;
          var tracker = {};
          var str = "";
          var self = this;
          Utils.then(tracker, function () {
            str += "A";
          });
          Utils.then(tracker, function () {
            return new qx.Promise(function (resolve, reject) {
              setTimeout(function () {
                reject();
              }, 200);
            });
          });
          Utils.then(tracker, function () {
            str += "C";
          });
          Utils.then(tracker, function () {
            self.assertTrue(false);
          });
          Utils.catch(tracker, function () {
            self.assertEquals("A", str);
            self.resume();
          });
          self.wait();
        }
      },
      testResolveAndReject: function testResolveAndReject() {
        {
          var Utils = qx.event.Utils;
          var tracker = {};
          var str = "";
          var self = this;
          Utils.then(tracker, function () {
            str += "A";
          });
          Utils.then(tracker, function () {
            return new qx.Promise(function (resolve) {
              setTimeout(function () {
                str += "B";
                resolve();
              }, 200);
            });
          });
          Utils.then(tracker, function () {
            return new qx.Promise(function (resolve, reject) {
              setTimeout(function () {
                reject();
              }, 200);
            });
          });
          Utils.then(tracker, function () {
            self.assertTrue(false);
          });
          Utils.catch(tracker, function () {
            self.assertEquals("AB", str);
            self.resume();
          });
          self.wait();
        }
      },
      testSeries1: function testSeries1() {
        {
          var Utils = qx.event.Utils;
          var tracker = {};
          var str = "";
          var self = this;
          Utils.catch(tracker, function () {
            self.assertTrue(false);
          });
          Utils.then(tracker, function () {
            return Utils.series(["A", "B", "C", "D"], function (value) {
              if (value === "C") {
                return new qx.Promise(function (resolve, reject) {
                  setTimeout(function () {
                    str += value;
                    resolve();
                  }, 200);
                });
              } else {
                str += value;
                return null;
              }
            });
          });
          Utils.then(tracker, function () {
            self.assertEquals("ABCD", str);
            self.resume();
            return null;
          });
          self.wait();
        }
      },
      testSeriesAbort: function testSeriesAbort() {
        {
          var Utils = qx.event.Utils;
          var tracker = {};
          var str = "";
          var self = this;
          Utils.catch(tracker, function () {
            self.assertEquals("AB", str);
            self.resume();
          });
          Utils.then(tracker, function () {
            return Utils.series(["A", "B", "C", "D"], function (value) {
              if (value === "B") {
                return new qx.Promise(function (resolve, reject) {
                  setTimeout(function () {
                    str += value;
                    resolve();
                  }, 200);
                });
              } else if (value === "C") {
                return Utils.ABORT;
              } else {
                str += value;
                return null;
              }
            });
          });
          Utils.then(tracker, function () {
            self.assertTrue(false);
          });
          self.wait();
        }
      },

      /**
       * @ignore(Promise)
       */
      testNativePromiseReturns: function testNativePromiseReturns() {
        if (Promise !== undefined) {
          var self = this;
          var p = new Promise(function (resolve) {
            setTimeout(resolve, 100);
          });
          p = p.then(function () {
            var p2 = new Promise(function (resolve) {
              setTimeout(resolve, 100);
            });
            return p2.then(function () {
              return true;
            });
          });
          p = p.then(function () {
            self.resume();
          });
          this.wait();
        } else {
          this.skip("Skipping because native Promise is not defined");
        }
      },
      testPromiseReturns: function testPromiseReturns() {
        {
          var self = this;
          var p = new qx.Promise(function (resolve) {
            setTimeout(function () {
              console.log("testPromiseReturns:: resolving p");
              resolve();
            }, 100);
          });
          p = p.then(function () {
            var p2 = new qx.Promise(function (resolve) {
              setTimeout(function () {
                console.log("testPromiseReturns:: resolving p2");
                resolve();
              }, 100);
            });
            return p2.then(function () {
              console.log("testPromiseReturns:: resolving post p2");
            });
          });
          p = p.then(function () {
            console.log("testPromiseReturns:: outer then, resuming test");
            self.resume();
          });
          this.wait();
        }
      },
      testSeriesReject: function testSeriesReject() {
        {
          var Utils = qx.event.Utils;
          var tracker = {};
          var str = "";
          var self = this;
          Utils.catch(tracker, function () {
            self.assertEquals("AB", str);
            self.resume();
          });
          Utils.then(tracker, function () {
            return Utils.series(["A", "B", "C", "D"], function (value) {
              if (value === "C") {
                return new qx.Promise(function (resolve, reject) {
                  setTimeout(function () {
                    reject();
                  }, 200);
                });
              } else {
                str += value;
                return null;
              }
            });
          });
          Utils.then(tracker, function () {
            self.assertTrue(false);
          });
          self.wait();
        }
      },
      testSeriesRejectNested: function testSeriesRejectNested() {
        {
          var Utils = qx.event.Utils;
          var tracker = {};
          var str = "";
          var self = this;
          Utils.catch(tracker, function () {
            self.assertEquals("ABC1", str);
            self.resume();
          });
          Utils.then(tracker, function () {
            return Utils.series(["A", "B", "C", "D"], function (letter) {
              if (letter === "C") {
                str += letter;
                return Utils.series([1, 2, 3, 4], function (number) {
                  if (number == 2) {
                    return new qx.Promise(function (resolve, reject) {
                      setTimeout(function () {
                        reject();
                      }, 200);
                    });
                  } else {
                    str += number;
                  }

                  return null;
                });
              } else {
                str += letter;
                return null;
              }
            });
          });
          Utils.then(tracker, function () {
            self.assertTrue(false);
            return null;
          });
          self.wait();
        }
      },
      testSeriesNested: function testSeriesNested() {
        {
          var Utils = qx.event.Utils;
          var tracker = {};
          var str = "";
          var self = this;
          Utils.catch(tracker, function () {
            self.assertTrue(false);
          });
          Utils.then(tracker, function () {
            return Utils.series(["A", "B", "C", "D"], function (letter) {
              if (letter === "C") {
                str += letter;
                return Utils.series([1, 2, 3, 4], function (number) {
                  if (number == 2) {
                    return new qx.Promise(function (resolve, reject) {
                      setTimeout(function () {
                        str += number;
                        resolve();
                      }, 200);
                    });
                  } else {
                    str += number;
                  }

                  return null;
                });
              } else {
                str += letter;
                return null;
              }
            });
          });
          Utils.then(tracker, function () {
            self.assertEquals("ABC1234D", str);
            self.resume();
            return null;
          });
          self.wait();
        }
      },
      testTrack: function testTrack() {
        {
          var Utils = qx.event.Utils;
          var str = "";
          var self = this;
          var finished = true;

          function outer() {
            var tracker = {};
            Utils.track(tracker, inner);
            Utils.then(tracker, function () {
              self.assertEquals("ABC", str);
              finished = true;
            });
            self.assertTrue(finished);
          }

          function add(ch, delay) {
            return function () {
              return new qx.Promise(function (resolve) {
                setTimeout(function () {
                  str += ch;
                  resolve();
                }, 300);
              });
            };
          }

          function inner() {
            var tracker = {};
            Utils.then(tracker, add("A", 300));
            Utils.then(tracker, add("B", 200));
            Utils.then(tracker, add("C", 100));
            return tracker.promise;
          }

          outer();
        }
      }
    }
  });
  qx.test.event.Utils.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.test.event.dispatch.TestingHandler": {},
      "qx.event.dispatch.MouseCapture": {},
      "qx.event.dispatch.DomBubbling": {},
      "qx.event.dispatch.Direct": {},
      "qx.event.Registration": {},
      "qx.test.event.dispatch.TestingWindow": {},
      "qx.event.Manager": {},
      "qx.event.type.Event": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.dispatch.MouseCapture", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        var root = qx.dom.Element.create("div", {
          id: "root"
        });
        document.body.appendChild(root); // root
        //   c_1
        //     c_1_1
        //   c_2

        root.innerHTML = "<div id='c_1'><div id='c_1_1'></div></div><div id='c_2'>";
        this.c_1 = document.getElementById("c_1");
        this.c_1_1 = document.getElementById("c_1_1");
        this.c_2 = document.getElementById("c_2");
        var registration = {
          removeManager: function removeManager() {},
          getHandlers: function getHandlers() {
            return [qx.test.event.dispatch.TestingHandler];
          },
          getDispatchers: function getDispatchers() {
            return [qx.event.dispatch.MouseCapture, qx.event.dispatch.DomBubbling, qx.event.dispatch.Direct];
          },
          fireEvent: function fireEvent(target, type, clazz, args) {
            var event = qx.event.Registration.createEvent(type, clazz, args);
            return manager.dispatchEvent(target, event);
          }
        };
        this.window = new qx.test.event.dispatch.TestingWindow();
        var manager = this.manager = new qx.event.Manager(this.window, registration);
        this.capture = this.manager.getDispatcher(qx.event.dispatch.MouseCapture);
        this.called = [];
        this.manager.addListener(this.c_1, "mousemove", this.logEvent, this);
        this.manager.addListener(this.c_1_1, "mousemove", this.logEvent, this);
        this.manager.addListener(this.c_2, "mousemove", this.logEvent, this);
      },
      tearDown: function tearDown() {
        var Reg = qx.event.Registration;
        Reg.removeAllListeners(this.c_1);
        Reg.removeAllListeners(this.c_1_1);
        Reg.removeAllListeners(this.c_2);
        document.body.removeChild(document.getElementById("root"));
        this.manager.dispose();
        this.window.dispose();
      },
      logEvent: function logEvent(e) {
        this.called.push(e.getCurrentTarget().id);
      },
      onLoseCapture: function onLoseCapture() {
        this.called.push("losecapture");
      },
      fire: function fire(target, type, bubble) {
        var event = qx.event.Registration.createEvent(type, qx.event.type.Event, [bubble !== false]);
        this.manager.dispatchEvent(target, event);
      },
      testNoCapture: function testNoCapture() {
        this.fire(this.c_1_1, "mousemove");
        this.assertEquals("c_1_1,c_1", this.called.join(","));
      },
      testContainerCapture: function testContainerCapture() {
        this.capture.activateCapture(this.c_1, true);
        this.called = [];
        this.fire(this.c_1, "mousemove");
        this.assertEquals("c_1", this.called.join(","));
        this.called = [];
        this.fire(this.c_1_1, "mousemove");
        this.assertEquals("c_1", this.called.join(","));
        this.called = [];
        this.fire(this.c_2, "mousemove");
        this.assertEquals("c_1", this.called.join(","));
      },
      testNoContainerCapture: function testNoContainerCapture() {
        this.capture.activateCapture(this.c_1, false);
        this.called = [];
        this.fire(this.c_1, "mousemove");
        this.assertEquals("c_1", this.called.join(","));
        this.called = [];
        this.fire(this.c_1_1, "mousemove");
        this.assertEquals("c_1_1,c_1", this.called.join(","));
        this.called = [];
        this.fire(this.c_2, "mousemove");
        this.assertEquals("c_1", this.called.join(","));
      },
      testCaptureBubbling: function testCaptureBubbling() {
        this.capture.activateCapture(this.c_1_1, true);
        this.called = [];
        this.fire(this.c_1, "mousemove");
        this.assertEquals("c_1_1,c_1", this.called.join(","));
      },
      testLoseCaptureOnClick: function testLoseCaptureOnClick() {
        this.manager.addListener(this.c_1, "losecapture", this.onLoseCapture, this);
        this.capture.activateCapture(this.c_1, true);
        this.called = [];
        this.fire(this.c_1, "mousemove");
        this.fire(this.c_2, "click");
        this.assertEquals("c_1,losecapture", this.called.join(","));
      },
      testLoseCaptureOnWindowBlur: function testLoseCaptureOnWindowBlur() {
        this.manager.addListener(this.c_1, "losecapture", this.onLoseCapture, this);
        this.capture.activateCapture(this.c_1, true);
        this.called = [];
        this.fire(this.c_1, "mousemove");
        this.fire(this.window, "blur", false);
        this.assertEquals("c_1,losecapture", this.called.join(","));
      },
      testLoseCaptureOnWindowFocus: function testLoseCaptureOnWindowFocus() {
        this.manager.addListener(this.c_1, "losecapture", this.onLoseCapture, this);
        this.capture.activateCapture(this.c_1, true);
        this.called = [];
        this.fire(this.c_1, "mousemove");
        this.fire(this.window, "focus", false);
        this.assertEquals("c_1,losecapture", this.called.join(","));
      },
      testLoseCaptureOnWindowScroll: function testLoseCaptureOnWindowScroll() {
        this.manager.addListener(this.c_1, "losecapture", this.onLoseCapture, this);
        this.capture.activateCapture(this.c_1, true);
        this.called = [];
        this.fire(this.c_1, "mousemove");
        this.fire(this.window, "scroll", false);
        this.assertEquals("c_1,losecapture", this.called.join(","));
      },
      testLoseCaptureOnCaptureChange: function testLoseCaptureOnCaptureChange() {
        this.manager.addListener(this.c_1, "losecapture", this.onLoseCapture, this);
        this.capture.activateCapture(this.c_1, true);
        this.called = [];
        this.fire(this.c_1, "mousemove");
        this.capture.activateCapture(this.c_2, true);
        this.assertEquals("c_1,losecapture", this.called.join(","));
      }
    }
  });
  qx.test.event.dispatch.MouseCapture.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.event.IEventHandler": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.dispatch.TestingHandler", {
    extend: qx.core.Object,
    implement: qx.event.IEventHandler,
    members: {
      canHandleEvent: function canHandleEvent() {
        return true;
      },
      registerEvent: function registerEvent() {},
      unregisterEvent: function unregisterEvent() {}
    }
  });
  qx.test.event.dispatch.TestingHandler.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.dispatch.TestingWindow", {
    extend: qx.core.Object,
    events: {
      "unload": "qx.event.type.Event",
      "onunload": "qx.event.type.Event"
    },
    members: {
      addEventListener: function addEventListener(type, callback, capture) {
        return this.addListener(type, callback, this, capture);
      },
      attachEvent: function attachEvent(type, callback) {
        return this.addListener(type, callback);
      }
    }
  });
  qx.test.event.dispatch.TestingWindow.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.log.appender.RingBuffer": {},
      "qx.log.Logger": {},
      "qx.event.Registration": {},
      "qx.bom.Element": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.dispatch.MouseEventOnDocument", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        this.root = qx.dom.Element.create("div", {
          id: "root"
        });
        document.body.appendChild(this.root);
        this.ringAppender = new qx.log.appender.RingBuffer();
        qx.log.Logger.register(this.ringAppender);
      },
      tearDown: function tearDown() {
        qx.log.Logger.unregister(this.ringAppender);
        qx.log.Logger.clear();
        this.ringAppender = null;
        var Reg = qx.event.Registration;
        Reg.removeAllListeners(document);
        Reg.removeAllListeners(window);
        Reg.removeAllListeners(this.root);
        document.body.removeChild(document.getElementById("root"));
      },
      testMouseEventsOnDocument: function testMouseEventsOnDocument() {
        this.doWork(document);
      },
      testMouseEventsOnWindow: function testMouseEventsOnWindow() {
        this.doWork(window);
      },
      testMouseEventsOnDomNode: function testMouseEventsOnDomNode() {
        this.doWork(this.root);
      },
      doWork: function doWork(el) {
        {
          this.ringAppender.clear();
          var events = ['mousemove', 'click', 'mousedown', 'mouseup'];

          for (var i = 0; i < events.length; i++) {
            qx.bom.Element.addListener(el, events[i], function () {});
          }

          var warnings = this.ringAppender.getAllLogEvents().length;
          this.assertTrue(0 === warnings, warnings + " events in ['mousemove','click','mousedown','mouseup'] generated a warning when added to target " + el);
        }
      }
    }
  });
  qx.test.event.dispatch.MouseEventOnDocument.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.event.Registration": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.handler.Offline": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.handler.Offline", {
    extend: qx.dev.unit.TestCase,
    members: {
      __handler__P_248_0: qx.event.Registration.getManager(window).getHandler(qx.event.handler.Offline),
      testIsOnline: function testIsOnline() {
        this.assertBoolean(this.__handler__P_248_0.isOnline());
      }
    }
  });
  qx.test.event.handler.Offline.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.core.Object": {},
      "qx.event.message.Bus": {},
      "qx.event.message.Message": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.message.Bus", {
    extend: qx.dev.unit.TestCase,
    members: {
      __subscriberOne__P_249_0: null,
      __subscriberTwo__P_249_1: null,
      __subscriberThree__P_249_2: null,
      setUp: function setUp() {
        this.__subscriberOne__P_249_0 = new qx.core.Object();
        this.__subscriberTwo__P_249_1 = new qx.core.Object();
        this.__subscriberThree__P_249_2 = new qx.core.Object();
      },
      tearDown: function tearDown() {
        this.__subscriberOne__P_249_0.dispose();

        this.__subscriberTwo__P_249_1.dispose();

        this.__subscriberThree__P_249_2.dispose();

        var subscribers = qx.event.message.Bus.getSubscriptions();

        for (var key in subscribers) {
          delete subscribers[key];
        }

        this.assertJsonEquals({}, qx.event.message.Bus.getSubscriptions());
      },
      testDispatch: function testDispatch() {
        var bus = qx.event.message.Bus;
        var calls = 0;
        var that = this;
        bus.subscribe("*", function (message) {
          calls++;
          that.assertEquals("MyMessage", message.getName());
          that.assertEquals(10, message.getData());
        }, this.__subscriberOne__P_249_0);
        bus.subscribe("MyMessage2", function (message) {
          that.assertFalse(true, "Wrong subscriber called!");
        }, this.__subscriberTwo__P_249_1);
        bus.subscribe("MyMessage", function (message) {
          calls++;
          that.assertEquals("MyMessage", message.getName());
          that.assertEquals(10, message.getData());
        }, this.__subscriberThree__P_249_2);
        var msg = new qx.event.message.Message("MyMessage", 10);
        this.assertTrue(bus.dispatch(msg), "Message not dispatched");
        this.assertEquals(2, calls, "Wrong callbacks!");
        msg.dispose();
      },
      testDispatchWithDisposed: function testDispatchWithDisposed() {
        var bus = qx.event.message.Bus;
        var calls = 0;
        var that = this;
        bus.subscribe("*", function (message) {
          calls++;
          that.assertEquals("MyMessage", message.getName());
          that.assertEquals(10, message.getData());
        }, this.__subscriberOne__P_249_0);

        this.__subscriberTwo__P_249_1.dispose();

        bus.subscribe("MyMessage", function (message) {
          that.assertFalse(true, "Wrong subscriber called!");
        }, this.__subscriberTwo__P_249_1);
        bus.subscribe("MyMessage", function (message) {
          calls++;
          that.assertEquals("MyMessage", message.getName());
          that.assertEquals(10, message.getData());
        }, this.__subscriberThree__P_249_2);
        var msg = new qx.event.message.Message("MyMessage", 10);
        this.assertTrue(bus.dispatch(msg), "Message not dispatched");
        this.assertEquals(2, calls, "Wrong callbacks!");
        msg.dispose();
      },
      // see http://bugzilla.qooxdoo.org/show_bug.cgi?id=2996
      testWildcard: function testWildcard() {
        var flag1 = false;
        var flag2 = false;

        function handler1() {
          flag1 = true;
        }

        function handler2() {
          flag2 = true;
        }

        var messageBus = qx.event.message.Bus.getInstance();
        messageBus.subscribe("*", handler1, this);
        messageBus.subscribe("mess*", handler2, this);
        var msg1 = new qx.event.message.Message("message", true);
        this.assertTrue(messageBus.dispatch(msg1), "Message not dispatched");
        this.assertTrue(flag1, "Handler1 (filter '*') was not called for message 'message'.");
        this.assertTrue(flag2, "Handler2 (filter 'mess*') was not called for message 'message'.");
        flag1 = false;
        flag2 = false;
        var msg2 = new qx.event.message.Message("massage", true);
        this.assertTrue(messageBus.dispatch(msg2), "Message not dispatched");
        this.assertTrue(flag1, "Handler1 (filter '*') was not called for message 'massage'.");
        this.assertFalse(flag2, "Handler2 (filter 'mess*') was wrongly called for message 'massage'.");
        msg1.dispose();
        msg2.dispose();
      },
      testRegex: function testRegex() {
        var flag1 = false;

        function handler1() {
          flag1 = true;
        }

        var messageBus = qx.event.message.Bus.getInstance();
        messageBus.subscribe(/^test\.[a-z]+$/, handler1, this);
        var msg1 = new qx.event.message.Message("test.abc", true);
        this.assertTrue(messageBus.dispatch(msg1), "Message not dispatched");
        this.assertTrue(flag1, "Handler1 (filter /^test\\.[a-z]+$/) was not called for message '" + msg1.getName() + "'");
        var msg2 = new qx.event.message.Message("test.123", true);
        this.assertFalse(messageBus.dispatch(msg2), "Message was dispatched and shouldn't have been");
        msg1.dispose();
        msg2.dispose();
      },
      testSubscribeOnce: function testSubscribeOnce() {
        var flag1 = false;

        function handler1() {
          flag1 = true;
        }

        var messageBus = qx.event.message.Bus.getInstance();
        messageBus.subscribeOnce("testSubscribeOnce", handler1, this);
        var msg1 = new qx.event.message.Message("testSubscribeOnce", true);
        this.assertTrue(messageBus.dispatch(msg1), "Message not dispatched");
        this.assertTrue(flag1, "Handler (filter \"testSubscribeOnce\") was not called for message '" + msg1.getName() + "'");
        flag1 = false;
        var msg2 = new qx.event.message.Message("testSubscribeOnce", true);
        this.assertFalse(messageBus.dispatch(msg2), "Message was dispatched but shouldn't have been.");
        msg1.dispose();
        msg2.dispose();
      },
      // see http://bugzilla.qooxdoo.org/show_bug.cgi?id=2996
      testUnsubscribe: function testUnsubscribe() {
        var flag = false;

        function handler() {
          flag = true;
        }

        function anotherHandler() {}

        var messageBus = qx.event.message.Bus.getInstance();
        messageBus.subscribe("message", handler, this);
        messageBus.unsubscribe("message", anotherHandler, this);
        var msg1 = new qx.event.message.Message("message", true);
        this.assertTrue(messageBus.dispatch(msg1), "Message not dispatched");
        this.assertTrue(flag, "Handler was not called.");
        flag = false;
        messageBus.unsubscribe("message", handler, this);
        var msg2 = new qx.event.message.Message("message", true);
        this.assertFalse(messageBus.dispatch(msg2), "Message not dispatched");
        this.assertFalse(flag, "Handler was called although unsubscribed.");
        msg1.dispose();
        msg2.dispose();
      },
      testUnsubscribeAll: function testUnsubscribeAll() {
        var flag = false;

        function handler() {
          flag = true;
        }

        ;

        function anotherHandler() {}

        ;
        var messageBus = qx.event.message.Bus.getInstance();
        messageBus.subscribe("message", handler, this);
        var msg1 = new qx.event.message.Message("message", true);
        this.assertTrue(messageBus.dispatch(msg1), "Message not dispatched");
        this.assertTrue(flag, "Handler was not called.");
        flag = false;
        messageBus.unsubscribe("message");
        var msg2 = new qx.event.message.Message("message", true);
        this.assertFalse(messageBus.dispatch(msg2), "Message not dispatched");
        this.assertFalse(flag, "Handler was called although unsubscribed.");
        msg1.dispose();
        msg2.dispose();
      },
      testWrongDispatch: function testWrongDispatch() {
        var flag = false;

        function handler() {
          flag = true;
        }

        var messageBus = qx.event.message.Bus.getInstance();
        messageBus.subscribe("message", handler, this);
        messageBus.subscribe("massage", handler, this);
        var msg = new qx.event.message.Message("trash", true);
        this.assertFalse(messageBus.dispatch(msg), "Message was dispatched");
        this.assertFalse(flag, "Handler was called.");
        msg.dispose();
      }
    }
  });
  qx.test.event.message.Bus.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.event.type.Dom": {},
      "qx.lang.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.type.Dom", {
    extend: qx.dev.unit.TestCase,
    members: {
      testClone: function testClone() {
        var domEvent = {
          shiftKey: true,
          ctrlKey: true,
          altKey: true,
          metaKey: true
        };
        var event = new qx.event.type.Dom().init(domEvent, document.body, document.body, true, true);
        var reference = {
          shift: event.isShiftPressed(),
          ctrl: event.isCtrlPressed(),
          alt: event.isAltPressed(),
          meta: event.isMetaPressed()
        };
        var clone = event.clone(); // simulate native event disposal

        qx.lang.Object.empty(domEvent);
        this.assertEquals(reference.shift, clone.isShiftPressed());
        this.assertEquals(reference.ctrl, clone.isCtrlPressed());
        this.assertEquals(reference.alt, clone.isAltPressed());
        this.assertEquals(reference.meta, clone.isMetaPressed());
        event.dispose();
        clone.dispose();
      }
    }
  });
  qx.test.event.type.Dom.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.event.type.Event": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.type.Event", {
    extend: qx.dev.unit.TestCase,
    members: {
      "test: stop() should prevent default and stop propagation": function testStopShouldPreventDefaultAndStopPropagation() {
        var e = new qx.event.type.Event().init(true, true);
        this.assertFalse(e.getPropagationStopped());
        this.assertFalse(e.getDefaultPrevented());
        e.stop();
        this.assertTrue(e.getPropagationStopped());
        this.assertTrue(e.getDefaultPrevented());
        e.dispose();
      },
      "test: stop() cannot prevent default on non cancelable events": function testStopCannotPreventDefaultOnNonCancelableEvents() {
        var e = new qx.event.type.Event().init(true, false);
        this.assertFalse(e.getDefaultPrevented());
        e.stop();
        this.assertFalse(e.getDefaultPrevented());
        e.dispose();
      },
      "test: stop() cannot stop propagation on a non bubbling event": function testStopCannotStopPropagationOnANonBubblingEvent() {
        var e = new qx.event.type.Event().init(false, true);
        this.assertFalse(e.getPropagationStopped());
        e.stop();
        this.assertFalse(e.getPropagationStopped());
        e.dispose();
      }
    }
  });
  qx.test.event.type.Event.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.event.type.MouseWheel": {},
      "qx.lang.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.type.Mouse", {
    extend: qx.dev.unit.TestCase,
    members: {
      testClone: function testClone() {
        var domEvent = {
          button: 2,
          // right button in IE and all other browsers
          clientX: 20,
          clientY: 40,
          srcElement: document.body,
          pageX: 20,
          pageY: 20,
          screenX: 1000,
          screenY: 400,
          wheelDelta: 20,
          detail: 20
        };
        var event = new qx.event.type.MouseWheel().init(domEvent, document.body, document.body, true, true);
        var reference = {
          button: event.getButton(),
          viewportLeft: event.getViewportLeft(),
          viewportTop: event.getViewportTop(),
          documentLeft: event.getDocumentLeft(),
          documentTop: event.getDocumentTop(),
          screenLeft: event.getScreenLeft(),
          screenTop: event.getScreenTop(),
          wheel: event.getWheelDelta()
        };
        var clone = event.clone(); // simulate native event disposal

        qx.lang.Object.empty(domEvent);
        this.assertEquals(reference.button, clone.getButton());
        this.assertEquals(reference.viewportLeft, clone.getViewportLeft());
        this.assertEquals(reference.viewportTop, clone.getViewportTop());
        this.assertEquals(reference.documentLeft, clone.getDocumentLeft());
        this.assertEquals(reference.documentTop, clone.getDocumentTop());
        this.assertEquals(reference.screenLeft, clone.getScreenLeft());
        this.assertEquals(reference.screenTop, clone.getScreenTop());
        this.assertEquals(reference.wheel, clone.getWheelDelta());
        event.dispose();
        clone.dispose();
      }
    }
  });
  qx.test.event.type.Mouse.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.event.type.Native": {},
      "qx.lang.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.event.type.Native", {
    extend: qx.dev.unit.TestCase,
    members: {
      testClone: function testClone() {
        var domEvent = {};
        var event = new qx.event.type.Native().init(domEvent, document.body, document.body, true, true);
        var clone = event.clone(); // simulate native event disposal

        qx.lang.Object.empty(domEvent);
        clone.preventDefault();
        event.dispose();
        clone.dispose();
      }
    }
  });
  qx.test.event.type.Native.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.event.util.Keyboard": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
   qooxdoo - the new era of web development
  
   http://qooxdoo.org
  
   Copyright:
   2007-20014 1&1 Internet AG, Germany, http://www.1und1.de
  
   License:
       MIT: https://opensource.org/licenses/MIT
   See the LICENSE file in the project's top-level directory for details.
  
   Authors:
   * Tobias Oberrauch <tobias.oberrauch@1und1.de>
  
   ************************************************************************
   */
  qx.Class.define("qx.test.event.util.Keyboard", {
    extend: qx.dev.unit.TestCase,
    members: {
      testCommaAsValidKeyIdentifier: function testCommaAsValidKeyIdentifier() {
        var isValidKeyIdentifier = qx.event.util.Keyboard.isValidKeyIdentifier(',');
        this.assertTrue(isValidKeyIdentifier);
      }
    }
  });
  qx.test.event.util.Keyboard.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.html.Root": {},
      "qx.html.Element": {},
      "qx.core.Init": {},
      "qx.bom.Selection": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.Class.define("qx.test.html.Element", {
    extend: qx.dev.unit.TestCase,
    members: {
      setUp: function setUp() {
        var helper = document.createElement("div");
        document.body.appendChild(helper);
        this._doc = new qx.html.Root(helper);

        this._doc.setAttribute("id", "doc");
      },
      tearDown: function tearDown() {
        qx.html.Element.flush();

        this._doc.dispose();

        var div = document.getElementById("doc");
        document.body.removeChild(div);
      },
      testHasListenerNoFlush: function testHasListenerNoFlush() {
        var listener = function listener(e) {};

        var el = new qx.html.Element();
        el.addListener("click", listener, this);
        el.addListener("mousedown", listener, this, true);
        this.assertTrue(el.hasListener("click", false));
        this.assertFalse(el.hasListener("click", true));
        this.assertTrue(el.hasListener("mousedown", true));
        this.assertFalse(el.hasListener("mousedown", false));
        el.dispose();
      },
      testHasListenerFlush: function testHasListenerFlush() {
        var listener = function listener(e) {};

        var el = new qx.html.Element();
        el.addListener("click", listener, this);
        el.addListener("mousedown", listener, this, true);
        qx.html.Element.flush();
        this.assertTrue(el.hasListener("click", false));
        this.assertFalse(el.hasListener("click", true));
        this.assertTrue(el.hasListener("mousedown", true));
        this.assertFalse(el.hasListener("mousedown", false));
        el.dispose();
      },
      testAddListener: function testAddListener() {
        // flush at end
        var listener = function listener() {};

        var el = new qx.html.Element();
        el.addListener("click", listener, this, false);
        this.assertTrue(el.hasListener("click", false));
        el.removeListener("click", listener, this, false);
        this.assertFalse(el.hasListener("click", false));
        qx.html.Element.flush();
        el.dispose(); // flush after create

        el = new qx.html.Element();
        qx.html.Element.flush();
        el.addListener("click", listener, this, false);
        this.assertTrue(el.hasListener("click", false));
        el.removeListener("click", listener, this, false);
        this.assertFalse(el.hasListener("click", false));
        el.dispose(); // flush after add listener

        var el = new qx.html.Element();
        el.addListener("click", listener, this, false);
        qx.html.Element.flush();
        this.assertTrue(el.hasListener("click", false));
        el.removeListener("click", listener, this, false);
        this.assertFalse(el.hasListener("click", false));
        el.dispose();
      },
      testRemoveListenerById: function testRemoveListenerById() {
        // flush at end
        var el = new qx.html.Element();
        var id = el.addListener("click", function () {}, this, false);
        this.assertTrue(el.hasListener("click", false));
        el.removeListenerById(id);
        this.assertFalse(el.hasListener("click", false));
        qx.html.Element.flush();
        el.dispose(); // flush after create

        var el = new qx.html.Element();
        qx.html.Element.flush();
        var id = el.addListener("click", function () {}, this, false);
        this.assertTrue(el.hasListener("click", false));
        el.removeListenerById(id);
        this.assertFalse(el.hasListener("click", false));
        el.dispose(); // flush after add

        var el = new qx.html.Element();
        var id = el.addListener("click", function () {}, this, false);
        qx.html.Element.flush();
        this.assertTrue(el.hasListener("click", false));
        el.removeListenerById(id);
        this.assertFalse(el.hasListener("click", false));
        el.dispose();
      },
      testAddListenerOnce: function testAddListenerOnce() {
        var el = new qx.html.Element("div", {
          width: '100px'
        });
        el.hide();
        qx.core.Init.getApplication().getRoot().getContentElement().add(el);
        var called = 0;
        el.addListenerOnce("appear", function () {
          this.debug("appear!");
          called++;
        }, this);
        el.show();
        qx.html.Element.flush();
        el.hide();
        qx.html.Element.flush();
        el.show();
        this.wait(100, function () {
          this.assertEquals(1, called);
          el.dispose();
        }, this);
      },
      testBasics: function testBasics() {
        //
        // BASICS
        //
        var el1 = new qx.html.Element();
        var el2a = new qx.html.Element();
        var el2b = new qx.html.Element();
        var el3a = new qx.html.Element();
        var el3b = new qx.html.Element();
        this.assertQxObject(el1);
        this.assertQxObject(el2a); // ...

        el1.setAttribute("id", "el1");
        el2a.setAttribute("id", "el2a");
        el2b.setAttribute("id", "el2b");
        el3a.setAttribute("id", "el3a");
        el3b.setAttribute("id", "el3b");
        this.assertIdentical(el1.getAttribute("id"), "el1");
        this.assertIdentical(el2a.getAttribute("id"), "el2a"); // ...

        el1.add(el2a, el2b);
        el2a.add(el3a, el3b);

        this._doc.add(el1);

        el3a.setAttribute("html", "<b>hello</b>");
        this.assertIdentical(el3a.getAttribute("html"), "<b>hello</b>");
        el1.setStyle("color", "blue");
        el1.setStyle("width", "100px").setStyle("height", "100px");
        this.assertCssColor("blue", el1.getStyle("color"));
        this.assertIdentical("100px", el1.getStyle("width"));
        this.assertIdentical("100px", el1.getStyle("height"));
        qx.html.Element.flush(); // DOM Structure Tests

        var pa = document.getElementById("el1");
        var ch1 = document.getElementById("el2a");
        var ch2 = document.getElementById("el2b");
        var ch3 = document.getElementById("el3a");
        var ch4 = document.getElementById("el3b");
        this.assertFalse(ch1 === ch2);
        this.assertIdentical(ch1.parentNode, pa);
        this.assertIdentical(ch2.parentNode, pa);
        this.assertIdentical(ch3.parentNode, ch1);
        this.assertIdentical(ch4.parentNode, ch1); // Internal Structure Tests

        this.assertIdentical(el1.getChildren()[0], el2a);
        this.assertIdentical(el1.getChildren()[1], el2b);
        this.assertIdentical(el2a.getChildren()[0], el3a);
        this.assertIdentical(el2a.getChildren()[1], el3b); //
        // POSITIONED INSERT #1
        //

        this.assertIdentical(this._doc.getChildren()[0], el1);
        var before1 = new qx.html.Element();
        before1.setAttribute("id", "before1");
        before1.insertBefore(el1);
        var after1 = new qx.html.Element();
        after1.setAttribute("id", "after1");
        after1.insertAfter(el1);
        this.assertIdentical(this._doc.getChildren()[0], before1);
        this.assertIdentical(this._doc.getChildren()[1], el1);
        this.assertIdentical(this._doc.getChildren()[2], after1);
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], before1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], after1.getDomElement()); //
        // POSITIONED INSERT #2
        //

        var before2 = new qx.html.Element();
        before2.setAttribute("id", "before2");

        this._doc.addAt(before2, 0);

        var after2 = new qx.html.Element();
        after2.setAttribute("id", "after2");

        this._doc.addAt(after2, 10);

        this.assertIdentical(this._doc.getChildren()[0], before2);
        this.assertIdentical(this._doc.getChildren()[1], before1);
        this.assertIdentical(this._doc.getChildren()[2], el1);
        this.assertIdentical(this._doc.getChildren()[3], after1);
        this.assertIdentical(this._doc.getChildren()[4], after2);
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], before2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], before1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], after1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], after2.getDomElement()); //
        // MOVE
        //

        before2.moveAfter(before1);
        after2.moveBefore(after1);
        this.assertIdentical(this._doc.getChildren()[0], before1);
        this.assertIdentical(this._doc.getChildren()[1], before2);
        this.assertIdentical(this._doc.getChildren()[2], el1);
        this.assertIdentical(this._doc.getChildren()[3], after2);
        this.assertIdentical(this._doc.getChildren()[4], after1);
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], before1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], before2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], after2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], after1.getDomElement()); //
        // SWITCH
        //

        var in1 = this._doc.indexOf(before2);

        var in2 = this._doc.indexOf(after2);

        this.assertIdentical(in1, 1);
        this.assertIdentical(in2, 3);
        before2.moveTo(in2);
        after2.moveTo(in1);
        this.assertIdentical(this._doc.getChildren()[0], before1);
        this.assertIdentical(this._doc.getChildren()[1], after2);
        this.assertIdentical(this._doc.getChildren()[2], el1);
        this.assertIdentical(this._doc.getChildren()[3], before2);
        this.assertIdentical(this._doc.getChildren()[4], after1);
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], before1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], after2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], before2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], after1.getDomElement()); //
        // REMOVE
        //

        this._doc.remove(before2);

        this._doc.remove(after2);

        this.assertIdentical(this._doc.getChildren()[0], before1);
        this.assertIdentical(this._doc.getChildren()[1], el1);
        this.assertIdentical(this._doc.getChildren()[2], after1);
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], before1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], after1.getDomElement()); // RE-ADD

        this._doc.add(before2, after2);

        this.assertIdentical(this._doc.getChildren()[0], before1);
        this.assertIdentical(this._doc.getChildren()[1], el1);
        this.assertIdentical(this._doc.getChildren()[2], after1);
        this.assertIdentical(this._doc.getChildren()[3], before2);
        this.assertIdentical(this._doc.getChildren()[4], after2);
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], before1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], after1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], before2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], after2.getDomElement()); // REMOVE, ADD, REMOVE, ADD
        // should be identical afterwards

        this._doc.remove(before2, after2);

        this._doc.add(before2, after2);

        this._doc.remove(before2, after2);

        this._doc.add(before2, after2);

        this.assertIdentical(this._doc.getChildren()[0], before1);
        this.assertIdentical(this._doc.getChildren()[1], el1);
        this.assertIdentical(this._doc.getChildren()[2], after1);
        this.assertIdentical(this._doc.getChildren()[3], before2);
        this.assertIdentical(this._doc.getChildren()[4], after2);
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], before1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], after1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], before2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], after2.getDomElement()); // REMOVER, MOVE AND INSERT IN ONE STEP

        this._doc.remove(before2);

        before1.moveAfter(after1);
        before2.insertBefore(before1);
        this.assertIdentical(this._doc.getChildren()[0], el1);
        this.assertIdentical(this._doc.getChildren()[1], after1);
        this.assertIdentical(this._doc.getChildren()[2], before2);
        this.assertIdentical(this._doc.getChildren()[3], before1);
        this.assertIdentical(this._doc.getChildren()[4], after2);
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], after1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], before2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], before1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], after2.getDomElement());
        /*
        BEFORE:        AFTER1:        AFTER2:        AFTER3:
         before1        before1        el1            el1
        el1            el1            after1         after1
        after1         after1         before1        before2
        before2        after2         after2         before1
        after2                                       after2
        */
        // SORT

        var a = this._doc.getChildren();

        for (var i = 1, l = a.length; i < l; i++) {
          a[i].moveTo(0);
        }

        this.assertIdentical(this._doc.getChildren()[0], after2);
        this.assertIdentical(this._doc.getChildren()[1], before1);
        this.assertIdentical(this._doc.getChildren()[2], before2);
        this.assertIdentical(this._doc.getChildren()[3], after1);
        this.assertIdentical(this._doc.getChildren()[4], el1);
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], after2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], before1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], before2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], after1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], el1.getDomElement()); // ROTATION

        before1.moveAfter(before2);
        this.assertIdentical(this._doc.getChildren()[0], after2);
        this.assertIdentical(this._doc.getChildren()[1], before2);
        this.assertIdentical(this._doc.getChildren()[2], before1);
        this.assertIdentical(this._doc.getChildren()[3], after1);
        this.assertIdentical(this._doc.getChildren()[4], el1);
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], after2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], before2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], before1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], after1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], el1.getDomElement());
      },
      testExclude: function testExclude() {
        this.info("Create five elements (2 hidden)");
        var el1 = new qx.html.Element();
        el1.setAttribute("id", "el1");
        var el2 = new qx.html.Element();
        el2.setAttribute("id", "el2");
        var el3 = new qx.html.Element();
        el3.setAttribute("id", "el3");
        var el4 = new qx.html.Element();
        el4.setAttribute("id", "el4");
        var el5 = new qx.html.Element();
        el5.setAttribute("id", "el5");

        this._doc.add(el1, el2, el3, el4, el5);

        el2.exclude();
        el4.exclude();
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el5.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], undefined);
        /**
         * Current:
         *
         * doc
         * - el1
         * - el3
         * - el5
         */

        this.info("Make simple hidden element visible");
        el2.include();
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], el5.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], undefined);
        /**
         * Current:
         *
         * doc
         * - el1
         * - el2
         * - el3
         * - el5
         */

        this.info("Make complex hidden element visible");
        var el4_1 = new qx.html.Element();
        el4_1.setAttribute("id", "el4_1");
        var el4_2 = new qx.html.Element();
        el4_2.setAttribute("id", "el4_2");
        el4_2.setStyle("color", "red");
        el4_2.setAttribute("text", "el4_2");
        el4_2.exclude();
        var el4_3 = new qx.html.Element();
        el4_3.setAttribute("id", "el4_3");
        el4.add(el4_1, el4_2, el4_3);
        el4.include();
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], el4.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], el5.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[5], undefined);
        this.assertIdentical(this._doc.getDomElement().childNodes[3].firstChild, el4_1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3].lastChild, el4_3.getDomElement());
        /**
         * Current:
         *
         * doc
         * - el1
         * - el2
         * - el3
         * - el4
         *   - el4_1
         *   - el4_3
         * - el5
         */

        this.info("Show inner element");
        el4_2.include();
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], el4.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], el5.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[5], undefined);
        this.assertIdentical(this._doc.getDomElement().childNodes[3].childNodes[0], el4_1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3].childNodes[1], el4_2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3].childNodes[2], el4_3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3].childNodes[3], undefined);
        /**
         * Current:
         *
         * doc
         * - el1
         * - el2
         * - el3
         * - el4
         *   - el4_1
         *   - el4_2
         *   - el4_3
         * - el5
         */

        this.info("Internal move while hidden");
        el4.exclude();
        el4_3.moveTo(0);
        el4.remove(el4_2);
        el4_1.setStyle("fontSize", "20px");
        el4_1.setAttribute("text", "el4_1");
        el4.setStyle("backgroundColor", "#ccc");
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], el5.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], undefined);
        /**
         * Current:
         *
         * doc
         * - el1
         * - el2
         * - el3
         * - el5
         */

        this.info("Internal move while hidden -> show again");
        el4.include();
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], el4.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], el5.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[5], undefined);
        this.assertIdentical(this._doc.getDomElement().childNodes[3].childNodes[0], el4_3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3].childNodes[1], el4_1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3].childNodes[2], undefined);
        /**
         * Current:
         *
         * doc
         * - el1
         * - el2
         * - el3
         * - el4
         *   - el4_3
         *   - el4_1
         * - el5
         */

        el4_2.dispose();
      },
      testVisibility: function testVisibility() {
        this.info("Create five elements (2 hidden)");
        var el1 = new qx.html.Element();
        el1.setAttribute("id", "el1");
        var el2 = new qx.html.Element();
        el2.setAttribute("id", "el2");
        var el3 = new qx.html.Element();
        el3.setAttribute("id", "el3");
        var el4 = new qx.html.Element();
        el4.setAttribute("id", "el4");
        var el5 = new qx.html.Element();
        el5.setAttribute("id", "el5");

        this._doc.add(el1, el2, el3, el4, el5);

        el2.hide();
        el4.hide();
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el5.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], undefined);
        /**
         * Current:
         *
         * doc
         * - el1
         * - el3
         * - el5
         */

        this.info("Show one of the two hidden elements");
        el2.show();
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], el5.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], undefined);
        /**
         * Current:
         *
         * doc
         * - el1
         * - el2
         * - el3
         * - el5
         */

        this.info("Hide a rendered element");
        el3.hide();
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], el5.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], undefined);
        this.assertIdentical(el3.getDomElement().style.display, "none");
        /**
         * Current:
         *
         * doc
         * - el1
         * - el2
         * - el3 (hidden)
         * - el5
         */

        this.info("Exclude & show together");
        el3.exclude();
        el3.show();
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el5.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], undefined);
        this.assertIdentical(el3.getDomElement().style.display, "");
        /**
         * Current:
         *
         * doc
         * - el1
         * - el2
         * - el5
         */

        this.info("Include one and hide another element");
        el3.include();
        el2.hide();
        qx.html.Element.flush();
        this.assertIdentical(this._doc.getDomElement().childNodes[0], el1.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[1], el2.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[2], el3.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[3], el5.getDomElement());
        this.assertIdentical(this._doc.getDomElement().childNodes[4], undefined);
        this.assertIdentical(el2.getDomElement().style.display, "none");
        this.assertIdentical(el3.getDomElement().style.display, "");
        /**
         * Current:
         *
         * doc
         * - el1
         * - el2 (hidden)
         * - el3
         * - el5
         */
      },
      testResetStyles: function testResetStyles() {
        var el = new qx.html.Element();

        this._doc.add(el);

        qx.html.Element.flush();
        this.assertIdentical(el.getDomElement().style.backgroundColor, '');
        el.setStyle("backgroundColor", "green");
        qx.html.Element.flush();
        this.assertCssColor("green", el.getDomElement().style.backgroundColor);
        el.setStyle("backgroundColor", null);
        el.setStyle("backgroundColor", "yellow");
        qx.html.Element.flush();
        this.assertCssColor("yellow", el.getDomElement().style.backgroundColor);
        el.setStyle("backgroundColor", null);
        qx.html.Element.flush();
        this.assertIdentical(el.getDomElement().style.backgroundColor, "");
      },
      testGetTextSelection: function testGetTextSelection() {
        var el = new qx.html.Element("input");
        el.setAttribute("value", "vanillebaer");

        this._doc.add(el);

        qx.html.Element.flush();
        qx.bom.Selection.set(el.getDomElement(), 0, 4);
        this.assertEquals(el.getTextSelection(), "vani");
        el.clearTextSelection();
        qx.html.Element.flush();
      },
      testSetTextSelection: function testSetTextSelection() {
        var el = new qx.html.Element("input");
        el.setAttribute("value", "vanillebaer");

        this._doc.add(el);

        qx.html.Element.flush();
        qx.bom.Selection.set(el.getDomElement(), 0, 4);
        this.assertEquals(el.getTextSelection(), "vani");
        el.setTextSelection(2, 5);
        this.assertEquals(el.getTextSelection(), "nil");
        el.clearTextSelection();
        qx.html.Element.flush();
      },
      testClearTextSelection: function testClearTextSelection() {
        var el = new qx.html.Element("input");
        el.setAttribute("value", "vanillebaer");

        this._doc.add(el);

        qx.html.Element.flush();
        qx.bom.Selection.set(el.getDomElement(), 0, 2);
        this.assertEquals(el.getTextSelection(), "va");
        el.clearTextSelection();
        this.assertEquals(el.getTextSelection(), "");
        el.clearTextSelection();
        qx.html.Element.flush();
      },
      testSelectAllText: function testSelectAllText() {
        var el = new qx.html.Element("input");
        el.setAttribute("value", "vanillebaer");

        this._doc.add(el);

        qx.html.Element.flush();
        qx.bom.Selection.set(el.getDomElement(), 0);
        this.assertEquals(el.getTextSelection(), "vanillebaer");
        el.clearTextSelection();
        qx.html.Element.flush();
      }
    }
  });
  qx.test.html.Element.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.html.Flash": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/test/UnitTestFlash.swf)
   */
  qx.Class.define("qx.test.html.Flash", {
    extend: qx.dev.unit.TestCase,
    members: {
      __flash__P_250_0: null,
      setUp: function setUp() {
        this.__flash__P_250_0 = new qx.html.Flash();
      },
      tearDown: function tearDown() {
        this.__flash__P_250_0.dispose();

        this.__flash__P_250_0 = null;
      },
      testSetSource: function testSetSource(value) {
        this.__flash__P_250_0.setSource("movieURL");

        this.assertIdentical("movieURL", this.__flash__P_250_0.getAttributes().movie);
      },
      testSetId: function testSetId(value) {
        this.__flash__P_250_0.setId("flashID");

        this.assertIdentical("flashID", this.__flash__P_250_0.getAttributes().id);
      },
      testSetVariables: function testSetVariables(value) {
        var map = {
          a: "valueA",
          b: "valueB"
        };

        this.__flash__P_250_0.setVariables(map);

        this.assertIdentical(map, this.__flash__P_250_0.getVariables());
      },
      testSetAttribute: function testSetAttribute(key, value) {
        this.__flash__P_250_0.setAttribute("attrib1", "hoho");

        this.__flash__P_250_0.setAttribute("attrib2", "gogo");

        this.__flash__P_250_0.setAttribute("attrib3", true);

        this.__flash__P_250_0.setAttribute("attrib4", false);

        var map = this.__flash__P_250_0.getAttribute();

        this.assertIdentical("hoho", this.__flash__P_250_0.getAttributes().attrib1);
        this.assertIdentical("gogo", this.__flash__P_250_0.getAttributes().attrib2);
        this.assertTrue(this.__flash__P_250_0.getAttributes().attrib3);
        this.assertFalse(this.__flash__P_250_0.getAttributes().attrib4);

        this.__flash__P_250_0.setAttribute("attrib1");

        this.__flash__P_250_0.setAttribute("attrib3");

        this.assertUndefined(this.__flash__P_250_0.getAttributes().attrib1);
        this.assertIdentical("gogo", this.__flash__P_250_0.getAttributes().attrib2);
        this.assertUndefined(this.__flash__P_250_0.getAttributes().attrib3);
        this.assertFalse(this.__flash__P_250_0.getAttributes().attrib4);

        this.__flash__P_250_0.setAttribute("attrib2", null);

        this.__flash__P_250_0.setAttribute("attrib4", null);

        this.assertUndefined(this.__flash__P_250_0.getAttributes().attrib1);
        this.assertUndefined(this.__flash__P_250_0.getAttributes().attrib2);
        this.assertUndefined(this.__flash__P_250_0.getAttributes().attrib3);
        this.assertUndefined(this.__flash__P_250_0.getAttributes().attrib4);
      },
      testSetParam: function testSetParam(key, value) {
        this.__flash__P_250_0.setParam("param1", "hoho");

        this.__flash__P_250_0.setParam("param2", "gogo");

        this.__flash__P_250_0.setParam("param3", true);

        this.__flash__P_250_0.setParam("param4", false);

        var map = this.__flash__P_250_0.getParams();

        this.assertIdentical("hoho", this.__flash__P_250_0.getParams().param1);
        this.assertIdentical("gogo", this.__flash__P_250_0.getParams().param2);
        this.assertTrue(this.__flash__P_250_0.getParams().param3);
        this.assertFalse(this.__flash__P_250_0.getParams().param4);

        this.__flash__P_250_0.setParam("param1");

        this.__flash__P_250_0.setParam("param3");

        this.assertUndefined(this.__flash__P_250_0.getParams().param1);
        this.assertIdentical("gogo", this.__flash__P_250_0.getParams().param2);
        this.assertUndefined(this.__flash__P_250_0.getParams().param3);
        this.assertFalse(this.__flash__P_250_0.getParams().param4);

        this.__flash__P_250_0.setParam("param2", null);

        this.__flash__P_250_0.setParam("param4", null);

        this.assertUndefined(this.__flash__P_250_0.getParams().param1);
        this.assertUndefined(this.__flash__P_250_0.getParams().param2);
        this.assertUndefined(this.__flash__P_250_0.getParams().param3);
        this.assertUndefined(this.__flash__P_250_0.getParams().param4);
      }
    }
  });
  qx.test.html.Flash.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "require": true
      },
      "qx.dev.unit.MMock": {
        "require": true
      },
      "qx.html.Root": {},
      "qx.html.Iframe": {},
      "qx.util.ResourceManager": {},
      "qx.bom.Iframe": {},
      "qx.html.Element": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   *
   * @asset(qx/static/blank.html)
   */
  qx.Class.define("qx.test.html.Iframe", {
    extend: qx.dev.unit.TestCase,
    include: qx.dev.unit.MMock,
    members: {
      __doc__P_251_0: null,
      __frame__P_251_1: null,
      __origin__P_251_2: null,
      __destSource__P_251_3: null,
      __alredyRun__P_251_4: false,
      setUp: function setUp() {
        var helper = document.createElement("div");
        document.body.appendChild(helper);
        this.__doc__P_251_0 = new qx.html.Root(helper);

        this.__doc__P_251_0.setAttribute("id", "doc");

        var frame = this.__frame__P_251_1 = new qx.html.Iframe();

        this.__doc__P_251_0.add(frame); // Source in parent directory is not of same origin
        // when using file protocol – use non-existing file
        // in same directory instead


        if (window.location.protocol === "file:") {
          this.__destSource__P_251_3 = "blank.html";
        } else {
          this.__destSource__P_251_3 = qx.util.ResourceManager.getInstance().toUri("qx/static/blank.html");
        }
      },
      "test: set source to URL with same origin": function testSetSourceToURLWithSameOrigin() {
        var frame = this.__frame__P_251_1;
        var source = this.__destSource__P_251_3;
        frame.addListener("load", function () {
          this.resume(function () {
            var element = frame.getDomElement();
            var currentUrl = qx.bom.Iframe.queryCurrentUrl(element) || element.src;
            var source = frame.getSource();
            var blank = "\/blank.html$";

            var msg = function msg(actual) {
              return "Must be " + currentUrl + ", but was " + actual;
            }; // BOM


            this.assertString(currentUrl);
            this.assertMatch(currentUrl, blank, msg(currentUrl)); // HTML

            this.assertString(source);
            this.assertMatch(source, blank, msg(source));
          });
        }, this);
        frame.setSource(source);
        qx.html.Element.flush();
        this.wait();
      },
      "test: update source on navigate": function testUpdateSourceOnNavigate() {
        var frame = this.__frame__P_251_1; // As soon as the original frame has loaded,
        // fake user-action and browse

        var source = this.__destSource__P_251_3;
        frame.addListenerOnce("load", function () {
          qx.html.Element.flush();
          qx.bom.Iframe.setSource(frame.getDomElement(), source);
        });
        qx.html.Element.flush(); // Give changed frame some time to load

        this.wait(500, function () {
          this.assertMatch(frame.getSource(), "\/blank.html$");
        }, this);
      },
      "test: skip setting source if frame is already on URL": function testSkipSettingSourceIfFrameIsAlreadyOnURL() {
        var frame = this.__frame__P_251_1; // As soon as the original frame has loaded,
        // fake user-action and browse

        var source = this.__destSource__P_251_3;
        frame.addListenerOnce("load", function () {
          qx.bom.Iframe.setSource(frame.getDomElement(), source);
        });
        qx.html.Element.flush();
        var origSetSource;
        frame.addListener("load", function () {
          origSetSource = qx.bom.Iframe.setSource;

          qx.bom.Iframe.setSource = function () {
            throw "setSource";
          };

          try {
            var url = qx.bom.Iframe.queryCurrentUrl(frame.getDomElement());
            frame.setSource(url);
            qx.html.Element.flush();
            this.resume();
          } catch (e) {
            this.resume(function () {
              this.fail("Setting same URL must be skipped");
            });
          }

          qx.bom.Iframe.setSource = origSetSource;
        }, this);
        this.wait();
      },
      "test: set null source if frame is cross-origin": function testSetNullSourceIfFrameIsCrossOrigin() {
        var frame = this.__frame__P_251_1;

        if (this.__alredyRun__P_251_4) {
          this.skip("This test can only run once. Reload to run again.");
        } // On cross origin


        frame.addListener("load", function () {
          this.resume(function () {
            var elem = frame.getDomElement();
            this.spy(qx.bom.Iframe, "setSource");
            frame.setSource(null);
            this.assertCalledWith(qx.bom.Iframe.setSource, elem, null);
          });
        }, this);
        frame.setSource("http://example.com");
        this.__alredyRun__P_251_4 = true;
        this.wait();
      },
      tearDown: function tearDown() {
        qx.html.Element.flush();
        var div = document.getElementById("doc");
        document.body.removeChild(div);
        this.getSandbox().restore();

        this.__frame__P_251_1.dispose();

        this.__frame__P_251_1 = null;
      }
    }
  });
  qx.test.html.Iframe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Json": {},
      "qx.dev.unit.Sinon": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * Mixin containing special assert methods
   */
  qx.Mixin.define("qx.test.io.MAssert", {
    members: {
      /**
       * Deep equal comparison, using Sinon's `deepEqual` comparison.
       * Two values are "deep equal" if:
       *
       *   - They are equal, according to samsam.identical
       *   (https://sinonjs.github.io/samsam/)
       *   - They are both date objects representing the same time
       *   - They are both arrays containing elements that are all deepEqual
       *   - They are objects with the same set of properties, and each property
       *     in obj1 is deepEqual to the corresponding property in obj2
       *
       * Supports cyclic objects.
       * @param {*} expected
       * @param {*} actual
       * @param {String?} msg
       */
      assertDeepEquals: function assertDeepEquals(expected, actual, msg) {
        if (!msg) {
          msg = `Failed to assert that ${qx.lang.Json.stringify(actual)} deeply equals ${qx.lang.Json.stringify(expected)}.`;
        }

        this.assert(qx.dev.unit.Sinon.getSinon().deepEqual(expected, actual), msg);
      },

      /**
       * Assert that an message is dispatched via the message bus.
       *
       * @param {String} name The name of the message
       * @param {*|Function|undefined} data The data of the message, if any, or a
       * valiation function which returns true of false depending on whether the
       * data was correct. If you dont want to check the data and want to provide
       * a message as the third argument, pass `undefined` explicitly.
       * @param msg {String?""} Message to be shows if the assertion fails.
       */
      assertMessageDispatched: function assertMessageDispatched(name, data, msg) {
        throw new Error("Needs to be implemented");
      }
    }
  });
  qx.test.io.MAssert.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.unit.TestCase": {
        "construct": true,
        "require": true
      },
      "qx.test.io.MAssert": {
        "require": true
      },
      "qx.io.graphql.Client": {
        "construct": true
      },
      "qx.io.graphql.protocol.Request": {},
      "qx.io.exception.Protocol": {},
      "qx.io.exception.Transport": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */
  qx.Class.define("qx.test.io.graphql.Client", {
    extend: qx.dev.unit.TestCase,
    include: [qx.test.io.MAssert],
    statics: {
      TEST_ENDPOINT: "https://countries-274616.ew.r.appspot.com/"
    },

    construct() {
      qx.dev.unit.TestCase.constructor.call(this);
      this.client = new qx.io.graphql.Client(this.constructor.TEST_ENDPOINT);
    },

    members: {
      async runQuery(query, expected) {
        let req = new qx.io.graphql.protocol.Request({
          query
        });
        let result = await this.client.send(req);
        this.assertDeepEquals(expected, result);
      },

      async runQueryWithVariables(query, variables, expected) {
        let req = new qx.io.graphql.protocol.Request({
          query
        });
        req.marshalVariables(variables);
        let result = await this.client.send(req);
        this.assertDeepEquals(expected, result);
      },

      async "test: execute query"() {
        await this.runQuery(`query {
          Country(name: "Switzerland") {
            name, nativeName, flag {svgFile},
            officialLanguages {name}
          }
        }`, {
          "Country": [{
            "name": "Switzerland",
            "nativeName": "Schweiz",
            "flag": {
              "svgFile": "https://restcountries.eu/data/che.svg"
            },
            "officialLanguages": [{
              "name": "Italian"
            }, {
              "name": "French"
            }, {
              "name": "German"
            }]
          }]
        });
      },

      async "test: execute query with variables"() {
        await this.runQueryWithVariables(`query($country:String!) {
         Country(name: $country) {
           nativeName
           officialLanguages { name }
         }
       }`, {
          "country": "Belgium"
        }, {
          "Country": [{
            "nativeName": "België",
            "officialLanguages": [{
              "name": "German"
            }, {
              "name": "French"
            }, {
              "name": "Dutch"
            }]
          }]
        });
      },

      async "test: expect protocol error"() {
        try {
          await this.runQuery(`query { invalid}`);
        } catch (e) {
          this.assertInstance(e, qx.io.exception.Protocol);
          this.assertEquals("Cannot query field \"invalid\" on type \"Query\".", e.message);
          return;
        }

        throw new Error("Query should throw qx.io.exception.Protocol");
      },

      async "test: expect transport error"() {
        try {
          let client = new qx.io.graphql.Client("https://doesnotexist.org/" + Math.random());
          let response = await client.send("query: { doesnotmatter }");
        } catch (e) {
          this.assertInstance(e, qx.io.exception.Transport);
          return;
        }

        throw new Error("Query should throw qx.io.exception.Transport");
      }

    }
  });
  qx.test.io.graphql.Client.$$dbClassInfo = $$dbClassInfo;
})();
//# sourceMappingURL=package-7.js.map?dt=1599488415190
qx.$$packageData['7'] = {
  "locales": {},
  "resources": {},
  "translations": {
    "en": {}
  }
};
