(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.core.IDisposable": {
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      },
      "qx.bom.rest.Resource": {},
      "qx.event.type.Rest": {},
      "qx.io.request.Xhr": {},
      "qx.lang.Function": {},
      "qx.event.Timer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /**
   * Client-side wrapper of a REST resource.
   *
   * Each instance represents a resource in terms of REST. A number of actions
   * (usually HTTP methods) unique to the resource can be defined and invoked.
   * A resource with its actions is configured declaratively by passing a resource
   * description to the constructor, or programmatically using {@link #map}.
   *
   * Each action is associated to a route. A route is a combination of method,
   * URL pattern and optional parameter constraints.
   *
   * An action is invoked by calling a method with the same name. When a URL
   * pattern of a route contains positional parameters, those parameters must be
   * passed when invoking the associated action. Also, constraints defined in the
   * route must be satisfied.
   *
   * When an action is invoked, a request is configured according to the associated
   * route, is passed the URL parameters, request body data, and finally send.
   * What kind of request is send can be configured by overwriting {@link #_getRequest}.
   *
   * No constraints on the action's name or the scope of the URLs are imposed. However,
   * if you want to follow RESTful design patterns it is recommended to name actions
   * the same as the HTTP action.
   *
   * <pre class="javascript">
   * var description = {
   *  "get": { method: "GET", url: "/photo/{id}" },
   *  "put": { method: "PUT", url: "/photo/{id}"},
   *  "post": { method: "POST", url: "/photos/"}
   * };
   * var photo = new qx.io.rest.Resource(description);
   * // Can also be written: photo.invoke("get", {id: 1});
   * photo.get({id: 1});
   *
   * // Additionally sets request data (provide it as string or set the content type)
   * // In a RESTful environment this creates a new resource with the given 'id'
   * photo.configureRequest(function(req) {
   *  req.setRequestHeader("Content-Type", "application/json");
   * });
   * photo.put({id: 1}, {title: "Monkey"});
   *
   * // Additionally sets request data (provide it as string or set the content type)
   * // In a RESTful environment this adds a new resource to the resource collection 'photos'
   * photo.configureRequest(function(req) {
   *  req.setRequestHeader("Content-Type", "application/json");
   * });
   * photo.post(null, {title: "Monkey"});
   * </pre>
   *
   * To check for existence of URL parameters or constrain them to a certain format, you
   * can add a <code>check</code> property to the description. See {@link #map} for details.
   *
   * <pre class="javascript">
   * var description = {
   *  "get": { method: "GET", url: "/photo/{id}", check: { id: /\d+/ } }
   * };
   * var photo = new qx.io.rest.Resource(description);
   * // photo.get({id: "FAIL"});
   * // -- Error: "Parameter 'id' is invalid"
   * </pre>
   *
   * If your description happens to use the same action more than once, consider
   * defining another resource.
   *
   * <pre class="javascript">
   * var description = {
   *  "get": { method: "GET", url: "/photos"},
   * };
   * // Distinguish "photo" (singular) and "photos" (plural) resource
   * var photos = new qx.io.rest.Resource(description);
   * photos.get();
   * </pre>
   *
   * Basically, all routes of a resource should point to the same URL (resource in
   * terms of HTTP). One acceptable exception of this constraint are resources where
   * required parameters are part of the URL (<code>/photos/1/</code>) or filter
   * resources. For instance:
   *
   * <pre class="javascript">
   * var description = {
   *  "get": { method: "GET", url: "/photos/{tag}" }
   * };
   * var photos = new qx.io.rest.Resource(description);
   * photos.get();
   * photos.get({tag: "wildlife"})
   * </pre>
   *
   * Strictly speaking, the <code>photos</code> instance represents two distinct resources
   * and could therefore just as well mapped to two distinct resources (for instance,
   * named photos and photosTagged). What style to choose depends on the kind of data
   * returned. For instance, it seems sensible to stick with one resource if the filter
   * only limits the result set (i.e. the individual results have the same properties).
   *
   * In order to respond to successful (or erroneous) invocations of actions,
   * either listen to the generic "success" or "error" event and get the action
   * from the event data, or listen to action specific events defined at runtime.
   * Action specific events follow the pattern "&lt;action&gt;Success" and
   * "&lt;action&gt;Error", e.g. "indexSuccess".
   * 
   * NOTE: Instances of this class must be disposed of after use
   *
   */
  qx.Class.define("qx.io.rest.Resource", {
    extend: qx.core.Object,
    implement: [qx.core.IDisposable],

    /**
     * @param description {Map?} Each key of the map is interpreted as
     *  <code>action</code> name. The value associated to the key must be a map
     *  with the properties <code>method</code> and <code>url</code>.
     *  <code>check</code> is optional. Also see {@link #map}.
     *
     * For example:
     *
     * <pre class="javascript">
     * { get: {method: "GET", url: "/photos/{id}", check: { id: /\d+/ }} }
     * </pre>
     *
     * @see qx.bom.rest
     * @see qx.io.rest
     */
    construct: function construct(description) {
      qx.core.Object.constructor.call(this);
      this.__longPollHandlers__P_174_0 = {};
      this.__pollTimers__P_174_1 = {};
      this.__routes__P_174_2 = {};
      this._resource = this._tailorResource(this._getResource());

      try {
        if (typeof description !== "undefined") {
          {
            qx.core.Assert.assertMap(description);
          }

          this.__mapFromDescription__P_174_3(description);
        }
      } catch (e) {
        this.dispose();
        throw e;
      }
    },
    events: {
      /**
       * Fired when any request was successful.
       *
       * The action the successful request is associated to, as well as the
       * request itself, can be retrieved from the event’s properties.
       * Additionally, an action specific event is fired that follows the pattern
       * "<action>Success", e.g. "indexSuccess".
       */
      "success": "qx.event.type.Rest",

      /**
       * Fired when request associated to action given in prefix was successful.
       *
       * For example, "indexSuccess" is fired when <code>index()</code> was
       * successful.
       */
      "actionSuccess": "qx.event.type.Rest",

      /**
       * Fired when any request fails.
       *
       * The action the failed request is associated to, as well as the
       * request itself, can be retrieved from the event’s properties.
       * Additionally, an action specific event is fired that follows the pattern
       * "<action>Error", e.g. "indexError".
       */
      "error": "qx.event.type.Rest",

      /**
       * Fired when any request associated to action given in prefix fails.
       *
       * For example, "indexError" is fired when <code>index()</code> failed.
       */
      "actionError": "qx.event.type.Rest"
    },
    statics: {
      /**
       * Number of milliseconds below a long-poll request is considered immediate and
       * subject to throttling checks.
       */
      POLL_THROTTLE_LIMIT: 100,

      /**
       * Number of immediate long-poll responses accepted before throttling takes place.
       */
      POLL_THROTTLE_COUNT: 30,

      /**
       * A symbol used in checks to declare required parameter.
       */
      REQUIRED: true,

      /**
       * Get placeholders from URL.
       *
       * @param url {String} The URL to parse for placeholders.
       * @return {Array} Array of placeholders without the placeholder prefix.
       */
      placeholdersFromUrl: function placeholdersFromUrl(url) {
        return qx.bom.rest.Resource.placeholdersFromUrl(url);
      }
    },
    members: {
      _resource: null,
      __longPollHandlers__P_174_0: null,
      __pollTimers__P_174_1: null,
      __routes__P_174_2: null,

      /**
       * Get resource.
       *
       * May be overridden to change type of resource.
       * @param description {Map?} See construct.
       * @return {qx.bom.rest.Resource} Resource implementation which does the heavy lifting.
       */
      _getResource: function _getResource(description) {
        return new qx.bom.rest.Resource(description);
      },

      /**
       * Tailors (apply dependency injection) the given resource to fit our needs.
       *
       * @param resource {qx.bom.rest.Resource} Resource.
       * @return {qx.bom.rest.Resource} Tailored resource.
       */
      _tailorResource: function _tailorResource(resource) {
        // inject different request implementation
        resource.setRequestFactory(this._getRequest); // inject different request handling

        resource.setRequestHandler({
          onsuccess: {
            callback: function callback(req, action) {
              return function () {
                var props = [req.getResponse(), null, false, req, action, req.getPhase()];
                this.fireEvent(action + "Success", qx.event.type.Rest, props);
                this.fireEvent("success", qx.event.type.Rest, props);
              };
            },
            context: this
          },
          onfail: {
            callback: function callback(req, action) {
              return function () {
                var props = [req.getResponse(), null, false, req, action, req.getPhase()];
                this.fireEvent(action + "Error", qx.event.type.Rest, props);
                this.fireEvent("error", qx.event.type.Rest, props);
              };
            },
            context: this
          },
          onloadend: {
            callback: function callback(req, action) {
              return function () {
                req.dispose();
              };
            },
            context: this
          }
        });
        return resource;
      },
      //
      // Request
      //

      /**
       * Configure request.
       *
       * @param callback {Function} Function called before request is send.
       *   Receives request, action, params and data.
       *
       * <pre class="javascript">
       * res.configureRequest(function(req, action, params, data) {
       *   if (action === "index") {
       *     req.setAccept("application/json");
       *   }
       * });
       * </pre>
       */
      configureRequest: function configureRequest(callback) {
        this._resource.configureRequest(callback);
      },

      /**
       * Get request.
       *
       * May be overridden to change type of request.
       * @return {qx.io.request.Xhr} Xhr object
       */
      _getRequest: function _getRequest() {
        return new qx.io.request.Xhr();
      },
      //
      // Routes and actions
      //

      /**
       * Map action to combination of method and URL pattern.
       *
       * <pre class="javascript">
       *   res.map("get", "GET", "/photos/{id}", {id: /\d+/});
       *
       *   // GET /photos/123
       *   res.get({id: "123"});
       * </pre>
       *
       * @param action {String} Action to associate to request.
       * @param method {String} Method to configure request with.
       * @param url {String} URL to configure request with. May contain positional
       *   parameters (<code>{param}</code>) that are replaced by values given when the action
       *   is invoked. Parameters are optional, unless a check is defined. A default
       *   value can be provided (<code>{param=default}</code>).
       * @param check {Map?} Map defining parameter constraints, where the key is
       *   the URL parameter and the value a regular expression (to match string) or
       *   <code>qx.io.rest.Resource.REQUIRED</code> (to verify existence).
       */
      map: function map(action, method, url, check) {
        // add dynamic methods also on ourself to allow 'invoke()' delegation
        this.__addAction__P_174_4(action, method, url, check);

        this._resource.map(action, method, url, check);
      },

      /**
       * Map actions to members.
       *
       * @param action {String} Action to associate to request.
       * @param method {String} Method to configure request with.
       * @param url {String} URL to configure request with. May contain positional
       *   parameters (<code>{param}</code>) that are replaced by values given when the action
       *   is invoked. Parameters are optional, unless a check is defined. A default
       *   value can be provided (<code>{param=default}</code>).
       * @param check {Map?} Map defining parameter constraints, where the key is
       *   the URL parameter and the value a regular expression (to match string) or
       *   <code>qx.io.rest.Resource.REQUIRED</code> (to verify existence).
       */
      __addAction__P_174_4: function __addAction__P_174_4(action, method, url, check) {
        this.__routes__P_174_2[action] = [method, url, check]; // Undefine generic getter when action is named "get"

        if (action == "get") {
          this[action] = undefined;
        } // Do not overwrite existing "non-action" methods unless the method is
        // null (i.e. because it exists as a stub for documentation)


        if (typeof this[action] !== "undefined" && this[action] !== null && this[action].action !== true) {
          throw new Error("Method with name of action (" + action + ") already exists");
        }

        this.__declareEvent__P_174_5(action + "Success");

        this.__declareEvent__P_174_5(action + "Error");

        this[action] = qx.lang.Function.bind(function () {
          Array.prototype.unshift.call(arguments, action);
          return this.invoke.apply(this, arguments);
        }, this); // Method is safe to overwrite

        this[action].action = true;
      },

      /**
       * Invoke action with parameters.
       *
       * Internally called by actions dynamically created.
       *
       * May be overridden to customize action and parameter handling.
       *
       * @lint ignoreUnused(successHandler, failHandler, loadEndHandler)
       *
       * @param action {String} Action to invoke.
       * @param params {Map} Map of parameters inserted into URL when a matching
       *  positional parameter is found.
       * @param data {Map|String} Data to be send as part of the request.
       *  See {@link qx.io.request.AbstractRequest#requestData}.
       * @return {Number} Id of the action's invocation.
       */
      invoke: function invoke(action, params, data) {
        var params = params == null ? {} : params; // Cache parameters

        this.__routes__P_174_2[action].params = params;
        return this._resource.invoke(action, params, data);
      },

      /**
       * Set base URL.
       *
       * The base URL is prepended to the URLs given in the description.
       * Changes affect all future invocations.
       *
       * @param baseUrl {String} Base URL.
       */
      setBaseUrl: function setBaseUrl(baseUrl) {
        this._resource.setBaseUrl(baseUrl);
      },

      /**
       * Abort action.
       *
       * Example:
       *
       * <pre class="javascript">
       *   // Abort all invocations of action
       *   res.get({id: 1});
       *   res.get({id: 2});
       *   res.abort("get");
       *
       *   // Abort specific invocation of action (by id)
       *   var actionId = res.get({id: 1});
       *   res.abort(actionId);
       * </pre>
       *
       * @param varargs {String|Number} Action of which all invocations to abort
       *  (when string), or a single invocation of an action to abort (when number)
       */
      abort: function abort(varargs) {
        this._resource.abort(varargs);
      },

      /**
       * Resend request associated to action.
       *
       * Replays parameters given when action was invoked originally.
       *
       * @param action {String} Action to refresh.
       */
      refresh: function refresh(action) {
        this._resource.refresh(action);
      },

      /**
       * Periodically invoke action.
       *
       * Replays parameters given when action was invoked originally. When the
       * action was not yet invoked and requires parameters, parameters must be
       * given.
       *
       * Please note that IE tends to cache overly aggressive. One work-around is
       * to disable caching on the client side by configuring the request with
       * <code>setCache(false)</code>. If you control the server, a better
       * work-around is to include appropriate headers to explicitly control
       * caching. This way you still avoid requests that can be correctly answered
       * from cache (e.g. when nothing has changed since the last poll). Please
       * refer to <a href="http://www.mnot.net/javascript/xmlhttprequest/cache.html">
       * XMLHttpRequest Caching Test</a> for available options.
       *
       * @lint ignoreUnused(intervalListener)
       *
       * @param action {String} Action to poll.
       * @param interval {Number} Interval in ms.
       * @param params {Map?} Map of parameters. See {@link #invoke}.
       * @param immediately {Boolean?false} <code>true</code>, if the poll should
       *   invoke a call immediately.
       * @return {qx.event.Timer} Timer that periodically invokes action. Use to
       *   stop or resume. Is automatically disposed on disposal of object.
       */
      poll: function poll(action, interval, params, immediately) {
        // Dispose timer previously created for action
        if (this.__pollTimers__P_174_1[action]) {
          this.__pollTimers__P_174_1[action].dispose();
        } // Fallback to previous params


        if (typeof params == "undefined") {
          params = this.__routes__P_174_2[action].params;
        } // Invoke immediately


        if (immediately) {
          this.invoke(action, params);
        }

        var intervalListener = function intervalListener() {
          var reqs = this.getRequestsByAction(action),
              req = reqs ? reqs[0] : null;

          if (!immediately && !req) {
            this.invoke(action, params);
            return;
          }

          if (req && (req.isDone() || req.isDisposed())) {
            this.refresh(action);
          }
        };

        var timer = this.__pollTimers__P_174_1[action] = new qx.event.Timer(interval);
        timer.addListener("interval", intervalListener, this._resource);
        timer.start();
        return timer;
      },

      /**
       * Long-poll action.
       *
       * Use Ajax long-polling to continuously fetch a resource as soon as the
       * server signals new data. The server determines when new data is available,
       * while the client keeps open a request. Requires configuration on the
       * server side. Basically, the server must not close a connection until
       * new data is available. For a high level introduction to long-polling,
       * refer to <a href="http://en.wikipedia.org/wiki/Comet_(programming)#Ajax_with_long_polling">
       * Ajax with long polling</a>.
       *
       * Uses {@link #refresh} internally. Make sure you understand the
       * implications of IE's tendency to cache overly aggressive.
       *
       * Note no interval is given on the client side.
       *
       * @lint ignoreUnused(longPollHandler)
       *
       * @param action {String} Action to poll.
       * @return {String} Id of handler responsible for long-polling. To stop
       *  polling, remove handler using {@link qx.core.Object#removeListenerById}.
       */
      longPoll: function longPoll(action) {
        var res = this,
            lastResponse,
            // Keep track of last response
        immediateResponseCount = 0; // Count immediate responses
        // Throttle to prevent high load on server and client

        function throttle() {
          var isImmediateResponse = lastResponse && new Date() - lastResponse < res._getThrottleLimit();

          if (isImmediateResponse) {
            immediateResponseCount += 1;

            if (immediateResponseCount > res._getThrottleCount()) {
              {
                res.debug("Received successful response more than " + res._getThrottleCount() + " times subsequently, each within " + res._getThrottleLimit() + " ms. Throttling.");
              }
              return true;
            }
          } // Reset counter on delayed response


          if (!isImmediateResponse) {
            immediateResponseCount = 0;
          }

          return false;
        }

        var handlerId = this.__longPollHandlers__P_174_0[action] = this.addListener(action + "Success", function longPollHandler() {
          if (res.isDisposed()) {
            return;
          }

          if (!throttle()) {
            lastResponse = new Date();
            res.refresh(action);
          }
        });
        this.invoke(action);
        return handlerId;
      },

      /**
       * Get request configuration for action and parameters.
       *
       * This is were placeholders are replaced with parameters.
       *
       * @param action {String} Action associated to request.
       * @param params {Map} Parameters to embed in request.
       * @return {Map} Map of configuration settings. Has the properties
       *   <code>method</code>, <code>url</code> and <code>check</code>.
       */
      _getRequestConfig: function _getRequestConfig(action, params) {
        return this._resource._getRequestConfig(action, params);
      },

      /**
       * Override to adjust the throttle limit.
       * @return {Integer} Throttle limit in milliseconds
       */
      _getThrottleLimit: function _getThrottleLimit() {
        return qx.io.rest.Resource.POLL_THROTTLE_LIMIT;
      },

      /**
       * Override to adjust the throttle count.
       * @return {Integer} Throttle count
       */
      _getThrottleCount: function _getThrottleCount() {
        return qx.io.rest.Resource.POLL_THROTTLE_COUNT;
      },

      /**
       * Map actions from description.
       *
       * Allows to decoratively define routes.
       *
       * @param description {Map} Map that defines the routes.
       */
      __mapFromDescription__P_174_3: function __mapFromDescription__P_174_3(description) {
        Object.keys(description).forEach(function (action) {
          var route = description[action],
              method = route.method,
              url = route.url,
              check = route.check;
          {
            qx.core.Assert.assertString(method, "Method must be string for route '" + action + "'");
            qx.core.Assert.assertString(url, "URL must be string for route '" + action + "'");
          }
          this.map(action, method, url, check);
        }, this);
      },

      /**
       * Declare event at runtime.
       *
       * @param type {String} Type of event.
       */
      __declareEvent__P_174_5: function __declareEvent__P_174_5(type) {
        if (!this.constructor.$$events) {
          this.constructor.$$events = {};
        }

        if (!this.constructor.$$events[type]) {
          this.constructor.$$events[type] = "qx.event.type.Rest";
        }
      }
    },

    /**
     * Destructs the Resource.
     *
     * All created requests, routes and pollTimers will be disposed.
     */
    destruct: function destruct() {
      var action;

      if (this.__pollTimers__P_174_1) {
        for (action in this.__pollTimers__P_174_1) {
          var timer = this.__pollTimers__P_174_1[action];
          timer.stop();
          timer.dispose();
        }
      }

      if (this.__longPollHandlers__P_174_0) {
        for (action in this.__longPollHandlers__P_174_0) {
          var id = this.__longPollHandlers__P_174_0[action];
          this.removeListenerById(id);
        }
      }

      this._resource.destruct();

      this._resource = this.__routes__P_174_2 = this.__pollTimers__P_174_1 = this.__longPollHandlers__P_174_0 = null;
    }
  });
  qx.io.rest.Resource.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * Abstract class for JSON-RPC transports
   *
   * For the moment, any special configuration of the transport, such as
   * authentication, must be done on the level of the underlying implementation,
   * an abstract API will be added later.
   */
  qx.Class.define("qx.io.transport.AbstractTransport", {
    extend: qx.core.Object,
    type: "abstract",
    properties: {
      /**
       * The uri of the endpoint
       */
      endpoint: {
        check: "String",
        event: "changeEndpoint"
      }
    },
    events: {
      /**
       * Event fired when a message is received from the endpoint. Event data
       * is an UTF-8 encoded string
       */
      "message": "qx.event.type.Data"
    },

    /**
     * Constructor
     * @param {String} endpoint
     */
    construct(endpoint) {
      qx.core.Object.constructor.call(this);
      this.setEndpoint(endpoint);
    }

  });
  qx.io.transport.AbstractTransport.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.io.transport.AbstractTransport": {
        "construct": true,
        "require": true
      },
      "qx.io.transport.ITransport": {
        "require": true
      },
      "qx.core.Assert": {},
      "qx.io.exception.Transport": {},
      "qx.io.graphql.Client": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * The implementation of a HTTP Transport using the Fetch API,
   * See https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch
   */
  qx.Class.define("qx.io.transport.Fetch", {
    extend: qx.io.transport.AbstractTransport,
    implement: qx.io.transport.ITransport,

    /**
     * Constructor.
     *
     * @param {String} url The URL of the http endpoint
     */
    construct(url) {
      qx.io.transport.AbstractTransport.constructor.call(this, url);
    },

    members: {
      __tranportImpl__P_176_0: null,

      /**
       * Returns the object which implements the transport on the
       * underlying level, so that transport-specific configuration
       * can be done on it. In the case of the Fetch API, the
       * "implementation" is a configuration object which will be
       * passed to the `fetch` method as second parameter.
       *
       * @return {qx.core.Object}
       */
      getTransportImpl() {
        this.__tranportImpl__P_176_0 = this.__tranportImpl__P_176_0 || this._createTransportImpl();
        return this.__tranportImpl__P_176_0;
      },

      /**
       * Transport the given message to the endpoint
       *
       * @param {String} message
       *
       * @return {qx.Promise} Promise that resolves (with no data)
       * when the message has been successfully sent out, and rejects
       * when there is an error or a cancellation up to that point.
       * @ignore(fetch)
       */
      async send(message) {
        qx.core.Assert.assertString(message);
        let init = this.getTransportImpl();
        init.body = message;
        let response;

        try {
          response = await fetch(this.getEndpoint(), init);
        } catch (e) {
          throw new qx.io.exception.Transport(e.message, e.code);
        }

        if (!response.ok) {
          switch (response.status) {
            case 400:
              // "400 Bad Request" is a really a protocol error (syntax error)
              break;

            default:
              throw new qx.io.exception.Transport(response.statusText, response.status);
          }
        }

        let responseData = await response.text(); // notify listeners

        this.fireDataEvent("message", responseData);
      },

      /**
       * Factory method to create a request object. In this implementation,
       * it returns an object that will be used as the `init` parameter of the
       * fetch method.
       * @return {Object}
       */
      _createTransportImpl() {
        let init = {};
        init.headers = {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        };
        init.method = "POST";
        return init;
      }

    },

    defer() {
      qx.io.graphql.Client.registerTransport(/^http/, qx.io.transport.Fetch);
    }

  });
  qx.io.transport.Fetch.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.io.transport.AbstractTransport": {
        "construct": true,
        "require": true
      },
      "qx.io.transport.ITransport": {
        "require": true
      },
      "qx.core.Assert": {},
      "qx.type.BaseError": {},
      "qx.io.exception.Transport": {},
      "qx.io.exception.Cancel": {},
      "qx.io.request.Xhr": {},
      "qx.io.jsonrpc.Client": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * The implementation of a HTTP Transport using the {@link qx.io.request} API,
   * so any special configuration of the HTTP request must be done on the
   * underlying implementation of {@link qx.io.request.AbstractRequest}.
   *
   * More abstract support for authentication will be added later.
   *
   */
  qx.Class.define("qx.io.transport.Xhr", {
    extend: qx.io.transport.AbstractTransport,
    implement: qx.io.transport.ITransport,

    /**
     * Constructor.
     *
     * @param {String} url The URL of the http endpoint
     */
    construct(url) {
      qx.io.transport.AbstractTransport.constructor.call(this, url);
    },

    members: {
      /**
       * Internal implementation of the transport
       * @var {qx.io.request.Xhr}
       */
      __tranportImpl__P_177_0: null,

      /**
       * Returns the object which implements the transport on the
       * underlying level, so that transport-specific configuration
       * can be done on it. Note that since in the HTTP transport,
       * this object cannot be reused, it will return a new object
       * each time which will be used in the immediately next request.
       *
       * @return {qx.core.Object}
       */
      getTransportImpl() {
        this.__tranportImpl__P_177_0 = this._createTransportImpl();
        return this.__tranportImpl__P_177_0;
      },

      /**
       * Transport the given message to the endpoint
       *
       * @param {String} message
       *
       * @return {qx.Promise} Promise that resolves (with no data)
       * when the message has been successfully sent out, and rejects
       * when there is an error or a cancellation up to that point.
       */
      async send(message) {
        qx.core.Assert.assertString(message);
        const req = this.__tranportImpl__P_177_0 || this.getTransportImpl();
        req.setRequestData(message);
        this.__tranportImpl__P_177_0 = null; // free the internal reference for the next request

        try {
          await req.sendWithPromise();
        } catch (e) {
          if (e instanceof qx.type.BaseError) {
            switch (e.getComment()) {
              case "timeout":
                throw new qx.io.exception.Transport(e.toString(), qx.io.exception.Transport.TIMEOUT, {
                  message
                });

              case "parseError":
                throw new qx.io.exception.Transport(e.toString(), qx.io.exception.Transport.INVALID_MSG_DATA, {
                  message
                });

              case "abort":
                throw new qx.io.exception.Cancel(e.toString(), {
                  message
                });

              case "statusError":
              case "error":
                throw new qx.io.exception.Transport(e.toString(), qx.io.exception.Transport.FAILED, {
                  message
                });
            }
          }
        } // notify listeners


        this.fireDataEvent("message", req.getResponse()); // discard old object

        req.dispose();
      },

      /**
       * Factory method to create a request object. By default, a POST
       * request will be made, and the expected response type will be
       * "application/json", but differently to the standard behavior,
       * the response will not be parsed into a javascript object.
       *
       * Classes extending this one may override this method to obtain
       * a Request object with different parameters and/or different
       * authentication settings. The object must be a subclass of {@link
       * qx.io.request.AbstractRequest} or implement its public API.
       *
       * @return {qx.io.jsonrpc.Request}
       */
      _createTransportImpl() {
        const req = new qx.io.request.Xhr(this.getEndpoint(), "POST");
        req.setAccept("application/json");
        req.setCache(false);
        req.setRequestHeader("content-type", "application/json"); // disable parsing, we are going to parse the JSON ourselves

        req.setParser(response => response);
        return req;
      }

    },

    defer() {
      qx.io.jsonrpc.Client.registerTransport(/^http/, qx.io.transport.Xhr);
    }

  });
  qx.io.transport.Xhr.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.locale.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Provides information about locale-dependent number formatting (like the decimal
   * separator).
   *
   * @cldr()
   */
  qx.Class.define("qx.locale.Number", {
    statics: {
      /**
       * Get decimal separator for number formatting
       *
       * @param locale {String} optional locale to be used
       * @return {String} decimal separator.
       */
      getDecimalSeparator: function getDecimalSeparator(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_number_decimal_separator", [], locale);
      },

      /**
       * Get thousand grouping separator for number formatting
       *
       * @param locale {String} optional locale to be used
       * @return {String} group separator.
       */
      getGroupSeparator: function getGroupSeparator(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_number_group_separator", [], locale);
      },

      /**
       * Get percent format string
       *
       * @param locale {String} optional locale to be used
       * @return {String} percent format string.
       */
      getPercentFormat: function getPercentFormat(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_number_percent_format", [], locale);
      }
    }
  });
  qx.locale.Number.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.locale.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Provides information about locale-dependent string formatting (like quotation
   * signs).
   *
   * @cldr()
   */
  qx.Class.define("qx.locale.String", {
    statics: {
      /**
       * Get quotation start sign
       *
       * @param locale {String} optional locale to be used
       * @return {String} quotation start sign
       */
      getQuotationStart: function getQuotationStart(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_quotationStart", [], locale);
      },

      /**
       * Get quotation end sign
       *
       * @param locale {String} optional locale to be used
       * @return {String} quotation end sign
       */
      getQuotationEnd: function getQuotationEnd(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_quotationEnd", [], locale);
      },

      /**
       * Get quotation alternative start sign
       *
       * @param locale {String} optional locale to be used
       * @return {String} alternative quotation start sign
       */
      getAlternateQuotationStart: function getAlternateQuotationStart(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_alternateQuotationStart", [], locale);
      },

      /**
       * Get quotation alternative end sign
       *
       * @param locale {String} optional locale to be used
       * @return {String} alternative quotation end sign
       */
      getAlternateQuotationEnd: function getAlternateQuotationEnd(locale) {
        return qx.locale.Manager.getInstance().localize("cldr_alternateQuotationEnd", [], locale);
      }
    }
  });
  qx.locale.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.bom.Stylesheet": {
        "construct": true
      },
      "qx.log.Logger": {
        "construct": true
      },
      "qx.bom.element.Class": {},
      "qx.log.appender.Formatter": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * This appender is used to log to an existing DOM element
   */
  qx.Class.define("qx.log.appender.Element", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param element {Element} DOM element to use for log output.
     */
    construct: function construct(element) {
      qx.core.Object.constructor.call(this);
      var style = ['.qxappender .level-debug{background:white}', '.qxappender .level-info{background:#DEEDFA}', '.qxappender .level-warn{background:#FFF7D5}', '.qxappender .level-error{background:#FFE2D5}', '.qxappender .level-user{background:#E3EFE9}', '.qxappender .type-string{color:black;font-weight:normal;}', '.qxappender .type-number{color:#155791;font-weight:normal;}', '.qxappender .type-boolean{color:#15BC91;font-weight:normal;}', '.qxappender .type-array{color:#CC3E8A;font-weight:bold;}', '.qxappender .type-map{color:#CC3E8A;font-weight:bold;}', '.qxappender .type-key{color:#565656;font-style:italic}', '.qxappender .type-class{color:#5F3E8A;font-weight:bold}', '.qxappender .type-instance{color:#565656;font-weight:bold}', '.qxappender .type-stringify{color:#565656;font-weight:bold}']; // Include stylesheet

      qx.bom.Stylesheet.createElement(style.join("")); // Finally register to log engine

      qx.log.Logger.register(this);
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __element__P_185_0: null,

      /**
       * Configures the DOM element to use.
       *
       * @param element {Element} DOM element to log to
       */
      setElement: function setElement(element) {
        // Clear old element
        this.clear(); // Add classname

        if (element) {
          qx.bom.element.Class.add(element, "qxappender");
        } // Link to element


        this.__element__P_185_0 = element;
      },

      /**
       * Clears the current output.
       *
       */
      clear: function clear() {
        var elem = this.__element__P_185_0; // Remove all messages

        if (elem) {
          elem.innerHTML = "";
        }
      },

      /**
       * Processes a single log entry
       *
       * @signature function(entry)
       * @param entry {Map} The entry to process
       */
      process: function process(entry) {
        var elem = this.__element__P_185_0;

        if (!elem) {
          return;
        } // Append new content


        var formatter = qx.log.appender.Formatter.getFormatter();
        elem.appendChild(formatter.toHtml(entry)); // Scroll down

        elem.scrollTop = elem.scrollHeight;
      }
    }
  });
  qx.log.appender.Element.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.log.appender.Formatter": {
        "require": true,
        "defer": "runtime"
      },
      "qx.bom.client.Html": {
        "require": true,
        "defer": "runtime"
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.log.Logger": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "html.console": {
          "className": "qx.bom.client.Html"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Processes the incoming log entry and displays it by means of the native
   * logging capabilities of the client.
   *
   * Supported browsers:
   * * Firefox <4 using FireBug (if available).
   * * Firefox >=4 using the Web Console.
   * * WebKit browsers using the Web Inspector/Developer Tools.
   * * Internet Explorer 8+ using the F12 Developer Tools.
   * * Opera >=10.60 using either the Error Console or Dragonfly
   *
   * Currently unsupported browsers:
   * * Opera <10.60
   *
   * @require(qx.log.appender.Formatter)
   * @require(qx.bom.client.Html)
   */
  qx.Bootstrap.define("qx.log.appender.Native", {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * Processes a single log entry
       *
       * @param entry {Map} The entry to process
       */
      process: function process(entry) {
        if (qx.core.Environment.get("html.console")) {
          // Firefox 4's Web Console doesn't support "debug"
          var level = console[entry.level] ? entry.level : "log";

          if (console[level]) {
            var formatter = qx.log.appender.Formatter.getFormatter();
            var args = formatter.toText(entry);
            console[level](args);
          }
        }
      }
    },

    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer: function defer(statics) {
      qx.log.Logger.register(statics);
    }
  });
  qx.log.appender.Native.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006-2011 1&1 Internet AG, Germany, http://www.1and1.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
       * Thomas Herchenroeder (thron7)
  
  ************************************************************************ */

  /**
   * Log appender for qooxdoo applications running in Node.js. Writes log
   * messages to STDOUT/STDERR.
   *
   * @ignore(process.*)
   */
  qx.Class.define("qx.log.appender.NodeConsole", {
    statics: {
      /**
       * process.stdout
       */
      __OUT__P_187_0: null,

      /**
       * process.stderr
       */
      __ERR__P_187_1: null,

      /**
       * Writes a message to the shell. Errors will be sent to STDERR, everything
       * else goes to STDOUT
       *
       * @param logMessage {String} Message to be logged
       * @param level {String} Log level. One of "debug", "info", "warn", "error"
       */
      log: function log(logMessage, level) {
        if (level == "error") {
          this.__ERR__P_187_1.write(logMessage + '\n');
        } else {
          this.__OUT__P_187_0.write(logMessage + '\n');
        }
      },

      /**
       * Logs a debug message
       *
       * @param logMessage {String} Message to be logged
       */
      debug: function debug(logMessage) {
        this.log(logMessage, "debug");
      },

      /**
       * Logs an info message
       *
       * @param logMessage {String} Message to be logged
       */
      info: function info(logMessage) {
        this.log(logMessage, "info");
      },

      /**
       * Logs a warning message
       *
       * @param logMessage {String} Message to be logged
       */
      warn: function warn(logMessage) {
        this.log(logMessage, "warn");
      },

      /**
       * Logs an error message
       *
       * @param logMessage {String} Message to be logged
       */
      error: function error(logMessage) {
        this.log(logMessage, "error");
      },

      /**
       * Process a log entry object from qooxdoo's logging system.
       *
       * @param entry {Map} Log entry object
       */
      process: function process(entry) {
        var level = entry.level || "info";

        for (var prop in entry) {
          if (prop == "items") {
            var items = entry[prop];

            for (var p = 0; p < items.length; p++) {
              var item = items[p];
              this[level](item.text);
            }
          }
        }
      }
    },

    /**
     * @ignore(process.*)
     */
    defer: function defer(statics) {
      if (typeof process !== "undefined") {
        statics.__OUT__P_187_0 = process.stdout;
        statics.__ERR__P_187_1 = process.stderr;
      }
    }
  });
  qx.log.appender.NodeConsole.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.log.appender.Formatter": {
        "require": true,
        "defer": "runtime"
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.log.Logger": {
        "defer": "runtime"
      },
      "qx.bom.client.PhoneGap": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "phonegap": {
          "defer": true,
          "className": "qx.bom.client.PhoneGap"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Unify Project
  
       Homepage:
         http://unify-project.org
  
       Copyright:
         2009-2010 Deutsche Telekom AG, Germany, http://telekom.com
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Processes the incoming log entry and displays it using the PhoneGap
   * logging capabilities.
   *
   * @require(qx.log.appender.Formatter)
   * @ignore(debug.*)
   */
  qx.Class.define("qx.log.appender.PhoneGap", {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * Processes a single log entry
       * @param entry {Map} The entry to process
       */
      process: function process(entry) {
        var formatter = qx.log.appender.Formatter.getFormatter();
        var args = formatter.toText(entry);
        var level = entry.level;

        if (level == "warn") {
          debug.warn(args);
        } else if (level == "error") {
          debug.error(args);
        } else {
          debug.log(args);
        }
      }
    },

    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer: function defer(statics) {
      function register() {
        if (window.debug) {
          qx.log.Logger.register(statics);
        } else {
          window.setTimeout(register, 200);
        }
      }

      if (qx.core.Environment.get("phonegap")) {
        register();
      }
    }
  });
  qx.log.appender.PhoneGap.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006-2010 1&1 Internet AG, Germany, http://www.1and1.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
  
  ************************************************************************ */

  /**
   * Log appender for qooxdoo applications running in Mozilla Rhino. Writes log
   * messages to STDOUT/STDERR.
   *
   * @ignore(java.*)
   */
  qx.Class.define("qx.log.appender.RhinoConsole", {
    statics: {
      /**
       * java.lang.System.out
       */
      __OUT__P_188_0: null,

      /**
       * java.lang.System.err
       */
      __ERR__P_188_1: null,

      /**
       * Writes a message to the shell. Errors will be sent to STDERR, everything
       * else goes to STDOUT
       *
       * @param logMessage {String} Message to be logged
       * @param level {String} Log level. One of "debug", "info", "warn", "error"
       */
      log: function log(logMessage, level) {
        if (level == "error") {
          this.__ERR__P_188_1.println(logMessage);
        } else {
          this.__OUT__P_188_0.println(logMessage);
        }
      },

      /**
       * Logs a debug message
       *
       * @param logMessage {String} Message to be logged
       */
      debug: function debug(logMessage) {
        this.log(logMessage, "debug");
      },

      /**
       * Logs an info message
       *
       * @param logMessage {String} Message to be logged
       */
      info: function info(logMessage) {
        this.log(logMessage, "info");
      },

      /**
       * Logs a warning message
       *
       * @param logMessage {String} Message to be logged
       */
      warn: function warn(logMessage) {
        this.log(logMessage, "warn");
      },

      /**
       * Logs an error message
       *
       * @param logMessage {String} Message to be logged
       */
      error: function error(logMessage) {
        this.log(logMessage, "error");
      },

      /**
       * Process a log entry object from qooxdoo's logging system.
       *
       * @param entry {Map} Log entry object
       */
      process: function process(entry) {
        var level = entry.level || "info";

        for (var prop in entry) {
          if (prop == "items") {
            var items = entry[prop];

            for (var p = 0, l = items.length; p < l; p++) {
              var item = items[p];
              this[level](item.text);
            }
          }
        }
      }
    },
    defer: function defer() {
      if (typeof java !== "undefined" && typeof java.lang !== "undefined") {
        qx.log.appender.RhinoConsole.__OUT__P_188_0 = java.lang.System.out;
        qx.log.appender.RhinoConsole.__ERR__P_188_1 = java.lang.System.err;
      }
    }
  });
  qx.log.appender.RhinoConsole.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006-2011 1&1 Internet AG, Germany, http://www.1and1.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */

  /**
   * Log appender for qooxdoo applications running in Mozilla Rhino. Writes log
   * messages to a text file.
   *
   * @ignore(java.*)
   */
  qx.Class.define("qx.log.appender.RhinoFile", {
    statics: {
      /**
       * Path/name of the log file to use, relative to the directory Rhino was
       * called from.
       */
      FILENAME: null,
      __FILEHANDLE__P_189_0: null,

      /**
       * Writes a message to the file.
       *
       * @param logMessage {String} Message to be logged
       * @param level {String} Log level. One of "debug", "info", "warn", "error"
       */
      log: function log(logMessage, level) {
        if (!qx.log.appender.RhinoFile.__FILEHANDLE__P_189_0) {
          qx.log.appender.RhinoFile.create();
        }

        var logFile = qx.log.appender.RhinoFile.__FILEHANDLE__P_189_0;
        logFile.write(logMessage);
        logFile.newLine();
        logFile.flush();
      },

      /**
       * Logs a debug message
       *
       * @param logMessage {String} Message to be logged
       */
      debug: function debug(logMessage) {
        this.log(logMessage, "debug");
      },

      /**
       * Logs an info message
       *
       * @param logMessage {String} Message to be logged
       */
      info: function info(logMessage) {
        this.log(logMessage, "info");
      },

      /**
       * Logs a warning message
       *
       * @param logMessage {String} Message to be logged
       */
      warn: function warn(logMessage) {
        this.log(logMessage, "warn");
      },

      /**
       * Logs an error message
       *
       * @param logMessage {String} Message to be logged
       */
      error: function error(logMessage) {
        this.log(logMessage, "error");
      },

      /**
       * Process a log entry object from qooxdoo's logging system.
       *
       * @param entry {Map} Log entry object
       */
      process: function process(entry) {
        var level = entry.level || "info";

        for (var prop in entry) {
          if (prop == "items") {
            var items = entry[prop];

            for (var p = 0, l = items.length; p < l; p++) {
              var item = items[p];
              this[level](item.text);
            }
          }
        }
      },

      /**
       * Creates a new log file using the value of {@link #FILENAME} as the
       * file path/name.
       */
      create: function create() {
        if (qx.log.appender.RhinoFile.__FILEHANDLE__P_189_0) {
          qx.log.appender.RhinoFile.__FILEHANDLE__P_189_0.close();
        }

        if (!qx.log.appender.RhinoFile.FILENAME) {
          qx.log.appender.RhinoFile.FILENAME = "qooxdoo.log";
        }

        var fstream = new java.io.FileWriter(qx.log.appender.RhinoFile.FILENAME, true);
        qx.log.appender.RhinoFile.__FILEHANDLE__P_189_0 = new java.io.BufferedWriter(fstream);
      }
    }
  });
  qx.log.appender.RhinoFile.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.log.appender.Formatter": {
        "defer": "runtime",
        "require": true
      },
      "qx.lang.Array": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Contains some common methods available to all log appenders.
   * 
   * @deprecated {6.0} See qx.util.appender.Formatter instead
   */
  qx.Bootstrap.define("qx.log.appender.Util", {
    statics: {
      toHtml: null,
      toText: null,
      toTextArray: null,
      escapeHTML: qx.log.appender.Formatter.escapeHTML
    },
    defer: function defer(statics) {
      var formatter = qx.log.appender.Formatter.getFormatter();
      ["toHtml", "toText", "toTextArray", "escapeHTML"].forEach(function (name) {
        statics[name] = function () {
          return formatter[name].apply(formatter, qx.lang.Array.fromArguments(arguments));
        };
      });
    }
  });
  qx.log.appender.Util.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.element.Attribute": {},
      "qx.bom.Html": {},
      "qx.bom.Input": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Attribute/Property handling for DOM elements.
   * @group (Core)
   */
  qx.Bootstrap.define("qx.module.Attribute", {
    members: {
      /**
       * Returns the HTML content of the first item in the collection
       * @attach {qxWeb}
       * @return {String|null} HTML content or null if the collection is empty
       */
      getHtml: function getHtml() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Attribute.get(this[0], "html");
        }

        return null;
      },

      /**
       * Sets the HTML content of each item in the collection
       *
       * @attach {qxWeb}
       * @param html {String} HTML string
       * @return {qxWeb} The collection for chaining
       */
      setHtml: function setHtml(html) {
        html = qx.bom.Html.fixEmptyTags(html);

        this._forEachElement(function (item) {
          qx.bom.element.Attribute.set(item, "html", html);
        });

        return this;
      },

      /**
       * Sets an HTML attribute on each item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Attribute name
       * @param value {var} Attribute value
       * @return {qxWeb} The collection for chaining
       */
      setAttribute: function setAttribute(name, value) {
        this._forEachElement(function (item) {
          qx.bom.element.Attribute.set(item, name, value);
        });

        return this;
      },

      /**
       * Returns the value of the given attribute for the first item in the
       * collection.
       *
       * @attach {qxWeb}
       * @param name {String} Attribute name
       * @return {var} Attribute value
       */
      getAttribute: function getAttribute(name) {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Attribute.get(this[0], name);
        }

        return null;
      },

      /**
       * Removes the given attribute from all elements in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Attribute name
       * @return {qxWeb} The collection for chaining
       */
      removeAttribute: function removeAttribute(name) {
        this._forEachElement(function (item) {
          qx.bom.element.Attribute.set(item, name, null);
        });

        return this;
      },

      /**
       * Sets multiple attributes for each item in the collection.
       *
       * @attach {qxWeb}
       * @param attributes {Map} A map of attribute name/value pairs
       * @return {qxWeb} The collection for chaining
       */
      setAttributes: function setAttributes(attributes) {
        for (var name in attributes) {
          this.setAttribute(name, attributes[name]);
        }

        return this;
      },

      /**
       * Returns the values of multiple attributes for the first item in the collection
       *
       * @attach {qxWeb}
       * @param names {String[]} List of attribute names
       * @return {Map} Map of attribute name/value pairs
       */
      getAttributes: function getAttributes(names) {
        var attributes = {};

        for (var i = 0; i < names.length; i++) {
          attributes[names[i]] = this.getAttribute(names[i]);
        }

        return attributes;
      },

      /**
       * Removes multiple attributes from each item in the collection.
       *
       * @attach {qxWeb}
       * @param attributes {String[]} List of attribute names
       * @return {qxWeb} The collection for chaining
       */
      removeAttributes: function removeAttributes(attributes) {
        for (var i = 0, l = attributes.length; i < l; i++) {
          this.removeAttribute(attributes[i]);
        }

        return this;
      },

      /**
       * Sets a property on each item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Property name
       * @param value {var} Property value
       * @return {qxWeb} The collection for chaining
       */
      setProperty: function setProperty(name, value) {
        for (var i = 0; i < this.length; i++) {
          this[i][name] = value;
        }

        return this;
      },

      /**
       * Returns the value of the given property for the first item in the
       * collection
       *
       * @attach {qxWeb}
       * @param name {String} Property name
       * @return {var} Property value
       */
      getProperty: function getProperty(name) {
        if (this[0]) {
          return this[0][name];
        }

        return null;
      },

      /**
       * Sets multiple properties for each item in the collection.
       *
       * @attach {qxWeb}
       * @param properties {Map} A map of property name/value pairs
       * @return {qxWeb} The collection for chaining
       */
      setProperties: function setProperties(properties) {
        for (var name in properties) {
          this.setProperty(name, properties[name]);
        }

        return this;
      },

      /**
       * Removes multiple properties for each item in the collection.
       *
       * @attach {qxWeb}
       * @param properties {String[]} An array of property names
       * @return {qxWeb} The collection for chaining
       */
      removeProperties: function removeProperties(properties) {
        for (var i = 0; i < properties.length; i++) {
          this.removeProperty(properties[i]);
        }

        return this;
      },

      /**
       * Returns the values of multiple properties for the first item in the collection
       *
       * @attach {qxWeb}
       * @param names {String[]} List of property names
       * @return {Map} Map of property name/value pairs
       */
      getProperties: function getProperties(names) {
        var properties = {};

        for (var i = 0; i < names.length; i++) {
          properties[names[i]] = this.getProperty(names[i]);
        }

        return properties;
      },

      /**
       * Deletes a property from each item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Property name
       * @return {qxWeb} The collection for chaining
       */
      removeProperty: function removeProperty(name) {
        if (this[0]) {
          this[0][name] = undefined;
        }

        return this;
      },

      /**
       * Returns the currently configured value for the first item in the collection.
       * Works with simple input fields as well as with select boxes or option
       * elements. Returns an array for select boxes with multi selection. In all
       * other cases, a string is returned.
       *
       * @attach {qxWeb}
       * @return {String|String[]} String value or Array of string values (for multiselect)
       */
      getValue: function getValue() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.Input.getValue(this[0]);
        }

        return null;
      },

      /**
       * Applies the given value to each element in the collection.
       * Normally the value is given as a string/number value and applied to the
       * field content (textfield, textarea) or used to detect whether the field
       * is checked (checkbox, radiobutton).
       * Supports array values for selectboxes (multiple selection) and checkboxes
       * or radiobuttons (for convenience).
       *
       * Please note: To modify the value attribute of a checkbox or radiobutton
       * use {@link #setAttribute} instead and manipulate the <code>checked</code> attribute.
       *
       * @attach {qxWeb}
       * @param value {String|Number|Array} The value to apply
       * @return {qxWeb} The collection for chaining
       */
      setValue: function setValue(value) {
        this._forEachElement(function (item) {
          qx.bom.Input.setValue(item, value);
        });

        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.Attribute.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Cookie": {
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Cookie handling module
   */
  qx.Bootstrap.define("qx.module.Cookie", {
    statics: {
      /**
       * Returns the string value of a cookie.
       *
       * @attachStatic {qxWeb, cookie.get}
       * @param key {String} The key for the saved string value.
       * @return {String|null} Returns the saved string value if the cookie
       *    contains a value for the key, otherwise <code>null</code>
       * @signature function(key)
       */
      get: qx.bom.Cookie.get,

      /**
       * Sets the string value of a cookie.
       *
       * @attachStatic {qxWeb, cookie.set}
       * @param key {String} The key for the string value.
       * @param value {String} The string value.
       * @param expires {Number?null} Expires directive value in days starting from now,
       *    or <code>null</code> if the cookie should be deleted when the browser
       *    is closed.
       * @param path {String?null} Path value.
       * @param domain {String?null} Domain value.
       * @param secure {Boolean?null} Secure flag.
       * @signature function(key, value, expires, path, domain, secure)
       */
      set: qx.bom.Cookie.set,

      /**
       * Deletes the string value of a cookie.
       *
       * @attachStatic {qxWeb, cookie.del}
       * @param key {String} The key for the string value.
       * @param path {String?null} Path value.
       * @param domain {String?null} Domain value.
       * @signature function(key, path, domain)
       */
      del: qx.bom.Cookie.del
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "cookie");
    }
  });
  qx.module.Cookie.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Object": {},
      "qx.lang.Type": {},
      "qx.bom.Html": {},
      "qx.dom.Node": {},
      "qxWeb": {
        "defer": "runtime"
      },
      "qx.dom.Element": {},
      "qx.lang.Array": {},
      "qx.bom.Viewport": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * DOM manipulation module
   *
   * @ignore(qx.bom.element, qx.bom.element.AnimationJs)
   * @group (Core)
   */
  qx.Bootstrap.define("qx.module.Manipulating", {
    statics: {
      /** Default animation descriptions for animated scrolling **/
      _animationDescription: {
        scrollLeft: {
          duration: 700,
          timing: "ease-in",
          keep: 100,
          keyFrames: {
            0: {},
            100: {
              scrollLeft: 1
            }
          }
        },
        scrollTop: {
          duration: 700,
          timing: "ease-in",
          keep: 100,
          keyFrames: {
            0: {},
            100: {
              scrollTop: 1
            }
          }
        }
      },

      /**
       * Performs animated scrolling
       *
       * @param property {String} Element property to animate: <code>scrollLeft</code>
       * or <code>scrollTop</code>
       * @param value {Number} Final scroll position
       * @param duration {Number} The animation's duration in ms
       * @return {q} The collection for chaining.
       */
      __animateScroll__P_193_0: function __animateScroll__P_193_0(property, value, duration) {
        var desc = qx.lang.Object.clone(qx.module.Manipulating._animationDescription[property], true);
        desc.keyFrames[100][property] = value;
        return this.animate(desc, duration);
      },

      /**
       * Creates a new collection from the given argument
       * @param arg {var} Selector expression, HTML string, DOM element or list of
       * DOM elements
       * @return {qxWeb} Collection
       * @internal
       */
      __getCollectionFromArgument__P_193_1: function __getCollectionFromArgument__P_193_1(arg) {
        var coll; // Collection/array of DOM elements

        if (qx.lang.Type.isArray(arg)) {
          coll = qxWeb(arg);
        } // HTML string
        else {
            var arr = qx.bom.Html.clean([arg]);

            if (arr.length > 0 && qx.dom.Node.isElement(arr[0])) {
              coll = qxWeb(arr);
            } // Selector or single element
            else {
                coll = qxWeb(arg);
              }
          }

        return coll;
      },

      /**
       * Returns the innermost element of a DOM tree as determined by a simple
       * depth-first search.
       *
       * @param element {Element} Root element
       * @return {Element} innermost element
       * @internal
       */
      __getInnermostElement__P_193_2: function __getInnermostElement__P_193_2(element) {
        if (element.childNodes.length == 0) {
          return element;
        }

        for (var i = 0, l = element.childNodes.length; i < l; i++) {
          if (element.childNodes[i].nodeType === 1) {
            return this.__getInnermostElement__P_193_2(element.childNodes[i]);
          }
        }

        return element;
      },

      /**
       * Returns an array from a selector expression or a single element
       *
       * @attach{qxWeb}
       * @param arg {String|Element} Selector expression or DOM element
       * @return {Element[]} Array of elements
       * @internal
       */
      __getElementArray__P_193_3: function __getElementArray__P_193_3(arg) {
        if (!qx.lang.Type.isArray(arg)) {
          var fromSelector = qxWeb(arg);
          arg = fromSelector.length > 0 ? fromSelector : [arg];
        }

        return arg.filter(function (item) {
          return item && (item.nodeType === 1 || item.nodeType === 11);
        });
      },

      /**
       * Creates a new collection from the given argument. This can either be an
       * HTML string, a single DOM element or an array of elements
       *
       * When no <code>context</code> is given the global document is used to
       * create new DOM elements.
       *
       * <strong>Note:</strong> When a complex HTML string is provided the <code>innerHTML</code>
       * mechanism of the browser is used. Some browsers do filter out elements like <code>&lt;html&gt;</code>,
       * <code>&lt;head&gt;</code> or <code>&lt;body&gt;</code>. The better approach is to create
       * a single element and the appending the child nodes.
       *
       * @attachStatic{qxWeb}
       * @param html {String|Element[]} HTML string or DOM element(s)
       * @param context {Document?document} Context in which the elements should be created
       * @return {qxWeb} Collection of elements
       */
      create: function create(html, context) {
        return qxWeb.$init(qx.bom.Html.clean([html], context), qxWeb);
      }
    },
    members: {
      /**
       * Clones the items in the current collection and returns them in a new set.
       * Event listeners can also be cloned.
       *
       * @attach{qxWeb}
       * @param events {Boolean} clone event listeners. Default: <code>false</code>
       * @return {qxWeb} New collection with clones
       */
      clone: function clone(events) {
        var clones = [];

        for (var i = 0; i < this.length; i++) {
          if (this[i] && this[i].nodeType === 1) {
            clones[i] = this[i].cloneNode(true);
          }
        }

        if (events === true && this.copyEventsTo) {
          this.copyEventsTo(clones);
        }

        return qxWeb(clones);
      },

      /**
       * Appends content to each element in the current set. Accepts an HTML string,
       * a single DOM element or an array of elements
       *
       * @attach{qxWeb}
       * @param html {String|Element[]|qxWeb} HTML string or DOM element(s) to append
       * @return {qxWeb} The collection for chaining
       */
      append: function append(html) {
        var arr = qx.bom.Html.clean([html]);
        var children = qxWeb.$init(arr, qxWeb);

        this._forEachElement(function (item, index) {
          for (var j = 0, m = children.length; j < m; j++) {
            if (index == 0) {
              // first parent: move the target node(s)
              qx.dom.Element.insertEnd(children[j], item);
            } else {
              qx.dom.Element.insertEnd(children.eq(j).clone(true)[0], item);
            }
          }
        });

        return this;
      },

      /**
       * Appends all items in the collection to the specified parents. If multiple
       * parents are given, the items will be moved to the first parent, while
       * clones of the items will be appended to subsequent parents.
       *
       * @attach{qxWeb}
       * @param parent {String|Element[]|qxWeb} Parent selector expression or list of
       * parent elements
       * @return {qxWeb} The collection for chaining
       */
      appendTo: function appendTo(parent) {
        parent = qx.module.Manipulating.__getElementArray__P_193_3(parent);

        for (var i = 0, l = parent.length; i < l; i++) {
          this._forEachElement(function (item, j) {
            if (i == 0) {
              // first parent: move the target node(s)
              qx.dom.Element.insertEnd(this[j], parent[i]);
            } else {
              // further parents: clone the target node(s)
              qx.dom.Element.insertEnd(this.eq(j).clone(true)[0], parent[i]);
            }
          });
        }

        return this;
      },

      /**
       * Inserts the current collection before each target item. The collection
       * items are moved before the first target. For subsequent targets,
       * clones of the collection items are created and inserted.
       *
       * @attach{qxWeb}
       * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,
       * Array of DOM elements or collection
       * @return {qxWeb} The collection for chaining
       */
      insertBefore: function insertBefore(target) {
        target = qx.module.Manipulating.__getElementArray__P_193_3(target);

        for (var i = 0, l = target.length; i < l; i++) {
          this._forEachElement(function (item, index) {
            if (i == 0) {
              // first target: move the target node(s)
              qx.dom.Element.insertBefore(item, target[i]);
            } else {
              // further targets: clone the target node(s)
              qx.dom.Element.insertBefore(this.eq(index).clone(true)[0], target[i]);
            }
          });
        }

        return this;
      },

      /**
       * Inserts the current collection after each target item. The collection
       * items are moved after the first target. For subsequent targets,
       * clones of the collection items are created and inserted.
       *
       * @attach{qxWeb}
       * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,
       * Array of DOM elements or collection
       * @return {qxWeb} The collection for chaining
       */
      insertAfter: function insertAfter(target) {
        target = qx.module.Manipulating.__getElementArray__P_193_3(target);

        for (var i = 0, l = target.length; i < l; i++) {
          for (var j = this.length - 1; j >= 0; j--) {
            if (!this[j] || this[j].nodeType !== 1) {
              continue;
            }

            if (i == 0) {
              // first target: move the target node(s)
              qx.dom.Element.insertAfter(this[j], target[i]);
            } else {
              // further targets: clone the target node(s)
              qx.dom.Element.insertAfter(this.eq(j).clone(true)[0], target[i]);
            }
          }
        }

        return this;
      },

      /**
       * Wraps each element in the collection in a copy of an HTML structure.
       * Elements will be appended to the deepest nested element in the structure
       * as determined by a depth-first search.
       *
       * @attach{qxWeb}
       * @param wrapper {String|Element|Element[]|qxWeb} Selector expression, HTML string, DOM element or
       * list of DOM elements
       * @return {qxWeb} The collection for chaining
       */
      wrap: function wrap(wrapper) {
        wrapper = qx.module.Manipulating.__getCollectionFromArgument__P_193_1(wrapper);

        if (wrapper.length == 0) {
          return this;
        }

        this._forEachElement(function (item) {
          var clonedwrapper = wrapper.eq(0).clone(true);
          qx.dom.Element.insertAfter(clonedwrapper[0], item);

          var innermost = qx.module.Manipulating.__getInnermostElement__P_193_2(clonedwrapper[0]);

          qx.dom.Element.insertEnd(item, innermost);
        });

        return this;
      },

      /**
       * Removes each element in the current collection from the DOM
       *
       * @attach{qxWeb}
       * @return {qxWeb} The collection for chaining
       */
      remove: function remove() {
        this._forEachElement(function (item) {
          qx.dom.Element.remove(item);
        });

        return this;
      },

      /**
       * Removes all content from the elements in the collection
       *
       * @attach{qxWeb}
       * @return {qxWeb} The collection for chaining
       */
      empty: function empty() {
        this._forEachElement(function (item) {
          // don't use innerHTML="" because of [BUG #7323]
          // and don't use textContent="" because of missing IE8 support
          while (item.firstChild) {
            item.removeChild(item.firstChild);
          }
        });

        return this;
      },

      /**
       * Inserts content before each element in the collection. This can either
       * be an HTML string, an array of HTML strings, a single DOM element or an
       * array of elements.
       *
       * @attach{qxWeb}
       * @param content {String|String[]|Element|Element[]|qxWeb} HTML string(s),
       * DOM element(s) or collection to insert
       * @return {qxWeb} The collection for chaining
       */
      before: function before(content) {
        if (!qx.lang.Type.isArray(content)) {
          content = [content];
        }

        var fragment = document.createDocumentFragment();
        qx.bom.Html.clean(content, document, fragment);

        this._forEachElement(function (item, index) {
          var kids = qx.lang.Array.cast(fragment.childNodes, Array);

          for (var i = 0, l = kids.length; i < l; i++) {
            var child;

            if (index < this.length - 1) {
              child = kids[i].cloneNode(true);
            } else {
              child = kids[i];
            }

            item.parentNode.insertBefore(child, item);
          }
        }, this);

        return this;
      },

      /**
       * Inserts content after each element in the collection. This can either
       * be an HTML string, an array of HTML strings, a single DOM element or an
       * array of elements.
       *
       * @attach{qxWeb}
       * @param content {String|String[]|Element|Element[]|qxWeb} HTML string(s),
       * DOM element(s) or collection to insert
       * @return {qxWeb} The collection for chaining
       */
      after: function after(content) {
        if (!qx.lang.Type.isArray(content)) {
          content = [content];
        }

        var fragment = document.createDocumentFragment();
        qx.bom.Html.clean(content, document, fragment);

        this._forEachElement(function (item, index) {
          var kids = qx.lang.Array.cast(fragment.childNodes, Array);

          for (var i = kids.length - 1; i >= 0; i--) {
            var child;

            if (index < this.length - 1) {
              child = kids[i].cloneNode(true);
            } else {
              child = kids[i];
            }

            item.parentNode.insertBefore(child, item.nextSibling);
          }
        }, this);

        return this;
      },

      /**
       * Returns the left scroll position of the first element in the collection.
       *
       * @attach{qxWeb}
       * @return {Number} Current left scroll position
       */
      getScrollLeft: function getScrollLeft() {
        var obj = this[0];

        if (!obj) {
          return null;
        }

        var Node = qx.dom.Node;

        if (Node.isWindow(obj) || Node.isDocument(obj)) {
          return qx.bom.Viewport.getScrollLeft();
        }

        return obj.scrollLeft;
      },

      /**
       * Returns the top scroll position of the first element in the collection.
       *
       * @attach{qxWeb}
       * @return {Number} Current top scroll position
       */
      getScrollTop: function getScrollTop() {
        var obj = this[0];

        if (!obj) {
          return null;
        }

        var Node = qx.dom.Node;

        if (Node.isWindow(obj) || Node.isDocument(obj)) {
          return qx.bom.Viewport.getScrollTop();
        }

        return obj.scrollTop;
      },

      /**
       * Scrolls the elements of the collection to the given coordinate.
       *
       * @attach{qxWeb}
       * @param value {Number} Left scroll position
       * @param duration {Number?} Optional: Duration in ms for animated scrolling
       * @return {qxWeb} The collection for chaining
       */
      setScrollLeft: function setScrollLeft(value, duration) {
        var Node = qx.dom.Node;

        if (duration && qx.bom.element && qx.bom.element.AnimationJs) {
          qx.module.Manipulating.__animateScroll__P_193_0.bind(this, "scrollLeft", value, duration)();
        }

        for (var i = 0, l = this.length, obj; i < l; i++) {
          obj = this[i];

          if (Node.isElement(obj)) {
            if (!(duration && qx.bom.element && qx.bom.element.AnimationJs)) {
              obj.scrollLeft = value;
            }
          } else if (Node.isWindow(obj)) {
            obj.scrollTo(value, this.getScrollTop(obj));
          } else if (Node.isDocument(obj)) {
            Node.getWindow(obj).scrollTo(value, this.getScrollTop(obj));
          }
        }

        return this;
      },

      /**
       * Scrolls the elements of the collection to the given coordinate.
       *
       * @attach{qxWeb}
       * @param value {Number} Top scroll position
       * @param duration {Number?} Optional: Duration in ms for animated scrolling
       * @return {qxWeb} The collection for chaining
       */
      setScrollTop: function setScrollTop(value, duration) {
        var Node = qx.dom.Node;

        if (duration && qx.bom.element && qx.bom.element.AnimationJs) {
          qx.module.Manipulating.__animateScroll__P_193_0.bind(this, "scrollTop", value, duration)();
        }

        for (var i = 0, l = this.length, obj; i < l; i++) {
          obj = this[i];

          if (Node.isElement(obj)) {
            if (!(duration && qx.bom.element && qx.bom.element.AnimationJs)) {
              obj.scrollTop = value;
            }
          } else if (Node.isWindow(obj)) {
            obj.scrollTo(this.getScrollLeft(obj), value);
          } else if (Node.isDocument(obj)) {
            Node.getWindow(obj).scrollTo(this.getScrollLeft(obj), value);
          }
        }

        return this;
      },

      /**
       * Focuses the first element in the collection
       *
       * @attach{qxWeb}
       * @return {qxWeb} The collection for chaining
       */
      focus: function focus() {
        try {
          this[0].focus();
        } catch (ex) {}

        return this;
      },

      /**
       * Blurs each element in the collection
       *
       * @attach{qxWeb}
       * @return {qxWeb} The collection for chaining
       */
      blur: function blur() {
        this.forEach(function (item, index) {
          try {
            item.blur();
          } catch (ex) {}
        });
        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.Manipulating.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.Selector": {},
      "qxWeb": {
        "defer": "runtime"
      },
      "qx.dom.Hierarchy": {},
      "qx.lang.Array": {},
      "qx.dom.Node": {},
      "qx.bom.client.Html": {},
      "qx.lang.Type": {},
      "qx.bom.element.Location": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "html.node.isequalnode": {
          "className": "qx.bom.client.Html"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * DOM traversal module
   *
   * @require(qx.dom.Hierarchy#getSiblings)
   * @require(qx.dom.Hierarchy#getNextSiblings)
   * @require(qx.dom.Hierarchy#getPreviousSiblings)
   * @require(qx.dom.Hierarchy#contains)
   *
   * @group (Core)
   */
  qx.Bootstrap.define("qx.module.Traversing", {
    statics: {
      /**
       * String attributes used to determine if two DOM nodes are equal
       * as defined in <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode">
       * DOM Level 3</a>
       */
      EQUALITY_ATTRIBUTES: ["nodeType", "nodeName", "localName", "namespaceURI", "prefix", "nodeValue"],

      /**
       * Internal helper for getAncestors and getAncestorsUntil
       *
       * @attach {qxWeb}
       * @param selector {String} Selector that indicates where to stop including
       * ancestor elements
       * @param filter {String?null} Optional selector to match
       * @return {qxWeb} Collection containing the ancestor elements
       * @internal
       */
      __getAncestors__P_198_0: function __getAncestors__P_198_0(selector, filter) {
        var ancestors = [];

        for (var i = 0; i < this.length; i++) {
          var parent = qx.dom.Element.getParentElement(this[i]);

          while (parent) {
            var found = [parent];

            if (selector && qx.bom.Selector.matches(selector, found).length > 0) {
              break;
            }

            if (filter) {
              found = qx.bom.Selector.matches(filter, found);
            }

            ancestors = ancestors.concat(found);
            parent = qx.dom.Element.getParentElement(parent);
          }
        }

        return qxWeb.$init(ancestors, qxWeb);
      },

      /**
       * Helper which returns the element from the given argument. If it's a collection,
       * it returns it's first child. If it's a string, it tries to use the string
       * as selector and returns the first child of the new collection.
       * @param arg {Node|String|qxWeb} The element.
       * @return {Node|var} If a node can be extracted, the node element will be return.
       *   If not, at given argument will be returned.
       */
      __getElementFromArgument__P_198_1: function __getElementFromArgument__P_198_1(arg) {
        if (arg instanceof qxWeb) {
          return arg[0];
        } else if (qx.Bootstrap.isString(arg)) {
          return qxWeb(arg)[0];
        }

        return arg;
      },

      /**
       * Helper that attempts to convert the given argument into a DOM node
       * @param arg {var} object to convert
       * @return {Node|null} DOM node or null if the conversion failed
       */
      __getNodeFromArgument__P_198_2: function __getNodeFromArgument__P_198_2(arg) {
        if (typeof arg == "string") {
          arg = qxWeb(arg);
        }

        if (arg instanceof Array || arg instanceof qxWeb) {
          arg = arg[0];
        }

        return qxWeb.isNode(arg) ? arg : null;
      },

      /**
       * Returns a map containing the given DOM node's attribute names
       * and values
       *
       * @param node {Node} DOM node
       * @return {Map} Map of attribute names/values
       */
      __getAttributes__P_198_3: function __getAttributes__P_198_3(node) {
        var attributes = {};

        for (var attr in node.attributes) {
          if (attr == "length") {
            continue;
          }

          var name = node.attributes[attr].name;
          var value = node.attributes[attr].value;
          attributes[name] = value;
        }

        return attributes;
      },

      /**
       * Helper function that iterates over a set of items and applies the given
       * qx.dom.Hierarchy method to each entry, storing the results in a new Array.
       * Duplicates are removed and the items are filtered if a selector is
       * provided.
       *
       * @attach{qxWeb}
       * @param collection {Array} Collection to iterate over (any Array-like object)
       * @param method {String} Name of the qx.dom.Hierarchy method to apply
       * @param selector {String?} Optional selector that elements to be included
       * must match
       * @return {Array} Result array
       * @internal
       */
      __hierarchyHelper__P_198_4: function __hierarchyHelper__P_198_4(collection, method, selector) {
        // Iterate ourself, as we want to directly combine the result
        var all = [];
        var Hierarchy = qx.dom.Hierarchy;

        for (var i = 0, l = collection.length; i < l; i++) {
          all.push.apply(all, Hierarchy[method](collection[i]));
        } // Remove duplicates


        var ret = qx.lang.Array.unique(all); // Post reduce result by selector

        if (selector) {
          ret = qx.bom.Selector.matches(selector, ret);
        }

        return ret;
      },

      /**
       * Checks if the given object is a DOM element
       *
       * @attachStatic{qxWeb}
       * @param selector {Object|String|qxWeb} Object to check
       * @return {Boolean} <code>true</code> if the object is a DOM element
       */
      isElement: function isElement(selector) {
        return qx.dom.Node.isElement(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Checks if the given object is a DOM node
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} Object to check
       * @return {Boolean} <code>true</code> if the object is a DOM node
       */
      isNode: function isNode(selector) {
        return qx.dom.Node.isNode(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Whether the node has the given node name
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} the node to check
       * @param  nodeName {String} the node name to check for
       * @return {Boolean} <code>true</code> if the node has the given name
       */
      isNodeName: function isNodeName(selector, nodeName) {
        return qx.dom.Node.isNodeName(qx.module.Traversing.__getElementFromArgument__P_198_1(selector), nodeName);
      },

      /**
       * Checks if the given object is a DOM document object
       *
       * @attachStatic{qxWeb}
       * @param node {Object|qxWeb} Object to check. If the value is a qxWeb
       * collection, isDocument will check the first item.
       * @return {Boolean} <code>true</code> if the object is a DOM document
       */
      isDocument: function isDocument(node) {
        if (node instanceof qxWeb) {
          node = node[0];
        }

        return qx.dom.Node.isDocument(node);
      },

      /**
       * Checks if the given object is a DOM document fragment object
       *
       * @attachStatic{qxWeb}
       * @param node {Object|qxWeb} Object to check. If the value is a qxWeb
       * collection, isDocumentFragment will check the first item.
       * @return {Boolean} <code>true</code> if the object is a DOM document fragment
       */
      isDocumentFragment: function isDocumentFragment(node) {
        if (node instanceof qxWeb) {
          node = node[0];
        }

        return qx.dom.Node.isDocumentFragment(node);
      },

      /**
       * Returns the DOM2 <code>defaultView</code> (window) for the given node.
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|Document|Window|String|qxWeb} Node to inspect
       * @return {Window} the <code>defaultView</code> for the given node
       */
      getWindow: function getWindow(selector) {
        return qx.dom.Node.getWindow(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Checks whether the given object is a DOM text node
       *
       * @attachStatic{qxWeb}
       * @param obj {Object} the object to be tested
       * @return {Boolean} <code>true</code> if the object is a textNode
       */
      isTextNode: function isTextNode(obj) {
        return qx.dom.Node.isText(obj);
      },

      /**
       * Check whether the given object is a browser window object.
       *
       * @attachStatic{qxWeb}
       * @param obj {Object|qxWeb} the object to be tested. If the value
       * is a qxWeb collection, isDocument will check the first item.
       * @return {Boolean} <code>true</code> if the object is a window object
       */
      isWindow: function isWindow(obj) {
        if (obj instanceof qxWeb) {
          obj = obj[0];
        }

        return qx.dom.Node.isWindow(obj);
      },

      /**
       * Returns the owner document of the given node
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} Node to get the document for
       * @return {Document|null} The document of the given DOM node
       */
      getDocument: function getDocument(selector) {
        return qx.dom.Node.getDocument(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Get the DOM node's name as a lowercase string
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} DOM Node
       * @return {String} node name
       */
      getNodeName: function getNodeName(selector) {
        return qx.dom.Node.getName(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Returns the text content of a node where the node type may be one of
       * NODE_ELEMENT, NODE_ATTRIBUTE, NODE_TEXT, NODE_CDATA
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} the node from where the search should start. If the
       * node has subnodes the text contents are recursively retrieved and joined
       * @return {String} the joined text content of the given node or null if not
       * appropriate.
       */
      getNodeText: function getNodeText(selector) {
        return qx.dom.Node.getText(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Checks if the given node is a block node
       *
       * @attachStatic{qxWeb}
       * @param selector {Node|String|qxWeb} the node to check
       * @return {Boolean} <code>true</code> if the node is a block node
       */
      isBlockNode: function isBlockNode(selector) {
        return qx.dom.Node.isBlockNode(qx.module.Traversing.__getElementFromArgument__P_198_1(selector));
      },

      /**
       * Determines if two DOM nodes are equal as defined in the
       * <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode">DOM Level 3 isEqualNode spec</a>.
       * Also works in legacy browsers without native <em>isEqualNode</em> support.
       *
       * @attachStatic{qxWeb}
       * @param node1 {String|Element|Element[]|qxWeb} first object to compare
       * @param node2 {String|Element|Element[]|qxWeb} second object to compare
       * @return {Boolean} <code>true</code> if the nodes are equal
       */
      equalNodes: function equalNodes(node1, node2) {
        node1 = qx.module.Traversing.__getNodeFromArgument__P_198_2(node1);
        node2 = qx.module.Traversing.__getNodeFromArgument__P_198_2(node2);

        if (!node1 || !node2) {
          return false;
        }

        if (qx.core.Environment.get("html.node.isequalnode")) {
          return node1.isEqualNode(node2);
        } else {
          if (node1 === node2) {
            return true;
          } // quick attributes length check


          var hasAttributes = node1.attributes && node2.attributes;

          if (hasAttributes && node1.attributes.length !== node2.attributes.length) {
            return false;
          }

          var hasChildNodes = node1.childNodes && node2.childNodes; // quick childNodes length check

          if (hasChildNodes && node1.childNodes.length !== node2.childNodes.length) {
            return false;
          } // string attribute check


          var domAttributes = qx.module.Traversing.EQUALITY_ATTRIBUTES;

          for (var i = 0, l = domAttributes.length; i < l; i++) {
            var domAttrib = domAttributes[i];

            if (node1[domAttrib] !== node2[domAttrib]) {
              return false;
            }
          } // attribute values


          if (hasAttributes) {
            var node1Attributes = qx.module.Traversing.__getAttributes__P_198_3(node1);

            var node2Attributes = qx.module.Traversing.__getAttributes__P_198_3(node2);

            for (var attr in node1Attributes) {
              if (node1Attributes[attr] !== node2Attributes[attr]) {
                return false;
              }
            }
          } // child nodes


          if (hasChildNodes) {
            for (var j = 0, m = node1.childNodes.length; j < m; j++) {
              var child1 = node1.childNodes[j];
              var child2 = node2.childNodes[j];

              if (!qx.module.Traversing.equalNodes(child1, child2)) {
                return false;
              }
            }
          }

          return true;
        }
      }
    },
    members: {
      __getAncestors__P_198_0: null,

      /**
       * Adds an element to the collection
       *
       * @attach {qxWeb}
       * @param el {Element|qxWeb} DOM element to add to the collection.
       * If a collection is given, only the first element will be added
       * @return {qxWeb} The collection for chaining
       */
      add: function add(el) {
        if (el instanceof qxWeb) {
          el = el[0];
        }

        if (qx.module.Traversing.isElement(el) || qx.module.Traversing.isDocument(el) || qx.module.Traversing.isWindow(el) || qx.module.Traversing.isDocumentFragment(el)) {
          this.push(el);
        }

        return this;
      },

      /**
       * Gets a set of elements containing all of the unique immediate children of
       * each of the matched set of elements.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?null} Optional selector to match
       * @return {qxWeb} Collection containing the child elements
       */
      getChildren: function getChildren(selector) {
        var children = [];

        for (var i = 0; i < this.length; i++) {
          var found = qx.dom.Hierarchy.getChildElements(this[i]);

          if (selector) {
            found = qx.bom.Selector.matches(selector, found);
          }

          children = children.concat(found);
        }

        ;
        return qxWeb.$init(children, qxWeb);
      },

      /**
       * Executes the provided callback function once for each item in the
       * collection.
       *
       * @attach {qxWeb}
       * @param fn {Function} Callback function which is called with two parameters
       * <ul>
       *  <li>current item - DOM node</li>
       *  <li>current index - Number</li>
       * </ul>
       * @param ctx {Object} Context object
       * @return {qxWeb} The collection for chaining
       */
      forEach: function forEach(fn, ctx) {
        for (var i = 0; i < this.length; i++) {
          fn.call(ctx, this[i], i, this);
        }

        ;
        return this;
      },

      /**
       * Gets a set of elements containing the parent of each element in the
       * collection.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?null} Optional selector to match
       * @return {qxWeb} Collection containing the parent elements
       */
      getParents: function getParents(selector) {
        var parents = [];

        for (var i = 0; i < this.length; i++) {
          var found = qx.dom.Element.getParentElement(this[i]);

          if (selector) {
            found = qx.bom.Selector.matches(selector, [found]);
          }

          parents = parents.concat(found);
        }

        ;
        return qxWeb.$init(parents, qxWeb);
      },

      /**
      * Checks if any element of the current collection is child of any element of a given
      * parent collection.
      *
      * @attach{qxWeb}
      * @param parent {qxWeb | String} Collection or selector of the parent collection to check.
      * @return {Boolean} Returns true if at least one element of the current collection is child of the parent collection
      *
      */
      isChildOf: function isChildOf(parent) {
        if (this.length == 0) {
          return false;
        }

        var ancestors = null,
            parentCollection = qxWeb(parent),
            isChildOf = false;

        for (var i = 0, l = this.length; i < l && !isChildOf; i++) {
          ancestors = qxWeb(this[i]).getAncestors();

          for (var j = 0, len = parentCollection.length; j < len; j++) {
            if (ancestors.indexOf(parentCollection[j]) != -1) {
              isChildOf = true;
              break;
            }
          }

          ;
        }

        return isChildOf;
      },

      /**
       * Gets a set of elements containing all ancestors of each element in the
       * collection.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param filter {String?null} Optional selector to match
       * @return {qxWeb} Collection containing the ancestor elements
       */
      getAncestors: function getAncestors(filter) {
        return this.__getAncestors__P_198_0(null, filter);
      },

      /**
       * Gets a set of elements containing all ancestors of each element in the
       * collection, up to (but not including) the element matched by the provided
       * selector.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String} Selector that indicates where to stop including
       * ancestor elements
       * @param filter {String?null} Optional selector to match
       * @return {qxWeb} Collection containing the ancestor elements
       */
      getAncestorsUntil: function getAncestorsUntil(selector, filter) {
        return this.__getAncestors__P_198_0(selector, filter);
      },

      /**
       * Gets a set containing the closest matching ancestor for each item in
       * the collection.
       * If the item itself matches, it is added to the new set. Otherwise, the
       * item's parent chain will be traversed until a match is found.
       *
       * @attach {qxWeb}
       * @param selector {String} Selector expression to match
       * @return {qxWeb} New collection containing the closest matching ancestors
       */
      getClosest: function getClosest(selector) {
        var closest = [];

        var findClosest = function findClosest(current) {
          var found = qx.bom.Selector.matches(selector, current);

          if (found.length) {
            closest.push(found[0]);
          } else {
            current = current.getParents(); // One up

            if (current[0] && current[0].parentNode) {
              findClosest(current);
            }
          }
        };

        for (var i = 0; i < this.length; i++) {
          findClosest(qxWeb(this[i]));
        }

        ;
        return qxWeb.$init(closest, qxWeb);
      },

      /**
       * Searches the child elements of each item in the collection and returns
       * a new collection containing the children that match the provided selector
       *
       * @attach {qxWeb}
       * @param selector {String} Selector expression to match the child elements
       * against
       * @return {qxWeb} New collection containing the matching child elements
       */
      find: function find(selector) {
        var found = [];

        for (var i = 0; i < this.length; i++) {
          found = found.concat(qx.bom.Selector.query(selector, this[i]));
        }

        ;
        return qxWeb.$init(found, qxWeb);
      },

      /**
       * Gets a new set of elements containing the child nodes of each item in the
       * current set.
       *
       * @attach {qxWeb}
       * @return {qxWeb} New collection containing the child nodes
       */
      getContents: function getContents() {
        var found = [];

        this._forEachElement(function (item) {
          found = found.concat(qx.lang.Array.fromCollection(item.childNodes));
        });

        return qxWeb.$init(found, qxWeb);
      },

      /**
       * Checks if at least one element in the collection passes the provided
       * filter. This can be either a selector expression or a filter
       * function
       *
       * @attach {qxWeb}
       * @param selector {String|Function} Selector expression or filter function
       * @return {Boolean} <code>true</code> if at least one element matches
       */
      is: function is(selector) {
        if (qx.lang.Type.isFunction(selector)) {
          return this.filter(selector).length > 0;
        }

        return !!selector && qx.bom.Selector.matches(selector, this).length > 0;
      },

      /**
       * Reduce the set of matched elements to a single element.
       *
       * @attach {qxWeb}
       * @param index {Number} The position of the element in the collection
       * @return {qxWeb} A new collection containing one element
       */
      eq: function eq(index) {
        return this.slice(index, +index + 1);
      },

      /**
       * Reduces the collection to the first element.
       *
       * @attach {qxWeb}
       * @return {qxWeb} A new collection containing one element
       */
      getFirst: function getFirst() {
        return this.slice(0, 1);
      },

      /**
       * Reduces the collection to the last element.
       *
       * @attach {qxWeb}
       * @return {qxWeb} A new collection containing one element
       */
      getLast: function getLast() {
        return this.slice(this.length - 1);
      },

      /**
       * Gets a collection containing only the elements that have descendants
       * matching the given selector
       *
       * @attach {qxWeb}
       * @param selector {String} Selector expression
       * @return {qxWeb} a new collection containing only elements with matching descendants
       */
      has: function has(selector) {
        var found = [];

        this._forEachElement(function (item, index) {
          var descendants = qx.bom.Selector.matches(selector, this.eq(index).getContents());

          if (descendants.length > 0) {
            found.push(item);
          }
        });

        return qxWeb.$init(found, this.constructor);
      },

      /**
       * Returns a new collection containing only those nodes that
       * contain the given element. Also accepts a qxWeb
       * collection or an Array of elements. In those cases, the first element
       * in the list is used.
       *
       * @attach {qxWeb}
       * @param element {Element|Window|Element[]|qxWeb} element to check for.
       * @return {qxWeb} Collection with matching items
       */
      contains: function contains(element) {
        // qxWeb does not inherit from Array in IE
        if (element instanceof Array || element instanceof qxWeb) {
          element = element[0];
        }

        if (!element) {
          return qxWeb();
        }

        if (qx.dom.Node.isWindow(element)) {
          element = element.document;
        }

        return this.filter(function (el) {
          if (qx.dom.Node.isWindow(el)) {
            el = el.document;
          }

          return qx.dom.Hierarchy.contains(el, element);
        });
      },

      /**
       * Gets a collection containing the next sibling element of each item in
       * the current set.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing next siblings
       */
      getNext: function getNext(selector) {
        var found = this.map(qx.dom.Hierarchy.getNextElementSibling, qx.dom.Hierarchy);

        if (selector) {
          found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);
        }

        return found;
      },

      /**
       * Gets a collection containing all following sibling elements of each
       * item in the current set.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing following siblings
       */
      getNextAll: function getNextAll(selector) {
        var ret = qx.module.Traversing.__hierarchyHelper__P_198_4(this, "getNextSiblings", selector);

        return qxWeb.$init(ret, qxWeb);
      },

      /**
       * Gets a collection containing the following sibling elements of each
       * item in the current set up to but not including any element that matches
       * the given selector.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing following siblings
       */
      getNextUntil: function getNextUntil(selector) {
        var found = [];
        this.forEach(function (item, index) {
          var nextSiblings = qx.dom.Hierarchy.getNextSiblings(item);

          for (var i = 0, l = nextSiblings.length; i < l; i++) {
            if (qx.bom.Selector.matches(selector, [nextSiblings[i]]).length > 0) {
              break;
            }

            found.push(nextSiblings[i]);
          }
        });
        return qxWeb.$init(found, qxWeb);
      },

      /**
       * Gets a collection containing the previous sibling element of each item in
       * the current set.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing previous siblings
       */
      getPrev: function getPrev(selector) {
        var found = this.map(qx.dom.Hierarchy.getPreviousElementSibling, qx.dom.Hierarchy);

        if (selector) {
          found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);
        }

        return found;
      },

      /**
       * Gets a collection containing all preceding sibling elements of each
       * item in the current set.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing preceding siblings
       */
      getPrevAll: function getPrevAll(selector) {
        var ret = qx.module.Traversing.__hierarchyHelper__P_198_4(this, "getPreviousSiblings", selector);

        return qxWeb.$init(ret, qxWeb);
      },

      /**
       * Gets a collection containing the preceding sibling elements of each
       * item in the current set up to but not including any element that matches
       * the given selector.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing preceding siblings
       */
      getPrevUntil: function getPrevUntil(selector) {
        var found = [];
        this.forEach(function (item, index) {
          var previousSiblings = qx.dom.Hierarchy.getPreviousSiblings(item);

          for (var i = 0, l = previousSiblings.length; i < l; i++) {
            if (qx.bom.Selector.matches(selector, [previousSiblings[i]]).length > 0) {
              break;
            }

            found.push(previousSiblings[i]);
          }
        });
        return qxWeb.$init(found, qxWeb);
      },

      /**
       * Gets a collection containing all sibling elements of the items in the
       * current set.
       * This set can be filtered with an optional expression that will cause only
       * elements matching the selector to be collected.
       *
       * @attach {qxWeb}
       * @param selector {String?} Optional selector expression
       * @return {qxWeb} New set containing sibling elements
       */
      getSiblings: function getSiblings(selector) {
        var ret = qx.module.Traversing.__hierarchyHelper__P_198_4(this, "getSiblings", selector);

        return qxWeb.$init(ret, qxWeb);
      },

      /**
       * Remove elements from the collection that do not pass the given filter.
       * This can be either a selector expression or a filter function
       *
       * @attach {qxWeb}
       * @param selector {String|Function} Selector or filter function
       * @return {qxWeb} Reduced collection
       */
      not: function not(selector) {
        if (qx.lang.Type.isFunction(selector)) {
          return this.filter(function (item, index, obj) {
            return !selector(item, index, obj);
          });
        }

        var res = qx.bom.Selector.matches(selector, this);
        return this.filter(function (value) {
          return res.indexOf(value) === -1;
        });
      },

      /**
       * Gets a new collection containing the offset parent of each item in the
       * current set.
       *
       * @attach {qxWeb}
       * @return {qxWeb} New collection containing offset parents
       */
      getOffsetParent: function getOffsetParent() {
        return this.map(qx.bom.element.Location.getOffsetParent);
      },

      /**
       * Whether the first element in the collection is inserted into
       * the document for which it was created.
       *
       * @attach {qxWeb}
       * @return {Boolean} <code>true</code> when the element is inserted
       *    into the document.
       */
      isRendered: function isRendered() {
        if (!this[0]) {
          return false;
        }

        return qx.dom.Hierarchy.isRendered(this[0]);
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this); // manually attach private method which is ignored by attachAll

      qxWeb.$attach({
        "__getAncestors__P_198_0": statics.__getAncestors__P_198_0
      });
    }
  });
  qx.module.Traversing.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Attribute": {
        "require": true
      },
      "qx.module.Css": {
        "require": true
      },
      "qx.module.Environment": {
        "require": true
      },
      "qx.module.Event": {
        "require": true
      },
      "qx.module.Manipulating": {
        "require": true
      },
      "qx.module.Polyfill": {
        "require": true
      },
      "qx.module.Traversing": {
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * Placeholder class which simply defines and includes the core of qxWeb.
   * The core modules are:
   *
   * * {@link qx.module.Attribute}
   * * {@link qx.module.Css}
   * * {@link qx.module.Environment}
   * * {@link qx.module.Event}
   * * {@link qx.module.Manipulating}
   * * {@link qx.module.Polyfill}
   * * {@link qx.module.Traversing}
   *
   * @require(qx.module.Attribute)
   * @require(qx.module.Css)
   * @require(qx.module.Environment)
   * @require(qx.module.Event)
   * @require(qx.module.Manipulating)
   * @require(qx.module.Polyfill)
   * @require(qx.module.Traversing)
   */
  qx.Bootstrap.define("qx.module.Core", {});
  qx.module.Core.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.element.Dataset": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Romeo Kenfack (rkenfack)
  
  ************************************************************************ */

  /**
   * Module for handling of HTML5 data-* attributes
   */
  qx.Bootstrap.define("qx.module.Dataset", {
    members: {
      /**
       * Sets an HTML "data-*" attribute on each item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Name of the attribute [CamelCase variant]
       * @param value {var} New value of the attribute
       * @return {qxWeb} The collection for chaining
       */
      setData: function setData(name, value) {
        this._forEachElement(function (item) {
          qx.bom.element.Dataset.set(item, name, value);
        });

        return this;
      },

      /**
       *
       * Returns the value of the given HTML "data-*" attribute for the first item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Name of the attribute [CamelCase variant]
       * @return {var} The value of the attribute
       *
       */
      getData: function getData(name) {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Dataset.get(this[0], name);
        }
      },

      /**
       * Returns a map containing all the HTML "data-*" attributes of the specified element
       *
       * @attach {qxWeb}
       * @return {Map} The map containing the "data-*" attributes
       *
       */
      getAllData: function getAllData() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Dataset.getAll(this[0]);
        }

        return {};
      },

      /**
      * Checks if any element in the collection has a "data-*" attribute
      * @return {Boolean} True if any element in the collection has a "data-*" attribute
      */
      hasData: function hasData() {
        return qx.bom.element.Dataset.hasData(this[0]);
      },

      /**
       * Remove an HTML "data-*" attribute on each item in the collection
       *
       * @attach {qxWeb}
       * @param name {String} Name of the attribute
       * @return {qxWeb} The collection for chaining
       */
      removeData: function removeData(name) {
        this._forEachElement(function (item) {
          qx.bom.element.Dataset.remove(item, name);
        });

        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.Dataset.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.request.Xhr": {},
      "qx.bom.request.Script": {},
      "qx.bom.request.Jsonp": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This module provides basic IO functionality. It contains three ways to load
   * data:
   *
   * * XMLHttpRequest
   * * Script tag
   * * Script tag using JSONP
   *
   * @require(qx.bom.request.Xhr#open)
   *
   * @group (IO)
   */
  qx.Bootstrap.define("qx.module.Io", {
    statics: {
      /**
       * Returns a configured XMLHttpRequest object. Using the send method will
       * finally send the request.
       *
       * @param url {String} Mandatory URL to load the data from.
       * @param settings {Map?} Optional settings map which may contain one of
       *   the following settings:
       * <ul>
       * <li><code>method</code> The method of the request. Default: <code>GET</code></li>
       * <li><code>async</code> flag to mark the request as asynchronous. Default: <code>true</code></li>
       * <li><code>header</code> A map of request headers.</li>
       * </ul>
       *
       * @attachStatic {qxWeb, io.xhr}
       * @return {qx.bom.request.Xhr} The request object.
       */
      xhr: function xhr(url, settings) {
        if (!settings) {
          settings = {};
        }

        var xhr = new qx.bom.request.Xhr();
        xhr.open(settings.method, url, settings.async);

        if (settings.header) {
          var header = settings.header;

          for (var key in header) {
            xhr.setRequestHeader(key, header[key]);
          }
        }

        return xhr;
      },

      /**
       * Returns a predefined script tag wrapper which can be used to load data
       * from cross-domain origins.
       *
       * @param url {String} Mandatory URL to load the data from.
       * @attachStatic {qxWeb, io.script}
       * @return {qx.bom.request.Script} The request object.
       */
      script: function script(url) {
        var script = new qx.bom.request.Script();
        script.open("get", url);
        return script;
      },

      /**
       * Returns a predefined script tag wrapper which can be used to load data
       * from cross-domain origins via JSONP.
       *
       * @param url {String} Mandatory URL to load the data from.
       * @param settings {Map?} Optional settings map which may contain one of
       *   the following settings:
       *
       * * <code>callbackName</code>: The name of the callback which will
       *      be called by the loaded script.
       * * <code>callbackParam</code>: The name of the callback expected by the server
       * @attachStatic {qxWeb, io.jsonp}
       * @return {qx.bom.request.Jsonp} The request object.
       */
      jsonp: function jsonp(url, settings) {
        var script = new qx.bom.request.Jsonp();

        if (settings && settings.callbackName) {
          script.setCallbackName(settings.callbackName);
        }

        if (settings && settings.callbackParam) {
          script.setCallbackParam(settings.callbackParam);
        }

        script.setPrefix("qxWeb.$$"); // needed in case no callback name is given

        script.open("get", url);
        return script;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "io");
    }
  });
  qx.module.Io.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.MediaQuery": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Romeo Kenfack Tsakem (rkenfack)
       * Tobias Oberrauch (toberrauch)
  
  ************************************************************************ */

  /**
   * Module for mediaqueries evaluation. The module is a wrapper for media.match.js,
   * that implements a polyfill for window.matchMedia when it's not supported natively.
   */
  qx.Bootstrap.define("qx.module.MatchMedia", {
    statics: {
      /**
       * Evaluates the specified mediaquery list
       *
       * @param query {String} the media query to evaluate
       * @return {qx.bom.MediaQuery}  The media query
       * @attachStatic {qxWeb, matchMedia}
       */
      matchMedia: function matchMedia(query) {
        return new qx.bom.MediaQuery(query);
      },

      /**
       * Adds screen size classes (e.g. small-only or medium-up) by pre-defined media queries using em.
       * The range goes from small to medium, large and xlarge up to xxlarge:
       *
       * small: 0em - 40em
       * medium: 40.063em - 64em
       * large: 64.063em - 90em
       * xlarge: 90.063em - 120em
       * xxlarge: > 120.063em
       *
       * The suffix of the class name indicates either that the current screen
       * is larger than this size (*-up) or in that range (*-only).
       *
       * @attachStatic {qxWeb}
       */
      addSizeClasses: function addSizeClasses() {
        qxWeb("html").mediaQueryToClass("only screen", "small-up");
        qxWeb("html").mediaQueryToClass("only screen and (max-width: 40em)", "small-only");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 40.063em)", "medium-up");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 40.063em) and (max-width: 64em)", "medium-only");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 64.063em)", "large-up");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 64.063em) and (max-width: 90em)", "large-only");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 90.063em)", "xlarge-up");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 90.063em) and (max-width: 120em)", "xlarge-only");
        qxWeb("html").mediaQueryToClass("only screen and (min-width: 120.063em)", "xxlarge-up");
      },

      /**
       * Adds or removes a class depending on matching a given media query
       *
       * @param query {String} the media query to evaluate
       * @param className {String} css class name that gets bind to an element
       */
      __applyClass__P_194_0: function __applyClass__P_194_0(query, className) {
        if (query.isMatching()) {
          this.addClass(className);
        } else {
          this.removeClass(className);
        }
      }
    },
    members: {
      /**
       * Listens for media query updates and applies/removes the css class.
       *
       * @param queryString {String} the media query to evaluate
       * @param className {String} css class name that gets bind to an element
       *
       * @attach {qxWeb}
       * @return {qxWeb} Self instance for chaining
       */
      mediaQueryToClass: function mediaQueryToClass(queryString, className) {
        var query = qx.module.MatchMedia.matchMedia(queryString);

        var callback = qx.module.MatchMedia.__applyClass__P_194_0.bind(this, query, className); // apply classes initially


        callback(query, className);
        query.on("change", callback);
        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.MatchMedia.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      },
      "qx.event.Messaging": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * Define messages to react on certain channels.
   *
   * The channel names will be used in the q.messaging.on method to define handlers which will
   * be called on certain channels and routes. The q.messaging.emit method can be used
   * to execute a given route on a channel. q.messaging.onAny defines a handler on any channel.
   *
   * @require(qx.event.Messaging#on)
   * @require(qx.event.Messaging#onAny)
   * @require(qx.event.Messaging#remove)
   * @require(qx.event.Messaging#emit)
   */
  qx.Bootstrap.define("qx.module.Messaging", {
    statics: {
      /**
       * Adds a route handler for the given channel. The route is called
       * if the {@link #emit} method finds a match.
       *
       * @attachStatic{qxWeb, messaging.on}
       * @param channel {String} The channel of the message.
       * @param type {String|RegExp} The type, used for checking if the executed path matches.
       * @param handler {Function} The handler to call if the route matches the executed path.
       * @param scope {var ? null} The scope of the handler.
       * @return {String} The id of the route used to remove the route.
       * @signature function(channel, type, handler, scope)
       */
      on: null,

      /**
       * Adds a handler for the "any" channel. The "any" channel is called
       * before all other channels.
       *
       * @attachStatic{qxWeb, messaging.onAny}
       * @param type {String|RegExp} The route, used for checking if the executed path matches
       * @param handler {Function} The handler to call if the route matches the executed path
       * @param scope {var ? null} The scope of the handler.
       * @return {String} The id of the route used to remove the route.
       * @signature function(type, handler, scope)
       */
      onAny: null,

      /**
       * Removes a registered listener by the given id.
       *
       * @attachStatic{qxWeb, messaging.remove}
       * @param id {String} The id of the registered listener.
       * @signature function(id)
       */
      remove: null,

      /**
       * Sends a message on the given channel and informs all matching route handlers.
       *
       * @attachStatic{qxWeb, messaging.emit}
       * @param channel {String} The channel of the message.
       * @param path {String} The path to execute
       * @param params {Map} The given parameters that should be propagated
       * @param customData {var} The given custom data that should be propagated
       * @signature function(channel, path, params, customData)
       */
      emit: null
    },
    defer: function defer(statics) {
      qxWeb.$attachStatic({
        "messaging": new qx.event.Messaging()
      });
    }
  });
  qx.module.Messaging.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Manipulating": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Css": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Attribute": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Environment": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Polyfill": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Traversing": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * The module supplies a fallback implementation for placeholders, which is
   * used on input and textarea elements. If the browser supports native placeholders
   * the API silently ignores all calls. If not, an element will be created for every
   * given input element and acts as placeholder. Most modern browsers support
   * placeholders which makes the fallback only relevant for IE < 10 and FF < 4.
   *
   *  * <a href="http://dev.w3.org/html5/spec/single-page.html#the-placeholder-attribute">HTML Spec</a>
   *
   *  * <a href="http://caniuse.com/#feat=input-placeholder">Browser Support</a>
   *
   * @require(qx.module.Manipulating)
   * @require(qx.module.Css)
   * @require(qx.module.Attribute)
   * @require(qx.module.Event)
   * @require(qx.module.Environment)
   * @require(qx.module.Polyfill)
   * @require(qx.module.Traversing)
   */
  qx.Bootstrap.define("qx.module.Placeholder", {
    statics: {
      /**
       * String holding the property name which holds the placeholder
       * element for each input.
       */
      PLACEHOLDER_NAME: "$qx_placeholder",

      /**
       * Queries for all input and textarea elements on the page and updates
       * their placeholder.
       * @attachStatic{qxWeb, placeholder.update}
       */
      update: function update() {
        // ignore if native placeholder are supported
        if (!qxWeb.env.get("css.placeholder")) {
          qxWeb("input[placeholder], textarea[placeholder]").updatePlaceholder();
        }
      },

      /**
       * Internal helper method to update the styles for a given input element.
       * @param item {qxWeb} The input element to update.
       */
      __syncStyles__P_195_0: function __syncStyles__P_195_0(item) {
        var placeholder = item.getAttribute("placeholder");
        var placeholderEl = item.getProperty(qx.module.Placeholder.PLACEHOLDER_NAME);
        var zIndex = item.getStyle("z-index");
        var paddingHor = parseInt(item.getStyle("padding-left")) + 2 * parseInt(item.getStyle("padding-right"));
        var paddingVer = parseInt(item.getStyle("padding-top")) + 2 * parseInt(item.getStyle("padding-bottom"));
        placeholderEl.setHtml(placeholder).setStyles({
          display: item.getValue() == "" ? "inline" : "none",
          zIndex: zIndex == "auto" ? 1 : zIndex + 1,
          textAlign: item.getStyle("text-align"),
          width: item.getWidth() - paddingHor - 4 + "px",
          height: item.getHeight() - paddingVer - 4 + "px",
          left: item.getPosition().left + "px",
          top: item.getPosition().top + "px",
          fontFamily: item.getStyle("font-family"),
          fontStyle: item.getStyle("font-style"),
          fontVariant: item.getStyle("font-variant"),
          fontWeight: item.getStyle("font-weight"),
          fontSize: item.getStyle("font-size"),
          paddingTop: parseInt(item.getStyle("padding-top")) + 2 + "px",
          paddingRight: parseInt(item.getStyle("padding-right")) + 2 + "px",
          paddingBottom: parseInt(item.getStyle("padding-bottom")) + 2 + "px",
          paddingLeft: parseInt(item.getStyle("padding-left")) + 2 + "px"
        });
      },

      /**
       * Creates a placeholder element based on the given input element.
       * @param item {qxWeb} The input element.
       * @return {qxWeb} The placeholder element.
       */
      __createPlaceholderElement__P_195_1: function __createPlaceholderElement__P_195_1(item) {
        // create the label with initial styles
        var placeholderEl = qxWeb.create("<label>").setStyles({
          position: "absolute",
          color: "#989898",
          overflow: "hidden",
          pointerEvents: "none"
        }); // store the label at the input field

        item.setProperty(qx.module.Placeholder.PLACEHOLDER_NAME, placeholderEl); // update the placeholders visibility on keyUp

        item.on("keyup", function (item) {
          var el = item.getProperty(qx.module.Placeholder.PLACEHOLDER_NAME);
          el.setStyle("display", item.getValue() == "" ? "inline" : "none");
        }.bind(this, item)); // for browsers not supporting pointer events

        if (!qxWeb.env.get("css.pointerevents")) {
          placeholderEl.setStyle("cursor", "text").on("tap", function (item) {
            item.focus();
          }.bind(this, item));
        }

        return placeholderEl;
      }
    },
    members: {
      /**
       * Updates the placeholders for input's and textarea's in the collection.
       * This includes positioning, styles and DOM positioning.
       * In case the browser supports native placeholders, this methods simply
       * does nothing.
       *
       * @attach {qxWeb}
       * @return {qxWeb} The collection for chaining
       */
      updatePlaceholder: function updatePlaceholder() {
        // ignore everything if native placeholder are supported
        if (!qxWeb.env.get("css.placeholder")) {
          for (var i = 0; i < this.length; i++) {
            var item = qxWeb(this[i]); // ignore all not fitting items in the collection

            var placeholder = item.getAttribute("placeholder");
            var tagName = item.getProperty("tagName");

            if (!placeholder || tagName != "TEXTAREA" && tagName != "INPUT") {
              continue;
            } // create the element if necessary


            var placeholderEl = item.getProperty(qx.module.Placeholder.PLACEHOLDER_NAME);

            if (!placeholderEl) {
              placeholderEl = qx.module.Placeholder.__createPlaceholderElement__P_195_1(item);
            } // remove and add handling


            var itemInBody = item.isRendered();
            var placeholderElInBody = placeholderEl.isRendered();

            if (itemInBody && !placeholderElInBody) {
              item.before(placeholderEl);
            } else if (!itemInBody && placeholderElInBody) {
              placeholderEl.remove();
              return this;
            }

            qx.module.Placeholder.__syncStyles__P_195_0(item);
          }

          ;
        }

        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "placeholder");
    }
  });
  qx.module.Placeholder.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.rest.Resource": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /**
   * This modules eases the communication with a RESTful web service by providing
   * a client-side wrapper of a REST resource.
   *
   * See {@link qx.bom.rest.Resource}.
   *
   * @group (IO)
   */
  qx.Bootstrap.define("qx.module.Rest", {
    statics: {
      /**
       * @param description {Map?} Each key of the map is interpreted as
       *  <code>action</code> name. The value associated to the key must be a map
       *  with the properties <code>method</code> and <code>url</code>.
       *  <code>check</code> is optional. Also see {@link qx.bom.rest.Resource#map}.
       *
       * @attachStatic {qxWeb, rest.resource}
       * @return {qx.bom.rest.Resource} The resource object.
       */
      resource: function resource(description) {
        return new qx.bom.rest.Resource(description);
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "rest");
    }
  });
  qx.module.Rest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Storage": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This module offers a cross browser storage implementation. The API is aligned
   * with the API of the HTML web storage (http://www.w3.org/TR/webstorage/) which is
   * also the preferred implementation used. As fallback for IE < 8, we use user data.
   * If both techniques are unsupported, we supply a in memory storage, which is
   * of course, not persistent.
   */
  qx.Bootstrap.define("qx.module.Storage", {
    statics: {
      /**
       * Store an item in the storage.
       *
       * @attachStatic {qxWeb, localStorage.setItem}
       * @param key {String} The identifier key.
       * @param value {var} The data, which will be stored as JSON.
       */
      setLocalItem: function setLocalItem(key, value) {
        qx.bom.Storage.getLocal().setItem(key, value);
      },

      /**
       * Returns the stored item.
       *
       * @attachStatic {qxWeb, localStorage.getItem}
       * @param key {String} The identifier to get the data.
       * @return {var} The stored data.
       */
      getLocalItem: function getLocalItem(key) {
        return qx.bom.Storage.getLocal().getItem(key);
      },

      /**
       * Removes an item form the storage.
       * @attachStatic {qxWeb, localStorage.removeItem}
       * @param key {String} The identifier.
       */
      removeLocalItem: function removeLocalItem(key) {
        qx.bom.Storage.getLocal().removeItem(key);
      },

      /**
       * Returns the amount of key-value pairs stored.
       * @attachStatic {qxWeb, localStorage.getLength}
       * @return {Number} The length of the storage.
       */
      getLocalLength: function getLocalLength() {
        return qx.bom.Storage.getLocal().getLength();
      },

      /**
       * Returns the named key at the given index.
       * @attachStatic {qxWeb, localStorage.getKey}
       * @param index {Number} The index in the storage.
       * @return {String} The key stored at the given index.
       */
      getLocalKey: function getLocalKey(index) {
        return qx.bom.Storage.getLocal().getKey(index);
      },

      /**
       * Deletes every stored item in the storage.
       * @attachStatic {qxWeb, localStorage.clear}
       */
      clearLocal: function clearLocal() {
        qx.bom.Storage.getLocal().clear();
      },

      /**
       * Helper to access every stored item.
       *
       * @attachStatic {qxWeb, localStorage.forEach}
       * @param callback {Function} A function which will be called for every item.
       *   The function will have two arguments, first the key and second the value
       *    of the stored data.
       * @param scope {var} The scope of the function.
       */
      forEachLocal: function forEachLocal(callback, scope) {
        qx.bom.Storage.getLocal().forEach(callback, scope);
      },

      /**
       * Store an item in the storage.
       *
       * @attachStatic {qxWeb, sessionStorage.setItem}
       * @param key {String} The identifier key.
       * @param value {var} The data, which will be stored as JSON.
       */
      setSessionItem: function setSessionItem(key, value) {
        qx.bom.Storage.getSession().setItem(key, value);
      },

      /**
       * Returns the stored item.
       *
       * @attachStatic {qxWeb, sessionStorage.getItem}
       * @param key {String} The identifier to get the data.
       * @return {var} The stored data.
       */
      getSessionItem: function getSessionItem(key) {
        return qx.bom.Storage.getSession().getItem(key);
      },

      /**
       * Removes an item form the storage.
       * @attachStatic {qxWeb, sessionStorage.removeItem}
       * @param key {String} The identifier.
       */
      removeSessionItem: function removeSessionItem(key) {
        qx.bom.Storage.getSession().removeItem(key);
      },

      /**
       * Returns the amount of key-value pairs stored.
       * @attachStatic {qxWeb, sessionStorage.getLength}
       * @return {Number} The length of the storage.
       */
      getSessionLength: function getSessionLength() {
        return qx.bom.Storage.getSession().getLength();
      },

      /**
       * Returns the named key at the given index.
       * @attachStatic {qxWeb, sessionStorage.getKey}
       * @param index {Number} The index in the storage.
       * @return {String} The key stored at the given index.
       */
      getSessionKey: function getSessionKey(index) {
        return qx.bom.Storage.getSession().getKey(index);
      },

      /**
       * Deletes every stored item in the storage.
       * @attachStatic {qxWeb, sessionStorage.clear}
       */
      clearSession: function clearSession() {
        qx.bom.Storage.getSession().clear();
      },

      /**
       * Helper to access every stored item.
       *
       * @attachStatic {qxWeb, sessionStorage.forEach}
       * @param callback {Function} A function which will be called for every item.
       *   The function will have two arguments, first the key and second the value
       *    of the stored data.
       * @param scope {var} The scope of the function.
       */
      forEachSession: function forEachSession(callback, scope) {
        qx.bom.Storage.getSession().forEach(callback, scope);
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachStatic({
        "localStorage": {
          setItem: statics.setLocalItem,
          getItem: statics.getLocalItem,
          removeItem: statics.removeLocalItem,
          getLength: statics.getLocalLength,
          getKey: statics.getLocalKey,
          clear: statics.clearLocal,
          forEach: statics.forEachLocal
        },
        "sessionStorage": {
          setItem: statics.setSessionItem,
          getItem: statics.getSessionItem,
          removeItem: statics.removeSessionItem,
          getLength: statics.getSessionLength,
          getKey: statics.getSessionKey,
          clear: statics.clearSession,
          forEach: statics.forEachSession
        }
      });
    }
  });
  qx.module.Storage.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Template": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * HTML templating module. This is a wrapper for mustache.js which is a
   * "framework-agnostic way to render logic-free views".
   *
   * For further details, please visit the mustache.js documentation here:
   *   https://github.com/janl/mustache.js/blob/master/README.md
   */
  qx.Bootstrap.define("qx.module.Template", {
    statics: {
      /**
       * Helper method which provides direct access to templates stored as HTML in
       * the DOM. The DOM node with the given ID will be treated as a template,
       * parsed and a new DOM element will be returned containing the parsed data.
       * Keep in mind that templates can only have one root element.
       * Additionally, you should not put the template into a regular, hidden
       * DOM element because the template may not be valid HTML due to the containing
       * mustache tags. We suggest to put it into a script tag with the type
       * <code>text/template</code>.
       *
       * @attachStatic{qxWeb, template.get}
       * @param id {String} The id of the HTML template in the DOM.
       * @param view {Object} The object holding the data to render.
       * @param partials {Object} Object holding parts of a template.
       * @return {qxWeb} Collection containing a single DOM element with the parsed
       * template data.
       */
      get: function get(id, view, partials) {
        var el = qx.bom.Template.get(id, view, partials);
        el = qx.module.Template.__wrap__P_196_0(el);
        return qxWeb.$init([el], qxWeb);
      },

      /**
       * Original and only template method of mustache.js. For further
       * documentation, please visit <a href="https://github.com/janl/mustache.js">mustache.js</a>.
       *
       * @attachStatic{qxWeb, template.render}
       * @param template {String} The String containing the template.
       * @param view {Object} The object holding the data to render.
       * @param partials {Object} Object holding parts of a template.
       * @return {String} The parsed template.
       */
      render: function render(template, view, partials) {
        return qx.bom.Template.render(template, view, partials);
      },

      /**
       * Combines {@link #render} and {@link #get}. Input is equal to {@link #render}
       * and output is equal to {@link #get}. The advantage over {@link #get}
       * is that you don't need a HTML template but can use a template
       * string and still get a collection. Keep in mind that templates
       * can only have one root element.
       *
       * @attachStatic{qxWeb, template.renderToNode}
       * @param template {String} The String containing the template.
       * @param view {Object} The object holding the data to render.
       * @param partials {Object} Object holding parts of a template.
       * @return {qxWeb} Collection containing a single DOM element with the parsed
       * template data.
       */
      renderToNode: function renderToNode(template, view, partials) {
        var el = qx.bom.Template.renderToNode(template, view, partials);
        el = qx.module.Template.__wrap__P_196_0(el);
        return qxWeb.$init([el], qxWeb);
      },

      /**
       * If the given node is a DOM text node, wrap it in a span element and return
       * the wrapper.
       * @param el {Node} a DOM node
       * @return {Element} Original element or wrapper
       */
      __wrap__P_196_0: function __wrap__P_196_0(el) {
        if (qxWeb.isTextNode(el)) {
          var wrapper = document.createElement("span");
          wrapper.appendChild(el);
          el = wrapper;
        }

        return el;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "template");
    }
  });
  qx.module.Template.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Selection": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Text selection manipulation module
   */
  qx.Bootstrap.define("qx.module.TextSelection", {
    statics: {
      /**
       * Checks if the given DOM node is a text input field or textarea
       *
       * @param el {Element} The node to check
       * @return {Boolean} <code>true</code> if the given node is an input field
       *
       * @attach {qxWeb}
       */
      __isInput__P_197_0: function __isInput__P_197_0(el) {
        var tag = el.tagName ? el.tagName.toLowerCase() : null;
        return tag === "input" || tag === "textarea";
      },

      /**
       * Returns the first text child node of the given element
       *
       * @param el {Element} DOM element
       * @return {Node|null} text node
       *
       * @attach {qxWeb}
       */
      __getTextNode__P_197_1: function __getTextNode__P_197_1(el) {
        for (var i = 0, l = el.childNodes.length; i < l; i++) {
          if (el.childNodes[i].nodeType === 3) {
            return el.childNodes[i];
          }
        }

        return null;
      }
    },
    members: {
      /**
       * Get the text selection of the first element.
       *
       * @return {String|null}
       */
      getTextSelection: function getTextSelection() {
        var el = this[0];

        if (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          return el ? qx.bom.Selection.get(el) : null;
        }

        return null;
      },

      /**
       * Get the length of the text selection of the first element.
       *
       *
       * @return {Integer|null}
       *
       * @attach {qxWeb}
       */
      getTextSelectionLength: function getTextSelectionLength() {
        var el = this[0];

        if (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          return el ? qx.bom.Selection.getLength(el) : null;
        }

        return null;
      },

      /**
       * Get the start of the text selection of the first element.
       *
       * @return {Integer|null}
       *
       * @attach {qxWeb}
       */
      getTextSelectionStart: function getTextSelectionStart() {
        var el = this[0];

        if (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          return el ? qx.bom.Selection.getStart(el) : null;
        }

        return null;
      },

      /**
       * Get the end of the text selection of the first element.
       *
       * @return {Integer|null}
       *
       * @attach {qxWeb}
       */
      getTextSelectionEnd: function getTextSelectionEnd() {
        var el = this[0];

        if (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          return el ? qx.bom.Selection.getEnd(el) : null;
        }

        return null;
      },

      /**
       * Set the text selection of the first element in the collection
       * with the given start and end value.
       * If no end value is passed the selection will extend to the end.
       *
       * @param start {Integer} start of the selection (zero based)
       * @param end {Integer} end of the selection
       * @return {qxWeb} The collection for chaining.
       *
       * @attach {qxWeb}
       */
      setTextSelection: function setTextSelection(start, end) {
        var el = this[0];

        if (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          if (el) {
            qx.bom.Selection.set(el, start, end);
          }
        }

        return this;
      },

      /**
       * Clears the text selection of all elements.
       *
       * @return {qxWeb} The collection for chaining.
       *
       * @attach {qxWeb}
       */
      clearTextSelection: function clearTextSelection() {
        this._forEachElement(function (el) {
          if (!qx.module.TextSelection.__isInput__P_197_0(el)) {
            el = qx.module.TextSelection.__getTextNode__P_197_1(el);
          }

          if (el) {
            qx.bom.Selection.clear(el);
          }
        });

        return this;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.TextSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.element.Transform": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This class is responsible for applying CSS3 transforms to the collection.
   * The implementation is mostly a cross browser wrapper for applying the
   * transforms.
   * The API is keep to the spec as close as possible.
   *
   * http://www.w3.org/TR/css3-3d-transforms/
   */
  qx.Bootstrap.define("qx.module.Transform", {
    members: {
      /**
       * Method to apply multiple transforms at once to the given element. It
       * takes a map containing the transforms you want to apply plus the values
       * e.g.<code>{scale: 2, rotate: "5deg"}</code>.
       * The values can be either singular, which means a single value will
       * be added to the CSS. If you give an array, the values will be split up
       * and each array entry will be used for the X, Y or Z dimension in that
       * order e.g. <code>{scale: [2, 0.5]}</code> will result in a element
       * double the size in X direction and half the size in Y direction.
       * Make sure your browser supports all transformations you apply.
       *
       * @attach {qxWeb}
       * @param transforms {Map} The map containing the transforms and value.
       * @return {qxWeb} This reference for chaining.
       */
      transform: function transform(transforms) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.transform(el, transforms);
        });

        return this;
      },

      /**
       * Translates by the given value. For further details, take
       * a look at the {@link #transform} method.
       *
       * @attach {qxWeb}
       * @param value {String|Array} The value to translate e.g. <code>"10px"</code>.
       * @return {qxWeb} This reference for chaining.
       */
      translate: function translate(value) {
        return this.transform({
          translate: value
        });
      },

      /**
       * Scales by the given value. For further details, take
       * a look at the {@link #transform} method.
       *
       * @attach {qxWeb}
       * @param value {Number|Array} The value to scale.
       * @return {qxWeb} This reference for chaining.
       */
      scale: function scale(value) {
        return this.transform({
          scale: value
        });
      },

      /**
       * Rotates by the given value. For further details, take
       * a look at the {@link #transform} method.
       *
       * @attach {qxWeb}
       * @param value {String|Array} The value to rotate e.g. <code>"90deg"</code>.
       * @return {qxWeb} This reference for chaining.
       */
      rotate: function rotate(value) {
        return this.transform({
          rotate: value
        });
      },

      /**
       * Skews by the given value. For further details, take
       * a look at the {@link #transform} method.
       *
       * @attach {qxWeb}
       * @param value {String|Array} The value to skew e.g. <code>"90deg"</code>.
       * @return {qxWeb} This reference for chaining.
       */
      skew: function skew(value) {
        return this.transform({
          skew: value
        });
      },

      /**
       * Sets the transform-origin property.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-origin-property
       *
       * @attach {qxWeb}
       * @param value {String} CSS position values like <code>50% 50%</code> or
       *   <code>left top</code>.
       * @return {qxWeb} This reference for chaining.
       */
      setTransformOrigin: function setTransformOrigin(value) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.setOrigin(el, value);
        });

        return this;
      },

      /**
       * Returns the transform-origin property of the first element.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-origin-property
       *
       * @attach {qxWeb}
       * @return {String} The set property, e.g. <code>50% 50%</code> or null,
       *   of the collection is empty.
       */
      getTransformOrigin: function getTransformOrigin() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Transform.getOrigin(this[0]);
        }

        return "";
      },

      /**
       * Sets the transform-style property.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-style-property
       *
       * @attach {qxWeb}
       * @param value {String} Either <code>flat</code> or <code>preserve-3d</code>.
       * @return {qxWeb} This reference for chaining.
       */
      setTransformStyle: function setTransformStyle(value) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.setStyle(el, value);
        });

        return this;
      },

      /**
       * Returns the transform-style property of the first element.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-style-property
       *
       * @attach {qxWeb}
       * @return {String} The set property, either <code>flat</code> or
       *   <code>preserve-3d</code>.
       */
      getTransformStyle: function getTransformStyle() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Transform.getStyle(this[0]);
        }

        return "";
      },

      /**
       * Sets the perspective property.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-property
       *
       * @attach {qxWeb}
       * @param value {Number} The perspective layer. Numbers between 100
       *   and 5000 give the best results.
       * @return {qxWeb} This reference for chaining.
       */
      setTransformPerspective: function setTransformPerspective(value) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.setPerspective(el, value);
        });

        return this;
      },

      /**
       * Returns the perspective property of the first element.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-property
       *
       * @attach {qxWeb}
       * @return {String} The set property, e.g. <code>500</code>
       */
      getTransformPerspective: function getTransformPerspective() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Transform.getPerspective(this[0]);
        }

        return "";
      },

      /**
       * Sets the perspective-origin property.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-origin-property
       *
       * @attach {qxWeb}
       * @param value {String} CSS position values like <code>50% 50%</code> or
       *   <code>left top</code>.
       * @return {qxWeb} This reference for chaining.
       */
      setTransformPerspectiveOrigin: function setTransformPerspectiveOrigin(value) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.setPerspectiveOrigin(el, value);
        });

        return this;
      },

      /**
       * Returns the perspective-origin property of the first element.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-origin-property
       *
       * @attach {qxWeb}
       * @return {String} The set property, e.g. <code>50% 50%</code>
       */
      getTransformPerspectiveOrigin: function getTransformPerspectiveOrigin() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Transform.getPerspectiveOrigin(this[0]);
        }

        return "";
      },

      /**
       * Sets the backface-visibility property.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#backface-visibility-property
       *
       * @attach {qxWeb}
       * @param value {Boolean} <code>true</code> if the backface should be visible.
       * @return {qxWeb} This reference for chaining.
       */
      setTransformBackfaceVisibility: function setTransformBackfaceVisibility(value) {
        this._forEachElement(function (el) {
          qx.bom.element.Transform.setBackfaceVisibility(el, value);
        });

        return this;
      },

      /**
       * Returns the backface-visibility property of the first element.
       *
       * Spec: http://www.w3.org/TR/css3-3d-transforms/#backface-visibility-property
       *
       * @attach {qxWeb}
       * @return {Boolean} <code>true</code>, if the backface is visible.
       */
      getTransformBackfaceVisibility: function getTransformBackfaceVisibility() {
        if (this[0] && this[0].nodeType === 1) {
          return qx.bom.element.Transform.getBackfaceVisibility(this[0]);
        }

        return "";
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this);
    }
  });
  qx.module.Transform.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dev.FakeServer": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /**
   * A wrapper around Sinon.JS's FakeXMLHttpRequest and FakeServer features that
   * allows quick and simple configuration of mock HTTP backends for testing and
   * development.
   * Automatically creates URL filtering rules to ensure that only configured
   * requests are faked while others will be processed normally by the browser's
   * XHR implementation.
   *
   * @group (IO)
   */
  qx.Bootstrap.define("qx.module.dev.FakeServer", {
    statics: {
      /**
       * Configures a set of fake HTTP responses. Each response is defined as a map
       * that must provide the following keys:
       * <ul>
       *   <li><code>method</code> HTTP method to respond to, e.g. <code>PUT</code></li>
       *   <li><code>url</code> URL used to match requests to fake responses. Can be
       *   a RegExp or a String. REST-style parameter placeholders in curly braces
       *   will be replaced with wildcards, e.g. the string "/resource/{resourceId}"
       *   is interpreted as the RegExp <code>/\/resource\/\{.*?\}/</code>
       *   <li><code>response</code> This can be either:
       *     <ul>
       *       <li>a string: This will be the response body, status code will be 200</li>
       *       <li>an array containing the status code, a map of response headers and
       *         the response text, e.g. <code>[200, { "Content-Type": "text/html" }, "OK"]</code>
       *       </li>
       *       <li>a function: This will be called with a FakeXMLHttpRequest object as
       *       the only argument. Its <code>respond</code> method must be called to send a response.
       *       See <a href="http://sinonjs.org/docs/#respond">Sinon.JS: Respond</a> for details.
       *       </li>
       *     </ul>
       *   </li>
       * </ul>
       *
       * @attachStatic {qxWeb, dev.fakeServer.configure}
       * @param responseData {Map[]} An array of response description maps.
       */
      configure: function configure(responseData) {
        qx.dev.FakeServer.getInstance().configure(responseData);
      },

      /**
       * Removes a response that was configured with {@link #configure}
       * @param method {String} HTTP method of the response
       * @param url {String|RegExp} URL of the response
       *
       * @attachStatic {qxWeb, dev.fakeServer.removeResponse}
       */
      removeResponse: function removeResponse(method, url) {
        qx.dev.FakeServer.getInstance().removeResponse(method, url);
      },

      /**
       * Adds a URL filtering function to decide whether a request should be handled
       * by the FakeServer or passed to the regular XMLHttp implementation.
       * See <a href="http://sinonjs.org/docs/#filtered-requests">Sinon.JS: Filtered Requests</a>
       * for details.
       *
       * @attachStatic {qxWeb, dev.fakeServer.addFilter}
       * @param filter {Function} URL filter function. Will be called with the
       * following arguments: <code>method</code>, <code>url</code>, <code>async</code>,
       * <code>username</code>, <code>password</code>. Must return <code>true</code>
       * if the request should not be faked.
       */
      addFilter: function addFilter(filter) {
        qx.dev.FakeServer.getInstance().addFilter(filter);
      },

      /**
       * Remove a filter that was added with {@link #addFilter}
       * @param filter {Function} filter function to remove
       *
       * @attachStatic {qxWeb, dev.fakeServer.removeFilter}
       */
      removeFilter: function removeFilter(filter) {
        qx.dev.FakeServer.getInstance().removeFilter(filter);
      },

      /**
       * Defines a fake XHR response to a matching request.
       *
       * @attachStatic {qxWeb, dev.fakeServer.respondWith}
       * @param method {String} HTTP method to respond to, e.g. "GET"
       * @param urlRegExp {RegExp} Request URL must match match this expression
       * @param response {Function|Array|String} Response to send. See
       * <a href="http://sinonjs.org/docs/#fakeServer">Sinon.JS: Fake Server</a> for details.
       */
      respondWith: function respondWith(method, urlRegExp, response) {
        qx.dev.FakeServer.getInstance().respondWith(method, urlRegExp, response);
      },

      /**
       * Creates and configures a FakeServer if necessary and returns it.
       *
       * @attachStatic {qxWeb, dev.fakeServer.getFakeServer}
       * @return {Object} FakeServer object
       */
      getFakeServer: function getFakeServer() {
        return qx.dev.FakeServer.getInstance().getFakeServer();
      },

      /**
       * Stops the FakeServer and removes all configured responses and/or filters.
        * @attachStatic {qxWeb, dev.fakeServer.restore}
       */
      restore: function restore() {
        qx.dev.FakeServer.getInstance().restore();
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachStatic({
        "dev": {
          "fakeServer": {
            "configure": statics.configure,
            "removeResponse": statics.removeResponse,
            "addFilter": statics.addFilter,
            "removeFilter": statics.removeFilter,
            "respondWith": statics.respondWith,
            "getFakeServer": statics.getFakeServer,
            "restore": statics.restore
          }
        }
      });
    }
  });
  qx.module.dev.FakeServer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.event.PointerHandler": {
        "defer": "runtime"
      },
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Event": {},
      "qx.event.Emitter": {},
      "qx.event.handler.GestureCore": {},
      "qxWeb": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "event.dispatchevent": {
          "className": "qx.bom.client.Event"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Creates a gesture handler that fires high-level events such as "swipe"
   * based on low-level event sequences on the given element
   *
   * @require(qx.module.Event)
   * @use(qx.module.event.PointerHandler)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.GestureHandler", {
    statics: {
      TYPES: ["tap", "longtap", "swipe", "dbltap", "track", "trackstart", "trackend", "roll", "rotate", "pinch"],

      /**
       * Creates a gesture handler for the given element when a gesture event listener
       * is attached to it
       *
       * @param element {Element} DOM element
       * @param type {String} event type
       */
      register: function register(element, type) {
        if (!element.$$gestureHandler) {
          if (!qx.core.Environment.get("event.dispatchevent")) {
            if (!element.$$emitter) {
              element.$$emitter = new qx.event.Emitter();
            }
          }

          element.$$gestureHandler = new qx.event.handler.GestureCore(element, element.$$emitter);
        }
      },

      /**
       * Removes the gesture event handler from the element if there are no more
       * gesture event listeners attached to it
       * @param element {Element} DOM element
       */
      unregister: function unregister(element) {
        // check if there are any registered listeners left
        if (element.$$gestureHandler) {
          var listeners = element.$$emitter.getListeners();

          for (var type in listeners) {
            if (qx.module.event.GestureHandler.TYPES.indexOf(type) !== -1) {
              if (listeners[type].length > 0) {
                return;
              }
            }
          } // no more listeners, get rid of the handler


          element.$$gestureHandler.dispose();
          element.$$gestureHandler = undefined;
        }
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventHook(statics.TYPES, statics.register, statics.unregister);
    }
  });
  qx.module.event.GestureHandler.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Environment": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      },
      "qx.event.util.Keyboard": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for native keyboard events.
   *
   * NOTE: Some browsers won't fire the <code>keypress</code> event for all keys.
   * It's generally better to listen for <code>keyup</code> or <code>keydown</code>
   * instead.
   *
   * @require(qx.module.Event)
   * @require(qx.module.Environment)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Keyboard", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["keydown", "keypress", "keyup"],

      /**
       * List qx.module.event.Keyboard methods to be attached to native mouse event
       * objects
       * @internal
       */
      BIND_METHODS: ["getKeyIdentifier"],

      /**
       * Identifier of the pressed key. This property is modeled after the <em>KeyboardEvent.keyIdentifier</em> property
       * of the W3C DOM 3 event specification
       * (http://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/events.html#Events-KeyboardEvent-keyIdentifier).
       *
       * Printable keys are represented by an unicode string, non-printable keys
       * have one of the following values:
       *
       * <table>
       * <tr><th>Backspace</th><td>The Backspace (Back) key.</td></tr>
       * <tr><th>Tab</th><td>The Horizontal Tabulation (Tab) key.</td></tr>
       * <tr><th>Space</th><td>The Space (Spacebar) key.</td></tr>
       * <tr><th>Enter</th><td>The Enter key. Note: This key identifier is also used for the Return (Macintosh numpad) key.</td></tr>
       * <tr><th>Shift</th><td>The Shift key.</td></tr>
       * <tr><th>Control</th><td>The Control (Ctrl) key.</td></tr>
       * <tr><th>Alt</th><td>The Alt (Menu) key.</td></tr>
       * <tr><th>CapsLock</th><td>The CapsLock key</td></tr>
       * <tr><th>Meta</th><td>The Meta key. (Apple Meta and Windows key)</td></tr>
       * <tr><th>Escape</th><td>The Escape (Esc) key.</td></tr>
       * <tr><th>Left</th><td>The Left Arrow key.</td></tr>
       * <tr><th>Up</th><td>The Up Arrow key.</td></tr>
       * <tr><th>Right</th><td>The Right Arrow key.</td></tr>
       * <tr><th>Down</th><td>The Down Arrow key.</td></tr>
       * <tr><th>PageUp</th><td>The Page Up key.</td></tr>
       * <tr><th>PageDown</th><td>The Page Down (Next) key.</td></tr>
       * <tr><th>End</th><td>The End key.</td></tr>
       * <tr><th>Home</th><td>The Home key.</td></tr>
       * <tr><th>Insert</th><td>The Insert (Ins) key. (Does not fire in Opera/Win)</td></tr>
       * <tr><th>Delete</th><td>The Delete (Del) Key.</td></tr>
       * <tr><th>F1</th><td>The F1 key.</td></tr>
       * <tr><th>F2</th><td>The F2 key.</td></tr>
       * <tr><th>F3</th><td>The F3 key.</td></tr>
       * <tr><th>F4</th><td>The F4 key.</td></tr>
       * <tr><th>F5</th><td>The F5 key.</td></tr>
       * <tr><th>F6</th><td>The F6 key.</td></tr>
       * <tr><th>F7</th><td>The F7 key.</td></tr>
       * <tr><th>F8</th><td>The F8 key.</td></tr>
       * <tr><th>F9</th><td>The F9 key.</td></tr>
       * <tr><th>F10</th><td>The F10 key.</td></tr>
       * <tr><th>F11</th><td>The F11 key.</td></tr>
       * <tr><th>F12</th><td>The F12 key.</td></tr>
       * <tr><th>NumLock</th><td>The Num Lock key.</td></tr>
       * <tr><th>PrintScreen</th><td>The Print Screen (PrintScrn, SnapShot) key.</td></tr>
       * <tr><th>Scroll</th><td>The scroll lock key</td></tr>
       * <tr><th>Pause</th><td>The pause/break key</td></tr>
       * <tr><th>Win</th><td>The Windows Logo key</td></tr>
       * <tr><th>Apps</th><td>The Application key (Windows Context Menu)</td></tr>
       * </table>
       *
       * @return {String} The key identifier
       */
      getKeyIdentifier: function getKeyIdentifier() {
        if (this.type == "keypress" && (qxWeb.env.get("engine.name") != "gecko" || this.charCode !== 0)) {
          return qx.event.util.Keyboard.charCodeToIdentifier(this.charCode || this.keyCode);
        }

        return qx.event.util.Keyboard.keyCodeToIdentifier(this.keyCode);
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        }

        var bindMethods = qx.module.event.Keyboard.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Keyboard[bindMethods[i]].bind(event);
          }
        }

        return event;
      },

      /**
       * IE9 will not fire an "input" event on text input elements if the user changes
       * the field's value by pressing the Backspace key. We fix this by listening
       * for the "keyup" event and emitting the missing event if necessary
       *
       * @param element {Element} Target element
       * @internal
       */
      registerInputFix: function registerInputFix(element) {
        if (element.type === "text" || element.type === "password" || element.type === "textarea") {
          if (!element.__inputFix__P_199_0) {
            element.__inputFix__P_199_0 = qxWeb(element).on("keyup", qx.module.event.Keyboard._inputFix);
          }
        }
      },

      /**
       * Removes the IE9 input event fix
       *
       * @param element {Element} target element
       * @internal
       */
      unregisterInputFix: function unregisterInputFix(element) {
        if (element.__inputFix__P_199_0 && !qxWeb(element).hasListener("input")) {
          qxWeb(element).off("keyup", qx.module.event.Keyboard._inputFix);
          element.__inputFix__P_199_0 = null;
        }
      },

      /**
       * IE9 fix: Emits an "input" event if a text input element's value was changed
       * using the Backspace key
       * @param ev {Event} Keyup event
       */
      _inputFix: function _inputFix(ev) {
        if (ev.getKeyIdentifier() !== "Backspace") {
          return;
        }

        var target = ev.getTarget();
        var newValue = qxWeb(target).getValue();

        if (!target.__oldInputValue__P_199_1 || target.__oldInputValue__P_199_1 !== newValue) {
          target.__oldInputValue__P_199_1 = newValue;
          ev.type = ev._type = "input";
          target.$$emitter.emit("input", ev);
        }
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Keyboard.TYPES, statics.normalize);

      if (qxWeb.env.get("engine.name") === "mshtml" && qxWeb.env.get("browser.documentmode") === 9) {
        qxWeb.$registerEventHook("input", statics.registerInputFix, statics.unregisterInputFix);
      }
    }
  });
  qx.module.event.Keyboard.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Environment": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      },
      "qx.dom.Node": {},
      "qx.bom.Viewport": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for native mouse events. For cross-device applications that
   * support both mouse and touchscreen interaction, consider using
   * <a href="#Pointer">Pointer</a> and/or Gesture events (e.g. <a href="Tap"></a>).
   *
   * @require(qx.module.Environment)
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Mouse", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout"],

      /**
       * List qx.module.event.Mouse methods to be attached to native mouse event
       * objects
       * @internal
       */
      BIND_METHODS: ["getButton", "getViewportLeft", "getViewportTop", "getDocumentLeft", "getDocumentTop", "getScreenLeft", "getScreenTop"],

      /**
       * Standard mouse button mapping
       */
      BUTTONS_DOM2: {
        0: "left",
        2: "right",
        1: "middle"
      },

      /**
       * Legacy Internet Explorer mouse button mapping
       */
      BUTTONS_MSHTML: {
        1: "left",
        2: "right",
        4: "middle"
      },

      /**
       * Returns the identifier of the mouse button that change state when the
       * event was triggered
       *
       * @return {String} One of <code>left</code>, <code>right</code> or
       * <code>middle</code>
       */
      getButton: function getButton() {
        switch (this.type) {
          case "contextmenu":
            return "right";

          case "click":
            // IE does not support buttons on click --> assume left button
            if (qxWeb.env.get("browser.name") === "ie" && qxWeb.env.get("browser.documentmode") < 9) {
              return "left";
            }

          default:
            if (this.target !== undefined) {
              return qx.module.event.Mouse.BUTTONS_DOM2[this.button] || "none";
            } else {
              return qx.module.event.Mouse.BUTTONS_MSHTML[this.button] || "none";
            }

        }
      },

      /**
       * Get the horizontal coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The horizontal mouse position
       */
      getViewportLeft: function getViewportLeft() {
        return this.clientX;
      },

      /**
       * Get the vertical coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The vertical mouse position
       * @signature function()
       */
      getViewportTop: function getViewportTop() {
        return this.clientY;
      },

      /**
       * Get the horizontal position at which the event occurred relative to the
       * left of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The horizontal mouse position in the document.
       */
      getDocumentLeft: function getDocumentLeft() {
        if (this.pageX !== undefined) {
          return this.pageX;
        } else {
          var win = qx.dom.Node.getWindow(this.srcElement);
          return this.clientX + qx.bom.Viewport.getScrollLeft(win);
        }
      },

      /**
       * Get the vertical position at which the event occurred relative to the
       * top of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The vertical mouse position in the document.
       */
      getDocumentTop: function getDocumentTop() {
        if (this.pageY !== undefined) {
          return this.pageY;
        } else {
          var win = qx.dom.Node.getWindow(this.srcElement);
          return this.clientY + qx.bom.Viewport.getScrollTop(win);
        }
      },

      /**
       * Get the horizontal coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The horizontal mouse position on the screen.
       */
      getScreenLeft: function getScreenLeft() {
        return this.screenX;
      },

      /**
       * Get the vertical coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The vertical mouse position on the screen.
       */
      getScreenTop: function getScreenTop() {
        return this.screenY;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        }

        var bindMethods = qx.module.event.Mouse.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Mouse[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Mouse.TYPES, statics.normalize);
    }
  });
  qx.module.event.Mouse.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Event": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Common normalizations for native events
   *
   * @require(qx.module.Event)
   * @require(qx.bom.Event#getTarget)
   * @require(qx.bom.Event#getRelatedTarget)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Native", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["*"],

      /**
       * List of qx.bom.Event methods to be attached to native event objects
       * @internal
       */
      FORWARD_METHODS: ["getTarget", "getRelatedTarget"],

      /**
       * List of qx.module.event.Native methods to be attached to native event objects
       * @internal
       */
      BIND_METHODS: ["preventDefault", "stopPropagation", "getType"],

      /**
       * Prevent the native default behavior of the event.
       */
      preventDefault: function preventDefault() {
        try {
          // this allows us to prevent some key press events in IE.
          // See bug #1049
          this.keyCode = 0;
        } catch (ex) {}

        this.returnValue = false;
      },

      /**
       * Stops the event's propagation to the element's parent
       */
      stopPropagation: function stopPropagation() {
        this.cancelBubble = true;
      },

      /**
       * Returns the event's type
       *
       * @return {String} event type
       */
      getType: function getType() {
        return this._type || this.type;
      },

      /**
       * Returns the target of the event.
       *
       * @signature function ()
       * @return {Object} Any valid native event target
       */
      getTarget: function getTarget() {},

      /**
       * Computes the related target from the native DOM event
       *
       * @signature function ()
       * @return {Element} The related target
       */
      getRelatedTarget: function getRelatedTarget() {},

      /**
       * Computes the current target from the native DOM event. Emulates the current target
       * for all browsers without native support (like older IEs).
       *
       * @signature function ()
       * @return {Element} The current target
       */
      getCurrentTarget: function getCurrentTarget() {},

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        }

        var fwdMethods = qx.module.event.Native.FORWARD_METHODS;

        for (var i = 0, l = fwdMethods.length; i < l; i++) {
          event[fwdMethods[i]] = qx.bom.Event[fwdMethods[i]].bind(null, event);
        }

        var bindMethods = qx.module.event.Native.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Native[bindMethods[i]].bind(event);
          }
        }

        event.getCurrentTarget = function () {
          return event.currentTarget || element;
        };

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(statics.TYPES, statics.normalize);
    }
  });
  qx.module.event.Native.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for orientationchange events
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Orientation", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["orientationchange"],

      /**
       * List of qx.module.event.Orientation methods to be attached to native
       * event objects
       * @internal
       */
      BIND_METHODS: ["getOrientation", "isLandscape", "isPortrait"],

      /**
       * Returns the current orientation of the viewport in degrees.
       *
       * All possible values and their meaning:
       *
       * * <code>0</code>: "Portrait"
       * * <code>-90</code>: "Landscape (right, screen turned clockwise)"
       * * <code>90</code>: "Landscape (left, screen turned counterclockwise)"
       * * <code>180</code>: "Portrait (upside-down portrait)"
       *
       * @return {Number} The current orientation in degrees
       */
      getOrientation: function getOrientation() {
        return this._orientation;
      },

      /**
       * Whether the viewport orientation is currently in landscape mode.
       *
       * @return {Boolean} <code>true</code> when the viewport orientation
       *     is currently in landscape mode.
       */
      isLandscape: function isLandscape() {
        return this._mode == "landscape";
      },

      /**
       * Whether the viewport orientation is currently in portrait mode.
       *
       * @return {Boolean} <code>true</code> when the viewport orientation
       *     is currently in portrait mode.
       */
      isPortrait: function isPortrait() {
        return this._mode == "portrait";
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @param type {String} Event type
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element, type) {
        if (!event) {
          return event;
        }

        event._type = type;
        var bindMethods = qx.module.event.Orientation.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Orientation[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(statics.TYPES, statics.normalize);
    }
  });
  qx.module.event.Orientation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dom.Node": {},
      "qx.event.Emitter": {},
      "qx.event.handler.OrientationCore": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Orientation handler which is responsible for registering and unregistering a
   * {@link qx.event.handler.OrientationCore} handler for each given element.
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.OrientationHandler", {
    statics: {
      /**
       * List of events that require an orientation handler
       */
      TYPES: ["orientationchange"],

      /**
       * Creates an orientation handler for the given window when an
       * orientationchange event listener is attached to it
       *
       * @param element {Window} DOM Window
       */
      register: function register(element) {
        if (!qx.dom.Node.isWindow(element)) {
          throw new Error("The 'orientationchange' event is only available on window objects!");
        }

        if (!element.__orientationHandler__P_200_0) {
          if (!element.$$emitter) {
            element.$$emitter = new qx.event.Emitter();
          }

          element.__orientationHandler__P_200_0 = new qx.event.handler.OrientationCore(element, element.$$emitter);
        }
      },

      /**
       * Removes the orientation event handler from the element if there are no more
       * orientationchange event listeners attached to it
       * @param element {Element} DOM element
       */
      unregister: function unregister(element) {
        if (element.__orientationHandler__P_200_0) {
          if (!element.$$emitter) {
            element.__orientationHandler__P_200_0 = null;
          } else {
            var hasListener = false;
            var listeners = element.$$emitter.getListeners();
            qx.module.event.OrientationHandler.TYPES.forEach(function (type) {
              if (type in listeners && listeners[type].length > 0) {
                hasListener = true;
              }
            });

            if (!hasListener) {
              element.__orientationHandler__P_200_0 = null;
            }
          }
        }
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventHook(statics.TYPES, statics.register, statics.unregister);
    }
  });
  qx.module.event.OrientationHandler.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for the pinch gesture.
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Pinch", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["pinch"],
      BIND_METHODS: ["getScale"],

      /**
       * Returns the calculated scale of this event.
       *
       * @return {Float} the scale value of this event.
       */
      getScale: function getScale() {
        return this._original.scale;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        } // apply mouse event normalizations


        var bindMethods = qx.module.event.Pinch.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Pinch[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Pinch.TYPES, statics.normalize);
    }
  });
  qx.module.event.Pinch.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.type.dom.Pointer": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for pointer events. Pointer events are hardware-agnostic and
   * will be fired regardless of which input type of input device is used (e.g. mouse or touchscreen).
   *
   * @require(qx.module.Event)
   * @require(qx.module.event.Pointer#getPointerType) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getViewportLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getViewportTop) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getDocumentLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getDocumentTop) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getScreenLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Pointer#getScreenTop) // static code analysis - this method has to referenced
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Pointer", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["pointerdown", "pointerup", "pointermove", "pointercancel", "pointerover", "pointerout"],

      /**
       * Returns the device type which the event triggered. This can be one
       * of the following strings: <code>mouse</code>, <code>pen</code>
       * or <code>touch</code>.
       *
       * @return {String} The type of the pointer.
       */
      getPointerType: function getPointerType() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the horizontal coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The horizontal mouse position
       */
      getViewportLeft: function getViewportLeft() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the vertical coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The vertical mouse position
       * @signature function()
       */
      getViewportTop: function getViewportTop() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the horizontal position at which the event occurred relative to the
       * left of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The horizontal mouse position in the document.
       */
      getDocumentLeft: function getDocumentLeft() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the vertical position at which the event occurred relative to the
       * top of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The vertical mouse position in the document.
       */
      getDocumentTop: function getDocumentTop() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the horizontal coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The horizontal mouse position on the screen.
       */
      getScreenLeft: function getScreenLeft() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Get the vertical coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The vertical mouse position on the screen.
       */
      getScreenTop: function getScreenTop() {
        // stub for documentation. Implementation is in qx.event.type.dom.Pointer
        return false;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        }

        qx.event.type.dom.Pointer.normalize(event);
        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Pointer.TYPES, statics.normalize);
    }
  });
  qx.module.event.Pointer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for the rotate gesture.
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Rotate", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["rotate"],
      BIND_METHODS: ["getAngle"],

      /**
       * Returns a number with the current calculated angle between the primary and secondary active pointers.
       *
       * @return {Number} the angle of the two active pointers.
       */
      getAngle: function getAngle() {
        return this._original.angle;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        } // apply mouse event normalizations


        var bindMethods = qx.module.event.Rotate.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Rotate[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Rotate.TYPES, statics.normalize);
    }
  });
  qx.module.event.Rotate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for the swipe gesture. This gesture is based on <a href="#Pointer">Pointer events</a>
   * meaning that it's available on all devices, no matter which input device type is used (e.g. mouse or
   * touchscreen).
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Swipe", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["swipe"],
      BIND_METHODS: ["getStartTime", "getDuration", "getAxis", "getDirection", "getVelocity", "getDistance"],

      /**
       * Returns the start time of the performed swipe.
       *
       * @return {Integer} the start time
       */
      getStartTime: function getStartTime() {
        return this._original.swipe.startTime;
      },

      /**
       * Returns the duration the performed swipe took.
       *
       * @return {Integer} the duration
       */
      getDuration: function getDuration() {
        return this._original.swipe.duration;
      },

      /**
       * Returns whether the performed swipe was on the x or y axis.
       *
       * @return {String} "x"/"y" axis
       */
      getAxis: function getAxis() {
        return this._original.swipe.axis;
      },

      /**
       * Returns the direction of the performed swipe in reference to the axis.
       * y = up / down
       * x = left / right
       *
       * @return {String} the direction
       */
      getDirection: function getDirection() {
        return this._original.swipe.direction;
      },

      /**
       * Returns the velocity of the performed swipe.
       *
       * @return {Number} the velocity
       */
      getVelocity: function getVelocity() {
        return this._original.swipe.velocity;
      },

      /**
       * Returns the distance of the performed swipe.
       *
       * @return {Integer} the distance
       */
      getDistance: function getDistance() {
        return this._original.swipe.distance;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        } // apply mouse event normalizations


        var bindMethods = qx.module.event.Swipe.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Swipe[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Swipe.TYPES, statics.normalize);
    }
  });
  qx.module.event.Swipe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for tap gesture events. These gestures are based on <a href="#Pointer">Pointer events</a>,
   * meaning that they are available on all devices, no matter which input device type is used (e.g. mouse or
   * touchscreen).
   *
   * @require(qx.module.Event)
   * @require(qx.module.event.Tap#getViewportLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Tap#getViewportTop) // static code analysis - this method has to referenced
   * @require(qx.module.event.Tap#getDocumentLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Tap#getDocumentTop) // static code analysis - this method has to referenced
   * @require(qx.module.event.Tap#getScreenLeft) // static code analysis - this method has to referenced
   * @require(qx.module.event.Tap#getScreenTop) // static code analysis - this method has to referenced
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Tap", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["tap", "longtap", "dbltap"],

      /**
       * List methods to be attached to gesture event
       * objects
       * @internal
       */
      BIND_METHODS: ["getViewportLeft", "getViewportTop", "getDocumentLeft", "getDocumentTop", "getScreenLeft", "getScreenTop"],

      /**
       * Get the horizontal coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The horizontal contact position
       */
      getViewportLeft: function getViewportLeft() {
        return this._original.getViewportLeft();
      },

      /**
       * Get the vertical coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Number} The vertical contact position
       * @signature function()
       */
      getViewportTop: function getViewportTop() {
        return this._original.getViewportTop();
      },

      /**
       * Get the horizontal position at which the event occurred relative to the
       * left of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The horizontal contact position in the document.
       */
      getDocumentLeft: function getDocumentLeft() {
        return this._original.getDocumentLeft();
      },

      /**
       * Get the vertical position at which the event occurred relative to the
       * top of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Number} The vertical contact position in the document.
       */
      getDocumentTop: function getDocumentTop() {
        return this._original.getDocumentTop();
      },

      /**
       * Get the horizontal coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The horizontal contact position on the screen.
       */
      getScreenLeft: function getScreenLeft() {
        return this._original.getScreenLeft();
      },

      /**
       * Get the vertical coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Number} The vertical contact position on the screen.
       */
      getScreenTop: function getScreenTop() {
        return this._original.getScreenTop();
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        }

        var bindMethods = qx.module.event.Tap.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Tap[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Tap.TYPES, statics.normalize);
    }
  });
  qx.module.event.Tap.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for touch events. For cross-device applications that
   * support both mouse and touchscreen interaction, consider using
   * <a href="#Pointer">Pointer</a> and/or Gesture events (e.g. <a href="Tap"></a>).
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Touch", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["tap", "longtap", "swipe", "dbltap"],

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @param type {String} Event type
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element, type) {
        if (!event) {
          return event;
        }

        event._type = type;
        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(statics.TYPES, statics.normalize);
    }
  });
  qx.module.event.Touch.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.Emitter": {},
      "qx.event.handler.TouchCore": {},
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Creates a touch event handler that fires high-level events such as "swipe"
   * based on low-level event sequences on the given element
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.TouchHandler", {
    statics: {
      /**
       * List of events that require a touch handler
       */
      TYPES: ["touchstart", "touchend", "touchmove", "touchcancel"],

      /**
       * Creates a touch handler for the given element when a touch event listener
       * is attached to it
       *
       * @param element {Element} DOM element
       */
      register: function register(element) {
        if (!element.__touchHandler__P_201_0) {
          if (!element.$$emitter) {
            element.$$emitter = new qx.event.Emitter();
          }

          element.__touchHandler__P_201_0 = new qx.event.handler.TouchCore(element, element.$$emitter);
        }
      },

      /**
       * Removes the touch event handler from the element if there are no more
       * touch event listeners attached to it
       * @param element {Element} DOM element
       */
      unregister: function unregister(element) {
        if (element.__touchHandler__P_201_0) {
          if (!element.$$emitter) {
            element.__touchHandler__P_201_0 = null;
          } else {
            var hasTouchListener = false;
            var listeners = element.$$emitter.getListeners();
            qx.module.event.TouchHandler.TYPES.forEach(function (type) {
              if (type in listeners && listeners[type].length > 0) {
                hasTouchListener = true;
              }
            });

            if (!hasTouchListener) {
              element.__touchHandler__P_201_0 = null;
            }
          }
        }
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventHook(statics.TYPES, statics.register, statics.unregister);
    }
  });
  qx.module.event.TouchHandler.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Event": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Normalization for the track gesture. This gesture is based on <a href="#Pointer">Pointer events</a>,
   * meaning that it's available on all devices, no matter which input device type is used (e.g. mouse or
   * touchscreen).
   *
   * @require(qx.module.Event)
   *
   * @group (Event_Normalization)
   */
  qx.Bootstrap.define("qx.module.event.Track", {
    statics: {
      /**
       * List of event types to be normalized
       */
      TYPES: ["track"],
      BIND_METHODS: ["getDelta"],

      /**
       * Returns a map with the calculated delta coordinates and axis,
       * relative to the position on <code>trackstart</code> event.
       *
       * @return {Map} a map with contains the delta as <code>x</code> and
       * <code>y</code> and the movement axis as <code>axis</code>.
       */
      getDelta: function getDelta() {
        return this._original.delta;
      },

      /**
       * Manipulates the native event object, adding methods if they're not
       * already present
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element the listener was attached to
       * @return {Event} Normalized event object
       * @internal
       */
      normalize: function normalize(event, element) {
        if (!event) {
          return event;
        } // apply mouse event normalizations


        var bindMethods = qx.module.event.Track.BIND_METHODS;

        for (var i = 0, l = bindMethods.length; i < l; i++) {
          if (typeof event[bindMethods[i]] != "function") {
            event[bindMethods[i]] = qx.module.event.Track[bindMethods[i]].bind(event);
          }
        }

        return event;
      }
    },
    defer: function defer(statics) {
      qxWeb.$registerEventNormalization(qx.module.event.Track.TYPES, statics.normalize);
    }
  });
  qx.module.event.Track.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Array": {
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * Utility module to give some support to work with arrays.
   *
   * @group (Utilities)
   */
  qx.Bootstrap.define("qx.module.util.Array", {
    statics: {
      /**
       * Converts an array like object to any other array like
       * object.
       *
       * Attention: The returned array may be same
       * instance as the incoming one if the constructor is identical!
       *
       * @signature function(object, constructor, offset)
       * @attachStatic {qxWeb, array.cast}
       *
       * @param object {var} any array-like object
       * @param constructor {Function} constructor of the new instance
       * @param offset {Number?0} position to start from
       * @return {Array} the converted array
       */
      cast: qx.lang.Array.cast,

      /**
       * Check whether the two arrays have the same content. Checks only the
       * equality of the arrays' content.
       *
       * @signature function(arr1, arr2)
       * @attachStatic {qxWeb, array.equals}
       *
       * @param arr1 {Array} first array
       * @param arr2 {Array} second array
       * @return {Boolean} Whether the two arrays are equal
       */
      equals: qx.lang.Array.equals,

      /**
       * Modifies the first array as it removes all elements
       * which are listed in the second array as well.
       *
       * @signature function(arr1, arr2)
       * @attachStatic {qxWeb, array.exclude}
       *
       * @param arr1 {Array} the array
       * @param arr2 {Array} the elements of this array will be excluded from the other one
       * @return {Array} The modified array.
       */
      exclude: qx.lang.Array.exclude,

      /**
       * Convert an arguments object into an array.
       *
       * @signature function(args, offset)
       * @attachStatic {qxWeb, array.fromArguments}
       *
       * @param args {arguments} arguments object
       * @param offset {Number?0} position to start from
       * @return {Array} a newly created array (copy) with the content of the arguments object.
       */
      fromArguments: qx.lang.Array.fromArguments,

      /**
       * Insert an element into the array after a given second element.
       *
       * @signature function(arr, obj, obj2)
       * @attachStatic {qxWeb, array.insertAfter}
       *
       * @param arr {Array} the array
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 after this object
       * @return {Array} The given array.
       */
      insertAfter: qx.lang.Array.insertAfter,

      /**
       * Insert an element into the array before a given second element.
       *
       * @signature function(arr, obj, obj2)
       * @attachStatic {qxWeb, array.insertBefore}
       *
       * @param arr {Array} the array
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 before this object
       * @return {Array} The given array.
       */
      insertBefore: qx.lang.Array.insertBefore,

      /**
       * Returns the highest value in the given array. Supports
       * numeric values only.
       *
       * @signature function(arr)
       * @attachStatic {qxWeb, array.max}
       *
       * @param arr {Array} Array to process.
       * @return {Number | undefined} The highest of all values or undefined if array is empty.
       */
      max: qx.lang.Array.max,

      /**
       * Returns the lowest value in the given array. Supports
       * numeric values only.
       *
       * @signature function(arr)
       * @attachStatic {qxWeb, array.min}
       *
       * @param arr {Array} Array to process.
       * @return {Number | undefined} The lowest of all values or undefined if array is empty.
       */
      min: qx.lang.Array.min,

      /**
       * Remove an element from the array.
       *
       * @signature function(arr, obj)
       * @attachStatic {qxWeb, array.remove}
       *
       * @param arr {Array} the array
       * @param obj {var} element to be removed from the array
       * @return {var} the removed element
       */
      remove: qx.lang.Array.remove,

      /**
       * Remove all elements from the array
       *
       * @signature function(arr)
       * @attachStatic {qxWeb, array.removeAll}
       *
       * @param arr {Array} the array
       * @return {Array} empty array
       */
      removeAll: qx.lang.Array.removeAll,

      /**
       * Recreates an array which is free of all duplicate elements from the original.
       * This method do not modifies the original array!
       * Keep in mind that this methods deletes undefined indexes.
       *
       * @signature function(arr)
       * @attachStatic {qxWeb, array.unique}
       *
       * @param arr {Array} Incoming array
       * @return {Array} Returns a copy with no duplicates
       *   or the original array if no duplicates were found.
       */
      unique: qx.lang.Array.unique,

      /**
       * Returns a new array with integers from start to stop incremented or decremented by step.
       *
       * @signature function(start, stop, step)
       * @attachStatic {qxWeb, array.range}
       *
       * @param start {Integer} start of the new array, defaults to 0
       * @param stop {Integer} stop of the new array
       * @param step {Integer} increment / decrement - depends whether you use positive or negative values
       * @return {Array} Returns a new array with integers
       */
      range: qx.lang.Array.range
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "array");
    }
  });
  qx.module.util.Array.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.util.Function": {
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
       * Tobias Oberrauch (toberrauch)
  
  ************************************************************************ */

  /**
   * Utility module to give some support to work with functions.
   *
   * @group (Utilities)
   */
  qx.Bootstrap.define("qx.module.util.Function", {
    statics: {
      /**
       * Returns a debounced version of the given callback. The execution of the callback
       * is delayed by the given delay and after no events were triggered anymore.
       * This mechanism is very useful for event handling: only after a specified delay
       * the event should be handled (e.g. at keyboard input by the user) to prevent flooding
       * the handler with a large amounts of events.
       *
       * @attachStatic{qxWeb, func.debounce}
       * @signature function (callback, delay, immediate)
       * @param callback {Function} the callback which should be executed after the given delay
       * if the wrapper method is *not* called during this delay.
       * @param delay {Number} Delay in milliseconds
       * @param immediate {Boolean?} whether to run the callback at the beginning and then debounce, default is <code>false</code>
       * @return {Function} a wrapper function which <em>shields</em> the given callback function
       */
      debounce: qx.util.Function.debounce,

      /**
       * Returns a throttled version of the given callback. The execution of the callback
       * is throttled which means it is only executed in the given interval.
       * This mechanism is very useful for event handling: only in specified intervals
       * the event should be handled (e.g. at resize of the browser window) to prevent flooding
       * the handler with a large amounts of events.
       * As default the <code>leading</code> and <code>trailing</code> calls are executed.
       *
       * @attachStatic{qxWeb, func.throttle}
       * @signature function (callback, interval, options)
       * @param callback {Function} the callback which should be executed in the given interval
       * @param interval {Number} Interval in milliseconds
       * @param options {Map} the keys are <code>leading</code> and <code>trailing</code> to control the
       * executing of the callback precisely. Default values are <code>true</code> for both options.
       * @return {Function} a wrapper function which <em>shields</em> the given callback function
       */
      throttle: qx.util.Function.throttle
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "func");
    }
  });
  qx.module.util.Function.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.util.Array": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Object": {
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */

  /**
   * Helper functions to handle an Object as a Hash map.
   *
   * @group (Utilities)
   * @require (qx.module.util.Array)
   */
  qx.Bootstrap.define("qx.module.util.Object", {
    statics: {
      /**
       * Return a copy of an Object
       *
       * @signature function(source, deep)
       * @attachStatic {qxWeb, object.clone}
       *
       * @param source {Object} Object to copy
       * @param deep {Boolean} If the clone should be a deep clone.
       * @return {Object} A copy of the object
       */
      clone: qx.lang.Object.clone,

      /**
       * Get the values of a map as array
       *
       * @signature function(map)
       * @attachStatic {qxWeb, object.getValues}
       *
       * @param map {Object} the map
       * @return {Array} array of the values of the map
       */
      getValues: qx.lang.Object.getValues,

      /**
       * Inverts a map by exchanging the keys with the values.
       *
       * @signature function(map)
       * @attachStatic {qxWeb, object.invert}
       *
       * If the map has the same values for different keys, information will get lost.
       * The values will be converted to strings using the toString methods.
       *
       * @param map {Object} Map to invert
       * @return {Object} inverted Map
       */
      invert: qx.lang.Object.invert,

      /**
       * Whether the map contains the given value.
       *
       * @signature function(map, value)
       * @attachStatic {qxWeb, object.contains}
       *
       * @param map {Object} Map to search for the value
       * @param value {var} Value to look for
       * @return {Boolean} Whether the value was found in the map.
       */
      contains: qx.lang.Object.contains,

      /**
       * Merges one or more objects into the 'target' object.
       * *The objects are merged by overwriting existing keys.*
       *
       * @attachStatic {qxWeb, object.merge}
       *
       * @param target {Object} target object to merge into
       * @param varargs {var} As many items as you want to merge.
       * @return {Object} the merged object
       */
      merge: function merge(target, varargs) {
        var varargs = qxWeb.array.fromArguments(arguments);
        var target = varargs.shift();
        varargs.forEach(function (sourceObject) {
          target = qx.Bootstrap.objectMergeWith(target, sourceObject);
        });
        return target;
      }
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "object");
    }
  });
  qx.module.util.Object.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.String": {
        "require": true
      },
      "qx.bom.String": {
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * Utility module to give some support to work with strings.
   *
   * *Info:* The <pre class='javascript'>trim</pre> method is available as <a href="#String">Polyfill</a>.
   *
   * @group (Utilities)
   */
  qx.Bootstrap.define("qx.module.util.String", {
    statics: {
      /**
       * Converts a hyphenated string (separated by '-') to camel case.
       *
       * @attachStatic {qxWeb, string.camelCase}
       * @param str {String} hyphenated string
       * @return {String} camelcase string
       */
      camelCase: function camelCase(str) {
        return qx.lang.String.camelCase.call(qx.lang.String, str);
      },

      /**
       * Converts a camelcased string to a hyphenated (separated by '-') string.
       *
       * @attachStatic {qxWeb, string.hyphenate}
       * @param str {String} camelcased string
       * @return {String} hyphenated string
       */
      hyphenate: function hyphenate(str) {
        return qx.lang.String.hyphenate.call(qx.lang.String, str);
      },

      /**
       * Convert the first character of the string to upper case.
       *
       * @attachStatic {qxWeb, string.firstUp}
       * @signature function(str)
       * @param str {String} the string
       * @return {String} the string with an upper case first character
       */
      firstUp: qx.lang.String.firstUp,

      /**
       * Convert the first character of the string to lower case.
       *
       * @attachStatic {qxWeb, string.firstLow}
       * @signature function(str)
       * @param str {String} the string
       * @return {String} the string with a lower case first character
       */
      firstLow: qx.lang.String.firstLow,

      /**
       * Check whether the string starts with the given substring.
       *
       * @attachStatic {qxWeb, string.startsWith}
       * @signature function(fullstr, substr)
       * @param fullstr {String} the string to search in
       * @param substr {String} the substring to look for
       * @return {Boolean} whether the string starts with the given substring
       */
      startsWith: function startsWith(fullstr, substr) {
        return fullstr.startsWith(substr);
      },

      /**
       * Check whether the string ends with the given substring.
       *
       * @attachStatic {qxWeb, string.endsWith}
       * @signature function(fullstr, substr)
       * @param fullstr {String} the string to search in
       * @param substr {String} the substring to look for
       * @return {Boolean} whether the string ends with the given substring
       */
      endsWith: function endsWith(fullstr, substr) {
        return fullstr.endsWith(substr);
      },

      /**
       * Escapes all chars that have a special meaning in regular expressions.
       *
       * @attachStatic {qxWeb, string.escapeRegexpChars}
       * @signature function(str)
       * @param str {String} the string where to escape the chars.
       * @return {String} the string with the escaped chars.
       */
      escapeRegexpChars: qx.lang.String.escapeRegexpChars,

      /**
       * Escapes the characters in a <code>String</code> using HTML entities.
       * Supports all known HTML 4.0 entities, including funky accents.
       *
       * @attachStatic {qxWeb, string.escapeHtml}
       * @signature function(str)
       * @param str {String} the String to escape
       * @return {String} a new escaped String
       */
      escapeHtml: qx.bom.String.escape
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "string");
    }
  });
  qx.module.util.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * Utility for checking the type of a variable.
   * It adds a <code>type</code> key static to q and offers the given method.
   *
   * @group (Utilities)
   */
  qx.Bootstrap.define("qx.module.util.Type", {
    statics: {
      /**
       * Get the internal class of the value. The following classes are possible:
       * <pre>
       * <code>"String"</code>,
       * <code>"Array"</code>,
       * <code>"Object"</code>,
       * <code>"RegExp"</code>,
       * <code>"Number"</code>,
       * <code>"Boolean"</code>,
       * <code>"Date"</code>,
       * <code>"Function"</code>,
       * <code>"Error"</code>
       * </pre>
       * @attachStatic {qxWeb, type.get}
       * @signature function(value)
       * @param value {var} Value to get the class for.
       * @return {String} The internal class of the value.
       */
      get: qx.Bootstrap.getClass
    },
    defer: function defer(statics) {
      qxWeb.$attachAll(this, "type");
    }
  });
  qx.module.util.Type.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Css": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "css.rgba": {
          "load": true,
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Windows classic color theme
   */
  qx.Theme.define("qx.theme.classic.Color", {
    colors: {
      "background": "#EBE9ED",
      "background-light": "#F3F0F5",
      "light-background": "#EBE9ED",
      // compatibility
      "background-focused": "#F3F8FD",
      "background-focused-inner": "#DBEAF9",
      "background-disabled": "#F4F4F4",
      "background-selected": "#3E6CA8",
      "background-field": "white",
      "background-pane": "#FAFBFE",
      "background-invalid": "#FFE0E0",
      "border-lead": "#888888",
      "border-light": "white",
      "border-light-shadow": "#DCDFE4",
      "border-dark-shadow": "#A7A6AA",
      "border-dark": "#85878C",
      // alias for compatibility reasons
      "border-main": "#85878C",
      "border-focused-light": "#BCCEE5",
      "border-focused-light-shadow": "#A5BDDE",
      "border-focused-dark-shadow": "#7CA0CF",
      "border-focused-dark": "#3E6CA8",
      "border-separator": "#808080",
      // shadows
      "shadow": qx.core.Environment.get("css.rgba") ? "rgba(0, 0, 0, 0.4)" : "#666666",
      "invalid": "#990000",
      "border-focused-invalid": "#FF9999",
      "text": "black",
      "text-disabled": "#A7A6AA",
      "text-selected": "white",
      "text-focused": "#3E5B97",
      "text-placeholder": "#CBC8CD",
      "tooltip": "#FFFFE1",
      "tooltip-text": "black",
      "tooltip-invalid": "#C82C2C",
      "button": "#EBE9ED",
      "button-hovered": "#F6F5F7",
      "button-abandoned": "#F9F8E9",
      "button-checked": "#F3F0F5",
      "window-active-caption-text": [255, 255, 255],
      "window-inactive-caption-text": [255, 255, 255],
      "window-active-caption": [51, 94, 168],
      "window-inactive-caption": [111, 161, 217],
      "date-chooser": "white",
      "date-chooser-title": [116, 116, 116],
      "date-chooser-selected": [52, 52, 52],
      "effect": [254, 200, 60],
      "table-pane": "white",
      "table-header": [242, 242, 242],
      "table-header-border": [214, 213, 217],
      "table-header-cell": [235, 234, 219],
      "table-header-cell-hover": [255, 255, 255],
      "table-focus-indicator": [179, 217, 255],
      "table-row-background-focused-selected": [90, 138, 211],
      "table-row-background-focused": [221, 238, 255],
      "table-row-background-selected": [51, 94, 168],
      "table-row-background-even": [250, 248, 243],
      "table-row-background-odd": [255, 255, 255],
      "table-row-selected": [255, 255, 255],
      "table-row": [0, 0, 0],
      "table-row-line": "#EEE",
      "table-column-line": "#EEE",
      "progressive-table-header": "#AAAAAA",
      "progressive-table-row-background-even": [250, 248, 243],
      "progressive-table-row-background-odd": [255, 255, 255],
      "progressive-progressbar-background": "gray",
      "progressive-progressbar-indicator-done": "#CCCCCC",
      "progressive-progressbar-indicator-undone": "white",
      "progressive-progressbar-percent-background": "gray",
      "progressive-progressbar-percent-text": "white"
    }
  });
  qx.theme.classic.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Til Schneider (til132)
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The classic qooxdoo decoration theme.
   */
  qx.Theme.define("qx.theme.classic.Decoration", {
    aliases: {
      decoration: "qx/decoration/Classic"
    },
    decorations: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "main": {
        style: {
          width: 1,
          color: "border-dark"
        }
      },
      "keyboard-focus": {
        style: {
          width: 1,
          color: "black",
          style: "dotted"
        }
      },

      /*
      ---------------------------------------------------------------------------
        THREE DIMENSIONAL
      ---------------------------------------------------------------------------
      */
      "inset": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-dark-shadow", "border-light", "border-light", "border-dark-shadow"],
          innerColor: ["border-dark", "border-light-shadow", "border-light-shadow", "border-dark"]
        }
      },
      "outset": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-light-shadow", "border-dark", "border-dark", "border-light-shadow"],
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"]
        }
      },
      "groove": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-dark-shadow", "border-light", "border-light", "border-dark-shadow"],
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"]
        }
      },
      "ridge": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"],
          innerColor: ["border-dark-shadow", "border-light", "border-light", "border-dark-shadow"]
        }
      },
      "inset-thin": {
        style: {
          width: 1,
          color: ["border-dark-shadow", "border-light", "border-light", "border-dark-shadow"]
        }
      },
      "outset-thin": {
        style: {
          width: 1,
          color: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"]
        }
      },
      "focused-inset": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-focused-dark-shadow", "border-focused-light", "border-focused-light", "border-focused-dark-shadow"],
          innerColor: ["border-focused-dark", "border-focused-light-shadow", "border-focused-light-shadow", "border-focused-dark"]
        }
      },
      "focused-outset": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-focused-light-shadow", "border-focused-dark", "border-focused-dark", "border-focused-light-shadow"],
          innerColor: ["border-focused-light", "border-focused-dark-shadow", "border-focused-dark-shadow", "border-focused-light"]
        }
      },
      "border-invalid": {
        style: {
          width: 1,
          innerWidth: 1,
          color: ["border-dark-shadow", "border-light", "border-light", "border-dark-shadow"],
          innerColor: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        SEPARATOR
      ---------------------------------------------------------------------------
      */
      "separator-horizontal": {
        style: {
          widthLeft: 1,
          colorLeft: "border-separator"
        }
      },
      "separator-vertical": {
        style: {
          widthTop: 1,
          colorTop: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        include: "outset",
        style: {
          shadowLength: 1,
          shadowBlurRadius: 2,
          shadowColor: "shadow"
        }
      },

      /*
      ---------------------------------------------------------------------------
        LIST ITEM
      ---------------------------------------------------------------------------
      */
      "lead-item": {
        style: {
          width: 1,
          style: "dotted",
          color: "border-lead"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOL TIP / POPUP
      ---------------------------------------------------------------------------
      */
      "tooltip": {
        style: {
          width: 1,
          color: "tooltip-text",
          shadowLength: 1,
          shadowBlurRadius: 5,
          shadowColor: "shadow"
        }
      },
      "tooltip-error": {
        style: {
          width: 1,
          color: "tooltip-text",
          shadowLength: 1,
          shadowBlurRadius: 5,
          shadowColor: "shadow"
        }
      },
      "popup": {
        include: "main",
        style: {
          shadowLength: 2,
          shadowBlurRadius: 2,
          shadowColor: "shadow"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar-separator": {
        style: {
          widthLeft: 1,
          colorLeft: "border-dark-shadow"
        }
      },
      "toolbar-part-handle": {
        style: {
          width: 1,
          style: "solid",
          colorTop: "white",
          colorLeft: "white",
          colorRight: "border-dark-shadow",
          colorBottom: "border-dark-shadow"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        include: "outset",
        style: {
          shadowLength: 1,
          shadowBlurRadius: 3,
          shadowColor: "shadow"
        }
      },
      "menu-separator": {
        style: {
          widthTop: 1,
          widthBottom: 1,
          colorTop: "border-dark",
          colorBottom: "border-light"
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser-date-pane": {
        style: {
          widthTop: 1,
          colorTop: "gray",
          style: "solid"
        }
      },
      "datechooser-weekday": {
        style: {
          widthBottom: 1,
          colorBottom: "gray",
          style: "solid"
        }
      },
      "datechooser-week": {
        style: {
          widthRight: 1,
          colorRight: "gray",
          style: "solid"
        }
      },
      "datechooser-week-header": {
        style: {
          widthBottom: 1,
          colorBottom: "gray",
          widthRight: 1,
          colorRight: "gray",
          style: "solid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TAB VIEW
      ---------------------------------------------------------------------------
      */
      "tabview-page-button-top": {
        style: {
          width: 1,
          color: ["border-light-shadow", "border-dark", "border-dark", "border-light-shadow"],
          innerWidth: 1,
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"],
          widthBottom: 0,
          innerWidthBottom: 0
        }
      },
      "tabview-page-button-bottom": {
        style: {
          width: 1,
          color: ["border-light-shadow", "border-dark", "border-dark", "border-light-shadow"],
          innerWidth: 1,
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"],
          widthTop: 0,
          innerWidthTop: 0
        }
      },
      "tabview-page-button-left": {
        style: {
          width: 1,
          color: ["border-light-shadow", "border-dark", "border-dark", "border-light-shadow"],
          innerWidth: 1,
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"],
          widthRight: 0,
          innerWidthRight: 0
        }
      },
      "tabview-page-button-right": {
        style: {
          width: 1,
          color: ["border-light-shadow", "border-dark", "border-dark", "border-light-shadow"],
          innerWidth: 1,
          innerColor: ["border-light", "border-dark-shadow", "border-dark-shadow", "border-light"],
          widthLeft: 0,
          innerWidthLeft: 0
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table-statusbar": {
        style: {
          widthTop: 1,
          colorTop: "border-dark-shadow",
          styleTop: "solid"
        }
      },
      "table-scroller-header": {
        style: {
          widthBottom: 1,
          colorBottom: "table-header-border",
          styleBottom: "solid"
        }
      },
      "table-scroller-focus-indicator": {
        style: {
          width: 2,
          color: "table-focus-indicator",
          style: "solid"
        }
      },
      "table-header-cell": {
        style: {
          widthRight: 1,
          colorRight: "table-header-border",
          styleRight: "solid"
        }
      },
      "table-header-cell-hovered": {
        style: {
          widthRight: 1,
          colorRight: "table-header-border",
          styleRight: "solid",
          widthBottom: 2,
          colorBottom: "effect",
          styleBottom: "solid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: {
          backgroundColor: "#FFF",
          width: 1,
          color: "border-separator"
        }
      }
    }
  });
  qx.theme.classic.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
  
  ************************************************************************* */

  /**
   * The classic qooxdoo font theme.
   */
  qx.Theme.define("qx.theme.classic.Font", {
    fonts: {
      "default": {
        size: 11,
        lineHeight: 1.4,
        family: ["Lucida Grande", "Tahoma", "Verdana", "Bitstream Vera Sans", "Liberation Sans"]
      },
      "bold": {
        size: 11,
        lineHeight: 1.4,
        family: ["Lucida Grande", "Tahoma", "Verdana", "Bitstream Vera Sans", "Liberation Sans"],
        bold: true
      },
      "small": {
        size: 10,
        lineHeight: 1.4,
        family: ["Lucida Grande", "Tahoma", "Verdana", "Bitstream Vera Sans", "Liberation Sans"]
      },
      "monospace": {
        size: 11,
        lineHeight: 1.4,
        family: ["DejaVu Sans Mono", "Courier New", "monospace"]
      }
    }
  });
  qx.theme.classic.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Til Schneider (til132)
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The classic qooxdoo appearance theme.
   *
   * @asset(qx/icon/Oxygen/16/apps/office-calendar.png)
   * @asset(qx/icon/Oxygen/16/places/folder-open.png)
   * @asset(qx/icon/Oxygen/16/places/folder.png)
   * @asset(qx/icon/Oxygen/16/mimetypes/text-plain.png)
   * @asset(qx/icon/Oxygen/16/actions/view-refresh.png)
   * @asset(qx/icon/Oxygen/16/actions/window-close.png)
   * @asset(qx/icon/Oxygen/16/actions/dialog-cancel.png)
   * @asset(qx/icon/Oxygen/16/actions/dialog-ok.png)
   *
   * @asset(qx/decoration/Classic/*)
   */
  qx.Theme.define("qx.theme.classic.Appearance", {
    appearances: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "widget": {},
      "label": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "image": {
        style: function style(states) {
          return {
            opacity: !states.replacement && states.disabled ? 0.3 : undefined
          };
        }
      },
      "atom": {},
      "atom/label": "label",
      "atom/icon": "image",
      "root": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: "text",
            font: "default"
          };
        }
      },
      "popup": {
        style: function style(states) {
          return {
            decorator: "popup",
            backgroundColor: "background-pane"
          };
        }
      },
      "tooltip": {
        include: "popup",
        style: function style(states) {
          return {
            backgroundColor: "tooltip",
            textColor: "tooltip-text",
            decorator: "tooltip",
            padding: [1, 3, 2, 3],
            offset: [15, 5, 5, 5]
          };
        }
      },
      "tooltip/atom": "atom",
      "tooltip-error": {
        include: "tooltip",
        style: function style(states) {
          return {
            textColor: "text-selected",
            showTimeout: 100,
            hideTimeout: 10000,
            decorator: "tooltip-error",
            font: "bold",
            backgroundColor: "tooltip-invalid"
          };
        }
      },
      "tooltip-error/atom": "atom",
      "iframe": {
        style: function style(states) {
          return {
            backgroundColor: "white",
            decorator: "inset"
          };
        }
      },
      "move-frame": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },
      "resize-frame": "move-frame",
      "dragdrop-cursor": {
        style: function style(states) {
          var icon = "nodrop";

          if (states.copy) {
            icon = "copy";
          } else if (states.move) {
            icon = "move";
          } else if (states.alias) {
            icon = "alias";
          }

          return {
            source: "decoration/cursors/" + icon + ".gif",
            position: "right-top",
            offset: [2, 16, 2, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button-frame": {
        alias: "atom",
        style: function style(states) {
          if (states.pressed || states.abandoned || states.checked) {
            var decorator = !states.inner && states.focused ? "focused-inset" : "inset";
            var padding = [4, 3, 2, 5];
          } else {
            var decorator = !states.inner && states.focused ? "focused-outset" : "outset";
            var padding = [3, 4];
          }

          return {
            backgroundColor: states.abandoned ? "button-abandoned" : states.hovered ? "button-hovered" : states.checked ? "button-checked" : "button",
            decorator: decorator,
            padding: padding
          };
        }
      },
      "button": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          return {
            center: true
          };
        }
      },
      "toggle-button": "button",
      "hover-button": {
        alias: "atom",
        include: "atom",
        style: function style(states) {
          return {
            backgroundColor: states.hovered ? "background-selected" : undefined,
            textColor: states.hovered ? "text-selected" : undefined
          };
        }
      },
      "menubutton": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.gif",
            iconPosition: "right"
          };
        }
      },
      "splitbutton": {},
      "splitbutton/button": "button",
      "splitbutton/arrow": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLLAREA
      ---------------------------------------------------------------------------
      */
      "scrollarea/corner": {
        style: function style() {
          return {
            backgroundColor: "background"
          };
        }
      },
      "scrollarea": "widget",
      "scrollarea/pane": "widget",
      "scrollarea/scrollbar-x": "scrollbar",
      "scrollarea/scrollbar-y": "scrollbar",

      /*
      ---------------------------------------------------------------------------
        LIST
      ---------------------------------------------------------------------------
      */
      "list": {
        alias: "scrollarea",
        style: function style(states) {
          var backgroundColor;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (invalid && !disabled) {
            backgroundColor = "background-invalid";
          } else if (focused && !invalid && !disabled) {
            backgroundColor = "background-focused";
          } else if (disabled) {
            backgroundColor = "background-disabled";
          } else {
            backgroundColor = "white";
          }

          return {
            decorator: states.focused ? "focused-inset" : "inset",
            backgroundColor: backgroundColor
          };
        }
      },
      "listitem": {
        alias: "atom",
        style: function style(states) {
          return {
            gap: 4,
            padding: states.lead ? [2, 4] : [3, 5],
            backgroundColor: states.selected ? "background-selected" : undefined,
            textColor: states.selected ? "text-selected" : undefined,
            decorator: states.lead ? "lead-item" : undefined,
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        FORM FIELDS
      ---------------------------------------------------------------------------
      */
      "form-renderer-label": {
        include: "label",
        style: function style() {
          return {
            paddingTop: 4
          };
        }
      },
      "textfield": {
        style: function style(states) {
          var backgroundColor;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (invalid && !disabled) {
            backgroundColor = "background-invalid";
          } else if (focused && !invalid && !disabled) {
            backgroundColor = "background-focused";
          } else if (disabled) {
            backgroundColor = "background-disabled";
          } else {
            backgroundColor = "background-field";
          }

          var textColor;

          if (states.disabled) {
            textColor = "text-disabled";
          } else if (states.showingPlaceholder) {
            textColor = "text-placeholder";
          } else {
            textColor = undefined;
          }

          return {
            decorator: states.focused ? "focused-inset" : "inset",
            padding: [2, 3],
            textColor: textColor,
            backgroundColor: backgroundColor
          };
        }
      },
      "textarea": "textfield",
      "checkbox": {
        alias: "atom",
        style: function style(states) {
          // The "disabled" icon is set to an icon **without** the -disabled
          // suffix on purpose. This is because the Image widget handles this
          // already by replacing the current image with a disabled version
          // (if available). If no disabled image is found, the opacity style
          // is used.
          var icon; // Checked

          if (states.checked) {
            if (states.disabled) {
              icon = "checkbox-checked";
            } else if (states.focused) {
              icon = "checkbox-checked-focused";
            } else if (states.pressed) {
              icon = "checkbox-checked-pressed";
            } else if (states.hovered) {
              icon = "checkbox-checked-hovered";
            } else {
              icon = "checkbox-checked";
            } // Undetermined

          } else if (states.undetermined) {
            if (states.disabled) {
              icon = "checkbox-undetermined";
            } else if (states.focused) {
              icon = "checkbox-undetermined-focused";
            } else if (states.hovered) {
              icon = "checkbox-undetermined-hovered";
            } else {
              icon = "checkbox-undetermined";
            } // Focused & Pressed & Hovered (when enabled)

          } else if (!states.disabled) {
            if (states.focused) {
              icon = "checkbox-focused";
            } else if (states.pressed) {
              icon = "checkbox-pressed";
            } else if (states.hovered) {
              icon = "checkbox-hovered";
            }
          } // Unchecked


          icon = icon || "checkbox";
          var invalid = states.invalid && !states.disabled ? "-invalid" : "";
          return {
            icon: "decoration/form/" + icon + invalid + ".png",
            gap: 6
          };
        }
      },
      "radiobutton": {
        alias: "checkbox",
        include: "checkbox",
        style: function style(states) {
          // "disabled" state is not handled here with purpose. The image widget
          // does handle this already by replacing the current image with a
          // disabled version (if available). If no disabled image is found the
          // opacity style is used.
          var icon;

          if (states.checked && states.focused) {
            icon = "radiobutton-checked-focused";
          } else if (states.checked && states.disabled) {
            icon = "radiobutton-checked-disabled";
          } else if (states.checked && states.pressed) {
            icon = "radiobutton-checked-pressed";
          } else if (states.checked && states.hovered) {
            icon = "radiobutton-checked-hovered";
          } else if (states.checked) {
            icon = "radiobutton-checked";
          } else if (states.focused) {
            icon = "radiobutton-focused";
          } else if (states.pressed) {
            icon = "radiobutton-pressed";
          } else if (states.hovered) {
            icon = "radiobutton-hovered";
          } else {
            icon = "radiobutton";
          }

          var invalid = states.invalid && !states.disabled ? "-invalid" : "";
          return {
            icon: "decoration/form/" + icon + invalid + ".png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPINNER
      ---------------------------------------------------------------------------
      */
      "spinner": {
        style: function style(states) {
          return {
            decorator: states.focused ? "focused-inset" : "inset",
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "spinner/textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 3]
          };
        }
      },
      "spinner/upbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/up-small.gif",
            padding: states.pressed ? [2, 2, 0, 4] : [1, 3, 1, 3],
            backgroundColor: states.hovered ? "button-hovered" : "button"
          };
        }
      },
      "spinner/downbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down-small.gif",
            padding: states.pressed ? [2, 2, 0, 4] : [1, 3, 1, 3],
            backgroundColor: states.hovered ? "button-hovered" : "button"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATEFIELD
      ---------------------------------------------------------------------------
      */
      "datefield": "combobox",
      "datefield/button": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          return {
            icon: "icon/16/apps/office-calendar.png",
            padding: [0, 3],
            backgroundColor: undefined,
            decorator: undefined
          };
        }
      },
      "datefield/list": {
        alias: "datechooser",
        include: "datechooser",
        style: function style(states) {
          return {
            decorator: states.focused ? "focused-inset" : "inset"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "groupbox": {
        style: function style(states) {
          return {
            backgroundColor: "background"
          };
        }
      },
      "groupbox/legend": {
        alias: "atom",
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: states.invalid ? "invalid" : undefined,
            padding: [1, 0, 1, 4]
          };
        }
      },
      "groupbox/frame": {
        style: function style(states) {
          return {
            padding: [12, 9],
            marginTop: 10,
            decorator: "groove"
          };
        }
      },
      "check-groupbox": "groupbox",
      "check-groupbox/legend": {
        alias: "checkbox",
        include: "checkbox",
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: states.invalid ? "invalid" : undefined,
            padding: [1, 0, 1, 4]
          };
        }
      },
      "radio-groupbox": "groupbox",
      "radio-groupbox/legend": {
        alias: "radiobutton",
        include: "radiobutton",
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: states.invalid ? "invalid" : undefined,
            padding: [1, 0, 1, 4]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar": {
        style: function style(states) {
          return {
            backgroundColor: "background"
          };
        }
      },
      "toolbar/part": {},
      "toolbar/part/container": {},
      "toolbar/part/handle": {
        style: function style(states) {
          return {
            decorator: "toolbar-part-handle",
            backgroundColor: "background",
            padding: [0, 1],
            margin: [3, 2],
            allowGrowY: true
          };
        }
      },
      "toolbar-separator": {
        style: function style(states) {
          return {
            margin: [3, 2],
            decorator: "toolbar-separator"
          };
        }
      },
      "toolbar-button": {
        alias: "atom",
        style: function style(states) {
          if (states.pressed || states.checked || states.abandoned) {
            var border = "inset-thin";
            var padding = [3, 2, 1, 4];
          } else if (states.hovered && !states.disabled) {
            var border = "outset-thin";
            var padding = [2, 3];
          } else {
            var border = undefined;
            var padding = [3, 4];
          }

          return {
            cursor: "default",
            decorator: border,
            padding: padding,
            backgroundColor: states.abandoned ? "button-abandoned" : states.checked ? "background-light" : "button"
          };
        }
      },
      "toolbar-menubutton": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          return {
            showArrow: true
          };
        }
      },
      "toolbar-menubutton/arrow": {
        alias: "image",
        include: "image",
        style: function style(states) {
          return {
            source: "decoration/arrows/down-small.gif"
          };
        }
      },
      "toolbar-splitbutton": {},
      "toolbar-splitbutton/button": "toolbar-button",
      "toolbar-splitbutton/arrow": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDEBAR
      ---------------------------------------------------------------------------
      */
      "slidebar": {},
      "slidebar/scrollpane": {},
      "slidebar/content": {},
      "slidebar/button-forward": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: states.vertical ? "decoration/arrows/down.gif" : "decoration/arrows/next.gif"
          };
        }
      },
      "slidebar/button-backward": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: states.vertical ? "decoration/arrows/up.gif" : "decoration/arrows/left.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview": {},
      "tabview/bar": {
        alias: "slidebar",
        style: function style(states) {
          var marginTop = 0,
              marginRight = 0,
              marginBottom = 0,
              marginLeft = 0;

          if (states.barTop) {
            marginBottom = -2;
          } else if (states.barBottom) {
            marginTop = -2;
          } else if (states.barRight) {
            marginLeft = -2;
          } else {
            marginRight = -2;
          }

          return {
            marginBottom: marginBottom,
            marginTop: marginTop,
            marginLeft: marginLeft,
            marginRight: marginRight
          };
        }
      },
      "tabview/bar/button-forward": {
        include: "slidebar/button-forward",
        alias: "slidebar/button-forward",
        style: function style(states) {
          if (states.barTop || states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 2
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 2
            };
          }
        }
      },
      "tabview/bar/button-backward": {
        include: "slidebar/button-backward",
        alias: "slidebar/button-backward",
        style: function style(states) {
          if (states.barTop || states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 2
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 2
            };
          }
        }
      },
      "tabview/pane": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            decorator: "outset",
            padding: 10
          };
        }
      },
      "tabview-page": "widget",
      "tabview-page/button": {
        style: function style(states) {
          var decorator;
          var marginTop = 0,
              marginRight = 0,
              marginBottom = 0,
              marginLeft = 0;

          if (states.barTop || states.barBottom) {
            var paddingTop = 2,
                paddingBottom = 2,
                paddingLeft = 6,
                paddingRight = 6;
          } else {
            var paddingTop = 6,
                paddingBottom = 6,
                paddingLeft = 6,
                paddingRight = 6;
          }

          if (states.barTop) {
            decorator = "tabview-page-button-top";
          } else if (states.barRight) {
            decorator = "tabview-page-button-right";
          } else if (states.barBottom) {
            decorator = "tabview-page-button-bottom";
          } else {
            decorator = "tabview-page-button-left";
          }

          if (states.checked) {
            if (states.barTop || states.barBottom) {
              paddingLeft += 2;
              paddingRight += 2;
            } else {
              paddingTop += 2;
              paddingBottom += 2;
            }
          } else {
            if (states.barTop || states.barBottom) {
              marginBottom += 2;
              marginTop += 2;
            } else if (states.barLeft || states.barRight) {
              marginRight += 2;
              marginLeft += 2;
            }
          }

          if (states.checked) {
            if (!states.firstTab) {
              if (states.barTop || states.barBottom) {
                marginLeft = -4;
              } else {
                marginTop = -4;
              }
            }

            if (!states.lastTab) {
              if (states.barTop || states.barBottom) {
                marginRight = -4;
              } else {
                marginBottom = -4;
              }
            }
          }

          return {
            zIndex: states.checked ? 10 : 5,
            decorator: decorator,
            backgroundColor: "background",
            padding: [paddingTop, paddingRight, paddingBottom, paddingLeft],
            margin: [marginTop, marginRight, marginBottom, marginLeft],
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "tabview-page/button/label": {
        alias: "label",
        style: function style(states) {
          return {
            padding: states.focused ? [0, 1, 0, 1] : [1, 2, 1, 2],
            decorator: states.focused ? "keyboard-focus" : undefined
          };
        }
      },
      "tabview-page/button/icon": "image",
      "tabview-page/button/close-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: "qx/icon/Oxygen/16/actions/window-close.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar": {},
      "scrollbar/slider": {
        alias: "slider",
        style: function style(states) {
          return {
            backgroundColor: "background-light"
          };
        }
      },
      "scrollbar/slider/knob": {
        include: "button-frame",
        style: function style(states) {
          return {
            height: 14,
            width: 14,
            minHeight: states.horizontal ? undefined : 9,
            minWidth: states.horizontal ? 9 : undefined
          };
        }
      },
      "scrollbar/button": {
        alias: "button",
        include: "button",
        style: function style(states) {
          var padding;

          if (states.up || states.down) {
            if (states.pressed || states.abandoned || states.checked) {
              padding = [5, 2, 3, 4];
            } else {
              padding = [4, 3];
            }
          } else {
            if (states.pressed || states.abandoned || states.checked) {
              padding = [4, 3, 2, 5];
            } else {
              padding = [3, 4];
            }
          }

          var icon = "decoration/arrows/";

          if (states.left) {
            icon += "left.gif";
          } else if (states.right) {
            icon += "right.gif";
          } else if (states.up) {
            icon += "up.gif";
          } else {
            icon += "down.gif";
          }

          return {
            padding: padding,
            icon: icon
          };
        }
      },
      "scrollbar/button-begin": "scrollbar/button",
      "scrollbar/button-end": "scrollbar/button",

      /*
      ---------------------------------------------------------------------------
        SLIDER
      ---------------------------------------------------------------------------
      */
      "slider": {
        style: function style(states) {
          var backgroundColor;

          if (states.disabled) {
            backgroundColor = "background-disabled";
          } else if (states.invalid) {
            backgroundColor = "background-invalid";
          } else if (states.focused) {
            backgroundColor = "background-light";
          } else {
            backgroundColor = "background-field";
          }

          return {
            backgroundColor: backgroundColor,
            decorator: states.focused ? "focused-inset" : "inset"
          };
        }
      },
      "slider/knob": {
        include: "button-frame",
        style: function style(states) {
          return {
            width: 14,
            height: 14,
            decorator: "outset"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREE
      ---------------------------------------------------------------------------
      */
      "tree-folder/open": {
        style: function style(states) {
          return {
            source: states.opened ? "decoration/tree/minus.gif" : "decoration/tree/plus.gif"
          };
        }
      },
      "tree-folder": {
        style: function style(states) {
          return {
            padding: [2, 3, 2, 0],
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png",
            iconOpened: "icon/16/places/folder-open.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree-folder/icon": {
        style: function style(states) {
          return {
            padding: [0, 4, 0, 0]
          };
        }
      },
      "tree-folder/label": {
        style: function style(states) {
          return {
            padding: [1, 2],
            backgroundColor: states.selected ? "background-selected" : undefined,
            textColor: states.selected ? "text-selected" : undefined
          };
        }
      },
      "tree-file": {
        include: "tree-folder",
        alias: "tree-folder",
        style: function style(states) {
          return {
            icon: "icon/16/mimetypes/text-plain.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree": {
        include: "list",
        alias: "list",
        style: function style(states) {
          return {
            contentPadding: [4, 4, 4, 4]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREEVIRTUAL
      ---------------------------------------------------------------------------
      */
      "treevirtual": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },
      "treevirtual-folder": {
        style: function style(states) {
          return {
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-file": {
        include: "treevirtual-folder",
        alias: "treevirtual-folder",
        style: function style(states) {
          return {
            icon: "icon/16/mimetypes/text-plain.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-line": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/line.gif"
          };
        }
      },
      "treevirtual-contract": {
        style: function style(states) {
          return {
            icon: "decoration/tree/minus.gif"
          };
        }
      },
      "treevirtual-expand": {
        style: function style(states) {
          return {
            icon: "decoration/tree/plus.gif"
          };
        }
      },
      "treevirtual-only-contract": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/only_minus.gif"
          };
        }
      },
      "treevirtual-only-expand": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/only_plus.gif"
          };
        }
      },
      "treevirtual-start-contract": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/start_minus.gif"
          };
        }
      },
      "treevirtual-start-expand": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/start_plus.gif"
          };
        }
      },
      "treevirtual-end-contract": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/end_minus.gif"
          };
        }
      },
      "treevirtual-end-expand": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/end_plus.gif"
          };
        }
      },
      "treevirtual-cross-contract": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/cross_minus.gif"
          };
        }
      },
      "treevirtual-cross-expand": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/cross_plus.gif"
          };
        }
      },
      "treevirtual-end": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/end.gif"
          };
        }
      },
      "treevirtual-cross": {
        style: function style(states) {
          return {
            icon: "decoration/treevirtual/cross.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: function style(states) {
          return {
            contentPadding: [10, 10, 10, 10],
            backgroundColor: "background",
            decorator: states.maximized ? undefined : "window"
          };
        }
      },
      "window-resize-frame": "resize-frame",
      "window/pane": {},
      "window/captionbar": {
        style: function style(states) {
          return {
            padding: 1,
            backgroundColor: states.active ? "window-active-caption" : "window-inactive-caption",
            textColor: states.active ? "window-active-caption-text" : "window-inactive-caption-text"
          };
        }
      },
      "window/icon": {
        style: function style(states) {
          return {
            marginRight: 4
          };
        }
      },
      "window/title": {
        style: function style(states) {
          return {
            cursor: "default",
            font: "bold",
            marginRight: 20,
            alignY: "middle"
          };
        }
      },
      "window/minimize-button": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: "decoration/window/minimize.gif",
            padding: states.pressed || states.abandoned ? [2, 1, 0, 3] : [1, 2]
          };
        }
      },
      "window/restore-button": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: "decoration/window/restore.gif",
            padding: states.pressed || states.abandoned ? [2, 1, 0, 3] : [1, 2]
          };
        }
      },
      "window/maximize-button": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: "decoration/window/maximize.gif",
            padding: states.pressed || states.abandoned ? [2, 1, 0, 3] : [1, 2]
          };
        }
      },
      "window/close-button": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            marginLeft: 2,
            icon: "decoration/window/close.gif",
            padding: states.pressed || states.abandoned ? [2, 1, 0, 3] : [1, 2]
          };
        }
      },
      "window/statusbar": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            padding: [2, 6]
          };
        }
      },
      "window/statusbar-text": "label",

      /*
      ---------------------------------------------------------------------------
        RESIZER
      ---------------------------------------------------------------------------
      */
      "resizer": {
        style: function style(states) {
          return {
            decorator: "outset"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane": {},
      "splitpane/splitter": {
        style: function style(states) {
          return {
            backgroundColor: "background"
          };
        }
      },
      "splitpane/splitter/knob": {
        style: function style(states) {
          return {
            source: states.horizontal ? "decoration/splitpane/knob-horizontal.png" : "decoration/splitpane/knob-vertical.png",
            padding: 2
          };
        }
      },
      "splitpane/slider": {
        style: function style(states) {
          return {
            backgroundColor: "border-dark",
            opacity: 0.3
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTBOX
      ---------------------------------------------------------------------------
      */
      "selectbox": {
        include: "button-frame",
        style: function style(states) {
          var background = "button";

          if (states.invalid && !states.disabled) {
            background = "background-invalid";
          } else if (states.abandoned) {
            background = "button-abandoned";
          } else if (!states.abandoned && states.hovered) {
            background = "button-hovered";
          } else if (!states.abandoned && !states.hovered && states.checked) {
            background = "button-checked";
          }

          return {
            backgroundColor: background
          };
        }
      },
      "selectbox/atom": "atom",
      "selectbox/popup": "popup",
      "selectbox/list": "list",
      "selectbox/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: "decoration/arrows/down.gif",
            paddingRight: 4,
            paddingLeft: 5
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser": {
        style: function style(states) {
          return {
            decorator: "outset"
          };
        }
      },
      "datechooser/navigation-bar": {
        style: function style(states) {
          return {
            backgroundColor: "date-chooser",
            textColor: states.disabled ? "text-disabled" : states.invalid ? "invalid" : undefined,
            padding: [2, 10]
          };
        }
      },
      "datechooser/last-year-button-tooltip": "tooltip",
      "datechooser/last-month-button-tooltip": "tooltip",
      "datechooser/next-year-button-tooltip": "tooltip",
      "datechooser/next-month-button-tooltip": "tooltip",
      "datechooser/last-year-button": "datechooser/button",
      "datechooser/last-month-button": "datechooser/button",
      "datechooser/next-year-button": "datechooser/button",
      "datechooser/next-month-button": "datechooser/button",
      "datechooser/button/icon": {},
      "datechooser/button": {
        style: function style(states) {
          var result = {
            width: 17,
            show: "icon"
          };

          if (states.lastYear) {
            result.icon = "decoration/arrows/rewind.gif";
          } else if (states.lastMonth) {
            result.icon = "decoration/arrows/left.gif";
          } else if (states.nextYear) {
            result.icon = "decoration/arrows/forward.gif";
          } else if (states.nextMonth) {
            result.icon = "decoration/arrows/right.gif";
          }

          if (states.pressed || states.checked || states.abandoned) {
            result.decorator = "inset-thin";
          } else if (states.hovered) {
            result.decorator = "outset-thin";
          } else {
            result.decorator = undefined;
          }

          if (states.pressed || states.checked || states.abandoned) {
            result.padding = [2, 0, 0, 2];
          } else if (states.hovered) {
            result.padding = 1;
          } else {
            result.padding = 2;
          }

          return result;
        }
      },
      "datechooser/month-year-label": {
        style: function style(states) {
          return {
            font: "bold",
            textAlign: "center"
          };
        }
      },
      "datechooser/date-pane": {
        style: function style(states) {
          return {
            decorator: "datechooser-date-pane",
            backgroundColor: "date-chooser"
          };
        }
      },
      "datechooser/weekday": {
        style: function style(states) {
          return {
            decorator: "datechooser-weekday",
            font: "bold",
            textAlign: "center",
            textColor: states.disabled ? "text-disabled" : states.weekend ? "date-chooser-title" : "date-chooser",
            backgroundColor: states.weekend ? "date-chooser" : "date-chooser-title"
          };
        }
      },
      "datechooser/day": {
        style: function style(states) {
          return {
            textAlign: "center",
            decorator: states.today ? "main" : undefined,
            textColor: states.disabled ? "text-disabled" : states.selected ? "text-selected" : states.otherMonth ? "text-disabled" : undefined,
            backgroundColor: states.disabled ? undefined : states.selected ? "date-chooser-selected" : undefined,
            padding: [2, 4]
          };
        }
      },
      "datechooser/week": {
        style: function style(states) {
          return {
            textAlign: "center",
            textColor: "date-chooser-title",
            padding: [2, 4],
            decorator: states.header ? "datechooser-week-header" : "datechooser-week"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COMBOBOX
      ---------------------------------------------------------------------------
      */
      "combobox": {
        style: function style(states) {
          var backgroundColor;

          if (states.disabled) {
            backgroundColor = "background-disabled";
          } else if (states.invalid) {
            backgroundColor = "background-invalid";
          } else if (states.focused) {
            backgroundColor = "background-focused";
          } else {
            backgroundColor = "background-field";
          }

          return {
            decorator: states.focused ? "focused-inset" : "inset",
            textColor: states.disabled ? "text-disabled" : undefined,
            backgroundColor: backgroundColor
          };
        }
      },
      "combobox/button": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.gif",
            backgroundColor: states.hovered ? "button-hovered" : "button"
          };
        }
      },
      "combobox/popup": "popup",
      "combobox/list": "list",
      "combobox/textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 3],
            backgroundColor: undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        style: function style(states) {
          var result = {
            backgroundColor: "background",
            decorator: "menu",
            spacingX: 6,
            spacingY: 1,
            iconColumnWidth: 16,
            arrowColumnWidth: 4,
            padding: 1,
            placementModeY: states.submenu || states.contextmenu ? "best-fit" : "keep-align"
          };

          if (states.submenu) {
            result.position = "right-top";
            result.offset = [-2, -3];
          }

          if (states.contextmenu) {
            result.offset = 4;
          }

          return result;
        }
      },
      "menu/slidebar": "menu-slidebar",
      "menu-slidebar": "widget",
      "menu-slidebar-button": {
        style: function style(states) {
          return {
            backgroundColor: states.hovered ? "background-selected" : undefined,
            padding: 6,
            center: true
          };
        }
      },
      "menu-slidebar/button-backward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: states.hovered ? "decoration/arrows/up-invert.gif" : "decoration/arrows/up.gif"
          };
        }
      },
      "menu-slidebar/button-forward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: states.hovered ? "decoration/arrows/down-invert.gif" : "decoration/arrows/down.gif"
          };
        }
      },
      "menu-separator": {
        style: function style(states) {
          return {
            height: 0,
            decorator: "menu-separator",
            marginTop: 4,
            marginBottom: 4,
            marginLeft: 2,
            marginRight: 2
          };
        }
      },
      "menu-button": {
        alias: "atom",
        style: function style(states) {
          return {
            backgroundColor: states.selected ? "background-selected" : undefined,
            textColor: states.selected ? "text-selected" : undefined,
            padding: [2, 6]
          };
        }
      },
      "menu-button/icon": {
        include: "image",
        style: function style(states) {
          return {
            alignY: "middle"
          };
        }
      },
      "menu-button/label": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            padding: 1
          };
        }
      },
      "menu-button/shortcut": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            marginLeft: 14,
            padding: 1
          };
        }
      },
      "menu-button/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: states.selected ? "decoration/arrows/right-invert.gif" : "decoration/arrows/right.gif",
            alignY: "middle"
          };
        }
      },
      "menu-checkbox": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : states.selected ? "decoration/menu/checkbox-invert.gif" : "decoration/menu/checkbox.gif"
          };
        }
      },
      "menu-radiobutton": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : states.selected ? "decoration/menu/radiobutton-invert.gif" : "decoration/menu/radiobutton.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            decorator: "outset"
          };
        }
      },
      "menubar-button": {
        alias: "atom",
        style: function style(states) {
          return {
            padding: [2, 6],
            backgroundColor: states.pressed || states.hovered && !states.disabled ? "background-selected" : undefined,
            textColor: states.pressed || states.hovered ? "text-selected" : undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR SELECTOR
      ---------------------------------------------------------------------------
      */
      "colorselector": "widget",
      "colorselector/control-bar": "widget",
      "colorselector/visual-pane": "groupbox",
      "colorselector/control-pane": "widget",
      "colorselector/preset-grid": "widget",
      "colorselector/colorbucket": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            width: 16,
            height: 16
          };
        }
      },
      "colorselector/preset-field-set": "groupbox",
      "colorselector/input-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/preview-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/hex-field-composite": "widget",
      "colorselector/hex-field": "textfield",
      "colorselector/rgb-spinner-composite": "widget",
      "colorselector/rgb-spinner-red": "spinner",
      "colorselector/rgb-spinner-green": "spinner",
      "colorselector/rgb-spinner-blue": "spinner",
      "colorselector/hsb-spinner-composite": "widget",
      "colorselector/hsb-spinner-hue": "spinner",
      "colorselector/hsb-spinner-saturation": "spinner",
      "colorselector/hsb-spinner-brightness": "spinner",
      "colorselector/preview-content-old": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            width: 50,
            height: 10
          };
        }
      },
      "colorselector/preview-content-new": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            backgroundColor: "white",
            width: 50,
            height: 10
          };
        }
      },
      "colorselector/hue-saturation-field": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            margin: 5
          };
        }
      },
      "colorselector/brightness-field": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            margin: [5, 7]
          };
        }
      },
      "colorselector/hue-saturation-pane": "widget",
      "colorselector/hue-saturation-handle": "widget",
      "colorselector/brightness-pane": "widget",
      "colorselector/brightness-handle": "widget",

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table": "widget",
      "table/statusbar": {
        style: function style(states) {
          return {
            decorator: "table-statusbar",
            paddingLeft: 2,
            paddingRight: 2
          };
        }
      },
      "table/column-button": {
        alias: "button",
        style: function style(states) {
          var border, padding;

          if (states.pressed || states.checked || states.abandoned) {
            border = "inset-thin";
            padding = [3, 2, 1, 4];
          } else if (states.hovered) {
            border = "outset-thin";
            padding = [2, 3];
          } else {
            border = undefined;
            padding = [3, 4];
          }

          return {
            decorator: border,
            padding: padding,
            backgroundColor: states.abandoned ? "button-abandoned" : "button",
            icon: "decoration/table/select-column-order.png"
          };
        }
      },
      "table-column-reset-button": {
        extend: "menu-button",
        alias: "menu-button",
        style: function style() {
          return {
            icon: "icon/16/actions/view-refresh.png"
          };
        }
      },
      "table-scroller/scrollbar-x": "scrollbar",
      "table-scroller/scrollbar-y": "scrollbar",
      "table-scroller": "widget",
      "table-scroller/header": {
        style: function style(states) {
          return {
            decorator: "table-scroller-header",
            backgroundColor: "table-header"
          };
        }
      },
      "table-scroller/pane": {
        style: function style(states) {
          return {
            backgroundColor: "table-pane"
          };
        }
      },
      "table-scroller/focus-indicator": {
        style: function style(states) {
          return {
            decorator: "table-scroller-focus-indicator"
          };
        }
      },
      "table-scroller/resize-line": {
        style: function style(states) {
          return {
            backgroundColor: "table-header-border",
            width: 3
          };
        }
      },
      "table-header-cell": {
        alias: "atom",
        style: function style(states) {
          return {
            minWidth: 13,
            paddingLeft: 2,
            paddingRight: 2,
            paddingBottom: states.hovered ? 0 : 2,
            decorator: states.hovered ? "table-header-cell-hovered" : "table-header-cell",
            backgroundColor: states.hovered ? "table-header-cell-hover" : "table-header-cell",
            sortIcon: states.sorted ? states.sortedAscending ? "decoration/table/ascending.png" : "decoration/table/descending.png" : undefined
          };
        }
      },
      "table-header-cell/icon": {
        style: function style(states) {
          return {
            marginRight: 4,
            opacity: states.disabled ? 0.3 : 1
          };
        }
      },
      "table-header-cell/sort-icon": {
        style: function style(states) {
          return {
            alignY: "middle",
            opacity: states.disabled ? 0.3 : 1
          };
        }
      },
      "table-editor-textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 2]
          };
        }
      },
      "table-editor-selectbox": {
        include: "selectbox",
        alias: "selectbox",
        style: function style(states) {
          return {
            padding: [0, 2]
          };
        }
      },
      "table-editor-combobox": {
        include: "combobox",
        alias: "combobox",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },
      "progressive-table-header": {
        alias: "table-scroller/header"
      },
      "progressive-table-header-cell": {
        style: function style(states) {
          return {
            decorator: "table-header-cell",
            backgroundColor: "table-header-cell",
            padding: [0, 6, 0, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR POPUP
      ---------------------------------------------------------------------------
      */
      "colorpopup": {
        alias: "popup",
        include: "popup",
        style: function style(states) {
          return {
            decorator: "outset",
            padding: 5,
            backgroundColor: "background"
          };
        }
      },
      "colorpopup/field": {
        style: function style(states) {
          return {
            decorator: "inset-thin",
            margin: 2,
            width: 14,
            height: 14,
            backgroundColor: "background"
          };
        }
      },
      "colorpopup/selector-button": "button",
      "colorpopup/auto-button": "button",
      "colorpopup/preview-pane": "groupbox",
      "colorpopup/current-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginLeft: 4,
            decorator: "inset-thin",
            allowGrowX: true
          };
        }
      },
      "colorpopup/selected-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginRight: 4,
            decorator: "inset-thin",
            allowGrowX: true
          };
        }
      },
      "colorpopup/colorselector-okbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-ok.png"
          };
        }
      },
      "colorpopup/colorselector-cancelbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-cancel.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "virtual-list": "list",
      "virtual-list/row-layer": "row-layer",
      "row-layer": "widget",
      "column-layer": "widget",
      "group-item": {
        include: "label",
        alias: "label",
        style: function style(states) {
          return {
            padding: 4,
            backgroundColor: "#BABABA",
            textColor: "white",
            font: "bold"
          };
        }
      },
      "virtual-selectbox": "selectbox",
      "virtual-selectbox/dropdown": "popup",
      "virtual-selectbox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-combobox": "combobox",
      "virtual-combobox/dropdown": "popup",
      "virtual-combobox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-tree": {
        include: "tree",
        alias: "tree",
        style: function style(states) {
          return {
            itemHeight: 21
          };
        }
      },
      "virtual-tree-folder": "tree-folder",
      "virtual-tree-file": "tree-file",
      "cell": {
        style: function style(states) {
          return {
            backgroundColor: states.selected ? "table-row-background-selected" : "table-row-background-even",
            textColor: states.selected ? "text-selected" : "text",
            padding: [3, 6]
          };
        }
      },
      "cell-string": "cell",
      "cell-number": {
        include: "cell",
        style: function style(states) {
          return {
            textAlign: "right"
          };
        }
      },
      "cell-image": "cell",
      "cell-boolean": "cell",
      "cell-atom": "cell",
      "cell-date": "cell",
      "cell-html": "cell",

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: function style(states) {
          return {
            decorator: "progressbar",
            padding: [1],
            backgroundColor: "white",
            width: 200,
            height: 20
          };
        }
      },
      "progressbar/progress": {
        style: function style(states) {
          return {
            backgroundColor: states.disabled ? "background-disabled" : "background-selected"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header": {
        style: function style(states) {
          return {
            textColor: "text-selected",
            backgroundColor: "background-selected",
            padding: [8, 12]
          };
        }
      },
      "app-header-label": "label",
      "app-splitpane": {
        alias: "splitpane",
        style: function style(states) {
          return {
            padding: [0, 10, 10, 10],
            backgroundColor: "light-background"
          };
        }
      }
    }
  });
  qx.theme.classic.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * KDE Oxygen icons
   */
  qx.Theme.define("qx.theme.icon.Oxygen", {
    title: "Oxygen",
    aliases: {
      "icon": "qx/icon/Oxygen"
    }
  });
  qx.theme.icon.Oxygen.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.classic.Color": {
        "require": true
      },
      "qx.theme.classic.Decoration": {
        "require": true
      },
      "qx.theme.classic.Font": {
        "require": true
      },
      "qx.theme.classic.Appearance": {
        "require": true
      },
      "qx.theme.icon.Oxygen": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * Classic Windows Theme
   */
  qx.Theme.define("qx.theme.Classic", {
    title: "Classic Windows",
    meta: {
      color: qx.theme.classic.Color,
      decoration: qx.theme.classic.Decoration,
      font: qx.theme.classic.Font,
      appearance: qx.theme.classic.Appearance,
      icon: qx.theme.icon.Oxygen
    }
  });
  qx.theme.Classic.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Css": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "css.rgba": {
          "load": true,
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Tristan Koch (trkoch)
  
  ************************************************************************ */

  /**
   * Indigo color theme
   */
  qx.Theme.define("qx.theme.indigo.Color", {
    colors: {
      // main
      "background": "white",
      "dark-blue": "#323335",
      "light-background": "#F4F4F4",
      "font": "#262626",
      "highlight": "#3D72C9",
      // bright blue
      "highlight-shade": "#5583D0",
      // bright blue
      // backgrounds
      "background-selected": "#3D72C9",
      "background-selected-disabled": "#CDCDCD",
      "background-selected-dark": "#323335",
      "background-disabled": "#F7F7F7",
      "background-disabled-checked": "#BBBBBB",
      "background-pane": "white",
      // tabview
      "tabview-unselected": "#1866B5",
      "tabview-button-border": "#134983",
      "tabview-label-active-disabled": "#D9D9D9",
      // text colors
      "link": "#24B",
      // scrollbar
      "scrollbar-bright": "#F1F1F1",
      "scrollbar-dark": "#EBEBEB",
      // form
      "button": "#E8F0E3",
      "button-border": "#BBB",
      "button-border-hovered": "#939393",
      "invalid": "#C00F00",
      "button-box-bright": "#F9F9F9",
      "button-box-dark": "#E3E3E3",
      "button-box-bright-pressed": "#BABABA",
      "button-box-dark-pressed": "#EBEBEB",
      "border-lead": "#888888",
      // window
      "window-border": "#dddddd",
      "window-border-inner": "#F4F4F4",
      // group box
      "white-box-border": "#dddddd",
      // shadows
      "shadow": qx.core.Environment.get("css.rgba") ? "rgba(0, 0, 0, 0.4)" : "#666666",
      // borders
      "border-main": "#dddddd",
      "border-light": "#B7B7B7",
      "border-light-shadow": "#686868",
      // separator
      "border-separator": "#808080",
      // text
      "text": "#262626",
      "text-disabled": "#A7A6AA",
      "text-selected": "white",
      "text-placeholder": "#CBC8CD",
      // tooltip
      "tooltip": "#FE0",
      "tooltip-text": "black",
      // table
      "table-header": [242, 242, 242],
      "table-focus-indicator": "#3D72C9",
      // used in table code
      "table-header-cell": [235, 234, 219],
      "table-row-background-focused-selected": "#3D72C9",
      "table-row-background-focused": "#F4F4F4",
      "table-row-background-selected": [51, 94, 168],
      "table-row-background-even": "white",
      "table-row-background-odd": "white",
      "table-row-selected": [255, 255, 255],
      "table-row": [0, 0, 0],
      "table-row-line": "#EEE",
      "table-column-line": "#EEE",
      // used in progressive code
      "progressive-table-header": "#AAAAAA",
      "progressive-table-row-background-even": [250, 248, 243],
      "progressive-table-row-background-odd": [255, 255, 255],
      "progressive-progressbar-background": "gray",
      "progressive-progressbar-indicator-done": "#CCCCCC",
      "progressive-progressbar-indicator-undone": "white",
      "progressive-progressbar-percent-background": "gray",
      "progressive-progressbar-percent-text": "white"
    }
  });
  qx.theme.indigo.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /**
   * The simple qooxdoo decoration theme.
   */
  qx.Theme.define("qx.theme.simple.Decoration", {
    aliases: {
      decoration: "qx/decoration/Simple"
    },
    decorations: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "border-blue": {
        style: {
          width: 4,
          color: "background-selected"
        }
      },
      "main": {
        style: {
          width: 1,
          color: "border-main"
        }
      },
      "main-dark": {
        style: {
          width: 1,
          color: "button-border"
        }
      },
      "popup": {
        style: {
          width: 1,
          color: "window-border",
          shadowLength: 2,
          shadowBlurRadius: 5,
          shadowColor: "shadow"
        }
      },
      "dragover": {
        style: {
          bottom: [2, "solid", "dark-blue"]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button-box": {
        style: {
          radius: 3,
          width: 1,
          color: "button-border",
          gradientStart: ["button-box-bright", 40],
          gradientEnd: ["button-box-dark", 70],
          backgroundColor: "button-box-bright"
        }
      },
      "button-box-pressed": {
        include: "button-box",
        style: {
          gradientStart: ["button-box-bright-pressed", 40],
          gradientEnd: ["button-box-dark-pressed", 70],
          backgroundColor: "button-box-bright-pressed"
        }
      },
      "button-box-pressed-hovered": {
        include: "button-box-pressed",
        style: {
          color: "button-border-hovered"
        }
      },
      "button-box-hovered": {
        include: "button-box",
        style: {
          color: "button-border-hovered"
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON INVALID
      ---------------------------------------------------------------------------
      */
      "button-box-invalid": {
        include: "button-box",
        style: {
          color: "invalid"
        }
      },
      "button-box-pressed-invalid": {
        include: "button-box-pressed",
        style: {
          color: "invalid"
        }
      },
      "button-box-hovered-invalid": {
        include: "button-box-invalid"
      },
      "button-box-pressed-hovered-invalid": {
        include: "button-box-pressed-invalid"
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON FOCUSED
      ---------------------------------------------------------------------------
      */
      "button-box-focused": {
        include: "button-box",
        style: {
          color: "background-selected"
        }
      },
      "button-box-pressed-focused": {
        include: "button-box-pressed",
        style: {
          color: "background-selected"
        }
      },
      "button-box-hovered-focused": {
        include: "button-box-focused"
      },
      "button-box-pressed-hovered-focused": {
        include: "button-box-pressed-focused"
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-right": {
        include: "button-box",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-hovered-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-hovered-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-focused-right": {
        include: "button-box-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-hovered-focused-right": {
        include: "button-box-hovered-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-focused-right": {
        include: "button-box-pressed-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-hovered-focused-right": {
        include: "button-box-pressed-hovered-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON BORDERLESS RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-right-borderless": {
        include: "button-box",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-right-borderless": {
        include: "button-box-pressed",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-right-borderless": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-hovered-right-borderless": {
        include: "button-box-hovered",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON TOP RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-top-right": {
        include: "button-box",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-top-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-top-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-hovered-top-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON BOTOM RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-bottom-right": {
        include: "button-box",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-bottom-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-bottom-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-hovered-bottom-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON BOTOM LEFT
      ---------------------------------------------------------------------------
      */
      "button-box-bottom-left": {
        include: "button-box",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-pressed-bottom-left": {
        include: "button-box-pressed",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-bottom-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-hovered-bottom-left": {
        include: "button-box-hovered",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON TOP LEFT
      ---------------------------------------------------------------------------
      */
      "button-box-top-left": {
        include: "button-box",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-pressed-top-left": {
        include: "button-box-pressed",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-pressed-hovered-top-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-hovered-top-left": {
        include: "button-box-hovered",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON MIDDLE
      ---------------------------------------------------------------------------
      */
      "button-box-middle": {
        include: "button-box",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-middle": {
        include: "button-box-pressed",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-middle": {
        include: "button-box-pressed-hovered",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-middle": {
        include: "button-box-hovered",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON LEFT
      ---------------------------------------------------------------------------
      */
      "button-box-left": {
        include: "button-box",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-left": {
        include: "button-box-pressed",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-left": {
        include: "button-box-hovered",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-focused-left": {
        include: "button-box-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-focused-left": {
        include: "button-box-hovered-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-focused-left": {
        include: "button-box-pressed-hovered-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-focused-left": {
        include: "button-box-pressed-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        SEPARATOR
      ---------------------------------------------------------------------------
      */
      "separator-horizontal": {
        style: {
          widthLeft: 1,
          colorLeft: "border-separator"
        }
      },
      "separator-vertical": {
        style: {
          widthTop: 1,
          colorTop: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL KNOB
      ---------------------------------------------------------------------------
      */
      "scroll-knob": {
        style: {
          radius: 3,
          width: 1,
          color: "button-border",
          backgroundColor: "scrollbar-bright"
        }
      },
      "scroll-knob-pressed": {
        include: "scroll-knob",
        style: {
          backgroundColor: "scrollbar-dark"
        }
      },
      "scroll-knob-hovered": {
        include: "scroll-knob",
        style: {
          color: "button-border-hovered"
        }
      },
      "scroll-knob-pressed-hovered": {
        include: "scroll-knob-pressed",
        style: {
          color: "button-border-hovered"
        }
      },

      /*
      ---------------------------------------------------------------------------
        HOVER BUTTON
      ---------------------------------------------------------------------------
      */
      "button-hover": {
        style: {
          backgroundColor: "button",
          radius: 3
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: {
          width: 1,
          color: "window-border",
          innerWidth: 4,
          innerColor: "window-border-inner",
          shadowLength: 1,
          shadowBlurRadius: 3,
          shadowColor: "shadow",
          backgroundColor: "background"
        }
      },
      "window-active": {
        include: "window",
        style: {
          shadowLength: 2,
          shadowBlurRadius: 5
        }
      },
      "window-caption": {
        style: {
          width: [0, 0, 2, 0],
          color: "window-border-inner"
        }
      },

      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "white-box": {
        style: {
          width: 1,
          color: "white-box-border",
          shadowBlurRadius: 2,
          shadowColor: "#999999",
          radius: 7,
          backgroundColor: "white",
          shadowLength: 0
        }
      },

      /*
      ---------------------------------------------------------------------------
        TEXT FIELD
      ---------------------------------------------------------------------------
      */
      "inset": {
        style: {
          width: 1,
          color: ["border-light-shadow", "border-light", "border-light", "border-light"]
        }
      },
      "focused-inset": {
        style: {
          width: 2,
          color: "background-selected"
        }
      },
      "border-invalid": {
        style: {
          width: 2,
          color: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        LIST ITEM
      ---------------------------------------------------------------------------
      */
      "lead-item": {
        style: {
          width: 1,
          style: "dotted",
          color: "border-lead"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOL TIP
      ---------------------------------------------------------------------------
      */
      "tooltip": {
        style: {
          width: 1,
          color: "tooltip-text",
          shadowLength: 1,
          shadowBlurRadius: 2,
          shadowColor: "shadow"
        }
      },
      "tooltip-error": {
        style: {
          radius: 5,
          backgroundColor: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar-separator": {
        style: {
          widthLeft: 1,
          colorLeft: "button-border"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu-separator": {
        style: {
          widthTop: 1,
          colorTop: "background-selected"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar-button-hovered": {
        style: {
          width: 1,
          color: "border-main",
          radius: 3,
          backgroundColor: "white"
        }
      },
      "menubar-button-pressed": {
        include: "menubar-button-hovered",
        style: {
          radius: [3, 3, 0, 0],
          width: [1, 1, 0, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser-date-pane": {
        style: {
          widthTop: 1,
          colorTop: "gray",
          style: "solid"
        }
      },
      "datechooser-weekday": {
        style: {
          widthBottom: 1,
          colorBottom: "gray",
          style: "solid"
        }
      },
      "datechooser-week": {
        style: {
          widthRight: 1,
          colorRight: "gray",
          style: "solid"
        }
      },
      "datechooser-week-header": {
        style: {
          widthBottom: 1,
          colorBottom: "gray",
          widthRight: 1,
          colorRight: "gray",
          style: "solid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TAB VIEW
      ---------------------------------------------------------------------------
      */
      "tabview-page-button-top": {
        style: {
          width: [1, 1, 0, 1],
          backgroundColor: "background",
          color: "border-main",
          radius: [3, 3, 0, 0]
        }
      },
      "tabview-page-button-bottom": {
        include: "tabview-page-button-top",
        style: {
          radius: [0, 0, 3, 3],
          width: [0, 1, 1, 1]
        }
      },
      "tabview-page-button-left": {
        include: "tabview-page-button-top",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "tabview-page-button-right": {
        include: "tabview-page-button-top",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "statusbar": {
        style: {
          widthTop: 1,
          colorTop: "background-selected",
          styleTop: "solid"
        }
      },
      "table-scroller-focus-indicator": {
        style: {
          width: 2,
          color: "table-focus-indicator",
          style: "solid"
        }
      },
      "table-header": {
        include: "button-box",
        style: {
          radius: 0,
          width: [1, 0, 1, 0]
        }
      },
      "table-header-column-button": {
        include: "table-header",
        style: {
          width: 1,
          color: "button-border"
        }
      },
      "table-header-cell": {
        style: {
          widthRight: 1,
          color: "button-border"
        }
      },
      "table-header-cell-first": {
        include: "table-header-cell",
        style: {
          widthLeft: 1
        }
      },
      "progressive-table-header": {
        include: "button-box",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "progressive-table-header-cell": {
        style: {
          widthRight: 1,
          color: "button-border"
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: {
          backgroundColor: "#FFF",
          width: 1,
          color: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        RADIO BUTTON
      ---------------------------------------------------------------------------
      */
      "radiobutton": {
        style: {
          radius: 10,
          width: 1,
          color: "button-border",
          innerColor: "background",
          innerWidth: 2
        }
      },
      "radiobutton-focused": {
        include: "radiobutton",
        style: {
          color: "background-selected"
        }
      },
      "radiobutton-invalid": {
        include: "radiobutton",
        style: {
          color: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        CHECK BOX
      ---------------------------------------------------------------------------
      */
      "checkbox": {
        style: {
          width: 1,
          color: "button-border"
        }
      },
      "checkbox-focused": {
        include: "checkbox",
        style: {
          color: "background-selected"
        }
      },
      "checkbox-invalid": {
        include: "checkbox",
        style: {
          color: "invalid"
        }
      }
    }
  });
  qx.theme.simple.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.simple.Decoration": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /**
   * The indigo qooxdoo decoration theme.
   */
  qx.Theme.define("qx.theme.indigo.Decoration", {
    extend: qx.theme.simple.Decoration,
    aliases: {
      decoration: "qx/decoration/Simple"
    },
    decorations: {
      "window": {
        style: {
          width: 1,
          color: "window-border",
          shadowLength: 1,
          shadowBlurRadius: 3,
          shadowColor: "shadow",
          backgroundColor: "background",
          radius: 3
        }
      },
      "window-caption": {
        style: {
          radius: [3, 3, 0, 0],
          color: "window-border",
          widthBottom: 1
        }
      },
      "window-caption-active": {
        style: {
          radius: [3, 3, 0, 0],
          color: "highlight",
          widthBottom: 3
        }
      },
      "white-box": {
        style: {
          width: 1,
          color: "white-box-border",
          backgroundColor: "white"
        }
      },
      "statusbar": {
        style: {
          widthTop: 1,
          colorTop: "border-main",
          styleTop: "solid"
        }
      },
      "app-header": {
        style: {
          innerWidthBottom: 1,
          innerColorBottom: "highlight-shade",
          widthBottom: 9,
          colorBottom: "highlight",
          gradientStart: ["#505154", 0],
          gradientEnd: ["#323335", 100],
          backgroundColor: "#323335"
        }
      }
    }
  });
  qx.theme.indigo.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The simple qooxdoo font theme.
   *
   * @asset(qx/decoration/Indigo/font/JosefinSlab-SemiBold.woff)
   * @asset(qx/decoration/Indigo/font/JosefinSlab-SemiBold.ttf)
   */
  qx.Theme.define("qx.theme.indigo.Font", {
    fonts: {
      "default": {
        size: 12,
        family: ["Lucida Grande", "DejaVu Sans", "Verdana", "sans-serif"],
        color: "font",
        lineHeight: 1.8
      },
      "bold": {
        size: 12,
        family: ["Lucida Grande", "DejaVu Sans", "Verdana", "sans-serif"],
        bold: true,
        color: "font",
        lineHeight: 1.8
      },
      "headline": {
        size: 22,
        family: ["serif"],
        sources: [{
          family: "JosefinSlab",
          source: ["qx/decoration/Indigo/font/JosefinSlab-SemiBold.woff", "qx/decoration/Indigo/font/JosefinSlab-SemiBold.ttf"]
        }]
      },
      "small": {
        size: 11,
        family: ["Lucida Grande", "DejaVu Sans", "Verdana", "sans-serif"],
        color: "font",
        lineHeight: 1.8
      },
      "monospace": {
        size: 11,
        family: ["DejaVu Sans Mono", "Courier New", "monospace"],
        color: "font",
        lineHeight: 1.8
      }
    }
  });
  qx.theme.indigo.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.simple.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The simple qooxdoo appearance theme.
   *
   * @asset(qx/icon/${qx.icontheme}/16/apps/office-calendar.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder-open.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder.png)
   * @asset(qx/icon/${qx.icontheme}/16/mimetypes/text-plain.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/view-refresh.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/window-close.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-cancel.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-ok.png)
   */
  qx.Theme.define("qx.theme.simple.Appearance", {
    appearances: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "widget": {},
      "label": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "image": {
        style: function style(states) {
          return {
            opacity: !states.replacement && states.disabled ? 0.3 : undefined
          };
        }
      },
      "atom": {},
      "atom/label": "label",
      "atom/icon": "image",
      "root": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: "text",
            font: "default"
          };
        }
      },
      "popup": {
        style: function style(states) {
          return {
            decorator: "popup",
            backgroundColor: "background-pane"
          };
        }
      },
      "tooltip": {
        include: "popup",
        style: function style(states) {
          return {
            backgroundColor: "tooltip",
            textColor: "tooltip-text",
            decorator: "tooltip",
            padding: [1, 3, 2, 3],
            offset: [10, 5, 5, 5]
          };
        }
      },
      "tooltip/atom": "atom",
      "tooltip-error": {
        include: "tooltip",
        style: function style(states) {
          return {
            textColor: "text-selected",
            showTimeout: 100,
            hideTimeout: 10000,
            decorator: "tooltip-error",
            font: "bold",
            backgroundColor: undefined
          };
        }
      },
      "tooltip-error/atom": "atom",
      "iframe": {
        style: function style(states) {
          return {
            backgroundColor: "white",
            decorator: "main-dark"
          };
        }
      },
      "move-frame": {
        style: function style(states) {
          return {
            decorator: "main-dark"
          };
        }
      },
      "resize-frame": "move-frame",
      "dragdrop-cursor": {
        style: function style(states) {
          var icon = "nodrop";

          if (states.copy) {
            icon = "copy";
          } else if (states.move) {
            icon = "move";
          } else if (states.alias) {
            icon = "alias";
          }

          return {
            source: qx.theme.simple.Image.URLS["cursor-" + icon],
            position: "right-top",
            offset: [2, 16, 2, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDEBAR
      ---------------------------------------------------------------------------
      */
      "slidebar": {},
      "slidebar/scrollpane": {},
      "slidebar/content": {},
      "slidebar/button-forward": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-" + (states.vertical ? "down" : "right")]
          };
        }
      },
      "slidebar/button-backward": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-" + (states.vertical ? "up" : "left")]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table": "widget",
      "table/statusbar": {
        style: function style(states) {
          return {
            decorator: "statusbar",
            padding: [2, 5]
          };
        }
      },
      "table/column-button": {
        alias: "button",
        style: function style(states) {
          return {
            decorator: "table-header-column-button",
            padding: 3,
            icon: qx.theme.simple.Image.URLS["select-column-order"]
          };
        }
      },
      "table-column-reset-button": {
        include: "menu-button",
        alias: "menu-button",
        style: function style() {
          return {
            icon: "icon/16/actions/view-refresh.png"
          };
        }
      },
      "table-scroller/scrollbar-x": "scrollbar",
      "table-scroller/scrollbar-y": "scrollbar",
      "table-scroller": "widget",
      "table-scroller/header": {
        style: function style() {
          return {
            decorator: "table-header"
          };
        }
      },
      "table-scroller/pane": {},
      "table-scroller/focus-indicator": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },
      "table-scroller/resize-line": {
        style: function style(states) {
          return {
            backgroundColor: "button-border",
            width: 3
          };
        }
      },
      "table-header-cell": {
        alias: "atom",
        style: function style(states) {
          return {
            decorator: states.first ? "table-header-cell-first" : "table-header-cell",
            minWidth: 13,
            font: "bold",
            paddingTop: 3,
            paddingLeft: 5,
            cursor: states.disabled ? undefined : "pointer",
            sortIcon: states.sorted ? qx.theme.simple.Image.URLS["table-" + (states.sortedAscending ? "ascending" : "descending")] : undefined
          };
        }
      },
      "table-header-cell/icon": {
        include: "atom/icon",
        style: function style(states) {
          return {
            paddingRight: 5
          };
        }
      },
      "table-header-cell/sort-icon": {
        style: function style(states) {
          return {
            alignY: "middle",
            alignX: "right",
            paddingRight: 5
          };
        }
      },
      "table-editor-textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 2]
          };
        }
      },
      "table-editor-selectbox": {
        include: "selectbox",
        alias: "selectbox",
        style: function style(states) {
          return {
            padding: [0, 2]
          };
        }
      },
      "table-editor-combobox": {
        include: "combobox",
        alias: "combobox",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },
      "progressive-table-header": {
        style: function style(states) {
          return {
            decorator: "progressive-table-header"
          };
        }
      },
      "progressive-table-header-cell": {
        style: function style(states) {
          return {
            decorator: "progressive-table-header-cell",
            padding: [5, 6, 5, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREEVIRTUAL
      ---------------------------------------------------------------------------
      */
      "treevirtual": {
        include: "textfield",
        alias: "table",
        style: function style(states, superStyles) {
          return {
            padding: [superStyles.padding[0] + 2, superStyles.padding[1] + 1]
          };
        }
      },
      "treevirtual-folder": {
        style: function style(states) {
          return {
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-file": {
        include: "treevirtual-folder",
        alias: "treevirtual-folder",
        style: function style(states) {
          return {
            icon: "icon/16/mimetypes/text-plain.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-line": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-line"]
          };
        }
      },
      "treevirtual-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["tree-minus"]
          };
        }
      },
      "treevirtual-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["tree-plus"]
          };
        }
      },
      "treevirtual-only-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-only"]
          };
        }
      },
      "treevirtual-only-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-only"]
          };
        }
      },
      "treevirtual-start-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-start"]
          };
        }
      },
      "treevirtual-start-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-start"]
          };
        }
      },
      "treevirtual-end-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-end"]
          };
        }
      },
      "treevirtual-end-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-end"]
          };
        }
      },
      "treevirtual-cross-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-cross"]
          };
        }
      },
      "treevirtual-cross-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-cross"]
          };
        }
      },
      "treevirtual-end": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-end"]
          };
        }
      },
      "treevirtual-cross": {
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-cross"]
          };
        }
      },
      "treevirtual-node-editor-textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 2]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        RESIZER
      ---------------------------------------------------------------------------
      */
      "resizer": {
        style: function style(states) {
          return {
            decorator: "main-dark"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane": {},
      "splitpane/splitter": {
        style: function style(states) {
          return {
            backgroundColor: "light-background"
          };
        }
      },
      "splitpane/splitter/knob": {
        style: function style(states) {
          return {
            source: qx.theme.simple.Image.URLS["knob-" + (states.horizontal ? "horizontal" : "vertical")],
            padding: 2
          };
        }
      },
      "splitpane/slider": {
        style: function style(states) {
          return {
            backgroundColor: "border-light-shadow",
            opacity: 0.3
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        style: function style(states) {
          var result = {
            backgroundColor: "background",
            decorator: "main",
            spacingX: 6,
            spacingY: 1,
            iconColumnWidth: 16,
            arrowColumnWidth: 4,
            padding: 1,
            placementModeY: states.submenu || states.contextmenu ? "best-fit" : "keep-align"
          };

          if (states.submenu) {
            result.position = "right-top";
            result.offset = [-2, -3];
          }

          if (states.contextmenu) {
            result.offset = 4;
          }

          return result;
        }
      },
      "menu/slidebar": "menu-slidebar",
      "menu-slidebar": "widget",
      "menu-slidebar-button": {
        style: function style(states) {
          return {
            backgroundColor: states.hovered ? "background-selected" : undefined,
            padding: 6,
            center: true
          };
        }
      },
      "menu-slidebar/button-backward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-up" + (states.hovered ? "-invert" : "")]
          };
        }
      },
      "menu-slidebar/button-forward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-down" + (states.hovered ? "-invert" : "")]
          };
        }
      },
      "menu-separator": {
        style: function style(states) {
          return {
            height: 0,
            decorator: "menu-separator",
            marginTop: 4,
            marginBottom: 4,
            marginLeft: 2,
            marginRight: 2
          };
        }
      },
      "menu-button": {
        alias: "atom",
        style: function style(states) {
          return {
            backgroundColor: states.selected ? "background-selected" : undefined,
            textColor: states.selected ? "text-selected" : undefined,
            padding: [2, 6]
          };
        }
      },
      "menu-button/icon": {
        include: "image",
        style: function style(states) {
          return {
            alignY: "middle"
          };
        }
      },
      "menu-button/label": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            padding: 1
          };
        }
      },
      "menu-button/shortcut": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            marginLeft: 14,
            padding: 1
          };
        }
      },
      "menu-button/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: qx.theme.simple.Image.URLS["arrow-right" + (states.selected ? "-invert" : "")],
            alignY: "middle"
          };
        }
      },
      "menu-checkbox": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : qx.theme.simple.Image.URLS["menu-checkbox" + (states.selected ? "-invert" : "")]
          };
        }
      },
      "menu-radiobutton": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : qx.theme.simple.Image.URLS["menu-radiobutton" + (states.selected ? "-invert" : "")]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar": {
        style: function style(states) {
          return {
            backgroundColor: "light-background",
            padding: [4, 2]
          };
        }
      },
      "menubar-button": {
        style: function style(states) {
          var decorator;
          var padding = [2, 6];

          if (!states.disabled) {
            if (states.pressed) {
              decorator = "menubar-button-pressed";
              padding = [1, 5, 2, 5];
            } else if (states.hovered) {
              decorator = "menubar-button-hovered";
              padding = [1, 5];
            }
          }

          return {
            padding: padding,
            cursor: states.disabled ? undefined : "pointer",
            textColor: "link",
            decorator: decorator
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "virtual-list": "list",
      "virtual-list/row-layer": "row-layer",
      "row-layer": "widget",
      "column-layer": "widget",
      "group-item": {
        include: "label",
        alias: "label",
        style: function style(states) {
          return {
            padding: 4,
            backgroundColor: "#BABABA",
            textColor: "white",
            font: "bold"
          };
        }
      },
      "virtual-selectbox": "selectbox",
      "virtual-selectbox/dropdown": "popup",
      "virtual-selectbox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-combobox": "combobox",
      "virtual-combobox/dropdown": "popup",
      "virtual-combobox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-tree": {
        include: "tree",
        alias: "tree",
        style: function style(states) {
          return {
            itemHeight: 21
          };
        }
      },
      "virtual-tree-folder": "tree-folder",
      "virtual-tree-file": "tree-file",
      "cell": {
        style: function style(states) {
          return {
            backgroundColor: states.selected ? "table-row-background-selected" : "table-row-background-even",
            textColor: states.selected ? "text-selected" : "text",
            padding: [3, 6]
          };
        }
      },
      "cell-string": "cell",
      "cell-number": {
        include: "cell",
        style: function style(states) {
          return {
            textAlign: "right"
          };
        }
      },
      "cell-image": "cell",
      "cell-boolean": "cell",
      "cell-atom": "cell",
      "cell-date": "cell",
      "cell-html": "cell",

      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar": {},
      "scrollbar/slider": {},
      "scrollbar/slider/knob": {
        style: function style(states) {
          var decorator = "scroll-knob";

          if (!states.disabled) {
            if (states.hovered && !states.pressed && !states.checked) {
              decorator = "scroll-knob-hovered";
            } else if (states.hovered && (states.pressed || states.checked)) {
              decorator = "scroll-knob-pressed-hovered";
            } else if (states.pressed || states.checked) {
              decorator = "scroll-knob-pressed";
            }
          }

          return {
            height: 14,
            width: 14,
            cursor: states.disabled ? undefined : "pointer",
            decorator: decorator,
            minHeight: states.horizontal ? undefined : 20,
            minWidth: states.horizontal ? 20 : undefined
          };
        }
      },
      "scrollbar/button": {
        style: function style(states) {
          var styles = {};
          styles.padding = 4;
          var icon = "";

          if (states.left) {
            icon = "left";
            styles.marginRight = 2;
          } else if (states.right) {
            icon += "right";
            styles.marginLeft = 2;
          } else if (states.up) {
            icon += "up";
            styles.marginBottom = 2;
          } else {
            icon += "down";
            styles.marginTop = 2;
          }

          styles.icon = qx.theme.simple.Image.URLS["arrow-" + icon];
          styles.cursor = "pointer";
          styles.decorator = "button-box";
          return styles;
        }
      },
      "scrollbar/button-begin": "scrollbar/button",
      "scrollbar/button-end": "scrollbar/button",

      /*
      ---------------------------------------------------------------------------
        SCROLLAREA
      ---------------------------------------------------------------------------
      */
      "scrollarea/corner": {
        style: function style(states) {
          return {
            backgroundColor: "background"
          };
        }
      },
      "scrollarea": "widget",
      "scrollarea/pane": "widget",
      "scrollarea/scrollbar-x": "scrollbar",
      "scrollarea/scrollbar-y": "scrollbar",

      /*
      ---------------------------------------------------------------------------
        TEXT FIELD
      ---------------------------------------------------------------------------
      */
      "textfield": {
        style: function style(states) {
          var textColor;

          if (states.disabled) {
            textColor = "text-disabled";
          } else if (states.showingPlaceholder) {
            textColor = "text-placeholder";
          } else {
            textColor = undefined;
          }

          var decorator;
          var padding;

          if (states.disabled) {
            decorator = "inset";
            padding = [2, 3];
          } else if (states.invalid) {
            decorator = "border-invalid";
            padding = [1, 2];
          } else if (states.focused) {
            decorator = "focused-inset";
            padding = [1, 2];
          } else {
            padding = [2, 3];
            decorator = "inset";
          }

          return {
            decorator: decorator,
            padding: padding,
            textColor: textColor,
            backgroundColor: states.disabled ? "background-disabled" : "white"
          };
        }
      },
      "textarea": "textfield",

      /*
      ---------------------------------------------------------------------------
        RADIO BUTTON
      ---------------------------------------------------------------------------
      */
      "radiobutton/icon": {
        style: function style(states) {
          var decorator = "radiobutton";

          if (states.focused && !states.invalid) {
            decorator = "radiobutton-focused";
          }

          decorator += states.invalid && !states.disabled ? "-invalid" : "";
          var backgroundColor;

          if (states.disabled && states.checked) {
            backgroundColor = "background-disabled-checked";
          } else if (states.disabled) {
            backgroundColor = "background-disabled";
          } else if (states.checked) {
            backgroundColor = "background-selected";
          }

          return {
            decorator: decorator,
            width: 12,
            height: 12,
            backgroundColor: backgroundColor
          };
        }
      },
      "radiobutton": {
        style: function style(states) {
          // set an empty icon to be sure that the icon image is rendered
          return {
            icon: qx.theme.simple.Image.URLS["blank"]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        FORM
      ---------------------------------------------------------------------------
      */
      "form-renderer-label": {
        include: "label",
        style: function style() {
          return {
            paddingTop: 3
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        CHECK BOX
      ---------------------------------------------------------------------------
      */
      "checkbox": {
        alias: "atom",
        style: function style(states) {
          // The "disabled" icon is set to an icon **without** the -disabled
          // suffix on purpose. This is because the Image widget handles this
          // already by replacing the current image with a disabled version
          // (if available). If no disabled image is found, the opacity style
          // is used.
          var icon; // Checked

          if (states.checked) {
            icon = qx.theme.simple.Image.URLS["checkbox-checked"]; // Undetermined
          } else if (states.undetermined) {
            icon = qx.theme.simple.Image.URLS["checkbox-undetermined"]; // Unchecked
          } else {
            // empty icon
            icon = qx.theme.simple.Image.URLS["blank"];
          }

          return {
            icon: icon,
            gap: 6
          };
        }
      },
      "checkbox/icon": {
        style: function style(states) {
          var decorator = "checkbox";

          if (states.focused && !states.invalid) {
            decorator = "checkbox-focused";
          }

          decorator += states.invalid && !states.disabled ? "-invalid" : "";
          var padding; // Checked

          if (states.checked) {
            padding = 2; // Undetermined
          } else if (states.undetermined) {
            padding = [4, 2];
          }

          return {
            decorator: decorator,
            width: 12,
            height: 12,
            padding: padding,
            backgroundColor: "white"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPINNER
      ---------------------------------------------------------------------------
      */
      "spinner": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "spinner/textfield": "textfield",
      "spinner/upbutton": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          var decorator = "button-box-top-right";

          if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered-top-right";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered-top-right";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed-top-right";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-up-small"],
            decorator: decorator,
            width: 17
          };
        }
      },
      "spinner/downbutton": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          var decorator = "button-box-bottom-right";

          if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered-bottom-right";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered-bottom-right";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed-bottom-right";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down-small"],
            decorator: decorator,
            width: 17
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTBOX
      ---------------------------------------------------------------------------
      */
      "selectbox": "button-frame",
      "selectbox/atom": "atom",
      "selectbox/popup": "popup",
      "selectbox/list": {
        alias: "list",
        include: "list",
        style: function style() {
          return {
            decorator: undefined
          };
        }
      },
      "selectbox/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: qx.theme.simple.Image.URLS["arrow-down"],
            paddingRight: 4,
            paddingLeft: 5
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COMBO BOX
      ---------------------------------------------------------------------------
      */
      "combobox": {},
      "combobox/button": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          var decorator = "button-box-right-borderless";

          if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered-right-borderless";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered-right-borderless";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed-right-borderless";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            padding: [0, 5],
            width: 19
          };
        }
      },
      "combobox/popup": "popup",
      "combobox/list": {
        alias: "list"
      },
      "combobox/textfield": "textfield",

      /*
      ---------------------------------------------------------------------------
        DATEFIELD
      ---------------------------------------------------------------------------
      */
      "datefield": "textfield",
      "datefield/button": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          return {
            icon: "icon/16/apps/office-calendar.png",
            padding: [0, 0, 0, 3],
            backgroundColor: undefined,
            decorator: undefined,
            width: 19
          };
        }
      },
      "datefield/textfield": {
        alias: "textfield",
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: 0
          };
        }
      },
      "datefield/list": {
        alias: "datechooser",
        include: "datechooser",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        LIST
      ---------------------------------------------------------------------------
      */
      "list": {
        alias: "scrollarea",
        include: "textfield"
      },
      "listitem": {
        alias: "atom",
        style: function style(states) {
          var padding = [3, 5, 3, 5];

          if (states.lead) {
            padding = [2, 4, 2, 4];
          }

          if (states.dragover) {
            padding[2] -= 2;
          }

          var backgroundColor;

          if (states.selected) {
            backgroundColor = "background-selected";

            if (states.disabled) {
              backgroundColor += "-disabled";
            }
          }

          return {
            gap: 4,
            padding: padding,
            backgroundColor: backgroundColor,
            textColor: states.selected ? "text-selected" : undefined,
            decorator: states.lead ? "lead-item" : states.dragover ? "dragover" : undefined,
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDER
      ---------------------------------------------------------------------------
      */
      "slider": {
        style: function style(states) {
          var decorator;
          var padding;

          if (states.disabled) {
            decorator = "inset";
            padding = [2, 3];
          } else if (states.invalid) {
            decorator = "border-invalid";
            padding = [1, 2];
          } else if (states.focused) {
            decorator = "focused-inset";
            padding = [1, 2];
          } else {
            padding = [2, 3];
            decorator = "inset";
          }

          return {
            decorator: decorator,
            padding: padding
          };
        }
      },
      "slider/knob": "scrollbar/slider/knob",

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button-frame": {
        alias: "atom",
        style: function style(states) {
          var decorator = "button-box";

          if (!states.disabled) {
            if (states.hovered && !states.pressed && !states.checked) {
              decorator = "button-box-hovered";
            } else if (states.hovered && (states.pressed || states.checked)) {
              decorator = "button-box-pressed-hovered";
            } else if (states.pressed || states.checked) {
              decorator = "button-box-pressed";
            }
          }

          if (states.invalid && !states.disabled) {
            decorator += "-invalid";
          } else if (states.focused) {
            decorator += "-focused";
          }

          return {
            decorator: decorator,
            padding: [3, 8],
            cursor: states.disabled ? undefined : "pointer",
            minWidth: 5,
            minHeight: 5
          };
        }
      },
      "button-frame/label": {
        alias: "atom/label",
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "button": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          return {
            center: true
          };
        }
      },
      "toggle-button": "button",
      "hover-button": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            decorator: states.hovered ? "button-hover" : undefined
          };
        }
      },
      "menubutton": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            iconPosition: "right"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLIT BUTTON
      ---------------------------------------------------------------------------
      */
      "splitbutton": {},
      "splitbutton/button": {
        alias: "atom",
        style: function style(states) {
          var decorator = "button-box";

          if (!states.disabled) {
            if (states.pressed || states.checked) {
              decorator += "-pressed";
            }

            if (states.hovered) {
              decorator += "-hovered";
            }
          }

          if (states.focused) {
            decorator += "-focused";
          }

          decorator += "-left";
          return {
            decorator: decorator,
            padding: [3, 8],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "splitbutton/arrow": {
        style: function style(states) {
          var decorator = "button-box";

          if (!states.disabled) {
            if (states.pressed || states.checked) {
              decorator += "-pressed";
            }

            if (states.hovered) {
              decorator += "-hovered";
            }
          }

          if (states.focused) {
            decorator += "-focused";
          }

          decorator += "-right";
          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            cursor: states.disabled ? undefined : "pointer",
            padding: [3, 4]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "groupbox": {},
      "groupbox/legend": {
        alias: "atom",
        style: function style(states) {
          return {
            textColor: states.invalid ? "invalid" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },
      "groupbox/frame": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            padding: [6, 9],
            margin: [18, 2, 2, 2],
            decorator: "white-box"
          };
        }
      },
      "check-groupbox": "groupbox",
      "check-groupbox/legend": {
        alias: "checkbox",
        include: "checkbox",
        style: function style(states) {
          return {
            textColor: states.invalid ? "invalid" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },
      "radio-groupbox": "groupbox",
      "radio-groupbox/legend": {
        alias: "radiobutton",
        include: "radiobutton",
        style: function style(states) {
          return {
            textColor: states.invalid ? "invalid" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREE
      ---------------------------------------------------------------------------
      */
      "tree-folder/open": {
        include: "image",
        style: function style(states) {
          return {
            source: states.opened ? qx.theme.simple.Image.URLS["tree-minus"] : qx.theme.simple.Image.URLS["tree-plus"]
          };
        }
      },
      "tree-folder": {
        style: function style(states) {
          var backgroundColor;

          if (states.selected) {
            backgroundColor = "background-selected";

            if (states.disabled) {
              backgroundColor += "-disabled";
            }
          }

          return {
            padding: [2, 8, 2, 5],
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png",
            backgroundColor: backgroundColor,
            iconOpened: "icon/16/places/folder-open.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree-folder/icon": {
        include: "image",
        style: function style(states) {
          return {
            padding: [0, 4, 0, 0]
          };
        }
      },
      "tree-folder/label": {
        style: function style(states) {
          return {
            padding: [1, 2],
            textColor: states.selected && !states.disabled ? "text-selected" : undefined
          };
        }
      },
      "tree-file": {
        include: "tree-folder",
        alias: "tree-folder",
        style: function style(states) {
          return {
            icon: "icon/16/mimetypes/text-plain.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree": {
        include: "list",
        alias: "list",
        style: function style(states) {
          return {
            contentPadding: states.invalid && !states.disabled ? [3, 0] : [4, 1],
            padding: states.focused ? 0 : 1
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: function style(states) {
          return {
            contentPadding: [10, 10, 10, 10],
            backgroundColor: "background",
            decorator: states.maximized ? undefined : states.active ? "window-active" : "window"
          };
        }
      },
      "window-resize-frame": "resize-frame",
      "window/pane": {},
      "window/captionbar": {
        style: function style(states) {
          return {
            backgroundColor: states.active ? "light-background" : "background-disabled",
            padding: 8,
            font: "bold",
            decorator: "window-caption"
          };
        }
      },
      "window/icon": {
        style: function style(states) {
          return {
            marginRight: 4
          };
        }
      },
      "window/title": {
        style: function style(states) {
          return {
            cursor: "default",
            font: "bold",
            marginRight: 20,
            alignY: "middle"
          };
        }
      },
      "window/minimize-button": {
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["window-minimize"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/restore-button": {
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["window-restore"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/maximize-button": {
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.simple.Image.URLS["window-maximize"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/close-button": {
        alias: "button",
        style: function style(states) {
          return {
            marginLeft: 2,
            icon: qx.theme.simple.Image.URLS["window-close"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/statusbar": {
        style: function style(states) {
          return {
            decorator: "statusbar",
            padding: [2, 6]
          };
        }
      },
      "window/statusbar-text": "label",

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser": {
        style: function style(states) {
          return {
            decorator: "main",
            minWidth: 220
          };
        }
      },
      "datechooser/navigation-bar": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            textColor: states.disabled ? "text-disabled" : states.invalid ? "invalid" : undefined,
            padding: [2, 10]
          };
        }
      },
      "datechooser/last-year-button-tooltip": "tooltip",
      "datechooser/last-month-button-tooltip": "tooltip",
      "datechooser/next-year-button-tooltip": "tooltip",
      "datechooser/next-month-button-tooltip": "tooltip",
      "datechooser/last-year-button": "datechooser/button",
      "datechooser/last-month-button": "datechooser/button",
      "datechooser/next-year-button": "datechooser/button",
      "datechooser/next-month-button": "datechooser/button",
      "datechooser/button/icon": {},
      "datechooser/button": {
        style: function style(states) {
          var result = {
            width: 17,
            show: "icon",
            cursor: states.disabled ? undefined : "pointer"
          };

          if (states.lastYear) {
            result.icon = qx.theme.simple.Image.URLS["arrow-rewind"];
          } else if (states.lastMonth) {
            result.icon = qx.theme.simple.Image.URLS["arrow-left"];
          } else if (states.nextYear) {
            result.icon = qx.theme.simple.Image.URLS["arrow-forward"];
          } else if (states.nextMonth) {
            result.icon = qx.theme.simple.Image.URLS["arrow-right"];
          }

          return result;
        }
      },
      "datechooser/month-year-label": {
        style: function style(states) {
          return {
            font: "bold",
            textAlign: "center"
          };
        }
      },
      "datechooser/date-pane": {
        style: function style(states) {
          return {
            decorator: "datechooser-date-pane",
            backgroundColor: "background"
          };
        }
      },
      "datechooser/weekday": {
        style: function style(states) {
          return {
            decorator: "datechooser-weekday",
            font: "bold",
            textAlign: "center",
            textColor: states.disabled ? "text-disabled" : states.weekend ? "background-selected-dark" : "background",
            backgroundColor: states.weekend ? "background" : "background-selected-dark",
            paddingTop: 2
          };
        }
      },
      "datechooser/day": {
        style: function style(states) {
          return {
            textAlign: "center",
            decorator: states.today ? "main" : undefined,
            textColor: states.disabled ? "text-disabled" : states.selected ? "text-selected" : states.otherMonth ? "text-disabled" : undefined,
            backgroundColor: states.disabled ? undefined : states.selected ? "background-selected" : undefined,
            padding: states.today ? [1, 3] : [2, 4]
          };
        }
      },
      "datechooser/week": {
        style: function style(states) {
          return {
            textAlign: "center",
            textColor: "background-selected-dark",
            padding: [2, 4],
            decorator: states.header ? "datechooser-week-header" : "datechooser-week"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: function style(states) {
          return {
            decorator: "progressbar",
            padding: 1,
            backgroundColor: "white",
            width: 200,
            height: 20
          };
        }
      },
      "progressbar/progress": {
        style: function style(states) {
          return {
            backgroundColor: states.disabled ? "background-disabled-checked" : "background-selected"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar": {
        style: function style(states) {
          return {
            backgroundColor: "light-background",
            padding: 0
          };
        }
      },
      "toolbar/part": {
        style: function style(states) {
          return {
            margin: [0, 15]
          };
        }
      },
      "toolbar/part/container": {},
      "toolbar/part/handle": {},
      "toolbar-separator": {
        style: function style(states) {
          return {
            decorator: "toolbar-separator",
            margin: [7, 0],
            width: 4
          };
        }
      },
      "toolbar-button": {
        alias: "atom",
        style: function style(states) {
          var decorator = "button-box";

          if (states.disabled) {
            decorator = "button-box";
          } else if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed";
          } // set the right left and right decorator


          if (states.left) {
            decorator += "-left";
          } else if (states.right) {
            decorator += "-right";
          } else if (states.middle) {
            decorator += "-middle";
          } // set the margin


          var margin = [7, 10];

          if (states.left || states.middle || states.right) {
            margin = [7, 0];
          }

          return {
            cursor: states.disabled ? undefined : "pointer",
            decorator: decorator,
            margin: margin,
            padding: [3, 5]
          };
        }
      },
      "toolbar-menubutton": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          return {
            showArrow: true
          };
        }
      },
      "toolbar-menubutton/arrow": {
        alias: "image",
        include: "image",
        style: function style(states) {
          return {
            source: qx.theme.simple.Image.URLS["arrow-down"],
            cursor: states.disabled ? undefined : "pointer",
            padding: [0, 5],
            marginLeft: 2
          };
        }
      },
      "toolbar-splitbutton": {},
      "toolbar-splitbutton/button": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          var decorator = "button-box";

          if (states.disabled) {
            decorator = "button-box";
          } else if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed";
          } // default margin, when the button is alone


          var margin = [7, 0, 7, 10];

          if (states.left || states.middle || states.right) {
            margin = [7, 0, 7, 0];
          } // set the right left and right decorator


          if (states.left) {
            decorator += "-left";
          } else if (states.right) {
            decorator += "-middle";
          } else if (states.middle) {
            decorator += "-middle";
          } else {
            decorator += "-left";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            margin: margin
          };
        }
      },
      "toolbar-splitbutton/arrow": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          var decorator = "button-box";

          if (states.disabled) {
            decorator = "button-box";
          } else if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed";
          } // default margin, when the button is alone


          var margin = [7, 10, 7, 0];

          if (states.left || states.middle || states.right) {
            margin = [7, 0, 7, 0];
          } // set the right left and right decorator


          if (states.left) {
            decorator += "-middle";
          } else if (states.right) {
            decorator += "-right";
          } else if (states.middle) {
            decorator += "-middle";
          } else {
            decorator += "-right";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            margin: margin
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview": {},
      "tabview/bar": {
        alias: "slidebar",
        style: function style(states) {
          var marginTop = 0,
              marginRight = 0,
              marginBottom = 0,
              marginLeft = 0;

          if (states.barTop) {
            marginBottom -= 1;
          } else if (states.barBottom) {
            marginTop -= 1;
          } else if (states.barRight) {
            marginLeft -= 1;
          } else {
            marginRight -= 1;
          }

          return {
            marginBottom: marginBottom,
            marginTop: marginTop,
            marginLeft: marginLeft,
            marginRight: marginRight
          };
        }
      },
      "tabview/bar/button-forward": {
        include: "slidebar/button-forward",
        alias: "slidebar/button-forward",
        style: function style(states) {
          if (states.barTop) {
            return {
              marginTop: 4,
              marginBottom: 2,
              decorator: null
            };
          } else if (states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 4,
              decorator: null
            };
          } else if (states.barLeft) {
            return {
              marginLeft: 4,
              marginRight: 2,
              decorator: null
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 4,
              decorator: null
            };
          }
        }
      },
      "tabview/bar/button-backward": {
        include: "slidebar/button-backward",
        alias: "slidebar/button-backward",
        style: function style(states) {
          if (states.barTop) {
            return {
              marginTop: 4,
              marginBottom: 2,
              decorator: null
            };
          } else if (states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 4,
              decorator: null
            };
          } else if (states.barLeft) {
            return {
              marginLeft: 4,
              marginRight: 2,
              decorator: null
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 4,
              decorator: null
            };
          }
        }
      },
      "tabview/pane": {
        style: function style(states) {
          return {
            backgroundColor: "background",
            decorator: "main",
            padding: 10
          };
        }
      },
      "tabview-page": "widget",
      "tabview-page/button": {
        style: function style(states) {
          var decorator; // default padding

          if (states.barTop || states.barBottom) {
            var padding = [8, 16, 8, 13];
          } else {
            var padding = [8, 4, 8, 4];
          } // decorator


          if (states.checked) {
            if (states.barTop) {
              decorator = "tabview-page-button-top";
            } else if (states.barBottom) {
              decorator = "tabview-page-button-bottom";
            } else if (states.barRight) {
              decorator = "tabview-page-button-right";
            } else if (states.barLeft) {
              decorator = "tabview-page-button-left";
            }
          } else {
            for (var i = 0; i < padding.length; i++) {
              padding[i] += 1;
            } // reduce the size by 1 because we have different decorator border width


            if (states.barTop) {
              padding[2] -= 1;
            } else if (states.barBottom) {
              padding[0] -= 1;
            } else if (states.barRight) {
              padding[3] -= 1;
            } else if (states.barLeft) {
              padding[1] -= 1;
            }
          }

          return {
            zIndex: states.checked ? 10 : 5,
            decorator: decorator,
            textColor: states.disabled ? "text-disabled" : states.checked ? null : "link",
            padding: padding,
            cursor: "pointer"
          };
        }
      },
      "tabview-page/button/label": {
        alias: "label",
        style: function style(states) {
          return {
            padding: [0, 1, 0, 1]
          };
        }
      },
      "tabview-page/button/icon": "image",
      "tabview-page/button/close-button": {
        alias: "atom",
        style: function style(states) {
          return {
            cursor: states.disabled ? undefined : "pointer",
            icon: qx.theme.simple.Image.URLS["tabview-close"]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR POPUP
      ---------------------------------------------------------------------------
      */
      "colorpopup": {
        alias: "popup",
        include: "popup",
        style: function style(states) {
          return {
            padding: 5
          };
        }
      },
      "colorpopup/field": {
        style: function style(states) {
          return {
            margin: 2,
            width: 14,
            height: 14,
            backgroundColor: "background",
            decorator: "main-dark"
          };
        }
      },
      "colorpopup/selector-button": "button",
      "colorpopup/auto-button": "button",
      "colorpopup/preview-pane": "groupbox",
      "colorpopup/current-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginLeft: 4,
            decorator: "main-dark",
            allowGrowX: true
          };
        }
      },
      "colorpopup/selected-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginRight: 4,
            decorator: "main-dark",
            allowGrowX: true
          };
        }
      },
      "colorpopup/colorselector-okbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-ok.png"
          };
        }
      },
      "colorpopup/colorselector-cancelbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-cancel.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR SELECTOR
      ---------------------------------------------------------------------------
      */
      "colorselector": "widget",
      "colorselector/control-bar": "widget",
      "colorselector/visual-pane": "groupbox",
      "colorselector/control-pane": "widget",
      "colorselector/preset-grid": "widget",
      "colorselector/colorbucket": {
        style: function style(states) {
          return {
            decorator: "main-dark",
            width: 16,
            height: 16
          };
        }
      },
      "colorselector/preset-field-set": "groupbox",
      "colorselector/input-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/preview-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/hex-field-composite": "widget",
      "colorselector/hex-field": "textfield",
      "colorselector/rgb-spinner-composite": "widget",
      "colorselector/rgb-spinner-red": "spinner",
      "colorselector/rgb-spinner-green": "spinner",
      "colorselector/rgb-spinner-blue": "spinner",
      "colorselector/hsb-spinner-composite": "widget",
      "colorselector/hsb-spinner-hue": "spinner",
      "colorselector/hsb-spinner-saturation": "spinner",
      "colorselector/hsb-spinner-brightness": "spinner",
      "colorselector/preview-content-old": {
        style: function style(states) {
          return {
            decorator: "main-dark",
            width: 50,
            height: 25
          };
        }
      },
      "colorselector/preview-content-new": {
        style: function style(states) {
          return {
            decorator: "main-dark",
            backgroundColor: "white",
            width: 50,
            height: 25
          };
        }
      },
      "colorselector/hue-saturation-field": {
        style: function style(states) {
          return {
            decorator: "main-dark",
            margin: 5
          };
        }
      },
      "colorselector/brightness-field": {
        style: function style(states) {
          return {
            decorator: "main-dark",
            margin: [5, 7]
          };
        }
      },
      "colorselector/hue-saturation-pane": "widget",
      "colorselector/hue-saturation-handle": "widget",
      "colorselector/brightness-pane": "widget",
      "colorselector/brightness-handle": "widget",

      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header": {
        style: function style(states) {
          return {
            font: "headline",
            textColor: "text-selected",
            backgroundColor: "background-selected-dark",
            padding: [8, 12]
          };
        }
      },
      "app-header-label": {
        style: function style(states) {
          return {
            paddingTop: 5
          };
        }
      },
      "app-splitpane": {
        alias: "splitpane",
        style: function style(states) {
          return {
            padding: [0, 10, 10, 10],
            backgroundColor: "light-background"
          };
        }
      }
    }
  });
  qx.theme.simple.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.simple.Appearance": {
        "require": true
      },
      "qx.theme.simple.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The simple qooxdoo appearance theme.
   *
   * @asset(qx/icon/${qx.icontheme}/16/apps/office-calendar.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder-open.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder.png)
   * @asset(qx/icon/${qx.icontheme}/16/mimetypes/text-plain.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/view-refresh.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/window-close.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-cancel.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-ok.png)
   */
  qx.Theme.define("qx.theme.indigo.Appearance", {
    extend: qx.theme.simple.Appearance,
    appearances: {
      "colorselector/input-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 0
          };
        }
      },
      "colorselector/preview-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 0
          };
        }
      },
      "toolbar": {
        style: function style(states) {
          return {
            backgroundColor: "light-background",
            padding: [4, 0]
          };
        }
      },
      "splitpane/splitter/knob": {
        style: function style(states) {
          return {
            source: qx.theme.simple.Image.URLS["knob-" + (states.horizontal ? "horizontal" : "vertical")],
            padding: 3
          };
        }
      },
      "window": {
        style: function style(states) {
          return {
            contentPadding: [10, 10, 10, 10],
            backgroundColor: states.maximized ? "background" : undefined,
            decorator: states.maximized ? undefined : states.active ? "window-active" : "window"
          };
        }
      },
      "window/captionbar": {
        style: function style(states) {
          var active = states.active && !states.disabled;
          return {
            padding: [3, 8, active ? 1 : 3, 8],
            textColor: active ? "highlight" : "font",
            decorator: active ? "window-caption-active" : "window-caption"
          };
        }
      },
      "window/title": {
        style: function style(states) {
          return {
            cursor: "default",
            font: "default",
            marginRight: 20,
            alignY: "middle"
          };
        }
      },
      "virtual-tree": {
        include: "tree",
        alias: "tree",
        style: function style(states) {
          return {
            itemHeight: 27
          };
        }
      },
      "app-header": {
        style: function style(states) {
          return {
            font: "headline",
            textColor: "text-selected",
            decorator: "app-header",
            padding: 10
          };
        }
      },
      "app-header-label": {
        style: function style(states) {
          return {
            paddingTop: 5
          };
        }
      },
      "app-splitpane": {
        alias: "splitpane",
        style: function style(states) {
          return {
            padding: [0, 10, 10, 10],
            backgroundColor: "light-background"
          };
        }
      }
    }
  });
  qx.theme.indigo.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * Tango icons
   */
  qx.Theme.define("qx.theme.icon.Tango", {
    title: "Tango",
    aliases: {
      "icon": "qx/icon/Tango"
    }
  });
  qx.theme.icon.Tango.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.indigo.Color": {
        "require": true
      },
      "qx.theme.indigo.Decoration": {
        "require": true
      },
      "qx.theme.indigo.Font": {
        "require": true
      },
      "qx.theme.indigo.Appearance": {
        "require": true
      },
      "qx.theme.icon.Tango": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Tristan Koch (trkoch)
  
  ************************************************************************ */

  /**
   * Simple Theme
   */
  qx.Theme.define("qx.theme.Indigo", {
    title: "Indigo",
    meta: {
      color: qx.theme.indigo.Color,
      decoration: qx.theme.indigo.Decoration,
      font: qx.theme.indigo.Font,
      appearance: qx.theme.indigo.Appearance,
      icon: qx.theme.icon.Tango
    }
  });
  qx.theme.Indigo.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * Mapping class for all images used in the simple theme.
   *
   * @asset(qx/decoration/Simple/*)
   * @asset(qx/static/blank.png)
   */
  qx.Class.define("qx.theme.simple.Image", {
    extend: qx.core.Object,
    statics: {
      /**
       * Holds a map containing all the URL to the images.
       * @internal
       */
      URLS: {
        "blank": "qx/static/blank.png",
        // checkbox
        "checkbox-checked": "decoration/checkbox/checked.png",
        "checkbox-undetermined": "decoration/checkbox/undetermined.png",
        // window
        "window-minimize": "decoration/window/minimize.gif",
        "window-maximize": "decoration/window/maximize.gif",
        "window-restore": "decoration/window/restore.gif",
        "window-close": "decoration/window/close.gif",
        // cursor
        "cursor-copy": "decoration/cursors/copy.gif",
        "cursor-move": "decoration/cursors/move.gif",
        "cursor-alias": "decoration/cursors/alias.gif",
        "cursor-nodrop": "decoration/cursors/nodrop.gif",
        // arrows
        "arrow-right": "decoration/arrows/right.gif",
        "arrow-left": "decoration/arrows/left.gif",
        "arrow-up": "decoration/arrows/up.gif",
        "arrow-down": "decoration/arrows/down.gif",
        "arrow-forward": "decoration/arrows/forward.gif",
        "arrow-rewind": "decoration/arrows/rewind.gif",
        "arrow-down-small": "decoration/arrows/down-small.gif",
        "arrow-up-small": "decoration/arrows/up-small.gif",
        "arrow-up-invert": "decoration/arrows/up-invert.gif",
        "arrow-down-invert": "decoration/arrows/down-invert.gif",
        "arrow-right-invert": "decoration/arrows/right-invert.gif",
        // split pane
        "knob-horizontal": "decoration/splitpane/knob-horizontal.png",
        "knob-vertical": "decoration/splitpane/knob-vertical.png",
        // tree
        "tree-minus": "decoration/tree/minus.gif",
        "tree-plus": "decoration/tree/plus.gif",
        // table
        "select-column-order": "decoration/table/select-column-order.png",
        "table-ascending": "decoration/table/ascending.png",
        "table-descending": "decoration/table/descending.png",
        // tree virtual
        "treevirtual-line": "decoration/treevirtual/line.gif",
        "treevirtual-minus-only": "decoration/treevirtual/only_minus.gif",
        "treevirtual-plus-only": "decoration/treevirtual/only_plus.gif",
        "treevirtual-minus-start": "decoration/treevirtual/start_minus.gif",
        "treevirtual-plus-start": "decoration/treevirtual/start_plus.gif",
        "treevirtual-minus-end": "decoration/treevirtual/end_minus.gif",
        "treevirtual-plus-end": "decoration/treevirtual/end_plus.gif",
        "treevirtual-minus-cross": "decoration/treevirtual/cross_minus.gif",
        "treevirtual-plus-cross": "decoration/treevirtual/cross_plus.gif",
        "treevirtual-end": "decoration/treevirtual/end.gif",
        "treevirtual-cross": "decoration/treevirtual/cross.gif",
        // menu
        "menu-checkbox": "decoration/menu/checkbox.gif",
        "menu-checkbox-invert": "decoration/menu/checkbox-invert.gif",
        "menu-radiobutton-invert": "decoration/menu/radiobutton-invert.gif",
        "menu-radiobutton": "decoration/menu/radiobutton.gif",
        // tabview
        "tabview-close": "decoration/tabview/close.gif"
      }
    }
  });
  qx.theme.simple.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Css": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "css.rgba": {
          "load": true,
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Alexander Steitz (aback)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Modern color theme
   */
  qx.Theme.define("qx.theme.modern.Color", {
    colors: {
      /*
      ---------------------------------------------------------------------------
        BACKGROUND COLORS
      ---------------------------------------------------------------------------
      */
      // application, desktop, ...
      "background-application": "#DFDFDF",
      // pane color for windows, splitpanes, ...
      "background-pane": "#F3F3F3",
      // textfields, ...
      "background-light": "#FCFCFC",
      // headers, ...
      "background-medium": "#EEEEEE",
      // splitpane
      "background-splitpane": "#AFAFAF",
      // tooltip, ...
      "background-tip": "#ffffdd",
      // error tooltip
      "background-tip-error": "#C72B2B",
      // tables, ...
      "background-odd": "#E4E4E4",
      // progress bar
      "progressbar-background": "white",

      /*
      ---------------------------------------------------------------------------
        TEXT COLORS
      ---------------------------------------------------------------------------
      */
      // other types
      "text-light": "#909090",
      "text-gray": "#4a4a4a",
      // labels
      "text-label": "#1a1a1a",
      // group boxes
      "text-title": "#314a6e",
      // text fields
      "text-input": "#000000",
      // states
      "text-hovered": "#001533",
      "text-disabled": "#7B7A7E",
      "text-selected": "#fffefe",
      "text-active": "#26364D",
      "text-inactive": "#404955",
      "text-placeholder": "#CBC8CD",

      /*
      ---------------------------------------------------------------------------
        BORDER COLORS
      ---------------------------------------------------------------------------
      */
      "border-inner-scrollbar": "white",
      // menus, tables, scrollbars, list, etc.
      "border-main": "#4d4d4d",
      "menu-separator-top": "#C5C5C5",
      "menu-separator-bottom": "#FAFAFA",
      // between toolbars
      "border-separator": "#808080",
      "border-toolbar-button-outer": "#b6b6b6",
      "border-toolbar-border-inner": "#f8f8f8",
      "border-toolbar-separator-right": "#f4f4f4",
      "border-toolbar-separator-left": "#b8b8b8",
      // text fields
      "border-input": "#334866",
      "border-inner-input": "white",
      // disabled text fields
      "border-disabled": "#B6B6B6",
      // tab view, window
      "border-pane": "#00204D",
      // buttons
      "border-button": "#666666",
      // tables (vertical line)
      "border-column": "#CCCCCC",
      // focus state of text fields
      "border-focused": "#99C3FE",
      // invalid form widgets
      "invalid": "#990000",
      "border-focused-invalid": "#FF9999",
      // drag & drop
      "border-dragover": "#33508D",
      "keyboard-focus": "black",

      /*
      ---------------------------------------------------------------------------
        TABLE COLORS
      ---------------------------------------------------------------------------
      */
      // equal to "background-pane"
      "table-pane": "#F3F3F3",
      // own table colors
      // "table-row-background-selected" and "table-row-background-focused-selected"
      // are inspired by the colors of the selection decorator
      "table-focus-indicator": "#0880EF",
      "table-row-background-focused-selected": "#084FAB",
      "table-row-background-focused": "#80B4EF",
      "table-row-background-selected": "#084FAB",
      // equal to "background-pane" and "background-odd"
      "table-row-background-even": "#F3F3F3",
      "table-row-background-odd": "#E4E4E4",
      // equal to "text-selected" and "text-label"
      "table-row-selected": "#fffefe",
      "table-row": "#1a1a1a",
      // equal to "border-column"
      "table-row-line": "#CCC",
      "table-column-line": "#CCC",
      "table-header-hovered": "white",

      /*
      ---------------------------------------------------------------------------
        PROGRESSIVE TABLE COLORS
      ---------------------------------------------------------------------------
      */
      "progressive-table-header": "#AAAAAA",
      "progressive-table-header-border-right": "#F2F2F2",
      "progressive-table-row-background-even": "#F4F4F4",
      "progressive-table-row-background-odd": "#E4E4E4",
      "progressive-progressbar-background": "gray",
      "progressive-progressbar-indicator-done": "#CCCCCC",
      "progressive-progressbar-indicator-undone": "white",
      "progressive-progressbar-percent-background": "gray",
      "progressive-progressbar-percent-text": "white",

      /*
      ---------------------------------------------------------------------------
        CSS ONLY COLORS
      ---------------------------------------------------------------------------
      */
      "selected-start": "#004DAD",
      "selected-end": "#00368A",
      "background-selected": "#00368A",
      "tabview-background": "#07125A",
      "shadow": qx.core.Environment.get("css.rgba") ? "rgba(0, 0, 0, 0.4)" : "#999999",
      "pane-start": "#FBFBFB",
      "pane-end": "#F0F0F0",
      "group-background": "#E8E8E8",
      "group-border": "#B4B4B4",
      "radiobutton-background": "#EFEFEF",
      "checkbox-border": "#314A6E",
      "checkbox-focus": "#87AFE7",
      "checkbox-hovered": "#B2D2FF",
      "checkbox-hovered-inner": "#D1E4FF",
      "checkbox-inner": "#EEEEEE",
      "checkbox-start": "#E4E4E4",
      "checkbox-end": "#F3F3F3",
      "checkbox-disabled-border": "#787878",
      "checkbox-disabled-inner": "#CACACA",
      "checkbox-disabled-start": "#D0D0D0",
      "checkbox-disabled-end": "#D8D8D8",
      "checkbox-hovered-inner-invalid": "#FAF2F2",
      "checkbox-hovered-invalid": "#F7E9E9",
      "radiobutton-checked": "#005BC3",
      "radiobutton-disabled": "#D5D5D5",
      "radiobutton-checked-disabled": "#7B7B7B",
      "radiobutton-hovered-invalid": "#F7EAEA",
      "tooltip-error": "#C82C2C",
      "scrollbar-start": "#CCCCCC",
      "scrollbar-end": "#F1F1F1",
      "scrollbar-slider-start": "#EEEEEE",
      "scrollbar-slider-end": "#C3C3C3",
      "button-border-disabled": "#959595",
      "button-start": "#F0F0F0",
      "button-end": "#AFAFAF",
      "button-disabled-start": "#F4F4F4",
      "button-disabled-end": "#BABABA",
      "button-hovered-start": "#F0F9FE",
      "button-hovered-end": "#8EB8D6",
      "button-focused": "#83BAEA",
      "border-invalid": "#930000",
      "input-start": "#F0F0F0",
      "input-end": "#FBFCFB",
      "input-focused-start": "#D7E7F4",
      "input-focused-end": "#5CB0FD",
      "input-focused-inner-invalid": "#FF6B78",
      "input-border-disabled": "#9B9B9B",
      "input-border-inner": "white",
      "toolbar-start": "#EFEFEF",
      "toolbar-end": "#DDDDDD",
      "window-border": "#00204D",
      "window-border-caption": "#727272",
      "window-caption-active-text": "white",
      "window-caption-active-start": "#084FAA",
      "window-caption-active-end": "#003B91",
      "window-caption-inactive-start": "#F2F2F2",
      "window-caption-inactive-end": "#DBDBDB",
      "window-statusbar-background": "#EFEFEF",
      "tabview-start": "#FCFCFC",
      "tabview-end": "#EEEEEE",
      "tabview-inactive": "#777D8D",
      "tabview-inactive-start": "#EAEAEA",
      "tabview-inactive-end": "#CECECE",
      "table-header-start": "#E8E8E8",
      "table-header-end": "#B3B3B3",
      "menu-start": "#E8E8E9",
      "menu-end": "#D9D9D9",
      "menubar-start": "#E8E8E8",
      "groupitem-start": "#A7A7A7",
      "groupitem-end": "#949494",
      "groupitem-text": "white",
      "virtual-row-layer-background-even": "white",
      "virtual-row-layer-background-odd": "white"
    }
  });
  qx.theme.modern.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fabian Jakobs (fjakobs)
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Alexander Steitz (aback)
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   * The modern decoration theme.
   *
   * @asset(qx/decoration/Modern/toolbar/toolbar-part.gif)
   */
  qx.Theme.define("qx.theme.modern.Decoration", {
    aliases: {
      decoration: "qx/decoration/Modern"
    },
    decorations: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "main": {
        style: {
          width: 1,
          color: "border-main"
        }
      },
      "selected": {
        style: {
          startColorPosition: 0,
          endColorPosition: 100,
          startColor: "selected-start",
          endColor: "selected-end"
        }
      },
      "dragover": {
        style: {
          bottom: [2, "solid", "border-dragover"]
        }
      },
      "pane": {
        style: {
          width: 1,
          color: "tabview-background",
          radius: 3,
          shadowColor: "shadow",
          shadowBlurRadius: 2,
          shadowLength: 0,
          gradientStart: ["pane-start", 0],
          gradientEnd: ["pane-end", 100]
        }
      },
      "group": {
        style: {
          backgroundColor: "group-background",
          radius: 4,
          color: "group-border",
          width: 1
        }
      },
      "keyboard-focus": {
        style: {
          width: 1,
          color: "keyboard-focus",
          style: "dotted"
        }
      },

      /*
      ---------------------------------------------------------------------------
        RADIO BUTTON
      ---------------------------------------------------------------------------
      */
      "radiobutton": {
        style: {
          backgroundColor: "radiobutton-background",
          radius: 5,
          width: 1,
          innerWidth: 2,
          color: "checkbox-border",
          innerColor: "radiobutton-background",
          shadowLength: 0,
          shadowBlurRadius: 0,
          shadowColor: "checkbox-focus"
        }
      },
      "radiobutton-checked": {
        include: "radiobutton",
        style: {
          backgroundColor: "radiobutton-checked"
        }
      },
      "radiobutton-checked-focused": {
        include: "radiobutton-checked",
        style: {
          shadowBlurRadius: 4
        }
      },
      "radiobutton-checked-hovered": {
        include: "radiobutton-checked",
        style: {
          innerColor: "checkbox-hovered"
        }
      },
      "radiobutton-focused": {
        include: "radiobutton",
        style: {
          shadowBlurRadius: 4
        }
      },
      "radiobutton-hovered": {
        include: "radiobutton",
        style: {
          backgroundColor: "checkbox-hovered",
          innerColor: "checkbox-hovered"
        }
      },
      "radiobutton-disabled": {
        include: "radiobutton",
        style: {
          innerColor: "radiobutton-disabled",
          backgroundColor: "radiobutton-disabled",
          color: "checkbox-disabled-border"
        }
      },
      "radiobutton-checked-disabled": {
        include: "radiobutton-disabled",
        style: {
          backgroundColor: "radiobutton-checked-disabled"
        }
      },
      "radiobutton-invalid": {
        include: "radiobutton",
        style: {
          color: "invalid"
        }
      },
      "radiobutton-checked-invalid": {
        include: "radiobutton-checked",
        style: {
          color: "invalid"
        }
      },
      "radiobutton-checked-focused-invalid": {
        include: "radiobutton-checked-focused",
        style: {
          color: "invalid",
          shadowColor: "invalid"
        }
      },
      "radiobutton-checked-hovered-invalid": {
        include: "radiobutton-checked-hovered",
        style: {
          color: "invalid",
          innerColor: "radiobutton-hovered-invalid"
        }
      },
      "radiobutton-focused-invalid": {
        include: "radiobutton-focused",
        style: {
          color: "invalid",
          shadowColor: "invalid"
        }
      },
      "radiobutton-hovered-invalid": {
        include: "radiobutton-hovered",
        style: {
          color: "invalid",
          innerColor: "radiobutton-hovered-invalid",
          backgroundColor: "radiobutton-hovered-invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        SEPARATOR
      ---------------------------------------------------------------------------
      */
      "separator-horizontal": {
        style: {
          widthLeft: 1,
          colorLeft: "border-separator"
        }
      },
      "separator-vertical": {
        style: {
          widthTop: 1,
          colorTop: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLTIP
      ---------------------------------------------------------------------------
      */
      "tooltip-error": {
        style: {
          backgroundColor: "tooltip-error",
          radius: 4,
          shadowColor: "shadow",
          shadowBlurRadius: 2,
          shadowLength: 1
        }
      },

      /*
      ---------------------------------------------------------------------------
        POPUP
      ---------------------------------------------------------------------------
      */
      "popup": {
        style: {
          width: 1,
          color: "border-main",
          shadowColor: "shadow",
          shadowBlurRadius: 3,
          shadowLength: 1
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar-horizontal": {
        style: {
          gradientStart: ["scrollbar-start", 0],
          gradientEnd: ["scrollbar-end", 100]
        }
      },
      "scrollbar-vertical": {
        include: "scrollbar-horizontal",
        style: {
          orientation: "horizontal"
        }
      },
      "scrollbar-slider-horizontal": {
        style: {
          gradientStart: ["scrollbar-slider-start", 0],
          gradientEnd: ["scrollbar-slider-end", 100],
          color: "border-main",
          width: 1,
          radius: 3
        }
      },
      "scrollbar-slider-vertical": {
        include: "scrollbar-slider-horizontal",
        style: {
          orientation: "horizontal"
        }
      },
      "scrollbar-slider-horizontal-disabled": {
        include: "scrollbar-slider-horizontal",
        style: {
          color: "button-border-disabled"
        }
      },
      "scrollbar-slider-vertical-disabled": {
        include: "scrollbar-slider-vertical",
        style: {
          color: "button-border-disabled"
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button": {
        style: {
          radius: 3,
          color: "border-button",
          width: 1,
          startColor: "button-start",
          endColor: "button-end",
          startColorPosition: 35,
          endColorPosition: 100
        }
      },
      "button-disabled": {
        include: "button",
        style: {
          color: "button-border-disabled",
          startColor: "button-disabled-start",
          endColor: "button-disabled-end"
        }
      },
      "button-hovered": {
        include: "button",
        style: {
          startColor: "button-hovered-start",
          endColor: "button-hovered-end"
        }
      },
      "button-checked": {
        include: "button",
        style: {
          endColor: "button-start",
          startColor: "button-end"
        }
      },
      "button-pressed": {
        include: "button",
        style: {
          endColor: "button-hovered-start",
          startColor: "button-hovered-end"
        }
      },
      "button-focused": {
        style: {
          radius: 3,
          color: "border-button",
          width: 1,
          innerColor: "button-focused",
          innerWidth: 2,
          startColor: "button-start",
          endColor: "button-end",
          startColorPosition: 30,
          endColorPosition: 100
        }
      },
      "button-checked-focused": {
        include: "button-focused",
        style: {
          endColor: "button-start",
          startColor: "button-end"
        }
      },
      // invalid
      "button-invalid": {
        include: "button",
        style: {
          color: "border-invalid"
        }
      },
      "button-disabled-invalid": {
        include: "button-disabled",
        style: {
          color: "border-invalid"
        }
      },
      "button-hovered-invalid": {
        include: "button-hovered",
        style: {
          color: "border-invalid"
        }
      },
      "button-checked-invalid": {
        include: "button-checked",
        style: {
          color: "border-invalid"
        }
      },
      "button-pressed-invalid": {
        include: "button-pressed",
        style: {
          color: "border-invalid"
        }
      },
      "button-focused-invalid": {
        include: "button-focused",
        style: {
          color: "border-invalid"
        }
      },
      "button-checked-focused-invalid": {
        include: "button-checked-focused",
        style: {
          color: "border-invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        CHECK BOX
      ---------------------------------------------------------------------------
      */
      "checkbox": {
        style: {
          width: 1,
          color: "checkbox-border",
          innerWidth: 1,
          innerColor: "checkbox-inner",
          backgroundColor: "checkbox-end",
          shadowLength: 0,
          shadowBlurRadius: 0,
          shadowColor: "checkbox-focus"
        }
      },
      "checkbox-hovered": {
        include: "checkbox",
        style: {
          innerColor: "checkbox-hovered-inner",
          backgroundColor: "checkbox-hovered"
        }
      },
      "checkbox-focused": {
        include: "checkbox",
        style: {
          shadowBlurRadius: 4
        }
      },
      "checkbox-disabled": {
        include: "checkbox",
        style: {
          color: "checkbox-disabled-border",
          innerColor: "checkbox-disabled-inner",
          backgroundColor: "checkbox-disabled-end"
        }
      },
      "checkbox-invalid": {
        include: "checkbox",
        style: {
          color: "invalid"
        }
      },
      "checkbox-hovered-invalid": {
        include: "checkbox-hovered",
        style: {
          color: "invalid",
          innerColor: "checkbox-hovered-inner-invalid",
          backgroundColor: "checkbox-hovered-invalid"
        }
      },
      "checkbox-focused-invalid": {
        include: "checkbox-focused",
        style: {
          color: "invalid",
          shadowColor: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TEXT FIELD
      ---------------------------------------------------------------------------
      */
      "input": {
        style: {
          color: "border-input",
          innerColor: "border-inner-input",
          innerWidth: 1,
          width: 1,
          backgroundColor: "background-light",
          startColor: "input-start",
          endColor: "input-end",
          startColorPosition: 0,
          endColorPosition: 12,
          colorPositionUnit: "px"
        }
      },
      "border-invalid": {
        include: "input",
        style: {
          color: "border-invalid"
        }
      },
      "input-focused": {
        include: "input",
        style: {
          startColor: "input-focused-start",
          innerColor: "input-focused-end",
          endColorPosition: 4
        }
      },
      "input-focused-invalid": {
        include: "input-focused",
        style: {
          innerColor: "input-focused-inner-invalid",
          color: "border-invalid"
        }
      },
      "input-disabled": {
        include: "input",
        style: {
          color: "input-border-disabled"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar": {
        style: {
          startColorPosition: 40,
          endColorPosition: 60,
          startColor: "toolbar-start",
          endColor: "toolbar-end"
        }
      },
      "toolbar-button-hovered": {
        style: {
          color: "border-toolbar-button-outer",
          width: 1,
          innerWidth: 1,
          innerColor: "border-toolbar-border-inner",
          radius: 2,
          gradientStart: ["button-start", 30],
          gradientEnd: ["button-end", 100]
        }
      },
      "toolbar-button-checked": {
        include: "toolbar-button-hovered",
        style: {
          gradientStart: ["button-end", 30],
          gradientEnd: ["button-start", 100]
        }
      },
      "toolbar-separator": {
        style: {
          widthLeft: 1,
          widthRight: 1,
          colorLeft: "border-toolbar-separator-left",
          colorRight: "border-toolbar-separator-right",
          styleLeft: "solid",
          styleRight: "solid"
        }
      },
      "toolbar-part": {
        style: {
          backgroundImage: "decoration/toolbar/toolbar-part.gif",
          backgroundRepeat: "repeat-y"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview-pane": {
        style: {
          width: 1,
          color: "window-border",
          radius: 3,
          gradientStart: ["tabview-start", 90],
          gradientEnd: ["tabview-end", 100]
        }
      },
      "tabview-page-button-top-active": {
        style: {
          radius: [3, 3, 0, 0],
          width: [1, 1, 0, 1],
          color: "tabview-background",
          backgroundColor: "tabview-start",
          shadowLength: 1,
          shadowColor: "shadow",
          shadowBlurRadius: 2
        }
      },
      "tabview-page-button-top-inactive": {
        style: {
          radius: [3, 3, 0, 0],
          color: "tabview-inactive",
          colorBottom: "tabview-background",
          width: 1,
          gradientStart: ["tabview-inactive-start", 0],
          gradientEnd: ["tabview-inactive-end", 100]
        }
      },
      "tabview-page-button-bottom-active": {
        include: "tabview-page-button-top-active",
        style: {
          radius: [0, 0, 3, 3],
          width: [0, 1, 1, 1],
          backgroundColor: "tabview-inactive-start",
          shadowLength: 0,
          shadowBlurRadius: 0
        }
      },
      "tabview-page-button-bottom-inactive": {
        include: "tabview-page-button-top-inactive",
        style: {
          radius: [0, 0, 3, 3],
          width: [0, 1, 1, 1],
          colorBottom: "tabview-inactive",
          colorTop: "tabview-background"
        }
      },
      "tabview-page-button-left-active": {
        include: "tabview-page-button-top-active",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1],
          shadowLength: 0,
          shadowBlurRadius: 0
        }
      },
      "tabview-page-button-left-inactive": {
        include: "tabview-page-button-top-inactive",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1],
          colorBottom: "tabview-inactive",
          colorRight: "tabview-background"
        }
      },
      "tabview-page-button-right-active": {
        include: "tabview-page-button-top-active",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0],
          shadowLength: 0,
          shadowBlurRadius: 0
        }
      },
      "tabview-page-button-right-inactive": {
        include: "tabview-page-button-top-inactive",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0],
          colorBottom: "tabview-inactive",
          colorLeft: "tabview-background"
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane": {
        style: {
          backgroundColor: "background-pane",
          width: 3,
          color: "background-splitpane",
          style: "solid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: {
          radius: [5, 5, 0, 0],
          shadowBlurRadius: 4,
          shadowLength: 2,
          shadowColor: "shadow"
        }
      },
      "window-incl-statusbar": {
        include: "window",
        style: {
          radius: [5, 5, 5, 5]
        }
      },
      "window-resize-frame": {
        style: {
          radius: [5, 5, 0, 0],
          width: 1,
          color: "border-main"
        }
      },
      "window-resize-frame-incl-statusbar": {
        include: "window-resize-frame",
        style: {
          radius: [5, 5, 5, 5]
        }
      },
      "window-captionbar-active": {
        style: {
          width: 1,
          color: "window-border",
          colorBottom: "window-border-caption",
          radius: [5, 5, 0, 0],
          gradientStart: ["window-caption-active-start", 30],
          gradientEnd: ["window-caption-active-end", 70]
        }
      },
      "window-captionbar-inactive": {
        include: "window-captionbar-active",
        style: {
          gradientStart: ["window-caption-inactive-start", 30],
          gradientEnd: ["window-caption-inactive-end", 70]
        }
      },
      "window-statusbar": {
        style: {
          backgroundColor: "window-statusbar-background",
          width: [0, 1, 1, 1],
          color: "window-border",
          radius: [0, 0, 5, 5]
        }
      },
      "window-pane": {
        style: {
          backgroundColor: "background-pane",
          width: 1,
          color: "window-border",
          widthTop: 0
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table": {
        style: {
          width: 1,
          color: "border-main",
          style: "solid"
        }
      },
      "table-statusbar": {
        style: {
          widthTop: 1,
          colorTop: "border-main",
          style: "solid"
        }
      },
      "table-scroller-header": {
        style: {
          gradientStart: ["table-header-start", 10],
          gradientEnd: ["table-header-end", 90],
          widthBottom: 1,
          colorBottom: "border-main"
        }
      },
      "table-header-cell": {
        style: {
          widthRight: 1,
          colorRight: "border-separator",
          styleRight: "solid"
        }
      },
      "table-header-cell-hovered": {
        style: {
          widthRight: 1,
          colorRight: "border-separator",
          styleRight: "solid",
          widthBottom: 1,
          colorBottom: "table-header-hovered",
          styleBottom: "solid"
        }
      },
      "table-scroller-focus-indicator": {
        style: {
          width: 2,
          color: "table-focus-indicator",
          style: "solid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSIVE
      ---------------------------------------------------------------------------
      */
      "progressive-table-header": {
        style: {
          width: 1,
          color: "border-main",
          style: "solid"
        }
      },
      "progressive-table-header-cell": {
        style: {
          gradientStart: ["table-header-start", 10],
          gradientEnd: ["table-header-end", 90],
          widthRight: 1,
          colorRight: "progressive-table-header-border-right"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        style: {
          gradientStart: ["menu-start", 0],
          gradientEnd: ["menu-end", 100],
          shadowColor: "shadow",
          shadowBlurRadius: 2,
          shadowLength: 1,
          width: 1,
          color: "border-main"
        }
      },
      "menu-separator": {
        style: {
          widthTop: 1,
          colorTop: "menu-separator-top",
          widthBottom: 1,
          colorBottom: "menu-separator-bottom"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar": {
        style: {
          gradientStart: ["menubar-start", 0],
          gradientEnd: ["menu-end", 100],
          width: 1,
          color: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header": {
        style: {
          gradientStart: ["#243B58", 0],
          gradientEnd: ["#1D2D45", 100]
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: {
          width: 1,
          color: "border-input"
        }
      },

      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "group-item": {
        style: {
          startColorPosition: 0,
          endColorPosition: 100,
          startColor: "groupitem-start",
          endColor: "groupitem-end"
        }
      }
    }
  });
  qx.theme.modern.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.OperatingSystem": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "os.name": {
          "load": true,
          "className": "qx.bom.client.OperatingSystem"
        },
        "os.version": {
          "load": true,
          "className": "qx.bom.client.OperatingSystem"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
  
  ************************************************************************* */

  /**
   * The modern font theme.
   */
  qx.Theme.define("qx.theme.modern.Font", {
    fonts: {
      "default": {
        size: qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? 12 : 11,
        lineHeight: 1.4,
        family: qx.core.Environment.get("os.name") == "osx" ? ["Lucida Grande"] : qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? ["Segoe UI", "Candara"] : ["Tahoma", "Liberation Sans", "Arial", "sans-serif"]
      },
      "bold": {
        size: qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? 12 : 11,
        lineHeight: 1.4,
        family: qx.core.Environment.get("os.name") == "osx" ? ["Lucida Grande"] : qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? ["Segoe UI", "Candara"] : ["Tahoma", "Liberation Sans", "Arial", "sans-serif"],
        bold: true
      },
      "small": {
        size: qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? 11 : 10,
        lineHeight: 1.4,
        family: qx.core.Environment.get("os.name") == "osx" ? ["Lucida Grande"] : qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? ["Segoe UI", "Candara"] : ["Tahoma", "Liberation Sans", "Arial", "sans-serif"]
      },
      "monospace": {
        size: 11,
        lineHeight: 1.4,
        family: qx.core.Environment.get("os.name") == "osx" ? ["Lucida Console", "Monaco"] : qx.core.Environment.get("os.name") == "win" && (qx.core.Environment.get("os.version") == "7" || qx.core.Environment.get("os.version") == "vista") ? ["Consolas"] : ["Consolas", "DejaVu Sans Mono", "Courier New", "monospace"]
      }
    }
  });
  qx.theme.modern.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Fabian Jakobs (fjakobs)
     * Alexander Steitz (aback)
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The modern appearance theme.
   *
   * @asset(qx/icon/${qx.icontheme}/16/places/folder-open.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder.png)
   * @asset(qx/icon/${qx.icontheme}/16/mimetypes/office-document.png)
  
   * @asset(qx/icon/${qx.icontheme}/16/actions/window-close.png)
  
   * @asset(qx/icon/${qx.icontheme}/22/places/folder-open.png)
   * @asset(qx/icon/${qx.icontheme}/22/places/folder.png)
   * @asset(qx/icon/${qx.icontheme}/22/mimetypes/office-document.png)
  
   * @asset(qx/icon/${qx.icontheme}/32/places/folder-open.png)
   * @asset(qx/icon/${qx.icontheme}/32/places/folder.png)
   * @asset(qx/icon/${qx.icontheme}/32/mimetypes/office-document.png)
  
   * @asset(qx/icon/${qx.icontheme}/16/apps/office-calendar.png)
   * @asset(qx/icon/${qx.icontheme}/16/apps/utilities-color-chooser.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/view-refresh.png)
  
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-cancel.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-ok.png)
  
   * @asset(qx/decoration/Modern/cursors/*)
   *
   * @asset(qx/decoration/Modern/scrollbar/scrollbar-left.png)
   * @asset(qx/decoration/Modern/scrollbar/scrollbar-right.png)
   * @asset(qx/decoration/Modern/scrollbar/scrollbar-up.png)
   * @asset(qx/decoration/Modern/scrollbar/scrollbar-down.png)
   *
   * @asset(qx/decoration/Modern/toolbar/toolbar-handle-knob.gif)
   *
   * @asset(qx/decoration/Modern/tree/open-selected.png)
   * @asset(qx/decoration/Modern/tree/closed-selected.png)
   * @asset(qx/decoration/Modern/tree/open.png)
   * @asset(qx/decoration/Modern/tree/closed.png)
   *
   * @asset(qx/decoration/Modern/form/checked.png)
   * @asset(qx/decoration/Modern/form/undetermined.png)
   * @asset(qx/decoration/Modern/form/tooltip-error-arrow-right.png)
   * @asset(qx/decoration/Modern/form/tooltip-error-arrow.png)
   *
   * @asset(qx/decoration/Modern/window/minimize-active-hovered.png)
   * @asset(qx/decoration/Modern/window/minimize-active.png)
   * @asset(qx/decoration/Modern/window/minimize-inactive.png)
   * @asset(qx/decoration/Modern/window/restore-active-hovered.png)
   * @asset(qx/decoration/Modern/window/restore-active.png)
   * @asset(qx/decoration/Modern/window/restore-inactive.png)
   * @asset(qx/decoration/Modern/window/maximize-active-hovered.png)
   * @asset(qx/decoration/Modern/window/maximize-active.png)
   * @asset(qx/decoration/Modern/window/maximize-inactive.png)
   * @asset(qx/decoration/Modern/window/close-active-hovered.png)
   * @asset(qx/decoration/Modern/window/close-active.png)
   * @asset(qx/decoration/Modern/window/close-inactive.png)
   *
   * @asset(qx/decoration/Modern/splitpane/knob-horizontal.png)
   * @asset(qx/decoration/Modern/splitpane/knob-vertical.png)
   *
   * @asset(qx/decoration/Modern/arrows/down.png)
   * @asset(qx/decoration/Modern/arrows/up.png)
   * @asset(qx/decoration/Modern/arrows/right.png)
   * @asset(qx/decoration/Modern/arrows/left.png)
   * @asset(qx/decoration/Modern/arrows/rewind.png)
   * @asset(qx/decoration/Modern/arrows/forward.png)
   * @asset(qx/decoration/Modern/arrows/up-invert.png)
   * @asset(qx/decoration/Modern/arrows/down-invert.png)
   * @asset(qx/decoration/Modern/arrows/right-invert.png)
   * @asset(qx/decoration/Modern/arrows/up-small.png)
   * @asset(qx/decoration/Modern/arrows/down-small.png)
   *
   * @asset(qx/decoration/Modern/menu/checkbox-invert.gif)
   * @asset(qx/decoration/Modern/menu/checkbox.gif)
   * @asset(qx/decoration/Modern/menu/radiobutton-invert.gif)
   * @asset(qx/decoration/Modern/menu/radiobutton.gif)
   *
   * @asset(qx/decoration/Modern/table/select-column-order.png)
   * @asset(qx/decoration/Modern/table/ascending.png)
   * @asset(qx/decoration/Modern/table/descending.png)
   * @asset(qx/decoration/Modern/table/boolean-true.png)
   * @asset(qx/decoration/Modern/table/boolean-false.png)
   *
   * @asset(qx/static/blank.gif)
   * @asset(qx/static/blank.png)
   *
   * @asset(qx/decoration/Modern/colorselector/*)
   */
  qx.Theme.define("qx.theme.modern.Appearance", {
    appearances: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "widget": {},
      "root": {
        style: function style(states) {
          return {
            backgroundColor: "background-application",
            textColor: "text-label",
            font: "default"
          };
        }
      },
      "label": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "move-frame": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },
      "resize-frame": "move-frame",
      "dragdrop-cursor": {
        style: function style(states) {
          var icon = "nodrop";

          if (states.copy) {
            icon = "copy";
          } else if (states.move) {
            icon = "move";
          } else if (states.alias) {
            icon = "alias";
          }

          return {
            source: "decoration/cursors/" + icon + ".gif",
            position: "right-top",
            offset: [2, 16, 2, 6]
          };
        }
      },
      "image": {
        style: function style(states) {
          return {
            opacity: !states.replacement && states.disabled ? 0.3 : 1
          };
        }
      },
      "atom": {},
      "atom/label": "label",
      "atom/icon": "image",
      "popup": {
        style: function style(states) {
          return {
            decorator: "popup",
            backgroundColor: "background-light"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button-frame": {
        alias: "atom",
        style: function style(states) {
          var decorator, textColor;
          var padding = [3, 9]; // default padding

          if (states.checked && states.focused && !states.inner) {
            decorator = "button-checked-focused";
            textColor = undefined;
            padding = [1, 7];
          } else if (states.disabled) {
            decorator = "button-disabled";
            textColor = undefined;
          } else if (states.pressed) {
            decorator = "button-pressed";
            textColor = "text-hovered";
          } else if (states.checked) {
            decorator = "button-checked";
            textColor = undefined;
          } else if (states.hovered) {
            decorator = "button-hovered";
            textColor = "text-hovered";
          } else if (states.focused && !states.inner) {
            decorator = "button-focused";
            textColor = undefined;
            padding = [1, 7];
          } else {
            decorator = "button";
            textColor = undefined;
          }

          if (states.invalid && !states.disabled) {
            decorator += "-invalid";
          }

          return {
            decorator: decorator,
            textColor: textColor,
            padding: padding,
            margin: [1, 0]
          };
        }
      },
      "button-frame/image": {
        style: function style(states) {
          return {
            opacity: !states.replacement && states.disabled ? 0.5 : 1
          };
        }
      },
      "button": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          return {
            center: true
          };
        }
      },
      "toggle-button": "button",
      "hover-button": {
        alias: "atom",
        include: "atom",
        style: function style(states) {
          var decorator = states.hovered ? "selected" : undefined;
          return {
            decorator: decorator,
            textColor: states.hovered ? "text-selected" : undefined
          };
        }
      },
      "menubutton": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.png",
            iconPosition: "right"
          };
        }
      },
      "splitbutton": {},
      "splitbutton/button": "button",
      "splitbutton/arrow": {
        alias: "button",
        include: "button",
        style: function style(states, superStyles) {
          return {
            icon: "decoration/arrows/down.png",
            padding: [superStyles.padding[0], superStyles.padding[1] - 6],
            marginLeft: 1
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        FORM FIELDS
      ---------------------------------------------------------------------------
      */
      "form-renderer-label": {
        include: "label",
        style: function style() {
          return {
            paddingTop: 4
          };
        }
      },
      "checkbox": {
        alias: "atom",
        style: function style(states) {
          var icon;

          if (states.checked) {
            icon = "decoration/form/checked.png";
          } else if (states.undetermined) {
            icon = "decoration/form/undetermined.png";
          } else {
            icon = "qx/static/blank.gif";
          }

          return {
            icon: icon,
            minWidth: 14,
            gap: 8,
            paddingLeft: 2
          };
        }
      },
      "checkbox/icon": {
        style: function style(states) {
          var decorator;

          if (states.disabled) {
            decorator = "checkbox-disabled";
          } else if (states.focused) {
            decorator = "checkbox-focused";
          } else if (states.hovered) {
            decorator = "checkbox-hovered";
          } else {
            decorator = "checkbox";
          }

          decorator += states.invalid && !states.disabled ? "-invalid" : "";
          var padding = states.undetermined ? [3, 1] : 1;
          return {
            decorator: decorator,
            padding: padding,
            width: 10,
            height: 10
          };
        }
      },
      "radiobutton": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: "qx/static/blank.png",
            gap: 8,
            paddingLeft: 2
          };
        }
      },
      "radiobutton/icon": {
        style: function style(states) {
          var decorator;

          if (states.disabled && !states.checked) {
            decorator = "radiobutton-disabled";
          } else if (states.checked && states.focused) {
            decorator = "radiobutton-checked-focused";
          } else if (states.checked && states.disabled) {
            decorator = "radiobutton-checked-disabled";
          } else if (states.checked && states.hovered) {
            decorator = "radiobutton-checked-hovered";
          } else if (states.checked) {
            decorator = "radiobutton-checked";
          } else if (states.focused) {
            decorator = "radiobutton-focused";
          } else if (states.hovered) {
            decorator = "radiobutton-hovered";
          } else {
            decorator = "radiobutton";
          }

          decorator += states.invalid && !states.disabled ? "-invalid" : "";
          return {
            decorator: decorator,
            width: 10,
            height: 10
          };
        }
      },
      "textfield": {
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          var textColor;

          if (states.disabled) {
            textColor = "text-disabled";
          } else if (states.showingPlaceholder) {
            textColor = "text-placeholder";
          } else {
            textColor = "text-input";
          }

          return {
            decorator: decorator,
            padding: [2, 4, 1],
            textColor: textColor
          };
        }
      },
      "textarea": {
        include: "textfield",
        style: function style(states) {
          return {
            padding: 4
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPINNER
      ---------------------------------------------------------------------------
      */
      "spinner": {
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          return {
            decorator: decorator
          };
        }
      },
      "spinner/textfield": {
        style: function style(states) {
          return {
            marginRight: 2,
            padding: [2, 4, 1],
            textColor: states.disabled ? "text-disabled" : "text-input"
          };
        }
      },
      "spinner/upbutton": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states, superStyles) {
          return {
            icon: "decoration/arrows/up-small.png",
            padding: [superStyles.padding[0] - 1, superStyles.padding[1] - 5],
            margin: 0
          };
        }
      },
      "spinner/downbutton": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states, superStyles) {
          return {
            icon: "decoration/arrows/down-small.png",
            padding: [superStyles.padding[0] - 1, superStyles.padding[1] - 5],
            margin: 0
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATEFIELD
      ---------------------------------------------------------------------------
      */
      "datefield": "combobox",
      "datefield/button": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          return {
            icon: "icon/16/apps/office-calendar.png",
            padding: [0, 3],
            decorator: undefined
          };
        }
      },
      "datefield/textfield": "combobox/textfield",
      "datefield/list": {
        alias: "datechooser",
        include: "datechooser",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "groupbox": {
        style: function style(states) {
          return {
            legendPosition: "top"
          };
        }
      },
      "groupbox/legend": {
        alias: "atom",
        style: function style(states) {
          return {
            padding: [1, 0, 1, 4],
            textColor: states.invalid ? "invalid" : "text-title",
            font: "bold"
          };
        }
      },
      "groupbox/frame": {
        style: function style(states) {
          return {
            padding: 10,
            margin: 1,
            decorator: "group"
          };
        }
      },
      "check-groupbox": "groupbox",
      "check-groupbox/legend": {
        alias: "checkbox",
        include: "checkbox",
        style: function style(states) {
          return {
            padding: [1, 0, 1, 4],
            textColor: states.invalid ? "invalid" : "text-title",
            font: "bold"
          };
        }
      },
      "radio-groupbox": "groupbox",
      "radio-groupbox/legend": {
        alias: "radiobutton",
        include: "radiobutton",
        style: function style(states) {
          return {
            padding: [1, 0, 1, 4],
            textColor: states.invalid ? "invalid" : "text-title",
            font: "bold"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLLAREA
      ---------------------------------------------------------------------------
      */
      "scrollarea": "widget",
      "scrollarea/corner": {
        style: function style(states) {
          return {
            backgroundColor: "background-application"
          };
        }
      },
      "scrollarea/pane": "widget",
      "scrollarea/scrollbar-x": "scrollbar",
      "scrollarea/scrollbar-y": "scrollbar",

      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar": {
        style: function style(states) {
          if (states["native"]) {
            return {};
          }

          return {
            width: states.horizontal ? undefined : 16,
            height: states.horizontal ? 16 : undefined,
            decorator: states.horizontal ? "scrollbar-horizontal" : "scrollbar-vertical",
            padding: 1
          };
        }
      },
      "scrollbar/slider": {
        alias: "slider",
        style: function style(states) {
          return {
            padding: states.horizontal ? [0, 1, 0, 1] : [1, 0, 1, 0]
          };
        }
      },
      "scrollbar/slider/knob": {
        include: "button-frame",
        style: function style(states) {
          var decorator = states.horizontal ? "scrollbar-slider-horizontal" : "scrollbar-slider-vertical";

          if (states.disabled) {
            decorator += "-disabled";
          }

          return {
            decorator: decorator,
            minHeight: states.horizontal ? undefined : 9,
            minWidth: states.horizontal ? 9 : undefined,
            padding: undefined,
            margin: 0
          };
        }
      },
      "scrollbar/button": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          var icon = "decoration/scrollbar/scrollbar-";

          if (states.left) {
            icon += "left.png";
          } else if (states.right) {
            icon += "right.png";
          } else if (states.up) {
            icon += "up.png";
          } else {
            icon += "down.png";
          }

          if (states.left || states.right) {
            var paddingLeft = states.left ? 3 : 4;
            return {
              padding: [3, 0, 3, paddingLeft],
              icon: icon,
              width: 15,
              height: 14,
              margin: 0
            };
          } else {
            return {
              padding: 3,
              icon: icon,
              width: 14,
              height: 15,
              margin: 0
            };
          }
        }
      },
      "scrollbar/button-begin": "scrollbar/button",
      "scrollbar/button-end": "scrollbar/button",

      /*
      ---------------------------------------------------------------------------
        SLIDER
      ---------------------------------------------------------------------------
      */
      "slider": {
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          return {
            decorator: decorator
          };
        }
      },
      "slider/knob": {
        include: "button-frame",
        style: function style(states) {
          return {
            decorator: states.disabled ? "scrollbar-slider-horizontal-disabled" : "scrollbar-slider-horizontal",
            height: 14,
            width: 14,
            padding: 0,
            margin: 0
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        LIST
      ---------------------------------------------------------------------------
      */
      "list": {
        alias: "scrollarea",
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          return {
            backgroundColor: "background-light",
            decorator: decorator
          };
        }
      },
      "list/pane": "widget",
      "listitem": {
        alias: "atom",
        style: function style(states) {
          return {
            padding: states.dragover ? [4, 4, 2, 4] : 4,
            textColor: states.selected ? "text-selected" : undefined,
            decorator: states.selected ? "selected" : undefined,
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDEBAR
      ---------------------------------------------------------------------------
      */
      "slidebar": {},
      "slidebar/scrollpane": {},
      "slidebar/content": {},
      "slidebar/button-forward": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          return {
            padding: 5,
            center: true,
            icon: states.vertical ? "decoration/arrows/down.png" : "decoration/arrows/right.png"
          };
        }
      },
      "slidebar/button-backward": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          return {
            padding: 5,
            center: true,
            icon: states.vertical ? "decoration/arrows/up.png" : "decoration/arrows/left.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview": {
        style: function style(states) {
          return {
            contentPadding: 16
          };
        }
      },
      "tabview/bar": {
        alias: "slidebar",
        style: function style(states) {
          var result = {
            marginBottom: states.barTop ? -1 : 0,
            marginTop: states.barBottom ? -4 : 0,
            marginLeft: states.barRight ? -3 : 0,
            marginRight: states.barLeft ? -1 : 0,
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingLeft: 0
          };

          if (states.barTop || states.barBottom) {
            result.paddingLeft = 5;
            result.paddingRight = 7;
          } else {
            result.paddingTop = 5;
            result.paddingBottom = 7;
          }

          return result;
        }
      },
      "tabview/bar/button-forward": {
        include: "slidebar/button-forward",
        alias: "slidebar/button-forward",
        style: function style(states) {
          if (states.barTop || states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 2
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 2
            };
          }
        }
      },
      "tabview/bar/button-backward": {
        include: "slidebar/button-backward",
        alias: "slidebar/button-backward",
        style: function style(states) {
          if (states.barTop || states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 2
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 2
            };
          }
        }
      },
      "tabview/bar/scrollpane": {},
      "tabview/pane": {
        style: function style(states) {
          return {
            decorator: "tabview-pane",
            marginBottom: states.barBottom ? -1 : 0,
            marginTop: states.barTop ? -1 : 0,
            marginLeft: states.barLeft ? -1 : 0,
            marginRight: states.barRight ? -1 : 0
          };
        }
      },
      "tabview-page": {
        alias: "widget",
        include: "widget",
        style: function style(states) {
          // is used for the padding of the pane
          return {
            padding: [4, 3]
          };
        }
      },
      "tabview-page/button": {
        alias: "atom",
        style: function style(states) {
          var decorator,
              padding = 0;
          var marginTop = 0,
              marginBottom = 0,
              marginLeft = 0,
              marginRight = 0;

          if (states.checked) {
            if (states.barTop) {
              decorator = "tabview-page-button-top-active";
              padding = [5, 11];
              marginLeft = states.firstTab ? 0 : -5;
              marginRight = states.lastTab ? 0 : -5;
            } else if (states.barBottom) {
              decorator = "tabview-page-button-bottom-active";
              padding = [5, 11];
              marginLeft = states.firstTab ? 0 : -5;
              marginRight = states.lastTab ? 0 : -5;
              marginTop = 3;
            } else if (states.barRight) {
              decorator = "tabview-page-button-right-active";
              padding = [5, 10];
              marginTop = states.firstTab ? 0 : -5;
              marginBottom = states.lastTab ? 0 : -5;
              marginLeft = 2;
            } else {
              decorator = "tabview-page-button-left-active";
              padding = [5, 10];
              marginTop = states.firstTab ? 0 : -5;
              marginBottom = states.lastTab ? 0 : -5;
            }
          } else {
            if (states.barTop) {
              decorator = "tabview-page-button-top-inactive";
              padding = [3, 9];
              marginTop = 4;
              marginLeft = states.firstTab ? 5 : 1;
              marginRight = 1;
            } else if (states.barBottom) {
              decorator = "tabview-page-button-bottom-inactive";
              padding = [3, 9];
              marginBottom = 4;
              marginLeft = states.firstTab ? 5 : 1;
              marginRight = 1;
              marginTop = 3;
            } else if (states.barRight) {
              decorator = "tabview-page-button-right-inactive";
              padding = [3, 9];
              marginRight = 5;
              marginTop = states.firstTab ? 5 : 1;
              marginBottom = 1;
              marginLeft = 3;
            } else {
              decorator = "tabview-page-button-left-inactive";
              padding = [3, 9];
              marginLeft = 5;
              marginTop = states.firstTab ? 5 : 1;
              marginBottom = 1;
              marginRight = 1;
            }
          }

          return {
            zIndex: states.checked ? 10 : 5,
            decorator: decorator,
            padding: padding,
            marginTop: marginTop,
            marginBottom: marginBottom,
            marginLeft: marginLeft,
            marginRight: marginRight,
            textColor: states.disabled ? "text-disabled" : states.checked ? "text-active" : "text-inactive"
          };
        }
      },
      "tabview-page/button/label": {
        alias: "label",
        style: function style(states) {
          return {
            padding: states.focused ? [0, 1, 0, 1] : [1, 2, 1, 2],
            //margin : states.focused ? 0 : 1,
            decorator: states.focused ? "keyboard-focus" : undefined
          };
        }
      },
      "tabview-page/button/close-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: "icon/16/actions/window-close.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar": {
        style: function style(states) {
          return {
            decorator: "toolbar",
            spacing: 2
          };
        }
      },
      "toolbar/part": {
        style: function style(states) {
          return {
            decorator: "toolbar-part",
            spacing: 2
          };
        }
      },
      "toolbar/part/container": {
        style: function style(states) {
          return {
            paddingLeft: 2,
            paddingRight: 2
          };
        }
      },
      "toolbar/part/handle": {
        style: function style(states) {
          return {
            source: "decoration/toolbar/toolbar-handle-knob.gif",
            marginLeft: 3,
            marginRight: 3
          };
        }
      },
      "toolbar-button": {
        alias: "atom",
        style: function style(states) {
          var decorator;

          if (states.pressed || states.checked && !states.hovered || states.checked && states.disabled) {
            decorator = "toolbar-button-checked";
          } else if (states.hovered && !states.disabled) {
            decorator = "toolbar-button-hovered";
          }

          return {
            marginTop: 2,
            marginBottom: 2,
            padding: (states.pressed || states.checked || states.hovered) && !states.disabled || states.disabled && states.checked ? 3 : 5,
            decorator: decorator
          };
        }
      },
      "toolbar-menubutton": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          return {
            showArrow: true
          };
        }
      },
      "toolbar-menubutton/arrow": {
        alias: "image",
        include: "image",
        style: function style(states) {
          return {
            source: "decoration/arrows/down-small.png"
          };
        }
      },
      "toolbar-splitbutton": {
        style: function style(states) {
          return {
            marginTop: 2,
            marginBottom: 2
          };
        }
      },
      "toolbar-splitbutton/button": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          return {
            icon: "decoration/arrows/down.png",
            marginTop: undefined,
            marginBottom: undefined
          };
        }
      },
      "toolbar-splitbutton/arrow": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          if (states.pressed || states.checked || states.hovered && !states.disabled) {
            var padding = 1;
          } else {
            var padding = 3;
          }

          return {
            padding: padding,
            icon: "decoration/arrows/down.png",
            marginTop: undefined,
            marginBottom: undefined
          };
        }
      },
      "toolbar-separator": {
        style: function style(states) {
          return {
            decorator: "toolbar-separator",
            margin: 7
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREE
      ---------------------------------------------------------------------------
      */
      "tree": "list",
      "tree-item": {
        style: function style(states) {
          var decorator = states.selected ? "selected" : undefined;
          return {
            padding: [2, 6],
            textColor: states.selected ? "text-selected" : undefined,
            decorator: decorator,
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree-item/icon": {
        include: "image",
        style: function style(states) {
          return {
            paddingRight: 5
          };
        }
      },
      "tree-item/label": "label",
      "tree-item/open": {
        include: "image",
        style: function style(states) {
          var icon;

          if (states.selected && states.opened) {
            icon = "decoration/tree/open-selected.png";
          } else if (states.selected && !states.opened) {
            icon = "decoration/tree/closed-selected.png";
          } else if (states.opened) {
            icon = "decoration/tree/open.png";
          } else {
            icon = "decoration/tree/closed.png";
          }

          return {
            padding: [0, 5, 0, 2],
            source: icon
          };
        }
      },
      "tree-folder": {
        include: "tree-item",
        alias: "tree-item",
        style: function style(states) {
          var icon, iconOpened;

          if (states.small) {
            icon = states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png";
            iconOpened = "icon/16/places/folder-open.png";
          } else if (states.large) {
            icon = states.opened ? "icon/32/places/folder-open.png" : "icon/32/places/folder.png";
            iconOpened = "icon/32/places/folder-open.png";
          } else {
            icon = states.opened ? "icon/22/places/folder-open.png" : "icon/22/places/folder.png";
            iconOpened = "icon/22/places/folder-open.png";
          }

          return {
            icon: icon,
            iconOpened: iconOpened
          };
        }
      },
      "tree-file": {
        include: "tree-item",
        alias: "tree-item",
        style: function style(states) {
          return {
            icon: states.small ? "icon/16/mimetypes/office-document.png" : states.large ? "icon/32/mimetypes/office-document.png" : "icon/22/mimetypes/office-document.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREEVIRTUAL
      ---------------------------------------------------------------------------
      */
      "treevirtual": "table",
      "treevirtual-folder": {
        style: function style(states) {
          return {
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png"
          };
        }
      },
      "treevirtual-file": {
        include: "treevirtual-folder",
        alias: "treevirtual-folder",
        style: function style(states) {
          return {
            icon: "icon/16/mimetypes/office-document.png"
          };
        }
      },
      "treevirtual-line": {
        style: function style(states) {
          return {
            icon: "qx/static/blank.gif"
          };
        }
      },
      "treevirtual-contract": {
        style: function style(states) {
          return {
            icon: "decoration/tree/open.png",
            paddingLeft: 5,
            paddingTop: 2
          };
        }
      },
      "treevirtual-expand": {
        style: function style(states) {
          return {
            icon: "decoration/tree/closed.png",
            paddingLeft: 5,
            paddingTop: 2
          };
        }
      },
      "treevirtual-only-contract": "treevirtual-contract",
      "treevirtual-only-expand": "treevirtual-expand",
      "treevirtual-start-contract": "treevirtual-contract",
      "treevirtual-start-expand": "treevirtual-expand",
      "treevirtual-end-contract": "treevirtual-contract",
      "treevirtual-end-expand": "treevirtual-expand",
      "treevirtual-cross-contract": "treevirtual-contract",
      "treevirtual-cross-expand": "treevirtual-expand",
      "treevirtual-end": {
        style: function style(states) {
          return {
            icon: "qx/static/blank.gif"
          };
        }
      },
      "treevirtual-cross": {
        style: function style(states) {
          return {
            icon: "qx/static/blank.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOL TIP
      ---------------------------------------------------------------------------
      */
      "tooltip": {
        include: "popup",
        style: function style(states) {
          return {
            backgroundColor: "background-tip",
            padding: [1, 3, 2, 3],
            offset: [15, 5, 5, 5]
          };
        }
      },
      "tooltip/atom": "atom",
      "tooltip-error": {
        style: function style(states) {
          return {
            placeMethod: "widget",
            offset: [-3, 1, 0, 0],
            arrowPosition: states.placementLeft ? "left" : "right",
            position: "right-top",
            showTimeout: 100,
            hideTimeout: 10000,
            padding: [0, 4, 4, 0]
          };
        }
      },
      "tooltip-error/arrow": {
        include: "image",
        style: function style(states) {
          var source = states.placementLeft ? "decoration/form/tooltip-error-arrow-right.png" : "decoration/form/tooltip-error-arrow.png";
          return {
            source: source,
            padding: [6, 0, 0, 0],
            zIndex: 10000001
          };
        }
      },
      "tooltip-error/atom": {
        include: "popup",
        style: function style(states) {
          return {
            textColor: "text-selected",
            backgroundColor: undefined,
            decorator: "tooltip-error",
            font: "bold",
            padding: [3, 4, 4, 4],
            margin: [1, 0, 0, 0],
            maxWidth: 333
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: function style(states) {
          return {
            decorator: states.showStatusbar ? "window-incl-statusbar" : "window",
            contentPadding: [10, 10, 10, 10],
            margin: states.maximized ? 0 : [0, 5, 5, 0]
          };
        }
      },
      "window-resize-frame": {
        style: function style(states) {
          return {
            decorator: states.showStatusbar ? "window-resize-frame-incl-statusbar" : "window-resize-frame"
          };
        }
      },
      "window/pane": {
        style: function style(states) {
          return {
            decorator: "window-pane"
          };
        }
      },
      "window/captionbar": {
        style: function style(states) {
          return {
            decorator: states.active ? "window-captionbar-active" : "window-captionbar-inactive",
            textColor: states.active ? "window-caption-active-text" : "text-gray",
            minHeight: 26,
            paddingRight: 2
          };
        }
      },
      "window/icon": {
        style: function style(states) {
          return {
            margin: [5, 0, 3, 6]
          };
        }
      },
      "window/title": {
        style: function style(states) {
          return {
            alignY: "middle",
            font: "bold",
            marginLeft: 6,
            marginRight: 12
          };
        }
      },
      "window/minimize-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: states.active ? states.hovered ? "decoration/window/minimize-active-hovered.png" : "decoration/window/minimize-active.png" : "decoration/window/minimize-inactive.png",
            margin: [4, 8, 2, 0]
          };
        }
      },
      "window/restore-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: states.active ? states.hovered ? "decoration/window/restore-active-hovered.png" : "decoration/window/restore-active.png" : "decoration/window/restore-inactive.png",
            margin: [5, 8, 2, 0]
          };
        }
      },
      "window/maximize-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: states.active ? states.hovered ? "decoration/window/maximize-active-hovered.png" : "decoration/window/maximize-active.png" : "decoration/window/maximize-inactive.png",
            margin: [4, 8, 2, 0]
          };
        }
      },
      "window/close-button": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: states.active ? states.hovered ? "decoration/window/close-active-hovered.png" : "decoration/window/close-active.png" : "decoration/window/close-inactive.png",
            margin: [4, 8, 2, 0]
          };
        }
      },
      "window/statusbar": {
        style: function style(states) {
          return {
            padding: [2, 6],
            decorator: "window-statusbar",
            minHeight: 18
          };
        }
      },
      "window/statusbar-text": {
        style: function style(states) {
          return {
            font: "small"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        IFRAME
      ---------------------------------------------------------------------------
      */
      "iframe": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        RESIZER
      ---------------------------------------------------------------------------
      */
      "resizer": {
        style: function style(states) {
          return {
            decorator: "pane"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane": {
        style: function style(states) {
          return {
            decorator: "splitpane"
          };
        }
      },
      "splitpane/splitter": {
        style: function style(states) {
          return {
            width: states.horizontal ? 3 : undefined,
            height: states.vertical ? 3 : undefined,
            backgroundColor: "background-splitpane"
          };
        }
      },
      "splitpane/splitter/knob": {
        style: function style(states) {
          return {
            source: states.horizontal ? "decoration/splitpane/knob-horizontal.png" : "decoration/splitpane/knob-vertical.png"
          };
        }
      },
      "splitpane/slider": {
        style: function style(states) {
          return {
            width: states.horizontal ? 3 : undefined,
            height: states.vertical ? 3 : undefined,
            backgroundColor: "background-splitpane"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTBOX
      ---------------------------------------------------------------------------
      */
      "selectbox": "button-frame",
      "selectbox/atom": "atom",
      "selectbox/popup": "popup",
      "selectbox/list": {
        alias: "list"
      },
      "selectbox/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: "decoration/arrows/down.png",
            paddingLeft: 5
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser": {
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          return {
            padding: 2,
            decorator: decorator,
            backgroundColor: "background-light"
          };
        }
      },
      "datechooser/navigation-bar": {},
      "datechooser/nav-button": {
        include: "button-frame",
        alias: "button-frame",
        style: function style(states) {
          var result = {
            padding: [2, 4]
          };

          if (states.lastYear) {
            result.icon = "decoration/arrows/rewind.png";
            result.marginRight = 1;
          } else if (states.lastMonth) {
            result.icon = "decoration/arrows/left.png";
          } else if (states.nextYear) {
            result.icon = "decoration/arrows/forward.png";
            result.marginLeft = 1;
          } else if (states.nextMonth) {
            result.icon = "decoration/arrows/right.png";
          }

          return result;
        }
      },
      "datechooser/last-year-button-tooltip": "tooltip",
      "datechooser/last-month-button-tooltip": "tooltip",
      "datechooser/next-year-button-tooltip": "tooltip",
      "datechooser/next-month-button-tooltip": "tooltip",
      "datechooser/last-year-button": "datechooser/nav-button",
      "datechooser/last-month-button": "datechooser/nav-button",
      "datechooser/next-month-button": "datechooser/nav-button",
      "datechooser/next-year-button": "datechooser/nav-button",
      "datechooser/month-year-label": {
        style: function style(states) {
          return {
            font: "bold",
            textAlign: "center",
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "datechooser/date-pane": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined,
            marginTop: 2
          };
        }
      },
      "datechooser/weekday": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled" : states.weekend ? "text-light" : undefined,
            textAlign: "center",
            paddingTop: 2,
            backgroundColor: "background-medium"
          };
        }
      },
      "datechooser/week": {
        style: function style(states) {
          return {
            textAlign: "center",
            padding: [2, 4],
            backgroundColor: "background-medium"
          };
        }
      },
      "datechooser/day": {
        style: function style(states) {
          var decorator = states.disabled ? undefined : states.selected ? "selected" : undefined;
          return {
            textAlign: "center",
            decorator: decorator,
            textColor: states.disabled ? "text-disabled" : states.selected ? "text-selected" : states.otherMonth ? "text-light" : undefined,
            font: states.today ? "bold" : undefined,
            padding: [2, 4]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COMBOBOX
      ---------------------------------------------------------------------------
      */
      "combobox": {
        style: function style(states) {
          var decorator;
          var focused = !!states.focused;
          var invalid = !!states.invalid;
          var disabled = !!states.disabled;

          if (focused && invalid && !disabled) {
            decorator = "input-focused-invalid";
          } else if (focused && !invalid && !disabled) {
            decorator = "input-focused";
          } else if (disabled) {
            decorator = "input-disabled";
          } else if (!focused && invalid && !disabled) {
            decorator = "border-invalid";
          } else {
            decorator = "input";
          }

          return {
            decorator: decorator
          };
        }
      },
      "combobox/popup": "popup",
      "combobox/list": {
        alias: "list"
      },
      "combobox/button": {
        include: "button-frame",
        alias: "button-frame",
        style: function style(states, superStyles) {
          var ret = {
            icon: "decoration/arrows/down.png",
            padding: [superStyles.padding[0], superStyles.padding[1] - 6],
            margin: undefined
          };

          if (states.selected) {
            ret.decorator = "button-focused";
          }

          return ret;
        }
      },
      "combobox/textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        style: function style(states) {
          var result = {
            decorator: "menu",
            spacingX: 6,
            spacingY: 1,
            iconColumnWidth: 16,
            arrowColumnWidth: 4,
            placementModeY: states.submenu || states.contextmenu ? "best-fit" : "keep-align"
          };

          if (states.submenu) {
            result.position = "right-top";
            result.offset = [-2, -3];
          }

          return result;
        }
      },
      "menu/slidebar": "menu-slidebar",
      "menu-slidebar": "widget",
      "menu-slidebar-button": {
        style: function style(states) {
          var decorator = states.hovered ? "selected" : undefined;
          return {
            decorator: decorator,
            padding: 7,
            center: true
          };
        }
      },
      "menu-slidebar/button-backward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: states.hovered ? "decoration/arrows/up-invert.png" : "decoration/arrows/up.png"
          };
        }
      },
      "menu-slidebar/button-forward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: states.hovered ? "decoration/arrows/down-invert.png" : "decoration/arrows/down.png"
          };
        }
      },
      "menu-separator": {
        style: function style(states) {
          return {
            height: 0,
            decorator: "menu-separator",
            margin: [4, 2]
          };
        }
      },
      "menu-button": {
        alias: "atom",
        style: function style(states) {
          var decorator = states.selected ? "selected" : undefined;
          return {
            decorator: decorator,
            textColor: states.selected ? "text-selected" : undefined,
            padding: [4, 6]
          };
        }
      },
      "menu-button/icon": {
        include: "image",
        style: function style(states) {
          return {
            alignY: "middle"
          };
        }
      },
      "menu-button/label": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            padding: 1
          };
        }
      },
      "menu-button/shortcut": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            marginLeft: 14,
            padding: 1
          };
        }
      },
      "menu-button/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: states.selected ? "decoration/arrows/right-invert.png" : "decoration/arrows/right.png",
            alignY: "middle"
          };
        }
      },
      "menu-checkbox": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : states.selected ? "decoration/menu/checkbox-invert.gif" : "decoration/menu/checkbox.gif"
          };
        }
      },
      "menu-radiobutton": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          return {
            icon: !states.checked ? undefined : states.selected ? "decoration/menu/radiobutton-invert.gif" : "decoration/menu/radiobutton.gif"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar": {
        style: function style(states) {
          return {
            decorator: "menubar"
          };
        }
      },
      "menubar-button": {
        alias: "atom",
        style: function style(states) {
          var decorator = (states.pressed || states.hovered) && !states.disabled ? "selected" : undefined;
          return {
            decorator: decorator,
            textColor: states.pressed || states.hovered ? "text-selected" : undefined,
            padding: [3, 8]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR SELECTOR
      ---------------------------------------------------------------------------
      */
      "colorselector": "widget",
      "colorselector/control-bar": "widget",
      "colorselector/control-pane": "widget",
      "colorselector/visual-pane": "groupbox",
      "colorselector/preset-grid": "widget",
      "colorselector/colorbucket": {
        style: function style(states) {
          return {
            decorator: "main",
            width: 16,
            height: 16
          };
        }
      },
      "colorselector/preset-field-set": "groupbox",
      "colorselector/input-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 20
          };
        }
      },
      "colorselector/preview-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 20
          };
        }
      },
      "colorselector/hex-field-composite": "widget",
      "colorselector/hex-field": "textfield",
      "colorselector/rgb-spinner-composite": "widget",
      "colorselector/rgb-spinner-red": "spinner",
      "colorselector/rgb-spinner-green": "spinner",
      "colorselector/rgb-spinner-blue": "spinner",
      "colorselector/hsb-spinner-composite": "widget",
      "colorselector/hsb-spinner-hue": "spinner",
      "colorselector/hsb-spinner-saturation": "spinner",
      "colorselector/hsb-spinner-brightness": "spinner",
      "colorselector/preview-content-old": {
        style: function style(states) {
          return {
            decorator: "main",
            width: 50,
            height: 10
          };
        }
      },
      "colorselector/preview-content-new": {
        style: function style(states) {
          return {
            decorator: "main",
            backgroundColor: "background-light",
            width: 50,
            height: 10
          };
        }
      },
      "colorselector/hue-saturation-field": {
        style: function style(states) {
          return {
            decorator: "main",
            margin: 5
          };
        }
      },
      "colorselector/brightness-field": {
        style: function style(states) {
          return {
            decorator: "main",
            margin: [5, 7]
          };
        }
      },
      "colorselector/hue-saturation-pane": "widget",
      "colorselector/hue-saturation-handle": "widget",
      "colorselector/brightness-pane": "widget",
      "colorselector/brightness-handle": "widget",

      /*
      ---------------------------------------------------------------------------
        COLOR POPUP
      ---------------------------------------------------------------------------
      */
      "colorpopup": {
        alias: "popup",
        include: "popup",
        style: function style(states) {
          return {
            padding: 5,
            backgroundColor: "background-application"
          };
        }
      },
      "colorpopup/field": {
        style: function style(states) {
          return {
            decorator: "main",
            margin: 2,
            width: 14,
            height: 14,
            backgroundColor: "background-light"
          };
        }
      },
      "colorpopup/selector-button": "button",
      "colorpopup/auto-button": "button",
      "colorpopup/preview-pane": "groupbox",
      "colorpopup/current-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginLeft: 4,
            decorator: "main",
            allowGrowX: true
          };
        }
      },
      "colorpopup/selected-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginRight: 4,
            decorator: "main",
            allowGrowX: true
          };
        }
      },
      "colorpopup/colorselector-okbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-ok.png"
          };
        }
      },
      "colorpopup/colorselector-cancelbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-cancel.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table": {
        alias: "widget",
        style: function style(states) {
          return {
            decorator: "table"
          };
        }
      },
      "table/statusbar": {
        style: function style(states) {
          return {
            decorator: "table-statusbar",
            padding: [0, 2]
          };
        }
      },
      "table/column-button": {
        alias: "button-frame",
        style: function style(states) {
          return {
            decorator: "table-scroller-header",
            padding: 3,
            icon: "decoration/table/select-column-order.png"
          };
        }
      },
      "table-column-reset-button": {
        include: "menu-button",
        alias: "menu-button",
        style: function style() {
          return {
            icon: "icon/16/actions/view-refresh.png"
          };
        }
      },
      "table-scroller": "widget",
      "table-scroller/scrollbar-x": "scrollbar",
      "table-scroller/scrollbar-y": "scrollbar",
      "table-scroller/header": {
        style: function style(states) {
          return {
            decorator: "table-scroller-header",
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "table-scroller/pane": {
        style: function style(states) {
          return {
            backgroundColor: "table-pane"
          };
        }
      },
      "table-scroller/focus-indicator": {
        style: function style(states) {
          return {
            decorator: "table-scroller-focus-indicator"
          };
        }
      },
      "table-scroller/resize-line": {
        style: function style(states) {
          return {
            backgroundColor: "border-separator",
            width: 2
          };
        }
      },
      "table-header-cell": {
        alias: "atom",
        style: function style(states) {
          return {
            minWidth: 13,
            minHeight: 20,
            padding: states.hovered ? [3, 4, 2, 4] : [3, 4],
            decorator: states.hovered ? "table-header-cell-hovered" : "table-header-cell",
            sortIcon: states.sorted ? states.sortedAscending ? "decoration/table/ascending.png" : "decoration/table/descending.png" : undefined
          };
        }
      },
      "table-header-cell/label": {
        style: function style(states) {
          return {
            minWidth: 0,
            alignY: "middle",
            paddingRight: 5
          };
        }
      },
      "table-header-cell/sort-icon": {
        style: function style(states) {
          return {
            alignY: "middle",
            alignX: "right",
            opacity: states.disabled ? 0.3 : 1
          };
        }
      },
      "table-header-cell/icon": {
        style: function style(states) {
          return {
            minWidth: 0,
            alignY: "middle",
            paddingRight: 5,
            opacity: states.disabled ? 0.3 : 1
          };
        }
      },
      "table-editor-textfield": {
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 2],
            backgroundColor: "background-light"
          };
        }
      },
      "table-editor-selectbox": {
        include: "selectbox",
        alias: "selectbox",
        style: function style(states) {
          return {
            padding: [0, 2],
            backgroundColor: "background-light"
          };
        }
      },
      "table-editor-combobox": {
        include: "combobox",
        alias: "combobox",
        style: function style(states) {
          return {
            decorator: undefined,
            backgroundColor: "background-light"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSIVE
      ---------------------------------------------------------------------------
      */
      "progressive-table-header": {
        alias: "widget",
        style: function style(states) {
          return {
            decorator: "progressive-table-header"
          };
        }
      },
      "progressive-table-header-cell": {
        alias: "atom",
        style: function style(states) {
          return {
            minWidth: 40,
            minHeight: 25,
            paddingLeft: 6,
            decorator: "progressive-table-header-cell"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header": {
        style: function style(states) {
          return {
            font: "bold",
            textColor: "text-selected",
            padding: [8, 12],
            decorator: "app-header"
          };
        }
      },
      "app-header-label": "label",
      "app-splitpane": {
        alias: "splitpane",
        style: function style(states) {
          return {
            padding: 0
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "virtual-list": "list",
      "virtual-list/row-layer": "row-layer",
      "row-layer": "widget",
      "group-item": {
        include: "label",
        alias: "label",
        style: function style(states) {
          return {
            padding: 4,
            decorator: "group-item",
            textColor: "groupitem-text",
            font: "bold"
          };
        }
      },
      "virtual-selectbox": "selectbox",
      "virtual-selectbox/dropdown": "popup",
      "virtual-selectbox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-combobox": "combobox",
      "virtual-combobox/dropdown": "popup",
      "virtual-combobox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-tree": {
        include: "tree",
        alias: "tree",
        style: function style(states) {
          return {
            itemHeight: 26
          };
        }
      },
      "virtual-tree-folder": "tree-folder",
      "virtual-tree-file": "tree-file",
      "column-layer": "widget",
      "cell": {
        style: function style(states) {
          return {
            textColor: states.selected ? "text-selected" : "text-label",
            padding: [3, 6],
            font: "default"
          };
        }
      },
      "cell-string": "cell",
      "cell-number": {
        include: "cell",
        style: function style(states) {
          return {
            textAlign: "right"
          };
        }
      },
      "cell-image": "cell",
      "cell-boolean": {
        include: "cell",
        style: function style(states) {
          return {
            iconTrue: "decoration/table/boolean-true.png",
            iconFalse: "decoration/table/boolean-false.png"
          };
        }
      },
      "cell-atom": "cell",
      "cell-date": "cell",
      "cell-html": "cell",

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: function style(states) {
          return {
            decorator: "progressbar",
            padding: [1],
            backgroundColor: "progressbar-background",
            width: 200,
            height: 20
          };
        }
      },
      "progressbar/progress": {
        style: function style(states) {
          return {
            decorator: states.disabled ? "group-item" : "selected"
          };
        }
      }
    }
  });
  qx.theme.modern.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.modern.Color": {
        "require": true
      },
      "qx.theme.modern.Decoration": {
        "require": true
      },
      "qx.theme.modern.Font": {
        "require": true
      },
      "qx.theme.modern.Appearance": {
        "require": true
      },
      "qx.theme.icon.Tango": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Contemporary Theme
   */
  qx.Theme.define("qx.theme.Modern", {
    title: "Modern",
    meta: {
      color: qx.theme.modern.Color,
      decoration: qx.theme.modern.Decoration,
      font: qx.theme.modern.Font,
      appearance: qx.theme.modern.Appearance,
      icon: qx.theme.icon.Tango
    }
  });
  qx.theme.Modern.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Css": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "css.rgba": {
          "load": true,
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Simple color theme
   */
  qx.Theme.define("qx.theme.simple.Color", {
    colors: {
      // main
      "background": "white",
      "dark-blue": "#5685D6",
      "light-background": "#E0ECFF",
      // backgrounds
      "background-selected": "#6694E3",
      "background-selected-disabled": "#CDCDCD",
      "background-selected-dark": "#5685D6",
      "background-disabled": "#F7F7F7",
      "background-disabled-checked": "#BBBBBB",
      "background-pane": "#FAFBFE",
      // tabview
      "tabview-unselected": "#1866B5",
      "tabview-button-border": "#134983",
      "tabview-label-active-disabled": "#D9D9D9",
      // text colors
      "link": "#24B",
      // scrollbar
      "scrollbar-bright": "#F1F1F1",
      "scrollbar-dark": "#EBEBEB",
      // form
      "button": "#E8F0E3",
      "button-border": "#BBB",
      "button-border-hovered": "#939393",
      "invalid": "#FF0000",
      "button-box-bright": "#F9F9F9",
      "button-box-dark": "#E3E3E3",
      "button-box-bright-pressed": "#DDDDDD",
      "button-box-dark-pressed": "#F5F5F5",
      "border-lead": "#888888",
      // window
      "window-border": "#2E3A46",
      "window-border-inner": "#9DCBFE",
      // group box
      "white-box-border": "#BCBCBC",
      // shadows
      "shadow": qx.core.Environment.get("css.rgba") ? "rgba(0, 0, 0, 0.4)" : "#666666",
      // borders
      // 'border-main' is an alias of 'background-selected' (compatibility reasons)
      "border-main": "#6694E3",
      "border-light": "#B7B7B7",
      "border-light-shadow": "#686868",
      // separator
      "border-separator": "#808080",
      // text
      "text": "black",
      "text-disabled": "#A7A6AA",
      "text-selected": "white",
      "text-placeholder": "#CBC8CD",
      // tooltip
      "tooltip": "#FFFFE1",
      "tooltip-text": "black",
      // table
      "table-header": [242, 242, 242],
      "table-focus-indicator": [179, 217, 255],
      // used in table code
      "table-header-cell": [235, 234, 219],
      "table-row-background-focused-selected": [90, 138, 211],
      "table-row-background-focused": [221, 238, 255],
      "table-row-background-selected": [51, 94, 168],
      "table-row-background-even": "white",
      "table-row-background-odd": "white",
      "table-row-selected": [255, 255, 255],
      "table-row": [0, 0, 0],
      "table-row-line": "#EEE",
      "table-column-line": "#EEE",
      // used in progressive code
      "progressive-table-header": "#AAAAAA",
      "progressive-table-row-background-even": [250, 248, 243],
      "progressive-table-row-background-odd": [255, 255, 255],
      "progressive-progressbar-background": "gray",
      "progressive-progressbar-indicator-done": "#CCCCCC",
      "progressive-progressbar-indicator-undone": "white",
      "progressive-progressbar-percent-background": "gray",
      "progressive-progressbar-percent-text": "white"
    }
  });
  qx.theme.simple.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /**
   * The simple qooxdoo font theme.
   */
  qx.Theme.define("qx.theme.simple.Font", {
    fonts: {
      "default": {
        size: 13,
        family: ["arial", "sans-serif"]
      },
      "bold": {
        size: 13,
        family: ["arial", "sans-serif"],
        bold: true
      },
      "headline": {
        size: 24,
        family: ["sans-serif", "arial"]
      },
      "small": {
        size: 11,
        family: ["arial", "sans-serif"]
      },
      "monospace": {
        size: 11,
        family: ["DejaVu Sans Mono", "Courier New", "monospace"]
      }
    }
  });
  qx.theme.simple.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.simple.Color": {
        "require": true
      },
      "qx.theme.simple.Decoration": {
        "require": true
      },
      "qx.theme.simple.Font": {
        "require": true
      },
      "qx.theme.simple.Appearance": {
        "require": true
      },
      "qx.theme.icon.Tango": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Simple Theme
   */
  qx.Theme.define("qx.theme.Simple", {
    title: "Simple",
    meta: {
      color: qx.theme.simple.Color,
      decoration: qx.theme.simple.Decoration,
      font: qx.theme.simple.Font,
      appearance: qx.theme.simple.Appearance,
      icon: qx.theme.icon.Tango
    }
  });
  qx.theme.Simple.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.util.ColorUtil": {},
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
    Tangible Theme for Qooxdoo
  
    Copyright:
       2018 IT'IS Foundation
       2020 Tobi Oetiker
  
    License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
    Authors:
      * Tobias Oetiker (oetiker)
  
    Origin:
      This theme is inspired by ideas from Material design.
  ************************************************************************ */

  /**
   * Simple color theme
   */
  var helper = {
    tone: function tone(color) {
      if (color == "dark" || color == "light") {
        return color;
      }

      var minimumContrast = 3.1;
      var lightContrast = qx.util.ColorUtil.contrast(color, "#fff");
      var darkContrast = qx.util.ColorUtil.contrast(color, "rgba(0,0,0,0.87)");

      if (lightContrast < minimumContrast && darkContrast > lightContrast) {
        return "light";
      } else {
        return "dark";
      }
    },

    /**
     * contrastTone
     *
     * Should dark or light text be used on top of the given
     * color to get readable text.
     *
     * @param color {String} a valid qooxdoo/CSS rgb color string
     * @return {String} "dark" if color is light and vise versa
     */
    contrastTone: function contrastTone(color) {
      return helper.tone(color) === "dark" ? "light" : "dark";
    },

    /**
     * inkColorForFill
     *
     * @param textStyle {String}  primary|secondary|hint|disabled|icon
     * @param fillColor {String} a valid qooxdoo/CSS rgb color string
     * @return {String} a CSS rgba color string
     */
    inkColorForFill: function inkColorForFill(textStyle, fillColor) {
      var textColor = {
        dark: {
          primary: "rgba(0,0,0,0.87)",
          secondary: "rgba(0,0,0,0.54)",
          hint: "rgba(0,0,0,0.38)",
          disabled: "rgba(0,0,0,0,0.38)",
          icon: "rgba(0,0,0,0.38)"
        },
        light: {
          primary: "#fff",
          secondary: "rgba(255,255,255,0.7)",
          hint: "rgba(255,255,255,0.5)",
          disabled: "rgba(255,255,255,0.5)",
          icon: "rgba(255,255,255,0.5)"
        }
      };
      var contrastTone = helper.contrastTone(fillColor);
      return textColor[contrastTone][textStyle];
    },
    // helpers
    onX: function onX(key) {
      var baseColor = key.split('-')[2];
      return helper.contrastTone(baseColor) === "dark" ? "#000000" : "#ffffff";
    },
    // helpers
    xState: function xState(key) {
      var d = key.split('-');
      var color = d[0];
      var state = d[1];

      switch (state) {
        case 'focussed':
          return qx.util.ColorUtil.scale(color, {
            lightness: 10,
            saturation: 10
          });

        case 'hovered':
          return qx.util.ColorUtil.scale(color, {
            lightness: 10
          });

        case 'disabled':
          return qx.util.ColorUtil.scale(color, {
            lightness: -10,
            saturation: -70
          });

        case 'selected':
          return qx.util.ColorUtil.scale(color, {
            lightness: 30
          });

        case 'selected_disabled':
          return qx.util.ColorUtil.scale(color, {
            lightness: 30,
            saturation: -70
          });

        default:
          return color;
      }
    },
    textXonY: function textXonY(key) {
      var splitKey = key.split('-');
      var textStyle = splitKey[1];
      var fillColor = splitKey[3];
      return helper.inkColorForFill(textStyle, fillColor);
    },
    setAlpha: function setAlpha(key) {
      var splitKey = key.split('-');
      var baseColor = splitKey[0];
      var alphaPercent = splitKey[2];
      var rgba = qx.util.ColorUtil.stringToRgb(baseColor);
      rgba[3] = alphaPercent / 100;
      return qx.util.ColorUtil.rgbToRgbString(rgba);
    }
  };
  qx.Theme.define("qx.theme.tangible.ColorEngine", {
    colors: {
      // actual implementations must supply these 4 colors
      // at least
      //"primary": "#6200ee",
      //"secondary": "#018786",
      //"surface": "#ffffff",
      //"error": "#b00020",
      // automatic colors
      "text-on-primary": helper.onX,
      "text-on-secondary": helper.onX,
      "text-on-surface": helper.onX,
      "text-on-error": helper.onX,
      "primary-hovered": helper.xState,
      "primary-disabled": helper.xState,
      "primary-focussed": helper.xState,
      "primary-selected": helper.xState,
      "primary-selected_disabled": helper.xState,
      "error-focussed": helper.xState,
      // alpha colors
      "primary-alpha-5": helper.setAlpha,
      "primary-alpha-10": helper.setAlpha,
      "primary-alpha-30": helper.setAlpha,
      "secondary-alpha-5": helper.setAlpha,
      "primary-disabled-alpha-20": helper.setAlpha,
      // Text-primary on "surface" background
      "text-primary-on-surface": helper.textXonY,
      "text-hint-on-surface": helper.textXonY,
      "text-disabled-on-surface": helper.textXonY,
      "text-icon-on-surface": helper.textXonY,
      "text-disabled-on-primary": helper.textXonY,
      "text-icon-on-primary": helper.textXonY,
      // the following colors are used directly in table code
      "table-header-cell": "surface",
      "table-row-background-focused-selected": "primary-alpha-10",
      "table-row-background-focused": "primary-alpha-5",
      "table-row-background-selected": "secondary-alpha-5",
      "table-row-background-even": "surface",
      "table-row-background-odd": "surface",
      // foreground
      "table-row-selected": "text-primary-on-surface",
      "table-row": "text-primary-on-surface",
      // table grid color
      "table-row-line": "text-hint-on-surface",
      "table-column-line": "transparent",
      // used in the widget-browser-app
      "text-disabled": "text-disabled-on-surface",
      // used in progressive code
      "progressive-table-header": "table-header-cell",
      "progressive-table-row-background-even": "primary-alpha-5",
      "progressive-table-row-background-odd": "surface",
      "progressive-progressbar-background": "surface",
      "progressive-progressbar-indicator-done": "primary",
      "progressive-progressbar-indicator-undone": "surface",
      "progressive-progressbar-percent-background": "surface",
      "progressive-progressbar-percent-text": "text-primary-on-surface"
    }
  });
  qx.theme.tangible.ColorEngine.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.tangible.ColorEngine": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
    Tangible Dark Theme for Qooxdoo
  
    Copyright:
       2018 IT'IS Foundation
       2020 Tobi Oetiker
  
    License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
    Authors:
      * Tobias Oetiker (oetiker)
  
    Origin:
      This theme is based in large parts on the osparc.theme
  ************************************************************************ */

  /**
   * Simple color theme
   */
  qx.Theme.define("qx.theme.tangible.ColorDark", {
    extend: qx.theme.tangible.ColorEngine,
    colors: {
      // theme colors
      "primary": "#26a69a",
      "secondary": "#26c6da",
      "surface": "#455a64",
      "error": "#b00020"
    }
  });
  qx.theme.tangible.ColorDark.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
    Tangible Theme for Qooxdoo
  
    Copyright:
       2018 IT'IS Foundation
       2020 Tobi Oetiker
  
    License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
    Authors:
      * Tobias Oetiker (oetiker)
  
    Origin:
     This theme is based in large parts on the osparc.theme
  ************************************************************************ */

  /**
   * The simple qooxdoo decoration theme.
   */
  qx.Theme.define("qx.theme.tangible.Decoration", {
    aliases: {
      decoration: "qx/decoration/Simple"
    },
    decorations: {
      /*
        ---------------------------------------------------------------------------
          MATERIAL TEXT FIELD
        ---------------------------------------------------------------------------
        */
      "material-textfield": {
        style: {
          styleBottom: "solid",
          widthBottom: 1,
          colorBottom: "primary"
        }
      },
      "material-textfield-focused": {
        include: "material-textfield",
        style: {
          widthBottom: 2,
          colorBottom: "primary-focussed"
        }
      },
      "material-textfield-invalid": {
        include: "material-textfield",
        style: {
          widthBottom: 1,
          colorBottom: "error"
        }
      },
      "material-textfield-focused-invalid": {
        include: "material-textfield",
        style: {
          widthBottom: 2,
          colorBottom: "error-focussed"
        }
      },
      "material-textfield-disabled": {
        include: "material-textfield",
        style: {
          widthBottom: 1,
          colorBottom: "primary-disabled"
        }
      },
      "material-textfield-readonly": {
        style: {}
      },

      /*
        ---------------------------------------------------------------------------
          BUTTON
        ---------------------------------------------------------------------------
        */
      "material-button": {
        style: {
          radius: 2,
          backgroundColor: "primary",
          shadowHorizontalLength: 0,
          shadowVerticalLength: [3, 2, 1],
          shadowBlurRadius: [1, 2, 5],
          shadowSpreadRadius: [-2, 0, 0],
          shadowColor: ["rgba(0, 0, 0, 0.2)", "rgba(0, 0, 0, 0.14)", "rgba(0, 0, 0, 0.12)"],
          transitionProperty: ["all"],
          transitionDuration: "0s"
        }
      },
      "material-button-hovered": {
        include: "material-button",
        style: {
          backgroundColor: "primary-hovered",
          shadowVerticalLength: [2, 4, 1],
          shadowBlurRadius: [4, 5, 10],
          shadowSpreadRadius: [-1, 0, 0],
          transitionDuration: "0.1s"
        }
      },
      "material-button-pressed": {
        include: "material-button",
        style: {
          backgroundColor: "primary-hovered",
          shadowVerticalLength: [5, 8, 3],
          shadowBlurRadius: [5, 10, 14],
          shadowSpreadRadius: [-3, 1, 2],
          transitionDuration: "0.1s"
        }
      },
      "material-button-disabled": {
        include: "material-button",
        style: {
          shadowVerticalLength: 0,
          shadowBlurRadius: 0,
          shadowSpreadRadius: 0,
          backgroundColor: "primary-disabled"
        }
      },
      "material-button-left": {
        include: "material-button",
        style: {
          radius: [2, 0, 0, 2]
        }
      },
      "material-button-right": {
        include: "material-button",
        style: {
          radius: [0, 2, 2, 0]
        }
      },
      "material-button-hovered-left": {
        include: "material-button-hovered",
        style: {
          radius: [2, 0, 0, 2]
        }
      },
      "material-button-focused-left": {
        include: "material-button-hovered",
        style: {
          radius: [2, 0, 0, 2]
        }
      },
      "material-button-hovered-right": {
        include: "material-button-hovered",
        style: {
          radius: [0, 2, 2, 0]
        }
      },
      "material-button-focused-right": {
        include: "material-button-hovered",
        style: {
          radius: [0, 2, 2, 0]
        }
      },
      "material-button-pressed-left": {
        include: "material-button-pressed",
        style: {
          radius: [2, 0, 0, 2]
        }
      },
      "material-button-pressed-right": {
        include: "material-button-pressed",
        style: {
          radius: [0, 2, 2, 0]
        }
      },
      "material-button-disabled-left": {
        include: "material-button-disabled",
        style: {
          radius: [2, 0, 0, 2]
        }
      },
      "material-button-disabled-right": {
        include: "material-button-disabled",
        style: {
          radius: [0, 2, 2, 0]
        }
      },
      "toggle-button": {
        include: "material-button"
      },
      "toggle-button-hovered": {
        include: "material-button-hovered"
      },
      "toggle-button-checked": {
        include: "toggle-button",
        style: {
          backgroundColor: "primary-selected"
        }
      },
      "toggle-button-checked-hovered": {
        include: "toggle-button-hovered",
        style: {
          backgroundColor: "primary-selected"
        }
      },
      "toggle-button-disabled": {
        include: "material-button-disabled"
      },
      "toggle-button-checked-disabled": {
        include: "toggle-button-checked",
        style: {
          backgroundColor: "primary-selected_disabled"
        }
      },

      /*
        ---------------------------------------------------------------------------
          CORE
        ---------------------------------------------------------------------------
        */
      "border-blue": {
        style: {
          width: 4,
          color: "surface"
        }
      },
      "main": {
        style: {
          width: 1,
          color: "text-hint-on-surface"
        }
      },
      "main-top": {
        include: "main",
        style: {
          width: [1, 0, 0, 0]
        }
      },
      "main-right": {
        include: "main",
        style: {
          width: [0, 1, 0, 0]
        }
      },
      // eslint-disable-next-line no-dupe-keys
      "main-bottom": {
        include: "main",
        style: {
          width: [0, 0, 1, 0]
        }
      },
      "main-left": {
        include: "main",
        style: {
          width: [0, 0, 0, 1]
        }
      },
      "popup": {
        style: {
          width: 1,
          color: "text-hint-on-surface",
          shadowLength: 2,
          shadowBlurRadius: 5,
          shadowColor: "shadow"
        }
      },
      "dragover": {
        style: {
          bottom: [2, "solid", "dark-blue"]
        }
      },

      /*
        ---------------------------------------------------------------------------
          BUTTON
        ---------------------------------------------------------------------------
        */
      "button-box": {
        style: {
          radius: 0,
          width: 0,
          color: "text-on-primary",
          backgroundColor: "primary"
        }
      },
      "button-box-pressed": {
        include: "button-box",
        style: {
          backgroundColor: "primary-focussed"
        }
      },
      "button-box-pressed-hovered": {
        include: "button-box",
        style: {
          backgroundColor: "primary-selected"
        }
      },
      "button-box-hovered": {
        include: "button-box",
        style: {
          backgroundColor: "button-hovered"
        }
      },

      /*
        ---------------------------------------------------------------------------
          BUTTON INVALID
        ---------------------------------------------------------------------------
        */
      "button-box-invalid": {
        include: "button-box",
        style: {
          color: "error"
        }
      },
      "button-box-pressed-invalid": {
        include: "button-box-pressed",
        style: {
          color: "error"
        }
      },
      "button-box-hovered-invalid": {
        include: "button-box-invalid"
      },
      "button-box-pressed-hovered-invalid": {
        include: "button-box-pressed-invalid"
      },

      /*
        ---------------------------------------------------------------------------
          BUTTON FOCUSED
        ---------------------------------------------------------------------------
        */
      "button-box-focused": {
        include: "button-box",
        style: {
          color: "surface"
        }
      },
      "button-box-pressed-focused": {
        include: "button-box-pressed",
        style: {
          color: "surface"
        }
      },
      "button-box-hovered-focused": {
        include: "button-box-focused"
      },
      "button-box-pressed-hovered-focused": {
        include: "button-box-pressed-focused"
      },

      /*
        ---------------------------------------------------------------------------
          BUTTON RIGHT
        ---------------------------------------------------------------------------
        */
      "button-box-right": {
        include: "button-box",
        style: {
          radius: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 1, 1, 0]
        }
      },
      "button-box-hovered-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 1, 1, 0]
        }
      },
      "button-box-focused-right": {
        include: "button-box-focused",
        style: {
          radius: [0, 1, 1, 0]
        }
      },
      "button-box-hovered-focused-right": {
        include: "button-box-hovered-focused",
        style: {
          radius: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-focused-right": {
        include: "button-box-pressed-focused",
        style: {
          radius: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-focused-right": {
        include: "button-box-pressed-hovered-focused",
        style: {
          radius: [0, 1, 1, 0]
        }
      },

      /*
        ---------------------------------------------------------------------------
          BUTTON BORDERLESS RIGHT
        ---------------------------------------------------------------------------
       "button-box-right-borderless":
          {
            include: "button-box",
             style:
              {
                radius: [0, 1, 1, 0],
                width: [1, 1, 1, 0]
              }
          },
       "button-box-pressed-right-borderless":
          {
            include: "button-box-pressed",
             style:
              {
                radius: [0, 1, 1, 0],
                width: [1, 1, 1, 0]
              }
          },
       "button-box-pressed-hovered-right-borderless":
          {
            include: "button-box-pressed-hovered",
             style:
              {
                radius: [0, 1, 1, 0],
                width: [1, 1, 1, 0]
              }
          },
       "button-box-hovered-right-borderless":
          {
            include: "button-box-hovered",
             style:
              {
                radius: [0, 1, 1, 0],
                width: [1, 1, 1, 0]
              }
          },
      */

      /*
        ---------------------------------------------------------------------------
          BUTTON TOP RIGHT
        ---------------------------------------------------------------------------
        */
      "button-box-top-right": {
        include: "button-box",
        style: {
          radius: [0, 1, 0, 0]
        }
      },
      "button-box-pressed-top-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 1, 0, 0]
        }
      },
      "button-box-pressed-hovered-top-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 1, 0, 0]
        }
      },
      "button-box-hovered-top-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 1, 0, 0]
        }
      },

      /*
        ---------------------------------------------------------------------------
          BUTTON BOTOM RIGHT
        ---------------------------------------------------------------------------
        */
      "button-box-bottom-right": {
        include: "button-box",
        style: {
          radius: [0, 0, 1, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-bottom-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 0, 1, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-bottom-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 0, 1, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-hovered-bottom-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 0, 1, 0],
          width: [0, 1, 1, 0]
        }
      },

      /*
        ---------------------------------------------------------------------------
          BUTTON BOTOM LEFT
        ---------------------------------------------------------------------------
        */
      "button-box-bottom-left": {
        include: "button-box",
        style: {
          radius: [0, 0, 0, 1],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-pressed-bottom-left": {
        include: "button-box-pressed",
        style: {
          radius: [0, 0, 0, 1],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-bottom-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 0, 0, 1],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-hovered-bottom-left": {
        include: "button-box-hovered",
        style: {
          radius: [0, 0, 0, 1],
          width: [0, 0, 1, 1]
        }
      },

      /*
        ---------------------------------------------------------------------------
          BUTTON TOP LEFT
        ---------------------------------------------------------------------------
        */
      "button-box-top-left": {
        include: "button-box",
        style: {
          radius: [1, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-pressed-top-left": {
        include: "button-box-pressed",
        style: {
          radius: [1, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-pressed-hovered-top-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [1, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-hovered-top-left": {
        include: "button-box-hovered",
        style: {
          radius: [1, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },

      /*
        ---------------------------------------------------------------------------
          BUTTON MIDDLE
        ---------------------------------------------------------------------------
        */
      "button-box-middle": {
        include: "button-box",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-middle": {
        include: "button-box-pressed",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-middle": {
        include: "button-box-pressed-hovered",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-middle": {
        include: "button-box-hovered",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },

      /*
        ---------------------------------------------------------------------------
          BUTTON LEFT
        ---------------------------------------------------------------------------
        */
      "button-box-left": {
        include: "button-box",
        style: {
          radius: [1, 0, 0, 1],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-left": {
        include: "button-box-pressed",
        style: {
          radius: [1, 0, 0, 1],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [1, 0, 0, 1],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-left": {
        include: "button-box-hovered",
        style: {
          radius: [1, 0, 0, 1],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-focused-left": {
        include: "button-box-focused",
        style: {
          radius: [1, 0, 0, 1],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-focused-left": {
        include: "button-box-hovered-focused",
        style: {
          radius: [1, 0, 0, 1],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-focused-left": {
        include: "button-box-pressed-hovered-focused",
        style: {
          radius: [1, 0, 0, 1],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-focused-left": {
        include: "button-box-pressed-focused",
        style: {
          radius: [1, 0, 0, 1],
          width: [1, 0, 1, 1]
        }
      },

      /*
        ---------------------------------------------------------------------------
          SEPARATOR
        ---------------------------------------------------------------------------
        */
      "separator-horizontal": {
        style: {
          widthLeft: 1,
          colorLeft: "text-hint-on-surface"
        }
      },
      "separator-vertical": {
        style: {
          widthTop: 1,
          colorTop: "text-hint-on-surface"
        }
      },

      /*
        ---------------------------------------------------------------------------
          SCROLL KNOB
        ---------------------------------------------------------------------------
        */
      "scroll-knob": {
        style: {
          radius: 4,
          width: 0,
          backgroundColor: "text-hint-on-surface"
        }
      },
      "scroll-knob-pressed": {
        include: "scroll-knob",
        style: {
          backgroundColor: "text-primary-on-surface"
        }
      },
      "scroll-knob-hovered": {
        include: "scroll-knob"
      },
      "scroll-knob-pressed-hovered": {
        include: "scroll-knob-pressed"
      },

      /*
        ---------------------------------------------------------------------------
          HOVER BUTTON
        ---------------------------------------------------------------------------
        */
      "button-hover": {
        style: {
          backgroundColor: "primary-hovered",
          radius: 1
        }
      },

      /*
        ---------------------------------------------------------------------------
          WINDOW
        ---------------------------------------------------------------------------
        */
      "window": {
        style: {
          width: 1,
          color: "text-hint-on-surface",
          shadowLength: 1,
          shadowBlurRadius: 3,
          shadowColor: "rgba(0,0,0,0.2)",
          backgroundColor: "surface"
        }
      },
      "window-active": {
        include: "window",
        style: {
          shadowLength: 2,
          shadowBlurRadius: 5
        }
      },
      "window-caption": {
        style: {
          width: [0, 0, 1, 0],
          color: "text-hint-on-surface"
        }
      },

      /*
        ---------------------------------------------------------------------------
          GROUP BOX
        ---------------------------------------------------------------------------
        */
      "box": {
        style: {
          width: 1,
          radius: 2,
          color: "text-hint-on-surface",
          backgroundColor: "surface"
        }
      },

      /*
        ---------------------------------------------------------------------------
          FRAME BOX
        ---------------------------------------------------------------------------
        */
      "border": {
        style: {
          width: 1,
          color: "text-hint-on-surface"
        }
      },
      "border-disabled": {
        style: {
          width: 1,
          color: "text-disabled-on-surface"
        }
      },
      "border-focused": {
        style: {
          width: 1,
          color: "primary"
        }
      },
      "border-invalid": {
        style: {
          width: 1,
          color: "error"
        }
      },

      /*
        ---------------------------------------------------------------------------
          LIST ITEM
        ---------------------------------------------------------------------------
        */
      "lead-item": {
        style: {
          width: 1,
          style: "dotted",
          color: "text-disabled-on-surface"
        }
      },

      /*
        ---------------------------------------------------------------------------
          TOOL TIP
        ---------------------------------------------------------------------------
        */
      "tooltip": {
        style: {
          width: 1,
          color: "text-on-secondary",
          shadowLength: 1,
          shadowBlurRadius: 2,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      "tooltip-error": {
        style: {
          radius: 5,
          backgroundColor: "error"
        }
      },

      /*
        ---------------------------------------------------------------------------
          TOOLBAR
        ---------------------------------------------------------------------------
        */
      "toolbar-separator": {
        style: {
          widthLeft: 1,
          colorLeft: "text-hint-on-surface"
        }
      },
      "toolbar-button": {
        include: "material-button",
        style: {
          shadowHorizontalLength: 0,
          shadowVerticalLength: 0,
          shadowBlurRadius: 0,
          shadowSpreadRadius: 0
        }
      },
      "toolbar-button-hovered": {
        include: "material-button-hovered"
      },
      "toolbar-button-left": {
        include: "material-button-left",
        style: {
          shadowHorizontalLength: 0,
          shadowVerticalLength: 0,
          shadowBlurRadius: 0,
          shadowSpreadRadius: 0
        }
      },
      "toolbar-button-hovered-left": {
        include: "material-button-hovered-left"
      },
      "toolbar-button-right": {
        include: "material-button-right",
        style: {
          shadowHorizontalLength: 0,
          shadowVerticalLength: 0,
          shadowBlurRadius: 0,
          shadowSpreadRadius: 0
        }
      },
      "toolbar-button-hovered-right": {
        include: "material-button-hovered-right"
      },

      /*
        ---------------------------------------------------------------------------
          MENU
        ---------------------------------------------------------------------------
        */
      "menu-separator": {
        style: {
          widthTop: 1,
          colorTop: "text-hint-on-surface"
        }
      },

      /*
        ---------------------------------------------------------------------------
          MENU BAR
        ---------------------------------------------------------------------------
        */
      "menubar-button-hovered": {
        style: {
          backgroundColor: "primary-hovered"
        }
      },
      "menubar-button-pressed": {
        include: "menubar-button-hovered",
        style: {
          backgroundColor: "primary-selected"
        }
      },

      /*
        ---------------------------------------------------------------------------
          DATE CHOOSER
        ---------------------------------------------------------------------------
        */
      "datechooser-date-pane": {
        style: {
          widthTop: 1,
          colorTop: "text-hint-on-surface",
          style: "solid"
        }
      },
      "datechooser-weekday": {
        style: {
          widthBottom: 1,
          colorBottom: "text-hint-on-surface",
          style: "solid"
        }
      },
      "datechooser-week": {
        style: {
          widthRight: 1,
          colorRight: "text-hint-on-surface",
          style: "solid"
        }
      },
      "datechooser-week-header": {
        style: {
          widthBottom: 1,
          colorBottom: "text-hint-on-surface",
          widthRight: 1,
          colorRight: "text-hint-on-surface",
          style: "solid"
        }
      },

      /*
        ---------------------------------------------------------------------------
          TAB VIEW
        ---------------------------------------------------------------------------
        */
      "tabview-page-button-top": {
        style: {
          width: [0, 0, 2, 0],
          backgroundColor: "surface",
          color: "primary"
        }
      },
      "tabview-page-button-bottom": {
        include: "tabview-page-button-top",
        style: {
          width: [2, 0, 0, 0]
        }
      },
      "tabview-page-button-left": {
        include: "tabview-page-button-top",
        style: {
          width: [0, 2, 0, 0]
        }
      },
      "tabview-page-button-right": {
        include: "tabview-page-button-top",
        style: {
          width: [0, 0, 0, 2]
        }
      },

      /*
        ---------------------------------------------------------------------------
          TABLE
        ---------------------------------------------------------------------------
        */
      "statusbar": {
        style: {
          widthTop: 1,
          colorTop: "text-hint-on-surface",
          styleTop: "solid"
        }
      },
      // attention hackerery in the qx.ui.table.pane.Scroller
      // decorator: "table-scroller-focus-indicator"
      // gets applied hardcoded! So do not try to change its
      // name here!
      "table-scroller-focus-indicator": {
        style: {
          width: 1,
          style: 'dotted',
          color: "text-hint-on-surface"
        }
      },
      "table-header": {
        include: "button-box",
        style: {
          radius: 0,
          color: "text-hint-on-surface",
          width: [0, 0, 2, 0]
        }
      },
      "table-header-column-button": {
        include: "table-header"
      },
      "table-header-cell": {
        style: {}
      },
      "table-header-cell-first": {
        include: "table-header-cell"
      },
      "progressive-table-header": {
        include: "button-box",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "progressive-table-header-cell": {
        style: {
          widthRight: 1,
          color: "text-hint-on-surface"
        }
      },

      /*
        ---------------------------------------------------------------------------
          PROGRESSBAR
        ---------------------------------------------------------------------------
        */
      "progressbar": {
        style: {
          width: 1,
          color: "text-hint-on-surface"
        }
      },

      /*
        ---------------------------------------------------------------------------
          RADIO BUTTON
        ---------------------------------------------------------------------------
        */
      "radiobutton": {
        style: {
          color: "text-primary-on-surface"
        }
      },

      /*
        ---------------------------------------------------------------------------
          CHECK BOX
        ---------------------------------------------------------------------------
        */
      "checkbox": {
        style: {
          color: "text-primary-on-surface"
        }
      }
    }
  });
  qx.theme.tangible.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
    Tangible Theme for Qooxdoo
  
    Copyright:
       2018 IT'IS Foundation
       2020 Tobi Oetiker
  
    License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
    Authors:
      * Tobias Oetiker (oetiker)
  
    Origin:
      This theme is based in large parts on the osparc.theme
  
  ************************************************************************ */

  /**
   * @asset(qx/font/Roboto/*.woff)
   * @asset(qx/font/Roboto/*.woff2)
   * @asset(qx/font/Roboto/*.eot)
   * @asset(qx/font/Roboto/*.ttf)
   */

  /**
   * The simple qooxdoo font theme.
   */
  qx.Theme.define("qx.theme.tangible.Font", {
    fonts: {
      "default": {
        size: 14,
        family: ["sans-serif"],
        color: "text-primary-on-surface",
        sources: [{
          family: "Roboto",
          source: ["qx/font/Roboto/roboto-v18-latin_latin-ext-regular.eot", "qx/font/Roboto/roboto-v18-latin_latin-ext-regular.woff2", "qx/font/Roboto/roboto-v18-latin_latin-ext-regular.woff", "qx/font/Roboto/roboto-v18-latin_latin-ext-regular.ttf"]
        }]
      },
      "bold": {
        size: 14,
        family: ["sans-serif"],
        bold: true,
        color: "text-primary-on-surface",
        sources: [{
          family: "Roboto",
          source: ["qx/font/Roboto/roboto-v18-latin_latin-ext-700.eot", "qx/font/Roboto/roboto-v18-latin_latin-ext-700.woff2", "qx/font/Roboto/roboto-v18-latin_latin-ext-700.woff", "qx/font/Roboto/roboto-v18-latin_latin-ext-700.ttf"]
        }]
      },
      "headline": {
        size: 24,
        family: ["sans-serif"],
        color: "text-primary-on-surface",
        sources: [{
          family: "Roboto",
          source: ["qx/font/Roboto/roboto-v18-latin_latin-ext-regular.eot", "qx/font/Roboto/roboto-v18-latin_latin-ext-regular.woff2", "qx/font/Roboto/roboto-v18-latin_latin-ext-regular.woff", "qx/font/Roboto/roboto-v18-latin_latin-ext-regular.ttf"]
        }]
      },
      "small": {
        size: 12,
        family: ["sans-serif"],
        color: "text-primary-on-surface",
        sources: [{
          family: "Roboto",
          source: ["qx/font/Roboto/roboto-v18-latin_latin-ext-regular.eot", "qx/font/Roboto/roboto-v18-latin_latin-ext-regular.woff2", "qx/font/Roboto/roboto-v18-latin_latin-ext-regular.woff", "qx/font/Roboto/roboto-v18-latin_latin-ext-regular.ttf"]
        }]
      },
      "monospace": {
        size: 14,
        family: ["monospace"],
        color: "text-primary-on-surface",
        sources: [{
          family: "Roboto Mono",
          source: ["qx/font/Roboto/roboto-mono-v6-latin_latin-ext-regular.eot", "qx/font/Roboto/roboto-mono-v6-latin_latin-ext-regular.woff2", "qx/font/Roboto/roboto-mono-v6-latin_latin-ext-regular.woff", "qx/font/Roboto/roboto-mono-v6-latin_latin-ext-regular.ttf"]
        }]
      }
    }
  });
  qx.theme.tangible.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.tangible.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
    Tangible Theme for Qooxdoo
  
    Copyright:
       2018 IT'IS Foundation
       2020 Tobi Oetiker
  
    License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
    Authors:
      * Tobias Oetiker (oetiker)
  
    Origin:
      This theme is based in large parts on the osparc.theme
  
  ************************************************************************ */

  /* eslint no-negated-condition: "off", no-nested-ternary: "off" */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The simple qooxdoo appearance theme.
   *
   * @asset(qx/icon/Tango/16/apps/office-calendar.png)
   * @asset(qx/icon/Tango/16/places/folder-open.png)
   * @asset(qx/icon/Tango/16/places/folder.png)
   * @asset(qx/icon/Tango/16/mimetypes/text-plain.png)
   * @asset(qx/icon/Tango/16/actions/view-refresh.png)
   * @asset(qx/icon/Tango/16/actions/window-close.png)
   * @asset(qx/icon/Tango/16/actions/dialog-cancel.png)
   * @asset(qx/icon/Tango/16/actions/dialog-ok.png)
   */
  qx.Theme.define("qx.theme.tangible.Appearance", {
    appearances: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "widget": {},
      "label": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled-on-surface" : undefined
          };
        }
      },
      "image": {
        style: function style(states) {
          return {
            opacity: !states.replacement && states.disabled ? 0.3 : undefined
          };
        }
      },
      "atom": {},
      "atom/label": "label",
      "atom/icon": "image",
      "root": {
        style: function style(states) {
          return {
            backgroundColor: "surface",
            textColor: "text-primary-on-surface",
            font: "default"
          };
        }
      },
      "popup": {
        style: function style(states) {
          return {
            decorator: "popup",
            backgroundColor: "surface"
          };
        }
      },
      "tooltip": {
        include: "popup",
        style: function style(states) {
          return {
            backgroundColor: "secondary",
            textColor: "text-on-secondary",
            decorator: "tooltip",
            padding: [1, 3, 2, 3],
            offset: [10, 5, 5, 5]
          };
        }
      },
      "tooltip/atom": "atom",
      "tooltip-error": {
        include: "tooltip",
        style: function style(states) {
          return {
            textColor: "text-on-error",
            showTimeout: 100,
            hideTimeout: 10000,
            decorator: "tooltip-error",
            font: "bold",
            backgroundColor: undefined
          };
        }
      },
      "tooltip-error/atom": "atom",
      "iframe": {
        style: function style(states) {
          return {
            backgroundColor: "surface",
            decorator: "main"
          };
        }
      },
      "move-frame": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },
      "resize-frame": "move-frame",
      "dragdrop-cursor": {
        style: function style(states) {
          var icon = "nodrop";

          if (states.copy) {
            icon = "copy";
          } else if (states.move) {
            icon = "move";
          } else if (states.alias) {
            icon = "alias";
          }

          return {
            source: qx.theme.tangible.Image.URLS["cursor-" + icon],
            position: "right-top",
            offset: [2, 16, 2, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button": {
        /* qx.ui.form.Button */
        alias: "material-button",
        include: "material-button",
        style: function style(states) {
          return {
            center: true
          };
        }
      },
      "toggle-button": {
        include: "button",
        style: function style(states) {
          return {
            decorator: "toggle-button" + (states.checked ? "-checked" : "") + (states.disabled ? "-disabled" : "") + (!states.disabled && states.hovered ? "-hovered" : ""),
            textColor: states.disabled ? "text-disabled-on-primary" : "text-on-primary"
          };
        }
      },
      "toggle-button/label": {
        include: "button/label",
        style: function style(states) {
          if (states.checked) {
            return {
              textColor: undefined
            };
          }

          ;
          return {
            textColor: undefined
          };
        }
      },
      "material-button": {
        alias: "atom",
        style: function style(states) {
          var decorator = "material-button";

          if (!states.disabled) {
            if (states.pressed || states.checked) {
              decorator += "-pressed";
            } else if (states.hovered || states.focused) {
              decorator += "-hovered";
            }
          } else {
            decorator += "-disabled";
          }

          if (states.invalid && !states.disabled) {
            decorator += "-invalid";
          }

          return {
            decorator: decorator,
            padding: [6, 15],
            margin: [2, 4],
            cursor: states.disabled ? undefined : "pointer",
            minWidth: 5,
            minHeight: 5
          };
        }
      },
      "material-button/label": {
        alias: "atom/label",
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled-on-primary" : "text-on-primary"
          };
        }
      },
      "button-frame": {
        alias: "atom",
        style: function style(states) {
          var decorator = "button-box";

          if (!states.disabled) {
            if (states.hovered && !states.pressed && !states.checked) {
              decorator = "button-box-hovered";
            } else if (states.hovered && (states.pressed || states.checked)) {
              decorator = "button-box-pressed-hovered";
            } else if (states.pressed || states.checked) {
              decorator = "button-box-pressed";
            }
          }

          if (states.invalid && !states.disabled) {
            decorator += "-invalid";
          } else if (states.focused) {
            decorator += "-focused";
          }

          return {
            decorator: decorator,
            padding: [3, 8],
            cursor: states.disabled ? undefined : "pointer",
            minWidth: 5,
            minHeight: 5
          };
        }
      },
      "button-frame/label": {
        alias: "atom/label",
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled-on-primary" : "text-on-primary"
          };
        }
      },
      "hover-button": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            decorator: states.hovered ? "button-hover" : undefined
          };
        }
      },
      "menubutton": {
        include: "button",
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["arrow-down"],
            iconPosition: "right"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TEXT FIELD
      ---------------------------------------------------------------------------
      */
      "material-textfield": {
        style: function style(states) {
          var decorator;
          var padding;
          decorator = "material-textfield";
          padding = [3, 0, 4, 0];

          if (states.readonly) {
            decorator += "-readonly";
            padding = [3, 0, 5, 0];
          } else if (states.disabled) {
            decorator += "-disabled";
          } else if (states.focused) {
            decorator += "-focused";

            if (states.invalid) {
              decorator += "-invalid";
            }

            padding = [3, 0, 3, 0];
          } else if (states.invalid) {
            decorator += "-invalid";
          }

          return {
            decorator: decorator,
            padding: padding,
            textColor: states.disabled ? "text-disabled-on-surface" : states.showingPlaceholder ? "text-hint-on-surface" : undefined
          };
        }
      },
      "textfield": "material-textfield",
      "textarea": "textfield",
      "framebox": {
        style: function style(states) {
          var decorator;
          var padding;

          if (states.disabled) {
            decorator = "border-disabled";
            padding = [1, 2];
          } else if (states.invalid) {
            decorator = "border-invalid";
            padding = [1, 2];
          } else if (states.focused) {
            decorator = "border-focused";
            padding = [1, 2];
          } else {
            padding = [1, 2];
            decorator = "border";
          }

          return {
            decorator: decorator,
            padding: padding,
            textColor: states.disabled ? "text-disabled-on-surface" : states.showingPlaceholder ? "text-hint-on-surface" : undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLIT BUTTON
      ---------------------------------------------------------------------------
      */
      "splitbutton": {},
      "splitbutton/button": {
        alias: "material-button",
        style: function style(states) {
          var decorator = "material-button";

          if (!states.disabled) {
            if (states.pressed || states.checked) {
              decorator += "-pressed";
            } else if (states.hovered) {
              decorator += "-hovered";
            } else if (states.focused) {
              decorator += "-focused";
            }
          } else {
            decorator += "-disabled";
          }

          decorator += "-left";
          return {
            decorator: decorator,
            padding: [6, 15, 6, 15],
            margin: [2, 0, 2, 4],
            cursor: states.disabled ? undefined : "pointer",
            textColor: "text-primary-on-surface"
          };
        }
      },
      "splitbutton/arrow": {
        alias: "material-button",
        style: function style(states) {
          var decorator = "material-button";

          if (!states.disabled) {
            if (states.pressed || states.checked) {
              decorator += "-pressed";
            } else if (states.focused) {
              decorator += "-focused";
            } else if (states.hovered) {
              decorator += "-hovered";
            }
          } else {
            decorator += "-disabled";
          }

          decorator += "-right";
          return {
            icon: qx.theme.tangible.Image.URLS["arrow-down"],
            decorator: decorator,
            cursor: states.disabled ? undefined : "pointer",
            padding: [6, 10, 6, 10],
            margin: [2, 4, 2, 0],
            textColor: "text-on-primary"
          };
        }
      },
      "splitbutton/arrow/icon": {
        style: function style(states) {
          return {
            textColor: "text-icon-on-primary"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDEBAR
      ---------------------------------------------------------------------------
      */
      "slidebar": {},
      "slidebar/scrollpane": {},
      "slidebar/content": {},
      "slidebar/button-forward": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["arrow-" + (states.vertical ? "down" : "right")]
          };
        }
      },
      "slidebar/button-backward": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["arrow-" + (states.vertical ? "up" : "left")]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table": {
        style: function style(states) {
          return {
            rowHeight: 30
          };
        }
      },
      "table/statusbar": {
        style: function style(states) {
          return {
            decorator: "statusbar",
            padding: [2, 5]
          };
        }
      },
      "table/column-button": {
        alias: "button",
        style: function style(states) {
          return {
            decorator: "table-header-column-button",
            textColor: "text-primary-on-surface",
            backgroundColor: "surface",
            padding: 3,
            icon: qx.theme.tangible.Image.URLS["select-column-order"]
          };
        }
      },
      "table-column-reset-button": {
        include: "menu-button",
        alias: "menu-button",
        style: function style() {
          return {
            decorator: "table-header-column-button",
            icon: "icon/16/actions/view-refresh.png"
          };
        }
      },
      "table-scroller/scrollbar-x": "scrollbar",
      "table-scroller/scrollbar-y": "scrollbar",
      "table-scroller": "widget",
      "table-scroller/header": {
        style: function style() {
          return {
            textColor: "text-primary-on-surface",
            backgroundColor: "surface",
            decorator: "table-header"
          };
        }
      },
      "table-scroller/pane": {},
      "table-scroller/focus-indicator": {
        style: function style(states) {
          return {// attention hackerery in the qx.ui.table.pane.Scroller
            // decorator: "table-scroller-focus-indicator"
            // gets applied hardcoded! So do not try to change its
            // name here!
          };
        }
      },
      "table-scroller/resize-line": {
        style: function style(states) {
          return {
            backgroundColor: "text-hint-on-surface",
            width: 3
          };
        }
      },
      "table-header-cell": {
        alias: "atom",
        style: function style(states) {
          return {
            decorator: states.first ? "table-header-cell-first" : "table-header-cell",
            minWidth: 13,
            font: "bold",
            paddingTop: 3,
            paddingLeft: 5,
            cursor: states.disabled ? undefined : "pointer",
            sortIcon: states.sorted ? qx.theme.tangible.Image.URLS["table-" + (states.sortedAscending ? "ascending" : "descending")] : undefined
          };
        }
      },
      "table-header-cell/icon": {
        include: "atom/icon",
        style: function style(states) {
          return {
            paddingRight: 5
          };
        }
      },
      "table-header-cell/sort-icon": {
        style: function style(states) {
          return {
            alignY: "middle",
            alignX: "right",
            paddingRight: 5
          };
        }
      },
      "table-editor-textfield": {
        include: "framebox",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: [2, 2]
          };
        }
      },
      "table-editor-selectbox": {
        include: "selectbox",
        alias: "selectbox",
        style: function style(states) {
          return {
            padding: [0, 2]
          };
        }
      },
      "table-editor-combobox": {
        include: "combobox",
        alias: "combobox",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },
      "progressive-table-header": {
        style: function style(states) {
          return {
            decorator: "progressive-table-header"
          };
        }
      },
      "progressive-table-header-cell": {
        style: function style(states) {
          return {
            decorator: "progressive-table-header-cell",
            padding: [5, 6, 5, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREEVIRTUAL
      ---------------------------------------------------------------------------
      */
      "treevirtual": {
        include: "framebox",
        alias: "table",
        style: function style(states, superStyles) {
          return {
            padding: [superStyles.padding[0] + 2, superStyles.padding[1] + 1]
          };
        }
      },
      "treevirtual-folder": {
        style: function style(states) {
          return {
            icon: states.opened ? // the old treevirtual code can not use fonticons
            "icon/16/places/folder-open.png" : "icon/16/places/folder.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-file": {
        include: "treevirtual-folder",
        alias: "treevirtual-folder",
        style: function style(states) {
          return {
            icon: "icon/16/mimetypes/text-plain.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-line": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["treevirtual-line"]
          };
        }
      },
      "treevirtual-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["tree-minus"]
          };
        }
      },
      "treevirtual-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["tree-plus"]
          };
        }
      },
      "treevirtual-only-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["treevirtual-minus-only"]
          };
        }
      },
      "treevirtual-only-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["treevirtual-plus-only"]
          };
        }
      },
      "treevirtual-start-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["treevirtual-minus-start"]
          };
        }
      },
      "treevirtual-start-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["treevirtual-plus-start"]
          };
        }
      },
      "treevirtual-end-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["treevirtual-minus-end"]
          };
        }
      },
      "treevirtual-end-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["treevirtual-plus-end"]
          };
        }
      },
      "treevirtual-cross-contract": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["treevirtual-minus-cross"]
          };
        }
      },
      "treevirtual-cross-expand": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["treevirtual-plus-cross"]
          };
        }
      },
      "treevirtual-end": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["treevirtual-end"]
          };
        }
      },
      "treevirtual-cross": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["treevirtual-cross"]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        RESIZER
      ---------------------------------------------------------------------------
      */
      "resizer": {
        style: function style(states) {
          return {
            decorator: "main"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane": {},
      "splitpane/splitter": {
        style: function style(states) {
          return {
            backgroundColor: "text-hint-on-surface"
          };
        }
      },
      "splitpane/splitter/knob": {
        style: function style(states) {
          return {
            source: qx.theme.tangible.Image.URLS["knob-" + (states.horizontal ? "horizontal" : "vertical")],
            padding: 0
          };
        }
      },
      "splitpane/slider": {
        style: function style(states) {
          return {
            backgroundColor: "text-hint-on-surface",
            opacity: 0.3
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        style: function style(states) {
          var result = {
            backgroundColor: "surface",
            decorator: "main",
            spacingX: 6,
            spacingY: 1,
            iconColumnWidth: 16,
            arrowColumnWidth: 4,
            padding: 1,
            placementModeY: states.submenu || states.contextmenu ? "best-fit" : "keep-align"
          };

          if (states.submenu) {
            result.position = "right-top";
            result.offset = [-2, -3];
          }

          if (states.contextmenu) {
            result.offset = 4;
          }

          return result;
        }
      },
      "menu/slidebar": "menu-slidebar",
      "menu-slidebar": "widget",
      "menu-slidebar-button": {
        style: function style(states) {
          return {
            backgroundColor: states.hovered ? "primary-hovered" : undefined,
            padding: 6,
            center: true
          };
        }
      },
      "menu-slidebar/button-backward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["arrow-up" + (states.hovered ? "-invert" : "")]
          };
        }
      },
      "menu-slidebar/button-forward": {
        include: "menu-slidebar-button",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["arrow-down" + (states.hovered ? "-invert" : "")]
          };
        }
      },
      "menu-separator": {
        style: function style(states) {
          return {
            height: 0,
            decorator: "menu-separator",
            marginTop: 4,
            marginBottom: 4,
            marginLeft: 2,
            marginRight: 2
          };
        }
      },
      "menu-button": {
        alias: "atom",
        style: function style(states) {
          return {
            backgroundColor: states.selected ? "primary-selected" : undefined,
            textColor: states.selected ? "text-on-primary" : "text-primary-on-surface",
            padding: [2, 6]
          };
        }
      },
      "menu-button/icon": {
        include: "image",
        style: function style(states) {
          return {
            alignY: "middle",
            textColor: states.selected ? "text-icon-on-primary" : "text-icon-on-surface"
          };
        }
      },
      "menu-button/label": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            padding: 1
          };
        }
      },
      "menu-button/shortcut": {
        include: "label",
        style: function style(states) {
          return {
            alignY: "middle",
            marginLeft: 14,
            padding: 1
          };
        }
      },
      "menu-button/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: qx.theme.tangible.Image.URLS["arrow-right" + (states.selected ? "-invert" : "")],
            alignY: "middle"
          };
        }
      },
      "menu-checkbox": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          var icon = "menu-checkbox";

          if (states.checked) {
            icon += "-checked";
          }

          return {
            icon: qx.theme.tangible.Image.URLS[icon]
          };
        }
      },
      "menu-radiobutton": {
        alias: "menu-button",
        include: "menu-button",
        style: function style(states) {
          var icon = "menu-radiobutton";

          if (states.checked) {
            icon += "-checked";
          }

          return {
            icon: qx.theme.tangible.Image.URLS[icon]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar": {
        style: function style(states) {
          return {
            backgroundColor: "surface",
            padding: [4, 2]
          };
        }
      },
      "menubar-button": {
        style: function style(states) {
          var decorator;
          var padding = [2, 6];

          if (!states.disabled) {
            if (states.pressed) {
              decorator = "menubar-button-pressed";
            } else if (states.hovered) {
              decorator = "menubar-button-hovered";
            }
          }

          return {
            padding: padding,
            cursor: states.disabled ? undefined : "pointer",
            textColor: "text-on-primary",
            decorator: decorator
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "virtual-list": "list",
      "virtual-list/row-layer": "row-layer",
      "row-layer": "widget",
      "column-layer": "widget",
      "group-item": {
        include: "label",
        alias: "label",
        style: function style(states) {
          return {
            padding: 4,
            backgroundColor: "primary",
            textColor: "text-on-primary",
            font: "bold"
          };
        }
      },
      "virtual-selectbox": "selectbox",
      "virtual-selectbox/dropdown": "popup",
      "virtual-selectbox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-combobox": "combobox",
      "virtual-combobox/dropdown": "popup",
      "virtual-combobox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-tree": {
        include: "tree",
        alias: "tree",
        style: function style(states) {
          return {
            itemHeight: 21
          };
        }
      },
      "virtual-tree-folder": "tree-folder",
      "virtual-tree-file": "tree-file",
      "cell": {
        style: function style(states) {
          return {
            backgroundColor: states.selected ? "primary-selected" : "surface",
            textColor: states.selected ? "text-on-primary" : "text-primary-on-surface",
            padding: [3, 6]
          };
        }
      },
      "cell-string": "cell",
      "cell-number": {
        include: "cell",
        style: function style(states) {
          return {
            textAlign: "right"
          };
        }
      },
      "cell-image": "cell",
      "cell-boolean": "cell",
      "cell-atom": "cell",
      "cell-date": "cell",
      "cell-html": "cell",

      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar": {},
      "scrollbar/slider": {},
      "scrollbar/slider/knob": {
        style: function style(states) {
          var decorator = "scroll-knob";

          if (!states.disabled) {
            if (states.hovered && !states.pressed && !states.checked) {
              decorator = "scroll-knob-hovered";
            } else if (states.hovered && (states.pressed || states.checked)) {
              decorator = "scroll-knob-pressed-hovered";
            } else if (states.pressed || states.checked) {
              decorator = "scroll-knob-pressed";
            }
          }

          return {
            height: 8,
            width: 8,
            marginLeft: 2,
            marginTop: 2,
            cursor: states.disabled ? undefined : "pointer",
            decorator: decorator,
            minHeight: states.horizontal ? undefined : 30,
            minWidth: states.horizontal ? 30 : undefined
          };
        }
      },
      "scrollbar/button": {
        style: function style(states) {
          return {
            height: 0,
            width: 0,
            margin: [2, 2]
          };
        }
      },
      "scrollbar/button-begin": "scrollbar/button",
      "scrollbar/button-end": "scrollbar/button",

      /*
      ---------------------------------------------------------------------------
        SCROLLAREA
      ---------------------------------------------------------------------------
      */
      "scrollarea/corner": {
        style: function style(states) {
          return {
            backgroundColor: "surface"
          };
        }
      },
      "scrollarea": "widget",
      "scrollarea/pane": "widget",
      "scrollarea/scrollbar-x": "scrollbar",
      "scrollarea/scrollbar-y": "scrollbar",

      /*
      ---------------------------------------------------------------------------
        RADIO BUTTON
      ---------------------------------------------------------------------------
      */
      "radiobutton": {
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS[states.checked ? "radiobutton-checked" : "radiobutton-unchecked"],
            paddingTop: 2,
            textColor: states.disabled ? "text-disabled-on-surface" : states.invalid ? "error" : states.checked ? "primary" : "text-primary-on-surface",
            gap: 6
          };
        }
      },
      "radiobutton/icon": {
        style: function style(states) {
          return {
            decorator: "radiobutton",
            padding: [2, 0, 0, 0]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        FORM
      ---------------------------------------------------------------------------
      */
      "form-renderer-label": {
        include: "label",
        style: function style() {
          return {
            paddingTop: 3
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        CHECK BOX
      ---------------------------------------------------------------------------
      */
      "checkbox": {
        alias: "atom",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS[states.checked ? "checkbox-checked" : states.undetermined ? "checkbox-undetermined" : "checkbox-blank"],
            textColor: states.disabled ? "text-disabled-on-surface" : states.invalid ? "error" : states.checked ? "primary" : "text-primary-on-surface",
            gap: 6
          };
        }
      },
      "checkbox/icon": {
        style: function style(states) {
          return {
            decorator: "checkbox",
            padding: 0
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPINNER
      ---------------------------------------------------------------------------
      */
      "spinner": {
        style: function style(states) {
          return {
            textColor: states.disabled ? "text-disabled-on-surface" : undefined
          };
        }
      },
      "spinner/textfield": "textfield",
      "spinner/upbutton": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["arrow-up-small"],
            decorator: undefined,
            width: 12,
            height: 6,
            padding: [-1, 0, 0, 0]
          };
        }
      },
      "spinner/downbutton": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["arrow-down-small"],
            decorator: undefined,
            width: 12,
            height: 6,
            padding: [-1, 0, 0, 0]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTBOX
      ---------------------------------------------------------------------------
      */
      "selectbox": "textfield",
      "selectbox/atom": "atom",
      "selectbox/popup": "popup",
      "selectbox/list": {
        alias: "list",
        include: "list",
        style: function style() {
          return {
            decorator: undefined
          };
        }
      },
      "selectbox/arrow": {
        include: "image",
        style: function style(states) {
          return {
            source: qx.theme.tangible.Image.URLS["arrow-down"],
            paddingRight: 0,
            paddingLeft: 2,
            paddingTop: -3
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COMBO BOX
      ---------------------------------------------------------------------------
      */
      "combobox": {},
      "combobox/button": {
        alias: "button-frame",
        include: "button-frame",
        style: function style(states) {
          var decorator = "material-textfield";

          if (states.focused) {
            decorator += "-focused";

            if (states.invalid) {
              decorator += "-invalid";
            }
          } else if (states.invalid) {
            decorator += "-invalid";
          } else if (states.disabled) {
            decorator += "-disabled";
          }

          return {
            backgroundColor: undefined,
            icon: qx.theme.tangible.Image.URLS["arrow-down"],
            decorator: decorator,
            padding: [0, 0, 0, 0]
          };
        }
      },
      "combobox/popup": "popup",
      "combobox/list": {
        alias: "list",
        style: function style(states) {
          return {
            paddingRight: 2
          };
        }
      },
      "combobox/textfield": "textfield",

      /*
      ---------------------------------------------------------------------------
        DATEFIELD
      ---------------------------------------------------------------------------
      */
      "datefield": "textfield",
      "datefield/button": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function style(states) {
          return {
            icon: "@MaterialIcons/calendar_today/14",
            padding: [0, 0, 0, 0],
            backgroundColor: undefined,
            decorator: undefined,
            width: 16
          };
        }
      },
      "datefield/textfield": {
        alias: "textfield",
        include: "textfield",
        style: function style(states) {
          return {
            decorator: undefined,
            padding: 0
          };
        }
      },
      "datefield/list": {
        alias: "datechooser",
        include: "datechooser",
        style: function style(states) {
          return {
            decorator: undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        LIST
      ---------------------------------------------------------------------------
      */
      "list": {
        alias: "scrollarea",
        include: "framebox"
      },
      "listitem": {
        alias: "atom",
        style: function style(states) {
          var padding = [3, 5, 3, 5];

          if (states.lead) {
            padding = [2, 4, 2, 4];
          }

          if (states.dragover) {
            padding[2] -= 2;
          }

          return {
            gap: 4,
            padding: padding,
            backgroundColor: states.selected ? states.disabled ? "primary-disabled" : "primary" : "transparent",
            textColor: states.selected ? "text-on-primary" : "text-primary-on-surface",
            decorator: states.lead ? "lead-item" : states.dragover ? "dragover" : undefined,
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDER
      ---------------------------------------------------------------------------
      */
      "slider": {
        style: function style(states) {
          var decorator;
          var padding;

          if (states.disabled) {
            decorator = "border-disabled";
            padding = [1, 2];
          } else if (states.invalid) {
            decorator = "border-invalid";
            padding = [1, 2];
          } else if (states.focused) {
            decorator = "border-focused";
            padding = [1, 2];
          } else {
            padding = [1, 2];
            decorator = "border";
          }

          return {
            decorator: decorator,
            padding: padding
          };
        }
      },
      "slider/knob": "scrollbar/slider/knob",

      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "groupbox": {},
      "groupbox/legend": {
        alias: "atom",
        style: function style(states) {
          return {
            textColor: states.invalid ? "error" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },
      "groupbox/frame": {
        style: function style(states) {
          return {
            backgroundColor: "surface",
            padding: [6, 9],
            margin: [18, 2, 2, 2],
            decorator: "box"
          };
        }
      },
      "check-groupbox": "groupbox",
      "check-groupbox/legend": {
        alias: "checkbox",
        include: "checkbox",
        style: function style(states) {
          return {
            textColor: states.invalid ? "error" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },
      "radio-groupbox": "groupbox",
      "radio-groupbox/legend": {
        alias: "radiobutton",
        include: "radiobutton",
        style: function style(states) {
          return {
            textColor: states.invalid ? "error" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREE
      ---------------------------------------------------------------------------
      */
      "tree-folder/open": {
        include: "image",
        style: function style(states) {
          return {
            source: states.opened ? qx.theme.tangible.Image.URLS["tree-minus"] : qx.theme.tangible.Image.URLS["tree-plus"],
            textColor: states.selected ? "text-on-primary" : "text-primary-on-surface"
          };
        }
      },
      "tree-folder": {
        style: function style(states) {
          return {
            padding: [2, 8, 2, 5],
            icon: states.opened ? qx.theme.tangible.Image.URLS["folder-open"] : qx.theme.tangible.Image.URLS["folder"],
            backgroundColor: states.selected ? states.disables ? "primary-disabled" : "primary-selected" : "surface",
            textColor: states.selected ? "text-on-primary" : "text-disabled-on-primary",
            iconOpened: qx.theme.tangible.Image.URLS["folder-open"],
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree-folder/icon": {
        include: "image",
        style: function style(states) {
          return {
            padding: [0, 4, 0, 0],
            textColor: states.selected ? "text-icon-on-primary" : "text-primary-on-surface"
          };
        }
      },
      "tree-folder/label": {
        style: function style(states) {
          return {
            padding: [1, 2],
            textColor: states.selected ? "text-on-primary" : "text-primary-on-surface"
          };
        }
      },
      "tree-file": {
        include: "tree-folder",
        alias: "tree-folder",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["file"]
          };
        }
      },
      "tree": {
        include: "list",
        alias: "list",
        style: function style(states) {
          return {
            contentPadding: [4, 1],
            padding: 1
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: function style(states) {
          return {
            contentPadding: [10, 10, 10, 10],
            backgroundColor: "surface",
            decorator: states.maximized ? undefined : states.active ? "window-active" : "window"
          };
        }
      },
      "window-resize-frame": "resize-frame",
      "window/pane": {
        style: function style(states) {
          return {
            padding: 10
          };
        }
      },
      "window/captionbar": {
        style: function style(states) {
          return {
            backgroundColor: states.active ? "primary-selected" : "primary",
            margin: 0,
            padding: 8,
            decorator: "window-caption"
          };
        }
      },
      "window/icon": {
        style: function style(states) {
          return {
            marginRight: 4,
            marginTop: 2
          };
        }
      },
      "window/title": {
        style: function style(states) {
          return {
            cursor: "default",
            font: states.active ? "bold" : "default",
            textColor: states.active ? "text-on-primary" : "text-on-primary",
            marginRight: 20,
            marginLeft: 4,
            alignY: "middle"
          };
        }
      },
      "window/minimize-button": {
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["window-minimize"] + "/18",
            padding: 0,
            cursor: states.disabled ? undefined : "pointer",
            textColor: "text-on-primary"
          };
        }
      },
      "window/restore-button": {
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["window-restore"] + "/18",
            padding: 0,
            cursor: states.disabled ? undefined : "pointer",
            textColor: "text-on-primary"
          };
        }
      },
      "window/maximize-button": {
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["window-maximize"] + "/18",
            padding: 0,
            cursor: states.disabled ? undefined : "pointer",
            textColor: "text-on-primary"
          };
        }
      },
      "window/close-button": {
        alias: "button",
        style: function style(states) {
          return {
            icon: qx.theme.tangible.Image.URLS["window-close"] + "/18",
            padding: 0,
            cursor: states.disabled ? undefined : "pointer",
            textColor: "text-on-primary"
          };
        }
      },
      "window/statusbar": {
        style: function style(states) {
          return {
            decorator: "statusbar",
            padding: [2, 6]
          };
        }
      },
      "window/statusbar-text": "label",

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser": {
        style: function style(states) {
          return {
            decorator: "main",
            minWidth: 220
          };
        }
      },
      "datechooser/navigation-bar": {
        style: function style(states) {
          return {
            backgroundColor: "surface",
            textColor: states.disabled ? "text-disabled-on-surface" : states.invalid ? "error" : undefined,
            padding: [2, 10]
          };
        }
      },
      "datechooser/last-year-button-tooltip": "tooltip",
      "datechooser/last-month-button-tooltip": "tooltip",
      "datechooser/next-year-button-tooltip": "tooltip",
      "datechooser/next-month-button-tooltip": "tooltip",
      "datechooser/last-year-button": "datechooser/button",
      "datechooser/last-month-button": "datechooser/button",
      "datechooser/next-year-button": "datechooser/button",
      "datechooser/next-month-button": "datechooser/button",
      "datechooser/button/icon": {},
      "datechooser/button": {
        style: function style(states) {
          var result = {
            width: 17,
            show: "icon",
            cursor: states.disabled ? undefined : "pointer"
          };

          if (states.lastYear) {
            result.icon = qx.theme.tangible.Image.URLS["arrow-rewind"];
          } else if (states.lastMonth) {
            result.icon = qx.theme.tangible.Image.URLS["arrow-left"];
          } else if (states.nextYear) {
            result.icon = qx.theme.tangible.Image.URLS["arrow-forward"];
          } else if (states.nextMonth) {
            result.icon = qx.theme.tangible.Image.URLS["arrow-right"];
          }

          return result;
        }
      },
      "datechooser/month-year-label": {
        style: function style(states) {
          return {
            font: "bold",
            textAlign: "center"
          };
        }
      },
      "datechooser/date-pane": {
        style: function style(states) {
          return {
            decorator: "datechooser-date-pane",
            backgroundColor: "surface"
          };
        }
      },
      "datechooser/weekday": {
        style: function style(states) {
          return {
            decorator: "datechooser-weekday",
            font: states.weekend ? "bold" : "default",
            textAlign: "center",
            textColor: states.disabled ? "text-disabled-on-surface" : "text-primary-on-surface",
            backgroundColor: "surface",
            paddingTop: 2
          };
        }
      },
      "datechooser/day": {
        style: function style(states) {
          return {
            textAlign: "center",
            decorator: states.today ? "main" : undefined,
            textColor: states.disabled ? "text-disabled-on-surface" : states.selected ? "text-on-primary" : states.otherMonth ? "text-disabled-on-surface" : undefined,
            backgroundColor: states.selected ? states.disabled ? "primary-disabled" : "primary" : undefined,
            padding: states.today ? [1, 3] : [2, 4]
          };
        }
      },
      "datechooser/week": {
        style: function style(states) {
          return {
            textAlign: "center",
            textColor: "text-primary-on-surface",
            padding: [2, 4],
            decorator: states.header ? "datechooser-week-header" : "datechooser-week"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: function style(states) {
          return {
            decorator: "progressbar",
            padding: 1,
            backgroundColor: "surface",
            width: 200,
            height: 20
          };
        }
      },
      "progressbar/progress": {
        style: function style(states) {
          return {
            backgroundColor: states.disabled ? "primary-disabled" : "primary"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar": {
        style: function style(states) {
          return {
            backgroundColor: "primary",
            padding: 0
          };
        }
      },
      "toolbar/part": {
        style: function style(states) {
          return {
            margin: [0, 15]
          };
        }
      },
      "toolbar/part/container": {},
      "toolbar/part/handle": {},
      "toolbar-separator": {
        style: function style(states) {
          return {
            decorator: undefined,
            margin: [7, 0],
            width: 4
          };
        }
      },
      "toolbar-button": {
        alias: "atom",
        style: function style(states) {
          // set the margin
          var margin = [7, 10];

          if (states.left || states.middle || states.right) {
            margin = [7, 3];
          }

          var decorator = "toolbar-button";

          if (states.hovered || states.pressed || states.checked) {
            decorator += "-hovered";
          }

          return {
            cursor: states.disabled ? undefined : "pointer",
            decorator: decorator,
            textColor: "text-on-primary",
            margin: margin,
            padding: [3, 5]
          };
        }
      },
      "toolbar-menubutton": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          return {
            showArrow: true
          };
        }
      },
      "toolbar-menubutton/arrow": {
        alias: "image",
        include: "image",
        style: function style(states) {
          return {
            source: qx.theme.tangible.Image.URLS["arrow-down"],
            cursor: states.disabled ? undefined : "pointer",
            padding: 0,
            textColor: "text-on-primary",
            marginLeft: 2
          };
        }
      },
      "toolbar-splitbutton": {},
      "toolbar-splitbutton/button": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          // set the margin
          var margin = [7, 0, 7, 10];

          if (states.left || states.middle || states.right) {
            margin = [7, 0, 7, 3];
          }

          var decorator = "toolbar-button";

          if (states.hovered || states.pressed || states.focused || states.checked) {
            decorator += "-hovered";
          }

          decorator += "-left";
          return {
            decorator: decorator,
            margin: margin
          };
        }
      },
      "toolbar-splitbutton/arrow": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function style(states) {
          // set the margin
          var margin = [7, 10, 7, 0];

          if (states.left || states.middle || states.right) {
            margin = [7, 3, 7, 0];
          }

          var decorator = "toolbar-button";

          if (states.hovered || states.pressed || states.focused || states.checked) {
            decorator += "-hovered";
          }

          decorator += "-right";
          return {
            icon: qx.theme.tangible.Image.URLS["arrow-down"],
            decorator: decorator,
            margin: margin
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview": {},
      "tabview/bar": {
        alias: "slidebar",
        style: function style(states) {
          var marginTop = 0;
          var marginRight = 0;
          var marginBottom = 0;
          var marginLeft = 0;

          if (states.barTop) {
            marginBottom -= 1;
          } else if (states.barBottom) {
            marginTop -= 1;
          } else if (states.barRight) {
            marginLeft -= 1;
          } else {
            marginRight -= 1;
          }

          return {
            marginBottom: marginBottom,
            marginTop: marginTop,
            marginLeft: marginLeft,
            marginRight: marginRight
          };
        }
      },
      "tabview/bar/button-forward": {
        include: "slidebar/button-forward",
        alias: "slidebar/button-forward",
        style: function style(states) {
          if (states.barTop) {
            return {
              marginTop: 4,
              marginBottom: 2,
              decorator: null
            };
          } else if (states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 4,
              decorator: null
            };
          } else if (states.barLeft) {
            return {
              marginLeft: 4,
              marginRight: 2,
              decorator: null
            };
          }

          return {
            marginLeft: 2,
            marginRight: 4,
            decorator: null
          };
        }
      },
      "tabview/bar/button-backward": {
        include: "slidebar/button-backward",
        alias: "slidebar/button-backward",
        style: function style(states) {
          if (states.barTop) {
            return {
              marginTop: 4,
              marginBottom: 2,
              decorator: null
            };
          } else if (states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 4,
              decorator: null
            };
          } else if (states.barLeft) {
            return {
              marginLeft: 4,
              marginRight: 2,
              decorator: null
            };
          }

          return {
            marginLeft: 2,
            marginRight: 4,
            decorator: null
          };
        }
      },
      "tabview/pane": {
        style: function style(states) {
          var marginTop = 0;
          var marginBottom = 0;
          var marginLeft = 0;
          var marginRight = 0;
          var decorator;

          if (states.barTop) {
            marginTop = -1;
            decorator = "main-top";
          } else if (states.barBottom) {
            marginBottom = -1;
            decorator = "main-bottom";
          } else if (states.barLeft) {
            marginLeft = -1;
            decorator = "main-left";
          } else {
            marginRight = -1;
            decorator = "main-right";
          }

          return {
            marginLeft: marginLeft,
            marginRight: marginRight,
            marginTop: marginTop,
            marginBottom: marginBottom,
            padding: 10,
            decorator: decorator,
            backgroundColor: "surface"
          };
        }
      },
      "tabview-page": "widget",
      "tabview-page/button": {
        style: function style(states) {
          var decorator;
          var padding; // default padding

          if (states.barTop || states.barBottom) {
            padding = [8, 16, 8, 13];
          } else if (states.barRight) {
            padding = [8, 8, 8, 12];
          } else if (states.barLeft) {
            padding = [8, 8, 8, 8];
          } // decorator


          if (states.checked) {
            if (states.barTop) {
              decorator = "tabview-page-button-top";
              padding[2] -= 2;
            } else if (states.barBottom) {
              decorator = "tabview-page-button-bottom";
              padding[0] -= 2;
            } else if (states.barRight) {
              decorator = "tabview-page-button-right";
              padding[3] -= 2;
            } else if (states.barLeft) {
              decorator = "tabview-page-button-left";
              padding[1] -= 2;
            }
          }

          return {
            zIndex: states.checked ? 10 : 5,
            decorator: decorator,
            textColor: states.disabled ? "text-disabled-on-surface" : "text-primary-on-surface",
            font: states.checked ? "bold" : undefined,
            padding: padding,
            cursor: "pointer"
          };
        }
      },
      "tabview-page/button/label": {
        alias: "label",
        style: function style(states) {
          return {
            padding: [0, 1, 0, 1]
          };
        }
      },
      "tabview-page/button/icon": "image",
      "tabview-page/button/close-button": {
        alias: "atom",
        style: function style(states) {
          return {
            cursor: states.disabled ? undefined : "pointer",
            icon: qx.theme.tangible.Image.URLS["tabview-close"]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR POPUP
      ---------------------------------------------------------------------------
      */
      "colorpopup": {
        alias: "popup",
        include: "popup",
        style: function style(states) {
          return {
            padding: 5
          };
        }
      },
      "colorpopup/field": {
        style: function style(states) {
          return {
            margin: 2,
            width: 14,
            height: 14,
            backgroundColor: "surface",
            decorator: "main"
          };
        }
      },
      "colorpopup/selector-button": "button",
      "colorpopup/auto-button": "button",
      "colorpopup/preview-pane": "groupbox",
      "colorpopup/current-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginLeft: 4,
            decorator: "main",
            allowGrowX: true
          };
        }
      },
      "colorpopup/selected-preview": {
        style: function style(state) {
          return {
            height: 20,
            padding: 4,
            marginRight: 4,
            decorator: "main",
            allowGrowX: true
          };
        }
      },
      "colorpopup/colorselector-okbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-ok.png"
          };
        }
      },
      "colorpopup/colorselector-cancelbutton": {
        alias: "button",
        include: "button",
        style: function style(states) {
          return {
            icon: "icon/16/actions/dialog-cancel.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR SELECTOR
      ---------------------------------------------------------------------------
      */
      "colorselector": "widget",
      "colorselector/control-bar": "widget",
      "colorselector/visual-pane": "groupbox",
      "colorselector/control-pane": "widget",
      "colorselector/preset-grid": "widget",
      "colorselector/colorbucket": {
        style: function style(states) {
          return {
            decorator: "main",
            width: 16,
            height: 16
          };
        }
      },
      "colorselector/preset-field-set": "groupbox",
      "colorselector/input-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/preview-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function style() {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/hex-field-composite": "widget",
      "colorselector/hex-field": "textfield",
      "colorselector/rgb-spinner-composite": "widget",
      "colorselector/rgb-spinner-red": "spinner",
      "colorselector/rgb-spinner-green": "spinner",
      "colorselector/rgb-spinner-blue": "spinner",
      "colorselector/hsb-spinner-composite": "widget",
      "colorselector/hsb-spinner-hue": "spinner",
      "colorselector/hsb-spinner-saturation": "spinner",
      "colorselector/hsb-spinner-brightness": "spinner",
      "colorselector/preview-content-old": {
        style: function style(states) {
          return {
            decorator: "main",
            width: 50,
            height: 25
          };
        }
      },
      "colorselector/preview-content-new": {
        style: function style(states) {
          return {
            decorator: "main",
            backgroundColor: "surface",
            width: 50,
            height: 25
          };
        }
      },
      "colorselector/hue-saturation-field": {
        style: function style(states) {
          return {
            decorator: "main",
            margin: 5
          };
        }
      },
      "colorselector/brightness-field": {
        style: function style(states) {
          return {
            decorator: "main",
            margin: [5, 7]
          };
        }
      },
      "colorselector/hue-saturation-pane": "widget",
      "colorselector/hue-saturation-handle": "widget",
      "colorselector/brightness-pane": "widget",
      "colorselector/brightness-handle": "widget",

      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header": {
        style: function style(states) {
          return {
            font: "headline",
            textColor: "text-on-primary",
            backgroundColor: "primary",
            padding: [8, 12]
          };
        }
      },
      "app-header-label": {
        style: function style(states) {
          return {
            paddingTop: 5
          };
        }
      },
      "app-splitpane": {
        alias: "splitpane",
        style: function style(states) {
          return {
            padding: [0, 10, 10, 10]
          };
        }
      }
    }
  });
  qx.theme.tangible.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.tangible.ColorDark": {
        "require": true
      },
      "qx.theme.tangible.Decoration": {
        "require": true
      },
      "qx.theme.tangible.Font": {
        "require": true
      },
      "qx.theme.tangible.Appearance": {
        "require": true
      },
      "qx.theme.icon.Tango": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
    OSparc Dark Theme for Qooxdoo
  
    Copyright:
       2018 IT'IS Foundation
  
    License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
    Authors:
      * Tobias Oetiker (oetiker)
  
    Origin:
      This theme is based in large parts on the osparc.theme
  ************************************************************************ */

  /**
   * Tangible Theme (Dark)
   *
   * The tangible theme is inspired by ideas from material design. A lot of work went into designing a higly automated color
   * system. In order to customize the theme to your taste, simply create your own color system. Use qx.theme.tangible.ColorDark for inspiration.
   *
   * The Tangible Theme is very new and still in a state of flux. PRs highly welcome. Use https://material.io as a visual guide.
   * 
   */
  qx.Theme.define("qx.theme.TangibleDark", {
    title: "Tangible Dark Theme",
    meta: {
      color: qx.theme.tangible.ColorDark,
      decoration: qx.theme.tangible.Decoration,
      font: qx.theme.tangible.Font,
      appearance: qx.theme.tangible.Appearance,
      icon: qx.theme.icon.Tango
    }
  });
  qx.theme.TangibleDark.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
    Tangible Theme for Qooxdoo
  
    Copyright:
       2018 IT'IS Foundation
       2020 Tobi Oetiker
  
    License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
    Authors:
      * Tobias Oetiker (oetiker)
  
    Origin:
      This theme is based in large parts on the osparc.theme
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * Mapping class for all images used in the tangible theme.
   *
   * @asset(qx/iconfont/MaterialIcons/materialicons-v50.ttf)
   * @asset(qx/iconfont/MaterialIcons/materialicons-v50.woff2)
   * @asset(qx/iconfont/MaterialIcons/materialicons-v50.woff)
   * @asset(qx/iconfont/MaterialIcons/materialicons-v50.eot)
   * @asset(qx/static/blank.png)
   */
  qx.Class.define("qx.theme.tangible.Image", {
    extend: qx.core.Object,
    statics: {
      /**
       * Holds a map containing all the URL to the images.
       * @internal
       */
      URLS: {
        "blank": "qx/static/blank.png",
        // checkbox
        "checkbox-checked": "@MaterialIcons/check_box/15",
        "checkbox-blank": "@MaterialIcons/check_box_outline_blank/15",
        "checkbox-undetermined": "@MaterialIcons/indeterminate_check_box/15",
        "radiobutton-checked": "@MaterialIcons/radio_button_on/15",
        "radiobutton-unchecked": "@MaterialIcons/radio_button_off/15",
        // window
        "window-minimize": "@MaterialIcons/keyboard_arrow_down",
        "window-maximize": "@MaterialIcons/fullscreen",
        "window-restore": "@MaterialIcons/fullscreen_exit",
        "window-close": "@MaterialIcons/close",
        // cursor
        "cursor-copy": "decoration/cursors/copy.gif",
        "cursor-move": "decoration/cursors/move.gif",
        "cursor-alias": "decoration/cursors/alias.gif",
        "cursor-nodrop": "decoration/cursors/nodrop.gif",
        // arrows
        "arrow-right": "@MaterialIcons/keyboard_arrow_right/18",
        "arrow-left": "@MaterialIcons/keyboard_arrow_left/18",
        "arrow-up": "@MaterialIcons/keyboard_arrow_up/18",
        "arrow-down": "@MaterialIcons/keyboard_arrow_down/18",
        "arrow-forward": "@MaterialIcons/fast_forward/18",
        "arrow-rewind": "@MaterialIcons/fast_rewind/18",
        "arrow-down-small": "@MaterialIcons/keyboard_arrow_down/13",
        "arrow-up-small": "@MaterialIcons/keyboard_arrow_up/13",
        "arrow-up-invert": "@MaterialIcons/keyboard_arrow_up/18",
        "arrow-down-invert": "@MaterialIcons/keyboard_arrow_down/18",
        "arrow-right-invert": "@MaterialIcons/keyboard_arrow_right/18",
        // split pane
        "knob-horizontal": "@MaterialIcons/drag_indicator/12",
        "knob-vertical": "@MaterialIcons/drag_handle/12",
        // tree (someone is using this without fonticon support)
        "tree-minus": "@MaterialIcons/arrow_drop_down/16",
        "tree-plus": "@MaterialIcons/arrow_right/16",
        // table
        "select-column-order": "@MaterialIcons/reorder/15",
        "table-ascending": "@MaterialIcons/keyboard_arrow_up/14",
        "table-descending": "@MaterialIcons/keyboard_arrow_down/14",
        // tree virtual
        "treevirtual-line": "decoration/treevirtual/line.gif",
        "treevirtual-minus-only": "decoration/treevirtual/only_minus.gif",
        "treevirtual-plus-only": "decoration/treevirtual/only_plus.gif",
        "treevirtual-minus-start": "decoration/treevirtual/start_minus.gif",
        "treevirtual-plus-start": "decoration/treevirtual/start_plus.gif",
        "treevirtual-minus-end": "decoration/treevirtual/end_minus.gif",
        "treevirtual-plus-end": "decoration/treevirtual/end_plus.gif",
        "treevirtual-minus-cross": "decoration/treevirtual/cross_minus.gif",
        "treevirtual-plus-cross": "decoration/treevirtual/cross_plus.gif",
        "treevirtual-end": "decoration/treevirtual/end.gif",
        "treevirtual-cross": "decoration/treevirtual/cross.gif",
        "folder-open": "@MaterialIcons/folder_open/15",
        "folder": "@MaterialIcons/folder/15",
        "file": "@MaterialIcons/insert_drive_file/15",
        // menu
        "menu-checkbox": "@MaterialIcons/check_box_outline_blank/15",
        "menu-checkbox-checked": "@MaterialIcons/check_box/15",
        "menu-radiobutton-checked": "@MaterialIcons/radio_button_checked/15",
        "menu-radiobutton": "@MaterialIcons/radio_button_unchecked/15",
        // tabview
        "tabview-close": "decoration/tabview/close.gif"
      }
    }
  });
  qx.theme.tangible.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.tangible.ColorEngine": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
    Tangible Light Theme for Qooxdoo
  
    Copyright:
       2018 IT'IS Foundation
       2020 Tobi Oetiker
  
    License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
    Authors:
      * Tobias Oetiker (oetiker)
  
    Origin:
      This theme is inspired by ideas from Material design.
  ************************************************************************ */

  /**
   * Simple color theme
   */
  qx.Theme.define("qx.theme.tangible.ColorLight", {
    extend: qx.theme.tangible.ColorEngine,
    colors: {
      // theme colors
      "primary": "#6200ee",
      "secondary": "#018786",
      "surface": "#ffffff",
      "error": "#b00020"
    }
  });
  qx.theme.tangible.ColorLight.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.tangible.ColorLight": {
        "require": true
      },
      "qx.theme.tangible.Decoration": {
        "require": true
      },
      "qx.theme.tangible.Font": {
        "require": true
      },
      "qx.theme.tangible.Appearance": {
        "require": true
      },
      "qx.theme.icon.Tango": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
    OSparc Dark Theme for Qooxdoo
  
    Copyright:
       2018 IT'IS Foundation
  
    License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
    Authors:
      * Tobias Oetiker (oetiker)
  
    Origin:
      This theme is based in large parts on the osparc.theme
  ************************************************************************ */

  /**
   * Tangible Theme (Light)
   *
   * The tangible theme is inspired by ideas from material design. A lot of work went into designing a higly automated color
   * system. In order to customize the theme to your taste, simply create your own color system. Use qx.theme.tangible.ColorLight for inspiration.
   *
   * The Tangible Theme is very new and still in a state of flux. PRs highly welcome. Use https://material.io as a visual guide.
   * 
   */
  qx.Theme.define("qx.theme.TangibleLight", {
    title: "Tangible Light Theme",
    meta: {
      color: qx.theme.tangible.ColorLight,
      decoration: qx.theme.tangible.Decoration,
      font: qx.theme.tangible.Font,
      appearance: qx.theme.tangible.Appearance,
      icon: qx.theme.icon.Tango
    }
  });
  qx.theme.TangibleLight.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 OETIKER+PARTNER AG
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tobias Oetiker (oetiker)
  
  ************************************************************************ */

  /**
   * A dummy class to trigger the compiler to copy the MaterialIcons font files
   */

  /**
   * @asset(qx/iconfont/MaterialIcons/materialicons-v50.ttf)
   * @asset(qx/iconfont/MaterialIcons/materialicons-v50.woff2)
   * @asset(qx/iconfont/MaterialIcons/materialicons-v50.woff)
   * @asset(qx/iconfont/MaterialIcons/materialicons-v50.eot)
   */
  qx.Class.define("qx.theme.iconfont.LoadMaterialIcons", {});
  qx.theme.iconfont.LoadMaterialIcons.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 OETIKER+PARTNER AG
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tobias Oetiker (oetiker)
  
  ************************************************************************ */

  /**
   * A dummy class to trigger the compiler to copy the MaterialIconsOutlined font files
   */

  /**
   * @asset(qx/iconfont/MaterialIcons/materialiconsoutlined-v18.otf)
   * @asset(qx/iconfont/MaterialIcons/materialiconsoutlined-v18.woff2)
   * @asset(qx/iconfont/MaterialIcons/materialiconsoutlined-v18.woff)
   * @asset(qx/iconfont/MaterialIcons/materialiconsoutlined-v18.eot)
   */
  qx.Class.define("qx.theme.iconfont.LoadMaterialIconsOutlined", {});
  qx.theme.iconfont.LoadMaterialIconsOutlined.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 OETIKER+PARTNER AG
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tobias Oetiker (oetiker)
  
  ************************************************************************ */

  /**
   * A dummy class to trigger the compiler to copy the MaterialIconsRound font files
   */

  /**
   * @asset(qx/iconfont/MaterialIcons/materialiconsround-v18.otf)
   * @asset(qx/iconfont/MaterialIcons/materialiconsround-v18.woff2)
   * @asset(qx/iconfont/MaterialIcons/materialiconsround-v18.woff)
   * @asset(qx/iconfont/MaterialIcons/materialiconsround-v18.eot)
   */
  qx.Class.define("qx.theme.iconfont.LoadMaterialIconsRound", {});
  qx.theme.iconfont.LoadMaterialIconsRound.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 OETIKER+PARTNER AG
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tobias Oetiker (oetiker)
  
  ************************************************************************ */

  /**
   * A dummy class to trigger the compiler to copy the MaterialIconsSharpe font files
   */

  /**
   * @asset(qx/iconfont/MaterialIcons/materialiconssharp-v19.otf)
   * @asset(qx/iconfont/MaterialIcons/materialiconssharp-v19.woff2)
   * @asset(qx/iconfont/MaterialIcons/materialiconssharp-v19.woff)
   * @asset(qx/iconfont/MaterialIcons/materialiconssharp-v19.eot)
   */
  qx.Class.define("qx.theme.iconfont.LoadMaterialIconsSharp", {});
  qx.theme.iconfont.LoadMaterialIconsSharp.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 OETIKER+PARTNER AG
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tobias Oetiker (oetiker)
  
  ************************************************************************ */

  /**
   * A dummy class to trigger the compiler to copy the MaterialIconsTwoTone font files
   */

  /**
   * @asset(qx/iconfont/MaterialIcons/materialiconstwotone-v17.otf)
   * @asset(qx/iconfont/MaterialIcons/materialiconstwotone-v17.woff2)
   * @asset(qx/iconfont/MaterialIcons/materialiconstwotone-v17.woff)
   * @asset(qx/iconfont/MaterialIcons/materialiconstwotone-v17.eot)
   */
  qx.Class.define("qx.theme.iconfont.LoadMaterialIconsTwoTone", {});
  qx.theme.iconfont.LoadMaterialIconsTwoTone.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.type.BaseArray": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * An extended array class which adds a lot of often used
   * convenience methods to the regular array like <code>remove</code> or
   * <code>contains</code>.
   */
  qx.Class.define("qx.type.Array", {
    extend: qx.type.BaseArray,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Creates a new Array with the given length or the listed items.
     *
     * <pre class="javascript">
     * var arr1 = new qx.type.Array(length);
     * var arr2 = new qx.type.Array(elem0, elem1, ..., elemN);
     * </pre>
     *
     * * <code>length</code>: The initial length of the array.
     * * <code>item1, item2. .. itemN</code>:  the items that will make up the newly created array
     *
     * @param length_or_items {Integer|var?null} The initial size of the collection
     *        OR an argument list of elements.
     */
    construct: function construct(length_or_items) {
      qx.type.BaseArray.apply(this, arguments);
    },
    members: {
      /**
       * Returns a clone of the array. Primitive values are copied.
       * Others are referenced.
       *
       * @return {Array} Cloned array instance
       * @signature function()
       */
      clone: qx.type.BaseArray.prototype.concat,

      /**
       * Insert an element at a given position
       *
       * @param obj {var} the element to insert
       * @param i {Integer} position where to insert the element into the arr
       * @return {Array} the array
       */
      insertAt: function insertAt(obj, i) {
        this.splice(i, 0, obj);
        return this;
      },

      /**
       * Insert an element before a given second element
       *
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 before this object
       * @return {Array} the array
       */
      insertBefore: function insertBefore(obj, obj2) {
        var i = this.indexOf(obj2);

        if (i == -1) {
          this.push(obj);
        } else {
          this.splice(i, 0, obj);
        }

        return this;
      },

      /**
       * Insert an element after a given second element
       *
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 after this object
       * @return {Array} the array
       */
      insertAfter: function insertAfter(obj, obj2) {
        var i = this.indexOf(obj2);

        if (i == -1 || i == this.length - 1) {
          this.push(obj);
        } else {
          this.splice(i + 1, 0, obj);
        }

        return this;
      },

      /**
       * Remove an element at the given index
       *
       * @param i {Integer} index of the element to be removed
       * @return {var} The removed element.
       */
      removeAt: function removeAt(i) {
        return this.splice(i, 1)[0];
      },

      /**
       * Remove all elements
       *
       * @return {Array} empty array
       */
      removeAll: function removeAll() {
        this.length = 0;
        return this;
      },

      /**
       * Append the elements of the given array
       *
       * @param arr {Array} the elements of this array will be appended to other one
       * @return {Array} The modified array.
       * @throws {Error} if one of the arguments is not an array
       */
      append: function append(arr) {
        var arg = this.__toPlainArray__P_362_0(arr);

        Array.prototype.push.apply(this, arg);
        return this;
      },

      /**
       * Prepend the elements of the given array.
       *
       * @param arr {Array} The elements of this array will be prepended to other one
       * @return {Array} The modified array.
       * @throws {Error} if one of the arguments is not an array
       */
      prepend: function prepend(arr) {
        var arg = this.__toPlainArray__P_362_0(arr);

        Array.prototype.splice.apply(this, [0, 0].concat(arg));
        return this;
      },

      /**
       * Helper which checks for the given element and converts that to a
       * native array if necessary.
       *
       * @param arr {Array} Native or qx.type.BaseArray to convert.
       * @return {Array} A native array.
       */
      __toPlainArray__P_362_0: function __toPlainArray__P_362_0(arr) {
        // this check is important because Opera throws an uncatchable error if
        // apply is called without an arr as second argument.
        {
          qx.core.Assert.assertArray(arr, "The parameter must be an array.");
        }
        var arg = arr; // concat needs a plain array as argument [BUG #4488]

        if (arr instanceof qx.type.BaseArray) {
          arg = [];

          for (var i = 0; i < arr.length; i++) {
            arg[i] = arr[i];
          }

          ;
        }

        return arg;
      },

      /**
       * Remove an element
       *
       * @param obj {var} element to be removed from the array
       * @return {var} the removed element
       */
      remove: function remove(obj) {
        var i = this.indexOf(obj);

        if (i != -1) {
          this.splice(i, 1);
          return obj;
        }
      },

      /**
       * Whether the array contains the given element
       *
       * @param obj {var} object to look for
       * @return {Boolean} whether the array contains the element
       */
      contains: function contains(obj) {
        return this.indexOf(obj) !== -1;
      }
    }
  });
  qx.type.Array.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.bom.Shortcut": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Mustafa Sak (msak)
  
  ************************************************************************ */

  /**
   * Commands can be used to globally define keyboard shortcuts. They could
   * also be used to assign an execution of a command sequence to multiple
   * widgets. It is possible to use the same Command in a MenuButton and
   * ToolBarButton for example.
   * 
   * NOTE: Instances of this class must be disposed of after use
   *
   */
  qx.Class.define("qx.ui.command.Command", {
    extend: qx.core.Object,

    /**
     * @param shortcut {String} Shortcuts can be composed of optional modifier
     *    keys Control, Alt, Shift, Meta and a non modifier key.
     *    If no non modifier key is specified, the second parameter is evaluated.
     *    The key must be separated by a <code>+</code> or <code>-</code> character.
     *    Examples: Alt+F1, Control+C, Control+Alt+Delete
     */
    construct: function construct(shortcut) {
      qx.core.Object.constructor.call(this);
      this._shortcut = new qx.bom.Shortcut(shortcut);

      this._shortcut.addListener("execute", this.execute, this);

      if (shortcut !== undefined) {
        this.setShortcut(shortcut);
      }
    },
    events: {
      /**
       * Fired when the command is executed. Sets the "data" property of the
       * event to the object that issued the command.
       */
      "execute": "qx.event.type.Data"
    },
    properties: {
      /** Whether the command should be activated. If 'false' execute event
       * wouldn't fire. This property will be used by command groups when
       * activating/deactivating all commands of the group.*/
      active: {
        init: true,
        check: "Boolean",
        event: "changeActive",
        apply: "_applyActive"
      },

      /** Whether the command should be respected/enabled. If 'false' execute event
       * wouldn't fire. If value of property {@link qx.ui.command.Command#active}
       * is 'false', enabled value can be set but has no effect until
       * {@link qx.ui.command.Command#active} will be set to 'true'.*/
      enabled: {
        init: true,
        check: "Boolean",
        event: "changeEnabled",
        apply: "_applyEnabled"
      },

      /** The command shortcut as a string */
      shortcut: {
        check: "String",
        apply: "_applyShortcut",
        nullable: true
      },

      /** The label, which will be set in all connected widgets (if available) */
      label: {
        check: "String",
        nullable: true,
        event: "changeLabel"
      },

      /** The icon, which will be set in all connected widgets (if available) */
      icon: {
        check: "String",
        nullable: true,
        event: "changeIcon"
      },

      /**
       * The tooltip text, which will be set in all connected
       * widgets (if available)
       */
      toolTipText: {
        check: "String",
        nullable: true,
        event: "changeToolTipText"
      },

      /** The value of the connected widgets */
      value: {
        nullable: true,
        event: "changeValue"
      },

      /** The menu, which will be set in all connected widgets (if available) */
      menu: {
        check: "qx.ui.menu.Menu",
        nullable: true,
        event: "changeMenu"
      }
    },
    members: {
      _shortcut: null,
      // property apply
      _applyActive: function _applyActive(value) {
        if (value === false) {
          this._shortcut.setEnabled(false);
        } else {
          // synchronize value with current "enabled" value of this command
          this._shortcut.setEnabled(this.getEnabled());
        }
      },
      // property apply
      _applyEnabled: function _applyEnabled(value) {
        if (this.getActive()) {
          this._shortcut.setEnabled(value);
        }
      },
      // property apply
      _applyShortcut: function _applyShortcut(value) {
        this._shortcut.setShortcut(value);
      },

      /**
       * Fire the "execute" event on this command. If property
       * <code>active</code> and <code>enabled</code> set to
       * <code>true</code>.
       * @param target {Object?} Object which issued the execute event
       */
      execute: function execute(target) {
        if (this.getActive() && this.getEnabled()) {
          this.fireDataEvent("execute", target);
        }
      },

      /**
       * Returns the used shortcut as string using the currently selected locale.
       *
       * @return {String} shortcut
       */
      toString: function toString() {
        if (this._shortcut) {
          return this._shortcut.toString();
        }

        return qx.ui.command.Command.prototype.toString.base.call(this);
      }
    },
    destruct: function destruct() {
      this._shortcut.removeListener("execute", this.execute, this);

      this._disposeObjects("_shortcut");
    }
  });
  qx.ui.command.Command.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.command.Command": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     Authors:
       * Mustafa Sak (msak)
  
  ************************************************************************ */

  /**
   * Registrar for commands to be able to group them.
   */
  qx.Class.define("qx.ui.command.Group", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this._cmds = {};
    },
    properties: {
      /**
       * Activates or deactivates all commands in group.
       */
      active: {
        init: true,
        check: "Boolean",
        apply: "_applyActive"
      }
    },
    members: {
      _cmds: null,
      // property apply
      _applyActive: function _applyActive(value) {
        for (var cmdkey in this._cmds) {
          this._cmds[cmdkey].setActive(value);
        }
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Adds a command with a key to the group.
       *
       * @param key {String} Key to be able to addresses the command
       * @param command {qx.ui.command.Command} Command
       *
       * @return {Boolean} <code>false</code> if key already added before
       */
      add: function add(key, command) {
        {
          this.assertArgumentsCount(arguments, 2, 2, "Given parameter count mismatch! Please provide a key as string and a command intsance.");
          this.assertString(key, "Key parameter must be a string.");
          this.assertInstance(command, qx.ui.command.Command, "Given command is not an instance of qx.ui.command.Command");
        }

        if (this.has(key)) {
          {
            this.debug("Command with key: '" + key + "' already exists!");
          }
          return false;
        }

        this._cmds[key] = command;
        return true;
      },

      /**
       * Returns a command by key.
       *
       * @param key {String} Key which addresses the command
       *
       * @return {qx.ui.command.Command | null} Corresponding command instance or null
       */
      get: function get(key) {
        {
          this.assertString(key, "Key parameter must be a string.");
        }
        var cmd = this._cmds[key];

        if (!cmd) {
          {
            this.debug("The key: '" + key + "' was not added before. Please use " + "'add()' method to add the command.");
          }
          return null;
        }

        return cmd;
      },

      /**
       * Returns true if a command is registered by key.
       *
       * @param key {String} Key which addresses the command
       *
       * @return {Boolean} Returns <code>true</code> if a command is registered by a key
       */
      has: function has(key) {
        {
          this.assertString(key, "Key parameter must be a string.");
        }
        return !!this._cmds[key];
      },

      /**
       * Removes a command by key from group. Returns the command.
       *
       * @param key {String} Key which addresses the command
       *
       * @return {qx.ui.command.Command | null} Corresponding command instance or null
       */
      remove: function remove(key) {
        {
          this.assertString(key, "Key parameter must be a string.");
        }
        var cmd = this._cmds[key];

        if (!cmd) {
          {
            this.debug("The key: '" + key + "' was not added before. Please use " + "'add()' method to add the command.");
          }
          return null;
        }

        delete this._cmds[key];
        return cmd;
      }
    },
    destruct: function destruct() {
      this._cmds = null;
    }
  });
  qx.ui.command.Group.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.command.Group": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     Copyright:
       2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     Authors:
       * Mustafa Sak (msak)
  
  
  ************************************************************************ */

  /**
   * Registrar for command groups to be able to active or deactive them.
   */
  qx.Class.define("qx.ui.command.GroupManager", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__groups__P_367_0 = [];
    },
    members: {
      __groups__P_367_0: null,
      __activeGroup__P_367_1: null,

      /**
       * Add command group.
       *
       * @param group {qx.ui.command.Group} Command group
       *
       * @return {Boolean} <code>false</code> if group was already added before
       */
      add: function add(group) {
        {
          this.assertInstance(group, qx.ui.command.Group, "Given group is not an instance of qx.ui.command.Group");
        }

        if (this.__groups__P_367_0.includes(group)) {
          {
            this.debug("Group is already added!");
          }
          return false;
        }

        this.__groups__P_367_0.push(group); // deactivate added group to prevent collusions


        group.setActive(false);
        return true;
      },

      /**
       * Whether a command manager was added.
       *
       * @param group {qx.ui.command.Group} Command group
       *
       * @return {Boolean} <code>true</code> if group already added
       */
      has: function has(group) {
        {
          this.assertInstance(group, qx.ui.command.Group, "Given group is not an instance of qx.ui.command.Group");
        }
        return !!this._getGroup(group);
      },

      /**
       * Removes a command group from group manager. If removed group was the
       * active group, active group will be set to <code>null</code> Returns the
       * group.
       *
       * @param group {qx.ui.command.Group} Command group
       *
       * @return {qx.ui.command.Group | null} Command group or null if group was not added before
       */
      remove: function remove(group) {
        {
          this.assertInstance(group, qx.ui.command.Group, "Group must be an instance of qx.ui.command.Group");
        }

        var index = this.__groups__P_367_0.indexOf(group);

        if (index === -1) {
          {
            this.debug("Group was not added before. Please use 'add()' method to add the group.");
          }
        } // reset active group


        if (this.getActive() === group) {
          this.__activeGroup__P_367_1 = null;
        } // remove group from internal array


        this.__groups__P_367_0.splice(index, 1);

        return group;
      },

      /**
       * Activates a command group and deactivates all other added groups.
       *
       * @param group {qx.ui.command.Group} Command group
       *
       * @return {Boolean} <code>false</code> if group was not added before
       */
      setActive: function setActive(group) {
        {
          this.assertInstance(group, qx.ui.command.Group, "Given group is not an instance of qx.ui.command.Group");
        }

        if (!this.has(group)) {
          {
            this.debug("Group was not added before! You have to use 'addCommand()' method before activating!");
          }
          return false;
        } // iterate through all groups and deactivate all expect the given one


        for (var i = 0; i < this.__groups__P_367_0.length; i++) {
          var item = this.__groups__P_367_0[i];

          if (item == group) {
            item.setActive(true);
            this.__activeGroup__P_367_1 = item;
            continue;
          }

          item.setActive(false);
        }

        return true;
      },

      /**
       * Returns active command group.
       *
       * @return {qx.ui.command.Group | null} Active command group
       */
      getActive: function getActive() {
        return this.__activeGroup__P_367_1;
      },

      /**
       * Blocks the active command group.
       */
      block: function block() {
        if (this.__activeGroup__P_367_1) {
          this.__activeGroup__P_367_1.setActive(false);
        }
      },

      /**
       * Unblocks the active command group.
       */
      unblock: function unblock() {
        if (this.__activeGroup__P_367_1) {
          this.__activeGroup__P_367_1.setActive(true);
        }
      },

      /**
       * Helper function returns added command group.
       *
       * @param group {qx.ui.command.Group} Command group
       *
       * @return {qx.ui.command.Group | null} Command group or null
       */
      _getGroup: function _getGroup(group) {
        var index = this.__groups__P_367_0.indexOf(group);

        if (index === -1) {
          return null;
        }

        return this.__groups__P_367_0[index];
      }
    },
    destruct: function destruct() {
      this.__groups__P_367_0 = this.__activeGroup__P_367_1 = null;
    }
  });
  qx.ui.command.GroupManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.Registration": {
        "construct": true
      },
      "qx.event.handler.DragDrop": {
        "construct": true
      },
      "qx.ui.core.Widget": {},
      "qx.core.Init": {},
      "qx.lang.Object": {},
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 David Pérez Carmona
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * David Perez Carmona (david-perez)
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Provides resizing behavior to any widget.
   */
  qx.Mixin.define("qx.ui.core.MResizable", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      // Register listeners to the content
      var content = this.getContentElement();
      content.addListener("pointerdown", this.__onResizePointerDown__P_385_0, this, true);
      content.addListener("pointerup", this.__onResizePointerUp__P_385_1, this);
      content.addListener("pointermove", this.__onResizePointerMove__P_385_2, this);
      content.addListener("pointerout", this.__onResizePointerOut__P_385_3, this);
      content.addListener("losecapture", this.__onResizeLoseCapture__P_385_4, this); // Get a reference of the drag and drop handler

      var domElement = content.getDomElement();

      if (domElement == null) {
        domElement = window;
      }

      this.__dragDropHandler__P_385_5 = qx.event.Registration.getManager(domElement).getHandler(qx.event.handler.DragDrop);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Whether the top edge is resizable */
      resizableTop: {
        check: "Boolean",
        init: true
      },

      /** Whether the right edge is resizable */
      resizableRight: {
        check: "Boolean",
        init: true
      },

      /** Whether the bottom edge is resizable */
      resizableBottom: {
        check: "Boolean",
        init: true
      },

      /** Whether the left edge is resizable */
      resizableLeft: {
        check: "Boolean",
        init: true
      },

      /**
       * Property group to configure the resize behaviour for all edges at once
       */
      resizable: {
        group: ["resizableTop", "resizableRight", "resizableBottom", "resizableLeft"],
        mode: "shorthand"
      },

      /** The tolerance to activate resizing */
      resizeSensitivity: {
        check: "Integer",
        init: 5
      },

      /** Whether a frame replacement should be used during the resize sequence */
      useResizeFrame: {
        check: "Boolean",
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __dragDropHandler__P_385_5: null,
      __resizeFrame__P_385_6: null,
      __resizeActive__P_385_7: null,
      __resizeLeft__P_385_8: null,
      __resizeTop__P_385_9: null,
      __resizeStart__P_385_10: null,
      __resizeRange__P_385_11: null,
      RESIZE_TOP: 1,
      RESIZE_BOTTOM: 2,
      RESIZE_LEFT: 4,
      RESIZE_RIGHT: 8,

      /*
      ---------------------------------------------------------------------------
        CORE FEATURES
      ---------------------------------------------------------------------------
      */

      /**
       * Get the widget, which draws the resize/move frame. The resize frame is
       * shared by all widgets and is added to the root widget.
       *
       * @return {qx.ui.core.Widget} The resize frame
       */
      _getResizeFrame: function _getResizeFrame() {
        var frame = this.__resizeFrame__P_385_6;

        if (!frame) {
          frame = this.__resizeFrame__P_385_6 = new qx.ui.core.Widget();
          frame.setAppearance("resize-frame");
          frame.exclude();
          qx.core.Init.getApplication().getRoot().add(frame);
        }

        return frame;
      },

      /**
       * Creates, shows and syncs the frame with the widget.
       */
      __showResizeFrame__P_385_12: function __showResizeFrame__P_385_12() {
        var location = this.getContentLocation();

        var frame = this._getResizeFrame();

        frame.setUserBounds(location.left, location.top, location.right - location.left, location.bottom - location.top);
        frame.show();
        frame.setZIndex(this.getZIndex() + 1);
      },

      /*
      ---------------------------------------------------------------------------
        RESIZE SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Computes the new boundaries at each interval
       * of the resize sequence.
       *
       * @param e {qx.event.type.Pointer} Last pointer event
       * @return {Map} A map with the computed boundaries
       */
      __computeResizeResult__P_385_13: function __computeResizeResult__P_385_13(e) {
        // Detect mode
        var resizeActive = this.__resizeActive__P_385_7; // Read size hint

        var hint = this.getSizeHint();
        var range = this.__resizeRange__P_385_11; // Read original values

        var start = this.__resizeStart__P_385_10;
        var width = start.width;
        var height = start.height;
        var left = start.left;
        var top = start.top;
        var diff;

        if (resizeActive & this.RESIZE_TOP || resizeActive & this.RESIZE_BOTTOM) {
          diff = Math.max(range.top, Math.min(range.bottom, e.getDocumentTop())) - this.__resizeTop__P_385_9;

          if (resizeActive & this.RESIZE_TOP) {
            height -= diff;
          } else {
            height += diff;
          }

          if (height < hint.minHeight) {
            height = hint.minHeight;
          } else if (height > hint.maxHeight) {
            height = hint.maxHeight;
          }

          if (resizeActive & this.RESIZE_TOP) {
            top += start.height - height;
          }
        }

        if (resizeActive & this.RESIZE_LEFT || resizeActive & this.RESIZE_RIGHT) {
          diff = Math.max(range.left, Math.min(range.right, e.getDocumentLeft())) - this.__resizeLeft__P_385_8;

          if (resizeActive & this.RESIZE_LEFT) {
            width -= diff;
          } else {
            width += diff;
          }

          if (width < hint.minWidth) {
            width = hint.minWidth;
          } else if (width > hint.maxWidth) {
            width = hint.maxWidth;
          }

          if (resizeActive & this.RESIZE_LEFT) {
            left += start.width - width;
          }
        }

        return {
          // left and top of the visible widget
          viewportLeft: left,
          viewportTop: top,
          parentLeft: start.bounds.left + left - start.left,
          parentTop: start.bounds.top + top - start.top,
          // dimensions of the visible widget
          width: width,
          height: height
        };
      },

      /**
       * @type {Map} Maps internal states to cursor symbols to use
       *
       * @lint ignoreReferenceField(__resizeCursors)
       */
      __resizeCursors__P_385_14: {
        1: "n-resize",
        2: "s-resize",
        4: "w-resize",
        8: "e-resize",
        5: "nw-resize",
        6: "sw-resize",
        9: "ne-resize",
        10: "se-resize"
      },

      /**
       * Updates the internally stored resize mode
       *
       * @param e {qx.event.type.Pointer} Last pointer event
       */
      __computeResizeMode__P_385_15: function __computeResizeMode__P_385_15(e) {
        var location = this.getContentLocation();
        var pointerTolerance = this.getResizeSensitivity();
        var pointerLeft = e.getDocumentLeft();
        var pointerTop = e.getDocumentTop();

        var resizeActive = this.__computeResizeActive__P_385_16(location, pointerLeft, pointerTop, pointerTolerance); // check again in case we have a corner [BUG #1200]


        if (resizeActive > 0) {
          // this is really a | (or)!
          resizeActive = resizeActive | this.__computeResizeActive__P_385_16(location, pointerLeft, pointerTop, pointerTolerance * 2);
        }

        this.__resizeActive__P_385_7 = resizeActive;
      },

      /**
       * Internal helper for computing the proper resize action based on the
       * given parameters.
       *
       * @param location {Map} The current location of the widget.
       * @param pointerLeft {Integer} The left position of the pointer.
       * @param pointerTop {Integer} The top position of the pointer.
       * @param pointerTolerance {Integer} The desired distance to the edge.
       * @return {Integer} The resize active number.
       */
      __computeResizeActive__P_385_16: function __computeResizeActive__P_385_16(location, pointerLeft, pointerTop, pointerTolerance) {
        var resizeActive = 0; // TOP

        if (this.getResizableTop() && Math.abs(location.top - pointerTop) < pointerTolerance && pointerLeft > location.left - pointerTolerance && pointerLeft < location.right + pointerTolerance) {
          resizeActive += this.RESIZE_TOP; // BOTTOM
        } else if (this.getResizableBottom() && Math.abs(location.bottom - pointerTop) < pointerTolerance && pointerLeft > location.left - pointerTolerance && pointerLeft < location.right + pointerTolerance) {
          resizeActive += this.RESIZE_BOTTOM;
        } // LEFT


        if (this.getResizableLeft() && Math.abs(location.left - pointerLeft) < pointerTolerance && pointerTop > location.top - pointerTolerance && pointerTop < location.bottom + pointerTolerance) {
          resizeActive += this.RESIZE_LEFT; // RIGHT
        } else if (this.getResizableRight() && Math.abs(location.right - pointerLeft) < pointerTolerance && pointerTop > location.top - pointerTolerance && pointerTop < location.bottom + pointerTolerance) {
          resizeActive += this.RESIZE_RIGHT;
        }

        return resizeActive;
      },

      /*
      ---------------------------------------------------------------------------
        RESIZE EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the pointer down event
       *
       * @param e {qx.event.type.Pointer} The pointer event instance
       */
      __onResizePointerDown__P_385_0: function __onResizePointerDown__P_385_0(e) {
        // Check for active resize
        if (!this.__resizeActive__P_385_7 || !this.getEnabled() || e.getPointerType() == "touch") {
          return;
        } // Add resize state


        this.addState("resize"); // Store pointer coordinates

        this.__resizeLeft__P_385_8 = e.getDocumentLeft();
        this.__resizeTop__P_385_9 = e.getDocumentTop(); // Cache bounds

        var location = this.getContentLocation();
        var bounds = this.getBounds();
        this.__resizeStart__P_385_10 = {
          top: location.top,
          left: location.left,
          width: location.right - location.left,
          height: location.bottom - location.top,
          bounds: qx.lang.Object.clone(bounds)
        }; // Compute range

        var parent = this.getLayoutParent();
        var parentLocation = parent.getContentLocation();
        var parentBounds = parent.getBounds();
        this.__resizeRange__P_385_11 = {
          left: parentLocation.left,
          top: parentLocation.top,
          right: parentLocation.left + parentBounds.width,
          bottom: parentLocation.top + parentBounds.height
        }; // Show frame if configured this way

        if (this.getUseResizeFrame()) {
          this.__showResizeFrame__P_385_12();
        } // Enable capturing


        this.capture(); // Stop event

        e.stop();
      },

      /**
       * Event handler for the pointer up event
       *
       * @param e {qx.event.type.Pointer} The pointer event instance
       */
      __onResizePointerUp__P_385_1: function __onResizePointerUp__P_385_1(e) {
        // Check for active resize
        if (!this.hasState("resize") || !this.getEnabled() || e.getPointerType() == "touch") {
          return;
        } // Hide frame afterwards


        if (this.getUseResizeFrame()) {
          this._getResizeFrame().exclude();
        } // Compute bounds


        var bounds = this.__computeResizeResult__P_385_13(e); // Sync with widget


        this.setWidth(bounds.width);
        this.setHeight(bounds.height); // Update coordinate in canvas

        if (this.getResizableLeft() || this.getResizableTop()) {
          this.setLayoutProperties({
            left: bounds.parentLeft,
            top: bounds.parentTop
          });
        } // Clear mode


        this.__resizeActive__P_385_7 = 0; // Remove resize state

        this.removeState("resize"); // Reset cursor

        this.resetCursor();
        this.getApplicationRoot().resetGlobalCursor(); // Disable capturing

        this.releaseCapture();
        e.stopPropagation();
      },

      /**
       * Event listener for <code>losecapture</code> event.
       *
       * @param e {qx.event.type.Event} Lose capture event
       */
      __onResizeLoseCapture__P_385_4: function __onResizeLoseCapture__P_385_4(e) {
        // Check for active resize
        if (!this.__resizeActive__P_385_7) {
          return;
        } // Reset cursor


        this.resetCursor();
        this.getApplicationRoot().resetGlobalCursor(); // Remove drag state

        this.removeState("move"); // Hide frame afterwards

        if (this.getUseResizeFrame()) {
          this._getResizeFrame().exclude();
        }
      },

      /**
       * Event handler for the pointer move event
       *
       * @param e {qx.event.type.Pointer} The pointer event instance
       */
      __onResizePointerMove__P_385_2: function __onResizePointerMove__P_385_2(e) {
        if (!this.getEnabled() || e.getPointerType() == "touch") {
          return;
        }

        if (this.hasState("resize")) {
          var bounds = this.__computeResizeResult__P_385_13(e); // Update widget


          if (this.getUseResizeFrame()) {
            // Sync new bounds to frame
            var frame = this._getResizeFrame();

            frame.setUserBounds(bounds.viewportLeft, bounds.viewportTop, bounds.width, bounds.height);
          } else {
            // Update size
            this.setWidth(bounds.width);
            this.setHeight(bounds.height); // Update coordinate in canvas

            if (this.getResizableLeft() || this.getResizableTop()) {
              this.setLayoutProperties({
                left: bounds.parentLeft,
                top: bounds.parentTop
              });
            }
          } // Full stop for event


          e.stopPropagation();
        } else if (!this.hasState("maximized") && !this.__dragDropHandler__P_385_5.isSessionActive()) {
          this.__computeResizeMode__P_385_15(e);

          var resizeActive = this.__resizeActive__P_385_7;
          var root = this.getApplicationRoot();

          if (resizeActive) {
            var cursor = this.__resizeCursors__P_385_14[resizeActive];
            this.setCursor(cursor);
            root.setGlobalCursor(cursor);
          } else if (this.getCursor()) {
            this.resetCursor();
            root.resetGlobalCursor();
          }
        }
      },

      /**
       * Event handler for the pointer out event
       *
       * @param e {qx.event.type.Pointer} The pointer event instance
       */
      __onResizePointerOut__P_385_3: function __onResizePointerOut__P_385_3(e) {
        if (e.getPointerType() == "touch") {
          return;
        } // When the pointer left the window and resizing is not yet
        // active we must be sure to (especially) reset the global
        // cursor.


        if (this.getCursor() && !this.hasState("resize")) {
          this.resetCursor();
          this.getApplicationRoot().resetGlobalCursor();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this.getCursor()) {
        this.getApplicationRoot().resetGlobalCursor();
      }

      if (this.__resizeFrame__P_385_6 != null && !qx.core.ObjectRegistry.inShutDown) {
        this.__resizeFrame__P_385_6.destroy();

        this.__resizeFrame__P_385_6 = null;
      }

      this.__dragDropHandler__P_385_5 = null;
    }
  });
  qx.ui.core.MResizable.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "require": true
      },
      "qx.ui.core.MResizable": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * David Perez (david-perez)
  
  ************************************************************************ */

  /**
   * The Resizer is a resizable container widget.
   *
   * It allows to be resized (not moved), normally in
   * the right and/or bottom directions. It is an alternative to splitters.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var resizer = new qx.ui.container.Resizer().set({
   *     width: 200,
   *     height: 100
   *   });
   *
   *   resizer.setLayout(new qx.ui.layout.Canvas());
   *   var text = new qx.ui.form.TextArea("Resize me\nI'm resizable");
   *   resizer.add(text, {edge: 0});
   *
   *   this.getRoot().add(resizer);
   * </pre>
   *
   * This example creates a resizer, configures it with a canvas layout and
   * adds a text area to it.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/resizer.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.container.Resizer", {
    extend: qx.ui.container.Composite,
    include: qx.ui.core.MResizable,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "resizer"
      }
    }
  });
  qx.ui.container.Resizer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.scroll.ScrollBar": {}
    },
    "environment": {
      "provided": ["qx.nativeScrollBars"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.core.Environment.add("qx.nativeScrollBars", false);
  /**
   * Include this widget if you want to create scrollbars depending on the global
   * "qx.nativeScrollBars" setting.
   */

  qx.Mixin.define("qx.ui.core.scroll.MScrollBarFactory", {
    members: {
      /**
       * Creates a new scrollbar. This can either be a styled qooxdoo scrollbar
       * or a native browser scrollbar.
       *
       * @param orientation {String?"horizontal"} The initial scroll bar orientation
       * @return {qx.ui.core.scroll.IScrollBar} The scrollbar instance
       */
      _createScrollBar: function _createScrollBar(orientation) {
        {
          return new qx.ui.core.scroll.ScrollBar(orientation);
        }
      }
    }
  });
  qx.ui.core.scroll.MScrollBarFactory.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Mixin holding the handler for roll event. Please
   * keep in mind that the including widget has to have the scroll bars
   * implemented as child controls named <code>scrollbar-x</code> and
   * <code>scrollbar-y</code> to get the handler working. Also, you have to
   * attach the listener yourself.
   */
  qx.Mixin.define("qx.ui.core.scroll.MRoll", {
    members: {
      _cancelRoll: null,

      /**
       * Responsible for adding the event listener needed for scroll handling.
       */
      _addRollHandling: function _addRollHandling() {
        this.addListener("roll", this._onRoll, this);
        this.addListener("pointerdown", this._onPointerDownForRoll, this);
      },

      /**
       * Responsible for removing the event listener needed for scroll handling.
       */
      _removeRollHandling: function _removeRollHandling() {
        this.removeListener("roll", this._onRoll, this);
        this.removeListener("pointerdown", this._onPointerDownForRoll, this);
      },

      /**
       * Handler for the pointerdown event which simply stops the momentum scrolling.
       *
       * @param e {qx.event.type.Pointer} pointerdown event
       */
      _onPointerDownForRoll: function _onPointerDownForRoll(e) {
        this._cancelRoll = e.getPointerId();
      },

      /**
       * Roll event handler
       *
       * @param e {qx.event.type.Roll} Roll event
       */
      _onRoll: function _onRoll(e) {
        // only wheel and touch
        if (e.getPointerType() == "mouse") {
          return;
        }

        if (this._cancelRoll && e.getMomentum()) {
          e.stopMomentum();
          this._cancelRoll = null;
          return;
        }

        this._cancelRoll = null;

        var showX = this._isChildControlVisible("scrollbar-x");

        var showY = this._isChildControlVisible("scrollbar-y");

        var scrollbarY = showY ? this.getChildControl("scrollbar-y", true) : null;
        var scrollbarX = showX ? this.getChildControl("scrollbar-x", true) : null;
        var deltaY = e.getDelta().y;
        var deltaX = e.getDelta().x;
        var endY = !showY;
        var endX = !showX; // y case

        if (scrollbarY) {
          if (deltaY !== 0) {
            scrollbarY.scrollBy(parseInt(deltaY, 10));
          }

          var position = scrollbarY.getPosition();
          var max = scrollbarY.getMaximum(); // pass the event to the parent if the scrollbar is at an edge

          if (deltaY < 0 && position <= 0 || deltaY > 0 && position >= max) {
            endY = true;
          }
        } // x case


        if (scrollbarX) {
          if (deltaX !== 0) {
            scrollbarX.scrollBy(parseInt(deltaX, 10));
          }

          var position = scrollbarX.getPosition();
          var max = scrollbarX.getMaximum(); // pass the event to the parent if the scrollbar is at an edge

          if (deltaX < 0 && position <= 0 || deltaX > 0 && position >= max) {
            endX = true;
          }
        }

        if (endX && endY) {
          e.stopMomentum();
        } // pass the event to the parent if both scrollbars are at the end


        if (!endY && deltaX === 0 || !endX && deltaY === 0 || (!endX || !endY) && deltaX !== 0 && deltaY !== 0) {
          // Stop bubbling and native event only if a scrollbar is visible
          e.stop();
        }
      }
    }
  });
  qx.ui.core.scroll.MRoll.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.DragDropScrolling": {
        "construct": true
      },
      "qx.Class": {},
      "qx.ui.core.scroll.MScrollBarFactory": {},
      "qx.ui.core.Widget": {},
      "qx.event.Timer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Richard Sternagel (rsternagel)
  
  ************************************************************************ */

  /**
   * Provides scrolling ability during drag session to the widget.
   */
  qx.Mixin.define("qx.ui.core.MDragDropScrolling", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      var widget = this;

      if (this instanceof qx.ui.core.DragDropScrolling) {
        widget = this._getWidget();
      }

      widget.addListener("drag", this.__onDrag__P_379_0, this);
      widget.addListener("dragend", this.__onDragend__P_379_1, this);
      this.__xDirs__P_379_2 = ["left", "right"];
      this.__yDirs__P_379_3 = ["top", "bottom"];
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The threshold for the x-axis (in pixel) to activate scrolling at the edges. */
      dragScrollThresholdX: {
        check: "Integer",
        init: 30
      },

      /** The threshold for the y-axis (in pixel) to activate scrolling at the edges. */
      dragScrollThresholdY: {
        check: "Integer",
        init: 30
      },

      /** The factor for slowing down the scrolling. */
      dragScrollSlowDownFactor: {
        check: "Float",
        init: 0.1
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __dragScrollTimer__P_379_4: null,
      __xDirs__P_379_2: null,
      __yDirs__P_379_3: null,

      /**
       * Finds the first scrollable parent (in the parent chain).
       *
       * @param widget {qx.ui.core.LayoutItem} The widget to start from.
       * @return {qx.ui.core.Widget} A scrollable widget.
       */
      _findScrollableParent: function _findScrollableParent(widget) {
        var cur = widget;

        if (cur === null) {
          return null;
        }

        while (cur.getLayoutParent()) {
          cur = cur.getLayoutParent();

          if (this._isScrollable(cur)) {
            return cur;
          }
        }

        return null;
      },

      /**
       * Whether the widget is scrollable.
       *
       * @param widget {qx.ui.core.Widget} The widget to check.
       * @return {Boolean} Whether the widget is scrollable.
       */
      _isScrollable: function _isScrollable(widget) {
        return qx.Class.hasMixin(widget.constructor, qx.ui.core.scroll.MScrollBarFactory);
      },

      /**
       * Gets the bounds of the given scrollable.
       *
       * @param scrollable {qx.ui.core.Widget} Scrollable which has scrollbar child controls.
       * @return {Map} A map with all four bounds (e.g. {"left":0, "top":20, "right":0, "bottom":80}).
       */
      _getBounds: function _getBounds(scrollable) {
        var bounds = scrollable.getContentLocation(); // the scrollable may dictate a nested widget for more precise bounds

        if (scrollable.getScrollAreaContainer) {
          bounds = scrollable.getScrollAreaContainer().getContentLocation();
        }

        return bounds;
      },

      /**
       * Gets the edge type or null if the pointer isn't within one of the thresholds.
       *
       * @param diff {Map} Difference map with all for edgeTypes.
       * @param thresholdX {Number} x-axis threshold.
       * @param thresholdY {Number} y-axis threshold.
       * @return {String} One of the four edgeTypes ('left', 'right', 'top', 'bottom').
       */
      _getEdgeType: function _getEdgeType(diff, thresholdX, thresholdY) {
        if (diff.left * -1 <= thresholdX && diff.left < 0) {
          return "left";
        } else if (diff.top * -1 <= thresholdY && diff.top < 0) {
          return "top";
        } else if (diff.right <= thresholdX && diff.right > 0) {
          return "right";
        } else if (diff.bottom <= thresholdY && diff.bottom > 0) {
          return "bottom";
        } else {
          return null;
        }
      },

      /**
       * Gets the axis ('x' or 'y') by the edge type.
       *
       * @param edgeType {String} One of the four edgeTypes ('left', 'right', 'top', 'bottom').
       * @throws {Error} If edgeType is not one of the distinct four ones.
       * @return {String} Returns 'y' or 'x'.
       */
      _getAxis: function _getAxis(edgeType) {
        if (this.__xDirs__P_379_2.indexOf(edgeType) !== -1) {
          return "x";
        } else if (this.__yDirs__P_379_3.indexOf(edgeType) !== -1) {
          return "y";
        } else {
          throw new Error("Invalid edge type given (" + edgeType + "). Must be: 'left', 'right', 'top' or 'bottom'");
        }
      },

      /**
       * Gets the threshold amount by edge type.
       *
       * @param edgeType {String} One of the four edgeTypes ('left', 'right', 'top', 'bottom').
       * @return {Number} The threshold of the x or y axis.
       */
      _getThresholdByEdgeType: function _getThresholdByEdgeType(edgeType) {
        if (this.__xDirs__P_379_2.indexOf(edgeType) !== -1) {
          return this.getDragScrollThresholdX();
        } else if (this.__yDirs__P_379_3.indexOf(edgeType) !== -1) {
          return this.getDragScrollThresholdY();
        }
      },

      /**
       * Whether the scrollbar is visible.
       *
       * @param scrollable {qx.ui.core.Widget} Scrollable which has scrollbar child controls.
       * @param axis {String} Can be 'y' or 'x'.
       * @return {Boolean} Whether the scrollbar is visible.
       */
      _isScrollbarVisible: function _isScrollbarVisible(scrollable, axis) {
        if (scrollable && scrollable._isChildControlVisible) {
          return scrollable._isChildControlVisible("scrollbar-" + axis);
        } else {
          return false;
        }
      },

      /**
       * Whether the scrollbar is exceeding it's maximum position.
       *
       * @param scrollbar {qx.ui.core.scroll.IScrollBar} Scrollbar to check.
       * @param axis {String} Can be 'y' or 'x'.
       * @param amount {Number} Amount to scroll which may be negative.
       * @return {Boolean} Whether the amount will exceed the scrollbar max position.
       */
      _isScrollbarExceedingMaxPos: function _isScrollbarExceedingMaxPos(scrollbar, axis, amount) {
        var newPos = 0;

        if (!scrollbar) {
          return true;
        }

        newPos = scrollbar.getPosition() + amount;
        return newPos > scrollbar.getMaximum() || newPos < 0;
      },

      /**
       * Calculates the threshold exceedance (which may be negative).
       *
       * @param diff {Number} Difference value of one edgeType.
       * @param threshold {Number} x-axis or y-axis threshold.
       * @return {Number} Threshold exceedance amount (positive or negative).
       */
      _calculateThresholdExceedance: function _calculateThresholdExceedance(diff, threshold) {
        var amount = threshold - Math.abs(diff);
        return diff < 0 ? amount * -1 : amount;
      },

      /**
       * Calculates the scroll amount (which may be negative).
       * The amount is influenced by the scrollbar size (bigger = faster)
       * the exceedanceAmount (bigger = faster) and the slowDownFactor.
       *
       * @param scrollbarSize {Number} Size of the scrollbar.
       * @param exceedanceAmount {Number} Threshold exceedance amount (positive or negative).
       * @return {Number} Scroll amount (positive or negative).
       */
      _calculateScrollAmount: function _calculateScrollAmount(scrollbarSize, exceedanceAmount) {
        return Math.floor(scrollbarSize / 100 * exceedanceAmount * this.getDragScrollSlowDownFactor());
      },

      /**
       * Scrolls the given scrollable on the given axis for the given amount.
       *
       * @param scrollable {qx.ui.core.Widget} Scrollable which has scrollbar child controls.
       * @param axis {String} Can be 'y' or 'x'.
       * @param exceedanceAmount {Number} Threshold exceedance amount (positive or negative).
       */
      _scrollBy: function _scrollBy(scrollable, axis, exceedanceAmount) {
        var scrollbar = scrollable.getChildControl("scrollbar-" + axis, true);

        if (!scrollbar) {
          return;
        }

        var bounds = scrollbar.getBounds(),
            scrollbarSize = axis === "x" ? bounds.width : bounds.height,
            amount = this._calculateScrollAmount(scrollbarSize, exceedanceAmount);

        if (this._isScrollbarExceedingMaxPos(scrollbar, axis, amount)) {
          this.__dragScrollTimer__P_379_4.stop();
        }

        scrollbar.scrollBy(amount);
      },

      /*
      ---------------------------------------------------------------------------
      EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the drag event.
       *
       * @param e {qx.event.type.Drag} The drag event instance.
       */
      __onDrag__P_379_0: function __onDrag__P_379_0(e) {
        if (this.__dragScrollTimer__P_379_4) {
          // stop last scroll action
          this.__dragScrollTimer__P_379_4.stop();
        }

        var target;

        if (e.getOriginalTarget() instanceof qx.ui.core.Widget) {
          target = e.getOriginalTarget();
        } else {
          target = qx.ui.core.Widget.getWidgetByElement(e.getOriginalTarget());
        }

        if (!target) {
          return;
        }

        var scrollable;

        if (this._isScrollable(target)) {
          scrollable = target;
        } else {
          scrollable = this._findScrollableParent(target);
        }

        while (scrollable) {
          var bounds = this._getBounds(scrollable),
              xPos = e.getDocumentLeft(),
              yPos = e.getDocumentTop(),
              diff = {
            "left": bounds.left - xPos,
            "right": bounds.right - xPos,
            "top": bounds.top - yPos,
            "bottom": bounds.bottom - yPos
          },
              edgeType = null,
              axis = "",
              exceedanceAmount = 0;

          edgeType = this._getEdgeType(diff, this.getDragScrollThresholdX(), this.getDragScrollThresholdY());

          if (!edgeType) {
            scrollable = this._findScrollableParent(scrollable);
            continue;
          }

          axis = this._getAxis(edgeType);

          if (this._isScrollbarVisible(scrollable, axis)) {
            exceedanceAmount = this._calculateThresholdExceedance(diff[edgeType], this._getThresholdByEdgeType(edgeType));

            if (this.__dragScrollTimer__P_379_4) {
              this.__dragScrollTimer__P_379_4.dispose();
            }

            this.__dragScrollTimer__P_379_4 = new qx.event.Timer(50);

            this.__dragScrollTimer__P_379_4.addListener("interval", function (scrollable, axis, amount) {
              this._scrollBy(scrollable, axis, amount);
            }.bind(this, scrollable, axis, exceedanceAmount));

            this.__dragScrollTimer__P_379_4.start();

            e.stopPropagation();
            return;
          } else {
            scrollable = this._findScrollableParent(scrollable);
          }
        }
      },

      /**
       * Event handler for the dragend event.
       *
       * @param e {qx.event.type.Drag} The drag event instance.
       */
      __onDragend__P_379_1: function __onDragend__P_379_1(e) {
        if (this.__dragScrollTimer__P_379_4) {
          this.__dragScrollTimer__P_379_4.stop();
        }
      }
    },
    destruct: function destruct() {
      if (this.__dragScrollTimer__P_379_4) {
        this.__dragScrollTimer__P_379_4.dispose();
      }
    }
  });
  qx.ui.core.MDragDropScrolling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MDragDropScrolling": {
        "require": true
      },
      "qx.core.Init": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Mustafa Sak (msak)
  
  ************************************************************************ */

  /**
   * Provides scrolling ability during drag session to the widget.
   */
  qx.Class.define("qx.ui.core.DragDropScrolling", {
    extend: qx.core.Object,
    include: [qx.ui.core.MDragDropScrolling],
    construct: function construct(widget) {
      qx.core.Object.constructor.call(this);
      this._widget = widget;
    },
    members: {
      _widget: null,

      /**
       * Returns the root widget whose children will have scroll on drag session
       * behavior. Widget was set on constructor or will be application root by
       * default.
       *
       * @return {qx.ui.core.Widget} The root widget whose children will have
       * scroll on drag session
       */
      _getWidget: function _getWidget() {
        return this._widget || qx.core.Init.getApplication().getRoot();
      }
    }
  });
  qx.ui.core.DragDropScrolling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.scroll.MScrollBarFactory": {
        "require": true
      },
      "qx.ui.core.scroll.MRoll": {
        "require": true
      },
      "qx.ui.core.MDragDropScrolling": {
        "require": true
      },
      "qx.bom.client.Scroll": {
        "construct": true
      },
      "qx.ui.layout.Canvas": {
        "construct": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.core.scroll.ScrollPane": {},
      "qx.ui.core.queue.Manager": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "os.scrollBarOverlayed": {
          "construct": true,
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The ScrollArea provides a container widget with on demand scroll bars
   * if the content size exceeds the size of the container.
   *
   * @childControl pane {qx.ui.core.scroll.ScrollPane} pane which holds the content to scroll
   * @childControl scrollbar-x {qx.ui.core.scroll.ScrollBar?qx.ui.core.scroll.NativeScrollBar} horizontal scrollbar
   * @childControl scrollbar-y {qx.ui.core.scroll.ScrollBar?qx.ui.core.scroll.NativeScrollBar} vertical scrollbar
   * @childControl corner {qx.ui.core.Widget} corner where no scrollbar is shown
   */
  qx.Class.define("qx.ui.core.scroll.AbstractScrollArea", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.scroll.MScrollBarFactory, qx.ui.core.scroll.MRoll, qx.ui.core.MDragDropScrolling],
    type: "abstract",

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * The default width which is used for the width of the scroll bar if
       * overlaid.
       */
      DEFAULT_SCROLLBAR_WIDTH: 14
    },

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this);

      if (qx.core.Environment.get("os.scrollBarOverlayed")) {
        // use a plain canvas to overlay the scroll bars
        this._setLayout(new qx.ui.layout.Canvas());
      } else {
        // Create 'fixed' grid layout
        var grid = new qx.ui.layout.Grid();
        grid.setColumnFlex(0, 1);
        grid.setRowFlex(0, 1);

        this._setLayout(grid);
      } // since the scroll container disregards the min size of the scrollbars
      // we have to set the min size of the scroll area to ensure that the
      // scrollbars always have an usable size.


      var size = qx.ui.core.scroll.AbstractScrollArea.DEFAULT_SCROLLBAR_WIDTH * 2 + 14;
      this.set({
        minHeight: size,
        minWidth: size
      }); // Roll listener for scrolling

      this._addRollHandling();
    },
    events: {
      /** Fired as soon as the scroll animation in X direction ends. */
      scrollAnimationXEnd: 'qx.event.type.Event',

      /** Fired as soon as the scroll animation in Y direction ends. */
      scrollAnimationYEnd: 'qx.event.type.Event'
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "scrollarea"
      },

      /**
       * The policy, when the horizontal scrollbar should be shown.
       * <ul>
       *   <li><b>auto</b>: Show scrollbar on demand</li>
       *   <li><b>on</b>: Always show the scrollbar</li>
       *   <li><b>off</b>: Never show the scrollbar</li>
       * </ul>
       */
      scrollbarX: {
        check: ["auto", "on", "off"],
        init: "auto",
        themeable: true,
        apply: "_computeScrollbars"
      },

      /**
       * The policy, when the horizontal scrollbar should be shown.
       * <ul>
       *   <li><b>auto</b>: Show scrollbar on demand</li>
       *   <li><b>on</b>: Always show the scrollbar</li>
       *   <li><b>off</b>: Never show the scrollbar</li>
       * </ul>
       */
      scrollbarY: {
        check: ["auto", "on", "off"],
        init: "auto",
        themeable: true,
        apply: "_computeScrollbars"
      },

      /**
       * Group property, to set the overflow of both scroll bars.
       */
      scrollbar: {
        group: ["scrollbarX", "scrollbarY"]
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        CHILD CONTROL SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "pane":
            control = new qx.ui.core.scroll.ScrollPane();
            control.addListener("update", this._computeScrollbars, this);
            control.addListener("scrollX", this._onScrollPaneX, this);
            control.addListener("scrollY", this._onScrollPaneY, this);

            if (qx.core.Environment.get("os.scrollBarOverlayed")) {
              this._add(control, {
                edge: 0
              });
            } else {
              this._add(control, {
                row: 0,
                column: 0
              });
            }

            break;

          case "scrollbar-x":
            control = this._createScrollBar("horizontal");
            control.setMinWidth(0);
            control.exclude();
            control.addListener("scroll", this._onScrollBarX, this);
            control.addListener("changeVisibility", this._onChangeScrollbarXVisibility, this);
            control.addListener("scrollAnimationEnd", this._onScrollAnimationEnd.bind(this, "X"));

            if (qx.core.Environment.get("os.scrollBarOverlayed")) {
              control.setMinHeight(qx.ui.core.scroll.AbstractScrollArea.DEFAULT_SCROLLBAR_WIDTH);

              this._add(control, {
                bottom: 0,
                right: 0,
                left: 0
              });
            } else {
              this._add(control, {
                row: 1,
                column: 0
              });
            }

            break;

          case "scrollbar-y":
            control = this._createScrollBar("vertical");
            control.setMinHeight(0);
            control.exclude();
            control.addListener("scroll", this._onScrollBarY, this);
            control.addListener("changeVisibility", this._onChangeScrollbarYVisibility, this);
            control.addListener("scrollAnimationEnd", this._onScrollAnimationEnd.bind(this, "Y"));

            if (qx.core.Environment.get("os.scrollBarOverlayed")) {
              control.setMinWidth(qx.ui.core.scroll.AbstractScrollArea.DEFAULT_SCROLLBAR_WIDTH);

              this._add(control, {
                right: 0,
                bottom: 0,
                top: 0
              });
            } else {
              this._add(control, {
                row: 0,
                column: 1
              });
            }

            break;

          case "corner":
            control = new qx.ui.core.Widget();
            control.setWidth(0);
            control.setHeight(0);
            control.exclude();

            if (!qx.core.Environment.get("os.scrollBarOverlayed")) {
              // only add for non overlayed scroll bars
              this._add(control, {
                row: 1,
                column: 1
              });
            }

            break;
        }

        return control || qx.ui.core.scroll.AbstractScrollArea.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        PANE SIZE
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the dimensions of the pane.
       *
       * @return {Map|null} The pane dimension in pixel. Contains
       *    the keys <code>width</code> and <code>height</code>.
       */
      getPaneSize: function getPaneSize() {
        return this.getChildControl("pane").getInnerSize();
      },

      /*
      ---------------------------------------------------------------------------
        ITEM LOCATION SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the top offset of the given item in relation to the
       * inner height of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Top offset
       */
      getItemTop: function getItemTop(item) {
        return this.getChildControl("pane").getItemTop(item);
      },

      /**
       * Returns the top offset of the end of the given item in relation to the
       * inner height of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Top offset
       */
      getItemBottom: function getItemBottom(item) {
        return this.getChildControl("pane").getItemBottom(item);
      },

      /**
       * Returns the left offset of the given item in relation to the
       * inner width of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Top offset
       */
      getItemLeft: function getItemLeft(item) {
        return this.getChildControl("pane").getItemLeft(item);
      },

      /**
       * Returns the left offset of the end of the given item in relation to the
       * inner width of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Right offset
       */
      getItemRight: function getItemRight(item) {
        return this.getChildControl("pane").getItemRight(item);
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Scrolls the element's content to the given left coordinate
       *
       * @param value {Integer} The vertical position to scroll to.
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollToX: function scrollToX(value, duration) {
        // First flush queue before scroll
        qx.ui.core.queue.Manager.flush();
        this.getChildControl("scrollbar-x").scrollTo(value, duration);
      },

      /**
       * Scrolls the element's content by the given left offset
       *
       * @param value {Integer} The vertical position to scroll to.
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollByX: function scrollByX(value, duration) {
        // First flush queue before scroll
        qx.ui.core.queue.Manager.flush();
        this.getChildControl("scrollbar-x").scrollBy(value, duration);
      },

      /**
       * Returns the scroll left position of the content
       *
       * @return {Integer} Horizontal scroll position
       */
      getScrollX: function getScrollX() {
        var scrollbar = this.getChildControl("scrollbar-x", true);
        return scrollbar ? scrollbar.getPosition() : 0;
      },

      /**
       * Scrolls the element's content to the given top coordinate
       *
       * @param value {Integer} The horizontal position to scroll to.
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollToY: function scrollToY(value, duration) {
        // First flush queue before scroll
        qx.ui.core.queue.Manager.flush();
        this.getChildControl("scrollbar-y").scrollTo(value, duration);
      },

      /**
       * Scrolls the element's content by the given top offset
       *
       * @param value {Integer} The horizontal position to scroll to.
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollByY: function scrollByY(value, duration) {
        // First flush queue before scroll
        qx.ui.core.queue.Manager.flush();
        this.getChildControl("scrollbar-y").scrollBy(value, duration);
      },

      /**
       * Returns the scroll top position of the content
       *
       * @return {Integer} Vertical scroll position
       */
      getScrollY: function getScrollY() {
        var scrollbar = this.getChildControl("scrollbar-y", true);
        return scrollbar ? scrollbar.getPosition() : 0;
      },

      /**
       * In case a scroll animation is currently running in X direction,
       * it will be stopped. If not, the method does nothing.
       */
      stopScrollAnimationX: function stopScrollAnimationX() {
        var scrollbar = this.getChildControl("scrollbar-x", true);

        if (scrollbar) {
          scrollbar.stopScrollAnimation();
        }
      },

      /**
       * In case a scroll animation is currently running in X direction,
       * it will be stopped. If not, the method does nothing.
       */
      stopScrollAnimationY: function stopScrollAnimationY() {
        var scrollbar = this.getChildControl("scrollbar-y", true);

        if (scrollbar) {
          scrollbar.stopScrollAnimation();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the scroll animation end event for both scroll bars.
       *
       * @param direction {String} Either "X" or "Y".
       */
      _onScrollAnimationEnd: function _onScrollAnimationEnd(direction) {
        this.fireEvent("scrollAnimation" + direction + "End");
      },

      /**
       * Event handler for the scroll event of the horizontal scrollbar
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollBarX: function _onScrollBarX(e) {
        this.getChildControl("pane").scrollToX(e.getData());
      },

      /**
       * Event handler for the scroll event of the vertical scrollbar
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollBarY: function _onScrollBarY(e) {
        this.getChildControl("pane").scrollToY(e.getData());
      },

      /**
       * Event handler for the horizontal scroll event of the pane
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollPaneX: function _onScrollPaneX(e) {
        var scrollbar = this.getChildControl("scrollbar-x");

        if (scrollbar) {
          scrollbar.updatePosition(e.getData());
        }
      },

      /**
       * Event handler for the vertical scroll event of the pane
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollPaneY: function _onScrollPaneY(e) {
        var scrollbar = this.getChildControl("scrollbar-y");

        if (scrollbar) {
          scrollbar.updatePosition(e.getData());
        }
      },

      /**
       * Event handler for visibility changes of horizontal scrollbar.
       *
       * @param e {qx.event.type.Event} Property change event
       */
      _onChangeScrollbarXVisibility: function _onChangeScrollbarXVisibility(e) {
        var showX = this._isChildControlVisible("scrollbar-x");

        var showY = this._isChildControlVisible("scrollbar-y");

        if (!showX) {
          this.scrollToX(0);
        }

        showX && showY ? this._showChildControl("corner") : this._excludeChildControl("corner");
      },

      /**
       * Event handler for visibility changes of horizontal scrollbar.
       *
       * @param e {qx.event.type.Event} Property change event
       */
      _onChangeScrollbarYVisibility: function _onChangeScrollbarYVisibility(e) {
        var showX = this._isChildControlVisible("scrollbar-x");

        var showY = this._isChildControlVisible("scrollbar-y");

        if (!showY) {
          this.scrollToY(0);
        }

        showX && showY ? this._showChildControl("corner") : this._excludeChildControl("corner");
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Computes the visibility state for scrollbars.
       *
       */
      _computeScrollbars: function _computeScrollbars() {
        var pane = this.getChildControl("pane");
        var content = pane.getChildren()[0];

        if (!content) {
          this._excludeChildControl("scrollbar-x");

          this._excludeChildControl("scrollbar-y");

          return;
        }

        var innerSize = this.getInnerSize();
        var paneSize = pane.getInnerSize();
        var scrollSize = pane.getScrollSize(); // if the widget has not yet been rendered, return and try again in the
        // resize event

        if (!paneSize || !scrollSize) {
          return;
        }

        var scrollbarX = this.getScrollbarX();
        var scrollbarY = this.getScrollbarY();

        if (scrollbarX === "auto" && scrollbarY === "auto") {
          // Check if the container is big enough to show
          // the full content.
          var showX = scrollSize.width > innerSize.width;
          var showY = scrollSize.height > innerSize.height; // Dependency check
          // We need a special intelligence here when only one
          // of the autosized axis requires a scrollbar
          // This scrollbar may then influence the need
          // for the other one as well.

          if ((showX || showY) && !(showX && showY)) {
            if (showX) {
              showY = scrollSize.height > paneSize.height;
            } else if (showY) {
              showX = scrollSize.width > paneSize.width;
            }
          }
        } else {
          var showX = scrollbarX === "on";
          var showY = scrollbarY === "on"; // Check auto values afterwards with already
          // corrected client dimensions

          if (scrollSize.width > (showX ? paneSize.width : innerSize.width) && scrollbarX === "auto") {
            showX = true;
          }

          if (scrollSize.height > (showX ? paneSize.height : innerSize.height) && scrollbarY === "auto") {
            showY = true;
          }
        } // Update scrollbars


        if (showX) {
          var barX = this.getChildControl("scrollbar-x");
          barX.show();
          barX.setMaximum(Math.max(0, scrollSize.width - paneSize.width));
          barX.setKnobFactor(scrollSize.width === 0 ? 0 : paneSize.width / scrollSize.width);
        } else {
          this._excludeChildControl("scrollbar-x");
        }

        if (showY) {
          var barY = this.getChildControl("scrollbar-y");
          barY.show();
          barY.setMaximum(Math.max(0, scrollSize.height - paneSize.height));
          barY.setKnobFactor(scrollSize.height === 0 ? 0 : paneSize.height / scrollSize.height);
        } else {
          this._excludeChildControl("scrollbar-y");
        }
      }
    }
  });
  qx.ui.core.scroll.AbstractScrollArea.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This mixin defines the <code>contentPadding</code> property, which is used
   * by widgets like the window or group box, which must have a property, which
   * defines the padding of an inner pane.
   *
   * The including class must implement the method
   * <code>_getContentPaddingTarget</code>, which must return the widget on which
   * the padding should be applied.
   */
  qx.Mixin.define("qx.ui.core.MContentPadding", {
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Top padding of the content pane */
      contentPaddingTop: {
        check: "Integer",
        init: 0,
        apply: "_applyContentPadding",
        themeable: true
      },

      /** Right padding of the content pane */
      contentPaddingRight: {
        check: "Integer",
        init: 0,
        apply: "_applyContentPadding",
        themeable: true
      },

      /** Bottom padding of the content pane */
      contentPaddingBottom: {
        check: "Integer",
        init: 0,
        apply: "_applyContentPadding",
        themeable: true
      },

      /** Left padding of the content pane */
      contentPaddingLeft: {
        check: "Integer",
        init: 0,
        apply: "_applyContentPadding",
        themeable: true
      },

      /**
       * The 'contentPadding' property is a shorthand property for setting 'contentPaddingTop',
       * 'contentPaddingRight', 'contentPaddingBottom' and 'contentPaddingLeft'
       * at the same time.
       *
       * If four values are specified they apply to top, right, bottom and left respectively.
       * If there is only one value, it applies to all sides, if there are two or three,
       * the missing values are taken from the opposite side.
       */
      contentPadding: {
        group: ["contentPaddingTop", "contentPaddingRight", "contentPaddingBottom", "contentPaddingLeft"],
        mode: "shorthand",
        themeable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * @type {Map} Maps property names of content padding to the setter of the padding
       *
       * @lint ignoreReferenceField(__contentPaddingSetter)
       */
      __contentPaddingSetter__P_378_0: {
        contentPaddingTop: "setPaddingTop",
        contentPaddingRight: "setPaddingRight",
        contentPaddingBottom: "setPaddingBottom",
        contentPaddingLeft: "setPaddingLeft"
      },

      /**
       * @type {Map} Maps property names of content padding to the themed setter of the padding
       *
       * @lint ignoreReferenceField(__contentPaddingThemedSetter)
       */
      __contentPaddingThemedSetter__P_378_1: {
        contentPaddingTop: "setThemedPaddingTop",
        contentPaddingRight: "setThemedPaddingRight",
        contentPaddingBottom: "setThemedPaddingBottom",
        contentPaddingLeft: "setThemedPaddingLeft"
      },

      /**
       * @type {Map} Maps property names of content padding to the resetter of the padding
       *
       * @lint ignoreReferenceField(__contentPaddingResetter)
       */
      __contentPaddingResetter__P_378_2: {
        contentPaddingTop: "resetPaddingTop",
        contentPaddingRight: "resetPaddingRight",
        contentPaddingBottom: "resetPaddingBottom",
        contentPaddingLeft: "resetPaddingLeft"
      },
      // property apply
      _applyContentPadding: function _applyContentPadding(value, old, name, variant) {
        var target = this._getContentPaddingTarget();

        if (value == null) {
          var resetter = this.__contentPaddingResetter__P_378_2[name];
          target[resetter]();
        } else {
          // forward the themed sates if case the apply was invoked by a theme
          if (variant == "setThemed" || variant == "resetThemed") {
            var setter = this.__contentPaddingThemedSetter__P_378_1[name];
            target[setter](value);
          } else {
            var setter = this.__contentPaddingSetter__P_378_0[name];
            target[setter](value);
          }
        }
      }
    }
  });
  qx.ui.core.MContentPadding.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.lang.Object": {},
      "qx.ui.layout.Util": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The grid layout manager arranges the items in a two dimensional
   * grid. Widgets can be placed into the grid's cells and may span multiple rows
   * and columns.
   *
   * *Features*
   *
   * * Flex values for rows and columns
   * * Minimal and maximal column and row sizes
   * * Manually setting of column and row sizes
   * * Horizontal and vertical alignment
   * * Horizontal and vertical spacing
   * * Column and row spans
   * * Auto-sizing
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>row</strong> <em>(Integer)</em>: The row of the cell the
   *   widget should occupy. Each cell can only containing one widget. This layout
   *   property is mandatory.
   * </li>
   * <li><strong>column</strong> <em>(Integer)</em>: The column of the cell the
   *   widget should occupy. Each cell can only containing one widget. This layout
   *   property is mandatory.
   * </li>
   * <li><strong>rowSpan</strong> <em>(Integer)</em>: The number of rows, the
   *   widget should span, starting from the row specified in the <code>row</code>
   *   property. The cells in the spanned rows must be empty as well.
   * </li>
   * <li><strong>colSpan</strong> <em>(Integer)</em>: The number of columns, the
   *   widget should span, starting from the column specified in the <code>column</code>
   *   property. The cells in the spanned columns must be empty as well.
   * </li>
   * </ul>
   *
   * *Example*
   *
   * Here is a little example of how to use the grid layout.
   *
   * <pre class="javascript">
   * var layout = new qx.ui.layout.Grid();
   * layout.setRowFlex(0, 1); // make row 0 flexible
   * layout.setColumnWidth(1, 200); // set with of column 1 to 200 pixel
   *
   * var container = new qx.ui.container.Composite(layout);
   * container.add(new qx.ui.core.Widget(), {row: 0, column: 0});
   * container.add(new qx.ui.core.Widget(), {row: 0, column: 1});
   * container.add(new qx.ui.core.Widget(), {row: 1, column: 0, rowSpan: 2});
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='https://qooxdoo.org/documentation/#/desktop/layout/grid.md'>
   * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.
   */
  qx.Class.define("qx.ui.layout.Grid", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param spacingX {Integer?0} The horizontal spacing between grid cells.
     *     Sets {@link #spacingX}.
     * @param spacingY {Integer?0} The vertical spacing between grid cells.
     *     Sets {@link #spacingY}.
     */
    construct: function construct(spacingX, spacingY) {
      qx.ui.layout.Abstract.constructor.call(this);
      this.__rowData__P_436_0 = [];
      this.__colData__P_436_1 = [];

      if (spacingX) {
        this.setSpacingX(spacingX);
      }

      if (spacingY) {
        this.setSpacingY(spacingY);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The horizontal spacing between grid cells.
       */
      spacingX: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /**
       * The vertical spacing between grid cells.
       */
      spacingY: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /**
       * Allow growing of spanning cells' widths beyond the accumulated widths of the columns.
       * The default behavior (init value false) is that the width of the spanning cell is
       * determined by the accumulated width of the columns (plus spacing).
       * Setting this property to true lets the cell width grow as needed to show
       * the widget in the spanning cell, which also enlarges the width of the spanned columns.
       */
      allowGrowSpannedCellWidth: {
        check: "Boolean",
        init: false,
        apply: "_applyLayoutChange"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {Array} 2D array of grid cell data */
      __grid__P_436_2: null,
      __rowData__P_436_0: null,
      __colData__P_436_1: null,
      __colSpans__P_436_3: null,
      __rowSpans__P_436_4: null,
      __maxRowIndex__P_436_5: null,
      __maxColIndex__P_436_6: null,

      /** @type {Array} cached row heights */
      __rowHeights__P_436_7: null,

      /** @type {Array} cached column widths */
      __colWidths__P_436_8: null,
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        var layoutProperties = {
          "row": 1,
          "column": 1,
          "rowSpan": 1,
          "colSpan": 1
        };
        this.assert(layoutProperties[name] == 1, "The property '" + name + "' is not supported by the Grid layout!");
        this.assertInteger(value);
        this.assert(value >= 0, "Value must be positive");
      },

      /**
       * Rebuild the internal representation of the grid
       */
      __buildGrid__P_436_9: function __buildGrid__P_436_9() {
        var grid = [];
        var colSpans = [];
        var rowSpans = [];
        var maxRowIndex = -1;
        var maxColIndex = -1;

        var children = this._getLayoutChildren();

        for (var i = 0, l = children.length; i < l; i++) {
          var child = children[i];
          var props = child.getLayoutProperties();
          var row = props.row;
          var column = props.column;
          props.colSpan = props.colSpan || 1;
          props.rowSpan = props.rowSpan || 1; // validate arguments

          if (row == null || column == null) {
            throw new Error("The layout properties 'row' and 'column' of the child widget '" + child + "' must be defined!");
          }

          if (grid[row] && grid[row][column]) {
            throw new Error("Cannot add widget '" + child + "'!. " + "There is already a widget '" + grid[row][column] + "' in this cell (" + row + ", " + column + ") for '" + this + "'");
          }

          for (var x = column; x < column + props.colSpan; x++) {
            for (var y = row; y < row + props.rowSpan; y++) {
              if (grid[y] == undefined) {
                grid[y] = [];
              }

              grid[y][x] = child;
              maxColIndex = Math.max(maxColIndex, x);
              maxRowIndex = Math.max(maxRowIndex, y);
            }
          }

          if (props.rowSpan > 1) {
            rowSpans.push(child);
          }

          if (props.colSpan > 1) {
            colSpans.push(child);
          }
        } // make sure all columns are defined so that accessing the grid using
        // this.__grid[column][row] will never raise an exception


        for (var y = 0; y <= maxRowIndex; y++) {
          if (grid[y] == undefined) {
            grid[y] = [];
          }
        }

        this.__grid__P_436_2 = grid;
        this.__colSpans__P_436_3 = colSpans;
        this.__rowSpans__P_436_4 = rowSpans;
        this.__maxRowIndex__P_436_5 = maxRowIndex;
        this.__maxColIndex__P_436_6 = maxColIndex;
        this.__rowHeights__P_436_7 = null;
        this.__colWidths__P_436_8 = null; // Clear invalidation marker

        delete this._invalidChildrenCache;
      },

      /**
       * Stores data for a grid row
       *
       * @param row {Integer} The row index
       * @param key {String} The key under which the data should be stored
       * @param value {var} data to store
       */
      _setRowData: function _setRowData(row, key, value) {
        var rowData = this.__rowData__P_436_0[row];

        if (!rowData) {
          this.__rowData__P_436_0[row] = {};
          this.__rowData__P_436_0[row][key] = value;
        } else {
          rowData[key] = value;
        }
      },

      /**
       * Stores data for a grid column
       *
       * @param column {Integer} The column index
       * @param key {String} The key under which the data should be stored
       * @param value {var} data to store
       */
      _setColumnData: function _setColumnData(column, key, value) {
        var colData = this.__colData__P_436_1[column];

        if (!colData) {
          this.__colData__P_436_1[column] = {};
          this.__colData__P_436_1[column][key] = value;
        } else {
          colData[key] = value;
        }
      },

      /**
       * Shortcut to set both horizontal and vertical spacing between grid cells
       * to the same value.
       *
       * @param spacing {Integer} new horizontal and vertical spacing
       * @return {qx.ui.layout.Grid} This object (for chaining support).
       */
      setSpacing: function setSpacing(spacing) {
        this.setSpacingY(spacing);
        this.setSpacingX(spacing);
        return this;
      },

      /**
       * Set the default cell alignment for a column. This alignment can be
       * overridden on a per cell basis by setting the cell's content widget's
       * <code>alignX</code> and <code>alignY</code> properties.
       *
       * If on a grid cell both row and a column alignment is set, the horizontal
       * alignment is taken from the column and the vertical alignment is taken
       * from the row.
       *
       * @param column {Integer} Column index
       * @param hAlign {String} The horizontal alignment. Valid values are
       *    "left", "center" and "right".
       * @param vAlign {String} The vertical alignment. Valid values are
       *    "top", "middle", "bottom"
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnAlign: function setColumnAlign(column, hAlign, vAlign) {
        {
          this.assertInteger(column, "Invalid parameter 'column'");
          this.assertInArray(hAlign, ["left", "center", "right"]);
          this.assertInArray(vAlign, ["top", "middle", "bottom"]);
        }

        this._setColumnData(column, "hAlign", hAlign);

        this._setColumnData(column, "vAlign", vAlign);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get a map of the column's alignment.
       *
       * @param column {Integer} The column index
       * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>
       *     containing the vertical and horizontal column alignment.
       */
      getColumnAlign: function getColumnAlign(column) {
        var colData = this.__colData__P_436_1[column] || {};
        return {
          vAlign: colData.vAlign || "top",
          hAlign: colData.hAlign || "left"
        };
      },

      /**
       * Set the default cell alignment for a row. This alignment can be
       * overridden on a per cell basis by setting the cell's content widget's
       * <code>alignX</code> and <code>alignY</code> properties.
       *
       * If on a grid cell both row and a column alignment is set, the horizontal
       * alignment is taken from the column and the vertical alignment is taken
       * from the row.
       *
       * @param row {Integer} Row index
       * @param hAlign {String} The horizontal alignment. Valid values are
       *    "left", "center" and "right".
       * @param vAlign {String} The vertical alignment. Valid values are
       *    "top", "middle", "bottom"
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowAlign: function setRowAlign(row, hAlign, vAlign) {
        {
          this.assertInteger(row, "Invalid parameter 'row'");
          this.assertInArray(hAlign, ["left", "center", "right"]);
          this.assertInArray(vAlign, ["top", "middle", "bottom"]);
        }

        this._setRowData(row, "hAlign", hAlign);

        this._setRowData(row, "vAlign", vAlign);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get a map of the row's alignment.
       *
       * @param row {Integer} The Row index
       * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>
       *     containing the vertical and horizontal row alignment.
       */
      getRowAlign: function getRowAlign(row) {
        var rowData = this.__rowData__P_436_0[row] || {};
        return {
          vAlign: rowData.vAlign || "top",
          hAlign: rowData.hAlign || "left"
        };
      },

      /**
       * Get the widget located in the cell. If a the cell is empty or the widget
       * has a {@link qx.ui.core.Widget#visibility} value of <code>exclude</code>,
       * <code>null</code> is returned.
       *
       * @param row {Integer} The cell's row index
       * @param column {Integer} The cell's column index
       * @return {qx.ui.core.Widget|null}The cell's widget. The value may be null.
       */
      getCellWidget: function getCellWidget(row, column) {
        if (this._invalidChildrenCache) {
          this.__buildGrid__P_436_9();
        }

        var row = this.__grid__P_436_2[row] || {};
        return row[column] || null;
      },

      /**
       * Get the number of rows in the grid layout.
       *
       * @return {Integer} The number of rows in the layout
       */
      getRowCount: function getRowCount() {
        if (this._invalidChildrenCache) {
          this.__buildGrid__P_436_9();
        }

        return this.__maxRowIndex__P_436_5 + 1;
      },

      /**
       * Get the number of columns in the grid layout.
       *
       * @return {Integer} The number of columns in the layout
       */
      getColumnCount: function getColumnCount() {
        if (this._invalidChildrenCache) {
          this.__buildGrid__P_436_9();
        }

        return this.__maxColIndex__P_436_6 + 1;
      },

      /**
       * Get a map of the cell's alignment. For vertical alignment the row alignment
       * takes precedence over the column alignment. For horizontal alignment it is
       * the over way round. If an alignment is set on the cell widget using
       * {@link qx.ui.core.LayoutItem#setLayoutProperties}, this alignment takes
       * always precedence over row or column alignment.
       *
       * @param row {Integer} The cell's row index
       * @param column {Integer} The cell's column index
       * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>
       *     containing the vertical and horizontal cell alignment.
       */
      getCellAlign: function getCellAlign(row, column) {
        var vAlign = "top";
        var hAlign = "left";
        var rowData = this.__rowData__P_436_0[row];
        var colData = this.__colData__P_436_1[column];
        var widget = this.__grid__P_436_2[row][column];

        if (widget) {
          var widgetProps = {
            vAlign: widget.getAlignY(),
            hAlign: widget.getAlignX()
          };
        } else {
          widgetProps = {};
        } // compute vAlign
        // precedence : widget -> row -> column


        if (widgetProps.vAlign) {
          vAlign = widgetProps.vAlign;
        } else if (rowData && rowData.vAlign) {
          vAlign = rowData.vAlign;
        } else if (colData && colData.vAlign) {
          vAlign = colData.vAlign;
        } // compute hAlign
        // precedence : widget -> column -> row


        if (widgetProps.hAlign) {
          hAlign = widgetProps.hAlign;
        } else if (colData && colData.hAlign) {
          hAlign = colData.hAlign;
        } else if (rowData && rowData.hAlign) {
          hAlign = rowData.hAlign;
        }

        return {
          vAlign: vAlign,
          hAlign: hAlign
        };
      },

      /**
       * Set the flex value for a grid column.
       * By default the column flex value is <code>0</code>.
       *
       * @param column {Integer} The column index
       * @param flex {Integer} The column's flex value
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnFlex: function setColumnFlex(column, flex) {
        this._setColumnData(column, "flex", flex);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the flex value of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's flex value
       */
      getColumnFlex: function getColumnFlex(column) {
        var colData = this.__colData__P_436_1[column] || {};
        return colData.flex !== undefined ? colData.flex : 0;
      },

      /**
       * Set the flex value for a grid row.
       * By default the row flex value is <code>0</code>.
       *
       * @param row {Integer} The row index
       * @param flex {Integer} The row's flex value
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowFlex: function setRowFlex(row, flex) {
        this._setRowData(row, "flex", flex);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the flex value of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's flex value
       */
      getRowFlex: function getRowFlex(row) {
        var rowData = this.__rowData__P_436_0[row] || {};
        var rowFlex = rowData.flex !== undefined ? rowData.flex : 0;
        return rowFlex;
      },

      /**
       * Set the maximum width of a grid column.
       * The default value is <code>Infinity</code>.
       *
       * @param column {Integer} The column index
       * @param maxWidth {Integer} The column's maximum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnMaxWidth: function setColumnMaxWidth(column, maxWidth) {
        this._setColumnData(column, "maxWidth", maxWidth);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the maximum width of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's maximum width
       */
      getColumnMaxWidth: function getColumnMaxWidth(column) {
        var colData = this.__colData__P_436_1[column] || {};
        return colData.maxWidth !== undefined ? colData.maxWidth : Infinity;
      },

      /**
       * Set the preferred width of a grid column.
       * The default value is <code>Infinity</code>.
       *
       * @param column {Integer} The column index
       * @param width {Integer} The column's width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnWidth: function setColumnWidth(column, width) {
        this._setColumnData(column, "width", width);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the preferred width of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's width
       */
      getColumnWidth: function getColumnWidth(column) {
        var colData = this.__colData__P_436_1[column] || {};
        return colData.width !== undefined ? colData.width : null;
      },

      /**
       * Set the minimum width of a grid column.
       * The default value is <code>0</code>.
       *
       * @param column {Integer} The column index
       * @param minWidth {Integer} The column's minimum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnMinWidth: function setColumnMinWidth(column, minWidth) {
        this._setColumnData(column, "minWidth", minWidth);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the minimum width of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's minimum width
       */
      getColumnMinWidth: function getColumnMinWidth(column) {
        var colData = this.__colData__P_436_1[column] || {};
        return colData.minWidth || 0;
      },

      /**
       * Set the maximum height of a grid row.
       * The default value is <code>Infinity</code>.
       *
       * @param row {Integer} The row index
       * @param maxHeight {Integer} The row's maximum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowMaxHeight: function setRowMaxHeight(row, maxHeight) {
        this._setRowData(row, "maxHeight", maxHeight);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the maximum height of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's maximum width
       */
      getRowMaxHeight: function getRowMaxHeight(row) {
        var rowData = this.__rowData__P_436_0[row] || {};
        return rowData.maxHeight || Infinity;
      },

      /**
       * Set the preferred height of a grid row.
       * The default value is <code>Infinity</code>.
       *
       * @param row {Integer} The row index
       * @param height {Integer} The row's width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowHeight: function setRowHeight(row, height) {
        this._setRowData(row, "height", height);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the preferred height of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's width
       */
      getRowHeight: function getRowHeight(row) {
        var rowData = this.__rowData__P_436_0[row] || {};
        return rowData.height !== undefined ? rowData.height : null;
      },

      /**
       * Set the minimum height of a grid row.
       * The default value is <code>0</code>.
       *
       * @param row {Integer} The row index
       * @param minHeight {Integer} The row's minimum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowMinHeight: function setRowMinHeight(row, minHeight) {
        this._setRowData(row, "minHeight", minHeight);

        this._applyLayoutChange();

        return this;
      },

      /**
       * Get the minimum height of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's minimum width
       */
      getRowMinHeight: function getRowMinHeight(row) {
        var rowData = this.__rowData__P_436_0[row] || {};
        return rowData.minHeight || 0;
      },

      /**
       * Computes the widget's size hint including the widget's margins
       *
       * @param widget {qx.ui.core.LayoutItem} The widget to get the size for
       * @return {Map} a size hint map
       */
      _getOuterSize: function _getOuterSize(widget) {
        var hint = widget.getSizeHint();
        var hMargins = widget.getMarginLeft() + widget.getMarginRight();
        var vMargins = widget.getMarginTop() + widget.getMarginBottom();
        var outerSize = {
          height: hint.height + vMargins,
          width: hint.width + hMargins,
          minHeight: hint.minHeight + vMargins,
          minWidth: hint.minWidth + hMargins,
          maxHeight: hint.maxHeight + vMargins,
          maxWidth: hint.maxWidth + hMargins
        };
        return outerSize;
      },

      /**
       * Check whether all row spans fit with their preferred height into the
       * preferred row heights. If there is not enough space, the preferred
       * row sizes are increased. The distribution respects the flex and max
       * values of the rows.
       *
       *  The same is true for the min sizes.
       *
       *  The height array is modified in place.
       *
       * @param rowHeights {Map[]} The current row height array as computed by
       *     {@link #_getRowHeights}.
       */
      _fixHeightsRowSpan: function _fixHeightsRowSpan(rowHeights) {
        var vSpacing = this.getSpacingY();

        for (var i = 0, l = this.__rowSpans__P_436_4.length; i < l; i++) {
          var widget = this.__rowSpans__P_436_4[i];

          var hint = this._getOuterSize(widget);

          var widgetProps = widget.getLayoutProperties();
          var widgetRow = widgetProps.row;
          var prefSpanHeight = vSpacing * (widgetProps.rowSpan - 1);
          var minSpanHeight = prefSpanHeight;
          var rowFlexes = {};

          for (var j = 0; j < widgetProps.rowSpan; j++) {
            var row = widgetProps.row + j;
            var rowHeight = rowHeights[row];
            var rowFlex = this.getRowFlex(row);

            if (rowFlex > 0) {
              // compute flex array for the preferred height
              rowFlexes[row] = {
                min: rowHeight.minHeight,
                value: rowHeight.height,
                max: rowHeight.maxHeight,
                flex: rowFlex
              };
            }

            prefSpanHeight += rowHeight.height;
            minSpanHeight += rowHeight.minHeight;
          } // If there is not enough space for the preferred size
          // increment the preferred row sizes.


          if (prefSpanHeight < hint.height) {
            if (!qx.lang.Object.isEmpty(rowFlexes)) {
              var rowIncrements = qx.ui.layout.Util.computeFlexOffsets(rowFlexes, hint.height, prefSpanHeight);

              for (var k = 0; k < widgetProps.rowSpan; k++) {
                var offset = rowIncrements[widgetRow + k] ? rowIncrements[widgetRow + k].offset : 0;
                rowHeights[widgetRow + k].height += offset;
              } // row is too small and we have no flex value set

            } else {
              var totalSpacing = vSpacing * (widgetProps.rowSpan - 1);
              var availableHeight = hint.height - totalSpacing; // get the row height which every child would need to share the
              // available hight equally

              var avgRowHeight = Math.floor(availableHeight / widgetProps.rowSpan); // get the hight already used and the number of children which do
              // not have at least that avg row height

              var usedHeight = 0;
              var rowsNeedAddition = 0;

              for (var k = 0; k < widgetProps.rowSpan; k++) {
                var currentHeight = rowHeights[widgetRow + k].height;
                usedHeight += currentHeight;

                if (currentHeight < avgRowHeight) {
                  rowsNeedAddition++;
                }
              } // the difference of available and used needs to be shared among
              // those not having the min size


              var additionalRowHeight = Math.floor((availableHeight - usedHeight) / rowsNeedAddition); // add the extra height to the too small children

              for (var k = 0; k < widgetProps.rowSpan; k++) {
                if (rowHeights[widgetRow + k].height < avgRowHeight) {
                  rowHeights[widgetRow + k].height += additionalRowHeight;
                }
              }
            }
          } // If there is not enough space for the min size
          // increment the min row sizes.


          if (minSpanHeight < hint.minHeight) {
            var rowIncrements = qx.ui.layout.Util.computeFlexOffsets(rowFlexes, hint.minHeight, minSpanHeight);

            for (var j = 0; j < widgetProps.rowSpan; j++) {
              var offset = rowIncrements[widgetRow + j] ? rowIncrements[widgetRow + j].offset : 0;
              rowHeights[widgetRow + j].minHeight += offset;
            }
          }
        }
      },

      /**
       * Check whether all col spans fit with their preferred width into the
       * preferred column widths. If there is not enough space the preferred
       * column sizes are increased. The distribution respects the flex and max
       * values of the columns.
       *
       *  The same is true for the min sizes.
       *
       *  The width array is modified in place.
       *
       * @param colWidths {Map[]} The current column width array as computed by
       *     {@link #_getColWidths}.
       */
      _fixWidthsColSpan: function _fixWidthsColSpan(colWidths) {
        var hSpacing = this.getSpacingX();

        var colSpans = this._getColSpans();

        for (var i = 0, l = colSpans.length; i < l; i++) {
          var widget = colSpans[i];

          var hint = this._getOuterSize(widget);

          var widgetProps = widget.getLayoutProperties();
          var widgetColumn = widgetProps.column;
          var prefSpanWidth = hSpacing * (widgetProps.colSpan - 1);
          var minSpanWidth = prefSpanWidth;
          var colFlexes = {};
          var offset;

          for (var j = 0; j < widgetProps.colSpan; j++) {
            var col = widgetProps.column + j;
            var colWidth = colWidths[col];
            var colFlex = this.getColumnFlex(col); // compute flex array for the preferred width

            if (colFlex > 0) {
              colFlexes[col] = {
                min: colWidth.minWidth,
                value: colWidth.width,
                max: colWidth.maxWidth,
                flex: colFlex
              };
            }

            prefSpanWidth += colWidth.width;
            minSpanWidth += colWidth.minWidth;
          } // If there is not enough space for the preferred size
          // increment the preferred column sizes.


          if (prefSpanWidth < hint.width) {
            // Do not adapt column widths to the width
            // of the spanning cell if allowGrowSpannedCellWidth property
            // is set to false
            // See https://github.com/qooxdoo/qooxdoo/issues/9871
            if (!this.getAllowGrowSpannedCellWidth() || !qx.lang.Object.isEmpty(colFlexes)) {
              var colIncrements = qx.ui.layout.Util.computeFlexOffsets(colFlexes, hint.width, prefSpanWidth);

              for (var j = 0; j < widgetProps.colSpan; j++) {
                offset = colIncrements[widgetColumn + j] ? colIncrements[widgetColumn + j].offset : 0;
                colWidths[widgetColumn + j].width += offset;
              } // col is too small and we have no flex value set

            } else {
              var totalSpacing = hSpacing * (widgetProps.colSpan - 1);
              var availableWidth = hint.width - totalSpacing; // get the col width which every child would need to share the
              // available width equally

              var avgColWidth = Math.floor(availableWidth / widgetProps.colSpan); // get the width already used and the number of children which do
              // not have at least that avg col width

              var usedWidth = 0;
              var colsNeedAddition = 0;

              for (var k = 0; k < widgetProps.colSpan; k++) {
                var currentWidth = colWidths[widgetColumn + k].width;
                usedWidth += currentWidth;

                if (currentWidth < avgColWidth) {
                  colsNeedAddition++;
                }
              } // the difference of available and used needs to be shared among
              // those not having the min size


              var additionalColWidth = Math.floor((availableWidth - usedWidth) / colsNeedAddition); // add the extra width to the too small children

              for (var k = 0; k < widgetProps.colSpan; k++) {
                if (colWidths[widgetColumn + k].width < avgColWidth) {
                  colWidths[widgetColumn + k].width += additionalColWidth;
                }
              }
            }
          } // If there is not enough space for the min size
          // increment the min column sizes.


          if (minSpanWidth < hint.minWidth) {
            var colIncrements = qx.ui.layout.Util.computeFlexOffsets(colFlexes, hint.minWidth, minSpanWidth);

            for (var j = 0; j < widgetProps.colSpan; j++) {
              offset = colIncrements[widgetColumn + j] ? colIncrements[widgetColumn + j].offset : 0;
              colWidths[widgetColumn + j].minWidth += offset;
            }
          }
        }
      },

      /**
       * Compute the min/pref/max row heights.
       *
       * @return {Map[]} An array containing height information for each row. The
       *     entries have the keys <code>minHeight</code>, <code>maxHeight</code> and
       *     <code>height</code>.
       */
      _getRowHeights: function _getRowHeights() {
        if (this.__rowHeights__P_436_7 != null) {
          return this.__rowHeights__P_436_7;
        }

        var rowHeights = [];
        var maxRowIndex = this.__maxRowIndex__P_436_5;
        var maxColIndex = this.__maxColIndex__P_436_6;

        for (var row = 0; row <= maxRowIndex; row++) {
          var minHeight = 0;
          var height = 0;
          var maxHeight = 0;

          for (var col = 0; col <= maxColIndex; col++) {
            var widget = this.__grid__P_436_2[row][col];

            if (!widget) {
              continue;
            } // ignore rows with row spans at this place
            // these rows will be taken into account later


            var widgetRowSpan = widget.getLayoutProperties().rowSpan || 0;

            if (widgetRowSpan > 1) {
              continue;
            }

            var cellSize = this._getOuterSize(widget);

            if (this.getRowFlex(row) > 0) {
              minHeight = Math.max(minHeight, cellSize.minHeight);
            } else {
              minHeight = Math.max(minHeight, cellSize.height);
            }

            height = Math.max(height, cellSize.height);
          }

          var minHeight = Math.max(minHeight, this.getRowMinHeight(row));
          var maxHeight = this.getRowMaxHeight(row);

          if (this.getRowHeight(row) !== null) {
            var height = this.getRowHeight(row);
          } else {
            var height = Math.max(minHeight, Math.min(height, maxHeight));
          }

          rowHeights[row] = {
            minHeight: minHeight,
            height: height,
            maxHeight: maxHeight
          };
        }

        if (this.__rowSpans__P_436_4.length > 0) {
          this._fixHeightsRowSpan(rowHeights);
        }

        this.__rowHeights__P_436_7 = rowHeights;
        return rowHeights;
      },

      /**
       * Compute the min/pref/max column widths.
       *
       * @return {Map[]} An array containing width information for each column. The
       *     entries have the keys <code>minWidth</code>, <code>maxWidth</code> and
       *     <code>width</code>.
       */
      _getColWidths: function _getColWidths() {
        if (this.__colWidths__P_436_8 != null) {
          return this.__colWidths__P_436_8;
        }

        var colWidths = [];
        var maxColIndex = this.__maxColIndex__P_436_6;
        var maxRowIndex = this.__maxRowIndex__P_436_5;

        for (var col = 0; col <= maxColIndex; col++) {
          var width = 0;
          var minWidth = 0;
          var maxWidth = Infinity;

          for (var row = 0; row <= maxRowIndex; row++) {
            var widget = this.__grid__P_436_2[row][col];

            if (!widget) {
              continue;
            } // ignore columns with col spans at this place
            // these columns will be taken into account later


            var widgetColSpan = widget.getLayoutProperties().colSpan || 0;

            if (widgetColSpan > 1) {
              continue;
            }

            var cellSize = this._getOuterSize(widget);

            minWidth = Math.max(minWidth, cellSize.minWidth);
            width = Math.max(width, cellSize.width);
          }

          minWidth = Math.max(minWidth, this.getColumnMinWidth(col));
          maxWidth = this.getColumnMaxWidth(col);

          if (this.getColumnWidth(col) !== null) {
            var width = this.getColumnWidth(col);
          } else {
            var width = Math.max(minWidth, Math.min(width, maxWidth));
          }

          colWidths[col] = {
            minWidth: minWidth,
            width: width,
            maxWidth: maxWidth
          };
        }

        if (this._getColSpans().length > 0) {
          this._fixWidthsColSpan(colWidths);
        }

        this.__colWidths__P_436_8 = colWidths;
        return colWidths;
      },

      /**
       * Computes for each column by how many pixels it must grow or shrink, taking
       * the column flex values and min/max widths into account.
       *
       * @param width {Integer} The grid width
       * @return {Integer[]} Sparse array of offsets to add to each column width. If
       *     an array entry is empty nothing should be added to the column.
       */
      _getColumnFlexOffsets: function _getColumnFlexOffsets(width) {
        var hint = this.getSizeHint();
        var diff = width - hint.width;

        if (diff == 0) {
          return {};
        } // collect all flexible children


        var colWidths = this._getColWidths();

        var flexibles = {};

        for (var i = 0, l = colWidths.length; i < l; i++) {
          var col = colWidths[i];
          var colFlex = this.getColumnFlex(i);

          if (colFlex <= 0 || col.width == col.maxWidth && diff > 0 || col.width == col.minWidth && diff < 0) {
            continue;
          }

          flexibles[i] = {
            min: col.minWidth,
            value: col.width,
            max: col.maxWidth,
            flex: colFlex
          };
        }

        return qx.ui.layout.Util.computeFlexOffsets(flexibles, width, hint.width);
      },

      /**
       * Computes for each row by how many pixels it must grow or shrink, taking
       * the row flex values and min/max heights into account.
       *
       * @param height {Integer} The grid height
       * @return {Integer[]} Sparse array of offsets to add to each row height. If
       *     an array entry is empty nothing should be added to the row.
       */
      _getRowFlexOffsets: function _getRowFlexOffsets(height) {
        var hint = this.getSizeHint();
        var diff = height - hint.height;

        if (diff == 0) {
          return {};
        } // collect all flexible children


        var rowHeights = this._getRowHeights();

        var flexibles = {};

        for (var i = 0, l = rowHeights.length; i < l; i++) {
          var row = rowHeights[i];
          var rowFlex = this.getRowFlex(i);

          if (rowFlex <= 0 || row.height == row.maxHeight && diff > 0 || row.height == row.minHeight && diff < 0) {
            continue;
          }

          flexibles[i] = {
            min: row.minHeight,
            value: row.height,
            max: row.maxHeight,
            flex: rowFlex
          };
        }

        return qx.ui.layout.Util.computeFlexOffsets(flexibles, height, hint.height);
      },

      /**
       * Returns the internal private __colSpans array in order
       * have a protected getter which can be used other methods
       * to make them overridable
       *
       * @return {Array} the __colSpans array
       */
      _getColSpans: function _getColSpans() {
        return this.__colSpans__P_436_3;
      },
      // overridden
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        if (this._invalidChildrenCache) {
          this.__buildGrid__P_436_9();
        }

        var Util = qx.ui.layout.Util;
        var hSpacing = this.getSpacingX();
        var vSpacing = this.getSpacingY(); // calculate column widths

        var prefWidths = this._getColWidths();

        var colStretchOffsets = this._getColumnFlexOffsets(availWidth);

        var colWidths = [];
        var maxColIndex = this.__maxColIndex__P_436_6;
        var maxRowIndex = this.__maxRowIndex__P_436_5;
        var offset;

        for (var col = 0; col <= maxColIndex; col++) {
          offset = colStretchOffsets[col] ? colStretchOffsets[col].offset : 0;
          colWidths[col] = prefWidths[col].width + offset;
        } // calculate row heights


        var prefHeights = this._getRowHeights();

        var rowStretchOffsets = this._getRowFlexOffsets(availHeight);

        var rowHeights = [];

        for (var row = 0; row <= maxRowIndex; row++) {
          offset = rowStretchOffsets[row] ? rowStretchOffsets[row].offset : 0;
          rowHeights[row] = prefHeights[row].height + offset;
        } // do the layout


        var left = 0;

        for (var col = 0; col <= maxColIndex; col++) {
          var top = 0;

          for (var row = 0; row <= maxRowIndex; row++) {
            var widget = this.__grid__P_436_2[row][col]; // ignore empty cells

            if (!widget) {
              top += rowHeights[row] + vSpacing;
              continue;
            }

            var widgetProps = widget.getLayoutProperties(); // ignore cells, which have cell spanning but are not the origin
            // of the widget

            if (widgetProps.row !== row || widgetProps.column !== col) {
              top += rowHeights[row] + vSpacing;
              continue;
            } // compute sizes width including cell spanning


            var spanWidth = hSpacing * (widgetProps.colSpan - 1);

            for (var i = 0; i < widgetProps.colSpan; i++) {
              spanWidth += colWidths[col + i];
            }

            var spanHeight = vSpacing * (widgetProps.rowSpan - 1);

            for (var i = 0; i < widgetProps.rowSpan; i++) {
              spanHeight += rowHeights[row + i];
            }

            var cellHint = widget.getSizeHint();
            var marginTop = widget.getMarginTop();
            var marginLeft = widget.getMarginLeft();
            var marginBottom = widget.getMarginBottom();
            var marginRight = widget.getMarginRight();
            var cellWidth = Math.max(cellHint.minWidth, Math.min(spanWidth - marginLeft - marginRight, cellHint.maxWidth));
            var cellHeight = Math.max(cellHint.minHeight, Math.min(spanHeight - marginTop - marginBottom, cellHint.maxHeight));
            var cellAlign = this.getCellAlign(row, col);
            var cellLeft = left + Util.computeHorizontalAlignOffset(cellAlign.hAlign, cellWidth, spanWidth, marginLeft, marginRight);
            var cellTop = top + Util.computeVerticalAlignOffset(cellAlign.vAlign, cellHeight, spanHeight, marginTop, marginBottom);
            widget.renderLayout(cellLeft + padding.left, cellTop + padding.top, cellWidth, cellHeight);
            top += rowHeights[row] + vSpacing;
          }

          left += colWidths[col] + hSpacing;
        }
      },
      // overridden
      invalidateLayoutCache: function invalidateLayoutCache() {
        qx.ui.layout.Grid.prototype.invalidateLayoutCache.base.call(this);
        this.__colWidths__P_436_8 = null;
        this.__rowHeights__P_436_7 = null;
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        if (this._invalidChildrenCache) {
          this.__buildGrid__P_436_9();
        } // calculate col widths


        var colWidths = this._getColWidths();

        var minWidth = 0,
            width = 0;

        for (var i = 0, l = colWidths.length; i < l; i++) {
          var col = colWidths[i];

          if (this.getColumnFlex(i) > 0) {
            minWidth += col.minWidth;
          } else {
            minWidth += col.width;
          }

          width += col.width;
        } // calculate row heights


        var rowHeights = this._getRowHeights();

        var minHeight = 0,
            height = 0;

        for (var i = 0, l = rowHeights.length; i < l; i++) {
          var row = rowHeights[i];

          if (this.getRowFlex(i) > 0) {
            minHeight += row.minHeight;
          } else {
            minHeight += row.height;
          }

          height += row.height;
        }

        var spacingX = this.getSpacingX() * (colWidths.length - 1);
        var spacingY = this.getSpacingY() * (rowHeights.length - 1);
        var hint = {
          minWidth: minWidth + spacingX,
          width: width + spacingX,
          minHeight: minHeight + spacingY,
          height: height + spacingY
        };
        return hint;
      }
    },

    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__grid__P_436_2 = this.__rowData__P_436_0 = this.__colData__P_436_1 = this.__colSpans__P_436_3 = this.__rowSpans__P_436_4 = this.__colWidths__P_436_8 = this.__rowHeights__P_436_7 = null;
    }
  });
  qx.ui.layout.Grid.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.scroll.AbstractScrollArea": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Container, which allows vertical and horizontal scrolling if the contents is
   * larger than the container.
   *
   * Note that this class can only have one child widget. This container has a
   * fixed layout, which cannot be changed.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // create scroll container
   *   var scroll = new qx.ui.container.Scroll().set({
   *     width: 300,
   *     height: 200
   *   });
   *
   *   // add a widget which is larger than the container
   *   scroll.add(new qx.ui.core.Widget().set({
   *     width: 600,
   *     minWidth: 600,
   *     height: 400,
   *     minHeight: 400
   *   }));
   *
   *   this.getRoot().add(scroll);
   * </pre>
   *
   * This example creates a scroll container and adds a widget, which is larger
   * than the container. This will cause the container to display vertical
   * and horizontal toolbars.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/scroll.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.container.Scroll", {
    extend: qx.ui.core.scroll.AbstractScrollArea,
    include: [qx.ui.core.MContentPadding],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param content {qx.ui.core.LayoutItem?null} The content widget of the scroll
     *    container.
     */
    construct: function construct(content) {
      qx.ui.core.scroll.AbstractScrollArea.constructor.call(this);

      if (content) {
        this.add(content);
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Sets the content of the scroll container. Scroll containers
       * may only have one child, so it always replaces the current
       * child with the given one.
       *
       * @param widget {qx.ui.core.Widget} Widget to insert
       */
      add: function add(widget) {
        this.getChildControl("pane").add(widget);
      },

      /**
       * Returns the content of the scroll area.
       *
       * @param widget {qx.ui.core.Widget} Widget to remove
       */
      remove: function remove(widget) {
        this.getChildControl("pane").remove(widget);
      },

      /**
       * Returns the content of the scroll container.
       *
       * Scroll containers may only have one child. This
       * method returns an array containing the child or an empty array.
       *
       * @return {Object[]} The child array
       */
      getChildren: function getChildren() {
        return this.getChildControl("pane").getChildren();
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getChildControl("pane");
      }
    }
  });
  qx.ui.container.Scroll.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * All widget used as scrollbars must implement this interface.
   */
  qx.Interface.define("qx.ui.core.scroll.IScrollBar", {
    events: {
      /** Fired if the user scroll */
      "scroll": "qx.event.type.Data",

      /** Fired as soon as the scroll animation ended. */
      "scrollAnimationEnd": 'qx.event.type.Event'
    },
    properties: {
      /**
       * The scroll bar orientation
       */
      orientation: {},

      /**
       * The maximum value (difference between available size and
       * content size).
       */
      maximum: {},

      /**
       * Position of the scrollbar (which means the scroll left/top of the
       * attached area's pane)
       *
       * Strictly validates according to {@link #maximum}.
       * Does not apply any correction to the incoming value. If you depend
       * on this, please use {@link #scrollTo} instead.
       */
      position: {},

      /**
       * Factor to apply to the width/height of the knob in relation
       * to the dimension of the underlying area.
       */
      knobFactor: {}
    },
    members: {
      /**
       * Scrolls to the given position.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param position {Integer} Scroll to this position. Must be greater zero.
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollTo: function scrollTo(position, duration) {
        this.assertNumber(position);
      },

      /**
       * Scrolls by the given offset.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param offset {Integer} Scroll by this offset
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollBy: function scrollBy(offset, duration) {
        this.assertNumber(offset);
      },

      /**
       * Scrolls by the given number of steps.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param steps {Integer} Number of steps
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollBySteps: function scrollBySteps(steps, duration) {
        this.assertNumber(steps);
      }
    }
  });
  qx.ui.core.scroll.IScrollBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.scroll.IScrollBar": {
        "require": true
      },
      "qx.ui.core.scroll.ScrollSlider": {},
      "qx.ui.form.RepeatButton": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.layout.VBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The scroll bar widget, is a special slider, which is used in qooxdoo instead
   * of the native browser scroll bars.
   *
   * Scroll bars are used by the {@link qx.ui.container.Scroll} container. Usually
   * a scroll bar is not used directly.
   *
   * @childControl slider {qx.ui.core.scroll.ScrollSlider} scroll slider component
   * @childControl button-begin {qx.ui.form.RepeatButton} button to scroll to top
   * @childControl button-end {qx.ui.form.RepeatButton} button to scroll to bottom
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var scrollBar = new qx.ui.core.scroll.ScrollBar("horizontal");
   *   scrollBar.set({
   *     maximum: 500
   *   })
   *   this.getRoot().add(scrollBar);
   * </pre>
   *
   * This example creates a horizontal scroll bar with a maximum value of 500.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/scrollbar.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.core.scroll.ScrollBar", {
    extend: qx.ui.core.Widget,
    implement: qx.ui.core.scroll.IScrollBar,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param orientation {String?"horizontal"} The initial scroll bar orientation
     */
    construct: function construct(orientation) {
      qx.ui.core.Widget.constructor.call(this); // Create child controls

      this._createChildControl("button-begin");

      this._createChildControl("slider").addListener("resize", this._onResizeSlider, this);

      this._createChildControl("button-end"); // Configure orientation


      if (orientation != null) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      } // prevent drag & drop on scrolling


      this.addListener("track", function (e) {
        e.stopPropagation();
      }, this);
    },
    events: {
      /** Change event for the value. */
      "scrollAnimationEnd": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "scrollbar"
      },

      /**
       * The scroll bar orientation
       */
      orientation: {
        check: ["horizontal", "vertical"],
        init: "horizontal",
        apply: "_applyOrientation"
      },

      /**
       * The maximum value (difference between available size and
       * content size).
       */
      maximum: {
        check: "PositiveInteger",
        apply: "_applyMaximum",
        init: 100
      },

      /**
       * Position of the scrollbar (which means the scroll left/top of the
       * attached area's pane)
       *
       * Strictly validates according to {@link #maximum}.
       * Does not apply any correction to the incoming value. If you depend
       * on this, please use {@link #scrollTo} instead.
       */
      position: {
        check: "qx.lang.Type.isNumber(value)&&value>=0&&value<=this.getMaximum()",
        init: 0,
        apply: "_applyPosition",
        event: "scroll"
      },

      /**
       * Step size for each tap on the up/down or left/right buttons.
       */
      singleStep: {
        check: "Integer",
        init: 20
      },

      /**
       * The amount to increment on each event. Typically corresponds
       * to the user pressing <code>PageUp</code> or <code>PageDown</code>.
       */
      pageStep: {
        check: "Integer",
        init: 10,
        apply: "_applyPageStep"
      },

      /**
       * Factor to apply to the width/height of the knob in relation
       * to the dimension of the underlying area.
       */
      knobFactor: {
        check: "PositiveNumber",
        apply: "_applyKnobFactor",
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __offset__P_396_0: 2,
      __originalMinSize__P_396_1: 0,
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var hint = qx.ui.core.scroll.ScrollBar.prototype._computeSizeHint.base.call(this);

        if (this.getOrientation() === "horizontal") {
          this.__originalMinSize__P_396_1 = hint.minWidth;
          hint.minWidth = 0;
        } else {
          this.__originalMinSize__P_396_1 = hint.minHeight;
          hint.minHeight = 0;
        }

        return hint;
      },
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        var changes = qx.ui.core.scroll.ScrollBar.prototype.renderLayout.base.call(this, left, top, width, height);
        var horizontal = this.getOrientation() === "horizontal";

        if (this.__originalMinSize__P_396_1 >= (horizontal ? width : height)) {
          this.getChildControl("button-begin").setVisibility("hidden");
          this.getChildControl("button-end").setVisibility("hidden");
        } else {
          this.getChildControl("button-begin").setVisibility("visible");
          this.getChildControl("button-end").setVisibility("visible");
        }

        return changes;
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "slider":
            control = new qx.ui.core.scroll.ScrollSlider();
            control.setPageStep(100);
            control.setFocusable(false);
            control.addListener("changeValue", this._onChangeSliderValue, this);
            control.addListener("slideAnimationEnd", this._onSlideAnimationEnd, this);

            this._add(control, {
              flex: 1
            });

            break;

          case "button-begin":
            // Top/Left Button
            control = new qx.ui.form.RepeatButton();
            control.setFocusable(false);
            control.addListener("execute", this._onExecuteBegin, this);

            this._add(control);

            break;

          case "button-end":
            // Bottom/Right Button
            control = new qx.ui.form.RepeatButton();
            control.setFocusable(false);
            control.addListener("execute", this._onExecuteEnd, this);

            this._add(control);

            break;
        }

        return control || qx.ui.core.scroll.ScrollBar.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyMaximum: function _applyMaximum(value) {
        this.getChildControl("slider").setMaximum(value);
      },
      // property apply
      _applyPosition: function _applyPosition(value) {
        this.getChildControl("slider").setValue(value);
      },
      // property apply
      _applyKnobFactor: function _applyKnobFactor(value) {
        this.getChildControl("slider").setKnobFactor(value);
      },
      // property apply
      _applyPageStep: function _applyPageStep(value) {
        this.getChildControl("slider").setPageStep(value);
      },
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        // Dispose old layout
        var oldLayout = this._getLayout();

        if (oldLayout) {
          oldLayout.dispose();
        } // Reconfigure


        if (value === "horizontal") {
          this._setLayout(new qx.ui.layout.HBox());

          this.setAllowStretchX(true);
          this.setAllowStretchY(false);
          this.replaceState("vertical", "horizontal");
          this.getChildControl("button-begin").replaceState("up", "left");
          this.getChildControl("button-end").replaceState("down", "right");
        } else {
          this._setLayout(new qx.ui.layout.VBox());

          this.setAllowStretchX(false);
          this.setAllowStretchY(true);
          this.replaceState("horizontal", "vertical");
          this.getChildControl("button-begin").replaceState("left", "up");
          this.getChildControl("button-end").replaceState("right", "down");
        } // Sync slider orientation


        this.getChildControl("slider").setOrientation(value);
      },

      /*
      ---------------------------------------------------------------------------
        METHOD REDIRECTION TO SLIDER
      ---------------------------------------------------------------------------
      */

      /**
       * Scrolls to the given position.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param position {Integer} Scroll to this position. Must be greater zero.
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollTo: function scrollTo(position, duration) {
        this.getChildControl("slider").slideTo(position, duration);
      },

      /**
       * Scrolls by the given offset.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param offset {Integer} Scroll by this offset
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollBy: function scrollBy(offset, duration) {
        this.getChildControl("slider").slideBy(offset, duration);
      },

      /**
       * Scrolls by the given number of steps.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param steps {Integer} Number of steps
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      scrollBySteps: function scrollBySteps(steps, duration) {
        var size = this.getSingleStep();
        this.getChildControl("slider").slideBy(steps * size, duration);
      },

      /**
       * Updates the position property considering the minimum and maximum values.
       * @param position {Number} The new position.
       */
      updatePosition: function updatePosition(position) {
        this.getChildControl("slider").updatePosition(position);
      },

      /**
       * If a scroll animation is running, it will be stopped.
       */
      stopScrollAnimation: function stopScrollAnimation() {
        this.getChildControl("slider").stopSlideAnimation();
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENER
      ---------------------------------------------------------------------------
      */

      /**
       * Executed when the up/left button is executed (pressed)
       *
       * @param e {qx.event.type.Event} Execute event of the button
       */
      _onExecuteBegin: function _onExecuteBegin(e) {
        this.scrollBy(-this.getSingleStep(), 50);
      },

      /**
       * Executed when the down/right button is executed (pressed)
       *
       * @param e {qx.event.type.Event} Execute event of the button
       */
      _onExecuteEnd: function _onExecuteEnd(e) {
        this.scrollBy(this.getSingleStep(), 50);
      },

      /**
       * Change listener for slider animation end.
       */
      _onSlideAnimationEnd: function _onSlideAnimationEnd() {
        this.fireEvent("scrollAnimationEnd");
      },

      /**
       * Change listener for slider value changes.
       *
       * @param e {qx.event.type.Data} The change event object
       */
      _onChangeSliderValue: function _onChangeSliderValue(e) {
        this.setPosition(e.getData());
      },

      /**
       * Hide the knob of the slider if the slidebar is too small or show it
       * otherwise.
       *
       * @param e {qx.event.type.Data} event object
       */
      _onResizeSlider: function _onResizeSlider(e) {
        var knob = this.getChildControl("slider").getChildControl("knob");
        var knobHint = knob.getSizeHint();
        var hideKnob = false;
        var sliderSize = this.getChildControl("slider").getInnerSize();

        if (this.getOrientation() == "vertical") {
          if (sliderSize.height < knobHint.minHeight + this.__offset__P_396_0) {
            hideKnob = true;
          }
        } else {
          if (sliderSize.width < knobHint.minWidth + this.__offset__P_396_0) {
            hideKnob = true;
          }
        }

        if (hideKnob) {
          knob.exclude();
        } else {
          knob.show();
        }
      }
    }
  });
  qx.ui.core.scroll.ScrollBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which use a numeric value as their
   * primary data type like a spinner.
   */
  qx.Interface.define("qx.ui.form.INumberForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {Number|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {Number|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.INumberForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all widgets which deal with ranges. The spinner is a good
   * example for a range using widget.
   */
  qx.Interface.define("qx.ui.form.IRange", {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        MINIMUM PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Set the minimum value of the range.
       *
       * @param min {Number} The minimum.
       */
      setMinimum: function setMinimum(min) {
        return arguments.length == 1;
      },

      /**
       * Return the current set minimum of the range.
       *
       * @return {Number} The current set minimum.
       */
      getMinimum: function getMinimum() {},

      /*
      ---------------------------------------------------------------------------
        MAXIMUM PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Set the maximum value of the range.
       *
       * @param max {Number} The maximum.
       */
      setMaximum: function setMaximum(max) {
        return arguments.length == 1;
      },

      /**
       * Return the current set maximum of the range.
       *
       * @return {Number} The current set maximum.
       */
      getMaximum: function getMaximum() {},

      /*
      ---------------------------------------------------------------------------
        SINGLESTEP PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the value for single steps in the range.
       *
       * @param step {Number} The value of the step.
       */
      setSingleStep: function setSingleStep(step) {
        return arguments.length == 1;
      },

      /**
       * Returns the value which will be stepped in a single step in the range.
       *
       * @return {Number} The current value for single steps.
       */
      getSingleStep: function getSingleStep() {},

      /*
      ---------------------------------------------------------------------------
        PAGESTEP PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the value for page steps in the range.
       *
       * @param step {Number} The value of the step.
       */
      setPageStep: function setPageStep(step) {
        return arguments.length == 1;
      },

      /**
       * Returns the value which will be stepped in a page step in the range.
       *
       * @return {Number} The current value for page steps.
       */
      getPageStep: function getPageStep() {}
    }
  });
  qx.ui.form.IRange.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.locale.Manager": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Mixin handling the valid and required properties for the form widgets.
   */
  qx.Mixin.define("qx.ui.form.MForm", {
    construct: function construct() {
      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this.__onChangeLocale__P_416_0, this);
      }
    },
    properties: {
      /**
       * Flag signaling if a widget is valid. If a widget is invalid, an invalid
       * state will be set.
       */
      valid: {
        check: "Boolean",
        init: true,
        apply: "_applyValid",
        event: "changeValid"
      },

      /**
       * Flag signaling if a widget is required.
       */
      required: {
        check: "Boolean",
        init: false,
        event: "changeRequired"
      },

      /**
       * Message which is shown in an invalid tooltip.
       */
      invalidMessage: {
        check: "String",
        init: "",
        event: "changeInvalidMessage"
      },

      /**
       * Message which is shown in an invalid tooltip if the {@link #required} is
       * set to true.
       */
      requiredInvalidMessage: {
        check: "String",
        nullable: true,
        event: "changeInvalidMessage"
      }
    },
    members: {
      // apply method
      _applyValid: function _applyValid(value, old) {
        value ? this.removeState("invalid") : this.addState("invalid");
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      __onChangeLocale__P_416_0: function __onChangeLocale__P_416_0(e) {
        // invalid message
        var invalidMessage = this.getInvalidMessage();

        if (invalidMessage && invalidMessage.translate) {
          this.setInvalidMessage(invalidMessage.translate());
        } // required invalid message


        var requiredInvalidMessage = this.getRequiredInvalidMessage();

        if (requiredInvalidMessage && requiredInvalidMessage.translate) {
          this.setRequiredInvalidMessage(requiredInvalidMessage.translate());
        }
      }
    },
    destruct: function destruct() {
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this.__onChangeLocale__P_416_0, this);
      }
    }
  });
  qx.ui.form.MForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.INumberForm": {
        "require": true
      },
      "qx.ui.form.IRange": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.layout.Canvas": {
        "construct": true
      },
      "qx.theme.manager.Decoration": {},
      "qx.bom.element.Location": {},
      "qx.event.Timer": {},
      "qx.bom.AnimationFrame": {},
      "qx.event.type.Data": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The Slider widget provides a vertical or horizontal slider.
   *
   * The Slider is the classic widget for controlling a bounded value.
   * It lets the user move a slider handle along a horizontal or vertical
   * groove and translates the handle's position into an integer value
   * within the defined range.
   *
   * The Slider has very few of its own functions.
   * The most useful functions are slideTo() to set the slider directly to some
   * value; setSingleStep(), setPageStep() to set the steps; and setMinimum()
   * and setMaximum() to define the range of the slider.
   *
   * A slider accepts focus on Tab and provides both a mouse wheel and
   * a keyboard interface. The keyboard interface is the following:
   *
   * * Left/Right move a horizontal slider by one single step.
   * * Up/Down move a vertical slider by one single step.
   * * PageUp moves up one page.
   * * PageDown moves down one page.
   * * Home moves to the start (minimum).
   * * End moves to the end (maximum).
   *
   * Here are the main properties of the class:
   *
   * # <code>value</code>: The bounded integer that {@link qx.ui.form.INumberForm}
   * maintains.
   * # <code>minimum</code>: The lowest possible value.
   * # <code>maximum</code>: The highest possible value.
   * # <code>singleStep</code>: The smaller of two natural steps that an abstract
   * sliders provides and typically corresponds to the user pressing an arrow key.
   * # <code>pageStep</code>: The larger of two natural steps that an abstract
   * slider provides and typically corresponds to the user pressing PageUp or
   * PageDown.
   *
   * @childControl knob {qx.ui.core.Widget} knob to set the value of the slider
   */
  qx.Class.define("qx.ui.form.Slider", {
    extend: qx.ui.core.Widget,
    implement: [qx.ui.form.IForm, qx.ui.form.INumberForm, qx.ui.form.IRange],
    include: [qx.ui.form.MForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param orientation {String?"horizontal"} Configure the
     * {@link #orientation} property
     */
    construct: function construct(orientation) {
      qx.ui.core.Widget.constructor.call(this); // Force canvas layout

      this._setLayout(new qx.ui.layout.Canvas()); // Add listeners


      this.addListener("keypress", this._onKeyPress);
      this.addListener("roll", this._onRoll);
      this.addListener("pointerdown", this._onPointerDown);
      this.addListener("pointerup", this._onPointerUp);
      this.addListener("losecapture", this._onPointerUp);
      this.addListener("resize", this._onUpdate); // Stop events

      this.addListener("contextmenu", this._onStopEvent);
      this.addListener("tap", this._onStopEvent);
      this.addListener("dbltap", this._onStopEvent); // Initialize orientation

      if (orientation != null) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Change event for the value.
       */
      changeValue: 'qx.event.type.Data',

      /** Fired as soon as the slide animation ended. */
      slideAnimationEnd: 'qx.event.type.Event'
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "slider"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /** Whether the slider is horizontal or vertical. */
      orientation: {
        check: ["horizontal", "vertical"],
        init: "horizontal",
        apply: "_applyOrientation"
      },

      /**
       * The current slider value.
       *
       * Strictly validates according to {@link #minimum} and {@link #maximum}.
       * Do not apply any value correction to the incoming value. If you depend
       * on this, please use {@link #slideTo} instead.
       */
      value: {
        check: "typeof value==='number'&&value>=this.getMinimum()&&value<=this.getMaximum()",
        init: 0,
        apply: "_applyValue",
        nullable: true
      },

      /**
       * The minimum slider value (may be negative). This value must be smaller
       * than {@link #maximum}.
       */
      minimum: {
        check: "Integer",
        init: 0,
        apply: "_applyMinimum",
        event: "changeMinimum"
      },

      /**
       * The maximum slider value (may be negative). This value must be larger
       * than {@link #minimum}.
       */
      maximum: {
        check: "Integer",
        init: 100,
        apply: "_applyMaximum",
        event: "changeMaximum"
      },

      /**
       * The amount to increment on each event. Typically corresponds
       * to the user pressing an arrow key.
       */
      singleStep: {
        check: "Integer",
        init: 1
      },

      /**
       * The amount to increment on each event. Typically corresponds
       * to the user pressing <code>PageUp</code> or <code>PageDown</code>.
       */
      pageStep: {
        check: "Integer",
        init: 10
      },

      /**
       * Factor to apply to the width/height of the knob in relation
       * to the dimension of the underlying area.
       */
      knobFactor: {
        check: "Number",
        apply: "_applyKnobFactor",
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __sliderLocation__P_423_0: null,
      __knobLocation__P_423_1: null,
      __knobSize__P_423_2: null,
      __dragMode__P_423_3: null,
      __dragOffset__P_423_4: null,
      __trackingMode__P_423_5: null,
      __trackingDirection__P_423_6: null,
      __trackingEnd__P_423_7: null,
      __timer__P_423_8: null,
      // event delay stuff during drag
      __dragTimer__P_423_9: null,
      __lastValueEvent__P_423_10: null,
      __dragValue__P_423_11: null,
      __scrollAnimationframe__P_423_12: null,
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        invalid: true
      },
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        qx.ui.form.Slider.prototype.renderLayout.base.call(this, left, top, width, height); // make sure the layout engine does not override the knob position

        this._updateKnobPosition();
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "knob":
            control = new qx.ui.core.Widget();
            control.addListener("resize", this._onUpdate, this);
            control.addListener("pointerover", this._onPointerOver);
            control.addListener("pointerout", this._onPointerOut);

            this._add(control);

            break;
        }

        return control || qx.ui.form.Slider.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for pointerover events at the knob child control.
       *
       * Adds the 'hovered' state
       *
       * @param e {qx.event.type.Pointer} Incoming pointer event
       */
      _onPointerOver: function _onPointerOver(e) {
        this.addState("hovered");
      },

      /**
       * Event handler for pointerout events at the knob child control.
       *
       * Removes the 'hovered' state
       *
       * @param e {qx.event.type.Pointer} Incoming pointer event
       */
      _onPointerOut: function _onPointerOut(e) {
        this.removeState("hovered");
      },

      /**
       * Listener of roll event
       *
       * @param e {qx.event.type.Roll} Incoming event object
       */
      _onRoll: function _onRoll(e) {
        // only wheel
        if (e.getPointerType() != "wheel") {
          return;
        }

        var axis = this.getOrientation() === "horizontal" ? "x" : "y";
        var delta = e.getDelta()[axis];
        var direction = delta > 0 ? 1 : delta < 0 ? -1 : 0;
        this.slideBy(direction * this.getSingleStep());
        e.stop();
      },

      /**
       * Event handler for keypress events.
       *
       * Adds support for arrow keys, page up, page down, home and end keys.
       *
       * @param e {qx.event.type.KeySequence} Incoming keypress event
       */
      _onKeyPress: function _onKeyPress(e) {
        var isHorizontal = this.getOrientation() === "horizontal";
        var backward = isHorizontal ? "Left" : "Up";
        var forward = isHorizontal ? "Right" : "Down";

        switch (e.getKeyIdentifier()) {
          case forward:
            this.slideForward();
            break;

          case backward:
            this.slideBack();
            break;

          case "PageDown":
            this.slidePageForward(100);
            break;

          case "PageUp":
            this.slidePageBack(100);
            break;

          case "Home":
            this.slideToBegin(200);
            break;

          case "End":
            this.slideToEnd(200);
            break;

          default:
            return;
        } // Stop processed events


        e.stop();
      },

      /**
       * Listener of pointerdown event. Initializes drag or tracking mode.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onPointerDown: function _onPointerDown(e) {
        // this can happen if the user releases the button while dragging outside
        // of the browser viewport
        if (this.__dragMode__P_423_3) {
          return;
        }

        var isHorizontal = this.__isHorizontal__P_423_13;
        var knob = this.getChildControl("knob");
        var locationProperty = isHorizontal ? "left" : "top";
        var cursorLocation = isHorizontal ? e.getDocumentLeft() : e.getDocumentTop();
        var decorator = this.getDecorator();
        decorator = qx.theme.manager.Decoration.getInstance().resolve(decorator);

        if (isHorizontal) {
          var decoratorPadding = decorator ? decorator.getInsets().left : 0;
          var padding = (this.getPaddingLeft() || 0) + decoratorPadding;
        } else {
          var decoratorPadding = decorator ? decorator.getInsets().top : 0;
          var padding = (this.getPaddingTop() || 0) + decoratorPadding;
        }

        var sliderLocation = this.__sliderLocation__P_423_0 = qx.bom.element.Location.get(this.getContentElement().getDomElement())[locationProperty];
        sliderLocation += padding;
        var knobLocation = this.__knobLocation__P_423_1 = qx.bom.element.Location.get(knob.getContentElement().getDomElement())[locationProperty];

        if (e.getTarget() === knob) {
          // Switch into drag mode
          this.__dragMode__P_423_3 = true;

          if (!this.__dragTimer__P_423_9) {
            // create a timer to fire delayed dragging events if dragging stops.
            this.__dragTimer__P_423_9 = new qx.event.Timer(100);

            this.__dragTimer__P_423_9.addListener("interval", this._fireValue, this);
          }

          this.__dragTimer__P_423_9.start(); // Compute dragOffset (includes both: inner position of the widget and
          // cursor position on knob)


          this.__dragOffset__P_423_4 = cursorLocation + sliderLocation - knobLocation; // add state

          knob.addState("pressed");
        } else {
          // Switch into tracking mode
          this.__trackingMode__P_423_5 = true; // Detect tracking direction

          this.__trackingDirection__P_423_6 = cursorLocation <= knobLocation ? -1 : 1; // Compute end value

          this.__computeTrackingEnd__P_423_14(e); // Directly call interval method once


          this._onInterval(); // Initialize timer (when needed)


          if (!this.__timer__P_423_8) {
            this.__timer__P_423_8 = new qx.event.Timer(100);

            this.__timer__P_423_8.addListener("interval", this._onInterval, this);
          } // Start timer


          this.__timer__P_423_8.start();
        } // Register move listener


        this.addListener("pointermove", this._onPointerMove); // Activate capturing

        this.capture(); // Stop event

        e.stopPropagation();
      },

      /**
       * Listener of pointerup event. Used for cleanup of previously
       * initialized modes.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onPointerUp: function _onPointerUp(e) {
        if (this.__dragMode__P_423_3) {
          // Release capture mode
          this.releaseCapture(); // Cleanup status flags

          delete this.__dragMode__P_423_3; // as we come out of drag mode, make
          // sure content gets synced

          this.__dragTimer__P_423_9.stop();

          this._fireValue();

          delete this.__dragOffset__P_423_4; // remove state

          this.getChildControl("knob").removeState("pressed"); // it's necessary to check whether the cursor is over the knob widget to be able to
          // to decide whether to remove the 'hovered' state.

          if (e.getType() === "pointerup") {
            var deltaSlider;
            var deltaPosition;
            var positionSlider;

            if (this.__isHorizontal__P_423_13) {
              deltaSlider = e.getDocumentLeft() - (this._valueToPosition(this.getValue()) + this.__sliderLocation__P_423_0);
              positionSlider = qx.bom.element.Location.get(this.getContentElement().getDomElement())["top"];
              deltaPosition = e.getDocumentTop() - (positionSlider + this.getChildControl("knob").getBounds().top);
            } else {
              deltaSlider = e.getDocumentTop() - (this._valueToPosition(this.getValue()) + this.__sliderLocation__P_423_0);
              positionSlider = qx.bom.element.Location.get(this.getContentElement().getDomElement())["left"];
              deltaPosition = e.getDocumentLeft() - (positionSlider + this.getChildControl("knob").getBounds().left);
            }

            if (deltaPosition < 0 || deltaPosition > this.__knobSize__P_423_2 || deltaSlider < 0 || deltaSlider > this.__knobSize__P_423_2) {
              this.getChildControl("knob").removeState("hovered");
            }
          }
        } else if (this.__trackingMode__P_423_5) {
          // Stop timer interval
          this.__timer__P_423_8.stop(); // Release capture mode


          this.releaseCapture(); // Cleanup status flags

          delete this.__trackingMode__P_423_5;
          delete this.__trackingDirection__P_423_6;
          delete this.__trackingEnd__P_423_7;
        } // Remove move listener again


        this.removeListener("pointermove", this._onPointerMove); // Stop event

        if (e.getType() === "pointerup") {
          e.stopPropagation();
        }
      },

      /**
       * Listener of pointermove event for the knob. Only used in drag mode.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onPointerMove: function _onPointerMove(e) {
        if (this.__dragMode__P_423_3) {
          var dragStop = this.__isHorizontal__P_423_13 ? e.getDocumentLeft() : e.getDocumentTop();
          var position = dragStop - this.__dragOffset__P_423_4;
          this.slideTo(this._positionToValue(position));
        } else if (this.__trackingMode__P_423_5) {
          // Update tracking end on pointermove
          this.__computeTrackingEnd__P_423_14(e);
        } // Stop event


        e.stopPropagation();
      },

      /**
       * Listener of interval event by the internal timer. Only used
       * in tracking sequences.
       *
       * @param e {qx.event.type.Event} Incoming event object
       */
      _onInterval: function _onInterval(e) {
        // Compute new value
        var value = this.getValue() + this.__trackingDirection__P_423_6 * this.getPageStep(); // Limit value

        if (value < this.getMinimum()) {
          value = this.getMinimum();
        } else if (value > this.getMaximum()) {
          value = this.getMaximum();
        } // Stop at tracking position (where the pointer is pressed down)


        var slideBack = this.__trackingDirection__P_423_6 == -1;

        if (slideBack && value <= this.__trackingEnd__P_423_7 || !slideBack && value >= this.__trackingEnd__P_423_7) {
          value = this.__trackingEnd__P_423_7;
        } // Finally slide to the desired position


        this.slideTo(value);
      },

      /**
       * Listener of resize event for both the slider itself and the knob.
       *
       * @param e {qx.event.type.Data} Incoming event object
       */
      _onUpdate: function _onUpdate(e) {
        // Update sliding space
        var availSize = this.getInnerSize();
        var knobSize = this.getChildControl("knob").getBounds();
        var sizeProperty = this.__isHorizontal__P_423_13 ? "width" : "height"; // Sync knob size

        this._updateKnobSize(); // Store knob size


        this.__slidingSpace__P_423_15 = availSize[sizeProperty] - knobSize[sizeProperty];
        this.__knobSize__P_423_2 = knobSize[sizeProperty]; // Update knob position (sliding space must be updated first)

        this._updateKnobPosition();
      },

      /*
      ---------------------------------------------------------------------------
        UTILS
      ---------------------------------------------------------------------------
      */

      /** @type {Boolean} Whether the slider is laid out horizontally */
      __isHorizontal__P_423_13: false,

      /**
       * @type {Integer} Available space for knob to slide on, computed on resize of
       * the widget
       */
      __slidingSpace__P_423_15: 0,

      /**
       * Computes the value where the tracking should end depending on
       * the current pointer position.
       *
       * @param e {qx.event.type.Pointer} Incoming pointer event
       */
      __computeTrackingEnd__P_423_14: function __computeTrackingEnd__P_423_14(e) {
        var isHorizontal = this.__isHorizontal__P_423_13;
        var cursorLocation = isHorizontal ? e.getDocumentLeft() : e.getDocumentTop();
        var sliderLocation = this.__sliderLocation__P_423_0;
        var knobLocation = this.__knobLocation__P_423_1;
        var knobSize = this.__knobSize__P_423_2; // Compute relative position

        var position = cursorLocation - sliderLocation;

        if (cursorLocation >= knobLocation) {
          position -= knobSize;
        } // Compute stop value


        var value = this._positionToValue(position);

        var min = this.getMinimum();
        var max = this.getMaximum();

        if (value < min) {
          value = min;
        } else if (value > max) {
          value = max;
        } else {
          var old = this.getValue();
          var step = this.getPageStep();
          var method = this.__trackingDirection__P_423_6 < 0 ? "floor" : "ceil"; // Fix to page step

          value = old + Math[method]((value - old) / step) * step;
        } // Store value when undefined, otherwise only when it follows the
        // current direction e.g. goes up or down


        if (this.__trackingEnd__P_423_7 == null || this.__trackingDirection__P_423_6 == -1 && value <= this.__trackingEnd__P_423_7 || this.__trackingDirection__P_423_6 == 1 && value >= this.__trackingEnd__P_423_7) {
          this.__trackingEnd__P_423_7 = value;
        }
      },

      /**
       * Converts the given position to a value.
       *
       * Does not respect single or page step.
       *
       * @param position {Integer} Position to use
       * @return {Integer} Resulting value (rounded)
       */
      _positionToValue: function _positionToValue(position) {
        // Reading available space
        var avail = this.__slidingSpace__P_423_15; // Protect undefined value (before initial resize) and division by zero

        if (avail == null || avail == 0) {
          return 0;
        } // Compute and limit percent


        var percent = position / avail;

        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        } // Compute range


        var range = this.getMaximum() - this.getMinimum(); // Compute value

        return this.getMinimum() + Math.round(range * percent);
      },

      /**
       * Converts the given value to a position to place
       * the knob to.
       *
       * @param value {Integer} Value to use
       * @return {Integer} Computed position (rounded)
       */
      _valueToPosition: function _valueToPosition(value) {
        // Reading available space
        var avail = this.__slidingSpace__P_423_15;

        if (avail == null) {
          return 0;
        } // Computing range


        var range = this.getMaximum() - this.getMinimum(); // Protect division by zero

        if (range == 0) {
          return 0;
        } // Translating value to distance from minimum


        var value = value - this.getMinimum(); // Compute and limit percent

        var percent = value / range;

        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        } // Compute position from available space and percent


        return Math.round(avail * percent);
      },

      /**
       * Updates the knob position following the currently configured
       * value. Useful on reflows where the dimensions of the slider
       * itself have been modified.
       *
       */
      _updateKnobPosition: function _updateKnobPosition() {
        this._setKnobPosition(this._valueToPosition(this.getValue()));
      },

      /**
       * Moves the knob to the given position.
       *
       * @param position {Integer} Any valid position (needs to be
       *   greater or equal than zero)
       */
      _setKnobPosition: function _setKnobPosition(position) {
        // Use the DOM Element to prevent unnecessary layout recalculations
        var knob = this.getChildControl("knob");
        var dec = this.getDecorator();
        dec = qx.theme.manager.Decoration.getInstance().resolve(dec);
        var content = knob.getContentElement();

        if (this.__isHorizontal__P_423_13) {
          if (dec && dec.getPadding()) {
            position += dec.getPadding().left;
          }

          position += this.getPaddingLeft() || 0;
          content.setStyle("left", position + "px", true);
        } else {
          if (dec && dec.getPadding()) {
            position += dec.getPadding().top;
          }

          position += this.getPaddingTop() || 0;
          content.setStyle("top", position + "px", true);
        }
      },

      /**
       * Reconfigures the size of the knob depending on
       * the optionally defined {@link #knobFactor}.
       *
       */
      _updateKnobSize: function _updateKnobSize() {
        // Compute knob size
        var knobFactor = this.getKnobFactor();

        if (knobFactor == null) {
          return;
        } // Ignore when not rendered yet


        var avail = this.getInnerSize();

        if (avail == null) {
          return;
        } // Read size property


        if (this.__isHorizontal__P_423_13) {
          this.getChildControl("knob").setWidth(Math.round(knobFactor * avail.width));
        } else {
          this.getChildControl("knob").setHeight(Math.round(knobFactor * avail.height));
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDE METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Slides backward to the minimum value
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slideToBegin: function slideToBegin(duration) {
        this.slideTo(this.getMinimum(), duration);
      },

      /**
       * Slides forward to the maximum value
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slideToEnd: function slideToEnd(duration) {
        this.slideTo(this.getMaximum(), duration);
      },

      /**
       * Slides forward (right or bottom depending on orientation)
       *
       */
      slideForward: function slideForward() {
        this.slideBy(this.getSingleStep());
      },

      /**
       * Slides backward (to left or top depending on orientation)
       *
       */
      slideBack: function slideBack() {
        this.slideBy(-this.getSingleStep());
      },

      /**
       * Slides a page forward (to right or bottom depending on orientation)
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slidePageForward: function slidePageForward(duration) {
        this.slideBy(this.getPageStep(), duration);
      },

      /**
       * Slides a page backward (to left or top depending on orientation)
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slidePageBack: function slidePageBack(duration) {
        this.slideBy(-this.getPageStep(), duration);
      },

      /**
       * Slides by the given offset.
       *
       * This method works with the value, not with the coordinate.
       *
       * @param offset {Integer} Offset to scroll by
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slideBy: function slideBy(offset, duration) {
        this.slideTo(this.getValue() + offset, duration);
      },

      /**
       * Slides to the given value
       *
       * This method works with the value, not with the coordinate.
       *
       * @param value {Integer} Scroll to a value between the defined
       *   minimum and maximum.
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      slideTo: function slideTo(value, duration) {
        this.stopSlideAnimation();

        if (duration) {
          this.__animateTo__P_423_16(value, duration);
        } else {
          this.updatePosition(value);
        }
      },

      /**
       * Updates the position property considering the minimum and maximum values.
       * @param value {Number} The new position.
       */
      updatePosition: function updatePosition(value) {
        this.setValue(this.__normalizeValue__P_423_17(value));
      },

      /**
       * In case a slide animation is currently running, it will be stopped.
       * If not, the method does nothing.
       */
      stopSlideAnimation: function stopSlideAnimation() {
        if (this.__scrollAnimationframe__P_423_12) {
          this.__scrollAnimationframe__P_423_12.cancelSequence();

          this.__scrollAnimationframe__P_423_12 = null;
        }
      },

      /**
       * Internal helper to normalize the given value concerning the minimum
       * and maximum value.
       * @param value {Number} The value to normalize.
       * @return {Number} The normalized value.
       */
      __normalizeValue__P_423_17: function __normalizeValue__P_423_17(value) {
        // Bring into allowed range or fix to single step grid
        if (value < this.getMinimum()) {
          value = this.getMinimum();
        } else if (value > this.getMaximum()) {
          value = this.getMaximum();
        } else {
          value = this.getMinimum() + Math.round((value - this.getMinimum()) / this.getSingleStep()) * this.getSingleStep();
        }

        return value;
      },

      /**
       * Animation helper which takes care of the animated slide.
       * @param to {Number} The target value.
       * @param duration {Number} The time in milliseconds the slide to should take.
       */
      __animateTo__P_423_16: function __animateTo__P_423_16(to, duration) {
        to = this.__normalizeValue__P_423_17(to);
        var from = this.getValue();
        this.__scrollAnimationframe__P_423_12 = new qx.bom.AnimationFrame();

        this.__scrollAnimationframe__P_423_12.on("frame", function (timePassed) {
          this.setValue(parseInt(timePassed / duration * (to - from) + from));
        }, this);

        this.__scrollAnimationframe__P_423_12.on("end", function () {
          this.setValue(to);
          this.__scrollAnimationframe__P_423_12 = null;
          this.fireEvent("slideAnimationEnd");
        }, this);

        this.__scrollAnimationframe__P_423_12.startSequence(duration);
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        var knob = this.getChildControl("knob"); // Update private flag for faster access

        this.__isHorizontal__P_423_13 = value === "horizontal"; // Toggle states and knob layout

        if (this.__isHorizontal__P_423_13) {
          this.removeState("vertical");
          knob.removeState("vertical");
          this.addState("horizontal");
          knob.addState("horizontal");
          knob.setLayoutProperties({
            top: 0,
            right: null,
            bottom: 0
          });
        } else {
          this.removeState("horizontal");
          knob.removeState("horizontal");
          this.addState("vertical");
          knob.addState("vertical");
          knob.setLayoutProperties({
            right: 0,
            bottom: null,
            left: 0
          });
        } // Sync knob position


        this._updateKnobPosition();
      },
      // property apply
      _applyKnobFactor: function _applyKnobFactor(value, old) {
        if (value != null) {
          this._updateKnobSize();
        } else {
          if (this.__isHorizontal__P_423_13) {
            this.getChildControl("knob").resetWidth();
          } else {
            this.getChildControl("knob").resetHeight();
          }
        }
      },
      // property apply
      _applyValue: function _applyValue(value, old) {
        if (value != null) {
          this._updateKnobPosition();

          if (this.__dragMode__P_423_3) {
            this.__dragValue__P_423_11 = [value, old];
          } else {
            this.fireEvent("changeValue", qx.event.type.Data, [value, old]);
          }
        } else {
          this.resetValue();
        }
      },

      /**
       * Helper for applyValue which fires the changeValue event.
       */
      _fireValue: function _fireValue() {
        if (!this.__dragValue__P_423_11) {
          return;
        }

        var tmp = this.__dragValue__P_423_11;
        this.__dragValue__P_423_11 = null;
        this.fireEvent("changeValue", qx.event.type.Data, tmp);
      },
      // property apply
      _applyMinimum: function _applyMinimum(value, old) {
        if (this.getValue() < value) {
          this.setValue(value);
        }

        this._updateKnobPosition();
      },
      // property apply
      _applyMaximum: function _applyMaximum(value, old) {
        if (this.getValue() > value) {
          this.setValue(value);
        }

        this._updateKnobPosition();
      }
    }
  });
  qx.ui.form.Slider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Slider": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Minimal modified version of the {@link qx.ui.form.Slider} to be
   * used by {@link qx.ui.core.scroll.ScrollBar}.
   *
   * @internal
   */
  qx.Class.define("qx.ui.core.scroll.ScrollSlider", {
    extend: qx.ui.form.Slider,
    // overridden
    construct: function construct(orientation) {
      qx.ui.form.Slider.constructor.call(this, orientation); // Remove roll/keypress events

      this.removeListener("keypress", this._onKeyPress);
      this.removeListener("roll", this._onRoll);
    },
    members: {
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "knob":
            control = qx.ui.core.scroll.ScrollSlider.prototype._createChildControlImpl.base.call(this, id);
            control.addListener("dblclick", function (e) {
              e.stopPropagation();
            });
        }

        return control || qx.ui.core.scroll.ScrollSlider.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden
      getSizeHint: function getSizeHint(compute) {
        // get the original size hint
        var hint = qx.ui.core.scroll.ScrollSlider.prototype.getSizeHint.base.call(this); // set the width or height to 0 depending on the orientation.
        // this is necessary to prevent the ScrollSlider to change the size
        // hint of its parent, which can cause errors on outer flex layouts
        // [BUG #3279]

        if (this.getOrientation() === "horizontal") {
          hint.width = 0;
        } else {
          hint.height = 0;
        }

        return hint;
      }
    }
  });
  qx.ui.core.scroll.ScrollSlider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which are executable in some way. This
   * could be a button for example.
   */
  qx.Interface.define("qx.ui.form.IExecutable", {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the widget is executed. Sets the "data" property of the
       * event to the object that issued the command.
       */
      "execute": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        COMMAND PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Set the command of this executable.
       *
       * @param command {qx.ui.command.Command} The command.
       */
      setCommand: function setCommand(command) {
        return arguments.length == 1;
      },

      /**
       * Return the current set command of this executable.
       *
       * @return {qx.ui.command.Command} The current set command.
       */
      getCommand: function getCommand() {},

      /**
       * Fire the "execute" event on the command.
       */
      execute: function execute() {}
    }
  });
  qx.ui.form.IExecutable.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.basic.Atom": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A Button widget which supports various states and allows it to be used
   * via the mouse, touch, pen and the keyboard.
   *
   * If the user presses the button by clicking on it, or the <code>Enter</code> or
   * <code>Space</code> keys, the button fires an {@link qx.ui.core.MExecutable#execute} event.
   *
   * If the {@link qx.ui.core.MExecutable#command} property is set, the
   * command is executed as well.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.form.Button("Hello World");
   *
   *   button.addListener("execute", function(e) {
   *     alert("Button was clicked");
   *   }, this);
   *
   *   this.getRoot().add(button);
   * </pre>
   *
   * This example creates a button with the label "Hello World" and attaches an
   * event listener to the {@link #execute} event.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/button.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.form.Button", {
    extend: qx.ui.basic.Atom,
    include: [qx.ui.core.MExecutable],
    implement: [qx.ui.form.IExecutable],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} label of the atom
     * @param icon {String?null} Icon URL of the atom
     * @param command {qx.ui.command.Command?null} Command instance to connect with
     */
    construct: function construct(label, icon, command) {
      qx.ui.basic.Atom.constructor.call(this, label, icon);

      if (command != null) {
        this.setCommand(command);
      } // Add listeners


      this.addListener("pointerover", this._onPointerOver);
      this.addListener("pointerout", this._onPointerOut);
      this.addListener("pointerdown", this._onPointerDown);
      this.addListener("pointerup", this._onPointerUp);
      this.addListener("tap", this._onTap);
      this.addListener("keydown", this._onKeyDown);
      this.addListener("keyup", this._onKeyUp); // Stop events

      this.addListener("dblclick", function (e) {
        e.stopPropagation();
      });
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "button"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        hovered: true,
        pressed: true,
        disabled: true
      },

      /*
      ---------------------------------------------------------------------------
        USER API
      ---------------------------------------------------------------------------
      */

      /**
       * Manually press the button
       */
      press: function press() {
        if (this.hasState("abandoned")) {
          return;
        }

        this.addState("pressed");
      },

      /**
       * Manually release the button
       */
      release: function release() {
        if (this.hasState("pressed")) {
          this.removeState("pressed");
        }
      },

      /**
       * Completely reset the button (remove all states)
       */
      reset: function reset() {
        this.removeState("pressed");
        this.removeState("abandoned");
        this.removeState("hovered");
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Listener method for "pointerover" event
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Mouse event
       */
      _onPointerOver: function _onPointerOver(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
          this.addState("pressed");
        }

        this.addState("hovered");
      },

      /**
       * Listener method for "pointerout" event
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" and removes "pressed" state (if "pressed" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Mouse event
       */
      _onPointerOut: function _onPointerOut(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        this.removeState("hovered");

        if (this.hasState("pressed")) {
          this.removeState("pressed");
          this.addState("abandoned");
        }
      },

      /**
       * Listener method for "pointerdown" event
       * <ul>
       * <li>Removes "abandoned" state</li>
       * <li>Adds "pressed" state</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Mouse event
       */
      _onPointerDown: function _onPointerDown(e) {
        if (!e.isLeftPressed()) {
          return;
        }

        e.stopPropagation(); // Activate capturing if the button get a pointerout while
        // the button is pressed.

        this.capture();
        this.removeState("abandoned");
        this.addState("pressed");
      },

      /**
       * Listener method for "pointerup" event
       * <ul>
       * <li>Removes "pressed" state (if set)</li>
       * <li>Removes "abandoned" state (if set)</li>
       * <li>Adds "hovered" state (if "abandoned" state is not set)</li>
       *</ul>
       *
       * @param e {qx.event.type.Pointer} Mouse event
       */
      _onPointerUp: function _onPointerUp(e) {
        this.releaseCapture(); // We must remove the states before executing the command
        // because in cases were the window lost the focus while
        // executing we get the capture phase back (mouseout).

        var hasPressed = this.hasState("pressed");
        var hasAbandoned = this.hasState("abandoned");

        if (hasPressed) {
          this.removeState("pressed");
        }

        if (hasAbandoned) {
          this.removeState("abandoned");
        }

        e.stopPropagation();
      },

      /**
       * Listener method for "tap" event which stops the propagation.
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onTap: function _onTap(e) {
        // "execute" is fired here so that the button can be dragged
        // without executing it (e.g. in a TabBar with overflow)
        this.execute();
        e.stopPropagation();
      },

      /**
       * Listener method for "keydown" event.<br/>
       * Removes "abandoned" and adds "pressed" state
       * for the keys "Enter" or "Space"
       *
       * @param e {Event} Key event
       */
      _onKeyDown: function _onKeyDown(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            this.removeState("abandoned");
            this.addState("pressed");
            e.stopPropagation();
        }
      },

      /**
       * Listener method for "keyup" event.<br/>
       * Removes "abandoned" and "pressed" state (if "pressed" state is set)
       * for the keys "Enter" or "Space"
       *
       * @param e {Event} Key event
       */
      _onKeyUp: function _onKeyUp(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            if (this.hasState("pressed")) {
              this.removeState("abandoned");
              this.removeState("pressed");
              this.execute();
              e.stopPropagation();
            }

        }
      }
    }
  });
  qx.ui.form.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Button": {
        "construct": true,
        "require": true
      },
      "qx.event.AcceleratingTimer": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The RepeatButton is a special button, which fires repeatedly {@link #execute}
   * events, while a button is pressed on the button. The initial delay
   * and the interval time can be set using the properties {@link #firstInterval}
   * and {@link #interval}. The {@link #execute} events will be fired in a shorter
   * amount of time if a button is hold, until the min {@link #minTimer}
   * is reached. The {@link #timerDecrease} property sets the amount of milliseconds
   * which will decreased after every firing.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.form.RepeatButton("Hello World");
   *
   *   button.addListener("execute", function(e) {
   *     alert("Button is executed");
   *   }, this);
   *
   *   this.getRoot.add(button);
   * </pre>
   *
   * This example creates a button with the label "Hello World" and attaches an
   * event listener to the {@link #execute} event.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/repeatbutton.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.form.RepeatButton", {
    extend: qx.ui.form.Button,

    /**
     * @param label {String} Label to use
     * @param icon {String?null} Icon to use
     */
    construct: function construct(label, icon) {
      qx.ui.form.Button.constructor.call(this, label, icon); // create the timer and add the listener

      this.__timer__P_420_0 = new qx.event.AcceleratingTimer();

      this.__timer__P_420_0.addListener("interval", this._onInterval, this);
    },
    events: {
      /**
       * This event gets dispatched with every interval. The timer gets executed
       * as long as the user holds down a button.
       */
      "execute": "qx.event.type.Event",

      /**
       * This event gets dispatched when the button is pressed.
       */
      "press": "qx.event.type.Event",

      /**
       * This event gets dispatched when the button is released.
       */
      "release": "qx.event.type.Event"
    },
    properties: {
      /**
       * Interval used after the first run of the timer. Usually a smaller value
       * than the "firstInterval" property value to get a faster reaction.
       */
      interval: {
        check: "Integer",
        init: 100
      },

      /**
       * Interval used for the first run of the timer. Usually a greater value
       * than the "interval" property value to a little delayed reaction at the first
       * time.
       */
      firstInterval: {
        check: "Integer",
        init: 500
      },

      /** This configures the minimum value for the timer interval. */
      minTimer: {
        check: "Integer",
        init: 20
      },

      /** Decrease of the timer on each interval (for the next interval) until minTimer reached. */
      timerDecrease: {
        check: "Integer",
        init: 2
      }
    },
    members: {
      __executed__P_420_1: null,
      __timer__P_420_0: null,

      /**
       * Calling this function is like a tap from the user on the
       * button with all consequences.
       * <span style='color: red'>Be sure to call the {@link #release} function.</span>
       *
       */
      press: function press() {
        // only if the button is enabled
        if (this.isEnabled()) {
          // if the state pressed must be applied (first call)
          if (!this.hasState("pressed")) {
            // start the timer
            this.__startInternalTimer__P_420_2();
          } // set the states


          this.removeState("abandoned");
          this.addState("pressed");
        }
      },

      /**
       * Calling this function is like a release from the user on the
       * button with all consequences.
       * Usually the {@link #release} function will be called before the call of
       * this function.
       *
       * @param fireExecuteEvent {Boolean?true} flag which signals, if an event should be fired
       */
      release: function release(fireExecuteEvent) {
        // only if the button is enabled
        if (!this.isEnabled()) {
          return;
        } // only if the button is pressed


        if (this.hasState("pressed")) {
          // if the button has not been executed
          if (!this.__executed__P_420_1) {
            this.execute();
          }
        } // remove button states


        this.removeState("pressed");
        this.removeState("abandoned"); // stop the repeat timer and therefore the execution

        this.__stopInternalTimer__P_420_3();
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.form.RepeatButton.prototype._applyEnabled.base.call(this, value, old);

        if (!value) {
          if (this.isCapturing()) {
            // also release capture because out event is missing on iOS
            this.releaseCapture();
          } // remove button states


          this.removeState("pressed");
          this.removeState("abandoned"); // stop the repeat timer and therefore the execution

          this.__stopInternalTimer__P_420_3();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Listener method for "pointerover" event
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onPointerOver: function _onPointerOver(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
          this.addState("pressed");

          this.__timer__P_420_0.start();
        }

        this.addState("hovered");
      },

      /**
       * Listener method for "pointerout" event
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" and removes "pressed" state (if "pressed" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onPointerOut: function _onPointerOut(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        this.removeState("hovered");

        if (this.hasState("pressed")) {
          this.removeState("pressed");
          this.addState("abandoned");

          this.__timer__P_420_0.stop();
        }
      },

      /**
       * Callback method for the "pointerdown" method.
       *
       * Sets the interval of the timer (value of firstInterval property) and
       * starts the timer. Additionally removes the state "abandoned" and adds the
       * state "pressed".
       *
       * @param e {qx.event.type.Pointer} pointerdown event
       */
      _onPointerDown: function _onPointerDown(e) {
        if (!e.isLeftPressed()) {
          return;
        } // Activate capturing if the button get a pointerout while
        // the button is pressed.


        this.capture();

        this.__startInternalTimer__P_420_2();

        e.stopPropagation();
      },

      /**
       * Callback method for the "pointerup" event.
       *
       * Handles the case that the user is releasing a button
       * before the timer interval method got executed. This way the
       * "execute" method get executed at least one time.
       *
       * @param e {qx.event.type.Pointer} pointerup event
       */
      _onPointerUp: function _onPointerUp(e) {
        this.releaseCapture();

        if (!this.hasState("abandoned")) {
          this.addState("hovered");

          if (this.hasState("pressed") && !this.__executed__P_420_1) {
            this.execute();
          }
        }

        this.__stopInternalTimer__P_420_3();

        e.stopPropagation();
      },
      // Nothing to do, 'execute' is already fired by _onPointerUp.
      _onTap: function _onTap(e) {},

      /**
       * Listener method for "keyup" event.
       *
       * Removes "abandoned" and "pressed" state (if "pressed" state is set)
       * for the keys "Enter" or "Space" and stops the internal timer
       * (same like pointer up).
       *
       * @param e {Event} Key event
       */
      _onKeyUp: function _onKeyUp(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            if (this.hasState("pressed")) {
              if (!this.__executed__P_420_1) {
                this.execute();
              }

              this.removeState("pressed");
              this.removeState("abandoned");
              e.stopPropagation();

              this.__stopInternalTimer__P_420_3();
            }

        }
      },

      /**
       * Listener method for "keydown" event.
       *
       * Removes "abandoned" and adds "pressed" state
       * for the keys "Enter" or "Space". It also starts
       * the internal timer (same like pointerdown).
       *
       * @param e {Event} Key event
       */
      _onKeyDown: function _onKeyDown(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            this.removeState("abandoned");
            this.addState("pressed");
            e.stopPropagation();

            this.__startInternalTimer__P_420_2();

        }
      },

      /**
       * Callback for the interval event.
       *
       * Stops the timer and starts it with a new interval
       * (value of the "interval" property - value of the "timerDecrease" property).
       * Dispatches the "execute" event.
       *
       * @param e {qx.event.type.Event} interval event
       */
      _onInterval: function _onInterval(e) {
        this.__executed__P_420_1 = true;
        this.fireEvent("execute");
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL TIMER
      ---------------------------------------------------------------------------
      */

      /**
       * Starts the internal timer which causes firing of execution
       * events in an interval. It also presses the button.
       *
       */
      __startInternalTimer__P_420_2: function __startInternalTimer__P_420_2() {
        this.fireEvent("press");
        this.__executed__P_420_1 = false;

        this.__timer__P_420_0.set({
          interval: this.getInterval(),
          firstInterval: this.getFirstInterval(),
          minimum: this.getMinTimer(),
          decrease: this.getTimerDecrease()
        }).start();

        this.removeState("abandoned");
        this.addState("pressed");
      },

      /**
       * Stops the internal timer and releases the button.
       *
       */
      __stopInternalTimer__P_420_3: function __stopInternalTimer__P_420_3() {
        this.fireEvent("release");

        this.__timer__P_420_0.stop();

        this.removeState("abandoned");
        this.removeState("pressed");
      }
    },

    /*
      *****************************************************************************
         DESTRUCTOR
      *****************************************************************************
      */
    destruct: function destruct() {
      this._disposeObjects("__timer__P_420_0");
    }
  });
  qx.ui.form.RepeatButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This mixin redirects all children handling methods to a child widget of the
   * including class. This is e.g. used in {@link qx.ui.window.Window} to add
   * child widgets directly to the window pane.
   *
   * The including class must implement the method <code>getChildrenContainer</code>,
   * which has to return the widget, to which the child widgets should be added.
   */
  qx.Mixin.define("qx.ui.core.MRemoteChildrenHandling", {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Forward the call with the given function name to the children container
       *
       * @param functionName {String} name of the method to forward
       * @param a1 {var?} first argument of the method to call
       * @param a2 {var?} second argument of the method to call
       * @param a3 {var?} third argument of the method to call
       * @return {var} The return value of the forward method
       */
      __forward__P_384_0: function __forward__P_384_0(functionName, a1, a2, a3) {
        var container = this.getChildrenContainer();

        if (container === this) {
          functionName = "_" + functionName;
        }

        return container[functionName](a1, a2, a3);
      },

      /**
       * Returns the children list
       *
       * @return {qx.ui.core.LayoutItem[]} The children array (Arrays are
       *   reference types, please do not modify them in-place)
       */
      getChildren: function getChildren() {
        return this.__forward__P_384_0("getChildren");
      },

      /**
       * Whether the widget contains children.
       *
       * @return {Boolean} Returns <code>true</code> when the widget has children.
       */
      hasChildren: function hasChildren() {
        return this.__forward__P_384_0("hasChildren");
      },

      /**
       * Adds a new child widget.
       *
       * The supported keys of the layout options map depend on the layout manager
       * used to position the widget. The options are documented in the class
       * documentation of each layout manager {@link qx.ui.layout}.
       *
       * @param child {qx.ui.core.LayoutItem} the item to add.
       * @param options {Map?null} Optional layout data for item.
       * @return {qx.ui.core.Widget} This object (for chaining support)
       */
      add: function add(child, options) {
        return this.__forward__P_384_0("add", child, options);
      },

      /**
       * Remove the given child item.
       *
       * @param child {qx.ui.core.LayoutItem} the item to remove
       * @return {qx.ui.core.Widget} This object (for chaining support)
       */
      remove: function remove(child) {
        return this.__forward__P_384_0("remove", child);
      },

      /**
       * Remove all children.
       * @return {Array} An array containing the removed children.
       */
      removeAll: function removeAll() {
        return this.__forward__P_384_0("removeAll");
      },

      /**
       * Returns the index position of the given item if it is
       * a child item. Otherwise it returns <code>-1</code>.
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {qx.ui.core.LayoutItem} the item to query for
       * @return {Integer} The index position or <code>-1</code> when
       *   the given item is no child of this layout.
       */
      indexOf: function indexOf(child) {
        return this.__forward__P_384_0("indexOf", child);
      },

      /**
       * Add a child at the specified index
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {qx.ui.core.LayoutItem} item to add
       * @param index {Integer} Index, at which the item will be inserted
       * @param options {Map?null} Optional layout data for item.
       */
      addAt: function addAt(child, index, options) {
        this.__forward__P_384_0("addAt", child, index, options);
      },

      /**
       * Add an item before another already inserted item
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {qx.ui.core.LayoutItem} item to add
       * @param before {qx.ui.core.LayoutItem} item before the new item will be inserted.
       * @param options {Map?null} Optional layout data for item.
       */
      addBefore: function addBefore(child, before, options) {
        this.__forward__P_384_0("addBefore", child, before, options);
      },

      /**
       * Add an item after another already inserted item
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {qx.ui.core.LayoutItem} item to add
       * @param after {qx.ui.core.LayoutItem} item, after which the new item will be inserted
       * @param options {Map?null} Optional layout data for item.
       */
      addAfter: function addAfter(child, after, options) {
        this.__forward__P_384_0("addAfter", child, after, options);
      },

      /**
       * Remove the item at the specified index.
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param index {Integer} Index of the item to remove.
       * @return {qx.ui.core.LayoutItem} The removed item
       */
      removeAt: function removeAt(index) {
        return this.__forward__P_384_0("removeAt", index);
      }
    }
  });
  qx.ui.core.MRemoteChildrenHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This mixin redirects the layout manager to a child widget of the
   * including class. This is e.g. used in {@link qx.ui.window.Window} to configure
   * the layout manager of the window pane instead of the window directly.
   *
   * The including class must implement the method <code>getChildrenContainer</code>,
   * which has to return the widget, to which the layout should be set.
   */
  qx.Mixin.define("qx.ui.core.MRemoteLayoutHandling", {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Set a layout manager for the widget. A a layout manager can only be connected
       * with one widget. Reset the connection with a previous widget first, if you
       * like to use it in another widget instead.
       *
       * @param layout {qx.ui.layout.Abstract} The new layout or
       *     <code>null</code> to reset the layout.
       */
      setLayout: function setLayout(layout) {
        this.getChildrenContainer().setLayout(layout);
      },

      /**
       * Get the widget's layout manager.
       *
       * @return {qx.ui.layout.Abstract} The widget's layout manager
       */
      getLayout: function getLayout() {
        return this.getChildrenContainer().getLayout();
      }
    }
  });
  qx.ui.core.MRemoteLayoutHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.core.MRemoteLayoutHandling": {
        "require": true
      },
      "qx.ui.form.RepeatButton": {},
      "qx.ui.container.Composite": {},
      "qx.ui.core.scroll.ScrollPane": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.layout.VBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Container, which provides scrolling in one dimension (vertical or horizontal).
   *
   * @childControl button-forward {qx.ui.form.RepeatButton} button to step forward
   * @childControl button-backward {qx.ui.form.RepeatButton} button to step backward
   * @childControl content {qx.ui.container.Composite} container to hold the content
   * @childControl scrollpane {qx.ui.core.scroll.ScrollPane} the scroll pane holds the content to enable scrolling
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // create slide bar container
   *   slideBar = new qx.ui.container.SlideBar().set({
   *     width: 300
   *   });
   *
   *   // set layout
   *   slideBar.setLayout(new qx.ui.layout.HBox());
   *
   *   // add some widgets
   *   for (var i=0; i<10; i++)
   *   {
   *     slideBar.add((new qx.ui.core.Widget()).set({
   *       backgroundColor : (i % 2 == 0) ? "red" : "blue",
   *       width : 60
   *     }));
   *   }
   *
   *   this.getRoot().add(slideBar);
   * </pre>
   *
   * This example creates a SlideBar and add some widgets with alternating
   * background colors. Since the content is larger than the container, two
   * scroll buttons at the left and the right edge are shown.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/slidebar.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.container.SlideBar", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.core.MRemoteLayoutHandling],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param orientation {String?"horizontal"} The slide bar orientation
     */
    construct: function construct(orientation) {
      qx.ui.core.Widget.constructor.call(this);
      var scrollPane = this.getChildControl("scrollpane");

      this._add(scrollPane, {
        flex: 1
      });

      if (orientation != null) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      }

      this.addListener("roll", this._onRoll, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "slidebar"
      },

      /** Orientation of the bar */
      orientation: {
        check: ["horizontal", "vertical"],
        init: "horizontal",
        apply: "_applyOrientation"
      },

      /** The number of pixels to scroll if the buttons are pressed */
      scrollStep: {
        check: "Integer",
        init: 15,
        themeable: true
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired on scroll animation end invoked by 'scroll*' methods. */
      scrollAnimationEnd: "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("content");
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "button-forward":
            control = new qx.ui.form.RepeatButton();
            control.addListener("execute", this._onExecuteForward, this);
            control.setFocusable(false);

            this._addAt(control, 2);

            break;

          case "button-backward":
            control = new qx.ui.form.RepeatButton();
            control.addListener("execute", this._onExecuteBackward, this);
            control.setFocusable(false);

            this._addAt(control, 0);

            break;

          case "content":
            control = new qx.ui.container.Composite();
            this.getChildControl("scrollpane").add(control);
            break;

          case "scrollpane":
            control = new qx.ui.core.scroll.ScrollPane();
            control.addListener("update", this._onResize, this);
            control.addListener("scrollX", this._onScroll, this);
            control.addListener("scrollY", this._onScroll, this);
            control.addListener("scrollAnimationEnd", this._onScrollAnimationEnd, this);
            break;
        }

        return control || qx.ui.container.SlideBar.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        barLeft: true,
        barTop: true,
        barRight: true,
        barBottom: true
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC SCROLL API
      ---------------------------------------------------------------------------
      */

      /**
       * Scrolls the element's content by the given amount.
       *
       * @param offset {Integer?0} Amount to scroll
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollBy: function scrollBy(offset, duration) {
        var pane = this.getChildControl("scrollpane");

        if (this.getOrientation() === "horizontal") {
          pane.scrollByX(offset, duration);
        } else {
          pane.scrollByY(offset, duration);
        }
      },

      /**
       * Scrolls the element's content to the given coordinate
       *
       * @param value {Integer} The position to scroll to.
       * @param duration {Number?} The time in milliseconds the scroll to should take.
       */
      scrollTo: function scrollTo(value, duration) {
        var pane = this.getChildControl("scrollpane");

        if (this.getOrientation() === "horizontal") {
          pane.scrollToX(value, duration);
        } else {
          pane.scrollToY(value, duration);
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyEnabled: function _applyEnabled(value, old, name) {
        qx.ui.container.SlideBar.prototype._applyEnabled.base.call(this, value, old, name);

        this._updateArrowsEnabled();
      },
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        var oldLayouts = [this.getLayout(), this._getLayout()];
        var buttonForward = this.getChildControl("button-forward");
        var buttonBackward = this.getChildControl("button-backward"); // old can also be null, so we have to check both explicitly to set
        // the states correctly.

        if (old == "vertical" && value == "horizontal") {
          buttonForward.removeState("vertical");
          buttonBackward.removeState("vertical");
          buttonForward.addState("horizontal");
          buttonBackward.addState("horizontal");
        } else if (old == "horizontal" && value == "vertical") {
          buttonForward.removeState("horizontal");
          buttonBackward.removeState("horizontal");
          buttonForward.addState("vertical");
          buttonBackward.addState("vertical");
        }

        if (value == "horizontal") {
          this._setLayout(new qx.ui.layout.HBox());

          this.setLayout(new qx.ui.layout.HBox());
        } else {
          this._setLayout(new qx.ui.layout.VBox());

          this.setLayout(new qx.ui.layout.VBox());
        }

        if (oldLayouts[0]) {
          oldLayouts[0].dispose();
        }

        if (oldLayouts[1]) {
          oldLayouts[1].dispose();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Scrolls pane on roll events
       *
       * @param e {qx.event.type.Roll} the roll event
       */
      _onRoll: function _onRoll(e) {
        // only wheel and touch
        if (e.getPointerType() == "mouse") {
          return;
        }

        var delta = 0;
        var pane = this.getChildControl("scrollpane");

        if (this.getOrientation() === "horizontal") {
          delta = e.getDelta().x;
          var position = pane.getScrollX();
          var max = pane.getScrollMaxX();
          var steps = parseInt(delta); // pass the event to the parent if both scrollbars are at the end

          if (!(steps < 0 && position <= 0 || steps > 0 && position >= max || delta == 0)) {
            e.stop();
          } else {
            e.stopMomentum();
          }
        } else {
          delta = e.getDelta().y;
          var position = pane.getScrollY();
          var max = pane.getScrollMaxY();
          var steps = parseInt(delta); // pass the event to the parent if both scrollbars are at the end

          if (!(steps < 0 && position <= 0 || steps > 0 && position >= max || delta == 0)) {
            e.stop();
          } else {
            e.stopMomentum();
          }
        }

        this.scrollBy(parseInt(delta, 10)); // block all momentum scrolling

        if (e.getMomentum()) {
          e.stop();
        }
      },

      /**
       * Update arrow enabled state after scrolling
       */
      _onScroll: function _onScroll() {
        this._updateArrowsEnabled();
      },

      /**
       * Handler to fire the 'scrollAnimationEnd' event.
       */
      _onScrollAnimationEnd: function _onScrollAnimationEnd() {
        this.fireEvent("scrollAnimationEnd");
      },

      /**
       * Listener for resize event. This event is fired after the
       * first flush of the element which leads to another queuing
       * when the changes modify the visibility of the scroll buttons.
       *
       * @param e {Event} Event object
       */
      _onResize: function _onResize(e) {
        var content = this.getChildControl("scrollpane").getChildren()[0];

        if (!content) {
          return;
        }

        var innerSize = this.getInnerSize();
        var contentSize = content.getBounds();
        var overflow = this.getOrientation() === "horizontal" ? contentSize.width > innerSize.width : contentSize.height > innerSize.height;

        if (overflow) {
          this._showArrows();

          this._updateArrowsEnabled();
        } else {
          this._hideArrows();
        }
      },

      /**
       * Scroll handler for left scrolling
       *
       */
      _onExecuteBackward: function _onExecuteBackward() {
        this.scrollBy(-this.getScrollStep());
      },

      /**
       * Scroll handler for right scrolling
       *
       */
      _onExecuteForward: function _onExecuteForward() {
        this.scrollBy(this.getScrollStep());
      },

      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */

      /**
       * Update arrow enabled state
       */
      _updateArrowsEnabled: function _updateArrowsEnabled() {
        // set the disables state directly because we are overriding the
        // inheritance
        if (!this.getEnabled()) {
          this.getChildControl("button-backward").setEnabled(false);
          this.getChildControl("button-forward").setEnabled(false);
          return;
        }

        var pane = this.getChildControl("scrollpane");

        if (this.getOrientation() === "horizontal") {
          var position = pane.getScrollX();
          var max = pane.getScrollMaxX();
        } else {
          var position = pane.getScrollY();
          var max = pane.getScrollMaxY();
        }

        this.getChildControl("button-backward").setEnabled(position > 0);
        this.getChildControl("button-forward").setEnabled(position < max);
      },

      /**
       * Show the arrows (Called from resize event)
       *
       */
      _showArrows: function _showArrows() {
        this._showChildControl("button-forward");

        this._showChildControl("button-backward");
      },

      /**
       * Hide the arrows (Called from resize event)
       *
       */
      _hideArrows: function _hideArrows() {
        this._excludeChildControl("button-forward");

        this._excludeChildControl("button-backward");

        this.scrollTo(0);
      }
    }
  });
  qx.ui.container.SlideBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.ui.core.SingleSelectionManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * This mixin links all methods to manage the single selection.
   *
   * The class which includes the mixin has to implements two methods:
   *
   * <ul>
   * <li><code>_getItems</code>, this method has to return a <code>Array</code>
   *    of <code>qx.ui.core.Widget</code> that should be managed from the manager.
   * </li>
   * <li><code>_isAllowEmptySelection</code>, this method has to return a
   *    <code>Boolean</code> value for allowing empty selection or not.
   * </li>
   * </ul>
   */
  qx.Mixin.define("qx.ui.core.MSingleSelectionHandling", {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data",

      /** Fires after the selection was modified */
      "changeSelection": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.core.SingleSelectionManager} the single selection manager */
      __manager__P_386_0: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * setValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @param item {null|qx.ui.core.Widget} Item to set as selected value.
       * @returns {null|TypeError} The status of this operation.
       */
      setValue: function setValue(item) {
        if (null === item) {
          this.resetSelection();
          return null;
        }

        if (item instanceof qx.ui.core.Widget) {
          this.__getManager__P_386_1().setSelected(item);

          return null;
        } else {
          return new TypeError("Given argument is not null or a {qx.ui.core.Widget}.");
        }
      },

      /**
       * getValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @returns {null|qx.ui.core.Widget} The currently selected widget or null if there is none.
       */
      getValue: function getValue() {
        return this.__getManager__P_386_1().getSelected() || null;
      },

      /**
       * resetValue implements part of the {@link qx.ui.form.IField} interface.
       */
      resetValue: function resetValue() {
        this.__getManager__P_386_1().resetSelected();
      },

      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {qx.ui.core.Widget[]} List of items.
       */
      getSelection: function getSelection() {
        var selected = this.__getManager__P_386_1().getSelected();

        if (selected) {
          return [selected];
        } else {
          return [];
        }
      },

      /**
       * Replaces current selection with the given items.
       *
       * @param items {qx.ui.core.Widget[]} Items to select.
       * @throws {Error} if one of the items is not a child element and if
       *    items contains more than one elements.
       */
      setSelection: function setSelection(items) {
        switch (items.length) {
          case 0:
            this.resetSelection();
            break;

          case 1:
            this.__getManager__P_386_1().setSelected(items[0]);

            break;

          default:
            throw new Error("Could only select one item, but the selection array contains " + items.length + " items!");
        }
      },

      /**
       * Clears the whole selection at once.
       */
      resetSelection: function resetSelection() {
        this.__getManager__P_386_1().resetSelected();
      },

      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {qx.ui.core.Widget} Any valid selectable item.
       * @return {Boolean} Whether the item is selected.
       * @throws {Error} if one of the items is not a child element.
       */
      isSelected: function isSelected(item) {
        return this.__getManager__P_386_1().isSelected(item);
      },

      /**
       * Whether the selection is empty.
       *
       * @return {Boolean} Whether the selection is empty.
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__getManager__P_386_1().isSelectionEmpty();
      },

      /**
       * Returns all elements which are selectable.
       *
       * @param all {Boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       * @return {qx.ui.core.Widget[]} The contained items.
       */
      getSelectables: function getSelectables(all) {
        return this.__getManager__P_386_1().getSelectables(all);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for <code>changeSelected</code> event on single
       * selection manager.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      _onChangeSelected: function _onChangeSelected(e) {
        var newValue = e.getData();
        var oldValue = e.getOldData();
        this.fireDataEvent("changeValue", newValue, oldValue);
        newValue == null ? newValue = [] : newValue = [newValue];
        oldValue == null ? oldValue = [] : oldValue = [oldValue];
        this.fireDataEvent("changeSelection", newValue, oldValue);
      },

      /**
       * Return the selection manager if it is already exists, otherwise creates
       * the manager.
       *
       * @return {qx.ui.core.SingleSelectionManager} Single selection manager.
       */
      __getManager__P_386_1: function __getManager__P_386_1() {
        if (this.__manager__P_386_0 == null) {
          var that = this;
          this.__manager__P_386_0 = new qx.ui.core.SingleSelectionManager({
            getItems: function getItems() {
              return that._getItems();
            },
            isItemSelectable: function isItemSelectable(item) {
              if (that._isItemSelectable) {
                return that._isItemSelectable(item);
              } else {
                return item.isVisible();
              }
            }
          });

          this.__manager__P_386_0.addListener("changeSelected", this._onChangeSelected, this);
        }

        this.__manager__P_386_0.setAllowEmptySelection(this._isAllowEmptySelection());

        return this.__manager__P_386_0;
      }
    },

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__manager__P_386_0");
    }
  });
  qx.ui.core.MSingleSelectionHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.core.ISingleSelection": {
        "require": true
      },
      "qx.ui.core.MSingleSelectionHandling": {
        "require": true
      },
      "qx.ui.core.MChildrenHandling": {
        "require": true
      },
      "qx.ui.layout.Grow": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */

  /**
   * The stack container puts its child widgets on top of each other and only the
   * topmost widget is visible.
   *
   * This is used e.g. in the tab view widget. Which widget is visible can be
   * controlled by using the {@link #getSelection} method.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // create stack container
   *   var stack = new qx.ui.container.Stack();
   *
   *   // add some children
   *   stack.add(new qx.ui.core.Widget().set({
   *    backgroundColor: "red"
   *   }));
   *   stack.add(new qx.ui.core.Widget().set({
   *    backgroundColor: "green"
   *   }));
   *   stack.add(new qx.ui.core.Widget().set({
   *    backgroundColor: "blue"
   *   }));
   *
   *   // select green widget
   *   stack.setSelection([stack.getChildren()[1]]);
   *
   *   this.getRoot().add(stack);
   * </pre>
   *
   * This example creates an stack with three children. Only the selected "green"
   * widget is visible.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/stack.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.container.Stack", {
    extend: qx.ui.core.Widget,
    implement: [qx.ui.form.IField, qx.ui.core.ISingleSelection],
    include: [qx.ui.core.MSingleSelectionHandling, qx.ui.core.MChildrenHandling],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this);

      this._setLayout(new qx.ui.layout.Grow());

      this.addListener("changeSelection", this.__onChangeSelection__P_368_0, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether the size of the widget depends on the selected child. When
       * disabled (default) the size is configured to the largest child.
       */
      dynamic: {
        check: "Boolean",
        init: false,
        apply: "_applyDynamic"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // property apply
      _applyDynamic: function _applyDynamic(value) {
        var children = this._getChildren();

        var selected = this.getSelection()[0];
        var child;

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (child != selected) {
            if (value) {
              children[i].exclude();
            } else {
              children[i].hide();
            }
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS FOR SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the widget for the selection.
       * @return {qx.ui.core.Widget[]} Widgets to select.
       */
      _getItems: function _getItems() {
        return this.getChildren();
      },

      /**
       * Returns if the selection could be empty or not.
       *
       * @return {Boolean} <code>true</code> If selection could be empty,
       *    <code>false</code> otherwise.
       */
      _isAllowEmptySelection: function _isAllowEmptySelection() {
        return true;
      },

      /**
       * Returns whether the given item is selectable.
       *
       * @param item {qx.ui.core.Widget} The item to be checked
       * @return {Boolean} Whether the given item is selectable
       */
      _isItemSelectable: function _isItemSelectable(item) {
        return true;
      },

      /**
       * Event handler for <code>changeSelection</code>.
       *
       * Shows the new selected widget and hide the old one.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      __onChangeSelection__P_368_0: function __onChangeSelection__P_368_0(e) {
        var old = e.getOldData()[0];
        var value = e.getData()[0];

        if (old) {
          if (this.isDynamic()) {
            old.exclude();
          } else {
            old.hide();
          }
        }

        if (value) {
          value.show();
        }
      },
      //overridden
      _afterAddChild: function _afterAddChild(child) {
        var selected = this.getSelection()[0];

        if (!selected) {
          this.setSelection([child]);
        } else if (selected !== child) {
          if (this.isDynamic()) {
            child.exclude();
          } else {
            child.hide();
          }
        }
      },
      //overridden
      _afterRemoveChild: function _afterRemoveChild(child) {
        if (this.getSelection()[0] === child) {
          var first = this._getChildren()[0];

          if (first) {
            this.setSelection([first]);
          } else {
            this.resetSelection();
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Go to the previous child in the children list.
       */
      previous: function previous() {
        var selected = this.getSelection()[0];
        var go = this._indexOf(selected) - 1;

        var children = this._getChildren();

        if (go < 0) {
          go = children.length - 1;
        }

        var prev = children[go];
        this.setSelection([prev]);
      },

      /**
       * Go to the next child in the children list.
       */
      next: function next() {
        var selected = this.getSelection()[0];
        var go = this._indexOf(selected) + 1;

        var children = this._getChildren();

        var next = children[go] || children[0];
        this.setSelection([next]);
      }
    }
  });
  qx.ui.container.Stack.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      },
      "qx.ui.core.ISingleSelectionProvider": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Responsible for the single selection management.
   *
   * The class manage a list of {@link qx.ui.core.Widget} which are returned from
   * {@link qx.ui.core.ISingleSelectionProvider#getItems}.
   *
   * @internal
   */
  qx.Class.define("qx.ui.core.SingleSelectionManager", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Construct the single selection manager.
     *
     * @param selectionProvider {qx.ui.core.ISingleSelectionProvider} The provider
     * for selection.
     */
    construct: function construct(selectionProvider) {
      qx.core.Object.constructor.call(this);
      {
        qx.core.Assert.assertInterface(selectionProvider, qx.ui.core.ISingleSelectionProvider, "Invalid selectionProvider!");
      }
      this.__selectionProvider__P_387_0 = selectionProvider;
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fires after the selection was modified */
      "changeSelected": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * If the value is <code>true</code> the manager allows an empty selection,
       * otherwise the first selectable element returned from the
       * <code>qx.ui.core.ISingleSelectionProvider</code> will be selected.
       */
      allowEmptySelection: {
        check: "Boolean",
        init: true,
        apply: "__applyAllowEmptySelection__P_387_1"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.core.Widget} The selected widget. */
      __selected__P_387_2: null,

      /** @type {qx.ui.core.ISingleSelectionProvider} The provider for selection management */
      __selectionProvider__P_387_0: null,

      /*
      ---------------------------------------------------------------------------
         PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the current selected element.
       *
       * @return {qx.ui.core.Widget | null} The current selected widget or
       *    <code>null</code> if the selection is empty.
       */
      getSelected: function getSelected() {
        return this.__selected__P_387_2;
      },

      /**
       * Selects the passed element.
       *
       * @param item {qx.ui.core.Widget} Element to select.
       * @throws {Error} if the element is not a child element.
       */
      setSelected: function setSelected(item) {
        if (!this.__isChildElement__P_387_3(item)) {
          throw new Error("Could not select " + item + ", because it is not a child element!");
        }

        this.__setSelected__P_387_4(item);
      },

      /**
       * Reset the current selection. If {@link #allowEmptySelection} is set to
       * <code>true</code> the first element will be selected.
       */
      resetSelected: function resetSelected() {
        this.__setSelected__P_387_4(null);
      },

      /**
       * Return <code>true</code> if the passed element is selected.
       *
       * @param item {qx.ui.core.Widget} Element to check if selected.
       * @return {Boolean} <code>true</code> if passed element is selected,
       *    <code>false</code> otherwise.
       * @throws {Error} if the element is not a child element.
       */
      isSelected: function isSelected(item) {
        if (!this.__isChildElement__P_387_3(item)) {
          throw new Error("Could not check if " + item + " is selected," + " because it is not a child element!");
        }

        return this.__selected__P_387_2 === item;
      },

      /**
       * Returns <code>true</code> if selection is empty.
       *
       * @return {Boolean} <code>true</code> if selection is empty,
       *    <code>false</code> otherwise.
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__selected__P_387_2 == null;
      },

      /**
       * Returns all elements which are selectable.
       *
       * @param all {Boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       * @return {qx.ui.core.Widget[]} The contained items.
       */
      getSelectables: function getSelectables(all) {
        var items = this.__selectionProvider__P_387_0.getItems();

        var result = [];

        for (var i = 0; i < items.length; i++) {
          if (this.__selectionProvider__P_387_0.isItemSelectable(items[i])) {
            result.push(items[i]);
          }
        } // in case of an user selectable list, remove the enabled items


        if (!all) {
          for (var i = result.length - 1; i >= 0; i--) {
            if (!result[i].getEnabled()) {
              result.splice(i, 1);
            }
          }

          ;
        }

        return result;
      },

      /*
      ---------------------------------------------------------------------------
         APPLY METHODS
      ---------------------------------------------------------------------------
      */
      // apply method
      __applyAllowEmptySelection__P_387_1: function __applyAllowEmptySelection__P_387_1(value, old) {
        if (!value) {
          this.__setSelected__P_387_4(this.__selected__P_387_2);
        }
      },

      /*
      ---------------------------------------------------------------------------
         HELPERS
      ---------------------------------------------------------------------------
      */

      /**
       * Set selected element.
       *
       * If passes value is <code>null</code>, the selection will be reseted.
       *
       * @param item {qx.ui.core.Widget | null} element to select, or
       *    <code>null</code> to reset selection.
       */
      __setSelected__P_387_4: function __setSelected__P_387_4(item) {
        var oldSelected = this.__selected__P_387_2;
        var newSelected = item;

        if (newSelected != null && oldSelected === newSelected) {
          return;
        }

        if (!this.isAllowEmptySelection() && newSelected == null) {
          var firstElement = this.getSelectables(true)[0];

          if (firstElement) {
            newSelected = firstElement;
          }
        }

        this.__selected__P_387_2 = newSelected;
        this.fireDataEvent("changeSelected", newSelected, oldSelected);
      },

      /**
       * Checks if passed element is a child element.
       *
       * @param item {qx.ui.core.Widget} Element to check if child element.
       * @return {Boolean} <code>true</code> if element is child element,
       *    <code>false</code> otherwise.
       */
      __isChildElement__P_387_3: function __isChildElement__P_387_3(item) {
        var items = this.__selectionProvider__P_387_0.getItems();

        for (var i = 0; i < items.length; i++) {
          if (items[i] === item) {
            return true;
          }
        }

        return false;
      }
    },

    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct: function destruct() {
      if (this.__selectionProvider__P_387_0.toHashCode) {
        this._disposeObjects("__selectionProvider__P_387_0");
      } else {
        this.__selectionProvider__P_387_0 = null;
      }

      this._disposeObjects("__selected__P_387_2");
    }
  });
  qx.ui.core.SingleSelectionManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Defines the callback for the single selection manager.
   *
   * @internal
   */
  qx.Interface.define("qx.ui.core.ISingleSelectionProvider", {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the elements which are part of the selection.
       *
       * @return {qx.ui.core.Widget[]} The widgets for the selection.
       */
      getItems: function getItems() {},

      /**
       * Returns whether the given item is selectable.
       *
       * @param item {qx.ui.core.Widget} The item to be checked
       * @return {Boolean} Whether the given item is selectable
       */
      isItemSelectable: function isItemSelectable(item) {}
    }
  });
  qx.ui.core.ISingleSelectionProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which have boolean as their primary
   * data type like a colorchooser.
   */
  qx.Interface.define("qx.ui.form.IColorForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {Color|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {Color|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.IColorForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.popup.Popup": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IColorForm": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.core.Widget": {},
      "qx.ui.form.Button": {},
      "qx.ui.groupbox.GroupBox": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.container.Composite": {},
      "qx.ui.layout.Basic": {},
      "qx.ui.window.Window": {},
      "qx.ui.control.ColorSelector": {},
      "qx.util.ColorUtil": {},
      "qx.lang.Array": {},
      "qx.locale.Manager": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
  
  
  ************************************************************************ */

  /**
   * A popup which contains palettes of colors and the possibility to open the
   * Colorselector to choose a color.
   *
   * @childControl field {qx.ui.core.Widget} shows preset colors
   * @childControl auto-button {qx.ui.form.Button} automatic button
   * @childControl selector-button {qx.ui.form.Button} button to open the color selector
   * @childControl preview-pane {qx.ui.groupbox.GroupBox} group box to show the old and the new color
   * @childControl selected-preview {qx.ui.container.Composite} show the selected color
   * @childControl current-preview {qx.ui.container.Composite} show the current color
   * @childControl colorselector-okbutton {qx.ui.form.Button} button of the colorselector
   * @childControl colorselector-cancelbutton {qx.ui.form.Button} button of the colorselector
   */
  qx.Class.define("qx.ui.control.ColorPopup", {
    extend: qx.ui.popup.Popup,
    implement: [qx.ui.form.IColorForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.popup.Popup.constructor.call(this);
      this.setLayout(new qx.ui.layout.VBox(5));

      this._createChildControl("auto-button");

      this._createBoxes();

      this._createChildControl("preview-pane");

      this._createChildControl("selector-button");

      this.addListener("changeVisibility", this._onChangeVisibility, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "colorpopup"
      },

      /** The hex value of the selected color. */
      value: {
        nullable: true,
        apply: "_applyValue",
        event: "changeValue"
      },

      /** The numeric red value of the selected color. */
      red: {
        check: "Number",
        init: null,
        nullable: true,
        event: "changeRed"
      },

      /** The numeric green value of the selected color. */
      green: {
        check: "Number",
        init: null,
        nullable: true,
        event: "changeGreen"
      },

      /** The numeric blue value of the selected color. */
      blue: {
        check: "Number",
        init: null,
        nullable: true,
        event: "changeBlue"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __minZIndex__P_369_0: 1e5,
      __boxes__P_369_1: null,
      __colorSelectorWindow__P_369_2: null,
      __colorSelector__P_369_3: null,
      __buttonBar__P_369_4: null,
      __recentTableId__P_369_5: "recent",
      __fieldNumber__P_369_6: 12,
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "field":
            control = new qx.ui.core.Widget();
            control.addListener("pointerdown", this._onFieldPointerDown, this);
            control.addListener("pointerover", this._onFieldPointerOver, this);
            control.addListener("pointerout", this._onFieldPointerOut, this);
            break;

          case "auto-button":
            control = new qx.ui.form.Button(this.tr("Automatic"));
            control.setAllowStretchX(true);
            control.addListener("execute", this._onAutomaticBtnExecute, this);
            this.add(control);
            break;

          case "selector-button":
            control = new qx.ui.form.Button(this.tr("Open ColorSelector"));
            control.addListener("execute", this._onSelectorButtonExecute, this);
            this.add(control);
            break;

          case "preview-pane":
            control = new qx.ui.groupbox.GroupBox(this.tr("Preview (Old/New)"));
            control.setLayout(new qx.ui.layout.HBox());
            control.add(this._createChildControl("selected-preview", true), {
              flex: 1
            });
            control.add(this._createChildControl("current-preview", true), {
              flex: 1
            });
            this.add(control);
            break;

          case "selected-preview":
            control = new qx.ui.container.Composite(new qx.ui.layout.Basic());
            break;

          case "current-preview":
            control = new qx.ui.container.Composite(new qx.ui.layout.Basic());
            break;

          case "colorselector-okbutton":
            control = new qx.ui.form.Button(this.tr("OK"));
            control.addListener("execute", this._onColorSelectorOk, this);
            break;

          case "colorselector-cancelbutton":
            control = new qx.ui.form.Button(this.tr("Cancel"));
            control.addListener("execute", this._onColorSelectorCancel, this);
            break;
        }

        return control || qx.ui.control.ColorPopup.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        CREATOR SUBS
      ---------------------------------------------------------------------------
      */

      /**
       * Creates the GroupBoxes containing the colored fields.
       */
      _createBoxes: function _createBoxes() {
        this.__boxes__P_369_1 = {};
        var tables = this._tables;
        var table, box, field;
        var j = 0;

        for (var tableId in tables) {
          table = tables[tableId];
          box = new qx.ui.groupbox.GroupBox(table.label);
          box.setLayout(new qx.ui.layout.HBox());
          this.__boxes__P_369_1[tableId] = box;
          this.add(box);

          for (var i = 0; i < this.__fieldNumber__P_369_6; i++) {
            field = this.getChildControl("field#" + j++);
            field.setBackgroundColor(table.values[i] || null);
            box.add(field);
          }
        }
      },

      /**
       * Creates the ColorSelector and adds buttons.
       */
      _createColorSelector: function _createColorSelector() {
        if (this.__colorSelector__P_369_3) {
          return;
        }

        var win = new qx.ui.window.Window(this.tr("Color Selector"));
        this.__colorSelectorWindow__P_369_2 = win;
        win.setLayout(new qx.ui.layout.VBox(16));
        win.setResizable(false);
        win.moveTo(20, 20);
        this.__colorSelector__P_369_3 = new qx.ui.control.ColorSelector();
        win.add(this.__colorSelector__P_369_3);
        this.__buttonBar__P_369_4 = new qx.ui.container.Composite(new qx.ui.layout.HBox(8, "right"));
        win.add(this.__buttonBar__P_369_4);

        var btnCancel = this._createChildControl("colorselector-cancelbutton");

        var btnOk = this._createChildControl("colorselector-okbutton");

        this.__buttonBar__P_369_4.add(btnCancel);

        this.__buttonBar__P_369_4.add(btnOk);
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // Property apply
      _applyValue: function _applyValue(value, old) {
        if (value === null) {
          this.setRed(null);
          this.setGreen(null);
          this.setBlue(null);
        } else {
          var rgb = qx.util.ColorUtil.stringToRgb(value);
          this.setRed(rgb[0]);
          this.setGreen(rgb[1]);
          this.setBlue(rgb[2]);
        }

        this.getChildControl("selected-preview").setBackgroundColor(value);

        this._rotatePreviousColors();
      },

      /**
       * Adds the most recent selected color to the "Recent colors" list.
       * If this list is full, the first color will be removed before inserting
       * the new one.
       */
      _rotatePreviousColors: function _rotatePreviousColors() {
        if (!this._tables) {
          return;
        }

        var vRecentTable = this._tables[this.__recentTableId__P_369_5].values;
        var vRecentBox = this.__boxes__P_369_1[this.__recentTableId__P_369_5];

        if (!vRecentTable) {
          return;
        }

        var newValue = this.getValue();

        if (!newValue) {
          return;
        } // Modifying incoming table


        var vIndex = vRecentTable.indexOf(newValue);

        if (vIndex != -1) {
          qx.lang.Array.removeAt(vRecentTable, vIndex);
        } else if (vRecentTable.length == this.__fieldNumber__P_369_6) {
          vRecentTable.shift();
        }

        vRecentTable.push(newValue); // Sync to visible fields

        var vFields = vRecentBox.getChildren();

        for (var i = 0; i < vFields.length; i++) {
          vFields[i].setBackgroundColor(vRecentTable[i] || null);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Listener of pointerdown event on a color field. Sets the ColorPoup's value
       * to field's color value and paint the preview pane.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onFieldPointerDown: function _onFieldPointerDown(e) {
        var vValue = this.getChildControl("current-preview").getBackgroundColor();
        this.setValue(vValue);

        if (vValue) {
          this.hide();
        }
      },

      /**
       * Listener of pointermove event on a color field. Sets preview pane's
       * background color to the field's color value.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onFieldPointerOver: function _onFieldPointerOver(e) {
        this.getChildControl("current-preview").setBackgroundColor(e.getTarget().getBackgroundColor());
      },

      /**
       * Listener of pointerout event on a color field. Reset the preview pane's
       * background color to the old color value.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onFieldPointerOut: function _onFieldPointerOut(e) {
        var red = this.getRed();
        var green = this.getGreen();
        var blue = this.getBlue();
        var color = null;

        if (red !== null || green !== null || blue !== null) {
          color = qx.util.ColorUtil.rgbToRgbString([red, green, blue]);
        }

        this.getChildControl("current-preview").setBackgroundColor(color);
      },

      /**
       * Listener of execute event on the "cancel" button.
       * Hides the ColorPopup and resets it's color value.
       */
      _onAutomaticBtnExecute: function _onAutomaticBtnExecute() {
        this.setValue(null);
        this.hide();
      },

      /**
       * Listener of execute event on the "Open ColorSelector" button.
       * Opens a ColorSelector widget and hides the ColorPopup.
       */
      _onSelectorButtonExecute: function _onSelectorButtonExecute() {
        this._createColorSelector();

        this.exclude();
        var red = this.getRed();
        var green = this.getGreen();
        var blue = this.getBlue();

        if (red === null || green === null || blue === null) {
          red = 255;
          green = 255;
          blue = 255;
        }

        this.__colorSelector__P_369_3.setRed(red);

        this.__colorSelector__P_369_3.setGreen(green);

        this.__colorSelector__P_369_3.setBlue(blue);

        this.__colorSelectorWindow__P_369_2.open();
      },

      /**
       * Listener of execute event on the "OK" button.
       * Hides the ColorPopup and sets it's color value to the selected color.
       */
      _onColorSelectorOk: function _onColorSelectorOk() {
        var sel = this.__colorSelector__P_369_3;
        this.setValue(qx.util.ColorUtil.rgbToRgbString([sel.getRed(), sel.getGreen(), sel.getBlue()]));

        this.__colorSelectorWindow__P_369_2.close();
      },

      /**
       * Listener of execute event on the "Cancel" button.
       * Hides the ColorPopup.
       */
      _onColorSelectorCancel: function _onColorSelectorCancel() {
        this.__colorSelectorWindow__P_369_2.close();
      },

      /**
       * Listener for visibility changes.
       * Sets preview pane's background color to the current color,
       * when the popup is visible.
       *
       * @param e {qx.event.type.Data} Incoming event object
       */
      _onChangeVisibility: function _onChangeVisibility(e) {
        if (this.getVisibility() == "visible") {
          var red = this.getRed();
          var green = this.getGreen();
          var blue = this.getBlue();
          var color = null;

          if (red !== null || green !== null || blue !== null) {
            color = qx.util.ColorUtil.rgbToRgbString([red, green, blue]);
          }

          this.getChildControl("selected-preview").setBackgroundColor(color);
          this.getChildControl("current-preview").setBackgroundColor(color);
        }
      },

      /**
       * @lint ignoreReferenceField(_tables)
       */
      _tables: {
        core: {
          label: qx.locale.Manager.tr("Basic Colors"),
          values: ["#000", "#333", "#666", "#999", "#CCC", "#FFF", "red", "green", "blue", "yellow", "teal", "maroon"]
        },
        recent: {
          label: qx.locale.Manager.tr("Recent Colors"),
          values: []
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this.__colorSelectorWindow__P_369_2) {
        this.__colorSelectorWindow__P_369_2.destroy();

        this.__colorSelector__P_369_3.destroy();

        this.__buttonBar__P_369_4.destroy();
      }

      this._tables = this.__boxes__P_369_1 = null;
    }
  });
  qx.ui.control.ColorPopup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.core.MRemoteLayoutHandling": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.layout.Canvas": {
        "construct": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.basic.Atom": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Group boxes are used to group a set of form elements.
   *
   * @childControl frame {qx.ui.container.Composite} frame for the content widgets
   * @childControl legend {qx.ui.basic.Atom} legend to show at top of the groupbox
   */
  qx.Class.define("qx.ui.groupbox.GroupBox", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.core.MRemoteLayoutHandling, qx.ui.core.MContentPadding, qx.ui.form.MForm],
    implement: [qx.ui.form.IForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param legend {String?""} The group boxes legend
     * @param icon {String?""} The icon of the legend
     */
    construct: function construct(legend, icon) {
      qx.ui.core.Widget.constructor.call(this);

      this._setLayout(new qx.ui.layout.Canvas()); // Sub widgets


      this._createChildControl("frame");

      this._createChildControl("legend"); // Processing parameters


      if (legend != null) {
        this.setLegend(legend);
      }

      if (icon != null) {
        this.setIcon(icon);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "groupbox"
      },

      /**
       * Label of the legend sub widget. Set if the given string is
       * valid. Otherwise the legend sub widget is not being displayed.
       */
      legend: {
        check: "String",
        apply: "_applyLegend",
        event: "changeLegend",
        nullable: true
      },

      /**
       * Property for setting the position of the legend.
       */
      legendPosition: {
        check: ["top", "middle"],
        init: "middle",
        apply: "_applyLegendPosition",
        themeable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        invalid: true
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "frame":
            control = new qx.ui.container.Composite();

            this._add(control, {
              left: 0,
              top: 6,
              right: 0,
              bottom: 0
            });

            break;

          case "legend":
            control = new qx.ui.basic.Atom();
            control.addListener("resize", this._repositionFrame, this);

            this._add(control, {
              left: 0,
              right: 0
            });

            break;
        }

        return control || qx.ui.groupbox.GroupBox.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getChildControl("frame");
      },

      /*
      ---------------------------------------------------------------------------
        LEGEND HANDLING
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyLegend: function _applyLegend(value, old) {
        var control = this.getChildControl("legend");

        if (value !== null) {
          control.setLabel(value);
          control.show();
        } else {
          control.exclude();
        }
      },

      /**
       * Apply method for applying the legend position. It calls the
       * {@link #_repositionFrame} method.
       */
      _applyLegendPosition: function _applyLegendPosition(e) {
        if (this.getChildControl("legend").getBounds()) {
          this._repositionFrame();
        }
      },

      /**
       * Repositions the frame of the group box dependent on the
       * {@link #legendPosition} property.
       */
      _repositionFrame: function _repositionFrame() {
        var legend = this.getChildControl("legend");
        var frame = this.getChildControl("frame"); // get the current height of the legend

        var height = legend.getBounds().height; // check for the property legend position

        if (this.getLegendPosition() == "middle") {
          frame.setLayoutProperties({
            "top": Math.round(height / 2)
          });
        } else if (this.getLegendPosition() == "top") {
          frame.setLayoutProperties({
            "top": height
          });
        }
      },

      /*
      ---------------------------------------------------------------------------
        GETTER FOR SUB WIDGETS
      ---------------------------------------------------------------------------
      */

      /**
       * The children container needed by the {@link qx.ui.core.MRemoteChildrenHandling}
       * mixin
       *
       * @return {qx.ui.container.Composite} pane sub widget
       */
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("frame");
      },

      /*
      ---------------------------------------------------------------------------
        SETTER/GETTER
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the icon of the legend sub widget.
       *
       * @param icon {String} source of the new icon of the legend sub widget
       */
      setIcon: function setIcon(icon) {
        this.getChildControl("legend").setIcon(icon);
      },

      /**
       * Accessor method for the icon of the legend sub widget
       *
       * @return {String} source of the new icon of the legend sub widget
       */
      getIcon: function getIcon() {
        return this.getChildControl("legend").getIcon();
      }
    }
  });
  qx.ui.groupbox.GroupBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.core.Init": {},
      "qx.Class": {},
      "qx.ui.window.IDesktop": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Provides move behavior to any widget.
   *
   * The widget using the mixin must register a widget as move handle so that
   * the pointer events needed for moving it are attached to this widget).
   * <pre class='javascript'>this._activateMoveHandle(widget);</pre>
   */
  qx.Mixin.define("qx.ui.core.MMovable", {
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Whether the widget is movable */
      movable: {
        check: "Boolean",
        init: true
      },

      /** Whether to use a frame instead of the original widget during move sequences */
      useMoveFrame: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __moveHandle__P_381_0: null,
      __moveFrame__P_381_1: null,
      __dragRange__P_381_2: null,
      __dragLeft__P_381_3: null,
      __dragTop__P_381_4: null,
      __parentLeft__P_381_5: null,
      __parentTop__P_381_6: null,
      __blockerAdded__P_381_7: false,
      __oldBlockerColor__P_381_8: null,
      __oldBlockerOpacity__P_381_9: 0,

      /*
      ---------------------------------------------------------------------------
        CORE FEATURES
      ---------------------------------------------------------------------------
      */

      /**
       * Configures the given widget as a move handle
       *
       * @param widget {qx.ui.core.Widget} Widget to activate as move handle
       */
      _activateMoveHandle: function _activateMoveHandle(widget) {
        if (this.__moveHandle__P_381_0) {
          throw new Error("The move handle could not be redefined!");
        }

        this.__moveHandle__P_381_0 = widget;
        widget.addListener("pointerdown", this._onMovePointerDown, this);
        widget.addListener("pointerup", this._onMovePointerUp, this);
        widget.addListener("pointermove", this._onMovePointerMove, this);
        widget.addListener("losecapture", this.__onMoveLoseCapture__P_381_10, this);
      },

      /**
       * Get the widget, which draws the resize/move frame.
       *
       * @return {qx.ui.core.Widget} The resize frame
       */
      __getMoveFrame__P_381_11: function __getMoveFrame__P_381_11() {
        var frame = this.__moveFrame__P_381_1;

        if (!frame) {
          frame = this.__moveFrame__P_381_1 = new qx.ui.core.Widget();
          frame.setAppearance("move-frame");
          frame.exclude();
          qx.core.Init.getApplication().getRoot().add(frame);
        }

        return frame;
      },

      /**
       * Creates, shows and syncs the frame with the widget.
       */
      __showMoveFrame__P_381_12: function __showMoveFrame__P_381_12() {
        var location = this.getContentLocation();
        var bounds = this.getBounds();

        var frame = this.__getMoveFrame__P_381_11();

        frame.setUserBounds(location.left, location.top, bounds.width, bounds.height);
        frame.show();
        frame.setZIndex(this.getZIndex() + 1);
      },

      /*
      ---------------------------------------------------------------------------
        MOVE SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Computes the new drag coordinates
       *
       * @param e {qx.event.type.Pointer} Pointer event
       * @return {Map} A map with the computed drag coordinates
       */
      __computeMoveCoordinates__P_381_13: function __computeMoveCoordinates__P_381_13(e) {
        var range = this.__dragRange__P_381_2;
        var pointerLeft = Math.max(range.left, Math.min(range.right, e.getDocumentLeft()));
        var pointerTop = Math.max(range.top, Math.min(range.bottom, e.getDocumentTop()));
        var viewportLeft = this.__dragLeft__P_381_3 + pointerLeft;
        var viewportTop = this.__dragTop__P_381_4 + pointerTop;
        return {
          viewportLeft: parseInt(viewportLeft, 10),
          viewportTop: parseInt(viewportTop, 10),
          parentLeft: parseInt(viewportLeft - this.__parentLeft__P_381_5, 10),
          parentTop: parseInt(viewportTop - this.__parentTop__P_381_6, 10)
        };
      },

      /*
      ---------------------------------------------------------------------------
        MOVE EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Roll handler which prevents the scrolling via tap & move on parent widgets
       * during the move of the widget.
       * @param e {qx.event.type.Roll} The roll event
       */
      _onMoveRoll: function _onMoveRoll(e) {
        e.stop();
      },

      /**
       * Enables the capturing of the caption bar and prepares the drag session and the
       * appearance (translucent, frame or opaque) for the moving of the window.
       *
       * @param e {qx.event.type.Pointer} pointer down event
       */
      _onMovePointerDown: function _onMovePointerDown(e) {
        if (!this.getMovable() || this.hasState("maximized")) {
          return;
        }

        this.addListener("roll", this._onMoveRoll, this); // Compute drag range

        var parent = this.getLayoutParent();
        var parentLocation = parent.getContentLocation();
        var parentBounds = parent.getBounds(); // Added a blocker, this solves the issue described in [BUG #1462]

        if (qx.Class.implementsInterface(parent, qx.ui.window.IDesktop)) {
          if (!parent.isBlocked()) {
            this.__oldBlockerColor__P_381_8 = parent.getBlockerColor();
            this.__oldBlockerOpacity__P_381_9 = parent.getBlockerOpacity();
            parent.setBlockerColor(null);
            parent.setBlockerOpacity(1);
            parent.blockContent(this.getZIndex() - 1);
            this.__blockerAdded__P_381_7 = true;
          }
        }

        this.__dragRange__P_381_2 = {
          left: parentLocation.left,
          top: parentLocation.top,
          right: parentLocation.left + parentBounds.width,
          bottom: parentLocation.top + parentBounds.height
        }; // Compute drag positions

        var widgetLocation = this.getContentLocation();
        this.__parentLeft__P_381_5 = parentLocation.left;
        this.__parentTop__P_381_6 = parentLocation.top;
        this.__dragLeft__P_381_3 = widgetLocation.left - e.getDocumentLeft();
        this.__dragTop__P_381_4 = widgetLocation.top - e.getDocumentTop(); // Add state

        this.addState("move"); // Enable capturing

        this.__moveHandle__P_381_0.capture(); // Enable drag frame


        if (this.getUseMoveFrame()) {
          this.__showMoveFrame__P_381_12();
        } // Stop event


        e.stop();
      },

      /**
       * Does the moving of the window by rendering the position
       * of the window (or frame) at runtime using direct dom methods.
       *
       * @param e {qx.event.type.Pointer} pointer move event
       */
      _onMovePointerMove: function _onMovePointerMove(e) {
        // Only react when dragging is active
        if (!this.hasState("move")) {
          return;
        } // Apply new coordinates using DOM


        var coords = this.__computeMoveCoordinates__P_381_13(e);

        if (this.getUseMoveFrame()) {
          this.__getMoveFrame__P_381_11().setDomPosition(coords.viewportLeft, coords.viewportTop);
        } else {
          var insets = this.getLayoutParent().getInsets();
          this.setDomPosition(coords.parentLeft - (insets.left || 0), coords.parentTop - (insets.top || 0));
        }

        e.stopPropagation();
      },

      /**
       * Disables the capturing of the caption bar and moves the window
       * to the last position of the drag session. Also restores the appearance
       * of the window.
       *
       * @param e {qx.event.type.Pointer} pointer up event
       */
      _onMovePointerUp: function _onMovePointerUp(e) {
        if (this.hasListener("roll")) {
          this.removeListener("roll", this._onMoveRoll, this);
        } // Only react when dragging is active


        if (!this.hasState("move")) {
          return;
        } // Remove drag state


        this.removeState("move"); // Removed blocker, this solves the issue described in [BUG #1462]

        var parent = this.getLayoutParent();

        if (qx.Class.implementsInterface(parent, qx.ui.window.IDesktop)) {
          if (this.__blockerAdded__P_381_7) {
            parent.unblock();
            parent.setBlockerColor(this.__oldBlockerColor__P_381_8);
            parent.setBlockerOpacity(this.__oldBlockerOpacity__P_381_9);
            this.__oldBlockerColor__P_381_8 = null;
            this.__oldBlockerOpacity__P_381_9 = 0;
            this.__blockerAdded__P_381_7 = false;
          }
        } // Disable capturing


        this.__moveHandle__P_381_0.releaseCapture(); // Apply them to the layout


        var coords = this.__computeMoveCoordinates__P_381_13(e);

        var insets = this.getLayoutParent().getInsets();
        this.setLayoutProperties({
          left: coords.parentLeft - (insets.left || 0),
          top: coords.parentTop - (insets.top || 0)
        }); // Hide frame afterwards

        if (this.getUseMoveFrame()) {
          this.__getMoveFrame__P_381_11().exclude();
        }

        e.stopPropagation();
      },

      /**
       * Event listener for <code>losecapture</code> event.
       *
       * @param e {qx.event.type.Event} Lose capture event
       */
      __onMoveLoseCapture__P_381_10: function __onMoveLoseCapture__P_381_10(e) {
        // Check for active move
        if (!this.hasState("move")) {
          return;
        } // Remove drag state


        this.removeState("move"); // Hide frame afterwards

        if (this.getUseMoveFrame()) {
          this.__getMoveFrame__P_381_11().exclude();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__moveFrame__P_381_1", "__moveHandle__P_381_0");

      this.__dragRange__P_381_2 = null;
    }
  });
  qx.ui.core.MMovable.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.window.IDesktop": {},
      "qx.ui.window.Window": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Required interface for all window manager.
   *
   * Window manager handle the z-order and modality blocking of windows managed
   * by the connected desktop {@link qx.ui.window.IDesktop}.
   */
  qx.Interface.define("qx.ui.window.IWindowManager", {
    members: {
      /**
       * Connect the window manager to the window desktop
       *
       * @param desktop {qx.ui.window.IDesktop|null} The connected desktop or null
       */
      setDesktop: function setDesktop(desktop) {
        if (desktop !== null) {
          this.assertInterface(desktop, qx.ui.window.IDesktop);
        }
      },

      /**
       * Inform the window manager about a new active window
       *
       * @param active {qx.ui.window.Window} new active window
       * @param oldActive {qx.ui.window.Window} old active window
       */
      changeActiveWindow: function changeActiveWindow(active, oldActive) {},

      /**
       * Update the window order and modality blocker
       */
      updateStack: function updateStack() {},

      /**
       * Ask the manager to bring a window to the front.
       *
       * @param win {qx.ui.window.Window} window to bring to front
       */
      bringToFront: function bringToFront(win) {
        this.assertInstance(win, qx.ui.window.Window);
      },

      /**
       * Ask the manager to send a window to the back.
       *
       * @param win {qx.ui.window.Window} window to sent to back
       */
      sendToBack: function sendToBack(win) {
        this.assertInstance(win, qx.ui.window.Window);
      }
    }
  });
  qx.ui.window.IWindowManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.window.IWindowManager": {
        "require": true
      },
      "qx.ui.core.queue.Widget": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The default window manager implementation
   */
  qx.Class.define("qx.ui.window.Manager", {
    extend: qx.core.Object,
    implement: qx.ui.window.IWindowManager,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __desktop__P_563_0: null,
      // interface implementation
      setDesktop: function setDesktop(desktop) {
        this.__desktop__P_563_0 = desktop;

        if (desktop) {
          this.updateStack();
        } else {
          // the window manager should be removed
          // from the widget queue if the desktop
          // was set to null
          qx.ui.core.queue.Widget.remove(this);
        }
      },

      /**
       * Returns the connected desktop
       *
       * @return {qx.ui.window.IDesktop} The desktop
       */
      getDesktop: function getDesktop() {
        return this.__desktop__P_563_0;
      },
      // interface implementation
      changeActiveWindow: function changeActiveWindow(active, oldActive) {
        if (active) {
          this.bringToFront(active);
          active.setActive(true);
        }

        if (oldActive) {
          oldActive.resetActive();
        }
      },

      /** @type {Integer} Minimum zIndex to start with for windows */
      _minZIndex: 1e5,
      // interface implementation
      updateStack: function updateStack() {
        // we use the widget queue to do the sorting one before the queues are
        // flushed. The queue will call "syncWidget"
        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * This method is called during the flush of the
       * {@link qx.ui.core.queue.Widget widget queue}.
       */
      syncWidget: function syncWidget() {
        this.__desktop__P_563_0.forceUnblock();

        var windows = this.__desktop__P_563_0.getWindows(); // z-index for all three window kinds


        var zIndex = this._minZIndex;
        var zIndexOnTop = zIndex + windows.length * 2;
        var zIndexModal = zIndex + windows.length * 4; // marker if there is an active window

        var active = null;

        for (var i = 0, l = windows.length; i < l; i++) {
          var win = windows[i]; // ignore invisible windows

          if (!win.isVisible()) {
            continue;
          } // take the first window as active window


          active = active || win; // We use only every second z index to easily insert a blocker between
          // two windows
          // Modal Windows stays on top of AlwaysOnTop Windows, which stays on
          // top of Normal Windows.

          if (win.isModal()) {
            win.setZIndex(zIndexModal);

            this.__desktop__P_563_0.blockContent(zIndexModal - 1);

            zIndexModal += 2; //just activate it if it's modal

            active = win;
          } else if (win.isAlwaysOnTop()) {
            win.setZIndex(zIndexOnTop);
            zIndexOnTop += 2;
          } else {
            win.setZIndex(zIndex);
            zIndex += 2;
          } // store the active window


          if (!active.isModal() && win.isActive() || win.getZIndex() > active.getZIndex()) {
            active = win;
          }
        } //set active window or null otherwise


        this.__desktop__P_563_0.setActiveWindow(active);
      },
      // interface implementation
      bringToFront: function bringToFront(win) {
        var windows = this.__desktop__P_563_0.getWindows();

        var removed = qx.lang.Array.remove(windows, win);

        if (removed) {
          windows.push(win);
          this.updateStack();
        }
      },
      // interface implementation
      sendToBack: function sendToBack(win) {
        var windows = this.__desktop__P_563_0.getWindows();

        var removed = qx.lang.Array.remove(windows, win);

        if (removed) {
          windows.unshift(win);
          this.updateStack();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__desktop__P_563_0");
    }
  });
  qx.ui.window.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.core.MRemoteLayoutHandling": {
        "require": true
      },
      "qx.ui.core.MResizable": {
        "require": true
      },
      "qx.ui.core.MMovable": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.ui.core.FocusHandler": {
        "construct": true
      },
      "qx.ui.window.Manager": {
        "require": true
      },
      "qx.ui.window.IDesktop": {},
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.basic.Label": {},
      "qx.ui.layout.Grid": {},
      "qx.ui.basic.Image": {},
      "qx.ui.form.Button": {},
      "qx.event.type.Event": {},
      "qx.bom.client.Engine": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A window widget
   *
   * More information can be found in the package description {@link qx.ui.window}.
   *
   * @childControl statusbar {qx.ui.container.Composite} statusbar container which shows the statusbar text
   * @childControl statusbar-text {qx.ui.basic.Label} text of the statusbar
   * @childControl pane {qx.ui.container.Composite} window pane which holds the content
   * @childControl captionbar {qx.ui.container.Composite} Container for all widgets inside the captionbar
   * @childControl icon {qx.ui.basic.Image} icon at the left of the captionbar
   * @childControl title {qx.ui.basic.Label} caption of the window
   * @childControl minimize-button {qx.ui.form.Button} button to minimize the window
   * @childControl restore-button {qx.ui.form.Button} button to restore the window
   * @childControl maximize-button {qx.ui.form.Button} button to maximize the window
   * @childControl close-button {qx.ui.form.Button} button to close the window
   */
  qx.Class.define("qx.ui.window.Window", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.core.MRemoteLayoutHandling, qx.ui.core.MResizable, qx.ui.core.MMovable, qx.ui.core.MContentPadding],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param caption {String?} The caption text
     * @param icon {String?} The URL of the caption bar icon
     */
    construct: function construct(caption, icon) {
      qx.ui.core.Widget.constructor.call(this); // configure internal layout

      this._setLayout(new qx.ui.layout.VBox()); // force creation of captionbar


      this._createChildControl("captionbar");

      this._createChildControl("pane"); // apply constructor parameters


      if (icon != null) {
        this.setIcon(icon);
      }

      if (caption != null) {
        this.setCaption(caption);
      } // Update captionbar


      this._updateCaptionBar(); // Activation listener


      this.addListener("pointerdown", this._onWindowPointerDown, this, true); // Focusout listener

      this.addListener("focusout", this._onWindowFocusOut, this); // Automatically add to application root.

      qx.core.Init.getApplication().getRoot().add(this); // Initialize visibility

      this.initVisibility(); // Register as root for the focus handler

      qx.ui.core.FocusHandler.getInstance().addRoot(this); // Change the resize frames appearance

      this._getResizeFrame().setAppearance("window-resize-frame");
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {Class} The default window manager class. */
      DEFAULT_MANAGER_CLASS: qx.ui.window.Manager
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired before the window is closed.
       *
       * The close action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeClose": "qx.event.type.Event",

      /** Fired if the window is closed */
      "close": "qx.event.type.Event",

      /**
       * Fired before the window is minimize.
       *
       * The minimize action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeMinimize": "qx.event.type.Event",

      /** Fired if the window is minimized */
      "minimize": "qx.event.type.Event",

      /**
       * Fired before the window is maximize.
       *
       * The maximize action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeMaximize": "qx.event.type.Event",

      /** Fired if the window is maximized */
      "maximize": "qx.event.type.Event",

      /**
       * Fired before the window is restored from a minimized or maximized state.
       *
       * The restored action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeRestore": "qx.event.type.Event",

      /** Fired if the window is restored from a minimized or maximized state */
      "restore": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /*
      ---------------------------------------------------------------------------
        INTERNAL OPTIONS
      ---------------------------------------------------------------------------
      */
      // overridden
      appearance: {
        refine: true,
        init: "window"
      },
      // overridden
      visibility: {
        refine: true,
        init: "excluded"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /**
       * If the window is active, only one window in a single qx.ui.window.Manager could
       *  have set this to true at the same time.
       */
      active: {
        check: "Boolean",
        init: false,
        apply: "_applyActive",
        event: "changeActive"
      },

      /*
      ---------------------------------------------------------------------------
        BASIC OPTIONS
      ---------------------------------------------------------------------------
      */

      /** Should the window be always on top */
      alwaysOnTop: {
        check: "Boolean",
        init: false,
        event: "changeAlwaysOnTop"
      },

      /** Should the window be modal (this disables minimize and maximize buttons) */
      modal: {
        check: "Boolean",
        init: false,
        event: "changeModal",
        apply: "_applyModal"
      },

      /** The text of the caption */
      caption: {
        apply: "_applyCaptionBarChange",
        event: "changeCaption",
        nullable: true
      },

      /** The icon of the caption */
      icon: {
        check: "String",
        nullable: true,
        apply: "_applyCaptionBarChange",
        event: "changeIcon",
        themeable: true
      },

      /** The text of the statusbar */
      status: {
        check: "String",
        nullable: true,
        apply: "_applyStatus",
        event: "changeStatus"
      },

      /*
      ---------------------------------------------------------------------------
        HIDE CAPTIONBAR FEATURES
      ---------------------------------------------------------------------------
      */

      /** Should the close button be shown */
      showClose: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange",
        themeable: true
      },

      /** Should the maximize button be shown */
      showMaximize: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange",
        themeable: true
      },

      /** Should the minimize button be shown */
      showMinimize: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange",
        themeable: true
      },

      /*
      ---------------------------------------------------------------------------
        DISABLE CAPTIONBAR FEATURES
      ---------------------------------------------------------------------------
      */

      /** Should the user have the ability to close the window */
      allowClose: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange"
      },

      /** Should the user have the ability to maximize the window */
      allowMaximize: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange"
      },

      /** Should the user have the ability to minimize the window */
      allowMinimize: {
        check: "Boolean",
        init: true,
        apply: "_applyCaptionBarChange"
      },

      /*
      ---------------------------------------------------------------------------
        STATUSBAR CONFIG
      ---------------------------------------------------------------------------
      */

      /** Should the statusbar be shown */
      showStatusbar: {
        check: "Boolean",
        init: false,
        apply: "_applyShowStatusbar"
      },

      /*
      ---------------------------------------------------------------------------
        WHEN TO AUTOMATICALY CENTER
      ---------------------------------------------------------------------------
      */

      /** Whether this window should be automatically centered when it appears */
      centerOnAppear: {
        init: false,
        check: "Boolean",
        apply: "_applyCenterOnAppear"
      },

      /** 
       * Whether this window should be automatically centered when its container
       * is resized.
       */
      centerOnContainerResize: {
        init: false,
        check: "Boolean",
        apply: "_applyCenterOnContainerResize"
      },

      /*
      ---------------------------------------------------------------------------
        CLOSE BEHAVIOR
      ---------------------------------------------------------------------------
      */

      /** 
       * Should the window be automatically destroyed when it is closed.
       *
       * When false, closing the window behaves like hiding the window.
       * 
       * When true, the window is removed from its container (the root), all
       * listeners are removed, the window's widgets are removed, and the window
       * is destroyed.
       *
       * NOTE: If any widgets that were added to this window require special
       * clean-up, you should listen on the 'close' event and remove and clean
       * up those widgets there.
       */
      autoDestroy: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {Integer} Original top value before maximation had occurred */
      __restoredTop__P_564_0: null,

      /** @type {Integer} Original left value before maximation had occurred */
      __restoredLeft__P_564_1: null,

      /** @type {Integer} Listener ID for centering on appear */
      __centeringAppearId__P_564_2: null,

      /** @type {Integer} Listener ID for centering on resize */
      __centeringResizeId__P_564_3: null,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */

      /**
       * The children container needed by the {@link qx.ui.core.MRemoteChildrenHandling}
       * mixin
       *
       * @return {qx.ui.container.Composite} pane sub widget
       */
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("pane");
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        active: true,
        maximized: true,
        showStatusbar: true,
        modal: true
      },
      // overridden
      setLayoutParent: function setLayoutParent(parent) {
        var oldParent;
        {
          parent && this.assertInterface(parent, qx.ui.window.IDesktop, "Windows can only be added to widgets, which implement the interface qx.ui.window.IDesktop. All root widgets implement this interface.");
        } // Before changing the parent, if there's a prior one, remove our resize
        // listener

        oldParent = this.getLayoutParent();

        if (oldParent && this.__centeringResizeId__P_564_3) {
          oldParent.removeListenerById(this.__centeringResizeId__P_564_3);
          this.__centeringResizeId__P_564_3 = null;
        } // Call the superclass


        qx.ui.window.Window.prototype.setLayoutParent.base.call(this, parent); // Re-add a listener for resize, if required

        if (parent && this.getCenterOnContainerResize()) {
          this.__centeringResizeId__P_564_3 = parent.addListener("resize", this.center, this);
        }
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "statusbar":
            control = new qx.ui.container.Composite(new qx.ui.layout.HBox());

            this._add(control);

            control.add(this.getChildControl("statusbar-text"));
            break;

          case "statusbar-text":
            control = new qx.ui.basic.Label();
            control.setValue(this.getStatus());
            break;

          case "pane":
            control = new qx.ui.container.Composite();

            this._add(control, {
              flex: 1
            });

            break;

          case "captionbar":
            // captionbar
            var layout = new qx.ui.layout.Grid();
            layout.setRowFlex(0, 1);
            layout.setColumnFlex(1, 1);
            control = new qx.ui.container.Composite(layout);

            this._add(control); // captionbar events


            control.addListener("dbltap", this._onCaptionPointerDblTap, this); // register as move handle

            this._activateMoveHandle(control);

            break;

          case "icon":
            control = new qx.ui.basic.Image(this.getIcon());
            this.getChildControl("captionbar").add(control, {
              row: 0,
              column: 0
            });
            break;

          case "title":
            control = new qx.ui.basic.Label(this.getCaption());
            control.setWidth(0);
            control.setAllowGrowX(true);
            var captionBar = this.getChildControl("captionbar");
            captionBar.add(control, {
              row: 0,
              column: 1
            });
            break;

          case "minimize-button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.addListener("execute", this._onMinimizeButtonTap, this);
            this.getChildControl("captionbar").add(control, {
              row: 0,
              column: 2
            });
            break;

          case "restore-button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.addListener("execute", this._onRestoreButtonTap, this);
            this.getChildControl("captionbar").add(control, {
              row: 0,
              column: 3
            });
            break;

          case "maximize-button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.addListener("execute", this._onMaximizeButtonTap, this);
            this.getChildControl("captionbar").add(control, {
              row: 0,
              column: 4
            });
            break;

          case "close-button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.addListener("execute", this._onCloseButtonTap, this);
            this.getChildControl("captionbar").add(control, {
              row: 0,
              column: 6
            });
            break;
        }

        return control || qx.ui.window.Window.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        CAPTIONBAR INTERNALS
      ---------------------------------------------------------------------------
      */

      /**
       * Updates the status and the visibility of each element of the captionbar.
       */
      _updateCaptionBar: function _updateCaptionBar() {
        var btn;
        var icon = this.getIcon();

        if (icon) {
          this.getChildControl("icon").setSource(icon);

          this._showChildControl("icon");
        } else {
          this._excludeChildControl("icon");
        }

        var caption = this.getCaption();

        if (caption) {
          this.getChildControl("title").setValue(caption);

          this._showChildControl("title");
        } else {
          this._excludeChildControl("title");
        }

        if (this.getShowMinimize()) {
          this._showChildControl("minimize-button");

          btn = this.getChildControl("minimize-button");
          this.getAllowMinimize() ? btn.resetEnabled() : btn.setEnabled(false);
        } else {
          this._excludeChildControl("minimize-button");
        }

        if (this.getShowMaximize()) {
          if (this.isMaximized()) {
            this._showChildControl("restore-button");

            this._excludeChildControl("maximize-button");
          } else {
            this._showChildControl("maximize-button");

            this._excludeChildControl("restore-button");
          }

          btn = this.getChildControl("maximize-button");
          this.getAllowMaximize() ? btn.resetEnabled() : btn.setEnabled(false);
        } else {
          this._excludeChildControl("maximize-button");

          this._excludeChildControl("restore-button");
        }

        if (this.getShowClose()) {
          this._showChildControl("close-button");

          btn = this.getChildControl("close-button");
          this.getAllowClose() ? btn.resetEnabled() : btn.setEnabled(false);
        } else {
          this._excludeChildControl("close-button");
        }
      },

      /*
      ---------------------------------------------------------------------------
        USER API
      ---------------------------------------------------------------------------
      */

      /**
       * Close the current window instance.
       *
       * Simply calls the {@link qx.ui.core.Widget#hide} method if the
       * {@link qx.ui.win.Window#autoDestroy} property is false; otherwise 
       * removes and destroys the window.
       */
      close: function close() {
        if (!this.getAutoDestroy() && !this.isVisible()) {
          return;
        }

        if (this.fireNonBubblingEvent("beforeClose", qx.event.type.Event, [false, true])) {
          this.hide();
          this.fireEvent("close");
        } // If automatically destroying the window upon close was requested, do
        // so now. (Note that we explicitly re-obtain the autoDestroy property
        // value, allowing the user's close handler to enable/disable it before
        // here.)


        if (this.getAutoDestroy()) {
          this.dispose();
        }
      },

      /**
       * Open the window.
       */
      open: function open() {
        this.show();
        this.setActive(true);
        this.focus();
      },

      /**
       * Centers the window to the parent.
       *
       * This call works with the size of the parent widget and the size of
       * the window as calculated in the last layout flush. It is best to call
       * this method just after rendering the window in the "resize" event:
       * <pre class='javascript'>
       *   win.addListenerOnce("resize", this.center, this);
       * </pre>
       */
      center: function center() {
        var parent = this.getLayoutParent();

        if (parent) {
          var bounds = parent.getBounds();

          if (bounds) {
            var hint = this.getSizeHint();
            var left = Math.round((bounds.width - hint.width) / 2);
            var top = Math.round((bounds.height - hint.height) / 2);

            if (top < 0) {
              top = 0;
            }

            this.moveTo(left, top);
            return;
          }
        }

        {
          this.warn("Centering depends on parent bounds!");
        }
      },

      /**
       * Maximize the window.
       */
      maximize: function maximize() {
        // If the window is already maximized -> return
        if (this.isMaximized()) {
          return;
        } // First check if the parent uses a canvas layout
        // Otherwise maximize() is not possible


        var parent = this.getLayoutParent();

        if (parent != null && parent.supportsMaximize()) {
          if (this.fireNonBubblingEvent("beforeMaximize", qx.event.type.Event, [false, true])) {
            if (!this.isVisible()) {
              this.open();
            } // store current dimension and location


            var props = this.getLayoutProperties();
            this.__restoredLeft__P_564_1 = props.left === undefined ? 0 : props.left;
            this.__restoredTop__P_564_0 = props.top === undefined ? 0 : props.top; // Update layout properties

            this.setLayoutProperties({
              left: null,
              top: null,
              edge: 0
            }); // Add state

            this.addState("maximized"); // Update captionbar

            this._updateCaptionBar(); // Fire user event


            this.fireEvent("maximize");
          }
        }
      },

      /**
       * Minimized the window.
       */
      minimize: function minimize() {
        if (!this.isVisible()) {
          return;
        }

        if (this.fireNonBubblingEvent("beforeMinimize", qx.event.type.Event, [false, true])) {
          // store current dimension and location
          var props = this.getLayoutProperties();
          this.__restoredLeft__P_564_1 = props.left === undefined ? 0 : props.left;
          this.__restoredTop__P_564_0 = props.top === undefined ? 0 : props.top;
          this.removeState("maximized");
          this.hide();
          this.fireEvent("minimize");
        }
      },

      /**
       * Restore the window to <code>"normal"</code>, if it is
       * <code>"maximized"</code> or <code>"minimized"</code>.
       */
      restore: function restore() {
        if (this.getMode() === "normal") {
          return;
        }

        if (this.fireNonBubblingEvent("beforeRestore", qx.event.type.Event, [false, true])) {
          if (!this.isVisible()) {
            this.open();
          } // Restore old properties


          var left = this.__restoredLeft__P_564_1;
          var top = this.__restoredTop__P_564_0;
          this.setLayoutProperties({
            edge: null,
            left: left,
            top: top
          }); // Remove maximized state

          this.removeState("maximized"); // Update captionbar

          this._updateCaptionBar(); // Fire user event


          this.fireEvent("restore");
        }
      },

      /**
       * Set the window's position relative to its parent
       *
       * @param left {Integer} The left position
       * @param top {Integer} The top position
       */
      moveTo: function moveTo(left, top) {
        if (this.isMaximized()) {
          return;
        }

        this.setLayoutProperties({
          left: left,
          top: top
        });
      },

      /**
       * Return <code>true</code> if the window is in maximized state,
       * but note that the window in maximized state could also be invisible, this
       * is equivalent to minimized. So use the {@link qx.ui.window.Window#getMode}
       * to get the window mode.
       *
       * @return {Boolean} <code>true</code> if the window is maximized,
       *   <code>false</code> otherwise.
       */
      isMaximized: function isMaximized() {
        return this.hasState("maximized");
      },

      /**
       * Return the window mode as <code>String</code>:
       * <code>"maximized"</code>, <code>"normal"</code> or <code>"minimized"</code>.
       *
       * @return {String} The window mode as <code>String</code> value.
       */
      getMode: function getMode() {
        if (!this.isVisible()) {
          return "minimized";
        } else {
          if (this.isMaximized()) {
            return "maximized";
          } else {
            return "normal";
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyActive: function _applyActive(value, old) {
        if (old) {
          this.removeState("active");
        } else {
          this.addState("active");
        }
      },
      // property apply
      _applyModal: function _applyModal(value, old) {
        if (old) {
          this.removeState("modal");
        } else {
          this.addState("modal");
        }
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getChildControl("pane");
      },
      // property apply
      _applyShowStatusbar: function _applyShowStatusbar(value, old) {
        // store the state if the status bar is shown
        var resizeFrame = this._getResizeFrame();

        if (value) {
          this.addState("showStatusbar");
          resizeFrame.addState("showStatusbar");
        } else {
          this.removeState("showStatusbar");
          resizeFrame.removeState("showStatusbar");
        }

        if (value) {
          this._showChildControl("statusbar");
        } else {
          this._excludeChildControl("statusbar");
        }
      },
      // property apply
      _applyCaptionBarChange: function _applyCaptionBarChange(value, old) {
        this._updateCaptionBar();
      },
      // property apply
      _applyStatus: function _applyStatus(value, old) {
        var label = this.getChildControl("statusbar-text", true);

        if (label) {
          label.setValue(value);
        }
      },
      // overridden
      _applyFocusable: function _applyFocusable(value, old) {
        // Workaround for bug #7581: Don't set the tabIndex
        // to prevent native scrolling on focus in IE
        if (qx.core.Environment.get("engine.name") !== "mshtml") {
          qx.ui.window.Window.prototype._applyFocusable.base.call(this, value, old);
        }
      },
      _applyCenterOnAppear: function _applyCenterOnAppear(value, old) {
        // Remove prior listener for centering on appear
        if (this.__centeringAppearId__P_564_2 !== null) {
          this.removeListenerById(this.__centeringAppearId__P_564_2);
          this.__centeringAppearId__P_564_2 = null;
        } // If we are to center on appear, arrange to do so


        if (value) {
          this.__centeringAppearId__P_564_2 = this.addListener("appear", this.center, this);
        }
      },
      _applyCenterOnContainerResize: function _applyCenterOnContainerResize(value, old) {
        var parent = this.getLayoutParent(); // Remove prior listener for centering on resize

        if (this.__centeringResizeId__P_564_3 !== null) {
          parent.removeListenerById(this.__centeringResizeId__P_564_3);
          this.__centeringResizeId__P_564_3 = null;
        } // If we are to center on resize, arrange to do so


        if (value) {
          if (parent) {
            this.__centeringResizeId__P_564_3 = parent.addListener("resize", this.center, this);
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        BASIC EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Stops every event
       *
       * @param e {qx.event.type.Event} any event
       */
      _onWindowEventStop: function _onWindowEventStop(e) {
        e.stopPropagation();
      },

      /**
       * Focuses the window instance.
       *
       * @param e {qx.event.type.Pointer} pointer down event
       */
      _onWindowPointerDown: function _onWindowPointerDown(e) {
        this.setActive(true);
      },

      /**
       * Listens to the "focusout" event to deactivate the window (if the
       * currently focused widget is not a child of the window)
       *
       * @param e {qx.event.type.Focus} focus event
       */
      _onWindowFocusOut: function _onWindowFocusOut(e) {
        // only needed for non-modal windows
        if (this.getModal()) {
          return;
        } // get the current focused widget and check if it is a child


        var current = e.getRelatedTarget();

        if (current != null && !qx.ui.core.Widget.contains(this, current)) {
          this.setActive(false);
        }
      },

      /**
       * Maximizes the window or restores it if it is already
       * maximized.
       *
       * @param e {qx.event.type.Pointer} double tap event
       */
      _onCaptionPointerDblTap: function _onCaptionPointerDblTap(e) {
        if (this.getAllowMaximize() && (e.getTarget() === this.getChildControl("captionbar") || e.getTarget() === this.getChildControl("title"))) {
          this.isMaximized() ? this.restore() : this.maximize();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENTS FOR CAPTIONBAR BUTTONS
      ---------------------------------------------------------------------------
      */

      /**
       * Minimizes the window, removes all states from the minimize button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Pointer} pointer tap event
       */
      _onMinimizeButtonTap: function _onMinimizeButtonTap(e) {
        this.minimize();
        this.getChildControl("minimize-button").reset();
      },

      /**
       * Restores the window, removes all states from the restore button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Pointer} pointer pointer event
       */
      _onRestoreButtonTap: function _onRestoreButtonTap(e) {
        this.restore();
        this.getChildControl("restore-button").reset();
      },

      /**
       * Maximizes the window, removes all states from the maximize button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Pointer} pointer pointer event
       */
      _onMaximizeButtonTap: function _onMaximizeButtonTap(e) {
        this.maximize();
        this.getChildControl("maximize-button").reset();
      },

      /**
       * Closes the window, removes all states from the close button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Pointer} pointer pointer event
       */
      _onCloseButtonTap: function _onCloseButtonTap(e) {
        this.close();
        this.getChildControl("close-button").reset();
      }
    },
    destruct: function destruct() {
      var id;
      var parent; // Remove ourselves from the focus handler

      qx.ui.core.FocusHandler.getInstance().removeRoot(this); // If we haven't been removed from our parent, clean it up too.

      parent = this.getLayoutParent();

      if (parent) {
        // Remove the listener for resize, if there is one
        id = this.__centeringResizeId__P_564_3;
        id && parent.removeListenerById(id); // Remove ourself from our parent

        parent.remove(this);
      }
    }
  });
  qx.ui.window.Window.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IColorForm": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.groupbox.GroupBox": {},
      "qx.ui.layout.Canvas": {},
      "qx.ui.basic.Image": {},
      "qx.ui.layout.Grow": {},
      "qx.ui.layout.Grid": {},
      "qx.ui.basic.Label": {},
      "qx.ui.form.TextField": {},
      "qx.ui.form.Spinner": {},
      "qx.util.ColorUtil": {},
      "qx.lang.Number": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
       * Matthew Gregory
  
  ************************************************************************ */

  /**
   * A typical color selector as known from native applications.
   *
   * Includes support for RGB and HSB color areas.
   *
   * @childControl control-bar {qx.ui.container.Composite} container which holds the control-pane and visual-pane
   * @childControl visual-pane {qx.ui.groupbox.GroupBox} pane shows the hue-saturation-pane and the brightness-pane
   * @childControl hue-saturation-pane {qx.ui.container.Composite} shows the hue saturation and the handle to select
   * @childControl hue-saturation-field {qx.ui.basic.Image} hue saturation image which shows all available colors
   * @childControl hue-saturation-handle {qx.ui.basic.Image} handle to select the color using the pointer
   * @childControl brightness-pane {qx.ui.container.Composite} shows the brightness field and the handle to select
   * @childControl brightness-field {qx.ui.basic.Image} brightness image which shows all brightness steps
   * @childControl brightness-handle {qx.ui.basic.Image} brightness handle to select the brightness using the pointer
   * @childControl preset-field-set {qx.ui.groupbox.GroupBox} groupbox holding all preset colors
   * @childControl colorbucket {qx.ui.core.Widget} color bucket
   * @childControl preset-grid {qx.ui.container.Composite} container for all color presets
   * @childControl input-field-set {qx.ui.groupbox.GroupBox} groupbox holding different input elements
   * @childControl preview-field-set {qx.ui.groupbox.GroupBox} groupbox holding the two preview fields
   * @childControl hex-field-composite {qx.ui.container.Composite} container for the hex field
   * @childControl hex-field {qx.ui.form.TextField} textfield to input a hex value
   * @childControl rgb-spinner-composite {qx.ui.container.Composite} container for the rgb spinner
   * @childControl rgb-spinner-red {qx.ui.form.Spinner} spinner control for the red hex value
   * @childControl rgb-spinner-green {qx.ui.form.Spinner} spinner control for the green hex value
   * @childControl rgb-spinner-blue {qx.ui.form.Spinner} spinner control for the blue hex value
   * @childControl hsb-spinner-composite {qx.ui.container.Composite} container for the hsb spinners
   * @childControl hsb-spinner-hue {qx.ui.form.Spinner} spinner control for the huevalue
   * @childControl hsb-spinner-saturation {qx.ui.form.Spinner} spinner control for the saturation value
   * @childControl hsb-spinner-brightness {qx.ui.form.Spinner} spinner control for the brightness value
   * @childControl preview-content-old {qx.ui.core.Widget} preview of the old color
   * @childControl preview-content-new {qx.ui.core.Widget} preview of the new color
   */
  qx.Class.define("qx.ui.control.ColorSelector", {
    extend: qx.ui.core.Widget,
    implement: [qx.ui.form.IColorForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Creates a ColorSelector.
     */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // add the basic layout

      this._setLayout(new qx.ui.layout.VBox());

      this._createChildControl("control-bar");

      this.addListener("appear", this._onAppear, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the "OK" button is tapped. */
      "dialogok": "qx.event.type.Event",

      /** Fired when the "Cancel" button is tapped. */
      "dialogcancel": "qx.event.type.Event",

      /** Fired when the value changes */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "colorselector"
      },

      /** The numeric red value of the selected color. */
      red: {
        check: "Integer",
        init: 255,
        apply: "_applyRed"
      },

      /** The numeric green value of the selected color. */
      green: {
        check: "Integer",
        init: 255,
        apply: "_applyGreen"
      },

      /** The numeric blue value of the selected color. */
      blue: {
        check: "Integer",
        init: 255,
        apply: "_applyBlue"
      },

      /** The numeric hue value. */
      hue: {
        check: "Number",
        init: 0,
        apply: "_applyHue"
      },

      /** The numeric saturation value. */
      saturation: {
        check: "Number",
        init: 0,
        apply: "_applySaturation"
      },

      /** The numeric brightness value. */
      brightness: {
        check: "Number",
        init: 100,
        apply: "_applyBrightness"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        CONTEXT HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * @type {String} The context in which an update has occurred.
       */
      __updateContext__P_370_0: null,

      /**
       * @type {Array} Map containing the preset colors.
       * @lint ignoreReferenceField(__presetTable)
       */
      __presetTable__P_370_1: ["maroon", "red", "orange", "yellow", "olive", "purple", "fuchsia", "lime", "green", "navy", "blue", "aqua", "teal", "black", "#333", "#666", "#999", "#BBB", "#EEE", "white"],

      /**
       * @type {String} Name of child control which is captured.
       */
      __capture__P_370_2: "",

      /**
       * @type {Number} Numeric brightness value
       */
      __brightnessSubtract__P_370_3: 0,

      /**
       * @type {Integer} HueSaturation's X coordinate
       */
      __hueSaturationSubtractTop__P_370_4: 0,

      /**
       * @type {Integer} HueSaturation's Y coordinate
       */
      __hueSaturationSubtractLeft__P_370_5: 0,
      // internal boolean flag to signal, that the value is set to null
      __nullValue__P_370_6: true,
      // internal mutex to prevent the changeValue event to be fired too often
      __preventChangeValueEvent__P_370_7: false,
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          /*
          ---------------------------------------------------------------------------
            CREATE #1: BASE STRUCTURE
          ---------------------------------------------------------------------------
          */
          case "control-bar":
            control = new qx.ui.container.Composite(new qx.ui.layout.HBox(10));
            control.add(this.getChildControl("control-pane"));
            control.add(this.getChildControl("visual-pane"));

            this._add(control);

            break;

          /*
          ---------------------------------------------------------------------------
            CREATE #2: PANES
          ---------------------------------------------------------------------------
          */

          case "visual-pane":
            control = new qx.ui.groupbox.GroupBox(this.tr("Visual"));
            control.setLayout(new qx.ui.layout.HBox(10));
            control.add(this.getChildControl("hue-saturation-pane"));
            control.add(this.getChildControl("brightness-pane"));
            break;

          case "control-pane":
            control = new qx.ui.container.Composite(new qx.ui.layout.VBox(0));
            control.add(this.getChildControl("preset-field-set"));
            control.add(this.getChildControl("input-field-set"));
            control.add(this.getChildControl("preview-field-set"), {
              flex: 1
            });
            break;

          case "hue-saturation-pane":
            control = new qx.ui.container.Composite(new qx.ui.layout.Canvas());
            control.setAllowGrowY(false);
            control.addListener("roll", this._onHueSaturationPaneRoll, this);
            control.add(this.getChildControl("hue-saturation-field"));
            control.add(this.getChildControl("hue-saturation-handle"), {
              left: 0,
              top: 256
            });
            break;

          case "hue-saturation-field":
            control = new qx.ui.basic.Image("decoration/colorselector/huesaturation-field.jpg");
            control.addListener("pointerdown", this._onHueSaturationFieldPointerDown, this);
            break;

          case "hue-saturation-handle":
            control = new qx.ui.basic.Image("decoration/colorselector/huesaturation-handle.gif");
            control.addListener("pointerdown", this._onHueSaturationFieldPointerDown, this);
            control.addListener("pointerup", this._onHueSaturationHandlePointerUp, this);
            control.addListener("pointermove", this._onHueSaturationHandlePointerMove, this);
            break;

          case "brightness-pane":
            control = new qx.ui.container.Composite(new qx.ui.layout.Canvas());
            control.setAllowGrowY(false);
            control.addListener("roll", this._onBrightnessPaneRoll, this);
            control.add(this.getChildControl("brightness-field"));
            control.add(this.getChildControl("brightness-handle"));
            break;

          case "brightness-field":
            control = new qx.ui.basic.Image("decoration/colorselector/brightness-field.png");
            control.addListener("pointerdown", this._onBrightnessFieldPointerDown, this);
            break;

          case "brightness-handle":
            control = new qx.ui.basic.Image("decoration/colorselector/brightness-handle.gif");
            control.addListener("pointerdown", this._onBrightnessHandlePointerDown, this);
            control.addListener("pointerup", this._onBrightnessHandlePointerUp, this);
            control.addListener("pointermove", this._onBrightnessHandlePointerMove, this);
            break;

          /*
          ---------------------------------------------------------------------------
            CREATE #3: CONTROL PANE CONTENT
          ---------------------------------------------------------------------------
          */

          case "preset-field-set":
            control = new qx.ui.groupbox.GroupBox(this.tr("Presets"));
            control.setLayout(new qx.ui.layout.Grow());
            control.add(this.getChildControl("preset-grid"));
            break;

          case "colorbucket":
            control = new qx.ui.core.Widget();
            control.addListener("pointerdown", this._onColorFieldTap, this);
            break;

          case "preset-grid":
            controlLayout = new qx.ui.layout.Grid(3, 3);
            control = new qx.ui.container.Composite(controlLayout);
            var colorField;
            var colorPos;

            for (var i = 0; i < 2; i++) {
              for (var j = 0; j < 10; j++) {
                colorPos = i * 10 + j;
                colorField = this.getChildControl("colorbucket#" + colorPos);
                colorField.setBackgroundColor(this.__presetTable__P_370_1[colorPos]);
                control.add(colorField, {
                  column: j,
                  row: i
                });
              }
            }

            break;

          case "input-field-set":
            control = new qx.ui.groupbox.GroupBox(this.tr("Details"));
            var controlLayout = new qx.ui.layout.VBox();
            controlLayout.setSpacing(10);
            control.setLayout(controlLayout);
            control.add(this.getChildControl("hex-field-composite"));
            control.add(this.getChildControl("rgb-spinner-composite"));
            control.add(this.getChildControl("hsb-spinner-composite"));
            break;

          case "preview-field-set":
            control = new qx.ui.groupbox.GroupBox(this.tr("Preview (Old/New)"));
            var controlLayout = new qx.ui.layout.HBox(10);
            control.setLayout(controlLayout);
            control.add(this.getChildControl("preview-content-old"), {
              flex: 1
            });
            control.add(this.getChildControl("preview-content-new"), {
              flex: 1
            });
            break;

          /*
          ---------------------------------------------------------------------------
            CREATE #4: INPUT FIELDSET CONTENT
          ---------------------------------------------------------------------------
          */

          case "hex-field-composite":
            var layout = new qx.ui.layout.HBox(4);
            layout.setAlignY("middle");
            control = new qx.ui.container.Composite(layout);
            var hexLabel = new qx.ui.basic.Label(this.tr("Hex"));
            hexLabel.setWidth(30);
            control.add(hexLabel);
            var hexHelper = new qx.ui.basic.Label("#");
            control.add(hexHelper);
            control.add(this.getChildControl("hex-field"));
            break;

          case "hex-field":
            control = new qx.ui.form.TextField("FFFFFF");
            control.setMaxLength(6);
            control.setFilter(/[0-9A-Fa-f]/);
            control.setWidth(55);
            control.addListener("changeValue", this._onHexFieldChange, this);
            break;

          case "rgb-spinner-composite":
            var layout = new qx.ui.layout.HBox(4);
            layout.setAlignY("middle");
            control = new qx.ui.container.Composite(layout);
            var rgbSpinLabel = new qx.ui.basic.Label(this.tr("RGB"));
            rgbSpinLabel.setWidth(30);
            control.add(rgbSpinLabel);
            control.add(this.getChildControl("rgb-spinner-red"));
            control.add(this.getChildControl("rgb-spinner-green"));
            control.add(this.getChildControl("rgb-spinner-blue"));
            break;

          case "rgb-spinner-red":
            control = new qx.ui.form.Spinner(0, 255, 255);
            control.setWidth(50);
            control.addListener("changeValue", this._setRedFromSpinner, this);
            break;

          case "rgb-spinner-green":
            control = new qx.ui.form.Spinner(0, 255, 255);
            control.setWidth(50);
            control.addListener("changeValue", this._setGreenFromSpinner, this);
            break;

          case "rgb-spinner-blue":
            control = new qx.ui.form.Spinner(0, 255, 255);
            control.setWidth(50);
            control.addListener("changeValue", this._setBlueFromSpinner, this);
            break;

          case "hsb-spinner-composite":
            var layout = new qx.ui.layout.HBox(4);
            layout.setAlignY("middle");
            control = new qx.ui.container.Composite(layout);
            var hsbSpinLabel = new qx.ui.basic.Label(this.tr("HSB"));
            hsbSpinLabel.setWidth(30);
            control.add(hsbSpinLabel);
            control.add(this.getChildControl("hsb-spinner-hue"));
            control.add(this.getChildControl("hsb-spinner-saturation"));
            control.add(this.getChildControl("hsb-spinner-brightness"));
            break;

          case "hsb-spinner-hue":
            control = new qx.ui.form.Spinner(0, 0, 360);
            control.setWidth(50);
            control.addListener("changeValue", this._setHueFromSpinner, this);
            break;

          case "hsb-spinner-saturation":
            control = new qx.ui.form.Spinner(0, 0, 100);
            control.setWidth(50);
            control.addListener("changeValue", this._setSaturationFromSpinner, this);
            break;

          case "hsb-spinner-brightness":
            control = new qx.ui.form.Spinner(0, 100, 100);
            control.setWidth(50);
            control.addListener("changeValue", this._setBrightnessFromSpinner, this);
            break;

          /*
          ---------------------------------------------------------------------------
            CREATE #5: PREVIEW CONTENT
          ---------------------------------------------------------------------------
          */

          case "preview-content-old":
            control = new qx.ui.core.Widget();
            break;

          case "preview-content-new":
            control = new qx.ui.core.Widget();
            break;
        }

        return control || qx.ui.control.ColorSelector.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * The value of the ColorSelector is a string containing the HEX value of
       * the currently selected color. Take a look at
       * {@link qx.util.ColorUtil#stringToRgb} to see what kind of input the
       * method can handle.
       *
       * @param value {String} The value of a color.
       */
      setValue: function setValue(value) {
        var rgb;

        if (value == null) {
          this.__nullValue__P_370_6 = true;
          rgb = [255, 255, 255];
        } else {
          rgb = qx.util.ColorUtil.stringToRgb(value);
          this.__nullValue__P_370_6 = false;
        } // block the first tow events


        this.__preventChangeValueEvent__P_370_7 = true;
        this.setRed(rgb[0]);
        this.setGreen(rgb[1]); // only allow the final change event

        this.__preventChangeValueEvent__P_370_7 = false;
        this.setBlue(rgb[2]);
      },

      /**
       * Returns the currently selected color.
       *
       * @return {String | null} The HEX value of the color of if not color
       *   is set, null.
       */
      getValue: function getValue() {
        return this.__nullValue__P_370_6 ? null : qx.util.ColorUtil.rgbToHexString([this.getRed(), this.getGreen(), this.getBlue()]);
      },

      /**
       * Resets the color to null.
       */
      resetValue: function resetValue() {
        this.__nullValue__P_370_6 = true;
        this.__preventChangeValueEvent__P_370_7 = true;
        this.setRed(255);
        this.setGreen(255);
        this.__preventChangeValueEvent__P_370_7 = false;
        this.setBlue(255);
      },

      /**
       * Helper for firing the changeValue event and checking for the mutex.
       */
      __fireChangeValueEvent__P_370_8: function __fireChangeValueEvent__P_370_8() {
        if (!this.__preventChangeValueEvent__P_370_7) {
          this.__nullValue__P_370_6 = false;
          this.fireDataEvent("changeValue", this.getValue());
        }
      },

      /*
      ---------------------------------------------------------------------------
        RGB MODIFIER
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyRed: function _applyRed(value, old) {
        if (this.__updateContext__P_370_0 === null) {
          this.__updateContext__P_370_0 = "redModifier";
        }

        if (this.__updateContext__P_370_0 !== "rgbSpinner") {
          this.getChildControl("rgb-spinner-red").setValue(value);
        }

        if (this.__updateContext__P_370_0 !== "hexField") {
          this._setHexFromRgb();
        }

        switch (this.__updateContext__P_370_0) {
          case "rgbSpinner":
          case "hexField":
          case "redModifier":
            this._setHueFromRgb();

        }

        this._setPreviewFromRgb();

        this.__fireChangeValueEvent__P_370_8();

        if (this.__updateContext__P_370_0 === "redModifier") {
          this.__updateContext__P_370_0 = null;
        }
      },
      // property apply
      _applyGreen: function _applyGreen(value, old) {
        if (this.__updateContext__P_370_0 === null) {
          this.__updateContext__P_370_0 = "greenModifier";
        }

        if (this.__updateContext__P_370_0 !== "rgbSpinner") {
          this.getChildControl("rgb-spinner-green").setValue(value);
        }

        if (this.__updateContext__P_370_0 !== "hexField") {
          this._setHexFromRgb();
        }

        switch (this.__updateContext__P_370_0) {
          case "rgbSpinner":
          case "hexField":
          case "greenModifier":
            this._setHueFromRgb();

        }

        this._setPreviewFromRgb();

        this.__fireChangeValueEvent__P_370_8();

        if (this.__updateContext__P_370_0 === "greenModifier") {
          this.__updateContext__P_370_0 = null;
        }
      },
      // property apply
      _applyBlue: function _applyBlue(value, old) {
        if (this.__updateContext__P_370_0 === null) {
          this.__updateContext__P_370_0 = "blueModifier";
        }

        if (this.__updateContext__P_370_0 !== "rgbSpinner") {
          this.getChildControl("rgb-spinner-blue").setValue(value);
        }

        if (this.__updateContext__P_370_0 !== "hexField") {
          this._setHexFromRgb();
        }

        switch (this.__updateContext__P_370_0) {
          case "rgbSpinner":
          case "hexField":
          case "blueModifier":
            this._setHueFromRgb();

        }

        this._setPreviewFromRgb();

        this.__fireChangeValueEvent__P_370_8();

        if (this.__updateContext__P_370_0 === "blueModifier") {
          this.__updateContext__P_370_0 = null;
        }
      },

      /*
      ---------------------------------------------------------------------------
        HSB MODIFIER
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyHue: function _applyHue(value, old) {
        if (this.__updateContext__P_370_0 === null) {
          this.__updateContext__P_370_0 = "hueModifier";
        }

        if (this.__updateContext__P_370_0 !== "hsbSpinner") {
          this.getChildControl("hsb-spinner-hue").setValue(value);
        }

        if (this.__updateContext__P_370_0 !== "hueSaturationField") {
          if (this.getChildControl("hue-saturation-handle").getBounds()) {
            this.getChildControl("hue-saturation-handle").setDomLeft(Math.round(value / 1.40625) + this.getChildControl("hue-saturation-pane").getPaddingLeft());
          } else {
            this.getChildControl("hue-saturation-handle").setLayoutProperties({
              left: Math.round(value / 1.40625)
            });
          }
        }

        switch (this.__updateContext__P_370_0) {
          case "hsbSpinner":
          case "hueSaturationField":
          case "hueModifier":
            this._setRgbFromHue();

        }

        this._setBrightnessGradiant();

        if (this.__updateContext__P_370_0 === "hueModifier") {
          this.__updateContext__P_370_0 = null;
        }
      },
      // property apply
      _applySaturation: function _applySaturation(value, old) {
        if (this.__updateContext__P_370_0 === null) {
          this.__updateContext__P_370_0 = "saturationModifier";
        }

        if (this.__updateContext__P_370_0 !== "hsbSpinner") {
          this.getChildControl("hsb-spinner-saturation").setValue(value);
        }

        if (this.__updateContext__P_370_0 !== "hueSaturationField") {
          this._setBrightnessGradiant();

          if (this.getChildControl("hue-saturation-handle").getBounds()) {
            this.getChildControl("hue-saturation-handle").setDomTop(256 - Math.round(value * 2.56) + this.getChildControl("hue-saturation-pane").getPaddingTop());
          } else {
            this.getChildControl("hue-saturation-handle").setLayoutProperties({
              top: 256 - Math.round(value * 2.56)
            });
          }
        }

        switch (this.__updateContext__P_370_0) {
          case "hsbSpinner":
          case "hueSaturationField":
          case "saturationModifier":
            this._setRgbFromHue();

        }

        if (this.__updateContext__P_370_0 === "saturationModifier") {
          this.__updateContext__P_370_0 = null;
        }
      },
      // property apply
      _applyBrightness: function _applyBrightness(value, old) {
        if (this.__updateContext__P_370_0 === null) {
          this.__updateContext__P_370_0 = "brightnessModifier";
        }

        if (this.__updateContext__P_370_0 !== "hsbSpinner") {
          this.getChildControl("hsb-spinner-brightness").setValue(value);
        }

        if (this.__updateContext__P_370_0 !== "brightnessField") {
          var topValue = 256 - Math.round(value * 2.56);

          if (this.getChildControl("brightness-handle").getBounds()) {
            this.getChildControl("brightness-handle").setDomTop(topValue + this.getChildControl("brightness-pane").getPaddingTop());
          } else {
            this.getChildControl("brightness-handle").setLayoutProperties({
              top: topValue
            });
          }
        }

        switch (this.__updateContext__P_370_0) {
          case "hsbSpinner":
          case "brightnessField":
          case "brightnessModifier":
            this._setRgbFromHue();

        }

        if (this.__updateContext__P_370_0 === "brightnessModifier") {
          this.__updateContext__P_370_0 = null;
        }
      },

      /*
      ---------------------------------------------------------------------------
        BRIGHTNESS IMPLEMENTATION
      ---------------------------------------------------------------------------
      */

      /**
       * Listener of pointerdown event on the brightness handle.
       * Adjusts the color by changing the brightness.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onBrightnessHandlePointerDown: function _onBrightnessHandlePointerDown(e) {
        // Activate Capturing
        this.getChildControl("brightness-handle").capture();
        this.__capture__P_370_2 = "brightness-handle"; // Calculate subtract: Position of Brightness Field - Current Pointer Offset

        var locationBrightnessField = this.getChildControl("brightness-field").getContentLocation();
        var locationBrightnessHandle = this.getChildControl("brightness-handle").getContentLocation();
        var fieldBounds = this.getChildControl("brightness-field").getBounds();
        this.__brightnessSubtract__P_370_3 = locationBrightnessField.top + (e.getDocumentTop() - locationBrightnessHandle.top) - fieldBounds.top; // Block field event handling

        e.stopPropagation();
      },

      /**
       * Listener of pointerup event on the brightness handle.
       * Releases the capture.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onBrightnessHandlePointerUp: function _onBrightnessHandlePointerUp(e) {
        // Disabling capturing
        this.getChildControl("brightness-handle").releaseCapture();
        this.__capture__P_370_2 = null;
      },

      /**
       * Listener of pointermove event on the brightness handle.
       * Forwards the event to _setBrightnessOnFieldEvent().
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onBrightnessHandlePointerMove: function _onBrightnessHandlePointerMove(e) {
        // Update if captured currently (through previous pointerdown)
        if (this.__capture__P_370_2 === "brightness-handle") {
          this._setBrightnessOnFieldEvent(e);

          e.stopPropagation();
        }
      },

      /**
       * Listener of pointerdown event on the brightness field.
       * Adjusts the color by changing the brightness.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onBrightnessFieldPointerDown: function _onBrightnessFieldPointerDown(e) {
        // Calculate substract: Half height of handler
        var location = this.getChildControl("brightness-field").getContentLocation();
        var bounds = this.getChildControl("brightness-handle").getBounds();
        this.__brightnessSubtract__P_370_3 = location.top + bounds.height / 2; // Update

        this._setBrightnessOnFieldEvent(e); // Afterwards: Activate Capturing for handle


        this.getChildControl("brightness-handle").capture();
        this.__capture__P_370_2 = "brightness-handle";
      },

      /**
       * Listener of roll event on the brightness pane.
       * Adjusts the color by changing the brightness.
       *
       * @param e {qx.event.type.Roll} Incoming event object
       */
      _onBrightnessPaneRoll: function _onBrightnessPaneRoll(e) {
        e.stop(); // only wheel

        if (e.getPointerType() != "wheel") {
          return;
        }

        this.setBrightness(qx.lang.Number.limit(this.getBrightness() - e.getDelta().y / 10, 0, 100));
      },

      /**
       * Sets the brightness and moves the brightness handle.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _setBrightnessOnFieldEvent: function _setBrightnessOnFieldEvent(e) {
        var value = qx.lang.Number.limit(e.getDocumentTop() - this.__brightnessSubtract__P_370_3, 0, 256);
        this.__updateContext__P_370_0 = "brightnessField";

        if (this.getChildControl("brightness-handle").getBounds()) {
          this.getChildControl("brightness-handle").setDomTop(value);
        } else {
          this.getChildControl("brightness-handle").setLayoutProperties({
            top: value
          });
        }

        this.setBrightness(100 - Math.round(value / 2.56));
        this.__updateContext__P_370_0 = null;
      },

      /*
      ---------------------------------------------------------------------------
        HUE/SATURATION IMPLEMENTATION
      ---------------------------------------------------------------------------
      */

      /**
       * Listener of pointerup event on the saturation handle.
       * Releases pointer capture.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onHueSaturationHandlePointerUp: function _onHueSaturationHandlePointerUp(e) {
        // Disabling capturing
        if (this.__capture__P_370_2) {
          e.stopPropagation();
          this.getChildControl("hue-saturation-handle").releaseCapture();
          this.__capture__P_370_2 = null;
        }
      },

      /**
       * Listener of pointermove event on the saturation handle.
       * Forwards the event to _onHueSaturationHandlePointerMove().
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onHueSaturationHandlePointerMove: function _onHueSaturationHandlePointerMove(e) {
        // Update if captured currently (through previous pointerdown)
        if (this.__capture__P_370_2 === "hue-saturation-handle") {
          this._setHueSaturationOnFieldEvent(e);

          e.stopPropagation();
        }
      },

      /**
       * Listener of pointerdown event on the saturation field.
       * Adjusts the color by changing the saturation.
       * Sets pointer capture.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onHueSaturationFieldPointerDown: function _onHueSaturationFieldPointerDown(e) {
        // Calculate substract: Half width/height of handler
        var location = this.getChildControl("hue-saturation-field").getContentLocation();
        var handleBounds = this.getChildControl("hue-saturation-handle").getBounds();
        var fieldBounds = this.getChildControl("hue-saturation-field").getBounds();
        this.__hueSaturationSubtractTop__P_370_4 = location.top + handleBounds.height / 2 - fieldBounds.top;
        this.__hueSaturationSubtractLeft__P_370_5 = location.left + handleBounds.width / 2 - fieldBounds.left; // Update

        this._setHueSaturationOnFieldEvent(e); // Afterwards: Activate Capturing for handle


        this.getChildControl("hue-saturation-handle").capture();
        this.__capture__P_370_2 = "hue-saturation-handle";
      },

      /**
       * Listener of roll event on the saturation pane.
       * Adjusts the color by changing the saturation.
       *
       * @param e {qx.event.type.Roll} Incoming event object
       */
      _onHueSaturationPaneRoll: function _onHueSaturationPaneRoll(e) {
        e.stop(); // only wheel

        if (e.getPointerType() != "wheel") {
          return;
        }

        var delta = e.getDelta();
        this.setSaturation(qx.lang.Number.limit(this.getSaturation() - delta.y / 10, 0, 100));
        this.setHue(qx.lang.Number.limit(this.getHue() + delta.x / 10, 0, 360));
      },

      /**
       * Sets the saturation and moves the saturation handle.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _setHueSaturationOnFieldEvent: function _setHueSaturationOnFieldEvent(e) {
        var vTop = qx.lang.Number.limit(e.getDocumentTop() - this.__hueSaturationSubtractTop__P_370_4, 0, 256);
        var vLeft = qx.lang.Number.limit(e.getDocumentLeft() - this.__hueSaturationSubtractLeft__P_370_5, 0, 256);
        this.getChildControl("hue-saturation-handle").setDomPosition(vLeft, vTop);
        this.__updateContext__P_370_0 = "hueSaturationField";
        this.setSaturation(100 - Math.round(vTop / 2.56));
        this.setHue(Math.round(vLeft * 1.40625));
        this.__updateContext__P_370_0 = null;
      },

      /*
      ---------------------------------------------------------------------------
        RGB SPINNER
      ---------------------------------------------------------------------------
      */

      /**
       * Sets widget's red value to spinner's value.
       */
      _setRedFromSpinner: function _setRedFromSpinner() {
        if (this.__updateContext__P_370_0 !== null) {
          return;
        }

        this.__updateContext__P_370_0 = "rgbSpinner";
        this.setRed(this.getChildControl("rgb-spinner-red").getValue());
        this.__updateContext__P_370_0 = null;
      },

      /**
       * Sets widget's green value to spinner's value.
       */
      _setGreenFromSpinner: function _setGreenFromSpinner() {
        if (this.__updateContext__P_370_0 !== null) {
          return;
        }

        this.__updateContext__P_370_0 = "rgbSpinner";
        this.setGreen(this.getChildControl("rgb-spinner-green").getValue());
        this.__updateContext__P_370_0 = null;
      },

      /**
       * Sets widget's blue value to spinner's value.
       */
      _setBlueFromSpinner: function _setBlueFromSpinner() {
        if (this.__updateContext__P_370_0 !== null) {
          return;
        }

        this.__updateContext__P_370_0 = "rgbSpinner";
        this.setBlue(this.getChildControl("rgb-spinner-blue").getValue());
        this.__updateContext__P_370_0 = null;
      },

      /*
      ---------------------------------------------------------------------------
        HSB SPINNER
      ---------------------------------------------------------------------------
      */

      /**
       * Sets widget's hue value to spinner's value.
       */
      _setHueFromSpinner: function _setHueFromSpinner() {
        if (this.__updateContext__P_370_0 !== null) {
          return;
        }

        this.__updateContext__P_370_0 = "hsbSpinner";
        this.setHue(this.getChildControl("hsb-spinner-hue").getValue());
        this.__updateContext__P_370_0 = null;
      },

      /**
       * Sets widget's saturation value to spinner's value.
       */
      _setSaturationFromSpinner: function _setSaturationFromSpinner() {
        if (this.__updateContext__P_370_0 !== null) {
          return;
        }

        this.__updateContext__P_370_0 = "hsbSpinner";
        this.setSaturation(this.getChildControl("hsb-spinner-saturation").getValue());
        this.__updateContext__P_370_0 = null;
      },

      /**
       * Sets widget's brightness value to spinner's value.
       */
      _setBrightnessFromSpinner: function _setBrightnessFromSpinner() {
        if (this.__updateContext__P_370_0 !== null) {
          return;
        }

        this.__updateContext__P_370_0 = "hsbSpinner";
        this.setBrightness(this.getChildControl("hsb-spinner-brightness").getValue());
        this.__updateContext__P_370_0 = null;
      },

      /*
      ---------------------------------------------------------------------------
        HEX FIELD
      ---------------------------------------------------------------------------
      */

      /**
       * Changes red, green and blue value to the corresponding hexfield value.
       * @param e {qx.event.type.Data} Incoming event object
       */
      _onHexFieldChange: function _onHexFieldChange(e) {
        if (this.__updateContext__P_370_0 !== null) {
          return;
        }

        try {
          var hexField = this.getChildControl("hex-field");
          var rgb = qx.util.ColorUtil.hexStringToRgb("#" + hexField.getValue());
        } catch (ex) {
          return;
        }

        ;
        this.__updateContext__P_370_0 = "hexField";
        this.setRed(rgb[0]);
        this.setGreen(rgb[1]);
        this.setBlue(rgb[2]);
        this.__updateContext__P_370_0 = null;
      },

      /**
       * Sets hexfield value to it's corresponding red, green and blue value.
       */
      _setHexFromRgb: function _setHexFromRgb() {
        var value = qx.util.ColorUtil.rgbToHexString([this.getRed(), this.getGreen(), this.getBlue()]); // get rid of the starting '#'

        value = value.substring(1, value.length);
        this.getChildControl("hex-field").setValue(value);
      },

      /*
      ---------------------------------------------------------------------------
        COLOR FIELD
      ---------------------------------------------------------------------------
      */

      /**
       * Listener of tap event on the color field.
       * Sets red, green and blue values to tapped color field's background color.
       *
       * @param e {qx.event.type.Pointer} Incoming event object
       */
      _onColorFieldTap: function _onColorFieldTap(e) {
        var vColor = e.getTarget().getBackgroundColor();

        if (!vColor) {
          this.error("Missing backgroundColor value for field: " + e.getTarget());
          return;
        }

        var rgb = qx.util.ColorUtil.stringToRgb(vColor);
        this.setRed(rgb[0]);
        this.setGreen(rgb[1]);
        this.setBlue(rgb[2]);
      },

      /*
      ---------------------------------------------------------------------------
        RGB/HSB SYNC
      ---------------------------------------------------------------------------
      */

      /**
       * Sets hue value to it's corresponding red, green and blue value.
       */
      _setHueFromRgb: function _setHueFromRgb() {
        switch (this.__updateContext__P_370_0) {
          case "hsbSpinner":
          case "hueSaturationField":
          case "brightnessField":
            break;

          default:
            var hsb = qx.util.ColorUtil.rgbToHsb([this.getRed(), this.getGreen(), this.getBlue()]);
            this.setHue(hsb[0]);
            this.setSaturation(hsb[1]);
            this.setBrightness(hsb[2]);
        }
      },

      /**
       * Sets red, green and blue value to corresponding hue value.
       */
      _setRgbFromHue: function _setRgbFromHue() {
        switch (this.__updateContext__P_370_0) {
          case "rgbSpinner":
          case "hexField":
            break;

          default:
            var vRgb = qx.util.ColorUtil.hsbToRgb([this.getHue(), this.getSaturation(), this.getBrightness()]);
            this.setRed(vRgb[0]);
            this.setGreen(vRgb[1]);
            this.setBlue(vRgb[2]);
        }
      },

      /*
      ---------------------------------------------------------------------------
        PREVIEW SYNC
      ---------------------------------------------------------------------------
      */

      /**
       * Sets preview pane's background color to corresponding red, green and blue color values.
       */
      _setPreviewFromRgb: function _setPreviewFromRgb() {
        var rgbString = qx.util.ColorUtil.rgbToRgbString([this.getRed(), this.getGreen(), this.getBlue()]);
        this.getChildControl("preview-content-new").setBackgroundColor(rgbString);
      },

      /**
       * Sets previous color's to given values.
       *
       * @param red {Number} Red color value.
       * @param green {Number} Green color value.
       * @param blue {Number} Blue color value.
       */
      setPreviousColor: function setPreviousColor(red, green, blue) {
        var color = qx.util.ColorUtil.rgbToRgbString([red, green, blue]);
        this.getChildControl("preview-content-old").setBackgroundColor(color);
        this.setRed(red);
        this.setGreen(green);
        this.setBlue(blue);
      },

      /**
       * Updates the background of the brightness field to give a nicer gradient
       */
      _setBrightnessGradiant: function _setBrightnessGradiant() {
        var ColorUtil = qx.util.ColorUtil;
        var helpRgb = ColorUtil.hsbToRgb([this.getHue(), this.getSaturation(), 255]);
        var helpRgbString = ColorUtil.rgbToRgbString(helpRgb);
        this.getChildControl("brightness-field").setBackgroundColor(helpRgbString);
      },

      /**
       * Listener for appear.
       * Sets preview pane's background color to the current color.
       *
       * @param e {qx.event.type.Data} Incoming event object
       */
      _onAppear: function _onAppear(e) {
        var color = qx.util.ColorUtil.rgbToRgbString([this.getRed(), this.getGreen(), this.getBlue()]);
        this.getChildControl("preview-content-old").setBackgroundColor(color);
        this.getChildControl("preview-content-new").setBackgroundColor(color);
      }
    }
  });
  qx.ui.control.ColorSelector.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.window.IWindowManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * All parent widgets of windows must implement this interface.
   */
  qx.Interface.define("qx.ui.window.IDesktop", {
    members: {
      /**
       * Sets the desktop's window manager
       *
       * @param manager {qx.ui.window.IWindowManager} The window manager
       */
      setWindowManager: function setWindowManager(manager) {
        this.assertInterface(manager, qx.ui.window.IWindowManager);
      },

      /**
       * Get a list of all windows added to the desktop (including hidden windows)
       *
       * @return {qx.ui.window.Window[]} Array of managed windows
       */
      getWindows: function getWindows() {},

      /**
       * Whether the configured layout supports a maximized window
       * e.g. is a Canvas.
       *
       * @return {Boolean} Whether the layout supports maximized windows
       */
      supportsMaximize: function supportsMaximize() {},

      /**
       * Block direct child widgets with a zIndex below <code>zIndex</code>
       *
       * @param zIndex {Integer} All child widgets with a zIndex below this value
       *     will be blocked
       */
      blockContent: function blockContent(zIndex) {
        this.assertInteger(zIndex);
      },

      /**
       * Remove the blocker.
       */
      unblock: function unblock() {},

      /**
       * Whether the widget is currently blocked
       *
       * @return {Boolean} whether the widget is blocked.
       */
      isBlocked: function isBlocked() {}
    }
  });
  qx.ui.window.IDesktop.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IStringForm": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.theme.manager.Color": {},
      "qx.ui.style.Stylesheet": {
        "defer": "runtime"
      },
      "qx.bom.client.Css": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true,
        "defer": "runtime"
      },
      "qx.html.Input": {},
      "qx.util.ResourceManager": {},
      "qx.theme.manager.Font": {},
      "qx.bom.webfonts.WebFont": {},
      "qx.bom.Font": {},
      "qx.html.Element": {},
      "qx.bom.Label": {},
      "qx.ui.core.queue.Layout": {},
      "qx.lang.Type": {},
      "qx.event.type.Data": {},
      "qx.html.Label": {},
      "qx.bom.Stylesheet": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "engine.version": {
          "className": "qx.bom.client.Engine"
        },
        "css.placeholder": {
          "construct": true,
          "className": "qx.bom.client.Css"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        },
        "browser.version": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This is a basic form field with common functionality for
   * {@link TextArea} and {@link TextField}.
   *
   * On every keystroke the value is synchronized with the
   * value of the textfield. Value changes can be monitored by listening to the
   * {@link #input} or {@link #changeValue} events, respectively.
   */
  qx.Class.define("qx.ui.form.AbstractField", {
    extend: qx.ui.core.Widget,
    implement: [qx.ui.form.IStringForm, qx.ui.form.IForm],
    include: [qx.ui.form.MForm],
    type: "abstract",
    statics: {
      /** Stylesheet needed to style the native placeholder element. */
      __stylesheet__P_410_0: null,

      /**
       * Adds the CSS rules needed to style the native placeholder element.
       */
      __addPlaceholderRules__P_410_1: function __addPlaceholderRules__P_410_1() {
        var engine = qx.core.Environment.get("engine.name");
        var browser = qx.core.Environment.get("browser.name");
        var colorManager = qx.theme.manager.Color.getInstance();
        var color = colorManager.resolve("text-placeholder");
        var selector;

        if (engine == "gecko") {
          // see https://developer.mozilla.org/de/docs/CSS/:-moz-placeholder for details
          if (parseFloat(qx.core.Environment.get("engine.version")) >= 19) {
            selector = "input::-moz-placeholder, textarea::-moz-placeholder";
          } else {
            selector = "input:-moz-placeholder, textarea:-moz-placeholder";
          }

          qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color + " !important");
        } else if (engine == "webkit" && browser != "edge") {
          selector = "input.qx-placeholder-color::-webkit-input-placeholder, textarea.qx-placeholder-color::-webkit-input-placeholder";
          qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color);
        } else if (engine == "mshtml" || browser == "edge") {
          var separator = browser == "edge" ? "::" : ":";
          selector = ["input.qx-placeholder-color", "-ms-input-placeholder, textarea.qx-placeholder-color", "-ms-input-placeholder"].join(separator);
          qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color + " !important");
        }
      }
    },

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {String} initial text value of the input field ({@link #setValue}).
     */
    construct: function construct(value) {
      qx.ui.core.Widget.constructor.call(this); // shortcut for placeholder feature detection

      this.__useQxPlaceholder__P_410_2 = !qx.core.Environment.get("css.placeholder");

      if (value != null) {
        this.setValue(value);
      }

      this.getContentElement().addListener("change", this._onChangeContent, this); // use qooxdoo placeholder if no native placeholder is supported

      if (this.__useQxPlaceholder__P_410_2) {
        // assign the placeholder text after the appearance has been applied
        this.addListener("syncAppearance", this._syncPlaceholder, this);
      } else {
        // add rules for native placeholder color
        qx.ui.form.AbstractField.__addPlaceholderRules__P_410_1(); // add a class to the input to restrict the placeholder color


        this.getContentElement().addClass("qx-placeholder-color");
      } // translation support


      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * The event is fired on every keystroke modifying the value of the field.
       *
       * The method {@link qx.event.type.Data#getData} returns the
       * current value of the text field.
       */
      "input": "qx.event.type.Data",

      /**
       * The event is fired each time the text field looses focus and the
       * text field values has changed.
       *
       * If you change {@link #liveUpdate} to true, the changeValue event will
       * be fired after every keystroke and not only after every focus loss. In
       * that mode, the changeValue event is equal to the {@link #input} event.
       *
       * The method {@link qx.event.type.Data#getData} returns the
       * current text value of the field.
       */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Alignment of the text
       */
      textAlign: {
        check: ["left", "center", "right"],
        nullable: true,
        themeable: true,
        apply: "_applyTextAlign"
      },

      /** Whether the field is read only */
      readOnly: {
        check: "Boolean",
        apply: "_applyReadOnly",
        event: "changeReadOnly",
        init: false
      },
      // overridden
      selectable: {
        refine: true,
        init: true
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /** Maximal number of characters that can be entered in the TextArea. */
      maxLength: {
        apply: "_applyMaxLength",
        check: "PositiveInteger",
        init: Infinity
      },

      /**
       * Whether the {@link #changeValue} event should be fired on every key
       * input. If set to true, the changeValue event is equal to the
       * {@link #input} event.
       */
      liveUpdate: {
        check: "Boolean",
        init: false
      },

      /**
       * Fire a {@link #changeValue} event whenever the content of the
       * field matches the given regular expression. Accepts both regular
       * expression objects as well as strings for input.
       */
      liveUpdateOnRxMatch: {
        check: "RegExp",
        transform: "_string2RegExp",
        init: null
      },

      /**
       * String value which will be shown as a hint if the field is all of:
       * unset, unfocused and enabled. Set to null to not show a placeholder
       * text.
       */
      placeholder: {
        check: "String",
        nullable: true,
        apply: "_applyPlaceholder"
      },

      /**
       * RegExp responsible for filtering the value of the textfield. the RegExp
       * gives the range of valid values.
       * Note: The regexp specified is applied to each character in turn, 
       * NOT to the entire string. So only regular expressions matching a 
       * single character make sense in the context.
       * The following example only allows digits in the textfield.
       * <pre class='javascript'>field.setFilter(/[0-9]/);</pre>
       */
      filter: {
        check: "RegExp",
        nullable: true,
        init: null
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __nullValue__P_410_3: true,
      _placeholder: null,
      __oldValue__P_410_4: null,
      __oldInputValue__P_410_5: null,
      __useQxPlaceholder__P_410_2: true,
      __font__P_410_6: null,
      __webfontListenerId__P_410_7: null,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      getFocusElement: function getFocusElement() {
        var el = this.getContentElement();

        if (el) {
          return el;
        }
      },

      /**
       * Creates the input element. Derived classes may override this
       * method, to create different input elements.
       *
       * @return {qx.html.Input} a new input element.
       */
      _createInputElement: function _createInputElement() {
        return new qx.html.Input("text");
      },
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        var updateInsets = this._updateInsets;
        var changes = qx.ui.form.AbstractField.prototype.renderLayout.base.call(this, left, top, width, height); // Directly return if superclass has detected that no
        // changes needs to be applied

        if (!changes) {
          return;
        }

        var inner = changes.size || updateInsets;
        var pixel = "px";

        if (inner || changes.local || changes.margin) {
          var innerWidth = width;
          var innerHeight = height;
        }

        var input = this.getContentElement(); // we don't need to update positions on native placeholders

        if (updateInsets && this.__useQxPlaceholder__P_410_2) {
          if (this.__useQxPlaceholder__P_410_2) {
            var insets = this.getInsets();

            this._getPlaceholderElement().setStyles({
              paddingTop: insets.top + pixel,
              paddingRight: insets.right + pixel,
              paddingBottom: insets.bottom + pixel,
              paddingLeft: insets.left + pixel
            });
          }
        }

        if (inner || changes.margin) {
          // we don't need to update dimensions on native placeholders
          if (this.__useQxPlaceholder__P_410_2) {
            var insets = this.getInsets();

            this._getPlaceholderElement().setStyles({
              "width": innerWidth - insets.left - insets.right + pixel,
              "height": innerHeight - insets.top - insets.bottom + pixel
            });
          }

          input.setStyles({
            "width": innerWidth + pixel,
            "height": innerHeight + pixel
          });

          this._renderContentElement(innerHeight, input);
        }

        if (changes.position) {
          if (this.__useQxPlaceholder__P_410_2) {
            this._getPlaceholderElement().setStyles({
              "left": left + pixel,
              "top": top + pixel
            });
          }
        }
      },

      /**
       * Hook into {@link qx.ui.form.AbstractField#renderLayout} method.
       * Called after the contentElement has a width and an innerWidth.
       *
       * Note: This was introduced to fix BUG#1585
       *
       * @param innerHeight {Integer} The inner height of the element.
       * @param element {Element} The element.
       */
      _renderContentElement: function _renderContentElement(innerHeight, element) {//use it in child classes
      },
      // overridden
      _createContentElement: function _createContentElement() {
        // create and add the input element
        var el = this._createInputElement(); // initialize the html input


        el.setSelectable(this.getSelectable());
        el.setEnabled(this.getEnabled()); // Add listener for input event

        el.addListener("input", this._onHtmlInput, this); // Disable HTML5 spell checking

        el.setAttribute("spellcheck", "false");
        el.addClass("qx-abstract-field"); // IE8 in standard mode needs some extra love here to receive events.

        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") == 8) {
          el.setStyles({
            backgroundImage: "url(" + qx.util.ResourceManager.getInstance().toUri("qx/static/blank.gif") + ")"
          });
        }

        return el;
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.form.AbstractField.prototype._applyEnabled.base.call(this, value, old);

        this.getContentElement().setEnabled(value);

        if (this.__useQxPlaceholder__P_410_2) {
          if (value) {
            this._showPlaceholder();
          } else {
            this._removePlaceholder();
          }
        } else {
          var input = this.getContentElement(); // remove the placeholder on disabled input elements

          input.setAttribute("placeholder", value ? this.getPlaceholder() : "");
        }
      },
      // default text sizes

      /**
       * @lint ignoreReferenceField(__textSize)
       */
      __textSize__P_410_8: {
        width: 16,
        height: 16
      },
      // overridden
      _getContentHint: function _getContentHint() {
        return {
          width: this.__textSize__P_410_8.width * 10,
          height: this.__textSize__P_410_8.height || 16
        };
      },
      // overridden
      _applyFont: function _applyFont(value, old) {
        if (old && this.__font__P_410_6 && this.__webfontListenerId__P_410_7) {
          this.__font__P_410_6.removeListenerById(this.__webfontListenerId__P_410_7);

          this.__webfontListenerId__P_410_7 = null;
        } // Apply


        var styles;

        if (value) {
          this.__font__P_410_6 = qx.theme.manager.Font.getInstance().resolve(value);

          if (this.__font__P_410_6 instanceof qx.bom.webfonts.WebFont) {
            this.__webfontListenerId__P_410_7 = this.__font__P_410_6.addListener("changeStatus", this._onWebFontStatusChange, this);
          }

          styles = this.__font__P_410_6.getStyles();
        } else {
          styles = qx.bom.Font.getDefaultStyles();
        } // check if text color already set - if so this local value has higher priority


        if (this.getTextColor() != null) {
          delete styles["color"];
        } // apply the font to the content element
        // IE 8 - 10 (but not 11 Preview) will ignore the lineHeight value
        // unless it's applied directly.


        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 11) {
          qx.html.Element.flush();
          this.getContentElement().setStyles(styles, true);
        } else {
          this.getContentElement().setStyles(styles);
        } // the font will adjust automatically on native placeholders


        if (this.__useQxPlaceholder__P_410_2) {
          // don't apply the color to the placeholder
          delete styles["color"]; // apply the font to the placeholder

          this._getPlaceholderElement().setStyles(styles);
        } // Compute text size


        if (value) {
          this.__textSize__P_410_8 = qx.bom.Label.getTextSize("A", styles);
        } else {
          delete this.__textSize__P_410_8;
        } // Update layout


        qx.ui.core.queue.Layout.add(this);
      },
      // overridden
      _applyTextColor: function _applyTextColor(value, old) {
        if (value) {
          this.getContentElement().setStyle("color", qx.theme.manager.Color.getInstance().resolve(value));
        } else {
          this.getContentElement().removeStyle("color");
        }
      },
      // property apply
      _applyMaxLength: function _applyMaxLength(value, old) {
        if (value) {
          this.getContentElement().setAttribute("maxLength", value);
        } else {
          this.getContentElement().removeAttribute("maxLength");
        }
      },
      // property transform
      _string2RegExp: function _string2RegExp(value, old) {
        if (qx.lang.Type.isString(value)) {
          value = new RegExp(value);
        }

        return value;
      },
      // overridden
      tabFocus: function tabFocus() {
        qx.ui.form.AbstractField.prototype.tabFocus.base.call(this);
        this.selectAllText();
      },

      /**
       * Returns the text size.
       * @return {Map} The text size.
       */
      _getTextSize: function _getTextSize() {
        return this.__textSize__P_410_8;
      },

      /*
      ---------------------------------------------------------------------------
        EVENTS
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for native input events. Redirects the event
       * to the widget. Also checks for the filter and max length.
       *
       * @param e {qx.event.type.Data} Input event
       */
      _onHtmlInput: function _onHtmlInput(e) {
        var value = e.getData();
        var fireEvents = true;
        this.__nullValue__P_410_3 = false; // value unchanged; Firefox fires "input" when pressing ESC [BUG #5309]

        if (this.__oldInputValue__P_410_5 && this.__oldInputValue__P_410_5 === value) {
          fireEvents = false;
        } // check for the filter


        if (this.getFilter() != null) {
          var filteredValue = this._validateInput(value);

          if (filteredValue != value) {
            fireEvents = this.__oldInputValue__P_410_5 !== filteredValue;
            value = filteredValue;
            this.getContentElement().setValue(value);
          }
        } // fire the events, if necessary


        if (fireEvents) {
          // store the old input value
          this.fireDataEvent("input", value, this.__oldInputValue__P_410_5);
          this.__oldInputValue__P_410_5 = value; // check for the live change event

          if (this.getLiveUpdate()) {
            this.__fireChangeValueEvent__P_410_9(value);
          } // check for the liveUpdateOnRxMatch change event
          else {
              var fireRx = this.getLiveUpdateOnRxMatch();

              if (fireRx && value.match(fireRx)) {
                this.__fireChangeValueEvent__P_410_9(value);
              }
            }
        }
      },

      /**
       * Triggers text size recalculation after a web font was loaded
       *
       * @param ev {qx.event.type.Data} "changeStatus" event
       */
      _onWebFontStatusChange: function _onWebFontStatusChange(ev) {
        if (ev.getData().valid === true) {
          var styles = this.__font__P_410_6.getStyles();

          this.__textSize__P_410_8 = qx.bom.Label.getTextSize("A", styles);
          qx.ui.core.queue.Layout.add(this);
        }
      },

      /**
       * Handles the firing of the changeValue event including the local cache
       * for sending the old value in the event.
       *
       * @param value {String} The new value.
       */
      __fireChangeValueEvent__P_410_9: function __fireChangeValueEvent__P_410_9(value) {
        var old = this.__oldValue__P_410_4;
        this.__oldValue__P_410_4 = value;

        if (old != value) {
          this.fireNonBubblingEvent("changeValue", qx.event.type.Data, [value, old]);
        }
      },

      /*
      ---------------------------------------------------------------------------
        TEXTFIELD VALUE API
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the value of the textfield to the given value.
       *
       * @param value {String} The new value
       */
      setValue: function setValue(value) {
        if (this.isDisposed()) {
          return null;
        } // handle null values


        if (value === null) {
          // just do nothing if null is already set
          if (this.__nullValue__P_410_3) {
            return value;
          }

          value = "";
          this.__nullValue__P_410_3 = true;
        } else {
          this.__nullValue__P_410_3 = false; // native placeholders will be removed by the browser

          if (this.__useQxPlaceholder__P_410_2) {
            this._removePlaceholder();
          }
        }

        if (qx.lang.Type.isString(value)) {
          var elem = this.getContentElement();

          if (elem.getValue() != value) {
            var oldValue = elem.getValue();
            elem.setValue(value);
            var data = this.__nullValue__P_410_3 ? null : value;
            this.__oldValue__P_410_4 = oldValue;

            this.__fireChangeValueEvent__P_410_9(data); // reset the input value on setValue calls [BUG #6892]


            this.__oldInputValue__P_410_5 = this.__oldValue__P_410_4;
          } // native placeholders will be shown by the browser


          if (this.__useQxPlaceholder__P_410_2) {
            this._showPlaceholder();
          }

          return value;
        }

        throw new Error("Invalid value type: " + value);
      },

      /**
       * Returns the current value of the textfield.
       *
       * @return {String|null} The current value
       */
      getValue: function getValue() {
        return this.isDisposed() || this.__nullValue__P_410_3 ? null : this.getContentElement().getValue();
      },

      /**
       * Resets the value to the default
       */
      resetValue: function resetValue() {
        this.setValue(null);
      },

      /**
       * Event listener for change event of content element
       *
       * @param e {qx.event.type.Data} Incoming change event
       */
      _onChangeContent: function _onChangeContent(e) {
        this.__nullValue__P_410_3 = e.getData() === null;

        this.__fireChangeValueEvent__P_410_9(e.getData());
      },

      /*
      ---------------------------------------------------------------------------
        TEXTFIELD SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the current selection.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @return {String|null}
       */
      getTextSelection: function getTextSelection() {
        return this.getContentElement().getTextSelection();
      },

      /**
       * Returns the current selection length.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @return {Integer|null}
       */
      getTextSelectionLength: function getTextSelectionLength() {
        return this.getContentElement().getTextSelectionLength();
      },

      /**
       * Returns the start of the text selection
       *
       * @return {Integer|null} Start of selection or null if not available
       */
      getTextSelectionStart: function getTextSelectionStart() {
        return this.getContentElement().getTextSelectionStart();
      },

      /**
       * Returns the end of the text selection
       *
       * @return {Integer|null} End of selection or null if not available
       */
      getTextSelectionEnd: function getTextSelectionEnd() {
        return this.getContentElement().getTextSelectionEnd();
      },

      /**
       * Set the selection to the given start and end (zero-based).
       * If no end value is given the selection will extend to the
       * end of the textfield's content.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @param start {Integer} start of the selection (zero-based)
       * @param end {Integer} end of the selection
       */
      setTextSelection: function setTextSelection(start, end) {
        this.getContentElement().setTextSelection(start, end);
      },

      /**
       * Clears the current selection.
       * This method only works if the widget is already created and
       * added to the document.
       *
       */
      clearTextSelection: function clearTextSelection() {
        this.getContentElement().clearTextSelection();
      },

      /**
       * Selects the whole content
       *
       */
      selectAllText: function selectAllText() {
        this.setTextSelection(0);
      },

      /*
      ---------------------------------------------------------------------------
        PLACEHOLDER HELPERS
      ---------------------------------------------------------------------------
      */
      // overridden
      setLayoutParent: function setLayoutParent(parent) {
        qx.ui.form.AbstractField.prototype.setLayoutParent.base.call(this, parent);

        if (this.__useQxPlaceholder__P_410_2) {
          if (parent) {
            this.getLayoutParent().getContentElement().add(this._getPlaceholderElement());
          } else {
            var placeholder = this._getPlaceholderElement();

            placeholder.getParent().remove(placeholder);
          }
        }
      },

      /**
       * Helper to show the placeholder text in the field. It checks for all
       * states and possible conditions and shows the placeholder only if allowed.
       */
      _showPlaceholder: function _showPlaceholder() {
        var fieldValue = this.getValue() || "";
        var placeholder = this.getPlaceholder();

        if (placeholder != null && fieldValue == "" && !this.hasState("focused") && !this.hasState("disabled")) {
          if (this.hasState("showingPlaceholder")) {
            this._syncPlaceholder();
          } else {
            // the placeholder will be set as soon as the appearance is applied
            this.addState("showingPlaceholder");
          }
        }
      },

      /**
       * Remove the fake placeholder
       */
      _onPointerDownPlaceholder: function _onPointerDownPlaceholder() {
        window.setTimeout(function () {
          this.focus();
        }.bind(this), 0);
      },

      /**
       * Helper to remove the placeholder. Deletes the placeholder text from the
       * field and removes the state.
       */
      _removePlaceholder: function _removePlaceholder() {
        if (this.hasState("showingPlaceholder")) {
          if (this.__useQxPlaceholder__P_410_2) {
            this._getPlaceholderElement().setStyle("visibility", "hidden");
          }

          this.removeState("showingPlaceholder");
        }
      },

      /**
       * Updates the placeholder text with the DOM
       */
      _syncPlaceholder: function _syncPlaceholder() {
        if (this.hasState("showingPlaceholder") && this.__useQxPlaceholder__P_410_2) {
          this._getPlaceholderElement().setStyle("visibility", "visible");
        }
      },

      /**
       * Returns the placeholder label and creates it if necessary.
       */
      _getPlaceholderElement: function _getPlaceholderElement() {
        if (this._placeholder == null) {
          // create the placeholder
          this._placeholder = new qx.html.Label();
          var colorManager = qx.theme.manager.Color.getInstance();

          this._placeholder.setStyles({
            "zIndex": 11,
            "position": "absolute",
            "color": colorManager.resolve("text-placeholder"),
            "whiteSpace": "normal",
            // enable wrap by default
            "cursor": "text",
            "visibility": "hidden"
          });

          this._placeholder.addListener("pointerdown", this._onPointerDownPlaceholder, this);
        }

        return this._placeholder;
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale: function _onChangeLocale(e) {
        var content = this.getPlaceholder();

        if (content && content.translate) {
          this.setPlaceholder(content.translate());
        }
      },
      // overridden
      _onChangeTheme: function _onChangeTheme() {
        qx.ui.form.AbstractField.prototype._onChangeTheme.base.call(this);

        if (this._placeholder) {
          // delete the placeholder element because it uses a theme dependent color
          this._placeholder.dispose();

          this._placeholder = null;
        }

        if (!this.__useQxPlaceholder__P_410_2 && qx.ui.form.AbstractField.__stylesheet__P_410_0) {
          qx.bom.Stylesheet.removeSheet(qx.ui.form.AbstractField.__stylesheet__P_410_0);
          qx.ui.form.AbstractField.__stylesheet__P_410_0 = null;

          qx.ui.form.AbstractField.__addPlaceholderRules__P_410_1();
        }
      },

      /**
       * Validates the the input value.
       * 
       * @param value {Object} The value to check
       * @returns The checked value
       */
      _validateInput: function _validateInput(value) {
        var filteredValue = value;
        var filter = this.getFilter(); // If no filter is set return just the value

        if (filter !== null) {
          filteredValue = "";
          var index = value.search(filter);
          var processedValue = value;

          while (index >= 0 && processedValue.length > 0) {
            filteredValue = filteredValue + processedValue.charAt(index);
            processedValue = processedValue.substring(index + 1, processedValue.length);
            index = processedValue.search(filter);
          }
        }

        return filteredValue;
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyPlaceholder: function _applyPlaceholder(value, old) {
        if (this.__useQxPlaceholder__P_410_2) {
          this._getPlaceholderElement().setValue(value);

          if (value != null) {
            this.addListener("focusin", this._removePlaceholder, this);
            this.addListener("focusout", this._showPlaceholder, this);

            this._showPlaceholder();
          } else {
            this.removeListener("focusin", this._removePlaceholder, this);
            this.removeListener("focusout", this._showPlaceholder, this);

            this._removePlaceholder();
          }
        } else {
          // only apply if the widget is enabled
          if (this.getEnabled()) {
            this.getContentElement().setAttribute("placeholder", value);

            if (qx.core.Environment.get("browser.name") === "firefox" && parseFloat(qx.core.Environment.get("browser.version")) < 36 && this.getContentElement().getNodeName() === "textarea" && !this.getContentElement().getDomElement()) {
              /* qx Bug #8870: Firefox 35 will not display a text area's
                 placeholder text if the attribute is set before the
                 element is added to the DOM. This is fixed in FF 36. */
              this.addListenerOnce("appear", function () {
                this.getContentElement().getDomElement().removeAttribute("placeholder");
                this.getContentElement().getDomElement().setAttribute("placeholder", value);
              }, this);
            }
          }
        }
      },
      // property apply
      _applyTextAlign: function _applyTextAlign(value, old) {
        this.getContentElement().setStyle("textAlign", value);
      },
      // property apply
      _applyReadOnly: function _applyReadOnly(value, old) {
        var element = this.getContentElement();
        element.setAttribute("readOnly", value);

        if (value) {
          this.addState("readonly");
          this.setFocusable(false);
        } else {
          this.removeState("readonly");
          this.setFocusable(true);
        }
      }
    },
    defer: function defer(statics) {
      var css = "border: none;padding: 0;margin: 0;display : block;background : transparent;outline: none;appearance: none;position: absolute;autoComplete: off;resize: none;border-radius: 0;";
      qx.ui.style.Stylesheet.getInstance().addRule(".qx-abstract-field", css);
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this._placeholder) {
        this._placeholder.removeListener("pointerdown", this._onPointerDownPlaceholder, this);

        var parent = this._placeholder.getParent();

        if (parent) {
          parent.remove(this._placeholder);
        }

        this._placeholder.dispose();
      }

      this._placeholder = this.__font__P_410_6 = null;
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }

      if (this.__font__P_410_6 && this.__webfontListenerId__P_410_7) {
        this.__font__P_410_6.removeListenerById(this.__webfontListenerId__P_410_7);
      }

      this.getContentElement().removeListener("input", this._onHtmlInput, this);
    }
  });
  qx.ui.form.AbstractField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.AbstractField": {
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.bom.client.Device": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "engine.version": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        },
        "device.type": {
          "className": "qx.bom.client.Device"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */

  /**
   * The TextField is a single-line text input field.
   */
  qx.Class.define("qx.ui.form.TextField", {
    extend: qx.ui.form.AbstractField,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "textfield"
      },
      // overridden
      allowGrowY: {
        refine: true,
        init: false
      },
      // overridden
      allowShrinkY: {
        refine: true,
        init: false
      }
    },
    members: {
      // overridden
      _renderContentElement: function _renderContentElement(innerHeight, element) {
        if (qx.core.Environment.get("engine.name") == "mshtml" && (parseInt(qx.core.Environment.get("engine.version"), 10) < 9 || qx.core.Environment.get("browser.documentmode") < 9)) {
          element.setStyles({
            "line-height": innerHeight + 'px'
          });
        }
      },
      // overridden
      _createContentElement: function _createContentElement() {
        var el = qx.ui.form.TextField.prototype._createContentElement.base.call(this);

        var deviceType = qx.core.Environment.get("device.type");

        if (deviceType == "tablet" || deviceType == "mobile") {
          el.addListener("keypress", this._onKeyPress, this);
        }

        return el;
      },

      /**
      * Close the virtual keyboard if the Enter key is pressed.
      * @param evt {qx.event.type.KeySequence} the keypress event.
      */
      _onKeyPress: function _onKeyPress(evt) {
        // On return
        if (evt.getKeyIdentifier() == "Enter") {
          if (this.isFocusable()) {
            this.blur();
          } else {
            // When the text field is not focusable, blur() will raise an exception on
            // touch devices and the virtual keyboard is not closed. To work around this
            // issue, we're enabling the focus just for the blur() call.
            this.setFocusable(true);
            this.blur();
            this.setFocusable(false);
          }
        }
      }
    },
    destruct: function destruct() {
      this.getContentElement().removeListener("keypress", this._onKeyPress, this);
    }
  });
  qx.ui.form.TextField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.INumberForm": {
        "require": true
      },
      "qx.ui.form.IRange": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.event.type.Focus": {
        "construct": true
      },
      "qx.ui.form.TextField": {},
      "qx.ui.form.RepeatButton": {},
      "qx.locale.Number": {},
      "qx.lang.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A *spinner* is a control that allows you to adjust a numerical value,
   * typically within an allowed range. An obvious example would be to specify the
   * month of a year as a number in the range 1 - 12.
   *
   * To do so, a spinner encompasses a field to display the current value (a
   * textfield) and controls such as up and down buttons to change that value. The
   * current value can also be changed by editing the display field directly, or
   * using mouse wheel and cursor keys.
   *
   * An optional {@link #numberFormat} property allows you to control the format of
   * how a value can be entered and will be displayed.
   *
   * A brief, but non-trivial example:
   *
   * <pre class='javascript'>
   * var s = new qx.ui.form.Spinner();
   * s.set({
   *   maximum: 3000,
   *   minimum: -3000
   * });
   * var nf = new qx.util.format.NumberFormat();
   * nf.setMaximumFractionDigits(2);
   * s.setNumberFormat(nf);
   * </pre>
   *
   * A spinner instance without any further properties specified in the
   * constructor or a subsequent *set* command will appear with default
   * values and behaviour.
   *
   * @childControl textfield {qx.ui.form.TextField} holds the current value of the spinner
   * @childControl upbutton {qx.ui.form.Button} button to increase the value
   * @childControl downbutton {qx.ui.form.Button} button to decrease the value
   *
   */
  qx.Class.define("qx.ui.form.Spinner", {
    extend: qx.ui.core.Widget,
    implement: [qx.ui.form.INumberForm, qx.ui.form.IRange, qx.ui.form.IForm],
    include: [qx.ui.core.MContentPadding, qx.ui.form.MForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param min {Number} Minimum value
     * @param value {Number} Current value
     * @param max {Number} Maximum value
     */
    construct: function construct(min, value, max) {
      qx.ui.core.Widget.constructor.call(this); // MAIN LAYOUT

      var layout = new qx.ui.layout.Grid();
      layout.setColumnFlex(0, 1);
      layout.setRowFlex(0, 1);
      layout.setRowFlex(1, 1);

      this._setLayout(layout); // EVENTS


      this.addListener("keydown", this._onKeyDown, this);
      this.addListener("keyup", this._onKeyUp, this);
      this.addListener("roll", this._onRoll, this);
      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      } // CREATE CONTROLS

      var textField = this._createChildControl("textfield");

      this._createChildControl("upbutton");

      this._createChildControl("downbutton"); // INITIALIZATION


      if (min != null) {
        this.setMinimum(min);
      }

      if (max != null) {
        this.setMaximum(max);
      }

      if (value !== undefined) {
        this.setValue(value);
      } else {
        this.initValue();
      } // forward the focusin and focusout events to the textfield. The textfield
      // is not focusable so the events need to be forwarded manually.


      this.addListener("focusin", function (e) {
        textField.fireNonBubblingEvent("focusin", qx.event.type.Focus);
      }, this);
      this.addListener("focusout", function (e) {
        textField.fireNonBubblingEvent("focusout", qx.event.type.Focus);
      }, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "spinner"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /** The amount to increment on each event (keypress or pointerdown) */
      singleStep: {
        check: "Number",
        init: 1
      },

      /** The amount to increment on each pageup/pagedown keypress */
      pageStep: {
        check: "Number",
        init: 10
      },

      /** minimal value of the Range object */
      minimum: {
        check: "Number",
        apply: "_applyMinimum",
        init: 0,
        event: "changeMinimum"
      },

      /** The value of the spinner. */
      value: {
        check: "this._checkValue(value)",
        nullable: true,
        apply: "_applyValue",
        init: 0,
        event: "changeValue"
      },

      /** maximal value of the Range object */
      maximum: {
        check: "Number",
        apply: "_applyMaximum",
        init: 100,
        event: "changeMaximum"
      },

      /** whether the value should wrap around */
      wrap: {
        check: "Boolean",
        init: false,
        apply: "_applyWrap"
      },

      /** Controls whether the textfield of the spinner is editable or not */
      editable: {
        check: "Boolean",
        init: true,
        apply: "_applyEditable"
      },

      /** Controls the display of the number in the textfield */
      numberFormat: {
        check: "qx.util.format.NumberFormat",
        apply: "_applyNumberFormat",
        nullable: true
      },
      // overridden
      allowShrinkY: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** Saved last value in case invalid text is entered */
      __lastValidValue__P_424_0: null,

      /** Whether the page-up button has been pressed */
      __pageUpMode__P_424_1: false,

      /** Whether the page-down button has been pressed */
      __pageDownMode__P_424_2: false,

      /*
      ---------------------------------------------------------------------------
        WIDGET INTERNALS
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "textfield":
            control = new qx.ui.form.TextField();
            control.setFilter(this._getFilterRegExp());
            control.addState("inner");
            control.setWidth(40);
            control.setFocusable(false);
            control.addListener("changeValue", this._onTextChange, this);

            this._add(control, {
              column: 0,
              row: 0,
              rowSpan: 2
            });

            break;

          case "upbutton":
            control = new qx.ui.form.RepeatButton();
            control.addState("inner");
            control.setFocusable(false);
            control.addListener("execute", this._countUp, this);

            this._add(control, {
              column: 1,
              row: 0
            });

            break;

          case "downbutton":
            control = new qx.ui.form.RepeatButton();
            control.addState("inner");
            control.setFocusable(false);
            control.addListener("execute", this._countDown, this);

            this._add(control, {
              column: 1,
              row: 1
            });

            break;
        }

        return control || qx.ui.form.Spinner.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Returns the regular expression used as the text field's filter
       *
       * @return {RegExp} The filter RegExp.
       */
      _getFilterRegExp: function _getFilterRegExp() {
        var decimalSeparator, groupSeparator, locale;

        if (this.getNumberFormat() !== null) {
          locale = this.getNumberFormat().getLocale();
        } else {
          locale = qx.locale.Manager.getInstance().getLocale();
        }

        decimalSeparator = qx.locale.Number.getDecimalSeparator(locale);
        groupSeparator = qx.locale.Number.getGroupSeparator(locale);
        var prefix = "";
        var postfix = "";

        if (this.getNumberFormat() !== null) {
          prefix = this.getNumberFormat().getPrefix() || "";
          postfix = this.getNumberFormat().getPostfix() || "";
        }

        var filterRegExp = new RegExp("[0-9" + qx.lang.String.escapeRegexpChars(decimalSeparator) + qx.lang.String.escapeRegexpChars(groupSeparator) + qx.lang.String.escapeRegexpChars(prefix) + qx.lang.String.escapeRegexpChars(postfix) + "\-]");
        return filterRegExp;
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        invalid: true
      },
      // overridden
      tabFocus: function tabFocus() {
        var field = this.getChildControl("textfield");
        field.getFocusElement().focus();
        field.selectAllText();
      },

      /*
      ---------------------------------------------------------------------------
        APPLY METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Apply routine for the minimum property.
       *
       * It sets the value of the spinner to the maximum of the current spinner
       * value and the given min property value.
       *
       * @param value {Number} The new value of the min property
       * @param old {Number} The old value of the min property
       */
      _applyMinimum: function _applyMinimum(value, old) {
        if (this.getMaximum() < value) {
          this.setMaximum(value);
        }

        if (this.getValue() < value) {
          this.setValue(value);
        } else {
          this._updateButtons();
        }
      },

      /**
       * Apply routine for the maximum property.
       *
       * It sets the value of the spinner to the minimum of the current spinner
       * value and the given max property value.
       *
       * @param value {Number} The new value of the max property
       * @param old {Number} The old value of the max property
       */
      _applyMaximum: function _applyMaximum(value, old) {
        if (this.getMinimum() > value) {
          this.setMinimum(value);
        }

        if (this.getValue() > value) {
          this.setValue(value);
        } else {
          this._updateButtons();
        }
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.form.Spinner.prototype._applyEnabled.base.call(this, value, old);

        this._updateButtons();
      },

      /**
       * Check whether the value being applied is allowed.
       *
       * If you override this to change the allowed type, you will also
       * want to override {@link #_applyValue}, {@link #_applyMinimum},
       * {@link #_applyMaximum}, {@link #_countUp}, {@link #_countDown}, and
       * {@link #_onTextChange} methods as those cater specifically to numeric
       * values.
       *
       * @param value {var}
       *   The value being set
       * @return {Boolean}
       *   <i>true</i> if the value is allowed;
       *   <i>false> otherwise.
       */
      _checkValue: function _checkValue(value) {
        return typeof value === "number" && value >= this.getMinimum() && value <= this.getMaximum();
      },

      /**
       * Apply routine for the value property.
       *
       * It disables / enables the buttons and handles the wrap around.
       *
       * @param value {Number} The new value of the spinner
       * @param old {Number} The former value of the spinner
       */
      _applyValue: function _applyValue(value, old) {
        var textField = this.getChildControl("textfield");

        this._updateButtons(); // save the last valid value of the spinner


        this.__lastValidValue__P_424_0 = value; // write the value of the spinner to the textfield

        if (value !== null) {
          if (this.getNumberFormat()) {
            textField.setValue(this.getNumberFormat().format(value));
          } else {
            textField.setValue(value + "");
          }
        } else {
          textField.setValue("");
        }
      },

      /**
       * Apply routine for the editable property.<br/>
       * It sets the textfield of the spinner to not read only.
       *
       * @param value {Boolean} The new value of the editable property
       * @param old {Boolean} The former value of the editable property
       */
      _applyEditable: function _applyEditable(value, old) {
        var textField = this.getChildControl("textfield");

        if (textField) {
          textField.setReadOnly(!value);
        }
      },

      /**
       * Apply routine for the wrap property.<br/>
       * Enables all buttons if the wrapping is enabled.
       *
       * @param value {Boolean} The new value of the wrap property
       * @param old {Boolean} The former value of the wrap property
       */
      _applyWrap: function _applyWrap(value, old) {
        this._updateButtons();
      },

      /**
       * Apply routine for the numberFormat property.<br/>
       * When setting a number format, the display of the
       * value in the text-field will be changed immediately.
       *
       * @param value {Boolean} The new value of the numberFormat property
       * @param old {Boolean} The former value of the numberFormat property
       */
      _applyNumberFormat: function _applyNumberFormat(value, old) {
        var textField = this.getChildControl("textfield");
        textField.setFilter(this._getFilterRegExp());

        if (old) {
          old.removeListener("changeNumberFormat", this._onChangeNumberFormat, this);
        }

        var numberFormat = this.getNumberFormat();

        if (numberFormat !== null) {
          numberFormat.addListener("changeNumberFormat", this._onChangeNumberFormat, this);
        }

        this._applyValue(this.__lastValidValue__P_424_0, undefined);
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getChildControl("textfield");
      },

      /**
       * Checks the min and max values, disables / enables the
       * buttons and handles the wrap around.
       */
      _updateButtons: function _updateButtons() {
        var upButton = this.getChildControl("upbutton");
        var downButton = this.getChildControl("downbutton");
        var value = this.getValue();

        if (!this.getEnabled()) {
          // If Spinner is disabled -> disable buttons
          upButton.setEnabled(false);
          downButton.setEnabled(false);
        } else {
          if (this.getWrap()) {
            // If wraped -> always enable buttons
            upButton.setEnabled(true);
            downButton.setEnabled(true);
          } else {
            // check max value
            if (value !== null && value < this.getMaximum()) {
              upButton.setEnabled(true);
            } else {
              upButton.setEnabled(false);
            } // check min value


            if (value !== null && value > this.getMinimum()) {
              downButton.setEnabled(true);
            } else {
              downButton.setEnabled(false);
            }
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        KEY EVENT-HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Callback for "keyDown" event.<br/>
       * Controls the interval mode ("single" or "page")
       * and the interval increase by detecting "Up"/"Down"
       * and "PageUp"/"PageDown" keys.<br/>
       * The corresponding button will be pressed.
       *
       * @param e {qx.event.type.KeySequence} keyDown event
       */
      _onKeyDown: function _onKeyDown(e) {
        switch (e.getKeyIdentifier()) {
          case "PageUp":
            // mark that the spinner is in page mode and process further
            this.__pageUpMode__P_424_1 = true;

          case "Up":
            this.getChildControl("upbutton").press();
            break;

          case "PageDown":
            // mark that the spinner is in page mode and process further
            this.__pageDownMode__P_424_2 = true;

          case "Down":
            this.getChildControl("downbutton").press();
            break;

          default:
            // Do not stop unused events
            return;
        }

        e.stopPropagation();
        e.preventDefault();
      },

      /**
       * Callback for "keyUp" event.<br/>
       * Detecting "Up"/"Down" and "PageUp"/"PageDown" keys.<br/>
       * Releases the button and disabled the page mode, if necessary.
       *
       * @param e {qx.event.type.KeySequence} keyUp event
       */
      _onKeyUp: function _onKeyUp(e) {
        switch (e.getKeyIdentifier()) {
          case "PageUp":
            this.getChildControl("upbutton").release();
            this.__pageUpMode__P_424_1 = false;
            break;

          case "Up":
            this.getChildControl("upbutton").release();
            break;

          case "PageDown":
            this.getChildControl("downbutton").release();
            this.__pageDownMode__P_424_2 = false;
            break;

          case "Down":
            this.getChildControl("downbutton").release();
            break;
        }
      },

      /*
      ---------------------------------------------------------------------------
        OTHER EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Callback method for the "roll" event.<br/>
       * Increments or decrements the value of the spinner.
       *
       * @param e {qx.event.type.Roll} roll event
       */
      _onRoll: function _onRoll(e) {
        // only wheel
        if (e.getPointerType() != "wheel") {
          return;
        }

        var delta = e.getDelta().y;

        if (delta < 0) {
          this._countUp();
        } else if (delta > 0) {
          this._countDown();
        }

        e.stop();
      },

      /**
       * Callback method for the "change" event of the textfield.
       *
       * @param e {qx.event.type.Event} text change event or blur event
       */
      _onTextChange: function _onTextChange(e) {
        var textField = this.getChildControl("textfield");
        var value; // if a number format is set

        if (this.getNumberFormat()) {
          // try to parse the current number using the number format
          try {
            value = this.getNumberFormat().parse(textField.getValue());
          } catch (ex) {// otherwise, process further
          }
        }

        if (value === undefined) {
          // try to parse the number as a float
          value = parseFloat(textField.getValue());
        } // if the result is a number


        if (!isNaN(value)) {
          // Fix value if invalid
          if (value > this.getMaximum()) {
            value = this.getMaximum();
          } else if (value < this.getMinimum()) {
            value = this.getMinimum();
          } // If value is the same than before, call directly _applyValue()


          if (value === this.__lastValidValue__P_424_0) {
            this._applyValue(this.__lastValidValue__P_424_0);
          } else {
            this.setValue(value);
          }
        } else {
          // otherwise, reset the last valid value
          this._applyValue(this.__lastValidValue__P_424_0, undefined);
        }
      },

      /**
       * Callback method for the locale Manager's "changeLocale" event.
       *
       * @param ev {qx.event.type.Event} locale change event
       */
      _onChangeLocale: function _onChangeLocale(ev) {
        if (this.getNumberFormat() !== null) {
          this.setNumberFormat(this.getNumberFormat());
          var textfield = this.getChildControl("textfield");
          textfield.setFilter(this._getFilterRegExp());
          textfield.setValue(this.getNumberFormat().format(this.getValue()));
        }
      },

      /**
       * Callback method for the number format's "changeNumberFormat" event.
       *
       * @param ev {qx.event.type.Event} number format change event
       */
      _onChangeNumberFormat: function _onChangeNumberFormat(ev) {
        var textfield = this.getChildControl("textfield");
        textfield.setFilter(this._getFilterRegExp());
        textfield.setValue(this.getNumberFormat().format(this.getValue()));
      },

      /*
      ---------------------------------------------------------------------------
        INTERVAL HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Checks if the spinner is in page mode and counts either the single
       * or page Step up.
       *
       */
      _countUp: function _countUp() {
        if (this.__pageUpMode__P_424_1) {
          var newValue = this.getValue() + this.getPageStep();
        } else {
          var newValue = this.getValue() + this.getSingleStep();
        } // handle the case where wrapping is enabled


        if (this.getWrap()) {
          if (newValue > this.getMaximum()) {
            var diff = this.getMaximum() - newValue;
            newValue = this.getMinimum() - diff - 1;
          }
        }

        this.gotoValue(newValue);
      },

      /**
       * Checks if the spinner is in page mode and counts either the single
       * or page Step down.
       *
       */
      _countDown: function _countDown() {
        if (this.__pageDownMode__P_424_2) {
          var newValue = this.getValue() - this.getPageStep();
        } else {
          var newValue = this.getValue() - this.getSingleStep();
        } // handle the case where wrapping is enabled


        if (this.getWrap()) {
          if (newValue < this.getMinimum()) {
            var diff = this.getMinimum() + newValue;
            newValue = this.getMaximum() + diff + 1;
          }
        }

        this.gotoValue(newValue);
      },

      /**
       * Normalizes the incoming value to be in the valid range and
       * applies it to the {@link #value} afterwards.
       *
       * @param value {Number} Any number
       * @return {Number} The normalized number
       */
      gotoValue: function gotoValue(value) {
        return this.setValue(Math.min(this.getMaximum(), Math.max(this.getMinimum(), value)));
      },
      // overridden
      focus: function focus() {
        qx.ui.form.Spinner.prototype.focus.base.call(this);
        this.getChildControl("textfield").getFocusElement().focus();
      }
    },
    destruct: function destruct() {
      var nf = this.getNumberFormat();

      if (nf) {
        nf.removeListener("changeNumberFormat", this._onChangeNumberFormat, this);
      }

      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
    }
  });
  qx.ui.form.Spinner.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which have date as their primary
   * data type like datechooser's.
   */
  qx.Interface.define("qx.ui.form.IDateForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {Date|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {Date|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.IDateForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IDateForm": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.locale.Date": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.tooltip.ToolTip": {},
      "qx.ui.toolbar.Button": {},
      "qx.ui.basic.Label": {},
      "qx.ui.layout.Grid": {},
      "qx.util.format.DateFormat": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * A *date chooser* is a small calendar including a navigation bar to switch the shown
   * month. It includes a column for the calendar week and shows one month. Selecting
   * a date is as easy as tapping on it.
   *
   * To be conform with all form widgets, the {@link qx.ui.form.IForm} interface
   * is implemented.
   *
   * The following example creates and adds a date chooser to the root element.
   * A listener alerts the user if a new date is selected.
   *
   * <pre class='javascript'>
   * var chooser = new qx.ui.control.DateChooser();
   * this.getRoot().add(chooser, { left : 20, top: 20});
   *
   * chooser.addListener("changeValue", function(e) {
   *   alert(e.getData());
   * });
   * </pre>
   *
   * Additionally to a selection event an execute event is available which is
   * fired by doubletap or tapping the space / enter key. With this event you
   * can for example save the selection and close the date chooser.
   *
   * @childControl navigation-bar {qx.ui.container.Composite} container for the navigation bar controls
   * @childControl last-year-button-tooltip {qx.ui.tooltip.ToolTip} tooltip for the last year button
   * @childControl last-year-button {qx.ui.form.Button} button to jump to the last year
   * @childControl last-month-button-tooltip {qx.ui.tooltip.ToolTip} tooltip for the last month button
   * @childControl last-month-button {qx.ui.form.Button} button to jump to the last month
   * @childControl next-month-button-tooltip {qx.ui.tooltip.ToolTip} tooltip for the next month button
   * @childControl next-month-button {qx.ui.form.Button} button to jump to the next month
   * @childControl next-year-button-tooltip {qx.ui.tooltip.ToolTip} tooltip for the next year button
   * @childControl next-year-button {qx.ui.form.Button} button to jump to the next year
   * @childControl month-year-label {qx.ui.basic.Label} shows the current month and year
   * @childControl week {qx.ui.basic.Label} week label (used multiple times)
   * @childControl weekday {qx.ui.basic.Label} weekday label (used multiple times)
   * @childControl day {qx.ui.basic.Label} day label (used multiple times)
   * @childControl date-pane {qx.ui.container.Composite} the pane used to position the week, weekday and day labels
   *
   */
  qx.Class.define("qx.ui.control.DateChooser", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MExecutable, qx.ui.form.MForm],
    implement: [qx.ui.form.IExecutable, qx.ui.form.IForm, qx.ui.form.IDateForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param date {Date ? null} The initial date to show. If <code>null</code>
     * the current day (today) is shown.
     */
    construct: function construct(date) {
      qx.ui.core.Widget.constructor.call(this); // set the layout

      var layout = new qx.ui.layout.VBox();

      this._setLayout(layout); // create the child controls


      this._createChildControl("navigation-bar");

      this._createChildControl("date-pane"); // Support for key events


      this.addListener("keypress", this._onKeyPress); // initialize format - moved from statics{} to constructor due to [BUG #7149]

      var DateChooser = qx.ui.control.DateChooser;

      if (!DateChooser.MONTH_YEAR_FORMAT) {
        DateChooser.MONTH_YEAR_FORMAT = qx.locale.Date.getDateTimeFormat("yyyyMMMM", "MMMM yyyy");
      } // Show the right date


      var shownDate = date != null ? date : new Date();
      this.showMonth(shownDate.getMonth(), shownDate.getFullYear()); // listen for locale changes

      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._updateDatePane, this);
      } // register pointer up and down handler

      this.addListener("pointerdown", this._onPointerUpDown, this);
      this.addListener("pointerup", this._onPointerUpDown, this);
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * @type {string} The format for the date year label at the top center.
       */
      MONTH_YEAR_FORMAT: null,

      /**
       * @type {string} The format for the weekday labels (the headers of the date table).
       */
      WEEKDAY_FORMAT: "EE",

      /**
       * @type {string} The format for the week numbers (the labels of the left column).
       */
      WEEK_FORMAT: "ww"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "datechooser"
      },
      // overridden
      width: {
        refine: true,
        init: 200
      },
      // overridden
      height: {
        refine: true,
        init: 150
      },

      /** The currently shown month. 0 = january, 1 = february, and so on. */
      shownMonth: {
        check: "Integer",
        init: null,
        nullable: true,
        event: "changeShownMonth"
      },

      /** The currently shown year. */
      shownYear: {
        check: "Integer",
        init: null,
        nullable: true,
        event: "changeShownYear"
      },

      /** The date value of the widget. */
      value: {
        check: "Date",
        init: null,
        nullable: true,
        event: "changeValue",
        apply: "_applyValue"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __weekdayLabelArr__P_371_0: null,
      __dayLabelArr__P_371_1: null,
      __weekLabelArr__P_371_2: null,
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        invalid: true
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET INTERNALS
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          // NAVIGATION BAR STUFF
          case "navigation-bar":
            control = new qx.ui.container.Composite(new qx.ui.layout.HBox()); // Add the navigation bar elements

            control.add(this.getChildControl("last-year-button"));
            control.add(this.getChildControl("last-month-button"));
            control.add(this.getChildControl("month-year-label"), {
              flex: 1
            });
            control.add(this.getChildControl("next-month-button"));
            control.add(this.getChildControl("next-year-button"));

            this._add(control);

            break;

          case "last-year-button-tooltip":
            control = new qx.ui.tooltip.ToolTip(this.tr("Last year"));
            break;

          case "last-year-button":
            control = new qx.ui.toolbar.Button();
            control.addState("lastYear");
            control.setFocusable(false);
            control.setToolTip(this.getChildControl("last-year-button-tooltip"));
            control.addListener("tap", this._onNavButtonTap, this);
            break;

          case "last-month-button-tooltip":
            control = new qx.ui.tooltip.ToolTip(this.tr("Last month"));
            break;

          case "last-month-button":
            control = new qx.ui.toolbar.Button();
            control.addState("lastMonth");
            control.setFocusable(false);
            control.setToolTip(this.getChildControl("last-month-button-tooltip"));
            control.addListener("tap", this._onNavButtonTap, this);
            break;

          case "next-month-button-tooltip":
            control = new qx.ui.tooltip.ToolTip(this.tr("Next month"));
            break;

          case "next-month-button":
            control = new qx.ui.toolbar.Button();
            control.addState("nextMonth");
            control.setFocusable(false);
            control.setToolTip(this.getChildControl("next-month-button-tooltip"));
            control.addListener("tap", this._onNavButtonTap, this);
            break;

          case "next-year-button-tooltip":
            control = new qx.ui.tooltip.ToolTip(this.tr("Next year"));
            break;

          case "next-year-button":
            control = new qx.ui.toolbar.Button();
            control.addState("nextYear");
            control.setFocusable(false);
            control.setToolTip(this.getChildControl("next-year-button-tooltip"));
            control.addListener("tap", this._onNavButtonTap, this);
            break;

          case "month-year-label":
            control = new qx.ui.basic.Label();
            control.setAllowGrowX(true);
            control.setAnonymous(true);
            break;

          case "week":
            control = new qx.ui.basic.Label();
            control.setAllowGrowX(true);
            control.setAllowGrowY(true);
            control.setSelectable(false);
            control.setAnonymous(true);
            control.setCursor("default");
            break;

          case "weekday":
            control = new qx.ui.basic.Label();
            control.setAllowGrowX(true);
            control.setAllowGrowY(true);
            control.setSelectable(false);
            control.setAnonymous(true);
            control.setCursor("default");
            break;

          case "day":
            control = new qx.ui.basic.Label();
            control.setAllowGrowX(true);
            control.setAllowGrowY(true);
            control.setCursor("default");
            control.addListener("pointerdown", this._onDayTap, this);
            control.addListener("dbltap", this._onDayDblTap, this);
            break;

          case "date-pane":
            var controlLayout = new qx.ui.layout.Grid();
            control = new qx.ui.container.Composite(controlLayout);

            for (var i = 0; i < 8; i++) {
              controlLayout.setColumnFlex(i, 1);
            }

            for (var i = 0; i < 7; i++) {
              controlLayout.setRowFlex(i, 1);
            } // Create the weekdays
            // Add an empty label as spacer for the week numbers


            var label = this.getChildControl("week#0");
            label.addState("header");
            control.add(label, {
              column: 0,
              row: 0
            });
            this.__weekdayLabelArr__P_371_0 = [];

            for (var i = 0; i < 7; i++) {
              label = this.getChildControl("weekday#" + i);
              control.add(label, {
                column: i + 1,
                row: 0
              });

              this.__weekdayLabelArr__P_371_0.push(label);
            } // Add the days


            this.__dayLabelArr__P_371_1 = [];
            this.__weekLabelArr__P_371_2 = [];

            for (var y = 0; y < 6; y++) {
              // Add the week label
              var label = this.getChildControl("week#" + (y + 1));
              control.add(label, {
                column: 0,
                row: y + 1
              });

              this.__weekLabelArr__P_371_2.push(label); // Add the day labels


              for (var x = 0; x < 7; x++) {
                var label = this.getChildControl("day#" + (y * 7 + x));
                control.add(label, {
                  column: x + 1,
                  row: y + 1
                });

                this.__dayLabelArr__P_371_1.push(label);
              }
            }

            this._add(control);

            break;
        }

        return control || qx.ui.control.DateChooser.prototype._createChildControlImpl.base.call(this, id);
      },
      // apply methods
      _applyValue: function _applyValue(value, old) {
        if (value != null && (this.getShownMonth() != value.getMonth() || this.getShownYear() != value.getFullYear())) {
          // The new date is in another month -> Show that month
          this.showMonth(value.getMonth(), value.getFullYear());
        } else {
          // The new date is in the current month -> Just change the states
          var newDay = value == null ? -1 : value.getDate();

          for (var i = 0; i < 42; i++) {
            var dayLabel = this.__dayLabelArr__P_371_1[i];

            if (dayLabel.hasState("otherMonth")) {
              if (dayLabel.hasState("selected")) {
                dayLabel.removeState("selected");
              }
            } else {
              var day = parseInt(dayLabel.getValue(), 10);

              if (day == newDay) {
                dayLabel.addState("selected");
              } else if (dayLabel.hasState("selected")) {
                dayLabel.removeState("selected");
              }
            }
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Handler which stops the propagation of the tap event if
       * the navigation bar or calendar headers will be tapped.
       *
       * @param e {qx.event.type.Pointer} The pointer up / down event
       */
      _onPointerUpDown: function _onPointerUpDown(e) {
        var target = e.getTarget();

        if (target == this.getChildControl("navigation-bar") || target == this.getChildControl("date-pane")) {
          e.stopPropagation();
          return;
        }
      },

      /**
       * Event handler. Called when a navigation button has been tapped.
       *
       * @param evt {qx.event.type.Data} The data event.
       */
      _onNavButtonTap: function _onNavButtonTap(evt) {
        var year = this.getShownYear();
        var month = this.getShownMonth();

        switch (evt.getCurrentTarget()) {
          case this.getChildControl("last-year-button"):
            year--;
            break;

          case this.getChildControl("last-month-button"):
            month--;

            if (month < 0) {
              month = 11;
              year--;
            }

            break;

          case this.getChildControl("next-month-button"):
            month++;

            if (month >= 12) {
              month = 0;
              year++;
            }

            break;

          case this.getChildControl("next-year-button"):
            year++;
            break;
        }

        this.showMonth(month, year);
      },

      /**
       * Event handler. Called when a day has been tapped.
       *
       * @param evt {qx.event.type.Data} The event.
       */
      _onDayTap: function _onDayTap(evt) {
        var time = evt.getCurrentTarget().dateTime;
        this.setValue(new Date(time));
      },

      /**
       * Event handler. Called when a day has been double-tapped.
       */
      _onDayDblTap: function _onDayDblTap() {
        this.execute();
      },

      /**
       * Event handler. Called when a key was pressed.
       *
       * @param evt {qx.event.type.Data} The event.
       */
      _onKeyPress: function _onKeyPress(evt) {
        var dayIncrement = null;
        var monthIncrement = null;
        var yearIncrement = null;

        if (evt.getModifiers() == 0) {
          switch (evt.getKeyIdentifier()) {
            case "Left":
              dayIncrement = -1;
              break;

            case "Right":
              dayIncrement = 1;
              break;

            case "Up":
              dayIncrement = -7;
              break;

            case "Down":
              dayIncrement = 7;
              break;

            case "PageUp":
              monthIncrement = -1;
              break;

            case "PageDown":
              monthIncrement = 1;
              break;

            case "Escape":
              if (this.getValue() != null) {
                this.setValue(null);
                return;
              }

              break;

            case "Enter":
            case "Space":
              if (this.getValue() != null) {
                this.execute();
              }

              return;
          }
        } else if (evt.isShiftPressed()) {
          switch (evt.getKeyIdentifier()) {
            case "PageUp":
              yearIncrement = -1;
              break;

            case "PageDown":
              yearIncrement = 1;
              break;
          }
        }

        if (dayIncrement != null || monthIncrement != null || yearIncrement != null) {
          var date = this.getValue();

          if (date != null) {
            date = new Date(date.getTime());
          }

          if (date == null) {
            date = new Date();
          } else {
            if (dayIncrement != null) {
              date.setDate(date.getDate() + dayIncrement);
            }

            if (monthIncrement != null) {
              date.setMonth(date.getMonth() + monthIncrement);
            }

            if (yearIncrement != null) {
              date.setFullYear(date.getFullYear() + yearIncrement);
            }
          }

          this.setValue(date);
        }
      },

      /**
       * Shows a certain month.
       *
       * @param month {Integer ? null} the month to show (0 = january). If not set
       *      the month will remain the same.
       * @param year {Integer ? null} the year to show. If not set the year will
       *      remain the same.
       */
      showMonth: function showMonth(month, year) {
        if (month != null && month != this.getShownMonth() || year != null && year != this.getShownYear()) {
          if (month != null) {
            this.setShownMonth(month);
          }

          if (year != null) {
            this.setShownYear(year);
          }

          this._updateDatePane();
        }
      },

      /**
       * Event handler. Used to handle the key events.
       *
       * @param e {qx.event.type.Data} The event.
       */
      handleKeyPress: function handleKeyPress(e) {
        this._onKeyPress(e);
      },

      /**
       * Updates the date pane.
       */
      _updateDatePane: function _updateDatePane() {
        var DateChooser = qx.ui.control.DateChooser;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth();
        var todayDayOfMonth = today.getDate();
        var selDate = this.getValue();
        var selYear = selDate == null ? -1 : selDate.getFullYear();
        var selMonth = selDate == null ? -1 : selDate.getMonth();
        var selDayOfMonth = selDate == null ? -1 : selDate.getDate();
        var shownMonth = this.getShownMonth();
        var shownYear = this.getShownYear();
        var startOfWeek = qx.locale.Date.getWeekStart(); // Create a help date that points to the first of the current month

        var helpDate = new Date(this.getShownYear(), this.getShownMonth(), 1);
        var monthYearFormat = new qx.util.format.DateFormat(DateChooser.MONTH_YEAR_FORMAT);
        this.getChildControl("month-year-label").setValue(monthYearFormat.format(helpDate)); // Show the day names

        var firstDayOfWeek = helpDate.getDay();
        var firstSundayInMonth = 1 + (7 - firstDayOfWeek) % 7;
        var weekDayFormat = new qx.util.format.DateFormat(DateChooser.WEEKDAY_FORMAT);

        for (var i = 0; i < 7; i++) {
          var day = (i + startOfWeek) % 7;
          var dayLabel = this.__weekdayLabelArr__P_371_0[i];
          helpDate.setDate(firstSundayInMonth + day);
          dayLabel.setValue(weekDayFormat.format(helpDate));

          if (qx.locale.Date.isWeekend(day)) {
            dayLabel.addState("weekend");
          } else {
            dayLabel.removeState("weekend");
          }
        } // Show the days


        helpDate = new Date(shownYear, shownMonth, 1, 12, 0, 0);
        var nrDaysOfLastMonth = (7 + firstDayOfWeek - startOfWeek) % 7;
        helpDate.setDate(helpDate.getDate() - nrDaysOfLastMonth);
        var weekFormat = new qx.util.format.DateFormat(DateChooser.WEEK_FORMAT);

        for (var week = 0; week < 6; week++) {
          this.__weekLabelArr__P_371_2[week].setValue(weekFormat.format(helpDate));

          for (var i = 0; i < 7; i++) {
            var dayLabel = this.__dayLabelArr__P_371_1[week * 7 + i];
            var year = helpDate.getFullYear();
            var month = helpDate.getMonth();
            var dayOfMonth = helpDate.getDate();
            var isSelectedDate = selYear == year && selMonth == month && selDayOfMonth == dayOfMonth;

            if (isSelectedDate) {
              dayLabel.addState("selected");
            } else {
              dayLabel.removeState("selected");
            }

            if (month != shownMonth) {
              dayLabel.addState("otherMonth");
            } else {
              dayLabel.removeState("otherMonth");
            }

            var isToday = year == todayYear && month == todayMonth && dayOfMonth == todayDayOfMonth;

            if (isToday) {
              dayLabel.addState("today");
            } else {
              dayLabel.removeState("today");
            }

            dayLabel.setValue("" + dayOfMonth);
            dayLabel.dateTime = helpDate.getTime(); // Go to the next day

            helpDate.setDate(helpDate.getDate() + 1);
          }
        }

        monthYearFormat.dispose();
        weekDayFormat.dispose();
        weekFormat.dispose();
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._updateDatePane, this);
      }
      this.__weekdayLabelArr__P_371_0 = this.__dayLabelArr__P_371_1 = this.__weekLabelArr__P_371_2 = null;
    }
  });
  qx.ui.control.DateChooser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Button": {
        "construct": true,
        "require": true
      },
      "qx.ui.toolbar.PartContainer": {},
      "qx.ui.core.queue.Appearance": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * The normal toolbar button. Like a normal {@link qx.ui.form.Button}
   * but with a style matching the toolbar and without keyboard support.
   */
  qx.Class.define("qx.ui.toolbar.Button", {
    extend: qx.ui.form.Button,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct(label, icon, command) {
      qx.ui.form.Button.constructor.call(this, label, icon, command); // Toolbar buttons should not support the keyboard events

      this.removeListener("keydown", this._onKeyDown);
      this.removeListener("keyup", this._onKeyUp);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "toolbar-button"
      },
      show: {
        refine: true,
        init: "inherit"
      },
      focusable: {
        refine: true,
        init: false
      }
    },
    members: {
      // overridden
      _applyVisibility: function _applyVisibility(value, old) {
        qx.ui.toolbar.Button.prototype._applyVisibility.base.call(this, value, old); // trigger a appearance recalculation of the parent


        var parent = this.getLayoutParent();

        if (parent && parent instanceof qx.ui.toolbar.PartContainer) {
          qx.ui.core.queue.Appearance.add(parent);
        }
      }
    }
  });
  qx.ui.toolbar.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The container used by {@link Part} to insert the buttons.
   *
   * @internal
   */
  qx.Class.define("qx.ui.toolbar.PartContainer", {
    extend: qx.ui.container.Composite,
    construct: function construct() {
      qx.ui.container.Composite.constructor.call(this);

      this._setLayout(new qx.ui.layout.HBox());
    },
    events: {
      /** Fired if a child has been added or removed */
      changeChildren: "qx.event.type.Event"
    },
    properties: {
      appearance: {
        refine: true,
        init: "toolbar/part/container"
      },

      /** Whether icons, labels, both or none should be shown. */
      show: {
        init: "both",
        check: ["both", "label", "icon"],
        inheritable: true,
        event: "changeShow"
      }
    },
    members: {
      // overridden
      _afterAddChild: function _afterAddChild(child) {
        this.fireEvent("changeChildren");
      },
      // overridden
      _afterRemoveChild: function _afterRemoveChild(child) {
        this.fireEvent("changeChildren");
      }
    }
  });
  qx.ui.toolbar.PartContainer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.LayoutItem": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * All of the resizing information about a column.
   *
   *  This is used internally by qx.ui.table and qx.ui.progressive's table and
   *  may be used for other widgets as well.
   */
  qx.Class.define("qx.ui.core.ColumnData", {
    extend: qx.ui.core.LayoutItem,
    construct: function construct() {
      qx.ui.core.LayoutItem.constructor.call(this);
      this.setColumnWidth("auto");
    },
    members: {
      __computedWidth__P_373_0: null,
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        this.__computedWidth__P_373_0 = width;
      },

      /**
       * Get the computed width of the column.
       * @return {Integer} Computed column width
       */
      getComputedWidth: function getComputedWidth() {
        return this.__computedWidth__P_373_0;
      },

      /**
       * Get the column's flex value
       *
       * @return {Integer} The column's flex value
       */
      getFlex: function getFlex() {
        return this.getLayoutProperties().flex || 0;
      },

      /**
       * Set the column width. The column width can be one of the following
       * values:
       *
       * * Pixels: e.g. <code>23</code>
       * * Autosized: <code>"auto"</code>
       * * Flex: e.g. <code>"1*"</code>
       * * Percent: e.g. <code>"33%"</code>
       *
       * @param width {Integer|String} The column width
       * @param flex {Integer?0} Optional flex value of the column
       */
      setColumnWidth: function setColumnWidth(width, flex) {
        var flex = flex || 0;
        var percent = null;

        if (typeof width == "number") {
          this.setWidth(width);
        } else if (typeof width == "string") {
          if (width == "auto") {
            flex = 1;
          } else {
            var match = width.match(/^[0-9]+(?:\.[0-9]+)?([%\*])$/);

            if (match) {
              if (match[1] == "*") {
                flex = parseFloat(width);
              } else {
                percent = width;
              }
            }
          }
        }

        this.setLayoutProperties({
          flex: flex,
          width: percent
        });
      }
    },
    environment: {
      "qx.tableResizeDebug": false
    }
  });
  qx.ui.core.ColumnData.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * This mixin links all methods to manage the multi selection from the
   * internal selection manager to the widget.
   */
  qx.Mixin.define("qx.ui.core.MMultiSelectionHandling", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      // Create selection manager
      var clazz = this.SELECTION_MANAGER;
      var manager = this.__manager__P_382_0 = new clazz(this); // Add widget event listeners

      this.addListener("pointerdown", manager.handlePointerDown, manager);
      this.addListener("tap", manager.handleTap, manager);
      this.addListener("pointerover", manager.handlePointerOver, manager);
      this.addListener("pointermove", manager.handlePointerMove, manager);
      this.addListener("losecapture", manager.handleLoseCapture, manager);
      this.addListener("keypress", manager.handleKeyPress, manager);
      this.addListener("addItem", manager.handleAddItem, manager);
      this.addListener("removeItem", manager.handleRemoveItem, manager); // Add manager listeners

      manager.addListener("changeSelection", this._onSelectionChange, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data",

      /** Fires after the selection was modified */
      "changeSelection": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The selection mode to use.
       *
       * For further details please have a look at:
       * {@link qx.ui.core.selection.Abstract#mode}
       */
      selectionMode: {
        check: ["single", "multi", "additive", "one"],
        init: "single",
        apply: "_applySelectionMode"
      },

      /**
       * Enable drag selection (multi selection of items through
       * dragging the pointer in pressed states).
       *
       * Only possible for the selection modes <code>multi</code> and <code>additive</code>
       */
      dragSelection: {
        check: "Boolean",
        init: false,
        apply: "_applyDragSelection"
      },

      /**
       * Enable quick selection mode, where no tap is needed to change the selection.
       *
       * Only possible for the modes <code>single</code> and <code>one</code>.
       */
      quickSelection: {
        check: "Boolean",
        init: false,
        apply: "_applyQuickSelection"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.core.selection.Abstract} The selection manager */
      __manager__P_382_0: null,

      /** @type {Boolean} used to control recursion in onSelectionChange */
      __inOnSelectionChange__P_382_1: false,

      /*
      ---------------------------------------------------------------------------
        USER API
      ---------------------------------------------------------------------------
      */

      /**
       * setValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @param items {null|qx.ui.core.Widget[]} Items to select.
       * @returns {null|TypeError} The status of this operation.
       */
      setValue: function setValue(items) {
        if (null === items) {
          this.__manager__P_382_0.clearSelection();

          return null;
        }

        {
          for (var i = 0, l = items.length; i < l; i++) {
            if (!(items[i] instanceof qx.ui.core.Widget)) {
              return new TypeError("Some items in provided argument are not widgets");
            }
          }
        }

        try {
          this.setSelection(items);
          return null;
        } catch (e) {
          return e;
        }
      },

      /**
       * getValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @returns {qx.ui.core.Widget[]} The selected widgets or null if there are none.
       */
      getValue: function getValue() {
        return this.__manager__P_382_0.getSelection();
      },

      /**
       * resetValue implements part of the {@link qx.ui.form.IField} interface.
       */
      resetValue: function resetValue() {
        this.__manager__P_382_0.clearSelection();
      },

      /**
       * Selects all items of the managed object.
       */
      selectAll: function selectAll() {
        this.__manager__P_382_0.selectAll();
      },

      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {qx.ui.core.Widget} Any valid selectable item.
       * @return {Boolean} Whether the item is selected.
       * @throws {Error} if the item is not a child element.
       */
      isSelected: function isSelected(item) {
        if (!qx.ui.core.Widget.contains(this, item)) {
          throw new Error("Could not test if " + item + " is selected, because it is not a child element!");
        }

        return this.__manager__P_382_0.isItemSelected(item);
      },

      /**
       * Adds the given item to the existing selection.
       *
       * Use {@link #setSelection} instead if you want to replace
       * the current selection.
       *
       * @param item {qx.ui.core.Widget} Any valid item.
       * @throws {Error} if the item is not a child element.
       */
      addToSelection: function addToSelection(item) {
        if (!qx.ui.core.Widget.contains(this, item)) {
          throw new Error("Could not add + " + item + " to selection, because it is not a child element!");
        }

        this.__manager__P_382_0.addItem(item);
      },

      /**
       * Removes the given item from the selection.
       *
       * Use {@link #resetSelection} when you want to clear
       * the whole selection at once.
       *
       * @param item {qx.ui.core.Widget} Any valid item
       * @throws {Error} if the item is not a child element.
       */
      removeFromSelection: function removeFromSelection(item) {
        if (!qx.ui.core.Widget.contains(this, item)) {
          throw new Error("Could not remove " + item + " from selection, because it is not a child element!");
        }

        this.__manager__P_382_0.removeItem(item);
      },

      /**
       * Selects an item range between two given items.
       *
       * @param begin {qx.ui.core.Widget} Item to start with
       * @param end {qx.ui.core.Widget} Item to end at
       */
      selectRange: function selectRange(begin, end) {
        this.__manager__P_382_0.selectItemRange(begin, end);
      },

      /**
       * Clears the whole selection at once. Also
       * resets the lead and anchor items and their
       * styles.
       */
      resetSelection: function resetSelection() {
        this.__manager__P_382_0.clearSelection();
      },

      /**
       * Replaces current selection with the given items.
       *
       * @param items {qx.ui.core.Widget[]} Items to select.
       * @throws {Error} if one of the items is not a child element and if
       *    the mode is set to <code>single</code> or <code>one</code> and
       *    the items contains more than one item.
       */
      setSelection: function setSelection(items) {
        // Block recursion so that when selection changes modelSelection, the modelSelection
        //  cannot change selection again; this is important because modelSelection does not
        //  necessarily match selection, for example when the item's model properties are
        //  null.
        if (this.__inOnSelectionChange__P_382_1) {
          return;
        }

        for (var i = 0; i < items.length; i++) {
          if (!qx.ui.core.Widget.contains(this, items[i])) {
            throw new Error("Could not select " + items[i] + ", because it is not a child element!");
          }
        }

        if (items.length === 0) {
          this.resetSelection();
        } else {
          var currentSelection = this.getSelection();

          if (!qx.lang.Array.equals(currentSelection, items)) {
            this.__manager__P_382_0.replaceSelection(items);
          }
        }
      },

      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {qx.ui.core.Widget[]} List of items.
       */
      getSelection: function getSelection() {
        return this.__manager__P_382_0.getSelection();
      },

      /**
       * Returns an array of currently selected items sorted
       * by their index in the container.
       *
       * @return {qx.ui.core.Widget[]} Sorted list of items
       */
      getSortedSelection: function getSortedSelection() {
        return this.__manager__P_382_0.getSortedSelection();
      },

      /**
       * Whether the selection is empty
       *
       * @return {Boolean} Whether the selection is empty
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__manager__P_382_0.isSelectionEmpty();
      },

      /**
       * Returns the last selection context.
       *
       * @return {String | null} One of <code>tap</code>, <code>quick</code>,
       *    <code>drag</code> or <code>key</code> or <code>null</code>.
       */
      getSelectionContext: function getSelectionContext() {
        return this.__manager__P_382_0.getSelectionContext();
      },

      /**
       * Returns the internal selection manager. Use this with
       * caution!
       *
       * @return {qx.ui.core.selection.Abstract} The selection manager
       */
      _getManager: function _getManager() {
        return this.__manager__P_382_0;
      },

      /**
       * Returns all elements which are selectable.
       *
       * @param all {Boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       * @return {qx.ui.core.Widget[]} The contained items.
       */
      getSelectables: function getSelectables(all) {
        return this.__manager__P_382_0.getSelectables(all);
      },

      /**
       * Invert the selection. Select the non selected and deselect the selected.
       */
      invertSelection: function invertSelection() {
        this.__manager__P_382_0.invertSelection();
      },

      /**
       * Returns the current lead item. Generally the item which was last modified
       * by the user (tapped on etc.)
       *
       * @return {qx.ui.core.Widget} The lead item or <code>null</code>
       */
      _getLeadItem: function _getLeadItem() {
        var mode = this.__manager__P_382_0.getMode();

        if (mode === "single" || mode === "one") {
          return this.__manager__P_382_0.getSelectedItem();
        } else {
          return this.__manager__P_382_0.getLeadItem();
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applySelectionMode: function _applySelectionMode(value, old) {
        this.__manager__P_382_0.setMode(value);
      },
      // property apply
      _applyDragSelection: function _applyDragSelection(value, old) {
        this.__manager__P_382_0.setDrag(value);
      },
      // property apply
      _applyQuickSelection: function _applyQuickSelection(value, old) {
        this.__manager__P_382_0.setQuick(value);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for <code>changeSelection</code> event on selection manager.
       *
       * @param e {qx.event.type.Data} Data event
       */
      _onSelectionChange: function _onSelectionChange(e) {
        if (this.__inOnSelectionChange__P_382_1) {
          return;
        }

        this.__inOnSelectionChange__P_382_1 = true;

        try {
          this.fireDataEvent("changeSelection", e.getData(), e.getOldData());
          this.fireDataEvent("changeValue", e.getData(), e.getOldData());
        } finally {
          this.__inOnSelectionChange__P_382_1 = false;
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__manager__P_382_0");
    }
  });
  qx.ui.core.MMultiSelectionHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This mixin is included by all widgets which supports native overflowing.
   */
  qx.Mixin.define("qx.ui.core.MNativeOverflow", {
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether the widget should have horizontal scrollbars.
       */
      overflowX: {
        check: ["hidden", "visible", "scroll", "auto"],
        nullable: true,
        apply: "_applyOverflowX"
      },

      /**
       * Whether the widget should have vertical scrollbars.
       */
      overflowY: {
        check: ["hidden", "visible", "scroll", "auto"],
        nullable: true,
        apply: "_applyOverflowY"
      },

      /**
       * Overflow group property
       */
      overflow: {
        group: ["overflowX", "overflowY"]
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // property apply
      _applyOverflowX: function _applyOverflowX(value) {
        this.getContentElement().setStyle("overflowX", value);
      },
      // property apply
      _applyOverflowY: function _applyOverflowY(value) {
        this.getContentElement().setStyle("overflowY", value);
      }
    }
  });
  qx.ui.core.MNativeOverflow.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Mixin holding the handler for the two axis mouse wheel scrolling. Please
   * keep in mind that the including widget has to have the scroll bars
   * implemented as child controls named <code>scrollbar-x</code> and
   * <code>scrollbar-y</code> to get the handler working. Also, you have to
   * attach the listener yourself.
   */
  qx.Mixin.define("qx.ui.core.scroll.MWheelHandling", {
    members: {
      /**
       * Mouse wheel event handler
       *
       * @param e {qx.event.type.Mouse} Mouse event
       */
      _onMouseWheel: function _onMouseWheel(e) {
        var showX = this._isChildControlVisible("scrollbar-x");

        var showY = this._isChildControlVisible("scrollbar-y");

        var scrollbarY = showY ? this.getChildControl("scrollbar-y", true) : null;
        var scrollbarX = showX ? this.getChildControl("scrollbar-x", true) : null;
        var deltaY = e.getWheelDelta("y");
        var deltaX = e.getWheelDelta("x");
        var endY = !showY;
        var endX = !showX; // y case

        if (scrollbarY) {
          var steps = parseInt(deltaY);

          if (steps !== 0) {
            scrollbarY.scrollBySteps(steps);
          }

          var position = scrollbarY.getPosition();
          var max = scrollbarY.getMaximum(); // pass the event to the parent if the scrollbar is at an edge

          if (steps < 0 && position <= 0 || steps > 0 && position >= max) {
            endY = true;
          }
        } // x case


        if (scrollbarX) {
          var steps = parseInt(deltaX);

          if (steps !== 0) {
            scrollbarX.scrollBySteps(steps);
          }

          var position = scrollbarX.getPosition();
          var max = scrollbarX.getMaximum(); // pass the event to the parent if the scrollbar is at an edge

          if (steps < 0 && position <= 0 || steps > 0 && position >= max) {
            endX = true;
          }
        } // pass the event to the parent if both scrollbars are at the end


        if (!endY && deltaX === 0 || !endX && deltaY === 0 || (!endX || !endY) && deltaX !== 0 && deltaY !== 0) {
          // Stop bubbling and native event only if a scrollbar is visible
          e.stop();
        }
      }
    }
  });
  qx.ui.core.scroll.MWheelHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.scroll.IScrollBar": {
        "require": true
      },
      "qx.html.Element": {},
      "qx.bom.element.Scroll": {},
      "qx.ui.core.queue.Layout": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.bom.AnimationFrame": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.name": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The scroll bar widget wraps the native browser scroll bars as a qooxdoo widget.
   * It can be uses instead of the styled qooxdoo scroll bars.
   *
   * Scroll bars are used by the {@link qx.ui.container.Scroll} container. Usually
   * a scroll bar is not used directly.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var scrollBar = new qx.ui.core.scroll.NativeScrollBar("horizontal");
   *   scrollBar.set({
   *     maximum: 500
   *   })
   *   this.getRoot().add(scrollBar);
   * </pre>
   *
   * This example creates a horizontal scroll bar with a maximum value of 500.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/scrollbar.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.core.scroll.NativeScrollBar", {
    extend: qx.ui.core.Widget,
    implement: qx.ui.core.scroll.IScrollBar,

    /**
     * @param orientation {String?"horizontal"} The initial scroll bar orientation
     */
    construct: function construct(orientation) {
      qx.ui.core.Widget.constructor.call(this);
      this.addState("native");
      this.getContentElement().addListener("scroll", this._onScroll, this);
      this.addListener("pointerdown", this._stopPropagation, this);
      this.addListener("pointerup", this._stopPropagation, this);
      this.addListener("pointermove", this._stopPropagation, this);
      this.addListener("appear", this._onAppear, this);
      this.getContentElement().add(this._getScrollPaneElement());
      this.getContentElement().setStyle("box-sizing", "content-box"); // Configure orientation

      if (orientation != null) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      } // prevent drag & drop on scrolling


      this.addListener("track", function (e) {
        e.stopPropagation();
      }, this);
    },
    events: {
      /**
       * Fired as soon as the scroll animation ended.
       */
      scrollAnimationEnd: 'qx.event.type.Event'
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "scrollbar"
      },
      // interface implementation
      orientation: {
        check: ["horizontal", "vertical"],
        init: "horizontal",
        apply: "_applyOrientation"
      },
      // interface implementation
      maximum: {
        check: "PositiveInteger",
        apply: "_applyMaximum",
        init: 100
      },
      // interface implementation
      position: {
        check: "Number",
        init: 0,
        apply: "_applyPosition",
        event: "scroll"
      },

      /**
       * Step size for each tap on the up/down or left/right buttons.
       */
      singleStep: {
        check: "Integer",
        init: 20
      },
      // interface implementation
      knobFactor: {
        check: "PositiveNumber",
        nullable: true
      }
    },
    members: {
      __isHorizontal__P_395_0: null,
      __scrollPaneElement__P_395_1: null,
      __requestId__P_395_2: null,
      __scrollAnimationframe__P_395_3: null,

      /**
       * Get the scroll pane html element.
       *
       * @return {qx.html.Element} The element
       */
      _getScrollPaneElement: function _getScrollPaneElement() {
        if (!this.__scrollPaneElement__P_395_1) {
          this.__scrollPaneElement__P_395_1 = new qx.html.Element();
        }

        return this.__scrollPaneElement__P_395_1;
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        var changes = qx.ui.core.scroll.NativeScrollBar.prototype.renderLayout.base.call(this, left, top, width, height);

        this._updateScrollBar();

        return changes;
      },
      // overridden
      _getContentHint: function _getContentHint() {
        var scrollbarWidth = qx.bom.element.Scroll.getScrollbarWidth();
        return {
          width: this.__isHorizontal__P_395_0 ? 100 : scrollbarWidth,
          maxWidth: this.__isHorizontal__P_395_0 ? null : scrollbarWidth,
          minWidth: this.__isHorizontal__P_395_0 ? null : scrollbarWidth,
          height: this.__isHorizontal__P_395_0 ? scrollbarWidth : 100,
          maxHeight: this.__isHorizontal__P_395_0 ? scrollbarWidth : null,
          minHeight: this.__isHorizontal__P_395_0 ? scrollbarWidth : null
        };
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.core.scroll.NativeScrollBar.prototype._applyEnabled.base.call(this, value, old);

        this._updateScrollBar();
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyMaximum: function _applyMaximum(value) {
        this._updateScrollBar();
      },
      // property apply
      _applyPosition: function _applyPosition(value) {
        var content = this.getContentElement();

        if (this.__isHorizontal__P_395_0) {
          content.scrollToX(value);
        } else {
          content.scrollToY(value);
        }
      },
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        var isHorizontal = this.__isHorizontal__P_395_0 = value === "horizontal";
        this.set({
          allowGrowX: isHorizontal,
          allowShrinkX: isHorizontal,
          allowGrowY: !isHorizontal,
          allowShrinkY: !isHorizontal
        });

        if (isHorizontal) {
          this.replaceState("vertical", "horizontal");
        } else {
          this.replaceState("horizontal", "vertical");
        }

        this.getContentElement().setStyles({
          overflowX: isHorizontal ? "scroll" : "hidden",
          overflowY: isHorizontal ? "hidden" : "scroll"
        }); // Update layout

        qx.ui.core.queue.Layout.add(this);
      },

      /**
       * Update the scroll bar according to its current size, max value and
       * enabled state.
       */
      _updateScrollBar: function _updateScrollBar() {
        var isHorizontal = this.__isHorizontal__P_395_0;
        var bounds = this.getBounds();

        if (!bounds) {
          return;
        }

        if (this.isEnabled()) {
          var containerSize = isHorizontal ? bounds.width : bounds.height;
          var innerSize = this.getMaximum() + containerSize;
        } else {
          innerSize = 0;
        } // Scrollbars don't work properly in IE/Edge if the element with overflow has
        // exactly the size of the scrollbar. Thus we move the element one pixel
        // out of the view and increase the size by one.


        if (qx.core.Environment.get("engine.name") == "mshtml" || qx.core.Environment.get("browser.name") == "edge") {
          var bounds = this.getBounds();
          this.getContentElement().setStyles({
            left: (isHorizontal ? bounds.left : bounds.left - 1) + "px",
            top: (isHorizontal ? bounds.top - 1 : bounds.top) + "px",
            width: (isHorizontal ? bounds.width : bounds.width + 1) + "px",
            height: (isHorizontal ? bounds.height + 1 : bounds.height) + "px"
          });
        }

        this._getScrollPaneElement().setStyles({
          left: 0,
          top: 0,
          width: (isHorizontal ? innerSize : 1) + "px",
          height: (isHorizontal ? 1 : innerSize) + "px"
        });

        this.updatePosition(this.getPosition());
      },
      // interface implementation
      scrollTo: function scrollTo(position, duration) {
        // if a user sets a new position, stop any animation
        this.stopScrollAnimation();

        if (duration) {
          var from = this.getPosition();
          this.__scrollAnimationframe__P_395_3 = new qx.bom.AnimationFrame();

          this.__scrollAnimationframe__P_395_3.on("frame", function (timePassed) {
            var newPos = parseInt(timePassed / duration * (position - from) + from);
            this.updatePosition(newPos);
          }, this);

          this.__scrollAnimationframe__P_395_3.on("end", function () {
            this.setPosition(Math.max(0, Math.min(this.getMaximum(), position)));
            this.__scrollAnimationframe__P_395_3 = null;
            this.fireEvent("scrollAnimationEnd");
          }, this);

          this.__scrollAnimationframe__P_395_3.startSequence(duration);
        } else {
          this.updatePosition(position);
        }
      },

      /**
       * Helper to set the new position taking care of min and max values.
       * @param position {Number} The new position.
       */
      updatePosition: function updatePosition(position) {
        this.setPosition(Math.max(0, Math.min(this.getMaximum(), position)));
      },
      // interface implementation
      scrollBy: function scrollBy(offset, duration) {
        this.scrollTo(this.getPosition() + offset, duration);
      },
      // interface implementation
      scrollBySteps: function scrollBySteps(steps, duration) {
        var size = this.getSingleStep();
        this.scrollBy(steps * size, duration);
      },

      /**
       * If a scroll animation is running, it will be stopped.
       */
      stopScrollAnimation: function stopScrollAnimation() {
        if (this.__scrollAnimationframe__P_395_3) {
          this.__scrollAnimationframe__P_395_3.cancelSequence();

          this.__scrollAnimationframe__P_395_3 = null;
        }
      },

      /**
       * Scroll event handler
       *
       * @param e {qx.event.type.Event} the scroll event
       */
      _onScroll: function _onScroll(e) {
        var container = this.getContentElement();
        var position = this.__isHorizontal__P_395_0 ? container.getScrollX() : container.getScrollY();
        this.setPosition(position);
      },

      /**
       * Listener for appear which ensured the scroll bar is positioned right
       * on appear.
       *
       * @param e {qx.event.type.Data} Incoming event object
       */
      _onAppear: function _onAppear(e) {
        this._applyPosition(this.getPosition());
      },

      /**
       * Stops propagation on the given even
       *
       * @param e {qx.event.type.Event} the event
       */
      _stopPropagation: function _stopPropagation(e) {
        e.stopPropagation();
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__scrollPaneElement__P_395_1");
    }
  });
  qx.ui.core.scroll.NativeScrollBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.lang.Object": {},
      "qx.bom.client.OperatingSystem": {},
      "qx.event.Timer": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "os.name": {
          "className": "qx.bom.client.OperatingSystem"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Generic selection manager to bring rich desktop like selection behavior
   * to widgets and low-level interactive controls.
   *
   * The selection handling supports both Shift and Ctrl/Meta modifies like
   * known from native applications.
   */
  qx.Class.define("qx.ui.core.selection.Abstract", {
    type: "abstract",
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this); // {Map} Internal selection storage

      this.__selection__P_398_0 = {};
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fires after the selection was modified. Contains the selection under the data property. */
      "changeSelection": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Selects the selection mode to use.
       *
       * * single: One or no element is selected
       * * multi: Multi items could be selected. Also allows empty selections.
       * * additive: Easy Web-2.0 selection mode. Allows multiple selections without modifier keys.
       * * one: If possible always exactly one item is selected
       */
      mode: {
        check: ["single", "multi", "additive", "one"],
        init: "single",
        apply: "_applyMode"
      },

      /**
       * Enable drag selection (multi selection of items through
       * dragging the pointer in pressed states).
       *
       * Only possible for the modes <code>multi</code> and <code>additive</code>
       */
      drag: {
        check: "Boolean",
        init: false
      },

      /**
       * Enable quick selection mode, where no tap is needed to change the selection.
       *
       * Only possible for the modes <code>single</code> and <code>one</code>.
       */
      quick: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __scrollStepX__P_398_1: 0,
      __scrollStepY__P_398_2: 0,
      __scrollTimer__P_398_3: null,
      __frameScroll__P_398_4: null,
      __lastRelX__P_398_5: null,
      __lastRelY__P_398_6: null,
      __frameLocation__P_398_7: null,
      __dragStartX__P_398_8: null,
      __dragStartY__P_398_9: null,
      __inCapture__P_398_10: null,
      __pointerX__P_398_11: null,
      __pointerY__P_398_12: null,
      __moveDirectionX__P_398_13: null,
      __moveDirectionY__P_398_14: null,
      __selectionModified__P_398_15: null,
      __selectionContext__P_398_16: null,
      __leadItem__P_398_17: null,
      __selection__P_398_0: null,
      __anchorItem__P_398_18: null,
      __pointerDownOnSelected__P_398_19: null,
      // A flag that signals an user interaction, which means the selection change
      // was triggered by pointer or keyboard [BUG #3344]
      _userInteraction: false,
      __oldScrollTop__P_398_20: null,

      /*
      ---------------------------------------------------------------------------
        USER APIS
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the selection context. One of <code>tap</code>,
       * <code>quick</code>, <code>drag</code> or <code>key</code> or
       * <code>null</code>.
       *
       * @return {String} One of <code>tap</code>, <code>quick</code>,
       *    <code>drag</code> or <code>key</code> or <code>null</code>
       */
      getSelectionContext: function getSelectionContext() {
        return this.__selectionContext__P_398_16;
      },

      /**
       * Selects all items of the managed object.
       *
       */
      selectAll: function selectAll() {
        var mode = this.getMode();

        if (mode == "single" || mode == "one") {
          throw new Error("Can not select all items in selection mode: " + mode);
        }

        this._selectAllItems();

        this._fireChange();
      },

      /**
       * Selects the given item. Replaces current selection
       * completely with the new item.
       *
       * Use {@link #addItem} instead if you want to add new
       * items to an existing selection.
       *
       * @param item {Object} Any valid item
       */
      selectItem: function selectItem(item) {
        this._setSelectedItem(item);

        var mode = this.getMode();

        if (mode !== "single" && mode !== "one") {
          this._setLeadItem(item);

          this._setAnchorItem(item);
        }

        this._scrollItemIntoView(item);

        this._fireChange();
      },

      /**
       * Adds the given item to the existing selection.
       *
       * Use {@link #selectItem} instead if you want to replace
       * the current selection.
       *
       * @param item {Object} Any valid item
       */
      addItem: function addItem(item) {
        var mode = this.getMode();

        if (mode === "single" || mode === "one") {
          this._setSelectedItem(item);
        } else {
          if (this._getAnchorItem() == null) {
            this._setAnchorItem(item);
          }

          this._setLeadItem(item);

          this._addToSelection(item);
        }

        this._scrollItemIntoView(item);

        this._fireChange();
      },

      /**
       * Removes the given item from the selection.
       *
       * Use {@link #clearSelection} when you want to clear
       * the whole selection at once.
       *
       * @param item {Object} Any valid item
       */
      removeItem: function removeItem(item) {
        this._removeFromSelection(item);

        if (this.getMode() === "one" && this.isSelectionEmpty()) {
          var selected = this._applyDefaultSelection(); // Do not fire any event in this case.


          if (selected == item) {
            return;
          }
        }

        if (this.getLeadItem() == item) {
          this._setLeadItem(null);
        }

        if (this._getAnchorItem() == item) {
          this._setAnchorItem(null);
        }

        this._fireChange();
      },

      /**
       * Selects an item range between two given items.
       *
       * @param begin {Object} Item to start with
       * @param end {Object} Item to end at
       */
      selectItemRange: function selectItemRange(begin, end) {
        var mode = this.getMode();

        if (mode == "single" || mode == "one") {
          throw new Error("Can not select multiple items in selection mode: " + mode);
        }

        this._selectItemRange(begin, end);

        this._setAnchorItem(begin);

        this._setLeadItem(end);

        this._scrollItemIntoView(end);

        this._fireChange();
      },

      /**
       * Clears the whole selection at once. Also
       * resets the lead and anchor items and their
       * styles.
       *
       */
      clearSelection: function clearSelection() {
        if (this.getMode() == "one") {
          var selected = this._applyDefaultSelection(true);

          if (selected != null) {
            return;
          }
        }

        this._clearSelection();

        this._setLeadItem(null);

        this._setAnchorItem(null);

        this._fireChange();
      },

      /**
       * Replaces current selection with given array of items.
       *
       * Please note that in single selection scenarios it is more
       * efficient to directly use {@link #selectItem}.
       *
       * @param items {Array} Items to select
       */
      replaceSelection: function replaceSelection(items) {
        var mode = this.getMode();

        if (mode == "one" || mode === "single") {
          if (items.length > 1) {
            throw new Error("Could not select more than one items in mode: " + mode + "!");
          }

          if (items.length == 1) {
            this.selectItem(items[0]);
          } else {
            this.clearSelection();
          }

          return;
        } else {
          this._replaceMultiSelection(items);
        }
      },

      /**
       * Get the selected item. This method does only work in <code>single</code>
       * selection mode.
       *
       * @return {Object} The selected item.
       */
      getSelectedItem: function getSelectedItem() {
        var mode = this.getMode();

        if (mode === "single" || mode === "one") {
          var result = this._getSelectedItem();

          return result != undefined ? result : null;
        }

        throw new Error("The method getSelectedItem() is only supported in 'single' and 'one' selection mode!");
      },

      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {Object[]} List of items.
       */
      getSelection: function getSelection() {
        return Object.values(this.__selection__P_398_0);
      },

      /**
       * Returns the selection sorted by the index in the
       * container of the selection (the assigned widget)
       *
       * @return {Object[]} Sorted list of items
       */
      getSortedSelection: function getSortedSelection() {
        var children = this.getSelectables();
        var sel = Object.values(this.__selection__P_398_0);
        sel.sort(function (a, b) {
          return children.indexOf(a) - children.indexOf(b);
        });
        return sel;
      },

      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {var} Any valid selectable item
       * @return {Boolean} Whether the item is selected
       */
      isItemSelected: function isItemSelected(item) {
        var hash = this._selectableToHashCode(item);

        return this.__selection__P_398_0[hash] !== undefined;
      },

      /**
       * Whether the selection is empty
       *
       * @return {Boolean} Whether the selection is empty
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return qx.lang.Object.isEmpty(this.__selection__P_398_0);
      },

      /**
       * Invert the selection. Select the non selected and deselect the selected.
       */
      invertSelection: function invertSelection() {
        var mode = this.getMode();

        if (mode === "single" || mode === "one") {
          throw new Error("The method invertSelection() is only supported in 'multi' and 'additive' selection mode!");
        }

        var selectables = this.getSelectables();

        for (var i = 0; i < selectables.length; i++) {
          this._toggleInSelection(selectables[i]);
        }

        this._fireChange();
      },

      /*
      ---------------------------------------------------------------------------
        LEAD/ANCHOR SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the lead item. Generally the item which was last modified
       * by the user (tapped on etc.)
       *
       * @param value {Object} Any valid item or <code>null</code>
       */
      _setLeadItem: function _setLeadItem(value) {
        var old = this.__leadItem__P_398_17;

        if (old !== null) {
          this._styleSelectable(old, "lead", false);
        }

        if (value !== null) {
          this._styleSelectable(value, "lead", true);
        }

        this.__leadItem__P_398_17 = value;
      },

      /**
       * Returns the current lead item. Generally the item which was last modified
       * by the user (tapped on etc.)
       *
       * @return {Object} The lead item or <code>null</code>
       */
      getLeadItem: function getLeadItem() {
        return this.__leadItem__P_398_17;
      },

      /**
       * Sets the anchor item. This is the item which is the starting
       * point for all range selections. Normally this is the item which was
       * tapped on the last time without any modifier keys pressed.
       *
       * @param value {Object} Any valid item or <code>null</code>
       */
      _setAnchorItem: function _setAnchorItem(value) {
        var old = this.__anchorItem__P_398_18;

        if (old != null) {
          this._styleSelectable(old, "anchor", false);
        }

        if (value != null) {
          this._styleSelectable(value, "anchor", true);
        }

        this.__anchorItem__P_398_18 = value;
      },

      /**
       * Returns the current anchor item. This is the item which is the starting
       * point for all range selections. Normally this is the item which was
       * tapped on the last time without any modifier keys pressed.
       *
       * @return {Object} The anchor item or <code>null</code>
       */
      _getAnchorItem: function _getAnchorItem() {
        return this.__anchorItem__P_398_18 !== null ? this.__anchorItem__P_398_18 : null;
      },

      /*
      ---------------------------------------------------------------------------
        BASIC SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Whether the given item is selectable.
       *
       * @param item {var} Any item
       * @return {Boolean} <code>true</code> when the item is selectable
       */
      _isSelectable: function _isSelectable(item) {
        throw new Error("Abstract method call: _isSelectable()");
      },

      /**
       * Finds the selectable instance from a pointer event
       *
       * @param event {qx.event.type.Pointer} The pointer event
       * @return {Object|null} The resulting selectable
       */
      _getSelectableFromPointerEvent: function _getSelectableFromPointerEvent(event) {
        var target = event.getTarget(); // check for target (may be null when leaving the viewport) [BUG #4378]

        if (target && this._isSelectable(target)) {
          return target;
        }

        return null;
      },

      /**
       * Returns an unique hashcode for the given item.
       *
       * @param item {var} Any item
       * @return {String} A valid hashcode
       */
      _selectableToHashCode: function _selectableToHashCode(item) {
        throw new Error("Abstract method call: _selectableToHashCode()");
      },

      /**
       * Updates the style (appearance) of the given item.
       *
       * @param item {var} Item to modify
       * @param type {String} Any of <code>selected</code>, <code>anchor</code> or <code>lead</code>
       * @param enabled {Boolean} Whether the given style should be added or removed.
       */
      _styleSelectable: function _styleSelectable(item, type, enabled) {
        throw new Error("Abstract method call: _styleSelectable()");
      },

      /**
       * Enables capturing of the container.
       *
       */
      _capture: function _capture() {
        throw new Error("Abstract method call: _capture()");
      },

      /**
       * Releases capturing of the container
       *
       */
      _releaseCapture: function _releaseCapture() {
        throw new Error("Abstract method call: _releaseCapture()");
      },

      /*
      ---------------------------------------------------------------------------
        DIMENSION AND LOCATION
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the location of the container
       *
       * @return {Map} Map with the keys <code>top</code>, <code>right</code>,
       *    <code>bottom</code> and <code>left</code>.
       */
      _getLocation: function _getLocation() {
        throw new Error("Abstract method call: _getLocation()");
      },

      /**
       * Returns the dimension of the container (available scrolling space).
       *
       * @return {Map} Map with the keys <code>width</code> and <code>height</code>.
       */
      _getDimension: function _getDimension() {
        throw new Error("Abstract method call: _getDimension()");
      },

      /**
       * Returns the relative (to the container) horizontal location of the given item.
       *
       * @param item {var} Any item
       * @return {Map} A map with the keys <code>left</code> and <code>right</code>.
       */
      _getSelectableLocationX: function _getSelectableLocationX(item) {
        throw new Error("Abstract method call: _getSelectableLocationX()");
      },

      /**
       * Returns the relative (to the container) horizontal location of the given item.
       *
       * @param item {var} Any item
       * @return {Map} A map with the keys <code>top</code> and <code>bottom</code>.
       */
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        throw new Error("Abstract method call: _getSelectableLocationY()");
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the scroll position of the container.
       *
       * @return {Map} Map with the keys <code>left</code> and <code>top</code>.
       */
      _getScroll: function _getScroll() {
        throw new Error("Abstract method call: _getScroll()");
      },

      /**
       * Scrolls by the given offset
       *
       * @param xoff {Integer} Horizontal offset to scroll by
       * @param yoff {Integer} Vertical offset to scroll by
       */
      _scrollBy: function _scrollBy(xoff, yoff) {
        throw new Error("Abstract method call: _scrollBy()");
      },

      /**
       * Scrolls the given item into the view (make it visible)
       *
       * @param item {var} Any item
       */
      _scrollItemIntoView: function _scrollItemIntoView(item) {
        throw new Error("Abstract method call: _scrollItemIntoView()");
      },

      /*
      ---------------------------------------------------------------------------
        QUERY SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Returns all selectable items of the container.
       *
       * @param all {Boolean} true for all selectables, false for the
        *   selectables the user can interactively select
       * @return {Array} A list of items
       */
      getSelectables: function getSelectables(all) {
        throw new Error("Abstract method call: getSelectables()");
      },

      /**
       * Returns all selectable items between the two given items.
       *
       * The items could be given in any order.
       *
       * @param item1 {var} First item
       * @param item2 {var} Second item
       * @return {Array} List of items
       */
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        throw new Error("Abstract method call: _getSelectableRange()");
      },

      /**
       * Returns the first selectable item.
       *
       * @return {var} The first selectable item
       */
      _getFirstSelectable: function _getFirstSelectable() {
        throw new Error("Abstract method call: _getFirstSelectable()");
      },

      /**
       * Returns the last selectable item.
       *
       * @return {var} The last selectable item
       */
      _getLastSelectable: function _getLastSelectable() {
        throw new Error("Abstract method call: _getLastSelectable()");
      },

      /**
       * Returns a selectable item which is related to the given
       * <code>item</code> through the value of <code>relation</code>.
       *
       * @param item {var} Any item
       * @param relation {String} A valid relation: <code>above</code>,
       *    <code>right</code>, <code>under</code> or <code>left</code>
       * @return {var} The related item
       */
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        throw new Error("Abstract method call: _getRelatedSelectable()");
      },

      /**
       * Returns the item which should be selected on pageUp/pageDown.
       *
       * May also scroll to the needed position.
       *
       * @param lead {var} The current lead item
       * @param up {Boolean?false} Which page key was pressed:
       *   <code>up</code> or <code>down</code>.
       */
      _getPage: function _getPage(lead, up) {
        throw new Error("Abstract method call: _getPage()");
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyMode: function _applyMode(value, old) {
        this._setLeadItem(null);

        this._setAnchorItem(null);

        this._clearSelection(); // Mode "one" requires one selected item


        if (value === "one") {
          this._applyDefaultSelection(true);
        }

        this._fireChange();
      },

      /*
      ---------------------------------------------------------------------------
        POINTER SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * This method should be connected to the <code>pointerover</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.Pointer} A valid pointer event
       */
      handlePointerOver: function handlePointerOver(event) {
        // All browsers (except Opera) fire a native "mouseover" event when a scroll appears
        // by keyboard interaction. We have to ignore the event to avoid a selection for
        // "pointerover" (quick selection). For more details see [BUG #4225]
        if (this.__oldScrollTop__P_398_20 != null && this.__oldScrollTop__P_398_20 != this._getScroll().top) {
          this.__oldScrollTop__P_398_20 = null;
          return;
        } // quick select should only work on mouse events


        if (event.getPointerType() != "mouse") {
          return;
        } // this is a method invoked by an user interaction, so be careful to
        // set / clear the mark this._userInteraction [BUG #3344]


        this._userInteraction = true;

        if (!this.getQuick()) {
          this._userInteraction = false;
          return;
        }

        var mode = this.getMode();

        if (mode !== "one" && mode !== "single") {
          this._userInteraction = false;
          return;
        }

        var item = this._getSelectableFromPointerEvent(event);

        if (item === null) {
          this._userInteraction = false;
          return;
        }

        this._setSelectedItem(item); // Be sure that item is in view
        // This does not feel good when pointerover is used
        // this._scrollItemIntoView(item);
        // Fire change event as needed


        this._fireChange("quick");

        this._userInteraction = false;
      },

      /**
       * This method should be connected to the <code>pointerdown</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.Pointer} A valid pointer event
       */
      handlePointerDown: function handlePointerDown(event) {
        // this is a method invoked by an user interaction, so be careful to
        // set / clear the mark this._userInteraction [BUG #3344]
        this._userInteraction = true;

        var item = this._getSelectableFromPointerEvent(event);

        if (item === null) {
          this._userInteraction = false;
          return;
        } // Read in keyboard modifiers


        var isCtrlPressed = event.isCtrlPressed() || qx.core.Environment.get("os.name") == "osx" && event.isMetaPressed();
        var isShiftPressed = event.isShiftPressed(); // tapping on selected items deselect on pointerup, not on pointerdown

        if (this.isItemSelected(item) && !isShiftPressed && !isCtrlPressed && !this.getDrag()) {
          this.__pointerDownOnSelected__P_398_19 = item;
          this._userInteraction = false;
          return;
        } else {
          this.__pointerDownOnSelected__P_398_19 = null;
        } // Be sure that item is in view


        this._scrollItemIntoView(item); // Drag selection


        var mode = this.getMode();

        if (this.getDrag() && mode !== "single" && mode !== "one" && !isShiftPressed && !isCtrlPressed && event.getPointerType() == "mouse") {
          this._setAnchorItem(item);

          this._setLeadItem(item); // Cache location/scroll data


          this.__frameLocation__P_398_7 = this._getLocation();
          this.__frameScroll__P_398_4 = this._getScroll(); // Store position at start

          this.__dragStartX__P_398_8 = event.getDocumentLeft() + this.__frameScroll__P_398_4.left;
          this.__dragStartY__P_398_9 = event.getDocumentTop() + this.__frameScroll__P_398_4.top; // Switch to capture mode

          this.__inCapture__P_398_10 = true;

          this._capture();
        } // Fire change event as needed


        this._fireChange("tap");

        this._userInteraction = false;
      },

      /**
       * This method should be connected to the <code>tap</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.Tap} A valid pointer event
       */
      handleTap: function handleTap(event) {
        // this is a method invoked by an user interaction, so be careful to
        // set / clear the mark this._userInteraction [BUG #3344]
        this._userInteraction = true; // Read in keyboard modifiers

        var isCtrlPressed = event.isCtrlPressed() || qx.core.Environment.get("os.name") == "osx" && event.isMetaPressed();
        var isShiftPressed = event.isShiftPressed();

        if (!isCtrlPressed && !isShiftPressed && this.__pointerDownOnSelected__P_398_19 != null) {
          this._userInteraction = false;

          var item = this._getSelectableFromPointerEvent(event);

          if (item === null || !this.isItemSelected(item)) {
            return;
          }
        }

        var item = this._getSelectableFromPointerEvent(event);

        if (item === null) {
          this._userInteraction = false;
          return;
        } // Action depends on selected mode


        switch (this.getMode()) {
          case "single":
          case "one":
            this._setSelectedItem(item);

            break;

          case "additive":
            this._setLeadItem(item);

            this._setAnchorItem(item);

            this._toggleInSelection(item);

            break;

          case "multi":
            // Update lead item
            this._setLeadItem(item); // Create/Update range selection


            if (isShiftPressed) {
              var anchor = this._getAnchorItem();

              if (anchor === null) {
                anchor = this._getFirstSelectable();

                this._setAnchorItem(anchor);
              }

              this._selectItemRange(anchor, item, isCtrlPressed);
            } // Toggle in selection
            else if (isCtrlPressed) {
                this._setAnchorItem(item);

                this._toggleInSelection(item);
              } // Replace current selection
              else {
                  this._setAnchorItem(item);

                  this._setSelectedItem(item);
                }

            break;
        } // Cleanup operation


        this._userInteraction = false;

        this._cleanup();
      },

      /**
       * This method should be connected to the <code>losecapture</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.Pointer} A valid pointer event
       */
      handleLoseCapture: function handleLoseCapture(event) {
        this._cleanup();
      },

      /**
       * This method should be connected to the <code>pointermove</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.Pointer} A valid pointer event
       */
      handlePointerMove: function handlePointerMove(event) {
        // Only relevant when capturing is enabled
        if (!this.__inCapture__P_398_10) {
          return;
        } // Update pointer position cache


        this.__pointerX__P_398_11 = event.getDocumentLeft();
        this.__pointerY__P_398_12 = event.getDocumentTop(); // this is a method invoked by an user interaction, so be careful to
        // set / clear the mark this._userInteraction [BUG #3344]

        this._userInteraction = true; // Detect move directions

        var dragX = this.__pointerX__P_398_11 + this.__frameScroll__P_398_4.left;

        if (dragX > this.__dragStartX__P_398_8) {
          this.__moveDirectionX__P_398_13 = 1;
        } else if (dragX < this.__dragStartX__P_398_8) {
          this.__moveDirectionX__P_398_13 = -1;
        } else {
          this.__moveDirectionX__P_398_13 = 0;
        }

        var dragY = this.__pointerY__P_398_12 + this.__frameScroll__P_398_4.top;

        if (dragY > this.__dragStartY__P_398_9) {
          this.__moveDirectionY__P_398_14 = 1;
        } else if (dragY < this.__dragStartY__P_398_9) {
          this.__moveDirectionY__P_398_14 = -1;
        } else {
          this.__moveDirectionY__P_398_14 = 0;
        } // Update scroll steps


        var location = this.__frameLocation__P_398_7;

        if (this.__pointerX__P_398_11 < location.left) {
          this.__scrollStepX__P_398_1 = this.__pointerX__P_398_11 - location.left;
        } else if (this.__pointerX__P_398_11 > location.right) {
          this.__scrollStepX__P_398_1 = this.__pointerX__P_398_11 - location.right;
        } else {
          this.__scrollStepX__P_398_1 = 0;
        }

        if (this.__pointerY__P_398_12 < location.top) {
          this.__scrollStepY__P_398_2 = this.__pointerY__P_398_12 - location.top;
        } else if (this.__pointerY__P_398_12 > location.bottom) {
          this.__scrollStepY__P_398_2 = this.__pointerY__P_398_12 - location.bottom;
        } else {
          this.__scrollStepY__P_398_2 = 0;
        } // Dynamically create required timer instance


        if (!this.__scrollTimer__P_398_3) {
          this.__scrollTimer__P_398_3 = new qx.event.Timer(100);

          this.__scrollTimer__P_398_3.addListener("interval", this._onInterval, this);
        } // Start interval


        this.__scrollTimer__P_398_3.start(); // Auto select based on new cursor position


        this._autoSelect();

        event.stopPropagation();
        this._userInteraction = false;
      },

      /**
       * This method should be connected to the <code>addItem</code> event
       * of the managed object.
       *
       * @param e {qx.event.type.Data} The event object
       */
      handleAddItem: function handleAddItem(e) {
        var item = e.getData();

        if (this.getMode() === "one" && this.isSelectionEmpty()) {
          this.addItem(item);
        }
      },

      /**
       * This method should be connected to the <code>removeItem</code> event
       * of the managed object.
       *
       * @param e {qx.event.type.Data} The event object
       */
      handleRemoveItem: function handleRemoveItem(e) {
        this.removeItem(e.getData());
      },

      /*
      ---------------------------------------------------------------------------
        POINTER SUPPORT INTERNALS
      ---------------------------------------------------------------------------
      */

      /**
       * Stops all timers, release capture etc. to cleanup drag selection
       */
      _cleanup: function _cleanup() {
        if (!this.getDrag() && this.__inCapture__P_398_10) {
          return;
        } // Fire change event if needed


        if (this.__selectionModified__P_398_15) {
          this._fireChange("tap");
        } // Remove flags


        delete this.__inCapture__P_398_10;
        delete this.__lastRelX__P_398_5;
        delete this.__lastRelY__P_398_6; // Stop capturing

        this._releaseCapture(); // Stop timer


        if (this.__scrollTimer__P_398_3) {
          this.__scrollTimer__P_398_3.stop();
        }
      },

      /**
       * Event listener for timer used by drag selection
       *
       * @param e {qx.event.type.Event} Timer event
       */
      _onInterval: function _onInterval(e) {
        // Scroll by defined block size
        this._scrollBy(this.__scrollStepX__P_398_1, this.__scrollStepY__P_398_2); // Update scroll cache


        this.__frameScroll__P_398_4 = this._getScroll(); // Auto select based on new scroll position and cursor

        this._autoSelect();
      },

      /**
       * Automatically selects items based on the pointer movement during a drag selection
       */
      _autoSelect: function _autoSelect() {
        var inner = this._getDimension(); // Get current relative Y position and compare it with previous one


        var relX = Math.max(0, Math.min(this.__pointerX__P_398_11 - this.__frameLocation__P_398_7.left, inner.width)) + this.__frameScroll__P_398_4.left;

        var relY = Math.max(0, Math.min(this.__pointerY__P_398_12 - this.__frameLocation__P_398_7.top, inner.height)) + this.__frameScroll__P_398_4.top; // Compare old and new relative coordinates (for performance reasons)


        if (this.__lastRelX__P_398_5 === relX && this.__lastRelY__P_398_6 === relY) {
          return;
        }

        this.__lastRelX__P_398_5 = relX;
        this.__lastRelY__P_398_6 = relY; // Cache anchor

        var anchor = this._getAnchorItem();

        var lead = anchor; // Process X-coordinate

        var moveX = this.__moveDirectionX__P_398_13;
        var nextX, locationX;

        while (moveX !== 0) {
          // Find next item to process depending on current scroll direction
          nextX = moveX > 0 ? this._getRelatedSelectable(lead, "right") : this._getRelatedSelectable(lead, "left"); // May be null (e.g. first/last item)

          if (nextX !== null) {
            locationX = this._getSelectableLocationX(nextX); // Continue when the item is in the visible area

            if (moveX > 0 && locationX.left <= relX || moveX < 0 && locationX.right >= relX) {
              lead = nextX;
              continue;
            }
          } // Otherwise break


          break;
        } // Process Y-coordinate


        var moveY = this.__moveDirectionY__P_398_14;
        var nextY, locationY;

        while (moveY !== 0) {
          // Find next item to process depending on current scroll direction
          nextY = moveY > 0 ? this._getRelatedSelectable(lead, "under") : this._getRelatedSelectable(lead, "above"); // May be null (e.g. first/last item)

          if (nextY !== null) {
            locationY = this._getSelectableLocationY(nextY); // Continue when the item is in the visible area

            if (moveY > 0 && locationY.top <= relY || moveY < 0 && locationY.bottom >= relY) {
              lead = nextY;
              continue;
            }
          } // Otherwise break


          break;
        } // Differenciate between the two supported modes


        var mode = this.getMode();

        if (mode === "multi") {
          // Replace current selection with new range
          this._selectItemRange(anchor, lead);
        } else if (mode === "additive") {
          // Behavior depends on the fact whether the
          // anchor item is selected or not
          if (this.isItemSelected(anchor)) {
            this._selectItemRange(anchor, lead, true);
          } else {
            this._deselectItemRange(anchor, lead);
          } // Improve performance. This mode does not rely
          // on full ranges as it always extend the old
          // selection/deselection.


          this._setAnchorItem(lead);
        } // Fire change event as needed


        this._fireChange("drag");
      },

      /*
      ---------------------------------------------------------------------------
        KEYBOARD SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * @type {Map} All supported navigation keys
       *
       * @lint ignoreReferenceField(__navigationKeys)
       */
      __navigationKeys__P_398_21: {
        Home: 1,
        Down: 1,
        Right: 1,
        PageDown: 1,
        End: 1,
        Up: 1,
        Left: 1,
        PageUp: 1
      },

      /**
       * This method should be connected to the <code>keypress</code> event
       * of the managed object.
       *
       * @param event {qx.event.type.KeySequence} A valid key sequence event
       */
      handleKeyPress: function handleKeyPress(event) {
        // this is a method invoked by an user interaction, so be careful to
        // set / clear the mark this._userInteraction [BUG #3344]
        this._userInteraction = true;
        var current, next;
        var key = event.getKeyIdentifier();
        var mode = this.getMode(); // Support both control keys on Mac

        var isCtrlPressed = event.isCtrlPressed() || qx.core.Environment.get("os.name") == "osx" && event.isMetaPressed();
        var isShiftPressed = event.isShiftPressed();
        var consumed = false;

        if (key === "A" && isCtrlPressed) {
          if (mode !== "single" && mode !== "one") {
            this._selectAllItems();

            consumed = true;
          }
        } else if (key === "Escape") {
          if (mode !== "single" && mode !== "one") {
            this._clearSelection();

            consumed = true;
          }
        } else if (key === "Space") {
          var lead = this.getLeadItem();

          if (lead != null && !isShiftPressed) {
            if (isCtrlPressed || mode === "additive") {
              this._toggleInSelection(lead);
            } else {
              this._setSelectedItem(lead);
            }

            consumed = true;
          }
        } else if (this.__navigationKeys__P_398_21[key]) {
          consumed = true;

          if (mode === "single" || mode == "one") {
            current = this._getSelectedItem();
          } else {
            current = this.getLeadItem();
          }

          if (current !== null) {
            switch (key) {
              case "Home":
                next = this._getFirstSelectable();
                break;

              case "End":
                next = this._getLastSelectable();
                break;

              case "Up":
                next = this._getRelatedSelectable(current, "above");
                break;

              case "Down":
                next = this._getRelatedSelectable(current, "under");
                break;

              case "Left":
                next = this._getRelatedSelectable(current, "left");
                break;

              case "Right":
                next = this._getRelatedSelectable(current, "right");
                break;

              case "PageUp":
                next = this._getPage(current, true);
                break;

              case "PageDown":
                next = this._getPage(current, false);
                break;
            }
          } else {
            switch (key) {
              case "Home":
              case "Down":
              case "Right":
              case "PageDown":
                next = this._getFirstSelectable();
                break;

              case "End":
              case "Up":
              case "Left":
              case "PageUp":
                next = this._getLastSelectable();
                break;
            }
          } // Process result


          if (next !== null) {
            switch (mode) {
              case "single":
              case "one":
                this._setSelectedItem(next);

                break;

              case "additive":
                this._setLeadItem(next);

                break;

              case "multi":
                if (isShiftPressed) {
                  var anchor = this._getAnchorItem();

                  if (anchor === null) {
                    this._setAnchorItem(anchor = this._getFirstSelectable());
                  }

                  this._setLeadItem(next);

                  this._selectItemRange(anchor, next, isCtrlPressed);
                } else {
                  this._setAnchorItem(next);

                  this._setLeadItem(next);

                  if (!isCtrlPressed) {
                    this._setSelectedItem(next);
                  }
                }

                break;
            }

            this.__oldScrollTop__P_398_20 = this._getScroll().top;

            this._scrollItemIntoView(next);
          }
        }

        if (consumed) {
          // Stop processed events
          event.stop(); // Fire change event as needed

          this._fireChange("key");
        }

        this._userInteraction = false;
      },

      /*
      ---------------------------------------------------------------------------
        SUPPORT FOR ITEM RANGES
      ---------------------------------------------------------------------------
      */

      /**
       * Adds all items to the selection
       */
      _selectAllItems: function _selectAllItems() {
        var range = this.getSelectables();

        for (var i = 0, l = range.length; i < l; i++) {
          this._addToSelection(range[i]);
        }
      },

      /**
       * Clears current selection
       */
      _clearSelection: function _clearSelection() {
        var selection = this.__selection__P_398_0;

        for (var hash in selection) {
          this._removeFromSelection(selection[hash]);
        }

        this.__selection__P_398_0 = {};
      },

      /**
       * Select a range from <code>item1</code> to <code>item2</code>.
       *
       * @param item1 {Object} Start with this item
       * @param item2 {Object} End with this item
       * @param extend {Boolean?false} Whether the current
       *    selection should be replaced or extended.
       */
      _selectItemRange: function _selectItemRange(item1, item2, extend) {
        var range = this._getSelectableRange(item1, item2); // Remove items which are not in the detected range


        if (!extend) {
          var selected = this.__selection__P_398_0;

          var mapped = this.__rangeToMap__P_398_22(range);

          for (var hash in selected) {
            if (!mapped[hash]) {
              this._removeFromSelection(selected[hash]);
            }
          }
        } // Add new items to the selection


        for (var i = 0, l = range.length; i < l; i++) {
          this._addToSelection(range[i]);
        }
      },

      /**
       * Deselect all items between <code>item1</code> and <code>item2</code>.
       *
       * @param item1 {Object} Start with this item
       * @param item2 {Object} End with this item
       */
      _deselectItemRange: function _deselectItemRange(item1, item2) {
        var range = this._getSelectableRange(item1, item2);

        for (var i = 0, l = range.length; i < l; i++) {
          this._removeFromSelection(range[i]);
        }
      },

      /**
       * Internal method to convert a range to a map of hash
       * codes for faster lookup during selection compare routines.
       *
       * @param range {Array} List of selectable items
       */
      __rangeToMap__P_398_22: function __rangeToMap__P_398_22(range) {
        var mapped = {};
        var item;

        for (var i = 0, l = range.length; i < l; i++) {
          item = range[i];
          mapped[this._selectableToHashCode(item)] = item;
        }

        return mapped;
      },

      /*
      ---------------------------------------------------------------------------
        SINGLE ITEM QUERY AND MODIFICATION
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the first selected item. Only makes sense
       * when using manager in single selection mode.
       *
       * @return {var} The selected item (or <code>null</code>)
       */
      _getSelectedItem: function _getSelectedItem() {
        for (var hash in this.__selection__P_398_0) {
          return this.__selection__P_398_0[hash];
        }

        return null;
      },

      /**
       * Replace current selection with given item.
       *
       * @param item {var} Any valid selectable item
       */
      _setSelectedItem: function _setSelectedItem(item) {
        if (this._isSelectable(item)) {
          // If already selected try to find out if this is the only item
          var current = this.__selection__P_398_0;

          var hash = this._selectableToHashCode(item);

          if (!current[hash] || current.length >= 2) {
            this._clearSelection();

            this._addToSelection(item);
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        MODIFY ITEM SELECTION
      ---------------------------------------------------------------------------
      */

      /**
       * Adds an item to the current selection.
       *
       * @param item {Object} Any item
       */
      _addToSelection: function _addToSelection(item) {
        var hash = this._selectableToHashCode(item);

        if (this.__selection__P_398_0[hash] == null && this._isSelectable(item)) {
          this.__selection__P_398_0[hash] = item;

          this._styleSelectable(item, "selected", true);

          this.__selectionModified__P_398_15 = true;
        }
      },

      /**
       * Toggles the item e.g. remove it when already selected
       * or select it when currently not.
       *
       * @param item {Object} Any item
       */
      _toggleInSelection: function _toggleInSelection(item) {
        var hash = this._selectableToHashCode(item);

        if (this.__selection__P_398_0[hash] == null) {
          this.__selection__P_398_0[hash] = item;

          this._styleSelectable(item, "selected", true);
        } else {
          delete this.__selection__P_398_0[hash];

          this._styleSelectable(item, "selected", false);
        }

        this.__selectionModified__P_398_15 = true;
      },

      /**
       * Removes the given item from the current selection.
       *
       * @param item {Object} Any item
       */
      _removeFromSelection: function _removeFromSelection(item) {
        var hash = this._selectableToHashCode(item);

        if (this.__selection__P_398_0[hash] != null) {
          delete this.__selection__P_398_0[hash];

          this._styleSelectable(item, "selected", false);

          this.__selectionModified__P_398_15 = true;
        }
      },

      /**
       * Replaces current selection with items from given array.
       *
       * @param items {Array} List of items to select
       */
      _replaceMultiSelection: function _replaceMultiSelection(items) {
        if (items.length === 0) {
          this.clearSelection();
          return;
        }

        var modified = false; // Build map from hash codes and filter non-selectables

        var selectable, hash;
        var incoming = {};

        for (var i = 0, l = items.length; i < l; i++) {
          selectable = items[i];

          if (this._isSelectable(selectable)) {
            hash = this._selectableToHashCode(selectable);
            incoming[hash] = selectable;
          }
        } // Remember last


        var first = items[0];
        var last = selectable; // Clear old entries from map

        var current = this.__selection__P_398_0;

        for (var hash in current) {
          if (incoming[hash]) {
            // Reduce map to make next loop faster
            delete incoming[hash];
          } else {
            // update internal map
            selectable = current[hash];
            delete current[hash]; // apply styling

            this._styleSelectable(selectable, "selected", false); // remember that the selection has been modified


            modified = true;
          }
        } // Add remaining selectables to selection


        for (var hash in incoming) {
          // update internal map
          selectable = current[hash] = incoming[hash]; // apply styling

          this._styleSelectable(selectable, "selected", true); // remember that the selection has been modified


          modified = true;
        } // Do not do anything if selection is equal to previous one


        if (!modified) {
          return false;
        } // Scroll last incoming item into view


        this._scrollItemIntoView(last); // Reset anchor and lead item


        this._setLeadItem(first);

        this._setAnchorItem(first); // Finally fire change event


        this.__selectionModified__P_398_15 = true;

        this._fireChange();
      },

      /**
       * Fires the selection change event if the selection has
       * been modified.
       *
       * @param context {String} One of <code>tap</code>, <code>quick</code>,
       *    <code>drag</code> or <code>key</code> or <code>null</code>
       */
      _fireChange: function _fireChange(context) {
        if (this.__selectionModified__P_398_15) {
          // Store context
          this.__selectionContext__P_398_16 = context || null; // Fire data event which contains the current selection

          this.fireDataEvent("changeSelection", this.getSelection());
          delete this.__selectionModified__P_398_15;
        }
      },

      /**
       * Applies the default selection. The default item is the first item.
       *
       * @param force {Boolean} Whether the default selection should be forced.
       *
       * @return {var} The selected item.
       */
      _applyDefaultSelection: function _applyDefaultSelection(force) {
        if (force === true || this.getMode() === "one" && this.isSelectionEmpty()) {
          var first = this._getFirstSelectable();

          if (first != null) {
            this.selectItem(first);
          }

          return first;
        }

        return null;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__scrollTimer__P_398_3");

      this.__selection__P_398_0 = this.__pointerDownOnSelected__P_398_19 = this.__anchorItem__P_398_18 = null;
      this.__leadItem__P_398_17 = null;
    }
  });
  qx.ui.core.selection.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.selection.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.bom.element.Location": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * A selection manager, which handles the selection in widgets.
   */
  qx.Class.define("qx.ui.core.selection.Widget", {
    extend: qx.ui.core.selection.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param widget {qx.ui.core.Widget} The widget to connect to
     */
    construct: function construct(widget) {
      qx.ui.core.selection.Abstract.constructor.call(this);
      this.__widget__P_399_0 = widget;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __widget__P_399_0: null,

      /*
      ---------------------------------------------------------------------------
        BASIC SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _isSelectable: function _isSelectable(item) {
        return this._isItemSelectable(item) && item.getLayoutParent() === this.__widget__P_399_0;
      },
      // overridden
      _selectableToHashCode: function _selectableToHashCode(item) {
        return item.toHashCode();
      },
      // overridden
      _styleSelectable: function _styleSelectable(item, type, enabled) {
        enabled ? item.addState(type) : item.removeState(type);
      },
      // overridden
      _capture: function _capture() {
        this.__widget__P_399_0.capture();
      },
      // overridden
      _releaseCapture: function _releaseCapture() {
        this.__widget__P_399_0.releaseCapture();
      },

      /**
       * Helper to return the selectability of the item concerning the
       * user interaction.
       *
       * @param item {qx.ui.core.Widget} The item to check.
       * @return {Boolean} true, if the item is selectable.
       */
      _isItemSelectable: function _isItemSelectable(item) {
        if (this._userInteraction) {
          return item.isVisible() && item.isEnabled();
        } else {
          return item.isVisible();
        }
      },

      /**
       * Returns the connected widget.
       * @return {qx.ui.core.Widget} The widget
       */
      _getWidget: function _getWidget() {
        return this.__widget__P_399_0;
      },

      /*
      ---------------------------------------------------------------------------
        DIMENSION AND LOCATION
      ---------------------------------------------------------------------------
      */
      // overridden
      _getLocation: function _getLocation() {
        var elem = this.__widget__P_399_0.getContentElement().getDomElement();

        return elem ? qx.bom.element.Location.get(elem) : null;
      },
      // overridden
      _getDimension: function _getDimension() {
        return this.__widget__P_399_0.getInnerSize();
      },
      // overridden
      _getSelectableLocationX: function _getSelectableLocationX(item) {
        var computed = item.getBounds();

        if (computed) {
          return {
            left: computed.left,
            right: computed.left + computed.width
          };
        }
      },
      // overridden
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        var computed = item.getBounds();

        if (computed) {
          return {
            top: computed.top,
            bottom: computed.top + computed.height
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _getScroll: function _getScroll() {
        return {
          left: 0,
          top: 0
        };
      },
      // overridden
      _scrollBy: function _scrollBy(xoff, yoff) {// empty implementation
      },
      // overridden
      _scrollItemIntoView: function _scrollItemIntoView(item) {
        this.__widget__P_399_0.scrollChildIntoView(item);
      },

      /*
      ---------------------------------------------------------------------------
        QUERY SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      getSelectables: function getSelectables(all) {
        // if only the user selectables should be returned
        var oldUserInteraction = false;

        if (!all) {
          oldUserInteraction = this._userInteraction;
          this._userInteraction = true;
        }

        var children = this.__widget__P_399_0.getChildren();

        var result = [];
        var child;

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (this._isItemSelectable(child)) {
            result.push(child);
          }
        } // reset to the former user interaction state


        this._userInteraction = oldUserInteraction;
        return result;
      },
      // overridden
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        // Fast path for identical items
        if (item1 === item2) {
          return [item1];
        } // Iterate over children and collect all items
        // between the given two (including them)


        var children = this.__widget__P_399_0.getChildren();

        var result = [];
        var active = false;
        var child;

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (child === item1 || child === item2) {
            if (active) {
              result.push(child);
              break;
            } else {
              active = true;
            }
          }

          if (active && this._isItemSelectable(child)) {
            result.push(child);
          }
        }

        return result;
      },
      // overridden
      _getFirstSelectable: function _getFirstSelectable() {
        var children = this.__widget__P_399_0.getChildren();

        for (var i = 0, l = children.length; i < l; i++) {
          if (this._isItemSelectable(children[i])) {
            return children[i];
          }
        }

        return null;
      },
      // overridden
      _getLastSelectable: function _getLastSelectable() {
        var children = this.__widget__P_399_0.getChildren();

        for (var i = children.length - 1; i > 0; i--) {
          if (this._isItemSelectable(children[i])) {
            return children[i];
          }
        }

        return null;
      },
      // overridden
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        var vertical = this.__widget__P_399_0.getOrientation() === "vertical";

        var children = this.__widget__P_399_0.getChildren();

        var index = children.indexOf(item);
        var sibling;

        if (vertical && relation === "above" || !vertical && relation === "left") {
          for (var i = index - 1; i >= 0; i--) {
            sibling = children[i];

            if (this._isItemSelectable(sibling)) {
              return sibling;
            }
          }
        } else if (vertical && relation === "under" || !vertical && relation === "right") {
          for (var i = index + 1; i < children.length; i++) {
            sibling = children[i];

            if (this._isItemSelectable(sibling)) {
              return sibling;
            }
          }
        }

        return null;
      },
      // overridden
      _getPage: function _getPage(lead, up) {
        if (up) {
          return this._getFirstSelectable();
        } else {
          return this._getLastSelectable();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__widget__P_399_0 = null;
    }
  });
  qx.ui.core.selection.Widget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.selection.Widget": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * A selection manager, which handles the selection in widgets extending
   * {@link qx.ui.core.scroll.AbstractScrollArea}.
   */
  qx.Class.define("qx.ui.core.selection.ScrollArea", {
    extend: qx.ui.core.selection.Widget,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        BASIC SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _isSelectable: function _isSelectable(item) {
        return this._isItemSelectable(item) && item.getLayoutParent() === this._getWidget().getChildrenContainer();
      },

      /*
      ---------------------------------------------------------------------------
        DIMENSION AND LOCATION
      ---------------------------------------------------------------------------
      */
      // overridden
      _getDimension: function _getDimension() {
        return this._getWidget().getPaneSize();
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _getScroll: function _getScroll() {
        var widget = this._getWidget();

        return {
          left: widget.getScrollX(),
          top: widget.getScrollY()
        };
      },
      // overridden
      _scrollBy: function _scrollBy(xoff, yoff) {
        var widget = this._getWidget();

        widget.scrollByX(xoff);
        widget.scrollByY(yoff);
      },

      /*
      ---------------------------------------------------------------------------
        QUERY SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _getPage: function _getPage(lead, up) {
        var selectables = this.getSelectables();
        var length = selectables.length;
        var start = selectables.indexOf(lead); // Given lead is not a selectable?!?

        if (start === -1) {
          throw new Error("Invalid lead item: " + lead);
        }

        var widget = this._getWidget();

        var scrollTop = widget.getScrollY();
        var innerHeight = widget.getInnerSize().height;
        var top, bottom, found;

        if (up) {
          var min = scrollTop;
          var i = start; // Loop required to scroll pages up dynamically

          while (1) {
            // Iterate through all selectables from start
            for (; i >= 0; i--) {
              top = widget.getItemTop(selectables[i]); // This item is out of the visible block

              if (top < min) {
                // Use previous one
                found = i;
                break;
              }
            } // Nothing found. Return first item.


            if (found == null) {
              var first = this._getFirstSelectable();

              return first == lead ? null : first;
            } // Found item, but is identical to start or even before start item
            // Update min position and try on previous page


            if (found >= start) {
              // Reduce min by the distance of the lead item to the visible
              // bottom edge. This is needed instead of a simple subtraction
              // of the inner height to keep the last lead visible on page key
              // presses. This is the behavior of native toolkits as well.
              min -= innerHeight + scrollTop - widget.getItemBottom(lead);
              found = null;
              continue;
            } // Return selectable


            return selectables[found];
          }
        } else {
          var max = innerHeight + scrollTop;
          var i = start; // Loop required to scroll pages down dynamically

          while (1) {
            // Iterate through all selectables from start
            for (; i < length; i++) {
              bottom = widget.getItemBottom(selectables[i]); // This item is out of the visible block

              if (bottom > max) {
                // Use next one
                found = i;
                break;
              }
            } // Nothing found. Return last item.


            if (found == null) {
              var last = this._getLastSelectable();

              return last == lead ? null : last;
            } // Found item, but is identical to start or even before start item
            // Update max position and try on next page


            if (found <= start) {
              // Extend max by the distance of the lead item to the visible
              // top edge. This is needed instead of a simple addition
              // of the inner height to keep the last lead visible on page key
              // presses. This is the behavior of native toolkits as well.
              max += widget.getItemTop(lead) - scrollTop;
              found = null;
              continue;
            } // Return selectable


            return selectables[found];
          }
        }
      }
    }
  });
  qx.ui.core.selection.ScrollArea.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Til Schneider (til132)
       * Jonathan Weiß (jonathan_rass)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Abstract base class for iframe widgets.
   */
  qx.Class.define("qx.ui.embed.AbstractIframe", {
    extend: qx.ui.core.Widget,

    /**
     * @param source {String} URL which should initially set.
     */
    construct: function construct(source) {
      qx.ui.core.Widget.constructor.call(this);

      if (source) {
        this.setSource(source);
      }

      this._getIframeElement().addListener("navigate", this.__onNavigate__P_405_0, this);
    },
    events: {
      /**
       * The "load" event is fired after the iframe content has successfully been loaded.
       */
      "load": "qx.event.type.Event",

      /**
      * The "navigate" event is fired whenever the location of the iframe
      * changes.
      *
      * Useful to track user navigation and internally used to keep the source
      * property in sync. Only works when the destination source is of same
      * origin than the page embedding the iframe.
      */
      "navigate": "qx.event.type.Data"
    },
    properties: {
      /**
       * Source URL of the iframe.
       */
      source: {
        check: "String",
        apply: "_applySource",
        init: "about:blank"
      },

      /**
       * Name of the iframe.
       */
      frameName: {
        check: "String",
        init: "",
        apply: "_applyFrameName"
      }
    },
    members: {
      /**
       * Get the Element wrapper for the iframe
       *
       * @abstract
       * @return {qx.html.Iframe} the iframe element wrapper
       */
      _getIframeElement: function _getIframeElement() {
        throw new Error("Abstract method call");
      },
      // property apply
      _applySource: function _applySource(value, old) {
        this._getIframeElement().setSource(value);
      },
      // property apply
      _applyFrameName: function _applyFrameName(value, old) {
        this._getIframeElement().setAttribute("name", value);
      },

      /**
       * Get the DOM window object of an iframe.
       *
       * @return {Window} The DOM window object of the iframe.
       */
      getWindow: function getWindow() {
        return this._getIframeElement().getWindow();
      },

      /**
       * Get the DOM document object of an iframe.
       *
       * @return {Document} The DOM document object of the iframe.
       */
      getDocument: function getDocument() {
        return this._getIframeElement().getDocument();
      },

      /**
       * Get the HTML body element of the iframe.
       *
       * @return {Element} The DOM node of the <code>body</code> element of the iframe.
       */
      getBody: function getBody() {
        return this._getIframeElement().getBody();
      },

      /**
       * Get the current name.
       *
       * @return {String} The iframe's name.
       */
      getName: function getName() {
        return this._getIframeElement().getName();
      },

      /**
       * Reload the contents of the iframe.
       *
       */
      reload: function reload() {
        this._getIframeElement().reload();
      },

      /**
      * Handle user navigation. Sync actual URL of iframe with source property.
      *
      * @param e {qx.event.type.Data} navigate event
      */
      __onNavigate__P_405_0: function __onNavigate__P_405_0(e) {
        var actualUrl = e.getData();

        if (actualUrl) {
          this.setSource(actualUrl);
        }

        this.fireDataEvent("navigate", actualUrl);
      }
    }
  });
  qx.ui.embed.AbstractIframe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.util.DeferredCall": {
        "construct": true
      },
      "qx.html.Canvas": {},
      "qx.event.type.Data": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The Canvas widget embeds the HMTL canvas element
   * [<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#the-canvas">W3C-HTML5</a>]
   *
   * Note: This widget does not work in Internet Explorer < 9!
   * Check for browser support with qx.core.Environment.get("html.canvas").
   *
   * To paint something on the canvas and keep the content updated on resizes you
   * either have to override the {@link #_draw} method or redraw the content on
   * the {@link #redraw} event. The drawing context can be obtained by {@link #getContext2d}.
   *
   * Note that this widget operates on two different coordinate systems. The canvas
   * has its own coordinate system for drawing operations. This canvas coordinate
   * system is scaled to fit actual size of the DOM element. Each time the size of
   * the canvas dimensions is changed a redraw is required. In this case the
   * protected method {@link #_draw} is called and the event {@link #redraw}
   * is fired. You can synchronize the internal canvas dimension with the
   * CSS dimension of the canvas element by setting {@link #syncDimension} to
   * <code>true</code>.
   *
   * *Example*
   *
   * Here is a little example of how to use the canvas widget.
   *
   * <pre class='javascript'>
   * var canvas = new qx.ui.embed.Canvas().set({
   *   canvasWidth: 200,
   *   canvasHeight: 200,
   *   syncDimension: true
   * });
   * canvas.addListener("redraw", function(e)
   * {
   *   var data = e.getData();
   *   var width = data.width;
   *   var height = data.height;
   *   var ctx = data.context;
   *
   *   ctx.fillStyle = "rgb(200,0,0)";
   *   ctx.fillRect (20, 20, width-5, height-5);
   *
   *   ctx.fillStyle = "rgba(0, 0, 200, 0.5)";
   *   ctx.fillRect (70, 70, 105, 100);
   * }, this);
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/canvas.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.embed.Canvas", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param canvasWidth {Integer} The internal with of the canvas coordinates.
     * @param canvasHeight {Integer} The internal height of the canvas coordinates.
     */
    construct: function construct(canvasWidth, canvasHeight) {
      qx.ui.core.Widget.constructor.call(this);
      this.__deferredDraw__P_406_0 = new qx.util.DeferredCall(this.__redraw__P_406_1, this);
      this.addListener("resize", this._onResize, this);

      if (canvasWidth !== undefined) {
        this.setCanvasWidth(canvasWidth);
      }

      if (canvasHeight !== undefined) {
        this.setCanvasHeight(canvasHeight);
      }
    },

    /*
     *****************************************************************************
        EVENTS
     *****************************************************************************
     */
    events: {
      /**
       * The redraw event is fired each time the canvas dimension change and the
       * canvas needs to be updated. The data field contains a map containing the
       * <code>width</code> and <code>height</code> of the canvas and the
       * rendering <code>context</code>.
       */
      "redraw": "qx.event.type.Data"
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    properties: {
      /** Whether canvas and widget coordinates should be synchronized */
      syncDimension: {
        check: "Boolean",
        init: false
      },

      /** The internal with of the canvas coordinates */
      canvasWidth: {
        check: "Integer",
        init: 300,
        apply: "_applyCanvasWidth"
      },

      /** The internal height of the canvas coordinates */
      canvasHeight: {
        check: "Integer",
        init: 150,
        apply: "_applyCanvasHeight"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.util.DeferredCall} */
      __deferredDraw__P_406_0: null,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createContentElement: function _createContentElement() {
        return new qx.html.Canvas();
      },

      /**
       * This methods triggers the redraw of the canvas' content
       */
      __redraw__P_406_1: function __redraw__P_406_1() {
        var canvas = this.getContentElement();
        var height = canvas.getHeight();
        var width = canvas.getWidth();
        var context = canvas.getContext2d();

        this._draw(width, height, context);

        this.fireNonBubblingEvent("redraw", qx.event.type.Data, [{
          width: width,
          height: height,
          context: context
        }]);
      },
      // property apply
      _applyCanvasWidth: function _applyCanvasWidth(value, old) {
        this.getContentElement().setWidth(value);

        this.__deferredDraw__P_406_0.schedule();
      },
      // property apply
      _applyCanvasHeight: function _applyCanvasHeight(value, old) {
        this.getContentElement().setHeight(value);

        this.__deferredDraw__P_406_0.schedule();
      },

      /**
       * Redraw the canvas
       */
      update: function update() {
        this.__deferredDraw__P_406_0.schedule();
      },

      /**
       * Widget resize event handler. Updates the canvas dimension if needed.
       *
       * @param e {qx.event.type.Data} The resize event object
       */
      _onResize: function _onResize(e) {
        var data = e.getData();

        if (this.getSyncDimension()) {
          this.setCanvasHeight(data.height);
          this.setCanvasWidth(data.width);
        }
      },

      /**
       * Get the native canvas 2D rendering context
       * [<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasrenderingcontext2d">W3C-HTML5</a>].
       * All drawing operations are performed on this context.
       *
       * @return {CanvasRenderingContext2D} The 2D rendering context.
       */
      getContext2d: function getContext2d() {
        return this.getContentElement().getContext2d();
      },

      /**
       * Template method, which can be used by derived classes to redraw the
       * content. It is called each time the canvas dimension change and the
       * canvas needs to be updated.
       *
       * @param width {Integer} New canvas width
       * @param height {Integer} New canvas height
       * @param context {CanvasRenderingContext2D} The rendering context to draw to
       */
      _draw: function _draw(width, height, context) {}
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this._disposeObjects("__deferredDraw__P_406_0");
    }
  });
  qx.ui.embed.Canvas.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      },
      "qx.html.Flash": {},
      "qx.util.TimerManager": {},
      "qx.util.ResourceManager": {},
      "qx.ui.core.queue.Layout": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The Flash widget embeds the HMTL Flash element
   */
  qx.Class.define("qx.ui.embed.Flash", {
    extend: qx.ui.core.Widget,

    /**
     * Constructs a flash widget.
     *
     * @param source {String} The URL of the Flash movie to display.
     * @param id {String?null} The unique id for the Flash movie.
     */
    construct: function construct(source, id) {
      qx.ui.core.Widget.constructor.call(this);
      {
        qx.core.Assert.assertString(source, "Invalid parameter 'source'.");

        if (id) {
          qx.core.Assert.assertString(id, "Invalid parameter 'id'.");
        }
      }
      this.setSource(source);

      if (id) {
        this.setId(id);
      } else {
        this.setId("flash" + this.toHashCode());
      } //init properties


      this.initQuality();
      this.initWmode();
      this.initAllowScriptAccess();
      this.initLiveConnect(); // Creates the Flash DOM element (movie) on appear,
      // because otherwise IE 7 and higher blocks the
      // ExternelInterface from Flash.

      this.addListenerOnce("appear", function () {
        this._checkLoading();

        this.getContentElement().createFlash();
      }, this);
    },
    events: {
      /**
       * Fired when the flash object still is loading.
       *
       * The loading action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "loading": "qx.event.type.Event",

      /**
       * Fired after the flash object has been loaded.
       *
       * The loaded action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "loaded": "qx.event.type.Event",

      /**
       * Fired after the flash object has got a timeout.
       *
       * The timeout action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "timeout": "qx.event.type.Event"
    },
    properties: {
      /**
       * The URL of the Flash movie.
       */
      source: {
        check: "String",
        apply: "_applySource"
      },

      /**
       * The unique Flash movie id.
       */
      id: {
        check: "String",
        apply: "_applyId"
      },

      /**
       * Set the quality attribute for the Flash movie.
       */
      quality: {
        check: ["low", "autolow", "autohigh", "medium", "high", "best"],
        init: "best",
        nullable: true,
        apply: "_applyQuality"
      },

      /**
       * Set the scale attribute for the Flash movie.
       */
      scale: {
        check: ["showall", "noborder", "exactfit", "noscale"],
        nullable: true,
        apply: "_applyScale"
      },

      /**
       * Set the wmode attribute for the Flash movie.
       */
      wmode: {
        check: ["window", "opaque", "transparent"],
        init: "opaque",
        nullable: true,
        apply: "_applyWmode"
      },

      /**
       * Set the play attribute for the Flash movie.
       */
      play: {
        check: "Boolean",
        nullable: true,
        apply: "_applyPlay"
      },

      /**
       * Set the loop attribute for the Flash movie.
       */
      loop: {
        check: "Boolean",
        nullable: true,
        apply: "_applyLoop"
      },

      /**
       * Set the mayscript attribute for the Flash movie.
       */
      mayScript: {
        check: "Boolean",
        nullable: false,
        apply: "_applyMayScript"
      },

      /**
       * Set the menu attribute for the Flash movie.
       */
      menu: {
        check: "Boolean",
        nullable: true,
        apply: "_applyMenu"
      },

      /**
       * Set allow script access
       **/
      allowScriptAccess: {
        check: ["sameDomain", "always", "never"],
        init: "sameDomain",
        nullable: true,
        apply: "_applyAllowScriptAccess"
      },

      /**
       * Enable/disable live connection
       **/
      liveConnect: {
        check: "Boolean",
        init: true,
        nullable: true,
        apply: "_applyLiveConnect"
      },

      /**
       * Set the 'FlashVars' to pass variables to the Flash movie.
       */
      variables: {
        init: {},
        check: "Map",
        apply: "_applyVariables"
      },

      /**
       * A timeout when trying to load the flash source.
       */
      loadTimeout: {
        check: "Integer",
        init: 10000
      }
    },
    members: {
      /** @type {Integer} The time stamp when the loading begins. */
      __time__P_407_0: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC WIDGET API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the DOM element of the Flash movie.
       *
       * Note: If you call the method before the widget is rendered, it will
       * always return <code>null</code>. Therefore call the method after
       * the {@link #appear} event is fired.
       *
       * @return {Element|null} The DOM element of the Flash movie.
       */
      getFlashElement: function getFlashElement() {
        var element = this.getContentElement();

        if (element) {
          return element.getFlashElement();
        } else {
          return null;
        }
      },

      /**
       * Checks if the movie is loaded.
       *
       * @return {Boolean} <code>true</code> When the movie is completely loaded,
       *   otherwise <code>false</code>.
       */
      isLoaded: function isLoaded() {
        return this.getPercentLoaded() === 100;
      },

      /**
       * Returns the current loaded state from the Flash movie.
       *
       * @return {Integer} The loaded percent value.
       */
      getPercentLoaded: function getPercentLoaded() {
        var flashFE = this.getFlashElement(); // First make sure the movie is defined and has received a non-zero object id.

        if (typeof flashFE != "undefined" && flashFE != null) {
          try {
            return flashFE.PercentLoaded();
          } catch (err) {
            // Not an accessible function yet.
            return 0;
          }
        } else {
          return 0;
        }
      },
      // overridden
      _createContentElement: function _createContentElement() {
        var el = new qx.html.Flash();
        el.connectWidget(this);
        return el;
      },

      /**
       * Checks the current loaded state and fires one of the defined events:
       * {@link #loading}, {@link #loaded} or {@link #timeout}.
       *
       * Note the {@link #timeout} event is fired when the check reached the
       * defined {@link #loadTimeout}.
       */
      _checkLoading: function _checkLoading() {
        var source = this.getSource();

        if (source != "" && source != null && source != "undefined") {
          if (!this.isLoaded()) {
            if (!this.__time__P_407_0) {
              this.__time__P_407_0 = new Date().getTime();
            }

            var timeDiff = new Date().getTime() - this.__time__P_407_0;

            if (this.getLoadTimeout() > timeDiff) {
              var timer = qx.util.TimerManager.getInstance();
              timer.start(this._checkLoading, 0, this, null, 10);
              this.fireEvent("loading");
            } else {
              {
                this.debug("Timeout after: " + timeDiff);
              }
              this.fireEvent("timeout");
              this.__time__P_407_0 = null;
            }
          } else {
            this.fireEvent("loaded");
            this.__time__P_407_0 = null;
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
       APPLY METHODS
      ---------------------------------------------------------------------------
      */
      // property apply
      _applySource: function _applySource(value, old) {
        var source = qx.util.ResourceManager.getInstance().toUri(value);
        this.getContentElement().setSource(source);
        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyId: function _applyId(value, old) {
        this.getContentElement().setId(value);
        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyVariables: function _applyVariables(value, old) {
        this.getContentElement().setVariables(value);
        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyMayScript: function _applyMayScript(value, old) {
        this.getContentElement().setAttribute("mayscript", value ? "" : false);
        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyQuality: function _applyQuality(value, old) {
        this.__flashParamHelper__P_407_1("quality", value);
      },
      // property apply
      _applyScale: function _applyScale(value, old) {
        this.__flashParamHelper__P_407_1("scale", value);
      },
      // property apply
      _applyWmode: function _applyWmode(value, old) {
        this.__flashParamHelper__P_407_1("wmode", value);
      },
      // property apply
      _applyPlay: function _applyPlay(value, old) {
        this.__flashParamHelper__P_407_1("play", value);
      },
      // property apply
      _applyLoop: function _applyLoop(value, old) {
        this.__flashParamHelper__P_407_1("loop", value);
      },
      // property apply
      _applyMenu: function _applyMenu(value, old) {
        this.__flashParamHelper__P_407_1("menu", value);
      },
      // property apply
      _applyAllowScriptAccess: function _applyAllowScriptAccess(value, old) {
        this.__flashParamHelper__P_407_1("allowScriptAccess", value);
      },
      // property apply
      _applyLiveConnect: function _applyLiveConnect(value, old) {
        this.__flashParamHelper__P_407_1("swLiveConnect", value);
      },

      /*
      ---------------------------------------------------------------------------
       HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Set the attribute for the Flash DOM element.
       *
       * @param key {String} Flash Player attribute name.
       * @param value {String?null} The value for the attribute, <code>null</code>
       *    if the attribute should be removed from the DOM element.
       */
      __flashParamHelper__P_407_1: function __flashParamHelper__P_407_1(key, value) {
        this.getContentElement().setParam(key, value);
        qx.ui.core.queue.Layout.add(this);
      }
    }
  });
  qx.ui.embed.Flash.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.event.Idle": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Timer manipulation for handling multiple timed callbacks with the use of
   * only a single native timer object.
   *
   * Use of these timers is via the methods start() and stop().  Examples:
   * <pre class='javascript'>
   * var timer = qx.util.TimerManager.getInstance();
   *
   * // Start a 5-second recurrent timer.
   * // Note that the first expiration is after 3 seconds
   * // (last parameter is 3000) but each subsequent expiration is
   * // at 5 second intervals.
   * timer.start(function(userData, timerId)
   *             {
   *               this.debug("Recurrent 5-second timer: " + timerId);
   *             },
   *             5000,
   *             this,
   *             null,
   *             3000);
   *
   * // Start a 1-second one-shot timer
   * timer.start(function(userData, timerId)
   *             {
   *               this.debug("One-shot 1-second timer: " + timerId);
   *             },
   *             0,
   *             this,
   *             null,
   *             1000);
   *
   * // Start a 2-second recurrent timer that stops itself after
   * // three iterations
   * timer.start(function(userData, timerId)
   *             {
   *               this.debug("Recurrent 2-second timer with limit 3:" +
   *                          timerId);
   *               if (++userData.count == 3)
   *               {
   *                 this.debug("Stopping recurrent 2-second timer");
   *                 timer.stop(timerId);
   *               }
   *             },
   *             2000,
   *             this,
   *             { count : 0 });
   *
   * // Start an immediate one-shot timer
   * timer.start(function(userData, timerId)
   *             {
   *               this.debug("Immediate one-shot timer: " + timerId);
   *             });
   * </pre>
   */
  qx.Class.define("qx.util.TimerManager", {
    extend: qx.core.Object,
    type: "singleton",
    statics: {
      /** Time-ordered queue of timers */
      __timerQueue__P_579_0: [],

      /** Saved data for each timer */
      __timerData__P_579_1: {},

      /** Next timer id value is determined by incrementing this */
      __timerId__P_579_2: 0
    },
    members: {
      /** Whether we're currently listening on the interval timer event */
      __timerListenerActive__P_579_3: false,

      /**
       * Start a new timer
       *
       * @param callback {Function}
       *   Function to be called upon expiration of the timer.  The function is
       *   passed these parameters:
       *   <dl>
       *     <dt>userData</dt>
       *       <dd>The user data provided to the start() method</dd>
       *     <dt>timerId</dt>
       *       <dd>The timer id, as was returned by the start() method</dd>
       *   </dl>
       *
       * @param recurTime {Integer|null}
       *   If null, the timer will not recur.  Once the callback function
       *   returns the first time, the timer will be removed from the timer
       *   queue.  If non-null, upon return from the callback function, the
       *   timer will be reset to this number of milliseconds.
       *
       * @param context {qx.core.Object|null}
       *   Context (this) the callback function is called with.  If not
       *   provided, this Timer singleton object is used.
       *
       * @param userData {var}
       *   Data which is passed to the callback function upon timer expiry
       *
       * @param initialTime {Integer|null}
       *   Milliseconds before the callback function is called the very first
       *   time.  If not specified and recurTime is specified, then recurTime
       *   will be used as initialTime; otherwise initialTime will default
       *   to zero.
       *
       * @return {Integer}
       *   The timer id of this unique timer.  It may be provided to the stop()
       *   method to cancel a timer before expiration.
       */
      start: function start(callback, recurTime, context, userData, initialTime) {
        // Get the expiration time for this timer
        if (typeof initialTime != "number") {
          initialTime = recurTime || 0;
        }

        var expireAt = new Date().getTime() + initialTime; // Save the callback, user data, and requested recurrency time as well
        // as the current expiry time

        qx.util.TimerManager.__timerData__P_579_1[++qx.util.TimerManager.__timerId__P_579_2] = {
          callback: callback,
          userData: userData || null,
          expireAt: expireAt,
          recurTime: recurTime,
          context: context || this
        }; // Insert this new timer on the time-ordered timer queue

        this.__insertNewTimer__P_579_4(expireAt, qx.util.TimerManager.__timerId__P_579_2); // Give 'em the timer id


        return qx.util.TimerManager.__timerId__P_579_2;
      },

      /**
       * Stop a running timer
       *
       * @param timerId {Integer}
       *   A timer id previously returned by start()
       */
      stop: function stop(timerId) {
        // Find this timer id in the time-ordered list
        var timerQueue = qx.util.TimerManager.__timerQueue__P_579_0;
        var length = timerQueue.length;

        for (var i = 0; i < length; i++) {
          // Is this the one we're looking for?
          if (timerQueue[i] == timerId) {
            // Yup.  Remove it.
            timerQueue.splice(i, 1); // We found it so no need to continue looping through the queue

            break;
          }
        } // Ensure it's gone from the timer data map as well


        delete qx.util.TimerManager.__timerData__P_579_1[timerId]; // If there are no more timers pending...

        if (timerQueue.length == 0 && this.__timerListenerActive__P_579_3) {
          // ... then stop listening for the periodic timer
          qx.event.Idle.getInstance().removeListener("interval", this.__processQueue__P_579_5, this);
          this.__timerListenerActive__P_579_3 = false;
        }
      },

      /**
       * Insert a timer on the time-ordered list of active timers.
       *
       * @param expireAt {Integer}
       *   Milliseconds from now when this timer should expire
       *
       * @param timerId {Integer}
       *   Id of the timer to be time-ordered
       *
       */
      __insertNewTimer__P_579_4: function __insertNewTimer__P_579_4(expireAt, timerId) {
        // The timer queue is time-ordered so that processing timers need not
        // search the queue; rather, it can simply look at the first element
        // and if not yet ready to fire, be done.  Search the queue for the
        // appropriate place to insert this timer.
        var timerQueue = qx.util.TimerManager.__timerQueue__P_579_0;
        var timerData = qx.util.TimerManager.__timerData__P_579_1;
        var length = timerQueue.length;

        for (var i = 0; i < length; i++) {
          // Have we reached a later time?
          if (timerData[timerQueue[i]].expireAt > expireAt) {
            // Yup.  Insert our new timer id before this element.
            timerQueue.splice(i, 0, timerId); // No need to loop through the queue further

            break;
          }
        } // Did we find someplace in the middle of the queue for it?


        if (timerQueue.length == length) {
          // Nope.  Insert it at the end.
          timerQueue.push(timerId);
        } // If this is the first element on the queue...


        if (!this.__timerListenerActive__P_579_3) {
          // ... then start listening for the periodic timer.
          qx.event.Idle.getInstance().addListener("interval", this.__processQueue__P_579_5, this);
          this.__timerListenerActive__P_579_3 = true;
        }
      },

      /**
       * Process the queue of timers.  Call the registered callback function for
       * any timer which has expired.  If the timer is marked as recurrent, the
       * timer is restarted with the recurrent timeout following completion of
       * the callback function.
       *
       */
      __processQueue__P_579_5: function __processQueue__P_579_5() {
        // Get the current time
        var timeNow = new Date().getTime(); // While there are timer elements that need processing...

        var timerQueue = qx.util.TimerManager.__timerQueue__P_579_0;
        var timerData = qx.util.TimerManager.__timerData__P_579_1; // Is it time to process the first timer element yet?

        while (timerQueue.length > 0 && timerData[timerQueue[0]].expireAt <= timeNow) {
          // Yup.  Do it.  First, remove element from the queue.
          var expiredTimerId = timerQueue.shift(); // Call the handler function for this timer

          var expiredTimerData = timerData[expiredTimerId];
          expiredTimerData.callback.call(expiredTimerData.context, expiredTimerData.userData, expiredTimerId); // If this is a recurrent timer which wasn't stopped by the callback...

          if (expiredTimerData.recurTime && timerData[expiredTimerId]) {
            // ... then restart it.
            var now = new Date().getTime();
            expiredTimerData.expireAt = now + expiredTimerData.recurTime; // Insert this timer back on the time-ordered timer queue

            this.__insertNewTimer__P_579_4(expiredTimerData.expireAt, expiredTimerId);
          } else {
            // If it's not a recurrent timer, we can purge its data too.
            delete timerData[expiredTimerId];
          }
        } // If there are no more timers pending...


        if (timerQueue.length == 0 && this.__timerListenerActive__P_579_3) {
          // ... then stop listening for the periodic timer
          qx.event.Idle.getInstance().removeListener("interval", this.__processQueue__P_579_5, this);
          this.__timerListenerActive__P_579_3 = false;
        }
      }
    }
  });
  qx.util.TimerManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MNativeOverflow": {
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.theme.manager.Font": {},
      "qx.bom.Font": {},
      "qx.theme.manager.Color": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The Html widget embeds plain HTML code into the application
   *
   * *Example*
   *
   * Here is a little example of how to use the canvas widget.
   *
   * <pre class='javascript'>
   * var html = new qx.ui.embed.Html();
   * html.setHtml("<h1>Hello World</h1>");
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/html.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.embed.Html", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MNativeOverflow],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param html {String} Initial HTML content
     */
    construct: function construct(html) {
      qx.ui.core.Widget.constructor.call(this);

      if (html != null) {
        this.setHtml(html);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Any text string which can contain HTML, too */
      html: {
        check: "String",
        apply: "_applyHtml",
        event: "changeHtml",
        nullable: true
      },

      /**
       * The css classname for the html embed.
       * <b>IMPORTANT</b> Paddings and borders does not work
       * in the css class. These styles cause conflicts with
       * the layout engine.
       */
      cssClass: {
        check: "String",
        init: "",
        apply: "_applyCssClass"
      },
      // overridden
      selectable: {
        refine: true,
        init: true
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      getFocusElement: function getFocusElement() {
        return this.getContentElement();
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyHtml: function _applyHtml(value, old) {
        var elem = this.getContentElement(); // Workaround for http://bugzilla.qooxdoo.org/show_bug.cgi?id=7679

        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") == 9) {
          elem.setStyle("position", "relative");
        } // Insert HTML content


        elem.setAttribute("html", value || "");
      },
      // property apply
      _applyCssClass: function _applyCssClass(value, old) {
        this.getContentElement().removeClass(old);
        this.getContentElement().addClass(value);
      },
      // overridden
      _applySelectable: function _applySelectable(value) {
        qx.ui.embed.Html.prototype._applySelectable.base.call(this, value);
        /*
         * We have to set the value to "text" in Webkit for the content element
         */


        if (qx.core.Environment.get("engine.name") == "webkit") {
          this.getContentElement().setStyle("userSelect", value ? "text" : "none");
        }
      },

      /*
      ---------------------------------------------------------------------------
        FONT SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyFont: function _applyFont(value, old) {
        var styles = value ? qx.theme.manager.Font.getInstance().resolve(value).getStyles() : qx.bom.Font.getDefaultStyles(); // check if text color already set - if so this local value has higher priority

        if (this.getTextColor() != null) {
          delete styles["color"];
        }

        this.getContentElement().setStyles(styles);
      },

      /*
      ---------------------------------------------------------------------------
        TEXT COLOR SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyTextColor: function _applyTextColor(value, old) {
        if (value) {
          this.getContentElement().setStyle("color", qx.theme.manager.Color.getInstance().resolve(value));
        } else {
          this.getContentElement().removeStyle("color");
        }
      }
    }
  });
  qx.ui.embed.Html.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.embed.AbstractIframe": {
        "construct": true,
        "require": true
      },
      "qx.event.Registration": {
        "construct": true
      },
      "qx.bom.client.EcmaScript": {
        "construct": true
      },
      "qx.bom.Event": {
        "construct": true
      },
      "qx.lang.Function": {
        "construct": true
      },
      "qx.html.Iframe": {},
      "qx.html.Blocker": {},
      "qx.bom.client.Event": {},
      "qx.bom.client.Browser": {},
      "qx.bom.Iframe": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "ecmascript.mutationobserver": {
          "construct": true,
          "className": "qx.bom.client.EcmaScript"
        },
        "event.help": {
          "className": "qx.bom.client.Event"
        },
        "browser.name": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Til Schneider (til132)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Container widget for internal frames (iframes).
   * An iframe can display any HTML page inside the widget.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   * var document = this.getRoot();
   * var iframe = new qx.ui.embed.Iframe("http://www.qooxdoo.org");
   * document.add(iframe);
   * </pre>
   *
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/iframe.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   *
   *
   * *Notes*
   * When modifying this file, note that the test qx.test.ui.embed.Iframe.testSyncSourceAfterDOMMove
   * has been disabled under Chrome because of problems with Travis and Github.  Changes to this file
   * should be tested manually against that test.
   */
  qx.Class.define("qx.ui.embed.Iframe", {
    extend: qx.ui.embed.AbstractIframe,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @ignore(MutationObserver)
     * @param source {String} URL which should initially set.
     */
    construct: function construct(source) {
      if (source != null) {
        this.__source__P_408_0 = source;
      }

      qx.ui.embed.AbstractIframe.constructor.call(this, source);
      qx.event.Registration.addListener(document.body, "pointerdown", this.block, this, true);
      qx.event.Registration.addListener(document.body, "pointerup", this.release, this, true);
      qx.event.Registration.addListener(document.body, "losecapture", this.release, this, true);
      this.__blockerElement__P_408_1 = this._createBlockerElement();

      if (qx.core.Environment.get("ecmascript.mutationobserver")) {
        this.addListenerOnce("appear", function () {
          var element = this.getContentElement().getDomElement(); // Mutation record check callback

          var isDOMNodeInserted = function isDOMNodeInserted(mutationRecord) {
            var i; // 'our' iframe was either added...

            if (mutationRecord.addedNodes) {
              for (i = mutationRecord.addedNodes.length; i >= 0; --i) {
                if (mutationRecord.addedNodes[i] == element) {
                  return true;
                }
              }
            } // ...or removed


            if (mutationRecord.removedNodes) {
              for (i = mutationRecord.removedNodes.length; i >= 0; --i) {
                if (mutationRecord.removedNodes[i] == element) {
                  return true;
                }
              }
            }

            return false;
          };

          var observer = new MutationObserver(function (mutationRecords) {
            if (mutationRecords.some(isDOMNodeInserted)) {
              this._syncSourceAfterDOMMove();
            }
          }.bind(this)); // Observe parent element

          var parent = this.getLayoutParent().getContentElement().getDomElement();
          observer.observe(parent, {
            childList: true,
            subtree: true
          });
        }, this);
      } else // !qx.core.Environment.get("ecmascript.mutationobserver")
        {
          this.addListenerOnce("appear", function () {
            var element = this.getContentElement().getDomElement();
            qx.bom.Event.addNativeListener(element, "DOMNodeInserted", this._onDOMNodeInserted);
          }, this);
          this._onDOMNodeInserted = qx.lang.Function.listener(this._syncSourceAfterDOMMove, this);
        }
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "iframe"
      },

      /**
       * Whether to show the frame's native context menu.
       *
       * Note: This only works if the iframe source is served from the same domain
       * as the main application.
       */
      nativeContextMenu: {
        refine: true,
        init: false
      },

      /**
       * If the user presses F1 in IE by default the onhelp event is fired and
       * IE’s help window is opened. Setting this property to <code>false</code>
       * prevents this behavior.
       *
       * Note: This only works if the iframe source is served from the same domain
       * as the main application.
       */
      nativeHelp: {
        check: "Boolean",
        init: false,
        apply: "_applyNativeHelp"
      },

      /**
       * Whether the widget should have scrollbars.
       */
      scrollbar: {
        check: ["auto", "no", "yes"],
        nullable: true,
        themeable: true,
        apply: "_applyScrollbar"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __source__P_408_0: null,
      __blockerElement__P_408_1: null,
      // overridden
      renderLayout: function renderLayout(left, top, width, height) {
        qx.ui.embed.Iframe.prototype.renderLayout.base.call(this, left, top, width, height);
        var pixel = "px";
        var insets = this.getInsets();

        this.__blockerElement__P_408_1.setStyles({
          "left": left + insets.left + pixel,
          "top": top + insets.top + pixel,
          "width": width - insets.left - insets.right + pixel,
          "height": height - insets.top - insets.bottom + pixel
        });
      },
      // overridden
      _createContentElement: function _createContentElement() {
        var iframe = new qx.html.Iframe(this.__source__P_408_0);
        iframe.addListener("load", this._onIframeLoad, this);
        return iframe;
      },
      // overridden
      _getIframeElement: function _getIframeElement() {
        return this.getContentElement();
      },

      /**
       * Creates <div> element which is aligned over iframe node to avoid losing pointer events.
       *
       * @return {Object} Blocker element node
       */
      _createBlockerElement: function _createBlockerElement() {
        var el = new qx.html.Blocker();
        el.setStyles({
          "zIndex": 20,
          "display": "none"
        });
        return el;
      },

      /**
       * Reacts on native load event and redirects it to the widget.
       *
       * @param e {qx.event.type.Event} Native load event
       */
      _onIframeLoad: function _onIframeLoad(e) {
        this._applyNativeContextMenu(this.getNativeContextMenu(), null);

        this._applyNativeHelp(this.getNativeHelp(), null);

        this.fireNonBubblingEvent("load");
      },

      /*
      ---------------------------------------------------------------------------
        METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Cover the iframe with a transparent blocker div element. This prevents
       * pointer or key events to be handled by the iframe. To release the blocker
       * use {@link #release}.
       *
       */
      block: function block() {
        this.__blockerElement__P_408_1.setStyle("display", "block");
      },

      /**
       * Release the blocker set by {@link #block}.
       *
       */
      release: function release() {
        this.__blockerElement__P_408_1.setStyle("display", "none");
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyNativeContextMenu: function _applyNativeContextMenu(value, old) {
        if (value !== false && old !== false) {
          return;
        }

        var doc = this.getDocument();

        if (!doc) {
          return;
        }

        try {
          var documentElement = doc.documentElement;
        } catch (e) {
          // this may fail due to security restrictions
          return;
        }

        if (old === false) {
          qx.event.Registration.removeListener(documentElement, "contextmenu", this._onNativeContextMenu, this, true);
        }

        if (value === false) {
          qx.event.Registration.addListener(documentElement, "contextmenu", this._onNativeContextMenu, this, true);
        }
      },

      /**
       * Stops the <code>contextmenu</code> event from showing the native context menu
       *
       * @param e {qx.event.type.Mouse} The event object
       */
      _onNativeContextMenu: function _onNativeContextMenu(e) {
        e.preventDefault();
      },
      // property apply
      _applyNativeHelp: function _applyNativeHelp(value, old) {
        if (qx.core.Environment.get("event.help")) {
          var document = this.getDocument();

          if (!document) {
            return;
          }

          try {
            if (old === false) {
              qx.bom.Event.removeNativeListener(document, "help", function () {
                return false;
              });
            }

            if (value === false) {
              qx.bom.Event.addNativeListener(document, "help", function () {
                return false;
              });
            }
          } catch (e) {
            {
              this.warn("Unable to set 'nativeHelp' property, possibly due to security restrictions");
            }
          }
        }
      },

      /**
       * Checks if the iframe element is out of sync. This can happen in Firefox
       * if the iframe is moved around and the source is changed right after.
       * The root cause is that Firefox is reloading the iframe when its position
       * in DOM has changed.
       */
      _syncSourceAfterDOMMove: function _syncSourceAfterDOMMove() {
        var iframeDomElement = this.getContentElement() && this.getContentElement().getDomElement();

        if (!iframeDomElement) {
          return;
        }

        var iframeSource = iframeDomElement.src; // remove trailing "/"

        if (iframeSource.charAt(iframeSource.length - 1) == "/") {
          iframeSource = iframeSource.substring(0, iframeSource.length - 1);
        }

        if (iframeSource != this.getSource()) {
          if (qx.core.Environment.get("browser.name") != "edge" && qx.core.Environment.get("browser.name") != "ie") {
            qx.bom.Iframe.getWindow(iframeDomElement).stop();
          }

          iframeDomElement.src = this.getSource();
        }
      },
      // property apply
      _applyScrollbar: function _applyScrollbar(value) {
        this.getContentElement().setAttribute("scrolling", value);
      },
      // overridden
      setLayoutParent: function setLayoutParent(parent) {
        qx.ui.embed.Iframe.prototype.setLayoutParent.base.call(this, parent);

        if (parent) {
          this.getLayoutParent().getContentElement().add(this.__blockerElement__P_408_1);
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this.getLayoutParent() && this.__blockerElement__P_408_1.getParent()) {
        this.getLayoutParent().getContentElement().remove(this.__blockerElement__P_408_1);
      }

      this._disposeObjects("__blockerElement__P_408_1");

      qx.event.Registration.removeListener(document.body, "pointerdown", this.block, this, true);
      qx.event.Registration.removeListener(document.body, "pointerup", this.release, this, true);
      qx.event.Registration.removeListener(document.body, "losecapture", this.release, this, true);
    }
  });
  qx.ui.embed.Iframe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.embed.AbstractIframe": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.scroll.MRoll": {
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.embed.Iframe": {},
      "qx.ui.core.scroll.ScrollBar": {},
      "qx.ui.core.Widget": {},
      "qx.bom.Element": {},
      "qx.event.Idle": {},
      "qx.bom.Document": {},
      "qx.bom.Viewport": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Container widget for internal frames (iframes) with qooxdoo scroll bar and
   * size hint support.
   *
   * An iframe can display any HTML page inside the widget. Note that custom
   * scroll bars do only work if the iframe's source points to the same domain
   * as the application.
   *
   * @childControl iframe {qx.ui.embed.Iframe} embedded iframe component
   * @childControl scrollbar-x {qx.ui.core.scroll.ScrollBar} horizontal scrollbar
   * @childControl scrollbar-y {qx.ui.core.scroll.ScrollBar} vertical scrollbar
   * @childControl corner {qx.ui.core.Widget} corner widget where no scrollbar is shown
   *
   * *Example*
   *
   * Here is a little example of how to use the widget:
   *
   * <pre class='javascript'>
   * var document = this.getRoot();
   * var iframe = new qx.ui.embed.ThemedIframe("frame.html");
   * document.add(iframe);
   * </pre>
   *
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/themediframe.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.embed.ThemedIframe", {
    extend: qx.ui.embed.AbstractIframe,
    include: qx.ui.core.scroll.MRoll,
    construct: function construct(source) {
      qx.ui.embed.AbstractIframe.constructor.call(this, source); // Create 'fixed' grid layout

      var grid = new qx.ui.layout.Grid();
      grid.setColumnFlex(0, 1);
      grid.setRowFlex(0, 1);

      this._setLayout(grid);

      this._showChildControl("iframe");
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "scrollarea"
      },

      /**
       * The policy, when the horizontal scrollbar should be shown.
       * <ul>
       *   <li><b>auto</b>: Show scrollbar on demand</li>
       *   <li><b>on</b>: Always show the scrollbar</li>
       *   <li><b>off</b>: Never show the scrollbar</li>
       * </ul>
       */
      scrollbarX: {
        check: ["auto", "on", "off"],
        init: "auto",
        themeable: true,
        apply: "_updateScrollbars"
      },

      /**
       * The policy, when the horizontal scrollbar should be shown.
       * <ul>
       *   <li><b>auto</b>: Show scrollbar on demand</li>
       *   <li><b>on</b>: Always show the scrollbar</li>
       *   <li><b>off</b>: Never show the scrollbar</li>
       * </ul>
       */
      scrollbarY: {
        check: ["auto", "on", "off"],
        init: "auto",
        themeable: true,
        apply: "_updateScrollbars"
      },

      /**
       * Group property, to set the overflow of both scroll bars.
       */
      scrollbar: {
        group: ["scrollbarX", "scrollbarY"]
      }
    },
    members: {
      __iframeSize__P_409_0: null,
      __iframeObserverId__P_409_1: null,
      // overridden
      _getIframeElement: function _getIframeElement() {
        return this.getChildControl("iframe").getContentElement();
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "iframe":
            control = new qx.ui.embed.Iframe(this.getSource());
            control.addListener("load", this._onIframeLoad, this);
            control.addListener("resize", this._onIframeResize, this);

            this._add(control, {
              row: 0,
              column: 0
            });

            break;

          case "scrollbar-x":
            control = new qx.ui.core.scroll.ScrollBar("horizontal");
            control.setMinWidth(0);
            control.exclude();
            control.addListener("scroll", this._onScrollBarX, this);

            this._add(control, {
              row: 1,
              column: 0
            });

            break;

          case "scrollbar-y":
            control = new qx.ui.core.scroll.ScrollBar("vertical");
            control.setMinHeight(0);
            control.exclude();
            control.addListener("scroll", this._onScrollBarY, this);

            this._add(control, {
              row: 0,
              column: 1
            });

            break;

          case "corner":
            control = new qx.ui.core.Widget();
            control.setWidth(0);
            control.setHeight(0);
            control.exclude();

            this._add(control, {
              row: 1,
              column: 1
            });

            break;
        }

        return control || qx.ui.embed.ThemedIframe.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the iframe's load event
       */
      _onIframeLoad: function _onIframeLoad() {
        this._disableScollbars();

        var body = this._getIframeElement().getBody();

        if (body) {
          this._startIframeObserver();

          this._addRollListener();
        }

        this.fireEvent("load");
      },

      /**
       * Event handler for resize event of the iframe widget.
       */
      _onIframeResize: function _onIframeResize() {
        this._updateScrollbars();
      },

      /**
       * Hide all scrollbars and stop observing the iframe document
       */
      _disableScollbars: function _disableScollbars() {
        this._excludeChildControl("scrollbar-x");

        this._excludeChildControl("scrollbar-y");

        this._excludeChildControl("corner");

        this._stopIframeObserver();
      },

      /**
       * Attach roll listener to the iframe
       */
      _addRollListener: function _addRollListener() {
        try {
          var body = this._getIframeElement().getBody();

          qx.bom.Element.addListener(body, "roll", this._onRoll, this);
          qx.bom.Element.addListener(body, "pointerdown", this._onPointerDownForRoll, this);
        } catch (e) {
          this._disableScollbars();
        }
      },

      /**
       * Start observing size changes of the iframe document
       */
      _startIframeObserver: function _startIframeObserver() {
        if (this.__iframeObserverId__P_409_1) {
          this._stopIframeObserver();
        }

        var idle = qx.event.Idle.getInstance();
        this.__iframeObserverId__P_409_1 = idle.addListener("interval", this._onIframeObserverInterval, this);
      },

      /**
       * Stop observing size changes of the iframe document
       */
      _stopIframeObserver: function _stopIframeObserver() {
        this.__iframeSize__P_409_0 = null;

        if (!this.__iframeObserverId__P_409_1) {
          return;
        }

        var idle = qx.event.Idle.getInstance();
        idle.removeListenerById(this.__iframeObserverId__P_409_1);
      },

      /**
       * Event handler, which is called periodically to update the scroll bars
       */
      _onIframeObserverInterval: function _onIframeObserverInterval() {
        var iframeSize = this._getIframeSize();

        if (!iframeSize) {
          this._disableScollbars();

          return;
        }

        if (this.__iframeSize__P_409_0 && iframeSize.width == this.__iframeSize__P_409_0.width && iframeSize.height == this.__iframeSize__P_409_0.height) {
          return;
        }

        this.__iframeSize__P_409_0 = iframeSize;

        this._preventIframeScrolling();

        this._updateScrollbars();
      },

      /**
       * Try to hide native scrollbars in the iframe
       */
      _preventIframeScrolling: function _preventIframeScrolling() {
        try {
          var win = this._getIframeElement().getWindow();

          var doc = this._getIframeElement().getDocument();

          if (qx.bom.Document.isStandardMode(win)) {
            doc.documentElement.style.overflow = "hidden";
          } else {
            doc.body.style.overflow = "hidden";
          }
        } catch (e) {
          this._disableScollbars();
        }
      },

      /**
       * Recompute scrollbar visibility and positions based on the iframe's
       * document size
       */
      _updateScrollbars: function _updateScrollbars() {
        var iframeSize = this.__iframeSize__P_409_0;
        var paneSize = this.getChildControl("iframe").getBounds();
        var innerSize = this.getChildControl("iframe").getInnerSize();

        if (!iframeSize || !innerSize || !innerSize) {
          return;
        }

        var showX = false;
        var showY = false;
        var scrollbarX = this.getScrollbarX();
        var scrollbarY = this.getScrollbarY();

        if (scrollbarX === "auto" && scrollbarY === "auto") {
          // Check if the container is big enough to show
          // the full content.
          var showX = iframeSize.width > innerSize.width;
          var showY = iframeSize.height > innerSize.height; // Dependency check
          // We need a special intelligence here when only one
          // of the autosized axis requires a scrollbar
          // This scrollbar may then influence the need
          // for the other one as well.

          if ((showX || showY) && !(showX && showY)) {
            if (showX) {
              showY = iframeSize.height > paneSize.height;
            } else if (showY) {
              showX = iframeSize.width > paneSize.width;
            }
          }
        } else {
          var showX = scrollbarX === "on";
          var showY = scrollbarY === "on"; // Check auto values afterwards with already
          // corrected client dimensions

          if (iframeSize.width > (showX ? paneSize.width : innerSize.width) && scrollbarX === "auto") {
            showX = true;
          }

          if (iframeSize.height > (showX ? paneSize.height : innerSize.height) && scrollbarY === "auto") {
            showY = true;
          }
        }

        this._configureScrollbar("scrollbar-x", showX, innerSize.width, iframeSize.width);

        this._configureScrollbar("scrollbar-y", showY, innerSize.height, iframeSize.height);

        this._updateCornerWidget();
      },

      /**
       * Compute the size of the iframe body
       *
       * @return {Object|null} A map with the body size or <code>null</code>.
       */
      _getIframeSize: function _getIframeSize() {
        try {
          var win = this._getIframeElement().getWindow();

          var frameSize = {
            width: qx.bom.Document.getWidth(win),
            height: qx.bom.Document.getHeight(win)
          };
          return frameSize;
        } catch (e) {
          return null;
        }
      },

      /**
       * Update visibility of the corner widget based on the visibility of the
       * scrollbars
       */
      _updateCornerWidget: function _updateCornerWidget() {
        if (this._isChildControlVisible("scrollbar-x") && this._isChildControlVisible("scrollbar-y")) {
          this._showChildControl("corner");
        } else {
          this._excludeChildControl("corner");
        }
      },

      /**
       * Configures the given scrollbar
       *
       * @param scrollbarId {String} child control id of the scrollbar to
       *   configure
       * @param show {Boolean} whether the scrollbar should be visible
       * @param containerSize {Integer} size of the container widget
       * @param contentSize {Integer} size of the iframe's document
       */
      _configureScrollbar: function _configureScrollbar(scrollbarId, show, containerSize, contentSize) {
        if (!show) {
          this._excludeChildControl(scrollbarId);

          return;
        }

        var bar = this._showChildControl(scrollbarId);

        if (containerSize >= contentSize) {
          bar.set({
            position: 0,
            maximum: contentSize,
            knobFactor: 1,
            enabled: false
          });
        } else {
          bar.setMaximum(1000000);
          bar.set({
            position: Math.min(bar.getPosition(), contentSize),
            maximum: contentSize - containerSize,
            knobFactor: containerSize / contentSize,
            enabled: true
          });
        }
      },

      /**
       * Event handler for the scroll event of the horizontal scrollbar
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollBarX: function _onScrollBarX(e) {
        this.scrollToX(e.getData());
      },

      /**
       * Event handler for the scroll event of the vertical scrollbar
       *
       * @param e {qx.event.type.Data} The scroll event object
       */
      _onScrollBarY: function _onScrollBarY(e) {
        this.scrollToY(e.getData());
      },

      /**
       * Scrolls the iframe's content to the given left coordinate
       *
       * @param x {Integer} The vertical position to scroll to.
       */
      scrollToX: function scrollToX(x) {
        try {
          var win = this._getIframeElement().getWindow();

          win.scroll(x, qx.bom.Viewport.getScrollTop(win));
        } catch (e) {
          this._disableScollbars();
        }
      },

      /**
       * Scrolls the iframe's content to the given top coordinate
       *
       * @param y {Integer} The horizontal position to scroll to.
       */
      scrollToY: function scrollToY(y) {
        try {
          var win = this._getIframeElement().getWindow();

          win.scroll(qx.bom.Viewport.getScrollLeft(win), y);
        } catch (e) {
          this._disableScollbars();
        }
      }
    },
    destruct: function destruct() {
      this._stopIframeObserver();

      this.__iframeSize__P_409_0 = null;
    }
  });
  qx.ui.embed.ThemedIframe.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.form.List": {},
      "qx.ui.popup.Popup": {},
      "qx.ui.layout.VBox": {},
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Basic class for a selectbox like lists. Basically supports a popup
   * with a list and the whole children management.
   *
   * @childControl list {qx.ui.form.List} list component of the selectbox
   * @childControl popup {qx.ui.popup.Popup} popup which shows the list
   *
   */
  qx.Class.define("qx.ui.form.AbstractSelectBox", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.form.MForm],
    implement: [qx.ui.form.IForm],
    type: "abstract",

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // set the layout

      var layout = new qx.ui.layout.HBox();

      this._setLayout(layout);

      layout.setAlignY("middle"); // Register listeners

      this.addListener("keypress", this._onKeyPress);
      this.addListener("blur", this._onBlur, this); // register the resize listener

      this.addListener("resize", this._onResize, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 120
      },

      /**
       * The maximum height of the list popup. Setting this value to
       * <code>null</code> will set cause the list to be auto-sized.
       */
      maxListHeight: {
        check: "Number",
        apply: "_applyMaxListHeight",
        nullable: true,
        init: 200
      },

      /**
       * Formatter which format the value from the selected <code>ListItem</code>.
       * Uses the default formatter {@link #_defaultFormat}.
       */
      format: {
        check: "Function",
        init: function init(item) {
          return this._defaultFormat(item);
        },
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "list":
            control = new qx.ui.form.List().set({
              focusable: false,
              keepFocus: true,
              height: null,
              width: null,
              maxHeight: this.getMaxListHeight(),
              selectionMode: "one",
              quickSelection: true
            });
            control.addListener("changeSelection", this._onListChangeSelection, this);
            control.addListener("pointerdown", this._onListPointerDown, this);
            control.getChildControl("pane").addListener("tap", this.close, this);
            break;

          case "popup":
            control = new qx.ui.popup.Popup(new qx.ui.layout.VBox());
            control.setAutoHide(false);
            control.setKeepActive(true);
            control.add(this.getChildControl("list"));
            control.addListener("changeVisibility", this._onPopupChangeVisibility, this);
            break;
        }

        return control || qx.ui.form.AbstractSelectBox.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyMaxListHeight: function _applyMaxListHeight(value, old) {
        this.getChildControl("list").setMaxHeight(value);
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the list widget.
       * @return {qx.ui.form.List} the list
       */
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("list");
      },

      /*
      ---------------------------------------------------------------------------
        LIST STUFF
      ---------------------------------------------------------------------------
      */

      /**
       * Shows the list popup.
       */
      open: function open() {
        var popup = this.getChildControl("popup");
        popup.placeToWidget(this, true);
        popup.show();
      },

      /**
       * Hides the list popup.
       */
      close: function close() {
        this.getChildControl("popup").hide();
      },

      /**
       * Toggles the popup's visibility.
       */
      toggle: function toggle() {
        var isListOpen = this.getChildControl("popup").isVisible();

        if (isListOpen) {
          this.close();
        } else {
          this.open();
        }
      },

      /*
      ---------------------------------------------------------------------------
        FORMAT HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Return the formatted label text from the <code>ListItem</code>.
       * The formatter removes all HTML tags and converts all HTML entities
       * to string characters when the rich property is <code>true</code>.
       *
       * @param item {qx.ui.form.ListItem} The list item to format.
       * @return {String} The formatted text.
       */
      _defaultFormat: function _defaultFormat(item) {
        var valueLabel = item ? item.getLabel() : "";
        var rich = item ? item.getRich() : false;

        if (rich) {
          valueLabel = valueLabel.replace(/<[^>]+?>/g, "");
          valueLabel = qx.bom.String.unescape(valueLabel);
        }

        return valueLabel;
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Handler for the blur event of the current widget.
       *
       * @param e {qx.event.type.Focus} The blur event.
       */
      _onBlur: function _onBlur(e) {
        this.close();
      },

      /**
       * Reacts on special keys and forwards other key events to the list widget.
       *
       * @param e {qx.event.type.KeySequence} Keypress event
       */
      _onKeyPress: function _onKeyPress(e) {
        // get the key identifier
        var identifier = e.getKeyIdentifier();
        var listPopup = this.getChildControl("popup"); // disabled pageUp and pageDown keys

        if (listPopup.isHidden() && (identifier == "PageDown" || identifier == "PageUp")) {
          e.stopPropagation();
        } // hide the list always on escape
        else if (!listPopup.isHidden() && identifier == "Escape") {
            this.close();
            e.stop();
          } // forward the rest of the events to the list
          else {
              this.getChildControl("list").handleKeyPress(e);
            }
      },

      /**
       * Updates list minimum size.
       *
       * @param e {qx.event.type.Data} Data event
       */
      _onResize: function _onResize(e) {
        this.getChildControl("popup").setMinWidth(e.getData().width);
      },

      /**
       * Syncs the own property from the list change
       *
       * @param e {qx.event.type.Data} Data Event
       */
      _onListChangeSelection: function _onListChangeSelection(e) {
        throw new Error("Abstract method: _onListChangeSelection()");
      },

      /**
       * Redirects pointerdown event from the list to this widget.
       *
       * @param e {qx.event.type.Pointer} Pointer Event
       */
      _onListPointerDown: function _onListPointerDown(e) {
        throw new Error("Abstract method: _onListPointerDown()");
      },

      /**
       * Redirects changeVisibility event from the list to this widget.
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onPopupChangeVisibility: function _onPopupChangeVisibility(e) {
        e.getData() == "visible" ? this.addState("popupOpen") : this.removeState("popupOpen");
      }
    }
  });
  qx.ui.form.AbstractSelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This mixin offers the selection of the model properties.
   * It can only be included if the object including it implements the
   * {@link qx.ui.core.ISingleSelection} interface and the selectables implement
   * the {@link qx.ui.form.IModel} interface.
   */
  qx.Mixin.define("qx.ui.form.MModelSelection", {
    construct: function construct() {
      // create the selection array
      this.__modelSelection__P_417_0 = new qx.data.Array(); // listen to the changes

      this.__modelSelection__P_417_0.addListener("change", this.__onModelSelectionArrayChange__P_417_1, this);

      this.addListener("changeSelection", this.__onModelSelectionChange__P_417_2, this);
    },
    events: {
      /**
       * Pseudo event. It will never be fired because the array itself can not
       * be changed. But the event description is needed for the data binding.
       */
      changeModelSelection: "qx.event.type.Data"
    },
    members: {
      __modelSelection__P_417_0: null,
      __inSelectionChange__P_417_3: false,

      /**
       * Handler for the selection change of the including class e.g. SelectBox,
       * List, ...
       * It sets the new modelSelection via {@link #setModelSelection}.
       */
      __onModelSelectionChange__P_417_2: function __onModelSelectionChange__P_417_2() {
        if (this.__inSelectionChange__P_417_3) {
          return;
        }

        var data = this.getSelection(); // create the array with the modes inside

        var modelSelection = [];

        for (var i = 0; i < data.length; i++) {
          var item = data[i]; // fallback if getModel is not implemented

          var model = item.getModel ? item.getModel() : null;

          if (model !== null) {
            modelSelection.push(model);
          }
        }

        try {
          this.setModelSelection(modelSelection);
        } catch (e) {
          throw new Error("Could not set the model selection. Maybe your models are not unique? " + e);
        }
      },

      /**
       * Listener for the change of the internal model selection data array.
       */
      __onModelSelectionArrayChange__P_417_1: function __onModelSelectionArrayChange__P_417_1() {
        this.__inSelectionChange__P_417_3 = true;
        var selectables = this.getSelectables(true);
        var itemSelection = [];

        var modelSelection = this.__modelSelection__P_417_0.toArray();

        for (var i = 0; i < modelSelection.length; i++) {
          var model = modelSelection[i];

          for (var j = 0; j < selectables.length; j++) {
            var selectable = selectables[j]; // fallback if getModel is not implemented

            var selectableModel = selectable.getModel ? selectable.getModel() : null;

            if (model === selectableModel) {
              itemSelection.push(selectable);
              break;
            }
          }
        }

        this.setSelection(itemSelection);
        this.__inSelectionChange__P_417_3 = false; // check if the setting has worked

        var currentSelection = this.getSelection();

        if (!qx.lang.Array.equals(currentSelection, itemSelection)) {
          // if not, set the actual selection
          this.__onModelSelectionChange__P_417_2();
        }
      },

      /**
       * Returns always an array of the models of the selected items. If no
       * item is selected or no model is given, the array will be empty.
       *
       * *CAREFUL!* The model selection can only work if every item item in the
       * selection providing widget has a model property!
       *
       * @return {qx.data.Array} An array of the models of the selected items.
       */
      getModelSelection: function getModelSelection() {
        return this.__modelSelection__P_417_0;
      },

      /**
       * Takes the given models in the array and searches for the corresponding
       * selectables. If an selectable does have that model attached, it will be
       * selected.
       *
       * *Attention:* This method can have a time complexity of O(n^2)!
       *
       * *CAREFUL!* The model selection can only work if every item item in the
       * selection providing widget has a model property!
       *
       * @param modelSelection {Array} An array of models, which should be
       *   selected.
       */
      setModelSelection: function setModelSelection(modelSelection) {
        // check for null values
        if (!modelSelection) {
          this.__modelSelection__P_417_0.removeAll();

          return;
        }

        {
          this.assertArray(modelSelection, "Please use an array as parameter.");
        } // add the first two parameter

        modelSelection.unshift(this.__modelSelection__P_417_0.getLength()); // remove index

        modelSelection.unshift(0); // start index

        var returnArray = this.__modelSelection__P_417_0.splice.apply(this.__modelSelection__P_417_0, modelSelection);

        returnArray.dispose();
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__modelSelection__P_417_0");
    }
  });
  qx.ui.form.MModelSelection.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.scroll.AbstractScrollArea": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.IMultiSelection": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IModelSelection": {
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.core.MMultiSelectionHandling": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelSelection": {
        "require": true
      },
      "qx.ui.core.selection.ScrollArea": {
        "require": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.layout.VBox": {},
      "qx.bom.element.Attribute": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A list of items. Displays an automatically scrolling list for all
   * added {@link qx.ui.form.ListItem} instances. Supports various
   * selection options: single, multi, ...
   */
  qx.Class.define("qx.ui.form.List", {
    extend: qx.ui.core.scroll.AbstractScrollArea,
    implement: [qx.ui.core.IMultiSelection, qx.ui.form.IForm, qx.ui.form.IField, qx.ui.form.IModelSelection],
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.core.MMultiSelectionHandling, qx.ui.form.MForm, qx.ui.form.MModelSelection],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param horizontal {Boolean?false} Whether the list should be horizontal.
     */
    construct: function construct(horizontal) {
      qx.ui.core.scroll.AbstractScrollArea.constructor.call(this); // Create content

      this.__content__P_415_0 = this._createListItemContainer(); // Used to fire item add/remove events

      this.__content__P_415_0.addListener("addChildWidget", this._onAddChild, this);

      this.__content__P_415_0.addListener("removeChildWidget", this._onRemoveChild, this); // Add to scrollpane


      this.getChildControl("pane").add(this.__content__P_415_0); // Apply orientation

      if (horizontal) {
        this.setOrientation("horizontal");
      } else {
        this.initOrientation();
      } // Add keypress listener


      this.addListener("keypress", this._onKeyPress);
      this.addListener("keyinput", this._onKeyInput); // initialize the search string

      this.__pressedString__P_415_1 = "";
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * This event is fired after a list item was added to the list. The
       * {@link qx.event.type.Data#getData} method of the event returns the
       * added item.
       */
      addItem: "qx.event.type.Data",

      /**
       * This event is fired after a list item has been removed from the list.
       * The {@link qx.event.type.Data#getData} method of the event returns the
       * removed item.
       */
      removeItem: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "list"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 100
      },
      // overridden
      height: {
        refine: true,
        init: 200
      },

      /**
       * Whether the list should be rendered horizontal or vertical.
       */
      orientation: {
        check: ["horizontal", "vertical"],
        init: "vertical",
        apply: "_applyOrientation"
      },

      /** Spacing between the items */
      spacing: {
        check: "Integer",
        init: 0,
        apply: "_applySpacing",
        themeable: true
      },

      /** Controls whether the inline-find feature is activated or not */
      enableInlineFind: {
        check: "Boolean",
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __pressedString__P_415_1: null,
      __lastKeyPress__P_415_2: null,

      /** @type {qx.ui.core.Widget} The children container */
      __content__P_415_0: null,

      /** @type {Class} Pointer to the selection manager to use */
      SELECTION_MANAGER: qx.ui.core.selection.ScrollArea,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      getChildrenContainer: function getChildrenContainer() {
        return this.__content__P_415_0;
      },

      /**
       * Handle child widget adds on the content pane
       *
       * @param e {qx.event.type.Data} the event instance
       */
      _onAddChild: function _onAddChild(e) {
        this.fireDataEvent("addItem", e.getData());
      },

      /**
       * Handle child widget removes on the content pane
       *
       * @param e {qx.event.type.Data} the event instance
       */
      _onRemoveChild: function _onRemoveChild(e) {
        this.fireDataEvent("removeItem", e.getData());
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Used to route external <code>keypress</code> events to the list
       * handling (in fact the manager of the list)
       *
       * @param e {qx.event.type.KeySequence} KeyPress event
       */
      handleKeyPress: function handleKeyPress(e) {
        if (!this._onKeyPress(e)) {
          this._getManager().handleKeyPress(e);
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROTECTED API
      ---------------------------------------------------------------------------
      */

      /**
       * This container holds the list item widgets.
       *
       * @return {qx.ui.container.Composite} Container for the list item widgets
       */
      _createListItemContainer: function _createListItemContainer() {
        return new qx.ui.container.Composite();
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        var content = this.__content__P_415_0; // save old layout for disposal

        var oldLayout = content.getLayout(); // Create new layout

        var horizontal = value === "horizontal";
        var layout = horizontal ? new qx.ui.layout.HBox() : new qx.ui.layout.VBox(); // Configure content

        content.setLayout(layout);
        content.setAllowGrowX(!horizontal);
        content.setAllowGrowY(horizontal); // Configure spacing

        this._applySpacing(this.getSpacing()); // dispose old layout


        if (oldLayout) {
          oldLayout.dispose();
        }
      },
      // property apply
      _applySpacing: function _applySpacing(value, old) {
        this.__content__P_415_0.getLayout().setSpacing(value);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for <code>keypress</code> events.
       *
       * @param e {qx.event.type.KeySequence} KeyPress event
       * @return {Boolean} Whether the event was processed
       */
      _onKeyPress: function _onKeyPress(e) {
        // Execute action on press <ENTER>
        if (e.getKeyIdentifier() == "Enter" && !e.isAltPressed()) {
          var items = this.getSelection();

          for (var i = 0; i < items.length; i++) {
            items[i].fireEvent("action");
          }

          return true;
        }

        return false;
      },

      /*
      ---------------------------------------------------------------------------
        FIND SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Handles the inline find - if enabled
       *
       * @param e {qx.event.type.KeyInput} key input event
       */
      _onKeyInput: function _onKeyInput(e) {
        // do nothing if the find is disabled
        if (!this.getEnableInlineFind()) {
          return;
        } // Only useful in single or one selection mode


        var mode = this.getSelectionMode();

        if (!(mode === "single" || mode === "one")) {
          return;
        } // Reset string after a second of non pressed key


        if (new Date().valueOf() - this.__lastKeyPress__P_415_2 > 1000) {
          this.__pressedString__P_415_1 = "";
        } // Combine keys the user pressed to a string


        this.__pressedString__P_415_1 += e.getChar(); // Find matching item

        var matchedItem = this.findItemByLabelFuzzy(this.__pressedString__P_415_1); // if an item was found, select it

        if (matchedItem) {
          this.setSelection([matchedItem]);
        } // Store timestamp


        this.__lastKeyPress__P_415_2 = new Date().valueOf();
      },

      /**
       * Takes the given string and tries to find a ListItem
       * which starts with this string. The search is not case sensitive and the
       * first found ListItem will be returned. If there could not be found any
       * qualifying list item, null will be returned.
       *
       * @param search {String} The text with which the label of the ListItem should start with
       * @return {qx.ui.form.ListItem} The found ListItem or null
       */
      findItemByLabelFuzzy: function findItemByLabelFuzzy(search) {
        // lower case search text
        search = search.toLowerCase(); // get all items of the list

        var items = this.getChildren(); // go threw all items

        for (var i = 0, l = items.length; i < l; i++) {
          // get the label of the current item
          var currentLabel = items[i].getLabel(); // if the label fits with the search text (ignore case, begins with)

          if (currentLabel && currentLabel.toLowerCase().indexOf(search) == 0) {
            // just return the first found element
            return items[i];
          }
        } // if no element was found, return null


        return null;
      },

      /**
       * Find an item by its {@link qx.ui.basic.Atom#getLabel}.
       *
       * @param search {String} A label or any item
       * @param ignoreCase {Boolean?true} description
       * @return {qx.ui.form.ListItem} The found ListItem or null
       */
      findItem: function findItem(search, ignoreCase) {
        // lowercase search
        if (ignoreCase !== false) {
          search = search.toLowerCase();
        }

        ; // get all items of the list

        var items = this.getChildren();
        var item; // go through all items

        for (var i = 0, l = items.length; i < l; i++) {
          item = items[i]; // get the content of the label; text content when rich

          var label;

          if (item.isRich()) {
            var control = item.getChildControl("label", true);

            if (control) {
              var labelNode = control.getContentElement().getDomElement();

              if (labelNode) {
                label = qx.bom.element.Attribute.get(labelNode, "text");
              }
            }
          } else {
            label = item.getLabel();
          }

          if (label != null) {
            if (label.translate) {
              label = label.translate();
            }

            if (ignoreCase !== false) {
              label = label.toLowerCase();
            }

            if (label.toString() == search.toString()) {
              return item;
            }
          }
        }

        return null;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__content__P_415_0");
    }
  });
  qx.ui.form.List.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which have boolean as their primary
   * data type like a checkbox.
   */
  qx.Interface.define("qx.ui.form.IBooleanForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {Boolean|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {Boolean|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.IBooleanForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.RadioGroup": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Each object, which should be managed by a {@link RadioGroup} have to
   * implement this interface.
   */
  qx.Interface.define("qx.ui.form.IRadioItem", {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the item was checked or unchecked */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Set whether the item is checked
       *
       * @param value {Boolean} whether the item should be checked
       */
      setValue: function setValue(value) {},

      /**
       * Get whether the item is checked
       *
       * @return {Boolean} whether the item it checked
       */
      getValue: function getValue() {},

      /**
       * Set the radiogroup, which manages this item
       *
       * @param value {qx.ui.form.RadioGroup} The radiogroup, which should
       *     manage the item.
       */
      setGroup: function setGroup(value) {
        this.assertInstance(value, qx.ui.form.RadioGroup);
      },

      /**
       * Get the radiogroup, which manages this item
       *
       * @return {qx.ui.form.RadioGroup} The radiogroup, which manages the item.
       */
      getGroup: function getGroup() {}
    }
  });
  qx.ui.form.IRadioItem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.basic.Atom": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * A toggle Button widget
   *
   * If the user presses the button by tapping on it pressing the enter or
   * space key, the button toggles between the pressed an not pressed states.
   */
  qx.Class.define("qx.ui.form.ToggleButton", {
    extend: qx.ui.basic.Atom,
    include: [qx.ui.core.MExecutable],
    implement: [qx.ui.form.IBooleanForm, qx.ui.form.IExecutable, qx.ui.form.IRadioItem],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Creates a ToggleButton.
     *
     * @param label {String} The text on the button.
     * @param icon {String} An URI to the icon of the button.
     */
    construct: function construct(label, icon) {
      qx.ui.basic.Atom.constructor.call(this, label, icon); // register pointer events

      this.addListener("pointerover", this._onPointerOver);
      this.addListener("pointerout", this._onPointerOut);
      this.addListener("pointerdown", this._onPointerDown);
      this.addListener("pointerup", this._onPointerUp); // register keyboard events

      this.addListener("keydown", this._onKeyDown);
      this.addListener("keyup", this._onKeyUp); // register execute event

      this.addListener("execute", this._onExecute, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "toggle-button"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /** The value of the widget. True, if the widget is checked. */
      value: {
        check: "Boolean",
        nullable: true,
        event: "changeValue",
        apply: "_applyValue",
        init: false
      },

      /** The assigned qx.ui.form.RadioGroup which handles the switching between registered buttons. */
      group: {
        check: "qx.ui.form.RadioGroup",
        nullable: true,
        apply: "_applyGroup"
      },

      /**
      * Whether the button has a third state. Use this for tri-state checkboxes.
      *
      * When enabled, the value null of the property value stands for "undetermined",
      * while true is mapped to "enabled" and false to "disabled" as usual. Note
      * that the value property is set to false initially.
      *
      */
      triState: {
        check: "Boolean",
        apply: "_applyTriState",
        nullable: true,
        init: null
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** The assigned {@link qx.ui.form.RadioGroup} which handles the switching between registered buttons */
      _applyGroup: function _applyGroup(value, old) {
        if (old) {
          old.remove(this);
        }

        if (value) {
          value.add(this);
        }
      },

      /**
       * Changes the state of the button dependent on the checked value.
       *
       * @param value {Boolean} Current value
       * @param old {Boolean} Previous value
       */
      _applyValue: function _applyValue(value, old) {
        value ? this.addState("checked") : this.removeState("checked");

        if (this.isTriState()) {
          if (value === null) {
            this.addState("undetermined");
          } else if (old === null) {
            this.removeState("undetermined");
          }
        }
      },

      /**
      * Apply value property when triState property is modified.
      *
      * @param value {Boolean} Current value
      * @param old {Boolean} Previous value
      */
      _applyTriState: function _applyTriState(value, old) {
        this._applyValue(this.getValue());
      },

      /**
       * Handler for the execute event.
       *
       * @param e {qx.event.type.Event} The execute event.
       */
      _onExecute: function _onExecute(e) {
        this.toggleValue();
      },

      /**
       * Listener method for "pointerover" event.
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onPointerOver: function _onPointerOver(e) {
        if (e.getTarget() !== this) {
          return;
        }

        this.addState("hovered");

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
          this.addState("pressed");
        }
      },

      /**
       * Listener method for "pointerout" event.
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" state (if "pressed" state is set)</li>
       * <li>Removes "pressed" state (if "pressed" state is set and button is not checked)
       * </ul>
       *
       * @param e {qx.event.type.Pointer} pointer event
       */
      _onPointerOut: function _onPointerOut(e) {
        if (e.getTarget() !== this) {
          return;
        }

        this.removeState("hovered");

        if (this.hasState("pressed")) {
          if (!this.getValue()) {
            this.removeState("pressed");
          }

          this.addState("abandoned");
        }
      },

      /**
       * Listener method for "pointerdown" event.
       * <ul>
       * <li>Activates capturing</li>
       * <li>Removes "abandoned" state</li>
       * <li>Adds "pressed" state</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} pointer event
       */
      _onPointerDown: function _onPointerDown(e) {
        if (!e.isLeftPressed()) {
          return;
        } // Activate capturing if the button get a pointerout while
        // the button is pressed.


        this.capture();
        this.removeState("abandoned");
        this.addState("pressed");
        e.stopPropagation();
      },

      /**
       * Listener method for "pointerup" event.
       * <ul>
       * <li>Releases capturing</li>
       * <li>Removes "pressed" state (if not "abandoned" state is set and "pressed" state is set)</li>
       * <li>Removes "abandoned" state (if set)</li>
       * <li>Toggles {@link #value} (if state "abandoned" is not set and state "pressed" is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} pointer event
       */
      _onPointerUp: function _onPointerUp(e) {
        this.releaseCapture();

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
        } else if (this.hasState("pressed")) {
          this.execute();
        }

        this.removeState("pressed");
        e.stopPropagation();
      },

      /**
       * Listener method for "keydown" event.<br/>
       * Removes "abandoned" and adds "pressed" state
       * for the keys "Enter" or "Space"
       *
       * @param e {Event} Key event
       */
      _onKeyDown: function _onKeyDown(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            this.removeState("abandoned");
            this.addState("pressed");
            e.stopPropagation();
        }
      },

      /**
       * Listener method for "keyup" event.<br/>
       * Removes "abandoned" and "pressed" state (if "pressed" state is set)
       * for the keys "Enter" or "Space". It also toggles the {@link #value} property.
       *
       * @param e {Event} Key event
       */
      _onKeyUp: function _onKeyUp(e) {
        if (!this.hasState("pressed")) {
          return;
        }

        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            this.removeState("abandoned");
            this.execute();
            this.removeState("pressed");
            e.stopPropagation();
        }
      }
    }
  });
  qx.ui.form.ToggleButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.ToggleButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A check box widget with an optional label.
   */
  qx.Class.define("qx.ui.form.CheckBox", {
    extend: qx.ui.form.ToggleButton,
    include: [qx.ui.form.MForm, qx.ui.form.MModelProperty],
    implement: [qx.ui.form.IForm, qx.ui.form.IModel],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String?null} An optional label for the check box.
     */
    construct: function construct(label) {
      {
        this.assertArgumentsCount(arguments, 0, 1);
      }
      qx.ui.form.ToggleButton.constructor.call(this, label); // Initialize the checkbox to a valid value (the default is null which
      // is invalid)

      this.setValue(false);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "checkbox"
      },
      // overridden
      allowGrowX: {
        refine: true,
        init: false
      }
    },
    members: {
      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        invalid: true,
        focused: true,
        undetermined: true,
        checked: true,
        hovered: true
      },

      /**
       * overridden (from MExecutable to keep the icon out of the binding)
       * @lint ignoreReferenceField(_bindableProperties)
       */
      _bindableProperties: ["enabled", "label", "toolTipText", "value", "menu"]
    }
  });
  qx.ui.form.CheckBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.ISingleSelection": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModelSelection": {
        "require": true
      },
      "qx.ui.core.MSingleSelectionHandling": {
        "require": true
      },
      "qx.ui.form.MModelSelection": {
        "require": true
      },
      "qx.lang.String": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The radio group handles a collection of items from which only one item
   * can be selected. Selection another item will deselect the previously selected
   * item.
   *
   * This class is e.g. used to create radio groups or {@link qx.ui.form.RadioButton}
   * or {@link qx.ui.toolbar.RadioButton} instances.
   *
   * We also offer a widget for the same purpose which uses this class. So if
   * you like to act with a widget instead of a pure logic coupling of the
   * widgets, take a look at the {@link qx.ui.form.RadioButtonGroup} widget.
   */
  qx.Class.define("qx.ui.form.RadioGroup", {
    extend: qx.core.Object,
    implement: [qx.ui.core.ISingleSelection, qx.ui.form.IField, qx.ui.form.IForm, qx.ui.form.IModelSelection],
    include: [qx.ui.core.MSingleSelectionHandling, qx.ui.form.MModelSelection],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param varargs {qx.core.Object} A variable number of items, which are
     *     initially added to the radio group, the first item will be selected.
     */
    construct: function construct(varargs) {
      qx.core.Object.constructor.call(this); // create item array

      this.__items__P_419_0 = []; // add listener before call add!!!

      this.addListener("changeSelection", this.__onChangeSelection__P_419_1, this);

      if (varargs != null) {
        this.add.apply(this, arguments);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The property name in each of the added widgets that is grouped
       */
      groupedProperty: {
        check: "String",
        apply: "_applyGroupedProperty",
        event: "changeGroupedProperty",
        init: "value"
      },

      /**
       * The property name in each of the added widgets that is informed of the
       * RadioGroup object it is a member of
       */
      groupProperty: {
        check: "String",
        event: "changeGroupProperty",
        init: "group"
      },

      /**
       * Whether the radio group is enabled
       */
      enabled: {
        check: "Boolean",
        apply: "_applyEnabled",
        event: "changeEnabled",
        init: true
      },

      /**
       * Whether the selection should wrap around. This means that the successor of
       * the last item is the first item.
       */
      wrap: {
        check: "Boolean",
        init: true
      },

      /**
       * If is set to <code>true</code> the selection could be empty,
       * otherwise is always one <code>RadioButton</code> selected.
       */
      allowEmptySelection: {
        check: "Boolean",
        init: false,
        apply: "_applyAllowEmptySelection"
      },

      /**
       * Flag signaling if the group at all is valid. All children will have the
       * same state.
       */
      valid: {
        check: "Boolean",
        init: true,
        apply: "_applyValid",
        event: "changeValid"
      },

      /**
       * Flag signaling if the group is required.
       */
      required: {
        check: "Boolean",
        init: false,
        event: "changeRequired"
      },

      /**
       * Message which is shown in an invalid tooltip.
       */
      invalidMessage: {
        check: "String",
        init: "",
        event: "changeInvalidMessage",
        apply: "_applyInvalidMessage"
      },

      /**
       * Message which is shown in an invalid tooltip if the {@link #required} is
       * set to true.
       */
      requiredInvalidMessage: {
        check: "String",
        nullable: true,
        event: "changeInvalidMessage"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.form.IRadioItem[]} The items of the radio group */
      __items__P_419_0: null,

      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */

      /**
       * Get all managed items
       *
       * @return {qx.ui.form.IRadioItem[]} All managed items.
       */
      getItems: function getItems() {
        return this.__items__P_419_0;
      },

      /*
      ---------------------------------------------------------------------------
        REGISTRY
      ---------------------------------------------------------------------------
      */

      /**
       * Add the passed items to the radio group.
       *
       * @param varargs {qx.ui.form.IRadioItem} A variable number of items to add.
       */
      add: function add(varargs) {
        var items = this.__items__P_419_0;
        var item;
        var groupedProperty = this.getGroupedProperty();
        var groupedPropertyUp = qx.lang.String.firstUp(groupedProperty);

        for (var i = 0, l = arguments.length; i < l; i++) {
          item = arguments[i];

          if (items.includes(item)) {
            continue;
          } // Register listeners


          item.addListener("change" + groupedPropertyUp, this._onItemChangeChecked, this); // Push RadioButton to array

          items.push(item); // Inform radio button about new group

          item.set(this.getGroupProperty(), this); // Need to update internal value?

          if (item.get(groupedProperty)) {
            this.setSelection([item]);
          }
        } // Select first item when only one is registered


        if (!this.isAllowEmptySelection() && items.length > 0 && !this.getSelection()[0]) {
          this.setSelection([items[0]]);
        }
      },

      /**
       * Remove an item from the radio group.
       *
       * @param item {qx.ui.form.IRadioItem} The item to remove.
       */
      remove: function remove(item) {
        var items = this.__items__P_419_0;
        var groupedProperty = this.getGroupedProperty();
        var groupedPropertyUp = qx.lang.String.firstUp(groupedProperty);

        if (items.includes(item)) {
          // Remove RadioButton from array
          qx.lang.Array.remove(items, item); // Inform radio button about new group

          if (item.get(this.getGroupProperty()) === this) {
            item.reset(this.getGroupProperty());
          } // Deregister listeners


          item.removeListener("change" + groupedPropertyUp, this._onItemChangeChecked, this); // if the radio was checked, set internal selection to null

          if (item.get(groupedProperty)) {
            this.resetSelection();
          }
        }
      },

      /**
       * Returns an array containing the group's items.
       *
       * @return {qx.ui.form.IRadioItem[]} The item array
       */
      getChildren: function getChildren() {
        return this.__items__P_419_0;
      },

      /*
      ---------------------------------------------------------------------------
        LISTENER FOR ITEM CHANGES
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for <code>changeValue</code> event of every managed item.
       *
       * @param e {qx.event.type.Data} Data event
       */
      _onItemChangeChecked: function _onItemChangeChecked(e) {
        var item = e.getTarget();
        var groupedProperty = this.getGroupedProperty();

        if (item.get(groupedProperty)) {
          this.setSelection([item]);
        } else if (this.getSelection()[0] == item) {
          this.resetSelection();
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyGroupedProperty: function _applyGroupedProperty(value, old) {
        var item;
        var oldFirstUp = qx.lang.String.firstUp(old);
        var newFirstUp = qx.lang.String.firstUp(value);

        for (var i = 0; i < this.__items__P_419_0.length; i++) {
          item = this.__items__P_419_0[i]; // remove the listener for the old change event

          item.removeListener("change" + oldFirstUp, this._onItemChangeChecked, this); // add the listener for the new change event

          item.removeListener("change" + newFirstUp, this._onItemChangeChecked, this);
        }
      },
      // property apply
      _applyInvalidMessage: function _applyInvalidMessage(value, old) {
        for (var i = 0; i < this.__items__P_419_0.length; i++) {
          this.__items__P_419_0[i].setInvalidMessage(value);
        }
      },
      // property apply
      _applyValid: function _applyValid(value, old) {
        for (var i = 0; i < this.__items__P_419_0.length; i++) {
          this.__items__P_419_0[i].setValid(value);
        }
      },
      // property apply
      _applyEnabled: function _applyEnabled(value, old) {
        var items = this.__items__P_419_0;

        if (value == null) {
          for (var i = 0, l = items.length; i < l; i++) {
            items[i].resetEnabled();
          }
        } else {
          for (var i = 0, l = items.length; i < l; i++) {
            items[i].setEnabled(value);
          }
        }
      },
      // property apply
      _applyAllowEmptySelection: function _applyAllowEmptySelection(value, old) {
        if (!value && this.isSelectionEmpty()) {
          this.resetSelection();
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION
      ---------------------------------------------------------------------------
      */

      /**
       * Select the item following the given item.
       */
      selectNext: function selectNext() {
        var item = this.getSelection()[0];
        var items = this.__items__P_419_0;
        var index = items.indexOf(item);

        if (index == -1) {
          return;
        }

        var i = 0;
        var length = items.length; // Find next enabled item

        if (this.getWrap()) {
          index = (index + 1) % length;
        } else {
          index = Math.min(index + 1, length - 1);
        }

        while (i < length && !items[index].getEnabled()) {
          index = (index + 1) % length;
          i++;
        }

        this.setSelection([items[index]]);
      },

      /**
       * Select the item previous the given item.
       */
      selectPrevious: function selectPrevious() {
        var item = this.getSelection()[0];
        var items = this.__items__P_419_0;
        var index = items.indexOf(item);

        if (index == -1) {
          return;
        }

        var i = 0;
        var length = items.length; // Find previous enabled item

        if (this.getWrap()) {
          index = (index - 1 + length) % length;
        } else {
          index = Math.max(index - 1, 0);
        }

        while (i < length && !items[index].getEnabled()) {
          index = (index - 1 + length) % length;
          i++;
        }

        this.setSelection([items[index]]);
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS FOR SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the items for the selection.
       *
       * @return {qx.ui.form.IRadioItem[]} Items to select.
       */
      _getItems: function _getItems() {
        return this.getItems();
      },

      /**
       * Returns if the selection could be empty or not.
       *
       * @return {Boolean} <code>true</code> If selection could be empty,
       *    <code>false</code> otherwise.
       */
      _isAllowEmptySelection: function _isAllowEmptySelection() {
        return this.isAllowEmptySelection();
      },

      /**
       * Returns whether the item is selectable. In opposite to the default
       * implementation (which checks for visible items) every radio button
       * which is part of the group is selected even if it is currently not visible.
       *
       * @param item {qx.ui.form.IRadioItem} The item to check if its selectable.
       * @return {Boolean} <code>true</code> if the item is part of the radio group
       *    <code>false</code> otherwise.
       */
      _isItemSelectable: function _isItemSelectable(item) {
        return this.__items__P_419_0.indexOf(item) != -1;
      },

      /**
       * Event handler for <code>changeSelection</code>.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      __onChangeSelection__P_419_1: function __onChangeSelection__P_419_1(e) {
        var value = e.getData()[0];
        var old = e.getOldData()[0];
        var groupedProperty = this.getGroupedProperty();

        if (old) {
          old.set(groupedProperty, false);
        }

        if (value) {
          value.set(groupedProperty, true);
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeArray("__items__P_419_0");
    }
  });
  qx.ui.form.RadioGroup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.AbstractSelectBox": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IStringForm": {
        "require": true
      },
      "qx.event.type.Focus": {
        "construct": true
      },
      "qx.ui.form.TextField": {},
      "qx.ui.form.Button": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Basically a text fields which allows a selection from a list of
   * preconfigured options. Allows custom user input. Public API is value
   * oriented.
   *
   * To work with selections without custom input the ideal candidates are
   * the {@link SelectBox} or the {@link RadioGroup}.
   *
   * @childControl textfield {qx.ui.form.TextField} textfield component of the combobox
   * @childControl button {qx.ui.form.Button} button to open the list popup
   * @childControl list {qx.ui.form.List} list inside the popup
   */
  qx.Class.define("qx.ui.form.ComboBox", {
    extend: qx.ui.form.AbstractSelectBox,
    implement: [qx.ui.form.IStringForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.form.AbstractSelectBox.constructor.call(this);

      var textField = this._createChildControl("textfield");

      this._createChildControl("button");

      this.addListener("tap", this._onTap); // forward the focusin and focusout events to the textfield. The textfield
      // is not focusable so the events need to be forwarded manually.

      this.addListener("focusin", function (e) {
        textField.fireNonBubblingEvent("focusin", qx.event.type.Focus);
      }, this);
      this.addListener("focusout", function (e) {
        textField.fireNonBubblingEvent("focusout", qx.event.type.Focus);
      }, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "combobox"
      },

      /**
       * String value which will be shown as a hint if the field is all of:
       * unset, unfocused and enabled. Set to null to not show a placeholder
       * text.
       */
      placeholder: {
        check: "String",
        nullable: true,
        apply: "_applyPlaceholder"
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Whenever the value is changed this event is fired
       *
       *  Event data: The new text value of the field.
       */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __preSelectedItem__P_411_0: null,
      __onInputId__P_411_1: null,
      // property apply
      _applyPlaceholder: function _applyPlaceholder(value, old) {
        this.getChildControl("textfield").setPlaceholder(value);
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "textfield":
            control = new qx.ui.form.TextField();
            control.setFocusable(false);
            control.addState("inner");
            control.addListener("changeValue", this._onTextFieldChangeValue, this);
            control.addListener("blur", this.close, this);

            this._add(control, {
              flex: 1
            });

            break;

          case "button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.setKeepActive(true);
            control.addState("inner");
            control.addListener("execute", this.toggle, this);

            this._add(control);

            break;

          case "list":
            // Get the list from the AbstractSelectBox
            control = qx.ui.form.ComboBox.prototype._createChildControlImpl.base.call(this, id); // Change selection mode

            control.setSelectionMode("single");
            break;
        }

        return control || qx.ui.form.ComboBox.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        invalid: true
      },
      // overridden
      tabFocus: function tabFocus() {
        var field = this.getChildControl("textfield");
        field.getFocusElement().focus();
        field.selectAllText();
      },
      // overridden
      focus: function focus() {
        qx.ui.form.ComboBox.prototype.focus.base.call(this);
        this.getChildControl("textfield").getFocusElement().focus();
      },
      // interface implementation
      setValue: function setValue(value) {
        var textfield = this.getChildControl("textfield");

        if (textfield.getValue() == value) {
          return;
        } // Apply to text field


        textfield.setValue(value);
      },
      // interface implementation
      getValue: function getValue() {
        return this.getChildControl("textfield").getValue();
      },
      // interface implementation
      resetValue: function resetValue() {
        this.getChildControl("textfield").setValue(null);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      // overridden
      _onKeyPress: function _onKeyPress(e) {
        var popup = this.getChildControl("popup");
        var iden = e.getKeyIdentifier();

        if (iden == "Down" && e.isAltPressed()) {
          this.getChildControl("button").addState("selected");
          this.toggle();
          e.stopPropagation();
        } else if (iden == "Enter") {
          if (popup.isVisible()) {
            this._setPreselectedItem();

            this.resetAllTextSelection();
            this.close();
            e.stop();
          }
        } else if (popup.isVisible()) {
          qx.ui.form.ComboBox.prototype._onKeyPress.base.call(this, e);
        }
      },

      /**
       * Toggles the popup's visibility.
       *
       * @param e {qx.event.type.Pointer} Pointer tap event
       */
      _onTap: function _onTap(e) {
        this.close();
      },
      // overridden
      _onListPointerDown: function _onListPointerDown(e) {
        this._setPreselectedItem();
      },

      /**
       * Apply pre-selected item
       */
      _setPreselectedItem: function _setPreselectedItem() {
        if (this.__preSelectedItem__P_411_0) {
          var label = this.__preSelectedItem__P_411_0.getLabel();

          if (this.getFormat() != null) {
            label = this.getFormat().call(this, this.__preSelectedItem__P_411_0);
          } // check for translation


          if (label && label.translate) {
            label = label.translate();
          }

          this.setValue(label);
          this.__preSelectedItem__P_411_0 = null;
        }
      },
      // overridden
      _onListChangeSelection: function _onListChangeSelection(e) {
        var current = e.getData();

        if (current.length > 0) {
          // Ignore quick context (e.g. pointerover)
          // and configure the new value when closing the popup afterwards
          var list = this.getChildControl("list");
          var ctx = list.getSelectionContext();

          if (ctx == "quick" || ctx == "key") {
            this.__preSelectedItem__P_411_0 = current[0];
          } else {
            var label = current[0].getLabel();

            if (this.getFormat() != null) {
              label = this.getFormat().call(this, current[0]);
            } // check for translation


            if (label && label.translate) {
              label = label.translate();
            }

            this.setValue(label);
            this.__preSelectedItem__P_411_0 = null;
          }
        }
      },
      // overridden
      _onPopupChangeVisibility: function _onPopupChangeVisibility(e) {
        qx.ui.form.ComboBox.prototype._onPopupChangeVisibility.base.call(this, e); // Synchronize the list with the current value on every
        // opening of the popup. This is useful because through
        // the quick selection mode, the list may keep an invalid
        // selection on close or the user may enter text while
        // the combobox is closed and reopen it afterwards.


        var popup = this.getChildControl("popup");

        if (popup.isVisible()) {
          var list = this.getChildControl("list");
          var value = this.getValue();
          var item = null;

          if (value) {
            item = list.findItem(value);
          }

          if (item) {
            list.setSelection([item]);
          } else {
            list.resetSelection();
          }
        } else {
          // When closing the popup text should selected and field should
          // have the focus. Identical to when reaching the field using the TAB key.
          //
          // Only focus if popup was visible before. Fixes [BUG #4453].
          if (e.getOldData() == "visible") {
            this.tabFocus();
          }
        } // In all cases: Remove focused state from button


        this.getChildControl("button").removeState("selected");
      },

      /**
       * Reacts on value changes of the text field and syncs the
       * value to the combobox.
       *
       * @param e {qx.event.type.Data} Change event
       */
      _onTextFieldChangeValue: function _onTextFieldChangeValue(e) {
        var value = e.getData();
        var list = this.getChildControl("list");

        if (value != null) {
          // Select item when possible
          var item = list.findItem(value, false);

          if (item) {
            list.setSelection([item]);
          } else {
            list.resetSelection();
          }
        } else {
          list.resetSelection();
        } // Fire event


        this.fireDataEvent("changeValue", value, e.getOldData());
      },

      /*
      ---------------------------------------------------------------------------
        TEXTFIELD SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the current selection.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @return {String|null}
       */
      getTextSelection: function getTextSelection() {
        return this.getChildControl("textfield").getTextSelection();
      },

      /**
       * Returns the current selection length.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @return {Integer|null}
       */
      getTextSelectionLength: function getTextSelectionLength() {
        return this.getChildControl("textfield").getTextSelectionLength();
      },

      /**
       * Set the selection to the given start and end (zero-based).
       * If no end value is given the selection will extend to the
       * end of the textfield's content.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @param start {Integer} start of the selection (zero-based)
       * @param end {Integer} end of the selection
       */
      setTextSelection: function setTextSelection(start, end) {
        this.getChildControl("textfield").setTextSelection(start, end);
      },

      /**
       * Clears the current selection.
       * This method only works if the widget is already created and
       * added to the document.
       *
       */
      clearTextSelection: function clearTextSelection() {
        this.getChildControl("textfield").clearTextSelection();
      },

      /**
       * Selects the whole content
       *
       */
      selectAllText: function selectAllText() {
        this.getChildControl("textfield").selectAllText();
      },

      /**
       * Clear any text selection, then select all text
       *
       */
      resetAllTextSelection: function resetAllTextSelection() {
        this.clearTextSelection();
        this.selectAllText();
      }
    }
  });
  qx.ui.form.ComboBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IDateForm": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.event.type.Focus": {
        "construct": true
      },
      "qx.locale.Date": {},
      "qx.util.format.DateFormat": {},
      "qx.locale.Manager": {},
      "qx.ui.form.TextField": {},
      "qx.ui.form.Button": {},
      "qx.ui.control.DateChooser": {},
      "qx.ui.popup.Popup": {},
      "qx.ui.layout.VBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * A *date field* is like a combo box with the date as popup. As button to
   * open the calendar a calendar icon is shown at the right to the textfield.
   *
   * To be conform with all form widgets, the {@link qx.ui.form.IForm} interface
   * is implemented.
   *
   * The following example creates a date field and sets the current
   * date as selected.
   *
   * <pre class='javascript'>
   * var dateField = new qx.ui.form.DateField();
   * this.getRoot().add(dateField, {top: 20, left: 20});
   * dateField.setValue(new Date());
   * </pre>
   *
   * @childControl list {qx.ui.control.DateChooser} date chooser component
   * @childControl popup {qx.ui.popup.Popup} popup which shows the list control
   * @childControl textfield {qx.ui.form.TextField} text field for manual date entry
   * @childControl button {qx.ui.form.Button} button that opens the list control
   */
  qx.Class.define("qx.ui.form.DateField", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling, qx.ui.form.MForm],
    implement: [qx.ui.form.IForm, qx.ui.form.IDateForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // set the layout

      var layout = new qx.ui.layout.HBox();

      this._setLayout(layout);

      layout.setAlignY("middle"); // text field

      var textField = this._createChildControl("textfield");

      this._createChildControl("button"); // register listeners


      this.addListener("tap", this._onTap, this);
      this.addListener("blur", this._onBlur, this); // forward the focusin and focusout events to the textfield. The textfield
      // is not focusable so the events need to be forwarded manually.

      this.addListener("focusin", function (e) {
        textField.fireNonBubblingEvent("focusin", qx.event.type.Focus);
      }, this);
      this.addListener("focusout", function (e) {
        textField.fireNonBubblingEvent("focusout", qx.event.type.Focus);
      }, this); // initializes the DateField with the default format

      this._setDefaultDateFormat(); // adds a locale change listener


      this._addLocaleChangeListener();
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Whenever the value is changed this event is fired
       *
       *  Event data: The new text value of the field.
       */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The formatter, which converts the selected date to a string. **/
      dateFormat: {
        check: "qx.util.format.DateFormat",
        apply: "_applyDateFormat"
      },

      /**
       * String value which will be shown as a hint if the field is all of:
       * unset, unfocused and enabled. Set to null to not show a placeholder
       * text.
       */
      placeholder: {
        check: "String",
        nullable: true,
        apply: "_applyPlaceholder"
      },
      // overridden
      appearance: {
        refine: true,
        init: "datefield"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 120
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    statics: {
      __dateFormat__P_412_0: null,
      __formatter__P_412_1: null,

      /**
       * Get the shared default date formatter
       *
       * @return {qx.util.format.DateFormat} The shared date formatter
       */
      getDefaultDateFormatter: function getDefaultDateFormatter() {
        var format = qx.locale.Date.getDateFormat("medium").toString();

        if (format == this.__dateFormat__P_412_0) {
          return this.__formatter__P_412_1;
        }

        if (this.__formatter__P_412_1) {
          this.__formatter__P_412_1.dispose();
        }

        this.__formatter__P_412_1 = new qx.util.format.DateFormat(format, qx.locale.Manager.getInstance().getLocale());
        this.__dateFormat__P_412_0 = format;
        return this.__formatter__P_412_1;
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __localeListenerId__P_412_2: null,

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        invalid: true
      },

      /*
      ---------------------------------------------------------------------------
        PROTECTED METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the default date format which is returned by
       * {@link #getDefaultDateFormatter}. You can override this method to
       * define your own default format.
       */
      _setDefaultDateFormat: function _setDefaultDateFormat() {
        this.setDateFormat(qx.ui.form.DateField.getDefaultDateFormatter());
      },

      /**
       * Checks for "qx.dynlocale" and adds a listener to the locale changes.
       * On every change, {@link #_setDefaultDateFormat} is called to reinitialize
       * the format. You can easily override that method to prevent that behavior.
       */
      _addLocaleChangeListener: function _addLocaleChangeListener() {
        // listen for locale changes
        {
          this.__localeListenerId__P_412_2 = qx.locale.Manager.getInstance().addListener("changeLocale", function () {
            this._setDefaultDateFormat();
          }, this);
        }
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC METHODS
      ---------------------------------------------------------------------------
      */

      /**
      * This method sets the date, which will be formatted according to
      * #dateFormat to the date field. It will also select the date in the
      * calendar popup.
      *
      * @param value {Date} The date to set.
       */
      setValue: function setValue(value) {
        // set the date to the textfield
        var textField = this.getChildControl("textfield");
        textField.setValue(this.getDateFormat().format(value)); // set the date in the datechooser

        var dateChooser = this.getChildControl("list");
        dateChooser.setValue(value);
      },

      /**
       * Returns the current set date, parsed from the input-field
       * corresponding to the {@link #dateFormat}.
       * If the given text could not be parsed, <code>null</code> will be returned.
       *
       * @return {Date} The currently set date.
       */
      getValue: function getValue() {
        // get the value of the textfield
        var textfieldValue = this.getChildControl("textfield").getValue(); // return the parsed date

        try {
          if (textfieldValue == null || textfieldValue.length == 0) {
            return null;
          }

          return this.getDateFormat().parse(textfieldValue);
        } catch (ex) {
          return null;
        }
      },

      /**
       * Resets the DateField. The textfield will be empty and the datechooser
       * will also have no selection.
       */
      resetValue: function resetValue() {
        // set the date to the textfield
        var textField = this.getChildControl("textfield");
        textField.setValue(""); // set the date in the datechooser

        var dateChooser = this.getChildControl("list");
        dateChooser.setValue(null);
      },

      /*
      ---------------------------------------------------------------------------
        LIST STUFF
      ---------------------------------------------------------------------------
      */

      /**
       * Shows the date chooser popup.
       */
      open: function open() {
        var popup = this.getChildControl("popup");
        popup.placeToWidget(this, true);
        popup.show();
      },

      /**
       * Hides the date chooser popup.
       */
      close: function close() {
        this.getChildControl("popup").hide();
      },

      /**
       * Toggles the date chooser popup visibility.
       */
      toggle: function toggle() {
        var isListOpen = this.getChildControl("popup").isVisible();

        if (isListOpen) {
          this.close();
        } else {
          this.open();
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY METHODS
      ---------------------------------------------------------------------------
      */
      // property apply routine
      _applyDateFormat: function _applyDateFormat(value, old) {
        // if old is undefined or null do nothing
        if (!old) {
          return;
        } // get the date with the old date format


        try {
          var textfield = this.getChildControl("textfield");
          var dateStr = textfield.getValue();

          if (dateStr != null) {
            var currentDate = old.parse(dateStr);
            textfield.setValue(value.format(currentDate));
          }
        } catch (ex) {// do nothing if the former date could not be parsed
        }
      },
      // property apply routine
      _applyPlaceholder: function _applyPlaceholder(value, old) {
        this.getChildControl("textfield").setPlaceholder(value);
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "textfield":
            control = new qx.ui.form.TextField();
            control.setFocusable(false);
            control.addState("inner");
            control.addListener("changeValue", this._onTextFieldChangeValue, this);
            control.addListener("blur", this.close, this);

            this._add(control, {
              flex: 1
            });

            break;

          case "button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.setKeepActive(true);
            control.addState("inner");
            control.addListener("execute", this.toggle, this);

            this._add(control);

            break;

          case "list":
            control = new qx.ui.control.DateChooser();
            control.setFocusable(false);
            control.setKeepFocus(true);
            control.addListener("execute", this._onChangeDate, this);
            break;

          case "popup":
            control = new qx.ui.popup.Popup(new qx.ui.layout.VBox());
            control.setAutoHide(false);
            control.add(this.getChildControl("list"));
            control.addListener("pointerup", this._onChangeDate, this);
            control.addListener("changeVisibility", this._onPopupChangeVisibility, this);
            break;
        }

        return control || qx.ui.form.DateField.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Handler method which handles the tap on the calender popup.
       *
       * @param e {qx.event.type.Pointer} The pointer event.
       */
      _onChangeDate: function _onChangeDate(e) {
        var textField = this.getChildControl("textfield");
        var selectedDate = this.getChildControl("list").getValue();
        textField.setValue(this.getDateFormat().format(selectedDate));
        this.close();
      },

      /**
       * Toggles the popup's visibility.
       *
       * @param e {qx.event.type.Pointer} Pointer tap event
       */
      _onTap: function _onTap(e) {
        this.close();
      },

      /**
       * Handler for the blur event of the current widget.
       *
       * @param e {qx.event.type.Focus} The blur event.
       */
      _onBlur: function _onBlur(e) {
        this.close();
      },

      /**
       * Handler method which handles the key press. It forwards all key event
       * to the opened date chooser except the escape key event. Escape closes
       * the popup.
       * If the list is cloned, all key events will not be processed further.
       *
       * @param e {qx.event.type.KeySequence} Keypress event
       */
      _onKeyPress: function _onKeyPress(e) {
        // get the key identifier
        var iden = e.getKeyIdentifier();

        if (iden == "Down" && e.isAltPressed()) {
          this.toggle();
          e.stopPropagation();
          return;
        } // if the popup is closed, ignore all


        var popup = this.getChildControl("popup");

        if (popup.getVisibility() == "hidden") {
          return;
        } // hide the list always on escape


        if (iden == "Escape") {
          this.close();
          e.stopPropagation();
          return;
        } // Stop navigation keys when popup is open


        if (iden === "Left" || iden === "Right" || iden === "Down" || iden === "Up") {
          e.preventDefault();
        } // forward the rest of the events to the date chooser


        this.getChildControl("list").handleKeyPress(e);
      },

      /**
       * Redirects changeVisibility event from the list to this widget.
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onPopupChangeVisibility: function _onPopupChangeVisibility(e) {
        e.getData() == "visible" ? this.addState("popupOpen") : this.removeState("popupOpen"); // Synchronize the chooser with the current value on every
        // opening of the popup. This is needed when the value has been
        // modified and not saved yet (e.g. no blur)

        var popup = this.getChildControl("popup");

        if (popup.isVisible()) {
          var chooser = this.getChildControl("list");
          var date = this.getValue();
          chooser.setValue(date);
        }
      },

      /**
       * Reacts on value changes of the text field and syncs the
       * value to the combobox.
       *
       * @param e {qx.event.type.Data} Change event
       */
      _onTextFieldChangeValue: function _onTextFieldChangeValue(e) {
        // Apply to popup
        var date = this.getValue();

        if (date != null) {
          var list = this.getChildControl("list");
          list.setValue(date);
        } // Fire event


        this.fireDataEvent("changeValue", this.getValue());
      },

      /**
       * Checks if the textfield of the DateField is empty.
       *
       * @return {Boolean} True, if the textfield of the DateField is empty.
       */
      isEmpty: function isEmpty() {
        var value = this.getChildControl("textfield").getValue();
        return value == null || value == "";
      },
      // overridden
      focus: function focus() {
        qx.ui.form.DateField.prototype.focus.base.call(this);
        this.getChildControl("textfield").getFocusElement().focus();
      }
    },
    destruct: function destruct() {
      // listen for locale changes
      {
        if (this.__localeListenerId__P_412_2) {
          qx.locale.Manager.getInstance().removeListenerById(this.__localeListenerId__P_412_2);
        }
      }
    }
  });
  qx.ui.form.DateField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.validation.Manager": {},
      "qx.ui.form.Resetter": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The form object is responsible for managing form items. For that, it takes
   * advantage of two existing qooxdoo classes.
   * The {@link qx.ui.form.Resetter} is used for resetting and the
   * {@link qx.ui.form.validation.Manager} is used for all validation purposes.
   *
   * The view code can be found in the used renderer ({@link qx.ui.form.renderer}).
   */
  qx.Class.define("qx.ui.form.Form", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__groups__P_413_0 = [];
      this._buttons = [];
      this._buttonOptions = [];
      this._validationManager = this._createValidationManager();
      this._resetter = this._createResetter();
    },
    events: {
      /** Fired as soon as something changes in the form.*/
      "change": "qx.event.type.Event"
    },
    members: {
      __groups__P_413_0: null,
      _validationManager: null,
      _groupCounter: 0,
      _buttons: null,
      _buttonOptions: null,
      _resetter: null,

      /*
      ---------------------------------------------------------------------------
         ADD
      ---------------------------------------------------------------------------
      */

      /**
       * Adds a form item to the form including its internal
       * {@link qx.ui.form.validation.Manager} and {@link qx.ui.form.Resetter}.
       *
       * *Hint:* The order of all add calls represent the order in the layout.
       *
       * @param item {qx.ui.form.IForm} A supported form item.
       * @param label {String} The string, which should be used as label.
       * @param validator {Function | qx.ui.form.validation.AsyncValidator ? null}
       *   The validator which is used by the validation
       *   {@link qx.ui.form.validation.Manager}.
       * @param name {String?null} The name which is used by the data binding
       *   controller {@link qx.data.controller.Form}.
       * @param validatorContext {var?null} The context of the validator.
       * @param options {Map?null} An additional map containing custom data which
       *   will be available in your form renderer specific to the added item.
       */
      add: function add(item, label, validator, name, validatorContext, options) {
        if (this.__isFirstAdd__P_413_1()) {
          this.__groups__P_413_0.push({
            title: null,
            items: [],
            labels: [],
            names: [],
            options: [],
            headerOptions: {}
          });
        } // save the given arguments


        this.__groups__P_413_0[this._groupCounter].items.push(item);

        this.__groups__P_413_0[this._groupCounter].labels.push(label);

        this.__groups__P_413_0[this._groupCounter].options.push(options); // if no name is given, use the label without not working character


        if (name == null) {
          name = label.replace(/\s+|&|-|\+|\*|\/|\||!|\.|,|:|\?|;|~|%|\{|\}|\(|\)|\[|\]|<|>|=|\^|@|\\/g, "");
        }

        this.__groups__P_413_0[this._groupCounter].names.push(name); // add the item to the validation manager


        this._validationManager.add(item, validator, validatorContext); // add the item to the reset manager


        this._resetter.add(item); // fire the change event


        this.fireEvent("change");
      },

      /**
       * Adds a group header to the form.
       *
       * *Hint:* The order of all add calls represent the order in the layout.
       *
       * @param title {String} The title of the group header.
       * @param options {Map?null} A special set of custom data which will be
       *   given to the renderer.
       */
      addGroupHeader: function addGroupHeader(title, options) {
        if (!this.__isFirstAdd__P_413_1()) {
          this._groupCounter++;
        }

        this.__groups__P_413_0.push({
          title: title,
          items: [],
          labels: [],
          names: [],
          options: [],
          headerOptions: options
        }); // fire the change event


        this.fireEvent("change");
      },

      /**
       * Adds a button to the form.
       *
       * *Hint:* The order of all add calls represent the order in the layout.
       *
       * @param button {qx.ui.form.Button} The button to add.
       * @param options {Map?null} An additional map containing custom data which
       *   will be available in your form renderer specific to the added button.
       */
      addButton: function addButton(button, options) {
        this._buttons.push(button);

        this._buttonOptions.push(options || null); // fire the change event


        this.fireEvent("change");
      },

      /**
       * Returns whether something has already been added.
       *
       * @return {Boolean} true, if nothing has been added jet.
       */
      __isFirstAdd__P_413_1: function __isFirstAdd__P_413_1() {
        return this.__groups__P_413_0.length === 0;
      },

      /*
      ---------------------------------------------------------------------------
         REMOVE
      ---------------------------------------------------------------------------
      */

      /**
       * Removes the given item from the form.
       *
       * @param item {qx.ui.form.IForm} A supported form item.
       * @return {Boolean} <code>true</code>, if the item could be removed.
       */
      remove: function remove(item) {
        for (var i = 0; i < this.__groups__P_413_0.length; i++) {
          var group = this.__groups__P_413_0[i];

          for (var j = 0; j < group.items.length; j++) {
            var storedItem = group.items[j];

            if (storedItem === item) {
              // remove all stored data
              group.items.splice(j, 1);
              group.labels.splice(j, 1);
              group.names.splice(j, 1);
              group.options.splice(j, 1); // remove the item to the validation manager

              this._validationManager.remove(item); // remove the item to the reset manager


              this._resetter.remove(item); // fire the change event


              this.fireEvent("change");
              return true;
            }
          }
        }

        return false;
      },

      /**
       * Removes the given group header from the form. All items in the group will be moved to
       * another group (usually the previous group). If there is more than one group with
       * the same title, only the first group will be removed.
       *
       * @param title {String} The title.
       * @return {Boolean} <code>true</code>, if the header could be removed.
       */
      removeGroupHeader: function removeGroupHeader(title) {
        for (var i = 0; i < this.__groups__P_413_0.length; i++) {
          var group = this.__groups__P_413_0[i];

          if (group.title === title) {
            var targetGroup; // if it's the first group

            if (i == 0) {
              // if it's the only group
              if (this.__groups__P_413_0.length == 1) {
                // remove the title and the header options
                group.title = null;
                group.headerOptions = {}; // fire the change event

                this.fireEvent("change");
                return true;
              } else {
                // add to the next
                targetGroup = this.__groups__P_413_0[i + 1];
              }
            } else {
              // add to the previous group
              targetGroup = this.__groups__P_413_0[i - 1];
            } // copy the data over


            targetGroup.items = targetGroup.items.concat(group.items);
            targetGroup.labels = targetGroup.labels.concat(group.labels);
            targetGroup.names = targetGroup.names.concat(group.names);
            targetGroup.options = targetGroup.options.concat(group.options); // delete the group

            this.__groups__P_413_0.splice(i, 1);

            this._groupCounter--; // fire the change event

            this.fireEvent("change");
            return true;
          }
        }

        return false;
      },

      /**
       * Removes the given button from the form.
       *
       * @param button {qx.ui.form.Button} The button to remove.
       * @return {Boolean} <code>true</code>, if the button could be removed.
       */
      removeButton: function removeButton(button) {
        for (var i = 0; i < this._buttons.length; i++) {
          var storedButton = this._buttons[i];

          if (storedButton === button) {
            this._buttons.splice(i, 1);

            this._buttonOptions.splice(i, 1); // fire the change event


            this.fireEvent("change");
            return true;
          }
        }

        return false;
      },

      /**
       * Returns all added items as a map.
       *
       * @return {Map} A map containing for every item an entry with its name.
       */
      getItems: function getItems() {
        var items = {}; // go threw all groups

        for (var i = 0; i < this.__groups__P_413_0.length; i++) {
          var group = this.__groups__P_413_0[i]; // get all items

          for (var j = 0; j < group.names.length; j++) {
            var name = group.names[j];
            items[name] = group.items[j];
          }
        }

        return items;
      },

      /**
       * Return an item by name.
       *
       * @param name {string} Item name.
       * @return {qx.ui.form.IForm|null} The form item or null.
       */
      getItem: function getItem(name) {
        for (var i = 0; i < this.__groups__P_413_0.length; i++) {
          var group = this.__groups__P_413_0[i];

          for (var j = 0; j < group.names.length; j++) {
            if (group.names[j] === name) {
              return group.items[j];
            }
          }
        }

        return null;
      },

      /*
      ---------------------------------------------------------------------------
         RESET SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Resets the form. This means reseting all form items and the validation.
       */
      reset: function reset() {
        this._resetter.reset();

        this._validationManager.reset();
      },

      /**
       * Redefines the values used for resetting. It calls
       * {@link qx.ui.form.Resetter#redefine} to get that.
       */
      redefineResetter: function redefineResetter() {
        this._resetter.redefine();
      },

      /**
       * Redefines the value used for resetting of the given item. It calls
       * {@link qx.ui.form.Resetter#redefineItem} to get that.
       *
       * @param item {qx.ui.core.Widget} The item to redefine.
       */
      redefineResetterItem: function redefineResetterItem(item) {
        this._resetter.redefineItem(item);
      },

      /*
      ---------------------------------------------------------------------------
         VALIDATION
      ---------------------------------------------------------------------------
      */

      /**
       * Validates the form using the
       * {@link qx.ui.form.validation.Manager#validate} method.
       *
       * @return {Boolean | null} The validation result.
       */
      validate: function validate() {
        return this._validationManager.validate();
      },

      /**
       * Returns the internally used validation manager. If you want to do some
       * enhanced validation tasks, you need to use the validation manager.
       *
       * @return {qx.ui.form.validation.Manager} The used manager.
       */
      getValidationManager: function getValidationManager() {
        return this._validationManager;
      },

      /*
      ---------------------------------------------------------------------------
         RENDERER SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Accessor method for the renderer which returns all added items in a
       * array containing a map of all items:
       * {title: title, items: [], labels: [], names: []}
       *
       * @return {Array} An array containing all necessary data for the renderer.
       * @internal
       */
      getGroups: function getGroups() {
        return this.__groups__P_413_0;
      },

      /**
       * Accessor method for the renderer which returns all added buttons in an
       * array.
       * @return {Array} An array containing all added buttons.
       * @internal
       */
      getButtons: function getButtons() {
        return this._buttons;
      },

      /**
       * Accessor method for the renderer which returns all added options for
       * the buttons in an array.
       * @return {Array} An array containing all added options for the buttons.
       * @internal
       */
      getButtonOptions: function getButtonOptions() {
        return this._buttonOptions;
      },

      /*
      ---------------------------------------------------------------------------
         INTERNAL
      ---------------------------------------------------------------------------
      */

      /**
       * Creates and returns the used validation manager.
       *
       * @return {qx.ui.form.validation.Manager} The validation manager.
       */
      _createValidationManager: function _createValidationManager() {
        return new qx.ui.form.validation.Manager();
      },

      /**
       * Creates and returns the used resetter.
       *
       * @return {qx.ui.form.Resetter} the resetter class.
       */
      _createResetter: function _createResetter() {
        return new qx.ui.form.Resetter();
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      // holding references to widgets --> must set to null
      this.__groups__P_413_0 = this._buttons = this._buttonOptions = null;

      this._validationManager.dispose();

      this._resetter.dispose();
    }
  });
  qx.ui.form.Form.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.lang.Type": {},
      "qx.lang.Object": {},
      "qx.core.ValidationError": {},
      "qx.type.BaseError": {},
      "qx.ui.form.validation.AsyncValidator": {},
      "qx.ui.form.IForm": {},
      "qx.ui.core.ISingleSelection": {},
      "qx.data.controller.ISelection": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This validation manager is responsible for validation of forms.
   *
   * @ignore(qx.ui.tooltip)
   * @ignore(qx.ui.tooltip.Manager.*)
   */
  qx.Class.define("qx.ui.form.validation.Manager", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this); // storage for all form items

      this.__formItems__P_432_0 = []; // storage for all results of async validation calls

      this.__asyncResults__P_432_1 = {}; // set the default required field message

      this.setRequiredFieldMessage(qx.locale.Manager.tr("This field is required"));
    },
    events: {
      /**
       * Change event for the valid state.
       */
      "changeValid": "qx.event.type.Data",

      /**
       * Signals that the validation is done. This is not needed on synchronous
       * validation (validation is done right after the call) but very important
       * in the case an asynchronous validator will be used.
       */
      "complete": "qx.event.type.Event"
    },
    properties: {
      /**
       * The validator of the form itself. You can set a function (for
       * synchronous validation) or a {@link qx.ui.form.validation.AsyncValidator}.
       * In both cases, the function can have all added form items as first
       * argument and the manager as a second argument. The manager should be used
       * to set the {@link #invalidMessage}.
       *
       * Keep in mind that the validator is optional if you don't need the
       * validation in the context of the whole form.
       * @type {Function | AsyncValidator}
       */
      validator: {
        check: "value instanceof Function || qx.Class.isSubClassOf(value.constructor, qx.ui.form.validation.AsyncValidator)",
        init: null,
        nullable: true
      },

      /**
       * The invalid message should store the message why the form validation
       * failed. It will be added to the array returned by
       * {@link #getInvalidMessages}.
       */
      invalidMessage: {
        check: "String",
        init: ""
      },

      /**
       * This message will be shown if a required field is empty and no individual
       * {@link qx.ui.form.MForm#requiredInvalidMessage} is given.
       */
      requiredFieldMessage: {
        check: "String",
        init: ""
      },

      /**
       * The context for the form validation.
       */
      context: {
        nullable: true
      }
    },
    members: {
      __formItems__P_432_0: null,
      __valid__P_432_2: null,
      __asyncResults__P_432_1: null,
      __syncValid__P_432_3: null,

      /**
       * Add a form item to the validation manager.
       *
       * The form item has to implement at least two interfaces:
       * <ol>
       *   <li>The {@link qx.ui.form.IForm} Interface</li>
       *   <li>One of the following interfaces:
       *     <ul>
       *       <li>{@link qx.ui.form.IBooleanForm}</li>
       *       <li>{@link qx.ui.form.IColorForm}</li>
       *       <li>{@link qx.ui.form.IDateForm}</li>
       *       <li>{@link qx.ui.form.INumberForm}</li>
       *       <li>{@link qx.ui.form.IStringForm}</li>
       *     </ul>
       *   </li>
       * </ol>
       * The validator can be a synchronous or asynchronous validator. In
       * both cases the validator can either returns a boolean or fire an
       * {@link qx.core.ValidationError}. For synchronous validation, a plain
       * JavaScript function should be used. For all asynchronous validations,
       * a {@link qx.ui.form.validation.AsyncValidator} is needed to wrap the
       * plain function.
       *
       * @param formItem {qx.ui.core.Widget} The form item to add.
       * @param validator {Function | qx.ui.form.validation.AsyncValidator}
       *   The validator.
       * @param context {var?null} The context of the validator.
       */
      add: function add(formItem, validator, context) {
        // check for the form API
        if (!this.__supportsInvalid__P_432_4(formItem)) {
          throw new Error("Added widget not supported.");
        } // check for the data type


        if (this.__supportsSingleSelection__P_432_5(formItem) && !formItem.getValue) {
          // check for a validator
          if (validator != null) {
            throw new Error("Widgets supporting selection can only be validated in the form validator");
          }
        }

        var dataEntry = {
          item: formItem,
          validator: validator,
          valid: null,
          context: context
        };

        this.__formItems__P_432_0.push(dataEntry);
      },

      /**
       * Remove a form item from the validation manager.
       *
       * @param formItem {qx.ui.core.Widget} The form item to remove.
       * @return {qx.ui.core.Widget?null} The removed form item or
       *  <code>null</code> if the item could not be found.
       */
      remove: function remove(formItem) {
        var items = this.__formItems__P_432_0;

        for (var i = 0, len = items.length; i < len; i++) {
          if (formItem === items[i].item) {
            items.splice(i, 1);
            return formItem;
          }
        }

        return null;
      },

      /**
       * Returns registered form items from the validation manager.
       *
       * @return {Array} The form items which will be validated.
       */
      getItems: function getItems() {
        var items = [];

        for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
          items.push(this.__formItems__P_432_0[i].item);
        }

        ;
        return items;
      },

      /**
       * Invokes the validation. If only synchronous validators are set, the
       * result of the whole validation is available at the end of the method
       * and can be returned. If an asynchronous validator is set, the result
       * is still unknown at the end of this method so nothing will be returned.
       * In both cases, a {@link #complete} event will be fired if the validation
       * has ended. The result of the validation can then be accessed with the
       * {@link #getValid} method.
       *
       * @return {Boolean|undefined} The validation result, if available.
       */
      validate: function validate() {
        var valid = true;
        this.__syncValid__P_432_3 = true; // collaboration of all synchronous validations

        var items = []; // check all validators for the added form items

        for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
          var formItem = this.__formItems__P_432_0[i].item;
          var validator = this.__formItems__P_432_0[i].validator; // store the items in case of form validation

          items.push(formItem); // ignore all form items without a validator

          if (validator == null) {
            // check for the required property
            var validatorResult = this._validateRequired(formItem);

            valid = valid && validatorResult;
            this.__syncValid__P_432_3 = validatorResult && this.__syncValid__P_432_3;
            continue;
          }

          var validatorResult = this._validateItem(this.__formItems__P_432_0[i], formItem.getValue()); // keep that order to ensure that null is returned on async cases


          valid = validatorResult && valid;

          if (validatorResult != null) {
            this.__syncValid__P_432_3 = validatorResult && this.__syncValid__P_432_3;
          }
        } // check the form validator (be sure to invoke it even if the form
        // items are already false, so keep the order!)


        var formValid = this.__validateForm__P_432_6(items);

        if (qx.lang.Type.isBoolean(formValid)) {
          this.__syncValid__P_432_3 = formValid && this.__syncValid__P_432_3;
        }

        valid = formValid && valid;

        this._setValid(valid);

        if (qx.lang.Object.isEmpty(this.__asyncResults__P_432_1)) {
          this.fireEvent("complete");
        }

        return valid;
      },

      /**
       * Checks if the form item is required. If so, the value is checked
       * and the result will be returned. If the form item is not required, true
       * will be returned.
       *
       * @param formItem {qx.ui.core.Widget} The form item to check.
       * @return {var} Validation result
       */
      _validateRequired: function _validateRequired(formItem) {
        if (formItem.getRequired()) {
          var validatorResult; // if its a widget supporting the selection

          if (this.__supportsSingleSelection__P_432_5(formItem)) {
            validatorResult = !!formItem.getSelection()[0];
          } else if (this.__supportsDataBindingSelection__P_432_7(formItem)) {
            validatorResult = formItem.getSelection().getLength() > 0;
          } else {
            var value = formItem.getValue();
            validatorResult = !!value || value === 0;
          }

          formItem.setValid(validatorResult);
          var individualMessage = formItem.getRequiredInvalidMessage();
          var message = individualMessage ? individualMessage : this.getRequiredFieldMessage();
          formItem.setInvalidMessage(message);
          return validatorResult;
        }

        return true;
      },

      /**
       * Validates a form item. This method handles the differences of
       * synchronous and asynchronous validation and returns the result of the
       * validation if possible (synchronous cases). If the validation is
       * asynchronous, null will be returned.
       *
       * @param dataEntry {Object} The map stored in {@link #add}
       * @param value {var} The currently set value
       * @return {Boolean|null} Validation result or <code>null</code> for async
       * validation
       */
      _validateItem: function _validateItem(dataEntry, value) {
        var formItem = dataEntry.item;
        var context = dataEntry.context;
        var validator = dataEntry.validator; // check for asynchronous validation

        if (this.__isAsyncValidator__P_432_8(validator)) {
          // used to check if all async validations are done
          this.__asyncResults__P_432_1[formItem.toHashCode()] = null;
          validator.validate(formItem, formItem.getValue(), this, context);
          return null;
        }

        var validatorResult = null;

        try {
          var validatorResult = validator.call(context || this, value, formItem);

          if (validatorResult === undefined) {
            validatorResult = true;
          }
        } catch (e) {
          if (e instanceof qx.core.ValidationError) {
            validatorResult = false;

            if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {
              var invalidMessage = e.message;
            } else {
              var invalidMessage = e.getComment();
            }

            formItem.setInvalidMessage(invalidMessage);
          } else {
            throw e;
          }
        }

        formItem.setValid(validatorResult);
        dataEntry.valid = validatorResult;
        return validatorResult;
      },

      /**
       * Validates the form. It checks for asynchronous validation and handles
       * the differences to synchronous validation. If no form validator is given,
       * true will be returned. If a synchronous validator is given, the
       * validation result will be returned. In asynchronous cases, null will be
       * returned cause the result is not available.
       *
       * @param items {qx.ui.core.Widget[]} An array of all form items.
       * @return {Boolean|null} description
       */
      __validateForm__P_432_6: function __validateForm__P_432_6(items) {
        var formValidator = this.getValidator();
        var context = this.getContext() || this;

        if (formValidator == null) {
          return true;
        } // reset the invalidMessage


        this.setInvalidMessage("");

        if (this.__isAsyncValidator__P_432_8(formValidator)) {
          this.__asyncResults__P_432_1[this.toHashCode()] = null;
          formValidator.validateForm(items, this, context);
          return null;
        }

        try {
          var formValid = formValidator.call(context, items, this);

          if (formValid === undefined) {
            formValid = true;
          }
        } catch (e) {
          if (e instanceof qx.core.ValidationError) {
            formValid = false;

            if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {
              var invalidMessage = e.message;
            } else {
              var invalidMessage = e.getComment();
            }

            this.setInvalidMessage(invalidMessage);
          } else {
            throw e;
          }
        }

        return formValid;
      },

      /**
       * Helper function which checks, if the given validator is synchronous
       * or asynchronous.
       *
       * @param validator {Function|qx.ui.form.validation.AsyncValidator}
       *   The validator to check.
       * @return {Boolean} True, if the given validator is asynchronous.
       */
      __isAsyncValidator__P_432_8: function __isAsyncValidator__P_432_8(validator) {
        var async = false;

        if (!qx.lang.Type.isFunction(validator)) {
          async = qx.Class.isSubClassOf(validator.constructor, qx.ui.form.validation.AsyncValidator);
        }

        return async;
      },

      /**
       * Returns true, if the given item implements the {@link qx.ui.form.IForm}
       * interface.
       *
       * @param formItem {qx.core.Object} The item to check.
       * @return {Boolean} true, if the given item implements the
       *   necessary interface.
       */
      __supportsInvalid__P_432_4: function __supportsInvalid__P_432_4(formItem) {
        var clazz = formItem.constructor;
        return qx.Class.hasInterface(clazz, qx.ui.form.IForm);
      },

      /**
       * Returns true, if the given item implements the
       * {@link qx.ui.core.ISingleSelection} interface.
       *
       * @param formItem {qx.core.Object} The item to check.
       * @return {Boolean} true, if the given item implements the
       *   necessary interface.
       */
      __supportsSingleSelection__P_432_5: function __supportsSingleSelection__P_432_5(formItem) {
        var clazz = formItem.constructor;
        return qx.Class.hasInterface(clazz, qx.ui.core.ISingleSelection);
      },

      /**
       * Returns true, if the given item implements the
       * {@link qx.data.controller.ISelection} interface.
       *
       * @param formItem {qx.core.Object} The item to check.
       * @return {Boolean} true, if the given item implements the
       *   necessary interface.
       */
      __supportsDataBindingSelection__P_432_7: function __supportsDataBindingSelection__P_432_7(formItem) {
        var clazz = formItem.constructor;
        return qx.Class.hasInterface(clazz, qx.data.controller.ISelection);
      },

      /**
       * Sets the valid state of the manager. It generates the event if
       * necessary and stores the new value.
       *
       * @param value {Boolean|null} The new valid state of the manager.
       */
      _setValid: function _setValid(value) {
        this._showToolTip(value);

        var oldValue = this.__valid__P_432_2;
        this.__valid__P_432_2 = value; // check for the change event

        if (oldValue != value) {
          this.fireDataEvent("changeValid", value, oldValue);
        }
      },

      /**
       * Responsible for showing a tooltip in case the validation is done for
       * widgets based on qx.ui.core.Widget.
       * @param valid {Boolean} <code>false</code>, if the tooltip should be shown
       */
      _showToolTip: function _showToolTip(valid) {
        // ignore if we don't have a tooltip manager e.g. mobile apps
        if (!qx.ui.tooltip || !qx.ui.tooltip.Manager) {
          return;
        }

        var tooltip = qx.ui.tooltip.Manager.getInstance().getSharedErrorTooltip();

        if (!valid) {
          var firstInvalid;

          for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
            var item = this.__formItems__P_432_0[i].item;

            if (!item.isValid()) {
              firstInvalid = item; // only for desktop widgets

              if (!item.getContentLocation) {
                return;
              } // only consider items on the screen


              if (item.isSeeable() === false) {
                continue;
              }

              tooltip.setLabel(item.getInvalidMessage());

              if (tooltip.getPlaceMethod() == "mouse") {
                var location = item.getContentLocation();
                var top = location.top - tooltip.getOffsetTop();
                tooltip.placeToPoint({
                  left: location.right,
                  top: top
                });
              } else {
                tooltip.placeToWidget(item);
              }

              tooltip.show();
              return;
            }
          }
        } else {
          tooltip.exclude();
        }
      },

      /**
       * Returns the valid state of the manager.
       *
       * @return {Boolean|null} The valid state of the manager.
       */
      getValid: function getValid() {
        return this.__valid__P_432_2;
      },

      /**
       * Returns the valid state of the manager.
       *
       * @return {Boolean|null} The valid state of the manager.
       */
      isValid: function isValid() {
        return this.getValid();
      },

      /**
       * Returns an array of all invalid messages of the invalid form items and
       * the form manager itself.
       *
       * @return {String[]} All invalid messages.
       */
      getInvalidMessages: function getInvalidMessages() {
        var messages = []; // combine the messages of all form items

        for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
          var formItem = this.__formItems__P_432_0[i].item;

          if (!formItem.getValid()) {
            messages.push(formItem.getInvalidMessage());
          }
        } // add the forms fail message


        if (this.getInvalidMessage() != "") {
          messages.push(this.getInvalidMessage());
        }

        return messages;
      },

      /**
       * Selects invalid form items
       *
       * @return {Array} invalid form items
       */
      getInvalidFormItems: function getInvalidFormItems() {
        var res = [];

        for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
          var formItem = this.__formItems__P_432_0[i].item;

          if (!formItem.getValid()) {
            res.push(formItem);
          }
        }

        return res;
      },

      /**
       * Resets the validator.
       */
      reset: function reset() {
        // reset all form items
        for (var i = 0; i < this.__formItems__P_432_0.length; i++) {
          var dataEntry = this.__formItems__P_432_0[i]; // set the field to valid

          dataEntry.item.setValid(true);
        } // set the manager to its initial valid value


        this.__valid__P_432_2 = null;

        this._showToolTip(true);
      },

      /**
       * Internal helper method to set the given item to valid for asynchronous
       * validation calls. This indirection is used to determinate if the
       * validation process is completed or if other asynchronous validators
       * are still validating. {@link #__checkValidationComplete} checks if the
       * validation is complete and will be called at the end of this method.
       *
       * @param formItem {qx.ui.core.Widget} The form item to set the valid state.
       * @param valid {Boolean} The valid state for the form item.
       *
       * @internal
       */
      setItemValid: function setItemValid(formItem, valid) {
        // store the result
        this.__asyncResults__P_432_1[formItem.toHashCode()] = valid;
        formItem.setValid(valid);

        this.__checkValidationComplete__P_432_9();
      },

      /**
       * Internal helper method to set the form manager to valid for asynchronous
       * validation calls. This indirection is used to determinate if the
       * validation process is completed or if other asynchronous validators
       * are still validating. {@link #__checkValidationComplete} checks if the
       * validation is complete and will be called at the end of this method.
       *
       * @param valid {Boolean} The valid state for the form manager.
       *
       * @internal
       */
      setFormValid: function setFormValid(valid) {
        this.__asyncResults__P_432_1[this.toHashCode()] = valid;

        this.__checkValidationComplete__P_432_9();
      },

      /**
       * Checks if all asynchronous validators have validated so the result
       * is final and the {@link #complete} event can be fired. If that's not
       * the case, nothing will happen in the method.
       */
      __checkValidationComplete__P_432_9: function __checkValidationComplete__P_432_9() {
        var valid = this.__syncValid__P_432_3; // check if all async validators are done

        for (var hash in this.__asyncResults__P_432_1) {
          var currentResult = this.__asyncResults__P_432_1[hash];
          valid = currentResult && valid; // the validation is not done so just do nothing

          if (currentResult == null) {
            return;
          }
        } // set the actual valid state of the manager


        this._setValid(valid); // reset the results


        this.__asyncResults__P_432_1 = {}; // fire the complete event (no entry in the results with null)

        this.fireEvent("complete");
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._showToolTip(true);

      this.__formItems__P_432_0 = null;
    }
  });
  qx.ui.form.validation.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
       2017 Martijn Evers, The Netherlands
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Martijn Evers (mever)
  
  ************************************************************************ */

  /**
   * The resetter is responsible for managing a set of fields and resetting these
   * fields on a {@link #reset} call. It can handle all form field implementing IField.
   */
  qx.Class.define("qx.ui.form.Resetter", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__items__P_421_0 = [];
    },
    members: {
      __items__P_421_0: null,

      /**
       * Adding a field to the resetter will get its current value and store
       * it for resetting.
       *
       * @param field {qx.ui.form.IField} The field which should be added.
       * @throws {TypeError} When given argument is not a field.
       */
      add: function add(field) {
        this.__typeCheck__P_421_1(field);

        this.__items__P_421_0.push({
          item: field,
          init: field.getValue()
        });
      },

      /**
       * Removes a field from the resetter.
       *
       * @param field {qx.ui.form.IField} The field which should be removed.
       * @throws {TypeError} When given argument is not a field.
       * @return {Boolean} <code>true</code>, if the field has been removed.
       */
      remove: function remove(field) {
        this.__typeCheck__P_421_1(field);

        for (var i = 0; i < this.__items__P_421_0.length; i++) {
          var storedItem = this.__items__P_421_0[i];

          if (storedItem.item === field) {
            this.__items__P_421_0.splice(i, 1);

            return true;
          }
        }

        return false;
      },

      /**
       * Resets all added fields to their initial value. The initial value
       * is the value in the widget during the {@link #add}.
       *
       * @return {null|Error} Returns an error when some fields could not be reset.
       */
      reset: function reset() {
        var dataEntry,
            e,
            errors = [];

        for (var i = 0; i < this.__items__P_421_0.length; i++) {
          dataEntry = this.__items__P_421_0[i];
          e = dataEntry.item.setValue(dataEntry.init);

          if (e && e instanceof Error) {
            errors.push(e);
          }
        }

        if (errors.length) {
          return new Error(errors.join(', '));
        } else {
          return null;
        }
      },

      /**
       * Resets a single given field. The field has to be added to the resetter
       * instance before. Otherwise, an error is thrown.
       *
       * @param field {qx.ui.form.IField} The field, which should be reset.
       * @throws {TypeError} When given argument is not a field.
       * @return {null|Error} Returns an error when the field value could not be set.
       */
      resetItem: function resetItem(field) {
        this.__typeCheck__P_421_1(field);

        for (var i = 0; i < this.__items__P_421_0.length; i++) {
          var dataEntry = this.__items__P_421_0[i];

          if (dataEntry.item === field) {
            return field.setValue(dataEntry.init);
          }
        }

        throw new Error("The given field has not been added.");
      },

      /**
       * Takes the current values of all added fields and uses these values as
       * init values for resetting.
       */
      redefine: function redefine() {
        // go threw all added items
        for (var i = 0; i < this.__items__P_421_0.length; i++) {
          var item = this.__items__P_421_0[i].item; // set the new init value for the item

          this.__items__P_421_0[i].init = item.getValue();
        }
      },

      /**
       * Takes the current value of the given field and stores this value as init
       * value for resetting.
       *
       * @param field {qx.ui.form.IField} The field to redefine.
       * @throws {TypeError} When given argument is not a field.
       */
      redefineItem: function redefineItem(field) {
        this.__typeCheck__P_421_1(field); // get the data entry


        var dataEntry;

        for (var i = 0; i < this.__items__P_421_0.length; i++) {
          if (this.__items__P_421_0[i].item === field) {
            dataEntry = this.__items__P_421_0[i];
            dataEntry.init = dataEntry.item.getValue();
            return;
          }
        }

        throw new Error("The given field has not been added.");
      },

      /**
       * Assert when given argument is not a field.
       *
       * @param field {qx.ui.form.IField|var} Any argument that should be a field.
       * @throws {TypeError} When given argument is not a field.
       * @private
       */
      __typeCheck__P_421_1: function __typeCheck__P_421_1(field) {
        if (!qx.Class.hasInterface(field.constructor, qx.ui.form.IField)) {
          throw new TypeError("Field " + field + " not supported for resetting.");
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      // holding references to widgets --> must set to null
      this.__items__P_421_0 = null;
    }
  });
  qx.ui.form.Resetter.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This class is responsible for validation in all asynchronous cases and
   * should always be used with {@link qx.ui.form.validation.Manager}.
   *
   *
   * It acts like a wrapper for asynchronous validation functions. These
   * validation function must be set in the constructor. The form manager will
   * invoke the validation and the validator function will be called with two
   * arguments:
   * <ul>
   *  <li>asyncValidator: A reference to the corresponding validator.</li>
   *  <li>value: The value of the assigned input field.</li>
   * </ul>
   * These two parameters are needed to set the validation status of the current
   * validator. {@link #setValid} is responsible for doing that.
   *
   *
   * *Warning:* Instances of this class can only be used with one input
   * field at a time. Multi usage is not supported!
   *
   * *Warning:* Calling {@link #setValid} synchronously does not work. If you
   * have an synchronous validator, please check
   * {@link qx.ui.form.validation.Manager#add}. If you have both cases, you have
   * to wrap the synchronous call in a timeout to make it asynchronous.
   */
  qx.Class.define("qx.ui.form.validation.AsyncValidator", {
    extend: qx.core.Object,

    /**
     * @param validator {Function} The validator function, which has to be
     *   asynchronous.
     */
    construct: function construct(validator) {
      qx.core.Object.constructor.call(this); // save the validator function

      this.__validatorFunction__P_431_0 = validator;
    },
    members: {
      __validatorFunction__P_431_0: null,
      __item__P_431_1: null,
      __manager__P_431_2: null,
      __usedForForm__P_431_3: null,

      /**
       * The validate function should only be called by
       * {@link qx.ui.form.validation.Manager}.
       *
       * It stores the given information and calls the validation function set in
       * the constructor. The method is used for form fields only. Validating a
       * form itself will be invokes with {@link #validateForm}.
       *
       * @param item {qx.ui.core.Widget} The form item which should be validated.
       * @param value {var} The value of the form item.
       * @param manager {qx.ui.form.validation.Manager} A reference to the form
       *   manager.
       * @param context {var?null} The context of the validator.
       *
       * @internal
       */
      validate: function validate(item, value, manager, context) {
        // mark as item validator
        this.__usedForForm__P_431_3 = false; // store the item and the manager

        this.__item__P_431_1 = item;
        this.__manager__P_431_2 = manager; // invoke the user set validator function

        this.__validatorFunction__P_431_0.call(context || this, this, value);
      },

      /**
       * The validateForm function should only be called by
       * {@link qx.ui.form.validation.Manager}.
       *
       * It stores the given information and calls the validation function set in
       * the constructor. The method is used for forms only. Validating a
       * form item will be invokes with {@link #validate}.
       *
       * @param items {qx.ui.core.Widget[]} All form items of the form manager.
       * @param manager {qx.ui.form.validation.Manager} A reference to the form
       *   manager.
       * @param context {var?null} The context of the validator.
       *
       * @internal
       */
      validateForm: function validateForm(items, manager, context) {
        this.__usedForForm__P_431_3 = true;
        this.__manager__P_431_2 = manager;

        this.__validatorFunction__P_431_0.call(context, items, this);
      },

      /**
       * This method should be called within the asynchronous callback to tell the
       * validator the result of the validation.
       *
       * @param valid {Boolean} The boolean state of the validation.
       * @param message {String?} The invalidMessage of the validation.
       */
      setValid: function setValid(valid, message) {
        // valid processing
        if (this.__usedForForm__P_431_3) {
          // message processing
          if (message !== undefined) {
            this.__manager__P_431_2.setInvalidMessage(message);
          }

          this.__manager__P_431_2.setFormValid(valid);
        } else {
          // message processing
          if (message !== undefined) {
            this.__item__P_431_1.setInvalidMessage(message);
          }

          this.__manager__P_431_2.setItemValid(this.__item__P_431_1, valid);
        }
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this.__manager__P_431_2 = this.__item__P_431_1 = null;
    }
  });
  qx.ui.form.validation.AsyncValidator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.basic.Atom": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.event.AcceleratingTimer": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The HoverButton is an {@link qx.ui.basic.Atom}, which fires repeatedly
   * execute events while the pointer is over the widget.
   *
   * The rate at which the execute event is fired accelerates is the pointer keeps
   * inside of the widget. The initial delay and the interval time can be set using
   * the properties {@link #firstInterval} and {@link #interval}. The
   * {@link #execute} events will be fired in a shorter amount of time if the pointer
   * remains over the widget, until the min {@link #minTimer} is reached.
   * The {@link #timerDecrease} property sets the amount of milliseconds which will
   * decreased after every firing.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.form.HoverButton("Hello World");
   *
   *   button.addListener("execute", function(e) {
   *     alert("Button is hovered");
   *   }, this);
   *
   *   this.getRoot.add(button);
   * </pre>
   *
   * This example creates a button with the label "Hello World" and attaches an
   * event listener to the {@link #execute} event.
   *
   * *External Documentation*
   *
   * <a href='http://qooxdoo.org/docs/#desktop/widget/hoverbutton.md' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define("qx.ui.form.HoverButton", {
    extend: qx.ui.basic.Atom,
    include: [qx.ui.core.MExecutable],
    implement: [qx.ui.form.IExecutable],

    /**
     * @param label {String} Label to use
     * @param icon {String?null} Icon to use
     */
    construct: function construct(label, icon) {
      qx.ui.basic.Atom.constructor.call(this, label, icon);
      this.addListener("pointerover", this._onPointerOver, this);
      this.addListener("pointerout", this._onPointerOut, this);
      this.__timer__P_414_0 = new qx.event.AcceleratingTimer();

      this.__timer__P_414_0.addListener("interval", this._onInterval, this);
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "hover-button"
      },

      /**
       * Interval used after the first run of the timer. Usually a smaller value
       * than the "firstInterval" property value to get a faster reaction.
       */
      interval: {
        check: "Integer",
        init: 80
      },

      /**
       * Interval used for the first run of the timer. Usually a greater value
       * than the "interval" property value to a little delayed reaction at the first
       * time.
       */
      firstInterval: {
        check: "Integer",
        init: 200
      },

      /** This configures the minimum value for the timer interval. */
      minTimer: {
        check: "Integer",
        init: 20
      },

      /** Decrease of the timer on each interval (for the next interval) until minTimer reached. */
      timerDecrease: {
        check: "Integer",
        init: 2
      }
    },
    members: {
      __timer__P_414_0: null,

      /**
       * Start timer on pointer over
       *
       * @param e {qx.event.type.Pointer} The pointer event
       */
      _onPointerOver: function _onPointerOver(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        this.__timer__P_414_0.set({
          interval: this.getInterval(),
          firstInterval: this.getFirstInterval(),
          minimum: this.getMinTimer(),
          decrease: this.getTimerDecrease()
        }).start();

        this.addState("hovered");
      },

      /**
       * Stop timer on pointer out
       *
       * @param e {qx.event.type.Pointer} The pointer event
       */
      _onPointerOut: function _onPointerOut(e) {
        this.__timer__P_414_0.stop();

        this.removeState("hovered");

        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }
      },

      /**
       * Fire execute event on timer interval event
       */
      _onInterval: function _onInterval() {
        if (this.isEnabled()) {
          this.execute();
        } else {
          this.__timer__P_414_0.stop();
        }
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__timer__P_414_0");
    }
  });
  qx.ui.form.HoverButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 Martijn Evers, The Netherlands
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martijn Evers (mever)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which have arrays as their primary data type.
   */
  qx.Interface.define("qx.ui.form.IArrayForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {qx.data.Array|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {qx.data.Array|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.IArrayForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 Martijn Evers, The Netherlands
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martijn Evers (mever)
  
  ************************************************************************ */

  /**
   * Form interface for all form widgets which have an
   * model object (i.e. {qx.core.Object}) as their primary data type.
   */
  qx.Interface.define("qx.ui.form.IModelForm", {
    extend: qx.ui.form.IField,

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the element's value.
       *
       * @param value {qx.core.Object|null} The new value of the element.
       */
      setValue: function setValue(value) {
        return arguments.length == 1;
      },

      /**
       * Resets the element's value to its initial value.
       */
      resetValue: function resetValue() {},

      /**
       * The element's user set value.
       *
       * @return {qx.core.Object|null} The value.
       */
      getValue: function getValue() {}
    }
  });
  qx.ui.form.IModelForm.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Button": {
        "construct": true,
        "require": true
      },
      "qx.ui.menu.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A button which opens the connected menu when tapping on it.
   */
  qx.Class.define("qx.ui.form.MenuButton", {
    extend: qx.ui.form.Button,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Initial label
     * @param icon {String?null} Initial icon
     * @param menu {qx.ui.menu.Menu} Connect to menu instance
     */
    construct: function construct(label, icon, menu) {
      qx.ui.form.Button.constructor.call(this, label, icon); // Initialize properties

      if (menu != null) {
        this.setMenu(menu);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The menu instance to show when tapping on the button */
      menu: {
        check: "qx.ui.menu.Menu",
        nullable: true,
        apply: "_applyMenu",
        event: "changeMenu"
      },
      // overridden
      appearance: {
        refine: true,
        init: "menubutton"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyVisibility: function _applyVisibility(value, old) {
        qx.ui.form.MenuButton.prototype._applyVisibility.base.call(this, value, old); // hide the menu too


        var menu = this.getMenu();

        if (value != "visible" && menu) {
          menu.hide();
        }
      },
      // property apply
      _applyMenu: function _applyMenu(value, old) {
        if (old) {
          old.removeListener("changeVisibility", this._onMenuChange, this);
          old.resetOpener();
        }

        if (value) {
          value.addListener("changeVisibility", this._onMenuChange, this);
          value.setOpener(this);
          value.removeState("submenu");
          value.removeState("contextmenu");
        }
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Positions and shows the attached menu widget.
       *
       * @param selectFirst {Boolean?false} Whether the first menu button should be selected
       */
      open: function open(selectFirst) {
        var menu = this.getMenu();

        if (menu) {
          // Hide all menus first
          qx.ui.menu.Manager.getInstance().hideAll(); // Open the attached menu

          menu.setOpener(this);
          menu.open(); // Select first item

          if (selectFirst) {
            var first = menu.getSelectables()[0];

            if (first) {
              menu.setSelectedButton(first);
            }
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Listener for visibility property changes of the attached menu
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onMenuChange: function _onMenuChange(e) {
        var menu = this.getMenu();

        if (menu.isVisible()) {
          this.addState("pressed");
        } else {
          this.removeState("pressed");
        }
      },
      // overridden
      _onPointerDown: function _onPointerDown(e) {
        // call the base function to get into the capture phase [BUG #4340]
        qx.ui.form.MenuButton.prototype._onPointerDown.base.call(this, e); // only open on left clicks [BUG #5125]


        if (e.getButton() != "left") {
          return;
        }

        var menu = this.getMenu();

        if (menu) {
          // Toggle sub menu visibility
          if (!menu.isVisible()) {
            this.open();
          } else {
            menu.exclude();
          } // Event is processed, stop it for others


          e.stopPropagation();
        }
      },
      // overridden
      _onPointerUp: function _onPointerUp(e) {
        // call base for firing the execute event
        qx.ui.form.MenuButton.prototype._onPointerUp.base.call(this, e); // Just stop propagation to stop menu manager
        // from getting the event


        e.stopPropagation();
      },
      // overridden
      _onPointerOver: function _onPointerOver(e) {
        // Add hovered state
        this.addState("hovered");
      },
      // overridden
      _onPointerOut: function _onPointerOut(e) {
        // Just remove the hover state
        this.removeState("hovered");
      },
      // overridden
      _onKeyDown: function _onKeyDown(e) {
        switch (e.getKeyIdentifier()) {
          case "Enter":
            this.removeState("abandoned");
            this.addState("pressed");
            var menu = this.getMenu();

            if (menu) {
              // Toggle sub menu visibility
              if (!menu.isVisible()) {
                this.open();
              } else {
                menu.exclude();
              }
            }

            e.stopPropagation();
        }
      },
      // overridden
      _onKeyUp: function _onKeyUp(e) {// no action required here
      }
    }
  });
  qx.ui.form.MenuButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.event.Registration": {
        "construct": true
      },
      "qx.bom.client.Event": {
        "construct": true
      },
      "qx.bom.Element": {
        "construct": true
      },
      "qx.event.Timer": {
        "construct": true
      },
      "qx.ui.menu.Menu": {},
      "qx.ui.menu.AbstractButton": {},
      "qx.lang.Array": {},
      "qx.ui.core.Widget": {},
      "qx.ui.menubar.Button": {},
      "qx.ui.menu.Button": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "event.touch": {
          "construct": true,
          "className": "qx.bom.client.Event"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * This singleton manages visible menu instances and supports some
   * core features to schedule menu open/close with timeout support.
   *
   * It also manages the whole keyboard support for the currently
   * registered widgets.
   *
   * The zIndex order is also managed by this class.
   */
  qx.Class.define("qx.ui.menu.Manager", {
    type: "singleton",
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this); // Create data structure

      this.__objects__P_445_0 = [];
      var el = document.body;
      var Registration = qx.event.Registration; // React on pointer/mouse events, but on native, to support inline applications

      Registration.addListener(window.document.documentElement, "pointerdown", this._onPointerDown, this, true);
      Registration.addListener(el, "roll", this._onRoll, this, true); // React on keypress events

      Registration.addListener(el, "keydown", this._onKeyUpDown, this, true);
      Registration.addListener(el, "keyup", this._onKeyUpDown, this, true);
      Registration.addListener(el, "keypress", this._onKeyPress, this, true); // only use the blur event to hide windows on non touch devices [BUG #4033]
      // When the menu is located on top of an iFrame, the select will fail

      if (!qx.core.Environment.get("event.touch")) {
        // Hide all when the window is blurred
        qx.bom.Element.addListener(window, "blur", this.hideAll, this);
      } // Create open timer


      this.__openTimer__P_445_1 = new qx.event.Timer();

      this.__openTimer__P_445_1.addListener("interval", this._onOpenInterval, this); // Create close timer


      this.__closeTimer__P_445_2 = new qx.event.Timer();

      this.__closeTimer__P_445_2.addListener("interval", this._onCloseInterval, this);
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __scheduleOpen__P_445_3: null,
      __scheduleClose__P_445_4: null,
      __openTimer__P_445_1: null,
      __closeTimer__P_445_2: null,
      __objects__P_445_0: null,

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Query engine for menu children.
       *
       * @param menu {qx.ui.menu.Menu} Any menu instance
       * @param start {Integer} Child index to start with
       * @param iter {Integer} Iteration count, normally <code>+1</code> or <code>-1</code>
       * @param loop {Boolean?false} Whether to wrap when reaching the begin/end of the list
       * @return {qx.ui.menu.Button} Any menu button or <code>null</code>
       */
      _getChild: function _getChild(menu, start, iter, loop) {
        var children = menu.getChildren();
        var length = children.length;
        var child;

        for (var i = start; i < length && i >= 0; i += iter) {
          child = children[i];

          if (child.isEnabled() && !child.isAnonymous() && child.isVisible()) {
            return child;
          }
        }

        if (loop) {
          i = i == length ? 0 : length - 1;

          for (; i != start; i += iter) {
            child = children[i];

            if (child.isEnabled() && !child.isAnonymous() && child.isVisible()) {
              return child;
            }
          }
        }

        return null;
      },

      /**
       * Whether the given widget is inside any Menu instance.
       *
       * @param widget {qx.ui.core.Widget} Any widget
       * @return {Boolean} <code>true</code> when the widget is part of any menu
       */
      _isInMenu: function _isInMenu(widget) {
        while (widget) {
          if (widget instanceof qx.ui.menu.Menu) {
            return true;
          }

          widget = widget.getLayoutParent();
        }

        return false;
      },

      /**
       * Whether the given widget is one of the menu openers.
       *
       * @param widget {qx.ui.core.Widget} Any widget
       * @return {Boolean} <code>true</code> if the widget is a menu opener
       */
      _isMenuOpener: function _isMenuOpener(widget) {
        var menus = this.__objects__P_445_0;

        for (var i = 0; i < menus.length; i++) {
          if (menus[i].getOpener() === widget) {
            return true;
          }
        }

        return false;
      },

      /**
       * Returns an instance of a menu button if the given widget is a child
       *
       * @param widget {qx.ui.core.Widget} any widget
       * @return {qx.ui.menu.Button} Any menu button instance or <code>null</code>
       */
      _getMenuButton: function _getMenuButton(widget) {
        while (widget) {
          if (widget instanceof qx.ui.menu.AbstractButton) {
            return widget;
          }

          widget = widget.getLayoutParent();
        }

        return null;
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Adds a menu to the list of visible menus.
       *
       * @param obj {qx.ui.menu.Menu} Any menu instance.
       */
      add: function add(obj) {
        {
          if (!(obj instanceof qx.ui.menu.Menu)) {
            throw new Error("Object is no menu: " + obj);
          }
        }
        var reg = this.__objects__P_445_0;
        reg.push(obj);
        obj.setZIndex(1e6 + reg.length);
      },

      /**
       * Remove a menu from the list of visible menus.
       *
       * @param obj {qx.ui.menu.Menu} Any menu instance.
       */
      remove: function remove(obj) {
        {
          if (!(obj instanceof qx.ui.menu.Menu)) {
            throw new Error("Object is no menu: " + obj);
          }
        }
        var reg = this.__objects__P_445_0;

        if (reg) {
          qx.lang.Array.remove(reg, obj);
        }
      },

      /**
       * Hides all currently opened menus.
       */
      hideAll: function hideAll() {
        var reg = this.__objects__P_445_0;

        if (reg) {
          for (var i = reg.length - 1; i >= 0; i--) {
            reg[i].exclude();
          }
        }
      },

      /**
       * Returns the menu which was opened at last (which
       * is the active one this way)
       *
       * @return {qx.ui.menu.Menu} The current active menu or <code>null</code>
       */
      getActiveMenu: function getActiveMenu() {
        var reg = this.__objects__P_445_0;
        return reg.length > 0 ? reg[reg.length - 1] : null;
      },

      /*
      ---------------------------------------------------------------------------
        SCHEDULED OPEN/CLOSE SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Schedules the given menu to be opened after the
       * {@link qx.ui.menu.Menu#openInterval} configured by the
       * menu instance itself.
       *
       * @param menu {qx.ui.menu.Menu} The menu to schedule for open
       */
      scheduleOpen: function scheduleOpen(menu) {
        // Cancel close of given menu first
        this.cancelClose(menu); // When the menu is already visible

        if (menu.isVisible()) {
          // Cancel all other open requests
          if (this.__scheduleOpen__P_445_3) {
            this.cancelOpen(this.__scheduleOpen__P_445_3);
          }
        } // When the menu is not visible and not scheduled already
        // then schedule it for opening
        else if (this.__scheduleOpen__P_445_3 != menu) {
            // menu.debug("Schedule open");
            this.__scheduleOpen__P_445_3 = menu;

            this.__openTimer__P_445_1.restartWith(menu.getOpenInterval());
          }
      },

      /**
       * Schedules the given menu to be closed after the
       * {@link qx.ui.menu.Menu#closeInterval} configured by the
       * menu instance itself.
       *
       * @param menu {qx.ui.menu.Menu} The menu to schedule for close
       */
      scheduleClose: function scheduleClose(menu) {
        // Cancel open of the menu first
        this.cancelOpen(menu); // When the menu is already invisible

        if (!menu.isVisible()) {
          // Cancel all other close requests
          if (this.__scheduleClose__P_445_4) {
            this.cancelClose(this.__scheduleClose__P_445_4);
          }
        } // When the menu is visible and not scheduled already
        // then schedule it for closing
        else if (this.__scheduleClose__P_445_4 != menu) {
            // menu.debug("Schedule close");
            this.__scheduleClose__P_445_4 = menu;

            this.__closeTimer__P_445_2.restartWith(menu.getCloseInterval());
          }
      },

      /**
       * When the given menu is scheduled for open this pending
       * request is canceled.
       *
       * @param menu {qx.ui.menu.Menu} The menu to cancel for open
       */
      cancelOpen: function cancelOpen(menu) {
        if (this.__scheduleOpen__P_445_3 == menu) {
          // menu.debug("Cancel open");
          this.__openTimer__P_445_1.stop();

          this.__scheduleOpen__P_445_3 = null;
        }
      },

      /**
       * When the given menu is scheduled for close this pending
       * request is canceled.
       *
       * @param menu {qx.ui.menu.Menu} The menu to cancel for close
       */
      cancelClose: function cancelClose(menu) {
        if (this.__scheduleClose__P_445_4 == menu) {
          // menu.debug("Cancel close");
          this.__closeTimer__P_445_2.stop();

          this.__scheduleClose__P_445_4 = null;
        }
      },

      /*
      ---------------------------------------------------------------------------
        TIMER EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for a pending open request. Configured to the interval
       * of the current menu to open.
       *
       * @param e {qx.event.type.Event} Interval event
       */
      _onOpenInterval: function _onOpenInterval(e) {
        // Stop timer
        this.__openTimer__P_445_1.stop(); // Open menu and reset flag


        this.__scheduleOpen__P_445_3.open();

        this.__scheduleOpen__P_445_3 = null;
      },

      /**
       * Event listener for a pending close request. Configured to the interval
       * of the current menu to close.
       *
       * @param e {qx.event.type.Event} Interval event
       */
      _onCloseInterval: function _onCloseInterval(e) {
        // Stop timer, reset scheduling flag
        this.__closeTimer__P_445_2.stop(); // Close menu and reset flag


        this.__scheduleClose__P_445_4.exclude();

        this.__scheduleClose__P_445_4 = null;
      },

      /*
      ---------------------------------------------------------------------------
        CONTEXTMENU EVENT HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Internal function registers a handler to stop next
       * <code>contextmenu</code> event.
       * This function will be called by {@link qx.ui.menu.Button#_onTap}, if
       * right click was pressed.
       *
       * @internal
       */
      preventContextMenuOnce: function preventContextMenuOnce() {
        qx.event.Registration.addListener(document.body, "contextmenu", this.__onPreventContextMenu__P_445_5, this, true);
      },

      /**
       * Internal event handler to stop <code>contextmenu</code> event bubbling,
       * if target is inside the opened menu.
       *
       * @param e {qx.event.type.Mouse} contextmenu event
       *
       * @internal
       */
      __onPreventContextMenu__P_445_5: function __onPreventContextMenu__P_445_5(e) {
        var target = e.getTarget();
        target = qx.ui.core.Widget.getWidgetByElement(target, true);

        if (this._isInMenu(target)) {
          e.stopPropagation();
          e.preventDefault();
        } // stop only once


        qx.event.Registration.removeListener(document.body, "contextmenu", this.__onPreventContextMenu__P_445_5, this, true);
      },

      /*
      ---------------------------------------------------------------------------
        POINTER EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for pointerdown events
       *
       * @param e {qx.event.type.Pointer} pointerdown event
       */
      _onPointerDown: function _onPointerDown(e) {
        var target = e.getTarget();
        target = qx.ui.core.Widget.getWidgetByElement(target, true); // If the target is 'null' the tap appears on a DOM element witch is not
        // a widget. This happens normally with an inline application, when the user
        // taps not in the inline application. In this case all all currently
        // open menus should be closed.

        if (target == null) {
          this.hideAll();
          return;
        } // If the target is the one which has opened the current menu
        // we ignore the pointerdown to let the button process the event
        // further with toggling or ignoring the tap.


        if (target.getMenu && target.getMenu() && target.getMenu().isVisible()) {
          return;
        } // All taps not inside a menu will hide all currently open menus


        if (this.__objects__P_445_0.length > 0 && !this._isInMenu(target)) {
          this.hideAll();
        }
      },

      /*
      ---------------------------------------------------------------------------
        KEY EVENT HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * @type {Map} Map of all keys working on an active menu selection
       * @lint ignoreReferenceField(__selectionKeys)
       */
      __selectionKeys__P_445_6: {
        "Enter": 1,
        "Space": 1
      },

      /**
       * @type {Map} Map of all keys working without a selection
       * @lint ignoreReferenceField(__navigationKeys)
       */
      __navigationKeys__P_445_7: {
        "Escape": 1,
        "Up": 1,
        "Down": 1,
        "Left": 1,
        "Right": 1
      },

      /**
       * Event handler for all keyup/keydown events. Stops all events
       * when any menu is opened.
       *
       * @param e {qx.event.type.KeySequence} Keyboard event
       */
      _onKeyUpDown: function _onKeyUpDown(e) {
        var menu = this.getActiveMenu();

        if (!menu) {
          return;
        } // Stop for all supported key combos


        var iden = e.getKeyIdentifier();

        if (this.__navigationKeys__P_445_7[iden] || this.__selectionKeys__P_445_6[iden] && menu.getSelectedButton()) {
          e.stopPropagation();
        }
      },

      /**
       * Event handler for all keypress events. Delegates the event to the more
       * specific methods defined in this class.
       *
       * Currently processes the keys: <code>Up</code>, <code>Down</code>,
       * <code>Left</code>, <code>Right</code> and <code>Enter</code>.
       *
       * @param e {qx.event.type.KeySequence} Keyboard event
       */
      _onKeyPress: function _onKeyPress(e) {
        var menu = this.getActiveMenu();

        if (!menu) {
          return;
        }

        var iden = e.getKeyIdentifier();
        var navigation = this.__navigationKeys__P_445_7[iden];
        var selection = this.__selectionKeys__P_445_6[iden];

        if (navigation) {
          switch (iden) {
            case "Up":
              this._onKeyPressUp(menu);

              break;

            case "Down":
              this._onKeyPressDown(menu);

              break;

            case "Left":
              this._onKeyPressLeft(menu);

              break;

            case "Right":
              this._onKeyPressRight(menu);

              break;

            case "Escape":
              this.hideAll();
              break;
          }

          e.stopPropagation();
          e.preventDefault();
        } else if (selection) {
          // Do not process these events when no item is hovered
          var button = menu.getSelectedButton();

          if (button) {
            switch (iden) {
              case "Enter":
                this._onKeyPressEnter(menu, button, e);

                break;

              case "Space":
                this._onKeyPressSpace(menu, button, e);

                break;
            }

            e.stopPropagation();
            e.preventDefault();
          }
        }
      },

      /**
       * Event handler for <code>Up</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       */
      _onKeyPressUp: function _onKeyPressUp(menu) {
        // Query for previous child
        var selectedButton = menu.getSelectedButton();
        var children = menu.getChildren();
        var start = selectedButton ? menu.indexOf(selectedButton) - 1 : children.length - 1;

        var nextItem = this._getChild(menu, start, -1, true); // Reconfigure property


        if (nextItem) {
          menu.setSelectedButton(nextItem);
        } else {
          menu.resetSelectedButton();
        }
      },

      /**
       * Event handler for <code>Down</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       */
      _onKeyPressDown: function _onKeyPressDown(menu) {
        // Query for next child
        var selectedButton = menu.getSelectedButton();
        var start = selectedButton ? menu.indexOf(selectedButton) + 1 : 0;

        var nextItem = this._getChild(menu, start, 1, true); // Reconfigure property


        if (nextItem) {
          menu.setSelectedButton(nextItem);
        } else {
          menu.resetSelectedButton();
        }
      },

      /**
       * Event handler for <code>Left</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       */
      _onKeyPressLeft: function _onKeyPressLeft(menu) {
        var menuOpener = menu.getOpener();

        if (!menuOpener) {
          return;
        } // Back to the "parent" menu


        if (menuOpener instanceof qx.ui.menu.AbstractButton) {
          var parentMenu = menuOpener.getLayoutParent();
          parentMenu.resetOpenedButton();
          parentMenu.setSelectedButton(menuOpener);
        } // Goto the previous toolbar button
        else if (menuOpener instanceof qx.ui.menubar.Button) {
            var buttons = menuOpener.getMenuBar().getMenuButtons();
            var index = buttons.indexOf(menuOpener); // This should not happen, definitely!

            if (index === -1) {
              return;
            } // Get previous button, fallback to end if first arrived


            var prevButton = null;
            var length = buttons.length;

            for (var i = 1; i <= length; i++) {
              var button = buttons[(index - i + length) % length];

              if (button.isEnabled() && button.isVisible()) {
                prevButton = button;
                break;
              }
            }

            if (prevButton && prevButton != menuOpener) {
              prevButton.open(true);
            }
          }
      },

      /**
       * Event handler for <code>Right</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       */
      _onKeyPressRight: function _onKeyPressRight(menu) {
        var selectedButton = menu.getSelectedButton(); // Open sub-menu of hovered item and select first child

        if (selectedButton) {
          var subMenu = selectedButton.getMenu();

          if (subMenu) {
            // Open previously hovered item
            menu.setOpenedButton(selectedButton); // Hover first item in new submenu

            var first = this._getChild(subMenu, 0, 1);

            if (first) {
              subMenu.setSelectedButton(first);
            }

            return;
          }
        } // No hover and no open item
        // When first button has a menu, open it, otherwise only hover it
        else if (!menu.getOpenedButton()) {
            var first = this._getChild(menu, 0, 1);

            if (first) {
              menu.setSelectedButton(first);

              if (first.getMenu()) {
                menu.setOpenedButton(first);
              }

              return;
            }
          } // Jump to the next toolbar button


        var menuOpener = menu.getOpener(); // Look up opener hierarchy for menu button

        if (menuOpener instanceof qx.ui.menu.Button && selectedButton) {
          // From one inner selected button try to find the top level
          // menu button which has opened the whole menu chain.
          while (menuOpener) {
            menuOpener = menuOpener.getLayoutParent();

            if (menuOpener instanceof qx.ui.menu.Menu) {
              menuOpener = menuOpener.getOpener();

              if (menuOpener instanceof qx.ui.menubar.Button) {
                break;
              }
            } else {
              break;
            }
          }

          if (!menuOpener) {
            return;
          }
        } // Ask the toolbar for the next menu button


        if (menuOpener instanceof qx.ui.menubar.Button) {
          var buttons = menuOpener.getMenuBar().getMenuButtons();
          var index = buttons.indexOf(menuOpener); // This should not happen, definitely!

          if (index === -1) {
            return;
          } // Get next button, fallback to first if end arrived


          var nextButton = null;
          var length = buttons.length;

          for (var i = 1; i <= length; i++) {
            var button = buttons[(index + i) % length];

            if (button.isEnabled() && button.isVisible()) {
              nextButton = button;
              break;
            }
          }

          if (nextButton && nextButton != menuOpener) {
            nextButton.open(true);
          }
        }
      },

      /**
       * Event handler for <code>Enter</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       * @param button {qx.ui.menu.AbstractButton} The selected button
       * @param e {qx.event.type.KeySequence} The keypress event
       */
      _onKeyPressEnter: function _onKeyPressEnter(menu, button, e) {
        // Route keypress event to the selected button
        if (button.hasListener("keypress")) {
          // Clone and reconfigure event
          var clone = e.clone();
          clone.setBubbles(false);
          clone.setTarget(button); // Finally dispatch the clone

          button.dispatchEvent(clone);
        } // Hide all open menus


        this.hideAll();
      },

      /**
       * Event handler for <code>Space</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       * @param button {qx.ui.menu.AbstractButton} The selected button
       * @param e {qx.event.type.KeySequence} The keypress event
       */
      _onKeyPressSpace: function _onKeyPressSpace(menu, button, e) {
        // Route keypress event to the selected button
        if (button.hasListener("keypress")) {
          // Clone and reconfigure event
          var clone = e.clone();
          clone.setBubbles(false);
          clone.setTarget(button); // Finally dispatch the clone

          button.dispatchEvent(clone);
        }
      },

      /**
       * Event handler for roll which hides all windows on scroll.
       *
       * @param e {qx.event.type.Roll} The roll event.
       */
      _onRoll: function _onRoll(e) {
        var target = e.getTarget();
        target = qx.ui.core.Widget.getWidgetByElement(target, true);

        if (this.__objects__P_445_0.length > 0 && !this._isInMenu(target) && !this._isMenuOpener(target) && !e.getMomentum()) {
          this.hideAll();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      var Registration = qx.event.Registration;
      var el = document.body; // React on pointerdown events

      Registration.removeListener(window.document.documentElement, "pointerdown", this._onPointerDown, this, true); // React on keypress events

      Registration.removeListener(el, "keydown", this._onKeyUpDown, this, true);
      Registration.removeListener(el, "keyup", this._onKeyUpDown, this, true);
      Registration.removeListener(el, "keypress", this._onKeyPress, this, true);

      this._disposeObjects("__openTimer__P_445_1", "__closeTimer__P_445_2");

      this._disposeArray("__objects__P_445_0");
    }
  });
  qx.ui.menu.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MPlacement": {
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.menu.Layout": {
        "construct": true
      },
      "qx.ui.core.Blocker": {
        "construct": true
      },
      "qx.ui.menu.Separator": {},
      "qx.ui.menu.Manager": {},
      "qx.ui.menu.AbstractButton": {},
      "qx.ui.menu.MenuSlideBar": {},
      "qx.ui.layout.Grow": {},
      "qx.lang.Array": {},
      "qx.ui.core.queue.Widget": {},
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The menu is a popup like control which supports buttons. It comes
   * with full keyboard navigation and an improved timeout based pointer
   * control behavior.
   *
   * This class is the container for all derived instances of
   * {@link qx.ui.menu.AbstractButton}.
   *
   * @childControl slidebar {qx.ui.menu.MenuSlideBar} shows a slidebar to easily navigate inside the menu (if too little space is left)
   */
  qx.Class.define("qx.ui.menu.Menu", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MPlacement, qx.ui.core.MRemoteChildrenHandling],
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // Use hard coded layout

      this._setLayout(new qx.ui.menu.Layout()); // Automatically add to application's root


      var root = this.getApplicationRoot();
      root.add(this); // Register pointer listeners

      this.addListener("pointerover", this._onPointerOver);
      this.addListener("pointerout", this._onPointerOut); // add resize listener

      this.addListener("resize", this._onResize, this);
      root.addListener("resize", this._onResize, this);
      this._blocker = new qx.ui.core.Blocker(root); // Initialize properties

      this.initVisibility();
      this.initKeepFocus();
      this.initKeepActive();
    },
    properties: {
      /*
      ---------------------------------------------------------------------------
        WIDGET PROPERTIES
      ---------------------------------------------------------------------------
      */
      // overridden
      appearance: {
        refine: true,
        init: "menu"
      },
      // overridden
      allowGrowX: {
        refine: true,
        init: false
      },
      // overridden
      allowGrowY: {
        refine: true,
        init: false
      },
      // overridden
      visibility: {
        refine: true,
        init: "excluded"
      },
      // overridden
      keepFocus: {
        refine: true,
        init: true
      },
      // overridden
      keepActive: {
        refine: true,
        init: true
      },

      /*
      ---------------------------------------------------------------------------
        STYLE OPTIONS
      ---------------------------------------------------------------------------
      */

      /** The spacing between each cell of the menu buttons */
      spacingX: {
        check: "Integer",
        apply: "_applySpacingX",
        init: 0,
        themeable: true
      },

      /** The spacing between each menu button */
      spacingY: {
        check: "Integer",
        apply: "_applySpacingY",
        init: 0,
        themeable: true
      },

      /**
      * Default icon column width if no icons are rendered.
      * This property is ignored as soon as an icon is present.
      */
      iconColumnWidth: {
        check: "Integer",
        init: 0,
        themeable: true,
        apply: "_applyIconColumnWidth"
      },

      /** Default arrow column width if no sub menus are rendered */
      arrowColumnWidth: {
        check: "Integer",
        init: 0,
        themeable: true,
        apply: "_applyArrowColumnWidth"
      },

      /**
       * Color of the blocker
       */
      blockerColor: {
        check: "Color",
        init: null,
        nullable: true,
        apply: "_applyBlockerColor",
        themeable: true
      },

      /**
       * Opacity of the blocker
       */
      blockerOpacity: {
        check: "Number",
        init: 1,
        apply: "_applyBlockerOpacity",
        themeable: true
      },

      /*
      ---------------------------------------------------------------------------
        FUNCTIONALITY PROPERTIES
      ---------------------------------------------------------------------------
      */

      /** The currently selected button */
      selectedButton: {
        check: "qx.ui.core.Widget",
        nullable: true,
        apply: "_applySelectedButton"
      },

      /** The currently opened button (sub menu is visible) */
      openedButton: {
        check: "qx.ui.core.Widget",
        nullable: true,
        apply: "_applyOpenedButton"
      },

      /** Widget that opened the menu */
      opener: {
        check: "qx.ui.core.Widget",
        nullable: true
      },

      /*
      ---------------------------------------------------------------------------
        BEHAVIOR PROPERTIES
      ---------------------------------------------------------------------------
      */

      /** Interval in ms after which sub menus should be opened */
      openInterval: {
        check: "Integer",
        themeable: true,
        init: 250,
        apply: "_applyOpenInterval"
      },

      /** Interval in ms after which sub menus should be closed  */
      closeInterval: {
        check: "Integer",
        themeable: true,
        init: 250,
        apply: "_applyCloseInterval"
      },

      /** Blocks the background if value is <code>true<code> */
      blockBackground: {
        check: "Boolean",
        themeable: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __scheduledOpen__P_446_0: null,
      __onAfterSlideBarAdd__P_446_1: null,

      /** @type {qx.ui.core.Blocker} blocker for background blocking */
      _blocker: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Opens the menu and configures the opener
       */
      open: function open() {
        if (this.getOpener() != null) {
          var isPlaced = this.placeToWidget(this.getOpener(), true);

          if (isPlaced) {
            this.__updateSlideBar__P_446_2();

            this.show();
            this._placementTarget = this.getOpener();
          } else {
            this.warn("Could not open menu instance because 'opener' widget is not visible");
          }
        } else {
          this.warn("The menu instance needs a configured 'opener' widget!");
        }
      },

      /**
       * Opens the menu at the pointer position
       *
       * @param e {qx.event.type.Pointer} Pointer event to align to
       */
      openAtPointer: function openAtPointer(e) {
        this.placeToPointer(e);

        this.__updateSlideBar__P_446_2();

        this.show();
        this._placementTarget = {
          left: e.getDocumentLeft(),
          top: e.getDocumentTop()
        };
      },

      /**
       * Opens the menu in relation to the given point
       *
       * @param point {Map} Coordinate of any point with the keys <code>left</code>
       *   and <code>top</code>.
       */
      openAtPoint: function openAtPoint(point) {
        this.placeToPoint(point);

        this.__updateSlideBar__P_446_2();

        this.show();
        this._placementTarget = point;
      },

      /**
       * Convenience method to add a separator to the menu
       */
      addSeparator: function addSeparator() {
        this.add(new qx.ui.menu.Separator());
      },

      /**
       * Returns the column sizes detected during the pre-layout phase
       *
       * @return {Array} List of all column widths
       */
      getColumnSizes: function getColumnSizes() {
        return this._getMenuLayout().getColumnSizes();
      },

      /**
       * Return all selectable menu items.
       *
       * @return {qx.ui.core.Widget[]} selectable widgets
       */
      getSelectables: function getSelectables() {
        var result = [];
        var children = this.getChildren();

        for (var i = 0; i < children.length; i++) {
          if (children[i].isEnabled()) {
            result.push(children[i]);
          }
        }

        return result;
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyIconColumnWidth: function _applyIconColumnWidth(value, old) {
        this._getMenuLayout().setIconColumnWidth(value);
      },
      // property apply
      _applyArrowColumnWidth: function _applyArrowColumnWidth(value, old) {
        this._getMenuLayout().setArrowColumnWidth(value);
      },
      // property apply
      _applySpacingX: function _applySpacingX(value, old) {
        this._getMenuLayout().setColumnSpacing(value);
      },
      // property apply
      _applySpacingY: function _applySpacingY(value, old) {
        this._getMenuLayout().setSpacing(value);
      },
      // overridden
      _applyVisibility: function _applyVisibility(value, old) {
        qx.ui.menu.Menu.prototype._applyVisibility.base.call(this, value, old);

        var mgr = qx.ui.menu.Manager.getInstance();

        if (value === "visible") {
          // Register to manager (zIndex handling etc.)
          mgr.add(this); // Mark opened in parent menu

          var parentMenu = this.getParentMenu();

          if (parentMenu) {
            parentMenu.setOpenedButton(this.getOpener());
          }
        } else if (old === "visible") {
          // Deregister from manager (zIndex handling etc.)
          mgr.remove(this); // Unmark opened in parent menu

          var parentMenu = this.getParentMenu();

          if (parentMenu && parentMenu.getOpenedButton() == this.getOpener()) {
            parentMenu.resetOpenedButton();
          } // Clear properties


          this.resetOpenedButton();
          this.resetSelectedButton();
        }

        this.__updateBlockerVisibility__P_446_3();
      },

      /**
       * Updates the blocker's visibility
       */
      __updateBlockerVisibility__P_446_3: function __updateBlockerVisibility__P_446_3() {
        if (this.isVisible()) {
          if (this.getBlockBackground()) {
            var zIndex = this.getZIndex();

            this._blocker.blockContent(zIndex - 1);
          }
        } else {
          if (this._blocker.isBlocked()) {
            this._blocker.unblock();
          }
        }
      },

      /**
       * Get the parent menu. Returns <code>null</code> if the menu doesn't have a
       * parent menu.
       *
       * @return {qx.ui.core.Widget|null} The parent menu.
       */
      getParentMenu: function getParentMenu() {
        var widget = this.getOpener();

        if (!widget || !(widget instanceof qx.ui.menu.AbstractButton)) {
          return null;
        }

        if (widget && widget.getContextMenu() === this) {
          return null;
        }

        while (widget && !(widget instanceof qx.ui.menu.Menu)) {
          widget = widget.getLayoutParent();
        }

        return widget;
      },
      // property apply
      _applySelectedButton: function _applySelectedButton(value, old) {
        if (old) {
          old.removeState("selected");
        }

        if (value) {
          value.addState("selected");
        }
      },
      // property apply
      _applyOpenedButton: function _applyOpenedButton(value, old) {
        if (old && old.getMenu()) {
          old.getMenu().exclude();
        }

        if (value) {
          value.getMenu().open();
        }
      },
      // property apply
      _applyBlockerColor: function _applyBlockerColor(value, old) {
        this._blocker.setColor(value);
      },
      // property apply
      _applyBlockerOpacity: function _applyBlockerOpacity(value, old) {
        this._blocker.setOpacity(value);
      },

      /*
      ---------------------------------------------------------------------------
      SCROLLING SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("slidebar", true) || this;
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "slidebar":
            var control = new qx.ui.menu.MenuSlideBar();

            var layout = this._getLayout();

            this._setLayout(new qx.ui.layout.Grow());

            var slidebarLayout = control.getLayout();
            control.setLayout(layout);
            slidebarLayout.dispose();
            var children = qx.lang.Array.clone(this.getChildren());

            for (var i = 0; i < children.length; i++) {
              control.add(children[i]);
            }

            this.removeListener("resize", this._onResize, this);
            control.getChildrenContainer().addListener("resize", this._onResize, this);

            this._add(control);

            break;
        }

        return control || qx.ui.menu.Menu.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Get the menu layout manager
       *
       * @return {qx.ui.layout.Abstract} The menu layout manager
       */
      _getMenuLayout: function _getMenuLayout() {
        if (this.hasChildControl("slidebar")) {
          return this.getChildControl("slidebar").getChildrenContainer().getLayout();
        } else {
          return this._getLayout();
        }
      },

      /**
       * Get the menu bounds
       *
       * @return {Map} The menu bounds
       */
      _getMenuBounds: function _getMenuBounds() {
        if (this.hasChildControl("slidebar")) {
          return this.getChildControl("slidebar").getChildrenContainer().getBounds();
        } else {
          return this.getBounds();
        }
      },

      /**
       * Computes the size of the menu. This method is used by the
       * {@link qx.ui.core.MPlacement} mixin.
       * @return {Map} The menu bounds
       */
      _computePlacementSize: function _computePlacementSize() {
        return this._getMenuBounds();
      },

      /**
       * Updates the visibility of the slidebar based on the menu's current size
       * and position.
       */
      __updateSlideBar__P_446_2: function __updateSlideBar__P_446_2() {
        var menuBounds = this._getMenuBounds();

        if (!menuBounds) {
          this.addListenerOnce("resize", this.__updateSlideBar__P_446_2, this);
          return;
        }

        var rootHeight = this.getLayoutParent().getBounds().height;
        var top = this.getLayoutProperties().top;
        var left = this.getLayoutProperties().left; // Adding the slidebar must be deferred because this call can happen
        // during the layout flush, which make it impossible to move existing
        // layout to the slidebar

        if (top < 0) {
          this._assertSlideBar(function () {
            this.setHeight(menuBounds.height + top);
            this.moveTo(left, 0);
          });
        } else if (top + menuBounds.height > rootHeight) {
          this._assertSlideBar(function () {
            this.setHeight(rootHeight - top);
          });
        } else {
          this.setHeight(null);
        }
      },

      /**
       * Schedules the addition of the slidebar and calls the given callback
       * after the slidebar has been added.
       *
       * @param callback {Function} the callback to call
       * @return {var|undefined} The return value of the callback if the slidebar
       * already exists, or <code>undefined</code> if it doesn't
       */
      _assertSlideBar: function _assertSlideBar(callback) {
        if (this.hasChildControl("slidebar")) {
          return callback.call(this);
        }

        this.__onAfterSlideBarAdd__P_446_1 = callback;
        qx.ui.core.queue.Widget.add(this);
      },
      // overridden
      syncWidget: function syncWidget(jobs) {
        this.getChildControl("slidebar");

        if (this.__onAfterSlideBarAdd__P_446_1) {
          this.__onAfterSlideBarAdd__P_446_1.call(this);

          delete this.__onAfterSlideBarAdd__P_446_1;
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Update position if the menu or the root is resized
       */
      _onResize: function _onResize() {
        if (this.isVisible()) {
          var target = this._placementTarget;

          if (!target) {
            return;
          } else if (target instanceof qx.ui.core.Widget) {
            this.placeToWidget(target, true);
          } else if (target.top !== undefined) {
            this.placeToPoint(target);
          } else {
            throw new Error("Unknown target: " + target);
          }

          this.__updateSlideBar__P_446_2();
        }
      },

      /**
       * Event listener for pointerover event.
       *
       * @param e {qx.event.type.Pointer} pointerover event
       */
      _onPointerOver: function _onPointerOver(e) {
        // Cache manager
        var mgr = qx.ui.menu.Manager.getInstance(); // Be sure this menu is kept

        mgr.cancelClose(this); // Change selection

        var target = e.getTarget();

        if (target.isEnabled() && target instanceof qx.ui.menu.AbstractButton) {
          // Select button directly
          this.setSelectedButton(target);
          var subMenu = target.getMenu && target.getMenu();

          if (subMenu) {
            subMenu.setOpener(target); // Finally schedule for opening

            mgr.scheduleOpen(subMenu); // Remember scheduled menu for opening

            this.__scheduledOpen__P_446_0 = subMenu;
          } else {
            var opened = this.getOpenedButton();

            if (opened) {
              mgr.scheduleClose(opened.getMenu());
            }

            if (this.__scheduledOpen__P_446_0) {
              mgr.cancelOpen(this.__scheduledOpen__P_446_0);
              this.__scheduledOpen__P_446_0 = null;
            }
          }
        } else if (!this.getOpenedButton()) {
          // When no button is opened reset the selection
          // Otherwise keep it
          this.resetSelectedButton();
        }
      },

      /**
       * Event listener for pointerout event.
       *
       * @param e {qx.event.type.Pointer} pointerout event
       */
      _onPointerOut: function _onPointerOut(e) {
        // Cache manager
        var mgr = qx.ui.menu.Manager.getInstance(); // Detect whether the related target is out of the menu

        if (!qx.ui.core.Widget.contains(this, e.getRelatedTarget())) {
          // Update selected property
          // Force it to the open sub menu in cases where that is opened
          // Otherwise reset it. Menus which are left by the cursor should
          // not show any selection.
          var opened = this.getOpenedButton();
          opened ? this.setSelectedButton(opened) : this.resetSelectedButton(); // Cancel a pending close request for the currently
          // opened sub menu

          if (opened) {
            mgr.cancelClose(opened.getMenu());
          } // When leaving this menu to the outside, stop
          // all pending requests to open any other sub menu


          if (this.__scheduledOpen__P_446_0) {
            mgr.cancelOpen(this.__scheduledOpen__P_446_0);
          }
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (!qx.core.ObjectRegistry.inShutDown) {
        qx.ui.menu.Manager.getInstance().remove(this);
      }

      this.getApplicationRoot().removeListener("resize", this._onResize, this);
      this._placementTarget = null;

      this._disposeObjects("_blocker");
    }
  });
  qx.ui.menu.Menu.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.menu.ButtonLayout": {
        "construct": true
      },
      "qx.ui.basic.Image": {},
      "qx.ui.basic.Label": {},
      "qx.event.Timer": {},
      "qx.ui.menu.Manager": {},
      "qx.locale.Manager": {},
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The abstract menu button class is used for all type of menu content
   * for example normal buttons, checkboxes or radiobuttons.
   *
   * @childControl icon {qx.ui.basic.Image} icon of the button
   * @childControl label {qx.ui.basic.Label} label of the button
   * @childControl shortcut {qx.ui.basic.Label} shows if specified the shortcut
   * @childControl arrow {qx.ui.basic.Image} shows the arrow to show an additional widget (e.g. popup or submenu)
   */
  qx.Class.define("qx.ui.menu.AbstractButton", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MExecutable],
    implement: [qx.ui.form.IExecutable],
    type: "abstract",

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // Use hard coded layout

      this._setLayout(new qx.ui.menu.ButtonLayout()); // Add listeners


      this.addListener("tap", this._onTap);
      this.addListener("keypress", this._onKeyPress); // Add command listener

      this.addListener("changeCommand", this._onChangeCommand, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      blockToolTip: {
        refine: true,
        init: true
      },

      /** The label text of the button */
      label: {
        check: "String",
        apply: "_applyLabel",
        nullable: true,
        event: "changeLabel"
      },

      /** Whether a sub menu should be shown and which one */
      menu: {
        check: "qx.ui.menu.Menu",
        apply: "_applyMenu",
        nullable: true,
        dereference: true,
        event: "changeMenu"
      },

      /** The icon to use */
      icon: {
        check: "String",
        apply: "_applyIcon",
        themeable: true,
        nullable: true,
        event: "changeIcon"
      },

      /** Indicates whether the label for the command (shortcut) should be visible or not. */
      showCommandLabel: {
        check: "Boolean",
        apply: "_applyShowCommandLabel",
        themeable: true,
        init: true,
        event: "changeShowCommandLabel"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "icon":
            control = new qx.ui.basic.Image();
            control.setAnonymous(true);

            this._add(control, {
              column: 0
            });

            break;

          case "label":
            control = new qx.ui.basic.Label();
            control.setAnonymous(true);

            this._add(control, {
              column: 1
            });

            break;

          case "shortcut":
            control = new qx.ui.basic.Label();
            control.setAnonymous(true);

            if (!this.getShowCommandLabel()) {
              control.exclude();
            }

            this._add(control, {
              column: 2
            });

            break;

          case "arrow":
            control = new qx.ui.basic.Image();
            control.setAnonymous(true);

            this._add(control, {
              column: 3
            });

            break;
        }

        return control || qx.ui.menu.AbstractButton.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        selected: 1
      },

      /*
      ---------------------------------------------------------------------------
        LAYOUT UTILS
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the dimensions of all children
       *
       * @return {Array} Preferred width of each child
       */
      getChildrenSizes: function getChildrenSizes() {
        var iconWidth = 0,
            labelWidth = 0,
            shortcutWidth = 0,
            arrowWidth = 0;

        if (this._isChildControlVisible("icon")) {
          var icon = this.getChildControl("icon");
          iconWidth = icon.getMarginLeft() + icon.getSizeHint().width + icon.getMarginRight();
        }

        if (this._isChildControlVisible("label")) {
          var label = this.getChildControl("label");
          labelWidth = label.getMarginLeft() + label.getSizeHint().width + label.getMarginRight();
        }

        if (this._isChildControlVisible("shortcut")) {
          var shortcut = this.getChildControl("shortcut");
          shortcutWidth = shortcut.getMarginLeft() + shortcut.getSizeHint().width + shortcut.getMarginRight();
        }

        if (this._isChildControlVisible("arrow")) {
          var arrow = this.getChildControl("arrow");
          arrowWidth = arrow.getMarginLeft() + arrow.getSizeHint().width + arrow.getMarginRight();
        }

        return [iconWidth, labelWidth, shortcutWidth, arrowWidth];
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for tap
       *
       * @param e {qx.event.type.Pointer} pointer event
       */
      _onTap: function _onTap(e) {
        if (e.isLeftPressed()) {
          this.execute();
          qx.event.Timer.once(qx.ui.menu.Manager.getInstance().hideAll, qx.ui.menu.Manager.getInstance(), 0);
        } // right click
        else {
            // only prevent contextmenu event if button has no further context menu.
            if (!this.getContextMenu()) {
              qx.ui.menu.Manager.getInstance().preventContextMenuOnce();
            }
          }
      },

      /**
       * Event listener for keypress event
       *
       * @param e {qx.event.type.KeySequence} keypress event
       */
      _onKeyPress: function _onKeyPress(e) {
        this.execute();
      },

      /**
       * Event listener for command changes. Updates the text of the shortcut.
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onChangeCommand: function _onChangeCommand(e) {
        var command = e.getData(); // do nothing if no command is set

        if (command == null) {
          return;
        }

        {
          var oldCommand = e.getOldData();

          if (!oldCommand) {
            qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
          }

          if (!command) {
            qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
          }
        }
        var cmdString = command != null ? command.toString() : "";
        this.getChildControl("shortcut").setValue(cmdString);
      },

      /**
       * Update command string on locale changes
       */
      _onChangeLocale: function _onChangeLocale(e) {
        var command = this.getCommand();

        if (command != null) {
          this.getChildControl("shortcut").setValue(command.toString());
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        if (value) {
          this._showChildControl("icon").setSource(value);
        } else {
          this._excludeChildControl("icon");
        }
      },
      // property apply
      _applyLabel: function _applyLabel(value, old) {
        if (value) {
          this._showChildControl("label").setValue(value);
        } else {
          this._excludeChildControl("label");
        }
      },
      // property apply
      _applyMenu: function _applyMenu(value, old) {
        if (old) {
          old.resetOpener();
          old.removeState("submenu");
        }

        if (value) {
          this._showChildControl("arrow");

          value.setOpener(this);
          value.addState("submenu");
        } else {
          this._excludeChildControl("arrow");
        }
      },
      // property apply
      _applyShowCommandLabel: function _applyShowCommandLabel(value, old) {
        if (value) {
          this._showChildControl("shortcut");
        } else {
          this._excludeChildControl("shortcut");
        }
      }
    },

    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct: function destruct() {
      this.removeListener("changeCommand", this._onChangeCommand, this);

      if (this.getMenu()) {
        if (!qx.core.ObjectRegistry.inShutDown) {
          this.getMenu().destroy();
        }
      }

      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
    }
  });
  qx.ui.menu.AbstractButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.MenuButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.toolbar.ToolBar": {},
      "qx.ui.menu.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A menubar button
   */
  qx.Class.define("qx.ui.menubar.Button", {
    extend: qx.ui.form.MenuButton,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct(label, icon, menu) {
      qx.ui.form.MenuButton.constructor.call(this, label, icon, menu);
      this.removeListener("keydown", this._onKeyDown);
      this.removeListener("keyup", this._onKeyUp);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "menubar-button"
      },
      show: {
        refine: true,
        init: "inherit"
      },
      focusable: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Inspects the parent chain to find the MenuBar
       *
       * @return {qx.ui.menubar.MenuBar} MenuBar instance or <code>null</code>.
       */
      getMenuBar: function getMenuBar() {
        var parent = this;

        while (parent) {
          /* this method is also used by toolbar.MenuButton, so we need to check
             for a ToolBar instance. */
          if (parent instanceof qx.ui.toolbar.ToolBar) {
            return parent;
          }

          parent = parent.getLayoutParent();
        }

        return null;
      },
      // overridden
      open: function open(selectFirst) {
        qx.ui.menubar.Button.prototype.open.base.call(this, selectFirst);
        var menubar = this.getMenuBar();

        if (menubar) {
          menubar._setAllowMenuOpenHover(true);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Listener for visibility property changes of the attached menu
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onMenuChange: function _onMenuChange(e) {
        var menu = this.getMenu();
        var menubar = this.getMenuBar();

        if (menu.isVisible()) {
          this.addState("pressed"); // Sync with open menu property

          if (menubar) {
            menubar.setOpenMenu(menu);
          }
        } else {
          this.removeState("pressed"); // Sync with open menu property

          if (menubar && menubar.getOpenMenu() == menu) {
            menubar.resetOpenMenu();

            menubar._setAllowMenuOpenHover(false);
          }
        }
      },
      // overridden
      _onPointerUp: function _onPointerUp(e) {
        qx.ui.menubar.Button.prototype._onPointerUp.base.call(this, e); // Set state 'pressed' to visualize that the menu is open.


        var menu = this.getMenu();

        if (menu && menu.isVisible() && !this.hasState("pressed")) {
          this.addState("pressed");
        }
      },

      /**
       * Event listener for pointerover event
       *
       * @param e {qx.event.type.Pointer} pointerover event object
       */
      _onPointerOver: function _onPointerOver(e) {
        // Add hovered state
        this.addState("hovered"); // Open submenu

        if (this.getMenu() && e.getPointerType() == "mouse") {
          var menubar = this.getMenuBar();

          if (menubar && menubar._isAllowMenuOpenHover()) {
            // Hide all open menus
            qx.ui.menu.Manager.getInstance().hideAll(); // Set it again, because hideAll remove it.

            menubar._setAllowMenuOpenHover(true); // Then show the attached menu


            if (this.isEnabled()) {
              this.open();
            }
          }
        }
      }
    }
  });
  qx.ui.menubar.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "require": true
      },
      "qx.lang.Array": {},
      "qx.ui.layout.Util": {},
      "qx.ui.menu.Menu": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Layout used for the menu buttons which may contain four elements. A icon,
   * a label, a shortcut text and an arrow (for a sub menu)
   *
   * @internal
   */
  qx.Class.define("qx.ui.menu.ButtonLayout", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        this.assert(name == "column", "The property '" + name + "' is not supported by the MenuButton layout!");
      },
      // overridden
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        var children = this._getLayoutChildren();

        var child;
        var column;
        var columnChildren = [];

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];
          column = child.getLayoutProperties().column;
          columnChildren[column] = child;
        }

        var menu = this.__getMenu__P_443_0(children[0]);

        var columns = menu.getColumnSizes();
        var spacing = menu.getSpacingX(); // stretch label column

        var neededWidth = qx.lang.Array.sum(columns) + spacing * (columns.length - 1);

        if (neededWidth < availWidth) {
          columns[1] += availWidth - neededWidth;
        }

        var left = padding.left,
            top = padding.top;
        var Util = qx.ui.layout.Util;

        for (var i = 0, l = columns.length; i < l; i++) {
          child = columnChildren[i];

          if (child) {
            var hint = child.getSizeHint();
            var childTop = top + Util.computeVerticalAlignOffset(child.getAlignY() || "middle", hint.height, availHeight, 0, 0);
            var offsetLeft = Util.computeHorizontalAlignOffset(child.getAlignX() || "left", hint.width, columns[i], child.getMarginLeft(), child.getMarginRight());
            child.renderLayout(left + offsetLeft, childTop, hint.width, hint.height);
          }

          if (columns[i] > 0) {
            left += columns[i] + spacing;
          }
        }
      },

      /**
       * Get the widget's menu
       *
       * @param widget {qx.ui.core.Widget} the widget to get the menu for
       * @return {qx.ui.menu.Menu} the menu
       */
      __getMenu__P_443_0: function __getMenu__P_443_0(widget) {
        while (!(widget instanceof qx.ui.menu.Menu)) {
          widget = widget.getLayoutParent();
        }

        return widget;
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var children = this._getLayoutChildren();

        var neededHeight = 0;
        var neededWidth = 0;

        for (var i = 0, l = children.length; i < l; i++) {
          var hint = children[i].getSizeHint();
          neededWidth += hint.width;
          neededHeight = Math.max(neededHeight, hint.height);
        }

        return {
          width: neededWidth,
          height: neededHeight
        };
      }
    }
  });
  qx.ui.menu.ButtonLayout.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menu.AbstractButton": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The real menu button class which supports a command and an icon. All
   * other features are inherited from the {@link qx.ui.menu.AbstractButton}
   * class.
   */
  qx.Class.define("qx.ui.menu.Button", {
    extend: qx.ui.menu.AbstractButton,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Initial label
     * @param icon {String} Initial icon
     * @param command {qx.ui.command.Command} Initial command (shortcut)
     * @param menu {qx.ui.menu.Menu} Initial sub menu
     */
    construct: function construct(label, icon, command, menu) {
      qx.ui.menu.AbstractButton.constructor.call(this); // Initialize with incoming arguments

      if (label != null) {
        this.setLabel(label);
      }

      if (icon != null) {
        this.setIcon(icon);
      }

      if (command != null) {
        this.setCommand(command);
      }

      if (menu != null) {
        this.setMenu(menu);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "menu-button"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      // overridden
      _onTap: function _onTap(e) {
        if (e.isLeftPressed() && this.getMenu()) {
          this.execute(); // don't close menus if the button is a sub menu button

          this.getMenu().open();
          return;
        }

        qx.ui.menu.Button.prototype._onTap.base.call(this, e);
      }
    }
  });
  qx.ui.menu.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.VBox": {
        "require": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Layouter used by the qooxdoo menu's to render their buttons
   *
   * @internal
   */
  qx.Class.define("qx.ui.menu.Layout", {
    extend: qx.ui.layout.VBox,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Spacing between each cell on the menu buttons */
      columnSpacing: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /**
       * Whether a column and which column should automatically span
       * when the following cell is empty. Spanning may be disabled
       * through setting this property to <code>null</code>.
       */
      spanColumn: {
        check: "Integer",
        init: 1,
        nullable: true,
        apply: "_applyLayoutChange"
      },

      /** Default icon column width if no icons are rendered */
      iconColumnWidth: {
        check: "Integer",
        init: 0,
        themeable: true,
        apply: "_applyLayoutChange"
      },

      /** Default arrow column width if no sub menus are rendered */
      arrowColumnWidth: {
        check: "Integer",
        init: 0,
        themeable: true,
        apply: "_applyLayoutChange"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __columnSizes__P_444_0: null,

      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var children = this._getLayoutChildren();

        var child, sizes, spacing;
        var spanColumn = this.getSpanColumn();
        var columnSizes = this.__columnSizes__P_444_0 = [0, 0, 0, 0];
        var columnSpacing = this.getColumnSpacing();
        var spanColumnWidth = 0;
        var maxInset = 0; // Compute column sizes and insets

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (child.isAnonymous()) {
            continue;
          }

          sizes = child.getChildrenSizes();

          for (var column = 0; column < sizes.length; column++) {
            if (spanColumn != null && column == spanColumn && sizes[spanColumn + 1] == 0) {
              spanColumnWidth = Math.max(spanColumnWidth, sizes[column]);
            } else {
              columnSizes[column] = Math.max(columnSizes[column], sizes[column]);
            }
          }

          var insets = children[i].getInsets();
          maxInset = Math.max(maxInset, insets.left + insets.right);
        } // Fix label column width is cases where the maximum button with no shortcut
        // is larger than the maximum button with a shortcut


        if (spanColumn != null && columnSizes[spanColumn] + columnSpacing + columnSizes[spanColumn + 1] < spanColumnWidth) {
          columnSizes[spanColumn] = spanColumnWidth - columnSizes[spanColumn + 1] - columnSpacing;
        } // When merging the cells for label and shortcut
        // ignore the spacing between them


        if (spanColumnWidth == 0) {
          spacing = columnSpacing * 2;
        } else {
          spacing = columnSpacing * 3;
        } // Fix zero size icon column


        if (columnSizes[0] == 0) {
          columnSizes[0] = this.getIconColumnWidth();
        } // Fix zero size arrow column


        if (columnSizes[3] == 0) {
          columnSizes[3] = this.getArrowColumnWidth();
        }

        var height = qx.ui.menu.Layout.prototype._computeSizeHint.base.call(this).height; // Build hint


        return {
          minHeight: height,
          height: height,
          width: qx.lang.Array.sum(columnSizes) + maxInset + spacing
        };
      },

      /*
      ---------------------------------------------------------------------------
        CUSTOM ADDONS
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the column sizes detected during the pre-layout phase
       *
       * @return {Array} List of all column widths
       */
      getColumnSizes: function getColumnSizes() {
        return this.__columnSizes__P_444_0 || null;
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this.__columnSizes__P_444_0 = null;
    }
  });
  qx.ui.menu.Layout.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This widget draws a separator line between two instances of
   * {@link qx.ui.menu.AbstractButton} and is inserted into the
   * {@link qx.ui.menu.Menu}.
   *
   * For convenience reasons there is also
   * a method {@link qx.ui.menu.Menu#addSeparator} to append instances
   * of this class to the menu.
   */
  qx.Class.define("qx.ui.menu.Separator", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "menu-separator"
      },
      // overridden
      anonymous: {
        refine: true,
        init: true
      }
    }
  });
  qx.ui.menu.Separator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.SlideBar": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.HoverButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The MenuSlideBar is used to scroll menus if they don't fit on the screen.
   *
   * @childControl button-forward {qx.ui.form.HoverButton} scrolls forward of hovered
   * @childControl button-backward {qx.ui.form.HoverButton} scrolls backward if hovered
   *
   * @internal
   */
  qx.Class.define("qx.ui.menu.MenuSlideBar", {
    extend: qx.ui.container.SlideBar,
    construct: function construct() {
      qx.ui.container.SlideBar.constructor.call(this, "vertical");
    },
    properties: {
      appearance: {
        refine: true,
        init: "menu-slidebar"
      }
    },
    members: {
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "button-forward":
            control = new qx.ui.form.HoverButton();
            control.addListener("execute", this._onExecuteForward, this);

            this._addAt(control, 2);

            break;

          case "button-backward":
            control = new qx.ui.form.HoverButton();
            control.addListener("execute", this._onExecuteBackward, this);

            this._addAt(control, 0);

            break;
        }

        return control || qx.ui.menu.MenuSlideBar.prototype._createChildControlImpl.base.call(this, id);
      }
    }
  });
  qx.ui.menu.MenuSlideBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MChildrenHandling": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.util.PropertyUtil": {},
      "qx.ui.core.Spacer": {},
      "qx.ui.toolbar.Separator": {},
      "qx.ui.menubar.Button": {},
      "qx.ui.toolbar.Part": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The Toolbar class is the main part of the toolbar widget.
   *
   * It can handle added {@link Button}s, {@link CheckBox}es, {@link RadioButton}s
   * and {@link Separator}s in its {@link #add} method. The {@link #addSpacer} method
   * adds a spacer at the current toolbar position. This means that the widgets
   * added after the method call of {@link #addSpacer} are aligned to the right of
   * the toolbar.
   *
   * For more details on the documentation of the toolbar widget, take a look at the
   * documentation of the {@link qx.ui.toolbar}-Package.
   */
  qx.Class.define("qx.ui.toolbar.ToolBar", {
    extend: qx.ui.core.Widget,
    include: qx.ui.core.MChildrenHandling,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // add needed layout

      this._setLayout(new qx.ui.layout.HBox()); // initialize the overflow handling


      this.__removedItems__P_526_0 = [];
      this.__removePriority__P_526_1 = [];
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Appearance of the widget */
      appearance: {
        refine: true,
        init: "toolbar"
      },

      /** Holds the currently open menu (when the toolbar is used for menus) */
      openMenu: {
        check: "qx.ui.menu.Menu",
        event: "changeOpenMenu",
        nullable: true
      },

      /** Whether icons, labels, both or none should be shown. */
      show: {
        init: "both",
        check: ["both", "label", "icon"],
        inheritable: true,
        apply: "_applyShow",
        event: "changeShow"
      },

      /** The spacing between every child of the toolbar */
      spacing: {
        nullable: true,
        check: "Integer",
        themeable: true,
        apply: "_applySpacing"
      },

      /**
       * Widget which will be shown if at least one toolbar item is hidden.
       * Keep in mind to add this widget to the toolbar before you set it as
       * indicator!
       */
      overflowIndicator: {
        check: "qx.ui.core.Widget",
        nullable: true,
        apply: "_applyOverflowIndicator"
      },

      /** Enables the overflow handling which automatically removes items.*/
      overflowHandling: {
        init: false,
        check: "Boolean",
        apply: "_applyOverflowHandling"
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired if an item will be hidden by the {@link #overflowHandling}.*/
      "hideItem": "qx.event.type.Data",

      /** Fired if an item will be shown by the {@link #overflowHandling}.*/
      "showItem": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        OVERFLOW HANDLING
      ---------------------------------------------------------------------------
      */
      __removedItems__P_526_0: null,
      __removePriority__P_526_1: null,
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        // get the original hint
        var hint = qx.ui.toolbar.ToolBar.prototype._computeSizeHint.base.call(this);

        if (true && this.getOverflowHandling()) {
          var minWidth = 0; // if an overflow widget is given, use its width + spacing as min width

          var overflowWidget = this.getOverflowIndicator();

          if (overflowWidget) {
            minWidth = overflowWidget.getSizeHint().width + this.getSpacing();
          } // reset the minWidth because we reduce the count of elements


          hint.minWidth = minWidth;
        }

        return hint;
      },

      /**
       * Resize event handler.
       *
       * @param e {qx.event.type.Data} The resize event.
       */
      _onResize: function _onResize(e) {
        this._recalculateOverflow(e.getData().width);
      },

      /**
       * Responsible for calculation the overflow based on the available width.
       *
       * @param width {Integer?null} The available width.
       * @param requiredWidth {Integer?null} The required width for the widget
       *   if available.
       */
      _recalculateOverflow: function _recalculateOverflow(width, requiredWidth) {
        // do nothing if overflow handling is not enabled
        if (!this.getOverflowHandling()) {
          return;
        } // get all required sizes


        requiredWidth = requiredWidth || this.getSizeHint().width;
        var overflowWidget = this.getOverflowIndicator();
        var overflowWidgetWidth = 0;

        if (overflowWidget) {
          overflowWidgetWidth = overflowWidget.getSizeHint().width;
        }

        if (width == undefined && this.getBounds() != null) {
          width = this.getBounds().width;
        } // if we still don't have a width, than we are not added to a parent


        if (width == undefined) {
          // we should ignore it in that case
          return;
        } // if we have not enough space


        if (width < requiredWidth) {
          do {
            // get the next child
            var childToHide = this._getNextToHide(); // if there is no child to hide, just do nothing


            if (!childToHide) {
              return;
            } // get margins or spacing


            var margins = childToHide.getMarginLeft() + childToHide.getMarginRight();
            margins = Math.max(margins, this.getSpacing());
            var childWidth = childToHide.getSizeHint().width + margins;

            this.__hideChild__P_526_2(childToHide); // new width is the requiredWidth - the removed childs width


            requiredWidth -= childWidth; // show the overflowWidgetWidth

            if (overflowWidget && overflowWidget.getVisibility() != "visible") {
              overflowWidget.setVisibility("visible"); // if we need to add the overflow indicator, we need to add its width

              requiredWidth += overflowWidgetWidth; // add spacing or margins

              var overflowWidgetMargins = overflowWidget.getMarginLeft() + overflowWidget.getMarginRight();
              requiredWidth += Math.max(overflowWidgetMargins, this.getSpacing());
            }
          } while (requiredWidth > width); // if we can possibly show something

        } else if (this.__removedItems__P_526_0.length > 0) {
          do {
            var removedChild = this.__removedItems__P_526_0[0]; // if we have something we can show

            if (removedChild) {
              // get the margins or spacing
              var margins = removedChild.getMarginLeft() + removedChild.getMarginRight();
              margins = Math.max(margins, this.getSpacing()); // check if the element has been rendered before [BUG #4542]

              if (removedChild.getContentElement().getDomElement() == null) {
                // if not, apply the decorator element because it can change the
                // width of the child with padding e.g.
                removedChild.syncAppearance(); // also invalidate the layout cache to trigger size hint
                // recalculation

                removedChild.invalidateLayoutCache();
              }

              var removedChildWidth = removedChild.getSizeHint().width; // check if it fits in in case its the last child to replace

              var fits = false; // if we can remove the overflow widget if its available

              if (this.__removedItems__P_526_0.length == 1 && overflowWidgetWidth > 0) {
                var addedMargin = margins - this.getSpacing();
                var wouldRequiredWidth = requiredWidth - overflowWidgetWidth + removedChildWidth + addedMargin;
                fits = width > wouldRequiredWidth;
              } // if it just fits in || it fits in when we remove the overflow widget


              if (width > requiredWidth + removedChildWidth + margins || fits) {
                this.__showChild__P_526_3(removedChild);

                requiredWidth += removedChildWidth; // check if we need to remove the overflow widget

                if (overflowWidget && this.__removedItems__P_526_0.length == 0) {
                  overflowWidget.setVisibility("excluded");
                }
              } else {
                return;
              }
            }
          } while (width >= requiredWidth && this.__removedItems__P_526_0.length > 0);
        }
      },

      /**
       * Helper to show a toolbar item.
       *
       * @param child {qx.ui.core.Widget} The widget to show.
       */
      __showChild__P_526_3: function __showChild__P_526_3(child) {
        child.setVisibility("visible");

        this.__removedItems__P_526_0.shift();

        this.fireDataEvent("showItem", child);
      },

      /**
       * Helper to exclude a toolbar item.
       *
       * @param child {qx.ui.core.Widget} The widget to exclude.
       */
      __hideChild__P_526_2: function __hideChild__P_526_2(child) {
        // ignore the call if no child is given
        if (!child) {
          return;
        }

        this.__removedItems__P_526_0.unshift(child);

        child.setVisibility("excluded");
        this.fireDataEvent("hideItem", child);
      },

      /**
       * Responsible for returning the next item to remove. In It checks the
       * priorities added by {@link #setRemovePriority}. If all priorized widgets
       * already excluded, it takes the widget added at last.
       *
       * @return {qx.ui.core.Widget|null} The widget which should be removed next.
       *   If null is returned, no widget is available to remove.
       */
      _getNextToHide: function _getNextToHide() {
        // get the elements by priority
        for (var i = this.__removePriority__P_526_1.length - 1; i >= 0; i--) {
          var item = this.__removePriority__P_526_1[i]; // maybe a priority is left out and spacers don't have the visibility

          if (item && item.getVisibility && item.getVisibility() == "visible") {
            return item;
          }
        }

        ; // if there is non found by priority, check all available widgets

        var children = this._getChildren();

        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i]; // ignore the overflow widget

          if (child == this.getOverflowIndicator()) {
            continue;
          } // spacer don't have the visibility


          if (child.getVisibility && child.getVisibility() == "visible") {
            return child;
          }
        }

        ;
      },

      /**
       * The removal of the toolbar items is priority based. You can change these
       * priorities with this method. The higher a priority, the earlier it will
       * be excluded. Remember to use every priority only once! If you want
       * override an already set priority, use the override parameter.
       * Keep in mind to only use already added items.
       *
       * @param item {qx.ui.core.Widget} The item to give the priority.
       * @param priority {Integer} The priority, higher means removed earlier.
       * @param override {Boolean} true, if the priority should be overridden.
       */
      setRemovePriority: function setRemovePriority(item, priority, override) {
        // security check for overriding priorities
        if (!override && this.__removePriority__P_526_1[priority] != undefined) {
          throw new Error("Priority already in use!");
        }

        this.__removePriority__P_526_1[priority] = item;
      },
      // property apply
      _applyOverflowHandling: function _applyOverflowHandling(value, old) {
        // invalidate the own and the parents layout cache because the size hint changes
        this.invalidateLayoutCache();
        var parent = this.getLayoutParent();

        if (parent) {
          parent.invalidateLayoutCache();
        } // recalculate if possible


        var bounds = this.getBounds();

        if (bounds && bounds.width) {
          this._recalculateOverflow(bounds.width);
        } // if the handling has been enabled


        if (value) {
          // add the resize listener
          this.addListener("resize", this._onResize, this); // if the handles has been disabled
        } else {
          this.removeListener("resize", this._onResize, this); // set the overflow indicator to excluded

          var overflowIndicator = this.getOverflowIndicator();

          if (overflowIndicator) {
            overflowIndicator.setVisibility("excluded");
          } // set all buttons back to visible


          for (var i = 0; i < this.__removedItems__P_526_0.length; i++) {
            this.__removedItems__P_526_0[i].setVisibility("visible");
          }

          ; // reset the removed items

          this.__removedItems__P_526_0 = [];
        }
      },
      // property apply
      _applyOverflowIndicator: function _applyOverflowIndicator(value, old) {
        if (old) {
          this._remove(old);
        }

        if (value) {
          // check if its a child of the toolbar
          if (this._indexOf(value) == -1) {
            throw new Error("Widget must be child of the toolbar.");
          } // hide the widget


          value.setVisibility("excluded");
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU OPEN
      ---------------------------------------------------------------------------
      */
      __allowMenuOpenHover__P_526_4: false,

      /**
       * Indicate if a menu could be opened on hover or not.
       *
       * @internal
       * @param value {Boolean} <code>true</code> if a menu could be opened,
       *    <code>false</code> otherwise.
       */
      _setAllowMenuOpenHover: function _setAllowMenuOpenHover(value) {
        this.__allowMenuOpenHover__P_526_4 = value;
      },

      /**
       * Return if a menu could be opened on hover or not.
       *
       * @internal
       * @return {Boolean} <code>true</code> if a menu could be opened,
       *    <code>false</code> otherwise.
       */
      _isAllowMenuOpenHover: function _isAllowMenuOpenHover() {
        return this.__allowMenuOpenHover__P_526_4;
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applySpacing: function _applySpacing(value, old) {
        var layout = this._getLayout();

        value == null ? layout.resetSpacing() : layout.setSpacing(value);
      },
      // property apply
      _applyShow: function _applyShow(value) {
        var children = this._getChildren();

        for (var i = 0; i < children.length; i++) {
          if (children[i].setShow) {
            children[i].setShow(value);
          }
        }

        ;
      },

      /*
      ---------------------------------------------------------------------------
        CHILD HANDLING
      ---------------------------------------------------------------------------
      */
      // overridden
      _add: function _add(child, options) {
        qx.ui.toolbar.ToolBar.prototype._add.base.call(this, child, options); // sync the show property (bug #6743) - but only if show wasn't explicitly set for the child (bug #6823)


        if (child.setShow && !qx.util.PropertyUtil.getUserValue(child, "show")) {
          child.setShow(this.getShow());
        }

        var newWidth = this.getSizeHint().width + child.getSizeHint().width + 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);
      },
      // overridden
      _addAt: function _addAt(child, index, options) {
        qx.ui.toolbar.ToolBar.prototype._addAt.base.call(this, child, index, options); // sync the show property (bug #6743) - but only if show wasn't explicitly set for the child (bug #6823)


        if (child.setShow && !qx.util.PropertyUtil.getUserValue(child, "show")) {
          child.setShow(this.getShow());
        }

        var newWidth = this.getSizeHint().width + child.getSizeHint().width + 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);
      },
      // overridden
      _addBefore: function _addBefore(child, before, options) {
        qx.ui.toolbar.ToolBar.prototype._addBefore.base.call(this, child, before, options); // sync the show property (bug #6743) - but only if show wasn't explicitly set for the child (bug #6823)


        if (child.setShow && !qx.util.PropertyUtil.getUserValue(child, "show")) {
          child.setShow(this.getShow());
        }

        var newWidth = this.getSizeHint().width + child.getSizeHint().width + 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);
      },
      // overridden
      _addAfter: function _addAfter(child, after, options) {
        qx.ui.toolbar.ToolBar.prototype._addAfter.base.call(this, child, after, options); // sync the show property (bug #6743) - but only if show wasn't explicitly set for the child (bug #6823)


        if (child.setShow && !qx.util.PropertyUtil.getUserValue(child, "show")) {
          child.setShow(this.getShow());
        }

        var newWidth = this.getSizeHint().width + child.getSizeHint().width + 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);
      },
      // overridden
      _remove: function _remove(child) {
        qx.ui.toolbar.ToolBar.prototype._remove.base.call(this, child);

        var newWidth = this.getSizeHint().width - child.getSizeHint().width - 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);
      },
      // overridden
      _removeAt: function _removeAt(index) {
        var child = this._getChildren()[index];

        qx.ui.toolbar.ToolBar.prototype._removeAt.base.call(this, index);

        var newWidth = this.getSizeHint().width - child.getSizeHint().width - 2 * this.getSpacing();

        this._recalculateOverflow(null, newWidth);

        return child;
      },
      // overridden
      _removeAll: function _removeAll() {
        var children = qx.ui.toolbar.ToolBar.prototype._removeAll.base.call(this);

        this._recalculateOverflow(null, 0);

        return children;
      },

      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */

      /**
       * Add a spacer to the toolbar. The spacer has a flex
       * value of one and will stretch to the available space.
       *
       * @return {qx.ui.core.Spacer} The newly added spacer object. A reference
       *   to the spacer is needed to remove this spacer from the layout.
       */
      addSpacer: function addSpacer() {
        var spacer = new qx.ui.core.Spacer();

        this._add(spacer, {
          flex: 1
        });

        return spacer;
      },

      /**
       * Adds a separator to the toolbar.
       */
      addSeparator: function addSeparator() {
        this.add(new qx.ui.toolbar.Separator());
      },

      /**
       * Returns all nested buttons which contains a menu to show. This is mainly
       * used for keyboard support.
       *
       * @return {Array} List of all menu buttons
       */
      getMenuButtons: function getMenuButtons() {
        var children = this.getChildren();
        var buttons = [];
        var child;

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (child instanceof qx.ui.menubar.Button) {
            buttons.push(child);
          } else if (child instanceof qx.ui.toolbar.Part) {
            buttons.push.apply(buttons, child.getMenuButtons());
          }
        }

        return buttons;
      }
    },
    destruct: function destruct() {
      if (this.hasListener("resize")) {
        this.removeListener("resize", this._onResize, this);
      }
    }
  });
  qx.ui.toolbar.ToolBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A widget used for decoration proposes to structure a toolbar. Each
   * Separator renders a line between the buttons around.
   */
  qx.Class.define("qx.ui.toolbar.Separator", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "toolbar-separator"
      },
      // overridden
      anonymous: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 0
      },
      // overridden
      height: {
        refine: true,
        init: 0
      }
    }
  });
  qx.ui.toolbar.Separator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MRemoteChildrenHandling": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.basic.Image": {},
      "qx.ui.toolbar.PartContainer": {},
      "qx.ui.toolbar.Separator": {},
      "qx.ui.menubar.Button": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A part is a container for multiple toolbar buttons. Each part comes
   * with a handle which may be used in later versions to drag the part
   * around and move it to another position. Currently mainly used
   * for structuring large toolbars beyond the capabilities of the
   * {@link Separator}.
   *
   * @childControl handle {qx.ui.basic.Image} prat handle to visualize the separation
   * @childControl container {qx.ui.toolbar.PartContainer} holds the content of the toolbar part
   */
  qx.Class.define("qx.ui.toolbar.Part", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MRemoteChildrenHandling],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this); // Hard coded HBox layout

      this._setLayout(new qx.ui.layout.HBox()); // Force creation of the handle


      this._createChildControl("handle");
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "toolbar/part"
      },

      /** Whether icons, labels, both or none should be shown. */
      show: {
        init: "both",
        check: ["both", "label", "icon"],
        inheritable: true,
        event: "changeShow"
      },

      /** The spacing between every child of the toolbar */
      spacing: {
        nullable: true,
        check: "Integer",
        themeable: true,
        apply: "_applySpacing"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "handle":
            control = new qx.ui.basic.Image();
            control.setAlignY("middle");

            this._add(control);

            break;

          case "container":
            control = new qx.ui.toolbar.PartContainer();
            control.addListener("syncAppearance", this.__onSyncAppearance__P_525_0, this);

            this._add(control);

            control.addListener("changeChildren", function () {
              this.__onSyncAppearance__P_525_0();
            }, this);
            break;
        }

        return control || qx.ui.toolbar.Part.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden
      getChildrenContainer: function getChildrenContainer() {
        return this.getChildControl("container");
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      _applySpacing: function _applySpacing(value, old) {
        var layout = this.getChildControl("container").getLayout();
        value == null ? layout.resetSpacing() : layout.setSpacing(value);
      },

      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */

      /**
       * Helper which applies the left, right and middle states.
       */
      __onSyncAppearance__P_525_0: function __onSyncAppearance__P_525_0() {
        // check every child
        var children = this.getChildrenContainer().getChildren();
        children = children.filter(function (child) {
          return child.getVisibility() == "visible";
        });

        for (var i = 0; i < children.length; i++) {
          // if its the first child
          if (i == 0 && i != children.length - 1) {
            children[i].addState("left");
            children[i].removeState("right");
            children[i].removeState("middle"); // if its the last child
          } else if (i == children.length - 1 && i != 0) {
            children[i].addState("right");
            children[i].removeState("left");
            children[i].removeState("middle"); // if there is only one child
          } else if (i == 0 && i == children.length - 1) {
            children[i].removeState("left");
            children[i].removeState("middle");
            children[i].removeState("right");
          } else {
            children[i].addState("middle");
            children[i].removeState("right");
            children[i].removeState("left");
          }
        }

        ;
      },

      /**
       * Adds a separator to the toolbar part.
       */
      addSeparator: function addSeparator() {
        this.add(new qx.ui.toolbar.Separator());
      },

      /**
       * Returns all nested buttons which contains a menu to show. This is mainly
       * used for keyboard support.
       *
       * @return {Array} List of all menu buttons
       */
      getMenuButtons: function getMenuButtons() {
        var children = this.getChildren();
        var buttons = [];
        var child;

        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];

          if (child instanceof qx.ui.menubar.Button) {
            buttons.push(child);
          }
        }

        return buttons;
      }
    }
  });
  qx.ui.toolbar.Part.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.TextField": {
        "require": true
      },
      "qx.html.Input": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A password input field, which hides the entered text.
   */
  qx.Class.define("qx.ui.form.PasswordField", {
    extend: qx.ui.form.TextField,
    members: {
      // overridden
      _createInputElement: function _createInputElement() {
        return new qx.html.Input("password");
      }
    }
  });
  qx.ui.form.PasswordField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Button": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * Radio buttons can be used in radio groups to allow to the user to select
   * exactly one item from a list. Radio groups are established by adding
   * radio buttons to a radio manager {@link qx.ui.form.RadioGroup}.
   *
   * Example:
   * <pre class="javascript">
   *   var container = new qx.ui.container.Composite(new qx.ui.layout.VBox);
   *
   *   var female = new qx.ui.form.RadioButton("female");
   *   var male = new qx.ui.form.RadioButton("male");
   *
   *   var mgr = new qx.ui.form.RadioGroup();
   *   mgr.add(female, male);
   *
   *   container.add(male);
   *   container.add(female);
   * </pre>
   */
  qx.Class.define("qx.ui.form.RadioButton", {
    extend: qx.ui.form.Button,
    include: [qx.ui.form.MForm, qx.ui.form.MModelProperty],
    implement: [qx.ui.form.IRadioItem, qx.ui.form.IForm, qx.ui.form.IBooleanForm, qx.ui.form.IModel],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String?null} An optional label for the radio button.
     */
    construct: function construct(label) {
      {
        this.assertArgumentsCount(arguments, 0, 1);
      }
      qx.ui.form.Button.constructor.call(this, label); // Add listeners

      this.addListener("execute", this._onExecute);
      this.addListener("keypress", this._onKeyPress);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The assigned qx.ui.form.RadioGroup which handles the switching between registered buttons */
      group: {
        check: "qx.ui.form.RadioGroup",
        nullable: true,
        apply: "_applyGroup"
      },

      /** The value of the widget. True, if the widget is checked. */
      value: {
        check: "Boolean",
        nullable: true,
        event: "changeValue",
        apply: "_applyValue",
        init: false
      },
      // overridden
      appearance: {
        refine: true,
        init: "radiobutton"
      },
      // overridden
      allowGrowX: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        checked: true,
        focused: true,
        invalid: true,
        hovered: true
      },
      // overridden (from MExecutable to keep the icon out of the binding)

      /**
       * @lint ignoreReferenceField(_bindableProperties)
       */
      _bindableProperties: ["enabled", "label", "toolTipText", "value", "menu"],

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyValue: function _applyValue(value, old) {
        value ? this.addState("checked") : this.removeState("checked");
      },

      /** The assigned {@link qx.ui.form.RadioGroup} which handles the switching between registered buttons */
      _applyGroup: function _applyGroup(value, old) {
        if (old) {
          old.remove(this);
        }

        if (value) {
          value.add(this);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT-HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for the "execute" event.
       *
       * Sets the property "checked" to true.
       *
       * @param e {qx.event.type.Event} execute event
       */
      _onExecute: function _onExecute(e) {
        var grp = this.getGroup();

        if (grp && grp.getAllowEmptySelection()) {
          this.toggleValue();
        } else {
          this.setValue(true);
        }
      },

      /**
       * Event listener for the "keyPress" event.
       *
       * Selects the previous RadioButton when pressing "Left" or "Up" and
       * Selects the next RadioButton when pressing "Right" and "Down"
       *
       * @param e {qx.event.type.KeySequence} KeyPress event
       */
      _onKeyPress: function _onKeyPress(e) {
        var grp = this.getGroup();

        if (!grp) {
          return;
        }

        switch (e.getKeyIdentifier()) {
          case "Left":
          case "Up":
            grp.selectPrevious();
            break;

          case "Right":
          case "Down":
            grp.selectNext();
            break;
        }
      }
    }
  });
  qx.ui.form.RadioButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MLayoutHandling": {
        "require": true
      },
      "qx.ui.form.MModelSelection": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.core.ISingleSelection": {
        "require": true
      },
      "qx.ui.form.IModelSelection": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.form.RadioGroup": {
        "construct": true
      },
      "qx.ui.form.IRadioItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The radio container handles a collection of items from which only one item
   * can be selected. Selection another item will deselect the previously selected
   * item. For that, it uses the {@link qx.ui.form.RadioGroup} object.
   *
   * This class is used to create radio groups of {@link qx.ui.form.RadioButton}
   * instances.
   *
   * This widget takes care of the layout of the added items. If you want to
   * take full control of the layout and just use the selection behavior,
   * take a look at the {@link qx.ui.form.RadioGroup} object for a loose coupling.
   */
  qx.Class.define("qx.ui.form.RadioButtonGroup", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MLayoutHandling, qx.ui.form.MModelSelection],
    implement: [qx.ui.form.IForm, qx.ui.form.IField, qx.ui.core.ISingleSelection, qx.ui.form.IModelSelection],

    /**
     * @param layout {qx.ui.layout.Abstract} The new layout or
     *     <code>null</code> to reset the layout.
     */
    construct: function construct(layout) {
      qx.ui.core.Widget.constructor.call(this); // if no layout is given, use the default layout (VBox)

      if (layout == null) {
        this.setLayout(new qx.ui.layout.VBox(4));
      } else {
        this.setLayout(layout);
      } // create the radio group


      this.__radioGroup__P_418_0 = new qx.ui.form.RadioGroup(); // attach the listener

      this.__radioGroup__P_418_0.addListener("changeSelection", this._onChangeSelection, this);
    },
    properties: {
      /**
       * Flag signaling if the group at all is valid. All children will have the
       * same state.
       */
      valid: {
        check: "Boolean",
        init: true,
        apply: "_applyValid",
        event: "changeValid"
      },

      /**
       * Flag signaling if the group is required.
       */
      required: {
        check: "Boolean",
        init: false,
        event: "changeRequired"
      },

      /**
       * Message which is shown in an invalid tooltip.
       */
      invalidMessage: {
        check: "String",
        init: "",
        event: "changeInvalidMessage",
        apply: "_applyInvalidMessage"
      },

      /**
       * Message which is shown in an invalid tooltip if the {@link #required} is
       * set to true.
       */
      requiredInvalidMessage: {
        check: "String",
        nullable: true,
        event: "changeInvalidMessage"
      }
    },
    events: {
      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data",

      /**
       * Fires after the selection was modified
       */
      "changeSelection": "qx.event.type.Data"
    },
    members: {
      __radioGroup__P_418_0: null,

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyInvalidMessage: function _applyInvalidMessage(value, old) {
        var children = this._getChildren();

        for (var i = 0; i < children.length; i++) {
          children[i].setInvalidMessage(value);
        }
      },
      // property apply
      _applyValid: function _applyValid(value, old) {
        var children = this._getChildren();

        for (var i = 0; i < children.length; i++) {
          children[i].setValid(value);
        }
      },

      /*
      ---------------------------------------------------------------------------
        REGISTRY
      ---------------------------------------------------------------------------
      */

      /**
       * The internally used radio group instance will be returned.
       *
       * @return {qx.ui.form.RadioGroup} Returns the used RadioGroup instance.
       */
      getRadioGroup: function getRadioGroup() {
        return this.__radioGroup__P_418_0;
      },

      /**
       * Returns the children list
       *
       * @return {qx.ui.core.LayoutItem[]} The children array.
       */
      getChildren: function getChildren() {
        return this._getChildren();
      },

      /**
       * Adds a new child widget.
       *
       * The supported keys of the layout options map depend on the layout
       * used to position the widget. The options are documented in the class
       * documentation of each layout manager {@link qx.ui.layout}.
       *
       * @param child {qx.ui.core.LayoutItem} the widget to add.
       * @param options {Map?null} Optional layout data for widget.
       */
      add: function add(child, options) {
        this.__radioGroup__P_418_0.add(child);

        this._add(child, options);
      },

      /**
       * Remove the given child widget.
       *
       * @param child {qx.ui.core.LayoutItem} the widget to remove
       */
      remove: function remove(child) {
        this.__radioGroup__P_418_0.remove(child);

        this._remove(child);
      },

      /**
       * Remove all children.
       *
       * @return {Array} An array of {@link qx.ui.core.LayoutItem}'s.
       */
      removeAll: function removeAll() {
        // remove all children from the radio group
        var radioItems = this.__radioGroup__P_418_0.getItems();

        for (var i = radioItems.length - 1; i >= 0; i--) {
          this.__radioGroup__P_418_0.remove(radioItems[i]);
        }

        return this._removeAll();
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION
      ---------------------------------------------------------------------------
      */

      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {qx.ui.core.Widget[]} List of items.
       */
      getSelection: function getSelection() {
        return this.__radioGroup__P_418_0.getSelection();
      },

      /**
       * Replaces current selection with the given items.
       *
       * @param items {qx.ui.core.Widget[]} Items to select.
       * @throws {Error} if the item is not a child element.
       */
      setSelection: function setSelection(items) {
        this.__radioGroup__P_418_0.setSelection(items);
      },

      /**
       * Clears the whole selection at once.
       */
      resetSelection: function resetSelection() {
        this.__radioGroup__P_418_0.resetSelection();
      },

      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {qx.ui.core.Widget} Any valid selectable item
       * @return {Boolean} Whether the item is selected.
       * @throws {Error} if the item is not a child element.
       */
      isSelected: function isSelected(item) {
        return this.__radioGroup__P_418_0.isSelected(item);
      },

      /**
       * Whether the selection is empty.
       *
       * @return {Boolean} Whether the selection is empty.
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__radioGroup__P_418_0.isSelectionEmpty();
      },

      /**
       * Returns all elements which are selectable.
       *
       * @param all {Boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       * @return {qx.ui.core.Widget[]} The contained items.
       */
      getSelectables: function getSelectables(all) {
        return this.__radioGroup__P_418_0.getSelectables(all);
      },

      /**
       * Select given value.
       *
       * @param item {null|var} Item to set as selected value.
       * @return {null|Error} The status of this operation.
       */
      setValue: function setValue(item) {
        if (item && 'object' === typeof item && item instanceof qx.ui.form.IRadioItem) {
          return this.__radioGroup__P_418_0.setValue(item);
        } else {
          return new Error("can not select radio item from value");
        }
      },

      /**
       * @return {null|var} Returns the selected value.
       */
      getValue: function getValue() {
        return this.__radioGroup__P_418_0.getValue();
      },

      /**
       * Reset radio item selection.
       */
      resetValue: function resetValue() {
        this.__radioGroup__P_418_0.resetValue();
      },

      /**
       * Called on {@link qx.ui.form.RadioGroup} selection change event.
       *
       * @param event {qx.event.type.Data} Event containing the {@link qx.ui.form.RadioGroup} selection data.
       */
      _onChangeSelection: function _onChangeSelection(event) {
        this.fireDataEvent("changeValue", event.getData(), event.getOldData());
        this.fireDataEvent("changeSelection", event.getData(), event.getOldData());
      }
    },
    destruct: function destruct() {
      this.__radioGroup__P_418_0.removeListener("changeSelection", this._onChangeSelection, this);

      this._disposeObjects("__radioGroup__P_418_0");
    }
  });
  qx.ui.form.RadioButtonGroup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.AbstractSelectBox": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.ISingleSelection": {
        "require": true
      },
      "qx.ui.form.IModelSelection": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.core.MSingleSelectionHandling": {
        "require": true
      },
      "qx.ui.form.MModelSelection": {
        "require": true
      },
      "qx.ui.core.Spacer": {},
      "qx.ui.basic.Atom": {},
      "qx.ui.basic.Image": {},
      "qx.bom.Viewport": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A form widget which allows a single selection. Looks somewhat like
   * a normal button, but opens a list of items to select when tapping on it.
   *
   * Keep in mind that the SelectBox widget has always a selected item (due to the
   * single selection mode). Right after adding the first item a <code>changeSelection</code>
   * event is fired.
   *
   * <pre class='javascript'>
   * var selectBox = new qx.ui.form.SelectBox();
   *
   * selectBox.addListener("changeSelection", function(e) {
   *   // ...
   * });
   *
   * // now the 'changeSelection' event is fired
   * selectBox.add(new qx.ui.form.ListItem("Item 1"));
   * </pre>
   *
   * @childControl spacer {qx.ui.core.Spacer} flexible spacer widget
   * @childControl atom {qx.ui.basic.Atom} shows the text and icon of the content
   * @childControl arrow {qx.ui.basic.Image} shows the arrow to open the popup
   */
  qx.Class.define("qx.ui.form.SelectBox", {
    extend: qx.ui.form.AbstractSelectBox,
    implement: [qx.ui.core.ISingleSelection, qx.ui.form.IModelSelection, qx.ui.form.IField],
    include: [qx.ui.core.MSingleSelectionHandling, qx.ui.form.MModelSelection],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.form.AbstractSelectBox.constructor.call(this);

      this._createChildControl("atom");

      this._createChildControl("spacer");

      this._createChildControl("arrow"); // Register listener


      this.addListener("pointerover", this._onPointerOver, this);
      this.addListener("pointerout", this._onPointerOut, this);
      this.addListener("tap", this._onTap, this);
      this.addListener("keyinput", this._onKeyInput, this);
      this.addListener("changeSelection", this.__onChangeSelection__P_422_0, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "selectbox"
      },
      rich: {
        init: false,
        check: "Boolean",
        apply: "_applyRich"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.form.ListItem} instance */
      __preSelectedItem__P_422_1: null,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      _applyRich: function _applyRich(value, oldValue) {
        this.getChildControl("atom").setRich(value);
      },
      // overridden
      _defaultFormat: function _defaultFormat(item) {
        if (item) {
          if (typeof item.isRich == "function" && item.isRich()) {
            this.setRich(true);
          }

          return item.getLabel();
        }

        return null;
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "spacer":
            control = new qx.ui.core.Spacer();

            this._add(control, {
              flex: 1
            });

            break;

          case "atom":
            control = new qx.ui.basic.Atom(" ");
            control.setCenter(false);
            control.setAnonymous(true);

            this._add(control, {
              flex: 1
            });

            break;

          case "arrow":
            control = new qx.ui.basic.Image();
            control.setAnonymous(true);

            this._add(control);

            break;
        }

        return control || qx.ui.form.SelectBox.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS FOR SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the list items for the selection.
       *
       * @return {qx.ui.form.ListItem[]} List items to select.
       */
      _getItems: function _getItems() {
        return this.getChildrenContainer().getChildren();
      },

      /**
       * Returns if the selection could be empty or not.
       *
       * @return {Boolean} <code>true</code> If selection could be empty,
       *    <code>false</code> otherwise.
       */
      _isAllowEmptySelection: function _isAllowEmptySelection() {
        return this.getChildrenContainer().getSelectionMode() !== "one";
      },

      /**
       * Event handler for <code>changeSelection</code>.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      __onChangeSelection__P_422_0: function __onChangeSelection__P_422_0(e) {
        var listItem = e.getData()[0];
        var list = this.getChildControl("list");

        if (list.getSelection()[0] != listItem) {
          if (listItem) {
            list.setSelection([listItem]);
          } else {
            list.resetSelection();
          }
        }

        this.__updateIcon__P_422_2();

        this.__updateLabel__P_422_3();
      },

      /**
       * Sets the icon inside the list to match the selected ListItem.
       */
      __updateIcon__P_422_2: function __updateIcon__P_422_2() {
        var listItem = this.getChildControl("list").getSelection()[0];
        var atom = this.getChildControl("atom");
        var icon = listItem ? listItem.getIcon() : "";
        icon == null ? atom.resetIcon() : atom.setIcon(icon);
      },

      /**
       * Sets the label inside the list to match the selected ListItem.
       */
      __updateLabel__P_422_3: function __updateLabel__P_422_3() {
        var listItem = this.getChildControl("list").getSelection()[0];
        var atom = this.getChildControl("atom");
        var label = listItem ? listItem.getLabel() : "";
        var format = this.getFormat();

        if (format != null && listItem) {
          label = format.call(this, listItem);
        } // check for translation


        if (label && label.translate) {
          label = label.translate();
        }

        label == null ? atom.resetLabel() : atom.setLabel(label);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Listener method for "pointerover" event
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onPointerOver: function _onPointerOver(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
          this.addState("pressed");
        }

        this.addState("hovered");
      },

      /**
       * Listener method for "pointerout" event
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" and removes "pressed" state (if "pressed" state is set)</li>
       * </ul>
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onPointerOut: function _onPointerOut(e) {
        if (!this.isEnabled() || e.getTarget() !== this) {
          return;
        }

        this.removeState("hovered");

        if (this.hasState("pressed")) {
          this.removeState("pressed");
          this.addState("abandoned");
        }
      },

      /**
       * Toggles the popup's visibility.
       *
       * @param e {qx.event.type.Pointer} Pointer event
       */
      _onTap: function _onTap(e) {
        this.toggle();
      },
      // overridden
      _onKeyPress: function _onKeyPress(e) {
        var iden = e.getKeyIdentifier();

        if (iden == "Enter" || iden == "Space") {
          // Apply pre-selected item (translate quick selection to real selection)
          if (this.__preSelectedItem__P_422_1) {
            this.setSelection([this.__preSelectedItem__P_422_1]);
            this.__preSelectedItem__P_422_1 = null;
          }

          this.toggle();
        } else {
          qx.ui.form.SelectBox.prototype._onKeyPress.base.call(this, e);
        }
      },

      /**
       * Forwards key event to list widget.
       *
       * @param e {qx.event.type.KeyInput} Key event
       */
      _onKeyInput: function _onKeyInput(e) {
        // clone the event and re-calibrate the event
        var clone = e.clone();
        clone.setTarget(this._list);
        clone.setBubbles(false); // forward it to the list

        this.getChildControl("list").dispatchEvent(clone);
      },
      // overridden
      _onListPointerDown: function _onListPointerDown(e) {
        // Apply pre-selected item (translate quick selection to real selection)
        if (this.__preSelectedItem__P_422_1) {
          this.setSelection([this.__preSelectedItem__P_422_1]);
          this.__preSelectedItem__P_422_1 = null;
        }
      },
      // overridden
      _onListChangeSelection: function _onListChangeSelection(e) {
        var current = e.getData();
        var old = e.getOldData(); // Remove old listeners for icon and label changes.

        if (old && old.length > 0) {
          old[0].removeListener("changeIcon", this.__updateIcon__P_422_2, this);
          old[0].removeListener("changeLabel", this.__updateLabel__P_422_3, this);
        }

        if (current.length > 0) {
          // Ignore quick context (e.g. pointerover)
          // and configure the new value when closing the popup afterwards
          var popup = this.getChildControl("popup");
          var list = this.getChildControl("list");
          var context = list.getSelectionContext();

          if (popup.isVisible() && (context == "quick" || context == "key")) {
            this.__preSelectedItem__P_422_1 = current[0];
          } else {
            this.setSelection([current[0]]);
            this.__preSelectedItem__P_422_1 = null;
          } // Add listeners for icon and label changes


          current[0].addListener("changeIcon", this.__updateIcon__P_422_2, this);
          current[0].addListener("changeLabel", this.__updateLabel__P_422_3, this);
        } else {
          this.resetSelection();
        }
      },
      // overridden
      _onPopupChangeVisibility: function _onPopupChangeVisibility(e) {
        qx.ui.form.SelectBox.prototype._onPopupChangeVisibility.base.call(this, e); // Synchronize the current selection to the list selection
        // when the popup is closed. The list selection may be invalid
        // because of the quick selection handling which is not
        // directly applied to the selectbox


        var popup = this.getChildControl("popup");

        if (!popup.isVisible()) {
          var list = this.getChildControl("list"); // check if the list has any children before selecting

          if (list.hasChildren()) {
            list.setSelection(this.getSelection());
          }
        } else {
          // ensure that the list is never bigger that the max list height and
          // the available space in the viewport
          var distance = popup.getLayoutLocation(this);
          var viewPortHeight = qx.bom.Viewport.getHeight(); // distance to the bottom and top borders of the viewport

          var toTop = distance.top;
          var toBottom = viewPortHeight - distance.bottom;
          var availableHeigth = toTop > toBottom ? toTop : toBottom;
          var maxListHeight = this.getMaxListHeight();
          var list = this.getChildControl("list");

          if (maxListHeight == null || maxListHeight > availableHeigth) {
            list.setMaxHeight(availableHeigth);
          } else if (maxListHeight < availableHeigth) {
            list.setMaxHeight(maxListHeight);
          }
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__preSelectedItem__P_422_1 = null;
    }
  });
  qx.ui.form.SelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MExecutable": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.form.Button": {},
      "qx.ui.form.MenuButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A button which acts as a normal button and shows a menu on one
   * of the sides to open something like a history list.
   *
   * @childControl button {qx.ui.form.Button} button to execute action
   * @childControl arrow {qx.ui.form.MenuButton} arrow to open the popup
   */
  qx.Class.define("qx.ui.form.SplitButton", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.MExecutable],
    implement: [qx.ui.form.IExecutable],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Label to use
     * @param icon {String?null} Icon to use
     * @param menu {qx.ui.menu.Menu} Connect to menu instance
     * @param command {qx.ui.command.Command} Command instance to connect with
     */
    construct: function construct(label, icon, menu, command) {
      qx.ui.core.Widget.constructor.call(this);

      this._setLayout(new qx.ui.layout.HBox()); // Force arrow creation


      this._createChildControl("arrow"); // Add pointer listeners


      this.addListener("pointerover", this._onPointerOver, this, true);
      this.addListener("pointerout", this._onPointerOut, this, true); // Add key listeners

      this.addListener("keydown", this._onKeyDown);
      this.addListener("keyup", this._onKeyUp); // Process incoming arguments

      if (label != null) {
        this.setLabel(label);
      }

      if (icon != null) {
        this.setIcon(icon);
      }

      if (menu != null) {
        this.setMenu(menu);
      }

      if (command != null) {
        this.setCommand(command);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "splitbutton"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },

      /** The label/caption/text of the qx.ui.basic.Atom instance */
      label: {
        apply: "_applyLabel",
        nullable: true,
        check: "String"
      },

      /** Any URI String supported by qx.ui.basic.Image to display an icon */
      icon: {
        check: "String",
        apply: "_applyIcon",
        nullable: true,
        themeable: true
      },

      /**
       * Configure the visibility of the sub elements/widgets.
       * Possible values: both, text, icon
       */
      show: {
        init: "both",
        check: ["both", "label", "icon"],
        themeable: true,
        inheritable: true,
        apply: "_applyShow",
        event: "changeShow"
      },

      /** The menu instance to show when tapping on the button */
      menu: {
        check: "qx.ui.menu.Menu",
        nullable: true,
        apply: "_applyMenu",
        event: "changeMenu"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __cursorIsOut__P_425_0: null,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "button":
            control = new qx.ui.form.Button();
            control.addListener("execute", this._onButtonExecute, this);
            control.setFocusable(false);

            this._addAt(control, 0, {
              flex: 1
            });

            break;

          case "arrow":
            control = new qx.ui.form.MenuButton();
            control.setFocusable(false);
            control.setShow("both");

            this._addAt(control, 1);

            break;
        }

        return control || qx.ui.form.SplitButton.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        hovered: 1,
        focused: 1
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyLabel: function _applyLabel(value, old) {
        var button = this.getChildControl("button");
        value == null ? button.resetLabel() : button.setLabel(value);
      },
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        var button = this.getChildControl("button");
        value == null ? button.resetIcon() : button.setIcon(value);
      },
      // property apply
      _applyMenu: function _applyMenu(value, old) {
        var arrow = this.getChildControl("arrow");

        if (value) {
          arrow.resetEnabled();
          arrow.setMenu(value);
          value.setOpener(this);
          value.addListener("changeVisibility", this._onChangeMenuVisibility, this);
        } else {
          arrow.setEnabled(false);
          arrow.resetMenu();
        }

        if (old) {
          old.removeListener("changeVisibility", this._onChangeMenuVisibility, this);
          old.resetOpener();
        }
      },
      // property apply
      _applyShow: function _applyShow(value, old) {// pass: is already inherited to the button
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Listener for <code>pointerover</code> event
       *
       * @param e {qx.event.type.Pointer} pointerover event
       */
      _onPointerOver: function _onPointerOver(e) {
        // Captured listener
        // Whole stop for event, do not let the
        // inner buttons know about this event.
        e.stopPropagation(); // Add hover state, is forwarded to the buttons

        this.addState("hovered"); // Delete cursor out flag

        delete this.__cursorIsOut__P_425_0;
      },

      /**
       * Listener for <code>pointerout</code> event
       *
       * @param e {qx.event.type.Pointer} pointerout event
       */
      _onPointerOut: function _onPointerOut(e) {
        // Captured listener
        // Whole stop for event, do not let the
        // inner buttons know about this event.
        e.stopPropagation(); // First simple state check

        if (!this.hasState("hovered")) {
          return;
        } // Only when the related target is not part of the button


        var related = e.getRelatedTarget();

        if (qx.ui.core.Widget.contains(this, related)) {
          return;
        } // When the menu is visible (cursor moved to the menu)
        // keep the hover state on the whole button


        var menu = this.getMenu();

        if (menu && menu.isVisible()) {
          this.__cursorIsOut__P_425_0 = true;
          return;
        } // Finally remove state


        this.removeState("hovered");
      },

      /**
       * Event listener for all keyboard events
       *
       * @param e {qx.event.type.KeySequence} Event object
       */
      _onKeyDown: function _onKeyDown(e) {
        var button = this.getChildControl("button");

        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            button.removeState("abandoned");
            button.addState("pressed");
        }
      },

      /**
       * Event listener for all keyboard events
       *
       * @param e {qx.event.type.KeySequence} Event object
       */
      _onKeyUp: function _onKeyUp(e) {
        var button = this.getChildControl("button");

        switch (e.getKeyIdentifier()) {
          case "Enter":
          case "Space":
            if (button.hasState("pressed")) {
              button.removeState("abandoned");
              button.removeState("pressed");
              button.execute();
            }

        }
      },

      /**
       * Event listener for button's execute event.
       *
       * @param e {qx.event.type.Event} execute event of the button
       */
      _onButtonExecute: function _onButtonExecute(e) {
        // forward execute event
        this.execute();
      },

      /**
       * Event listener for visibility changes of the menu
       *
       * @param e {qx.event.type.Data} property change event
       */
      _onChangeMenuVisibility: function _onChangeMenuVisibility(e) {
        if (!this.getMenu().isVisible() && this.__cursorIsOut__P_425_0) {
          this.removeState("hovered");
        }
      }
    }
  });
  qx.ui.form.SplitButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.AbstractField": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.queue.Layout": {},
      "qx.ui.core.queue.Manager": {},
      "qx.html.Element": {},
      "qx.bom.client.Engine": {},
      "qx.bom.client.Browser": {},
      "qx.bom.Element": {},
      "qx.html.Input": {},
      "qx.bom.element.Dimension": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */

  /**
   * The TextField is a multi-line text input field.
   */
  qx.Class.define("qx.ui.form.TextArea", {
    extend: qx.ui.form.AbstractField,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {String?""} The text area's initial value
     */
    construct: function construct(value) {
      qx.ui.form.AbstractField.constructor.call(this, value);
      this.initWrap();
      this.addListener("roll", this._onRoll, this);
      this.addListener("resize", this._onResize, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Controls whether text wrap is activated or not. */
      wrap: {
        check: "Boolean",
        init: true,
        apply: "_applyWrap"
      },
      // overridden
      appearance: {
        refine: true,
        init: "textarea"
      },

      /** Factor for scrolling the <code>TextArea</code> with the mouse wheel. */
      singleStep: {
        check: "Integer",
        init: 20
      },

      /** Minimal line height. On default this is set to four lines. */
      minimalLineHeight: {
        check: "Integer",
        apply: "_applyMinimalLineHeight",
        init: 4
      },

      /**
      * Whether the <code>TextArea</code> should automatically adjust to
      * the height of the content.
      *
      * To set the initial height, modify {@link #minHeight}. If you wish
      * to set a minHeight below four lines of text, also set
      * {@link #minimalLineHeight}. In order to limit growing to a certain
      * height, set {@link #maxHeight} respectively. Please note that
      * autoSize is ignored when the {@link #height} property is in use.
      */
      autoSize: {
        check: "Boolean",
        apply: "_applyAutoSize",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __areaClone__P_426_0: null,
      __areaHeight__P_426_1: null,
      __originalAreaHeight__P_426_2: null,
      // overridden
      setValue: function setValue(value) {
        value = qx.ui.form.TextArea.prototype.setValue.base.call(this, value);

        this.__autoSize__P_426_3();

        return value;
      },

      /**
       * Handles the roll for scrolling the <code>TextArea</code>.
       *
       * @param e {qx.event.type.Roll} roll event.
       */
      _onRoll: function _onRoll(e) {
        // only wheel
        if (e.getPointerType() != "wheel") {
          return;
        }

        var contentElement = this.getContentElement();
        var scrollY = contentElement.getScrollY();
        contentElement.scrollToY(scrollY + e.getDelta().y / 30 * this.getSingleStep());
        var newScrollY = contentElement.getScrollY();

        if (newScrollY != scrollY) {
          e.stop();
        }
      },

      /**
       * When the element resizes we throw away the clone and trigger autosize again, otherwise the clone would have
       * another width and the autosize calculation would be faulty.
       * 
       * @param e {qx.event.type.Data} resize event.
       */
      _onResize: function _onResize(e) {
        if (this.__areaClone__P_426_0) {
          this.__areaClone__P_426_0.dispose();

          this.__areaClone__P_426_0 = null;

          this.__autoSize__P_426_3();
        }
      },

      /*
      ---------------------------------------------------------------------------
        AUTO SIZE
      ---------------------------------------------------------------------------
      */

      /**
      * Adjust height of <code>TextArea</code> so that content fits without scroll bar.
      *
      */
      __autoSize__P_426_3: function __autoSize__P_426_3() {
        if (this.isAutoSize()) {
          var clone = this.__getAreaClone__P_426_4();

          if (clone && this.getBounds()) {
            // Remember original area height
            this.__originalAreaHeight__P_426_2 = this.__originalAreaHeight__P_426_2 || this._getAreaHeight();

            var scrolledHeight = this._getScrolledAreaHeight(); // Show scroll-bar when above maxHeight, if defined


            if (this.getMaxHeight()) {
              var insets = this.getInsets();
              var innerMaxHeight = -insets.top + this.getMaxHeight() - insets.bottom;

              if (scrolledHeight > innerMaxHeight) {
                this.getContentElement().setStyle("overflowY", "auto");
              } else {
                this.getContentElement().setStyle("overflowY", "hidden");
              }
            } // Never shrink below original area height


            var desiredHeight = Math.max(scrolledHeight, this.__originalAreaHeight__P_426_2); // Set new height

            this._setAreaHeight(desiredHeight); // On init, the clone is not yet present. Try again on appear.

          } else {
            this.getContentElement().addListenerOnce("appear", function () {
              this.__autoSize__P_426_3();
            }, this);
          }
        }
      },

      /**
      * Get actual height of <code>TextArea</code>
      *
      * @return {Integer} Height of <code>TextArea</code>
      */
      _getAreaHeight: function _getAreaHeight() {
        return this.getInnerSize().height;
      },

      /**
      * Set actual height of <code>TextArea</code>
      *
      * @param height {Integer} Desired height of <code>TextArea</code>
      */
      _setAreaHeight: function _setAreaHeight(height) {
        if (this._getAreaHeight() !== height) {
          this.__areaHeight__P_426_1 = height;
          qx.ui.core.queue.Layout.add(this); // Apply height directly. This works-around a visual glitch in WebKit
          // browsers where a line-break causes the text to be moved upwards
          // for one line. Since this change appears instantly whereas the queue
          // is computed later, a flicker is visible.

          qx.ui.core.queue.Manager.flush();

          this.__forceRewrap__P_426_5();
        }
      },

      /**
      * Get scrolled area height. Equals the total height of the <code>TextArea</code>,
      * as if no scroll-bar was visible.
      *
      * @return {Integer} Height of scrolled area
      */
      _getScrolledAreaHeight: function _getScrolledAreaHeight() {
        var clone = this.__getAreaClone__P_426_4();

        var cloneDom = clone.getDomElement();

        if (cloneDom) {
          // Clone created but not yet in DOM. Try again.
          if (!cloneDom.parentNode) {
            qx.html.Element.flush();
            return this._getScrolledAreaHeight();
          } // In WebKit and IE8, "wrap" must have been "soft" on DOM level before setting
          // "off" can disable wrapping. To fix, make sure wrap is toggled.
          // Otherwise, the height of an auto-size text area with wrapping
          // disabled initially is incorrectly computed as if wrapping was enabled.


          if (qx.core.Environment.get("engine.name") === "webkit" || qx.core.Environment.get("engine.name") == "mshtml") {
            clone.setWrap(!this.getWrap(), true);
          }

          clone.setWrap(this.getWrap(), true); // Webkit needs overflow "hidden" in order to correctly compute height

          if (qx.core.Environment.get("engine.name") === "webkit" || qx.core.Environment.get("engine.name") == "mshtml") {
            cloneDom.style.overflow = "hidden";
          } // IE >= 8 needs overflow "visible" in order to correctly compute height


          if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") >= 8) {
            cloneDom.style.overflow = "visible";
            cloneDom.style.overflowX = "hidden";
          } // Update value


          clone.setValue(this.getValue() || ""); // Force IE > 8 to update size measurements

          if (qx.core.Environment.get("engine.name") == "mshtml") {
            cloneDom.style.height = "auto";
            qx.html.Element.flush();
            cloneDom.style.height = "0";
          } // Recompute


          this.__scrollCloneToBottom__P_426_6(clone);

          if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") == 8) {
            // Flush required for scrollTop to return correct value
            // when initial value should be taken into consideration
            if (!cloneDom.scrollTop) {
              qx.html.Element.flush();
            }
          }

          return cloneDom.scrollTop;
        }
      },

      /**
      * Returns the area clone.
      *
      * @return {Element|null} DOM Element or <code>null</code> if there is no
      * original element
      */
      __getAreaClone__P_426_4: function __getAreaClone__P_426_4() {
        this.__areaClone__P_426_0 = this.__areaClone__P_426_0 || this.__createAreaClone__P_426_7();
        return this.__areaClone__P_426_0;
      },

      /**
      * Creates and prepares the area clone.
      *
      * @return {Element} Element
      */
      __createAreaClone__P_426_7: function __createAreaClone__P_426_7() {
        var orig, clone, cloneDom, cloneHtml;
        orig = this.getContentElement(); // An existing DOM element is required

        if (!orig.getDomElement()) {
          return null;
        } // Create DOM clone


        cloneDom = qx.bom.Element.clone(orig.getDomElement()); // Convert to qx.html Element

        cloneHtml = new qx.html.Input("textarea");
        cloneHtml.useElement(cloneDom);
        clone = cloneHtml; // Push out of view
        // Zero height (i.e. scrolled area equals height)

        clone.setStyles({
          position: "absolute",
          top: 0,
          left: "-9999px",
          height: 0,
          overflow: "hidden"
        }, true); // Fix attributes

        clone.removeAttribute('id');
        clone.removeAttribute('name');
        clone.setAttribute("tabIndex", "-1"); // Copy value

        clone.setValue(orig.getValue() || ""); // Attach to DOM

        clone.insertBefore(orig); // Make sure scrollTop is actual height

        this.__scrollCloneToBottom__P_426_6(clone);

        return clone;
      },

      /**
      * Scroll <code>TextArea</code> to bottom. That way, scrollTop reflects the height
      * of the <code>TextArea</code>.
      *
      * @param clone {Element} The <code>TextArea</code> to scroll
      */
      __scrollCloneToBottom__P_426_6: function __scrollCloneToBottom__P_426_6(clone) {
        clone = clone.getDomElement();

        if (clone) {
          clone.scrollTop = 10000;
        }
      },

      /*
      ---------------------------------------------------------------------------
        FIELD API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createInputElement: function _createInputElement() {
        return new qx.html.Input("textarea", {
          overflowX: "auto",
          overflowY: "auto"
        });
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyWrap: function _applyWrap(value, old) {
        this.getContentElement().setWrap(value);

        if (this._placeholder) {
          var whiteSpace = value ? "normal" : "nowrap";

          this._placeholder.setStyle("whiteSpace", whiteSpace);
        }

        this.__autoSize__P_426_3();
      },
      // property apply
      _applyMinimalLineHeight: function _applyMinimalLineHeight() {
        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyAutoSize: function _applyAutoSize(value, old) {
        {
          this.__warnAutoSizeAndHeight__P_426_8();
        }

        if (value) {
          this.__autoSize__P_426_3();

          this.addListener("input", this.__autoSize__P_426_3, this); // This is done asynchronously on purpose. The style given would
          // otherwise be overridden by the DOM changes queued in the
          // property apply for wrap. See [BUG #4493] for more details.

          if (!this.getBounds()) {
            this.addListenerOnce("appear", function () {
              this.getContentElement().setStyle("overflowY", "hidden");
            });
          } else {
            this.getContentElement().setStyle("overflowY", "hidden");
          }
        } else {
          this.removeListener("input", this.__autoSize__P_426_3);
          this.getContentElement().setStyle("overflowY", "auto");
        }
      },
      // property apply
      _applyDimension: function _applyDimension(value) {
        qx.ui.form.TextArea.prototype._applyDimension.base.call(this);

        {
          this.__warnAutoSizeAndHeight__P_426_8();
        }

        if (value === this.getMaxHeight()) {
          this.__autoSize__P_426_3();
        }
      },

      /**
       * Force rewrapping of text.
       *
       * The distribution of characters depends on the space available.
       * Unfortunately, browsers do not reliably (or not at all) rewrap text when
       * the size of the text area changes.
       *
       * This method is called on change of the area's size.
       */
      __forceRewrap__P_426_5: function __forceRewrap__P_426_5() {
        var content = this.getContentElement();
        var element = content.getDomElement(); // Temporarily increase width

        var width = content.getStyle("width");
        content.setStyle("width", parseInt(width, 10) + 1000 + "px", true); // Force browser to render

        if (element) {
          qx.bom.element.Dimension.getWidth(element);
        } // Restore width


        content.setStyle("width", width, true);
      },

      /**
       * Warn when both autoSize and height property are set.
       *
       */
      __warnAutoSizeAndHeight__P_426_8: function __warnAutoSizeAndHeight__P_426_8() {
        if (this.isAutoSize() && this.getHeight()) {
          this.warn("autoSize is ignored when the height property is set. If you want to set an initial height, use the minHeight property instead.");
        }
      },

      /*
      ---------------------------------------------------------------------------
        LAYOUT
      ---------------------------------------------------------------------------
      */
      // overridden
      _getContentHint: function _getContentHint() {
        var hint = qx.ui.form.TextArea.prototype._getContentHint.base.call(this); // lines of text


        hint.height = hint.height * this.getMinimalLineHeight(); // 20 character wide

        hint.width = this._getTextSize().width * 20;

        if (this.isAutoSize()) {
          hint.height = this.__areaHeight__P_426_1 || hint.height;
        }

        return hint;
      }
    },
    destruct: function destruct() {
      this.setAutoSize(false);

      if (this.__areaClone__P_426_0) {
        this.__areaClone__P_426_0.dispose();
      }
    }
  });
  qx.ui.form.TextArea.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.ui.core.queue.Widget": {},
      "qx.ui.form.core.VirtualDropDownList": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Basic class for widgets which need a virtual list as popup for example a
   * SelectBox. It's basically supports a drop-down as popup with a virtual list
   * and the whole children management.
   *
   * @childControl dropdown {qx.ui.form.core.VirtualDropDownList} The drop-down list.
   */
  qx.Class.define("qx.ui.form.core.AbstractVirtualBox", {
    extend: qx.ui.core.Widget,
    include: qx.ui.form.MForm,
    implement: qx.ui.form.IForm,
    type: "abstract",

    /**
     * @param model {qx.data.Array?null} The model data for the widget.
     */
    construct: function construct(model) {
      qx.ui.core.Widget.constructor.call(this); // set the layout

      var layout = new qx.ui.layout.HBox();

      this._setLayout(layout);

      layout.setAlignY("middle"); // Register listeners

      this.addListener("keypress", this._handleKeyboard, this);
      this.addListener("tap", this._handlePointer, this);
      this.addListener("blur", this._onBlur, this);
      this.addListener("resize", this._onResize, this);

      this._createChildControl("dropdown");

      this.bind('allowGrowDropDown', this.getChildControl('dropdown'), 'allowGrowDropDown');

      if (model != null) {
        this.initModel(model);
      } else {
        this.__defaultModel__P_429_0 = new qx.data.Array();
        this.initModel(this.__defaultModel__P_429_0);
      }
    },
    properties: {
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 120
      },

      /** Data array containing the data which should be shown in the drop-down. */
      model: {
        check: "qx.data.Array",
        apply: "_applyModel",
        event: "changeModel",
        nullable: false,
        deferredInit: true
      },

      /**
       * Delegation object which can have one or more functions defined by the
       * {@link qx.ui.list.core.IListDelegate} interface.
       */
      delegate: {
        apply: "_applyDelegate",
        event: "changeDelegate",
        init: null,
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as a label. This is only needed if objects are stored in the
       * model.
       */
      labelPath: {
        check: "String",
        apply: "_applyLabelPath",
        event: "changeLabelPath",
        nullable: true
      },

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      labelOptions: {
        apply: "_applyLabelOptions",
        event: "changeLabelOptions",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as an icon. This is only needed if objects are stored in the
       * model and icons should be displayed.
       */
      iconPath: {
        check: "String",
        event: "changeIconPath",
        apply: "_applyIconPath",
        nullable: true
      },

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      iconOptions: {
        apply: "_applyIconOptions",
        event: "changeIconOptions",
        nullable: true
      },

      /** Default item height. */
      itemHeight: {
        check: "Integer",
        init: 25,
        apply: "_applyRowHeight",
        themeable: true
      },

      /**
       * The maximum height of the drop-down list. Setting this value to
       * <code>null</code> will set cause the list to be auto-sized.
       */
      maxListHeight: {
        check: "Number",
        apply: "_applyMaxListHeight",
        nullable: true,
        init: 200
      },

      /**
       * Allow the drop-down to grow wider than its parent.
       */
      allowGrowDropDown: {
        init: false,
        nullable: false,
        check: "Boolean",
        event: "changeAllowGrowDropDown"
      }
    },
    members: {
      /** @type {qx.data.Array} The initial model array of this virtual box. */
      __defaultModel__P_429_0: null,

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        invalid: true
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Trigger a rebuild from the internal data structure.
       */
      refresh: function refresh() {
        this.getChildControl("dropdown").getChildControl("list").refresh();
        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * Shows the drop-down.
       */
      open: function open() {
        this._beforeOpen();

        this.getChildControl("dropdown").open();
      },

      /**
       * Hides the drop-down.
       */
      close: function close() {
        this._beforeClose();

        this.getChildControl("dropdown").close();
      },

      /**
       * Toggles the drop-down visibility.
       */
      toggle: function toggle() {
        var dropDown = this.getChildControl("dropdown");

        if (dropDown.isVisible()) {
          this.close();
        } else {
          this.open();
        }
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "dropdown":
            control = new qx.ui.form.core.VirtualDropDownList(this);
            control.addListener("changeVisibility", this._onPopupChangeVisibility, this);
            break;
        }

        return control || qx.ui.form.core.AbstractVirtualBox.prototype._createChildControlImpl.base.call(this, id, hash);
      },

      /**
       * This method is called before the drop-down is opened.
       */
      _beforeOpen: function _beforeOpen() {},

      /**
       * This method is called before the drop-down is closed.
       */
      _beforeClose: function _beforeClose() {},

      /**
       * Returns the action dependent on the user interaction: e. q. <code>open</code>,
       * or <code>close</code>.
       *
       * @param event {qx.event.type.KeySequence} The keyboard event.
       * @return {String|null} The action or <code>null</code> when interaction
       *  doesn't hit any action.
       */
      _getAction: function _getAction(event) {
        var keyIdentifier = event.getKeyIdentifier();
        var isOpen = this.getChildControl("dropdown").isVisible();

        var isModifierPressed = this._isModifierPressed(event);

        if (!isOpen && !isModifierPressed && (keyIdentifier === "Down" || keyIdentifier === "Up")) {
          return "open";
        } else if (isOpen && !isModifierPressed && keyIdentifier === "Escape") {
          return "close";
        } else {
          return null;
        }
      },

      /**
       * Helper Method to create bind path depended on the passed path.
       *
       * @param source {String} The path to the selection.
       * @param path {String?null} The path to the item's property.
       * @return {String} The created path.
       */
      _getBindPath: function _getBindPath(source, path) {
        var bindPath = source + "[0]";

        if (path != null && path != "") {
          bindPath += "." + path;
        }

        return bindPath;
      },

      /**
       * Helper method to check if one modifier key is pressed. e.q.
       * <code>Control</code>, <code>Shift</code>, <code>Meta</code> or
       * <code>Alt</code>.
       *
       * @param event {qx.event.type.KeySequence} The keyboard event.
       * @return {Boolean} <code>True</code> when a modifier key is pressed,
       *   <code>false</code> otherwise.
       */
      _isModifierPressed: function _isModifierPressed(event) {
        var isAltPressed = event.isAltPressed();
        var isCtrlOrCommandPressed = event.isCtrlOrCommandPressed();
        var isShiftPressed = event.isShiftPressed();
        var isMetaPressed = event.isMetaPressed();
        return isAltPressed || isCtrlOrCommandPressed || isShiftPressed || isMetaPressed;
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Handler for the blur event of the current widget.
       *
       * @param event {qx.event.type.Focus} The blur event.
       */
      _onBlur: function _onBlur(event) {
        this.close();
      },

      /**
       * Handles the complete keyboard events for user interaction. If there is
       * no defined user interaction {@link #_getAction}, the event is delegated
       * to the {@link qx.ui.form.core.VirtualDropDownList#_handleKeyboard} method.
       *
       * @param event {qx.event.type.KeySequence} The keyboard event.
       */
      _handleKeyboard: function _handleKeyboard(event) {
        var action = this._getAction(event);

        var isOpen = this.getChildControl("dropdown").isVisible();

        switch (action) {
          case "open":
            this.open();
            break;

          case "close":
            this.close();
            break;

          default:
            if (isOpen) {
              this.getChildControl("dropdown")._handleKeyboard(event);
            }

            break;
        }
      },

      /**
       * Handles all pointer events dispatched on the widget.
       *
       * @param event {qx.event.type.Pointer|qx.event.type.Roll} The pointer event.
       */
      _handlePointer: function _handlePointer(event) {},

      /**
       * Updates drop-down minimum size.
       *
       * @param event {qx.event.type.Data} Data event.
       */
      _onResize: function _onResize(event) {
        this.getChildControl("dropdown").setMinWidth(event.getData().width);
      },

      /**
       * Adds/removes the state 'popupOpen' depending on the visibility of the popup
       *
       * @param event {qx.event.type.Data} Data event
       */
      _onPopupChangeVisibility: function _onPopupChangeVisibility(event) {
        event.getData() == "visible" ? this.addState("popupOpen") : this.removeState("popupOpen");
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyModel: function _applyModel(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setModel(value);
        qx.ui.core.queue.Widget.add(this);
      },
      // property apply
      _applyDelegate: function _applyDelegate(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setDelegate(value);
      },
      // property apply
      _applyLabelPath: function _applyLabelPath(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setLabelPath(value);
        qx.ui.core.queue.Widget.add(this);
      },
      // property apply
      _applyLabelOptions: function _applyLabelOptions(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setLabelOptions(value);
        qx.ui.core.queue.Widget.add(this);
      },
      // property apply
      _applyIconPath: function _applyIconPath(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setIconPath(value);
        qx.ui.core.queue.Widget.add(this);
      },
      // property apply
      _applyIconOptions: function _applyIconOptions(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setIconOptions(value);
        qx.ui.core.queue.Widget.add(this);
      },
      // property apply
      _applyRowHeight: function _applyRowHeight(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setItemHeight(value);
      },
      // property apply
      _applyMaxListHeight: function _applyMaxListHeight(value, old) {
        this.getChildControl("dropdown").getChildControl("list").setMaxHeight(value);
      }
    },
    destruct: function destruct() {
      if (this.__defaultModel__P_429_0) {
        this.__defaultModel__P_429_0.dispose();
      }
    }
  });
  qx.ui.form.core.AbstractVirtualBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.core.AbstractVirtualBox": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IStringForm": {
        "require": true
      },
      "qx.event.type.Focus": {
        "construct": true
      },
      "qx.ui.form.TextField": {},
      "qx.ui.form.Button": {},
      "qx.data.SingleValueBinding": {},
      "qx.lang.Type": {},
      "qx.util.Delegate": {},
      "qx.lang.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A virtual form widget that allows text entry as well as selection from a
   * drop-down.
   *
   * @childControl textfield {qx.ui.form.TextField} Field for text entry.
   * @childControl button {qx.ui.form.Button} Opens the drop-down.
   */
  qx.Class.define("qx.ui.form.VirtualComboBox", {
    extend: qx.ui.form.core.AbstractVirtualBox,
    implement: [qx.ui.form.IStringForm],
    construct: function construct(model) {
      qx.ui.form.core.AbstractVirtualBox.constructor.call(this, model);

      var textField = this._createChildControl("textfield");

      this._createChildControl("button");

      var dropdown = this.getChildControl("dropdown");
      dropdown.getChildControl("list").setSelectionMode("single");
      this.__selection__P_427_0 = dropdown.getSelection();

      this.__selection__P_427_0.addListener("change", this.__onSelectionChange__P_427_1, this);

      this.bind("value", textField, "value");
      textField.bind("value", this, "value"); // forward the focusin and focusout events to the textfield. The textfield
      // is not focusable so the events need to be forwarded manually.

      this.addListener("focusin", function (e) {
        textField.fireNonBubblingEvent("focusin", qx.event.type.Focus);
      }, this);
      this.addListener("focusout", function (e) {
        textField.fireNonBubblingEvent("focusout", qx.event.type.Focus);
        this.fireNonBubblingEvent("blur", qx.event.type.Focus);
      }, this);
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "virtual-combobox"
      },
      // overridden
      width: {
        refine: true,
        init: 120
      },

      /**
       * The currently selected or entered value.
       */
      value: {
        nullable: true,
        event: "changeValue"
      },

      /**
       * String value which will be shown as a hint if the field is all of:
       * unset, unfocused and enabled. Set to null to not show a placeholder
       * text.
       */
      placeholder: {
        check: "String",
        nullable: true,
        apply: "_applyPlaceholder"
      },

      /**
       * Formatting function that will be applied to the value of a selected model
       * item's label before it is written to the text field. Also used to find
       * and preselect the first list entry that begins with the current content
       * of the text field when the drop-down list is opened. Can be used e.g. to
       * strip HTML tags from rich-formatted item labels. The function will be
       * called with the item's label (String) as the only parameter.
       */
      defaultFormat: {
        check: "Function",
        init: null,
        nullable: true
      }
    },
    members: {
      /** @type {var} Binding id between local value and text field value. */
      __localBindId__P_427_2: null,

      /** @type {var} Binding id between text field value and local value. */
      __textFieldBindId__P_427_3: null,

      /** @type {qx.data.Array} the drop-down selection. */
      __selection__P_427_0: null,

      /** @type {Boolean} Indicator to ignore selection changes from the list. */
      __ignoreChangeSelection__P_427_4: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the current selection. This method only works if the widget is
       * already created and added to the document.
       *
       * @return {String|null} The current text selection.
       */
      getTextSelection: function getTextSelection() {
        return this.getChildControl("textfield").getTextSelection();
      },

      /**
       * Returns the current selection length. This method only works if the
       * widget is already created and added to the document.
       *
       * @return {Integer|null} The current text selection length.
       */
      getTextSelectionLength: function getTextSelectionLength() {
        return this.getChildControl("textfield").getTextSelectionLength();
      },

      /**
       * Set the selection to the given start and end (zero-based). If no end
       * value is given the selection will extend to the end of the textfield's
       * content. This method only works if the widget is already created and
       * added to the document.
       *
       * @param start {Integer} Start of the selection (zero-based).
       * @param end {Integer} End of the selection.
       */
      setTextSelection: function setTextSelection(start, end) {
        this.getChildControl("textfield").setTextSelection(start, end);
      },

      /**
       * Clears the current selection. This method only works if the widget is
       * already created and added to the document.
       */
      clearTextSelection: function clearTextSelection() {
        this.getChildControl("textfield").clearTextSelection();
      },

      /**
       * Selects the whole content.
       */
      selectAllText: function selectAllText() {
        this.getChildControl("textfield").selectAllText();
      },

      /**
       * Clear any text selection, then select all text.
       */
      resetAllTextSelection: function resetAllTextSelection() {
        this.clearTextSelection();
        this.selectAllText();
      },
      // overridden
      tabFocus: function tabFocus() {
        var field = this.getChildControl("textfield");
        field.getFocusElement().focus();
        field.selectAllText();
      },
      // overridden
      focus: function focus() {
        qx.ui.form.VirtualComboBox.prototype.focus.base.call(this);
        this.getChildControl("textfield").getFocusElement().focus();
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "textfield":
            control = new qx.ui.form.TextField();
            control.setFocusable(false);
            control.addState("inner");

            this._add(control, {
              flex: 1
            });

            break;

          case "button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.setKeepActive(true);
            control.addState("inner");
            control.addListener("execute", this.toggle, this);

            this._add(control);

            break;
        }

        return control || qx.ui.form.VirtualComboBox.prototype._createChildControlImpl.base.call(this, id, hash);
      },
      // overridden
      _beforeOpen: function _beforeOpen() {
        this.__selectFirstMatch__P_427_5();
      },
      // overridden
      _handleKeyboard: function _handleKeyboard(event) {
        var action = this._getAction(event);

        switch (action) {
          case "select":
            this.setValue(this.getChildControl("textfield").getValue());
            break;

          default:
            qx.ui.form.VirtualComboBox.prototype._handleKeyboard.base.call(this, event);

            break;
        }
      },
      // overridden
      _getAction: function _getAction(event) {
        var keyIdentifier = event.getKeyIdentifier();
        var isOpen = this.getChildControl("dropdown").isVisible();

        var isModifierPressed = this._isModifierPressed(event);

        if (!isOpen && !isModifierPressed && keyIdentifier === "Enter") {
          return "select";
        } else {
          return qx.ui.form.VirtualComboBox.prototype._getAction.base.call(this, event);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      // overridden
      _handlePointer: function _handlePointer(event) {
        qx.ui.form.VirtualComboBox.prototype._handlePointer.base.call(this, event);

        var type = event.getType();

        if (type !== "tap") {
          return;
        }

        this.close();
      },

      /**
       * Handler to synchronize selection changes with the value property.
       *
       * @param event {qx.event.type.Data} The change event from the qx.data.Array.
       */
      __onSelectionChange__P_427_1: function __onSelectionChange__P_427_1(event) {
        if (this.__ignoreChangeSelection__P_427_4 == true) {
          return;
        }

        var selected = this.__selection__P_427_0.getItem(0);

        if (selected) {
          selected = this.__convertValue__P_427_6(selected);
          this.setValue(selected);
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyPlaceholder: function _applyPlaceholder(value, old) {
        this.getChildControl("textfield").setPlaceholder(value);
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Selects the first list item that starts with the text field's value.
       */
      __selectFirstMatch__P_427_5: function __selectFirstMatch__P_427_5() {
        var value = this.getValue();
        var dropdown = this.getChildControl("dropdown");
        var selection = dropdown.getSelection();
        var selected = selection.getItem(0); // try to preselect the matching item even if there is no current selection

        if (selected === undefined || this.__convertValue__P_427_6(selected) !== value) {
          // only reset the old selection if there is one
          if (selected !== undefined) {
            // reset the old selection
            this.__ignoreChangeSelection__P_427_4 = true;
            selection.removeAll();
            this.__ignoreChangeSelection__P_427_4 = false;
          } // No calculation is needed when the value is empty


          if (value == null || value == "") {
            return;
          }

          var model = this.getModel();

          var lookupTable = dropdown.getChildControl("list")._getLookupTable();

          for (var i = 0, l = lookupTable.length; i < l; i++) {
            var modelItem = model.getItem(lookupTable[i]);

            var itemLabel = this.__convertValue__P_427_6(modelItem);

            if (itemLabel && itemLabel.indexOf(value) == 0) {
              dropdown.setPreselected(modelItem);
              break;
            }
          }
        }
      },

      /**
       * Helper method to convert the model item to a String.
       *
       * @param modelItem {var} The model item to convert.
       * @return {String} The converted value.
       */
      __convertValue__P_427_6: function __convertValue__P_427_6(modelItem) {
        var labelOptions = this.getLabelOptions();
        var formatter = this.getDefaultFormat();
        var labelPath = this.getLabelPath();
        var result = null;

        if (labelPath != null) {
          result = qx.data.SingleValueBinding.resolvePropertyChain(modelItem, labelPath);
        } else if (qx.lang.Type.isString(modelItem)) {
          result = modelItem;
        }

        var converter = qx.util.Delegate.getMethod(labelOptions, "converter");

        if (converter != null) {
          result = converter(result);
        }

        if (result != null && formatter != null) {
          result = formatter(qx.lang.String.stripTags(result));
        }

        return result;
      }
    },
    destruct: function destruct() {
      var textField = this.getChildControl("textfield");
      this.removeAllBindings();
      textField.removeAllBindings();

      this.__selection__P_427_0.removeListener("change", this.__onSelectionChange__P_427_1, this);

      this.__selection__P_427_0 = null;
    }
  });
  qx.ui.form.VirtualComboBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.popup.Popup": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      },
      "qx.ui.form.core.AbstractVirtualBox": {
        "construct": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.ui.list.List": {},
      "qx.bom.Viewport": {},
      "qx.util.Delegate": {},
      "qx.ui.form.ListItem": {},
      "qx.theme.manager.Font": {},
      "qx.bom.Font": {},
      "qx.bom.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A drop-down (popup) widget which contains a virtual list for selection.
   *
   * @childControl list {qx.ui.list.List} The virtual list.
   *
   * @internal
   */
  qx.Class.define("qx.ui.form.core.VirtualDropDownList", {
    extend: qx.ui.popup.Popup,

    /**
     * Creates the drop-down list.
     *
     * @param target {qx.ui.form.core.AbstractVirtualBox} The composite widget.
     */
    construct: function construct(target) {
      qx.core.Assert.assertNotNull(target, "Invalid parameter 'target'!");
      qx.core.Assert.assertNotUndefined(target, "Invalid parameter 'target'!");
      qx.core.Assert.assertInterface(target, qx.ui.form.core.AbstractVirtualBox, "Invalid parameter 'target'!");
      qx.ui.popup.Popup.constructor.call(this, new qx.ui.layout.VBox());
      this._target = target;

      this._createChildControl("list");

      this.addListener("changeVisibility", this.__onChangeVisibility__P_430_0, this);
      this.__defaultSelection__P_430_1 = new qx.data.Array();
      this.initSelection(this.__defaultSelection__P_430_1);
    },
    properties: {
      // overridden
      autoHide: {
        refine: true,
        init: false
      },
      // overridden
      keepActive: {
        refine: true,
        init: true
      },

      /** Current selected items. */
      selection: {
        check: "qx.data.Array",
        event: "changeSelection",
        apply: "_applySelection",
        nullable: false,
        deferredInit: true
      },

      /**
       * Allow the drop-down to grow wider than its parent.
       */
      allowGrowDropDown: {
        init: false,
        nullable: false,
        check: "Boolean",
        apply: "_adjustSize",
        event: "changeAllowGrowDropDown"
      }
    },
    events: {
      /**
       * This event is fired as soon as the content of the selection property changes, but
       * this is not equal to the change of the selection of the widget. If the selection
       * of the widget changes, the content of the array stored in the selection property
       * changes. This means you have to listen to the change event of the selection array
       * to get an event as soon as the user changes the selected item.
       * <pre class="javascript">obj.getSelection().addListener("change", listener, this);</pre>
       */
      "changeSelection": "qx.event.type.Data"
    },
    members: {
      /** @type {qx.ui.form.core.AbstractVirtualBox} The composite widget. */
      _target: null,

      /** @type {var} The pre-selected model item. */
      _preselected: null,

      /**
       * @type {Boolean} Indicator to ignore selection changes from the
       * {@link #selection} array.
       */
      __ignoreSelection__P_430_2: false,

      /** @type {Boolean} Indicator to ignore selection changes from the list. */
      __ignoreListSelection__P_430_3: false,

      /** @type {qx.data.Array} The initial selection array. */
      __defaultSelection__P_430_1: null,

      /**
       * When the drop-down is allowed to grow wider than its parent,
       * this member variable will contain the cached maximum list item width in pixels.
       * This variable gets updated whenever the model or model length changes.
       *
       * @type {Number}
       */
      __cachedMaxListItemWidth__P_430_4: 0,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Shows the drop-down.
       */
      open: function open() {
        this.placeToWidget(this._target, true);
        this.show();
      },

      /**
       * Hides the drop-down.
       */
      close: function close() {
        this.hide();
      },

      /**
       * Pre-selects the drop-down item corresponding to the given model object.
       *
       * @param modelItem {Object} Item to be pre-selected.
       */
      setPreselected: function setPreselected(modelItem) {
        this._preselected = modelItem;
        this.__ignoreListSelection__P_430_3 = true;
        var listSelection = this.getChildControl("list").getSelection();
        var helper = new qx.data.Array([modelItem]);

        this.__synchronizeSelection__P_430_5(helper, listSelection);

        helper.dispose();
        this.__ignoreListSelection__P_430_3 = false;
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "list":
            control = new qx.ui.list.List().set({
              focusable: false,
              keepFocus: true,
              keepActive: true,
              height: null,
              width: null,
              maxHeight: this._target.getMaxListHeight(),
              selectionMode: "one",
              quickSelection: true
            });
            control.getSelection().addListener("change", this._onListChangeSelection, this);
            control.addListener("tap", this._handlePointer, this);
            control.addListener("changeModel", this._onChangeModel, this);
            control.addListener("changeModelLength", this._onChangeModelLength, this);
            control.addListener("changeDelegate", this._onChangeDelegate, this);
            this.add(control, {
              flex: 1
            });
            break;
        }

        return control || qx.ui.form.core.VirtualDropDownList.prototype._createChildControlImpl.base.call(this, id, hash);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Handles the complete keyboard events dispatched on the widget.
       *
       * @param event {qx.event.type.KeySequence} The keyboard event.
       */
      _handleKeyboard: function _handleKeyboard(event) {
        if (this.isVisible() && event.getKeyIdentifier() === "Enter") {
          this.__selectPreselected__P_430_6();

          return;
        }

        var clone = event.clone();
        clone.setTarget(this.getChildControl("list"));
        clone.setBubbles(false);
        this.getChildControl("list").dispatchEvent(clone);
      },

      /**
       * Handles all mouse events dispatched on the widget.
       *
       * @param event {qx.event.type.Mouse} The mouse event.
       */
      _handlePointer: function _handlePointer(event) {
        this.__selectPreselected__P_430_6();
      },

      /**
       * Handler for the local selection change. The method is responsible for
       * the synchronization between the own selection and the selection
       * form the drop-down.
       *
       * @param event {qx.event.type.Data} The data event.
       */
      __onChangeSelection__P_430_7: function __onChangeSelection__P_430_7(event) {
        if (this.__ignoreSelection__P_430_2) {
          return;
        }

        var selection = this.getSelection();
        var listSelection = this.getChildControl("list").getSelection();
        this.__ignoreListSelection__P_430_3 = true;

        this.__synchronizeSelection__P_430_5(selection, listSelection);

        this.__ignoreListSelection__P_430_3 = false;
        this.__ignoreSelection__P_430_2 = true;

        this.__synchronizeSelection__P_430_5(listSelection, selection);

        this.__ignoreSelection__P_430_2 = false;
      },

      /**
       * Handler for the selection change on the list. The method is responsible
       * for the synchronization between the list selection and the own selection.
       *
       * @param event {qx.event.type.Data} The data event.
       */
      _onListChangeSelection: function _onListChangeSelection(event) {
        if (this.__ignoreListSelection__P_430_3) {
          return;
        }

        var listSelection = this.getChildControl("list").getSelection();

        if (this.isVisible()) {
          this.setPreselected(listSelection.getItem(0));
        } else {
          this.__ignoreSelection__P_430_2 = true;

          this.__synchronizeSelection__P_430_5(listSelection, this.getSelection());

          this.__ignoreSelection__P_430_2 = false;
        }
      },

      /**
       * Handler for the own visibility changes. The method is responsible that
       * the list selects the current selected item.
       *
       * @param event {qx.event.type.Data} The event.
       */
      __onChangeVisibility__P_430_0: function __onChangeVisibility__P_430_0(event) {
        if (this.isVisible()) {
          if (this._preselected == null) {
            var selection = this.getSelection();
            var listSelection = this.getChildControl("list").getSelection();

            this.__synchronizeSelection__P_430_5(selection, listSelection);
          }

          this._adjustSize();
        } else {
          this.setPreselected(null);
        }
      },

      /**
       * Handler for the model change event.
       * Called when the whole model changes, not when its length changes.
       *
       * @param event {qx.event.type.Data} The change event.
       * @protected
       */
      _onChangeModel: function _onChangeModel(event) {
        if (this.getAllowGrowDropDown()) {
          this._recalculateMaxListItemWidth();
        }

        this._adjustSize();
      },

      /**
       * Handler for the model length change event.
       * Called whenever items get added or removed from the model,
       * not when the model itself changes.
       *
       * @param event {qx.event.type.Data}
       * @protected
       */
      _onChangeModelLength: function _onChangeModelLength(event) {
        if (this.getAllowGrowDropDown()) {
          this._recalculateMaxListItemWidth();
        }

        this._adjustSize();
      },

      /**
       * Handler for the delegate change event.
       *
       * @param event {qx.event.type.Data} The change event.
       */
      _onChangeDelegate: function _onChangeDelegate(event) {
        this.getSelection().removeAll();
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applySelection: function _applySelection(value, old) {
        value.addListener("change", this.__onChangeSelection__P_430_7, this);

        if (old != null) {
          old.removeListener("change", this.__onChangeSelection__P_430_7, this);
        }

        this.__synchronizeSelection__P_430_5(value, this.getChildControl("list").getSelection(value));
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Helper method to select the current preselected item, also closes the
       * drop-down.
       */
      __selectPreselected__P_430_6: function __selectPreselected__P_430_6() {
        if (this._preselected != null) {
          var selection = this.getSelection();
          selection.splice(0, 1, this._preselected);
          this._preselected = null;
          this.close();
        }
      },

      /**
       * Helper method to synchronize both selection. The target selection has
       * the same selection like the source selection after the synchronization.
       *
       * @param source {qx.data.Array} The source selection.
       * @param target {qx.data.Array} The target selection.
       */
      __synchronizeSelection__P_430_5: function __synchronizeSelection__P_430_5(source, target) {
        if (source.equals(target)) {
          return;
        }

        if (source.getLength() <= 0) {
          target.removeAll();
        } else {
          // build arguments array for splice(0, target.length, source[0], source[1], ...)
          var spliceArg = [0, target.length];
          spliceArg = spliceArg.concat(source.toArray()); // use apply since it allow to use an array as the argument array
          // (calling splice directly with an array insert it in the array on which splice is called)
          // don't forget to dispose the array created by splice

          target.splice.apply(target, spliceArg).dispose();
        }
      },

      /**
       * Adjust the drop-down to the available width and height, by calling
       * {@link #_adjustWidth} and {@link #_adjustHeight}.
       */
      _adjustSize: function _adjustSize() {
        if (!this._target.getBounds()) {
          this.addListenerOnce("appear", this._adjustSize, this);
          return;
        }

        this._adjustWidth();

        this._adjustHeight();
      },

      /**
       * Adjust the drop-down to the available width. The width is limited by
       * the current width from the _target, unless allowGrowDropDown is true.
       */
      _adjustWidth: function _adjustWidth() {
        var width = this._target.getBounds().width;

        var uiList = this.getChildControl('list');

        if (this.getAllowGrowDropDown()) {
          // Let the drop-down handle its own width.
          this.setWidth(null);

          if (this.__cachedMaxListItemWidth__P_430_4 > 0) {
            uiList.setWidth(this.__cachedMaxListItemWidth__P_430_4);
          } else {
            uiList.setWidth(width);
          }
        } else {
          // Make the drop-down as wide as the virtual-box that it is owned by.
          this.setWidth(width);
          uiList.resetWidth();
        }
      },

      /**
       * Adjust the drop-down to the available height. Ensure that the list
       * is never bigger that the max list height and the available space
       * in the viewport.
       */
      _adjustHeight: function _adjustHeight() {
        var availableHeight = this._getAvailableHeight();

        if (availableHeight === null) {
          return;
        }

        var maxHeight = this._target.getMaxListHeight();

        var list = this.getChildControl("list");
        var itemsHeight = list.getPane().getRowConfig().getTotalSize();

        if (maxHeight == null || itemsHeight < maxHeight) {
          maxHeight = itemsHeight;
        }

        if (maxHeight > availableHeight) {
          maxHeight = availableHeight;
        }

        var minHeight = list.getMinHeight();

        if (null !== minHeight && minHeight > maxHeight) {
          maxHeight = minHeight;
        }

        list.setMaxHeight(maxHeight);
      },

      /**
       * Calculates the available height in the viewport.
       *
       * @return {Integer|null} Available height in the viewport.
       */
      _getAvailableHeight: function _getAvailableHeight() {
        var distance = this.getLayoutLocation(this._target);

        if (!distance) {
          return null;
        }

        var viewPortHeight = qx.bom.Viewport.getHeight(); // distance to the bottom and top borders of the viewport

        var toTop = distance.top;
        var toBottom = viewPortHeight - distance.bottom;
        return toTop > toBottom ? toTop : toBottom;
      },

      /**
       * Loop over all model items to recalculate the maximum list item width.
       *
       * @protected
       */
      _recalculateMaxListItemWidth: function _recalculateMaxListItemWidth() {
        var maxWidth = 0;
        var list = this.getChildControl("list");
        var model = list.getModel();

        if (model && model.length) {
          var createWidget = qx.util.Delegate.getMethod(list.getDelegate(), "createItem");

          if (!createWidget) {
            createWidget = function createWidget() {
              return new qx.ui.form.ListItem();
            };
          }

          var tempListItem = createWidget(); // Make sure the widget has the correct padding properties.

          tempListItem.syncAppearance();
          var styles;
          var font = tempListItem.getFont();

          if (font) {
            styles = qx.theme.manager.Font.getInstance().resolve(font).getStyles();
          }

          if (!styles) {
            styles = qx.bom.Font.getDefaultStyles();
          }

          var paddingX = list.getPaddingLeft() + list.getPaddingRight() + tempListItem.getPaddingLeft() + tempListItem.getPaddingRight() + tempListItem.getMarginLeft() + tempListItem.getMarginRight();
          var label = tempListItem.getChildControl('label');

          if (label) {
            // Make sure the widget has the correct padding properties.
            label.syncAppearance();
            paddingX += label.getPaddingLeft() + label.getPaddingRight() + label.getMarginLeft() + label.getMarginRight();
          }

          model.forEach(function (item) {
            var width = 0;
            var content;

            if (typeof item === "string") {
              content = item;
            } else if (typeof item === "object" && item !== null) {
              content = item.get(list.getLabelPath());
            }

            if (content) {
              width = qx.bom.Label.getHtmlSize(content, styles, undefined).width + paddingX;

              if (width > maxWidth) {
                maxWidth = width;
              }
            }
          });
          tempListItem.dispose();
        }

        this.__cachedMaxListItemWidth__P_430_4 = maxWidth;
      },

      /**
       * Get the cached maximum list item width.
       *
       * @return {Number}
       * @protected
       */
      _getMaxListItemWidth: function _getMaxListItemWidth() {
        return this.__cachedMaxListItemWidth__P_430_4;
      }
    },
    destruct: function destruct() {
      if (this.__defaultSelection__P_430_1) {
        this.__defaultSelection__P_430_1.dispose();
      }
    }
  });
  qx.ui.form.core.VirtualDropDownList.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Function": {},
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Methods to work with the delegate pattern.
   */
  qx.Class.define("qx.util.Delegate", {
    statics: {
      /**
       * Returns the delegate method given my its name.
       *
       * @param delegate {Object} The delegate object to check the method.
       * @param specificMethod {String} The name of the delegate method.
       * @return {Function|null} The requested method or null, if no method is set.
       */
      getMethod: function getMethod(delegate, specificMethod) {
        if (qx.util.Delegate.containsMethod(delegate, specificMethod)) {
          return qx.lang.Function.bind(delegate[specificMethod], delegate);
        }

        return null;
      },

      /**
       * Checks, if the given delegate is valid or if a specific method is given.
       *
       * @param delegate {Object} The delegate object.
       * @param specificMethod {String} The name of the method to search for.
       * @return {Boolean} True, if everything was ok.
       */
      containsMethod: function containsMethod(delegate, specificMethod) {
        var Type = qx.lang.Type;

        if (Type.isObject(delegate)) {
          return Type.isFunction(delegate[specificMethod]);
        }

        return false;
      }
    }
  });
  qx.util.Delegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.scroll.AbstractScrollArea": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.Pane": {
        "construct": true
      },
      "qx.bom.client.Scroll": {
        "construct": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "os.scrollBarOverlayed": {
          "construct": true,
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The Scroller wraps a {@link Pane} and provides scroll bars to interactively
   * scroll the pane's content.
   *
   * @childControl pane {qx.ui.virtual.core.Pane} Virtual pane.
   */
  qx.Class.define("qx.ui.virtual.core.Scroller", {
    extend: qx.ui.core.scroll.AbstractScrollArea,

    /**
     * @param rowCount {Integer?0} The number of rows of the virtual grid.
     * @param columnCount {Integer?0} The number of columns of the virtual grid.
     * @param cellHeight {Integer?10} The default cell height.
     * @param cellWidth {Integer?10} The default cell width.
     */
    construct: function construct(rowCount, columnCount, cellHeight, cellWidth) {
      qx.ui.core.scroll.AbstractScrollArea.constructor.call(this);
      this.__pane__P_545_0 = new qx.ui.virtual.core.Pane(rowCount, columnCount, cellHeight, cellWidth);

      this.__pane__P_545_0.addListener("update", this._computeScrollbars, this);

      this.__pane__P_545_0.addListener("scrollX", this._onScrollPaneX, this);

      this.__pane__P_545_0.addListener("scrollY", this._onScrollPaneY, this);

      if (qx.core.Environment.get("os.scrollBarOverlayed")) {
        this._add(this.__pane__P_545_0, {
          edge: 0
        });
      } else {
        this._add(this.__pane__P_545_0, {
          row: 0,
          column: 0
        });
      }
    },
    members: {
      /** @type {qx.ui.virtual.core.Pane} Virtual pane. */
      __pane__P_545_0: null,

      /*
      ---------------------------------------------------------------------------
        ACCESSOR METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Get the scroller's virtual pane.
       *
       * @return {qx.ui.virtual.core.Pane} The scroller's pane.
       */
      getPane: function getPane() {
        return this.__pane__P_545_0;
      },

      /*
      ---------------------------------------------------------------------------
        CHILD CONTROL SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        if (id === "pane") {
          return this.__pane__P_545_0;
        } else {
          return qx.ui.virtual.core.Scroller.prototype._createChildControlImpl.base.call(this, id);
        }
      },

      /*
      ---------------------------------------------------------------------------
        ITEM LOCATION SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * NOT IMPLEMENTED
       *
       * @param item {qx.ui.core.Widget} Item to query.
       * @return {Integer} Top offset.
       * @abstract
       */
      getItemTop: function getItemTop(item) {
        throw new Error("The method 'getItemTop' is not implemented!");
      },

      /**
       * NOT IMPLEMENTED
       *
       * @param item {qx.ui.core.Widget} Item to query.
       * @return {Integer} Top offset.
       * @abstract
       */
      getItemBottom: function getItemBottom(item) {
        throw new Error("The method 'getItemBottom' is not implemented!");
      },

      /**
       * NOT IMPLEMENTED
       *
       * @param item {qx.ui.core.Widget} Item to query.
       * @return {Integer} Top offset.
       * @abstract
       */
      getItemLeft: function getItemLeft(item) {
        throw new Error("The method 'getItemLeft' is not implemented!");
      },

      /**
       * NOT IMPLEMENTED
       *
       * @param item {qx.ui.core.Widget} Item to query.
       * @return {Integer} Right offset.
       * @abstract
       */
      getItemRight: function getItemRight(item) {
        throw new Error("The method 'getItemRight' is not implemented!");
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      // overridden
      _onScrollBarX: function _onScrollBarX(e) {
        this.__pane__P_545_0.setScrollX(e.getData());
      },
      // overridden
      _onScrollBarY: function _onScrollBarY(e) {
        this.__pane__P_545_0.setScrollY(e.getData());
      }
    },
    destruct: function destruct() {
      this.__pane__P_545_0.dispose();

      this.__pane__P_545_0 = null;
    }
  });
  qx.ui.virtual.core.Scroller.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.ui.virtual.selection.Row": {},
      "qx.lang.Type": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Implements the different selection modes single, multi, additive and one
   * selection with there drag and quick selection.
   *
   * Example how to use selection:
   * <pre class="javascript">
   * var rawData = [];
   * for (var i = 0; i < 2500; i++) {
   *  rawData[i] = "Item No " + i;
   * }
   *
   * var model = qx.data.marshal.Json.createModel(rawData);
   * var list = new qx.ui.list.List(model);
   *
   * // Pre-Select "Item No 20"
   * list.getSelection().push(model.getItem(20));
   *
   * // log change selection
   * list.getSelection().addListener("change", function(e) {
   *   this.debug("Selection: " + list.getSelection().getItem(0));
   * }, this);
   * </pre>
   *
   * @internal
   */
  qx.Mixin.define("qx.ui.virtual.selection.MModel", {
    construct: function construct() {
      this._initSelectionManager();

      this.__selection__P_554_0 = new qx.data.Array();

      this.__selection__P_554_0.addListener("change", this._onChangeSelection, this);

      this._applySelection(this.__selection__P_554_0, null);
    },
    properties: {
      /** Current selected items */

      /* psuedo property - implemented manually in code below
      selection :
      {
        check : "qx.data.Array",
        event : "changeSelection",
        apply : "_applySelection",
        nullable : false,
        deferredInit : true
      },
      */

      /**
       * The selection mode to use.
       *
       * For further details please have a look at:
       * {@link qx.ui.core.selection.Abstract#mode}
       */
      selectionMode: {
        check: ["single", "multi", "additive", "one"],
        init: "single",
        apply: "_applySelectionMode"
      },

      /**
       * Enable drag selection (multi selection of items through
       * dragging the pointer in pressed states).
       *
       * Only possible for the selection modes <code>multi</code> and <code>additive</code>
       */
      dragSelection: {
        check: "Boolean",
        init: false,
        apply: "_applyDragSelection"
      },

      /**
       * Enable quick selection mode, where no tap is needed to change the selection.
       *
       * Only possible for the modes <code>single</code> and <code>one</code>.
       */
      quickSelection: {
        check: "Boolean",
        init: false,
        apply: "_applyQuickSelection"
      }
    },
    events: {
      /**
       * This event is fired as soon as the content of the selection property changes, but
       * this is not equal to the change of the selection of the widget. If the selection
       * of the widget changes, the content of the array stored in the selection property
       * changes. This means you have to listen to the change event of the selection array
       * to get an event as soon as the user changes the selected item.
       * <pre class="javascript">obj.getSelection().addListener("change", listener, this);</pre>
       */
      "changeSelection": "qx.event.type.Data",

      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data"
    },
    members: {
      /** @type {qx.ui.virtual.selection.Row} selection manager */
      _manager: null,

      /** @type {Boolean} flag to ignore the selection change from {@link #selection} */
      __ignoreChangeSelection__P_554_1: false,

      /** @type {Boolean} flag to ignore the selection change from <code>_manager</code> */
      __ignoreManagerChangeSelection__P_554_2: false,
      __selection__P_554_0: null,

      /**
       * setValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @param selection {qx.data.IListData|null} List data to select as value.
       * @return {null} The status of this operation.
       */
      setValue: function setValue(selection) {
        if (null === selection) {
          this.resetSelection();
        } else {
          this.setSelection(selection);
        }

        return null;
      },

      /**
       * getValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @return {qx.data.IListData} The current selection.
       */
      getValue: function getValue() {
        return this.getSelection();
      },

      /**
       * resetValue implements part of the {@link qx.ui.form.IField} interface.
       */
      resetValue: function resetValue() {
        this.resetSelection();
      },

      /**
       * Initialize the selection manager with his delegate.
       */
      _initSelectionManager: function _initSelectionManager() {
        var self = this;
        var selectionDelegate = {
          isItemSelectable: function isItemSelectable(row) {
            return self._provider.isSelectable(row);
          },
          styleSelectable: function styleSelectable(row, type, wasAdded) {
            if (type != "selected") {
              return;
            }

            if (wasAdded) {
              self._provider.styleSelectabled(row);
            } else {
              self._provider.styleUnselectabled(row);
            }
          }
        };
        this._manager = new qx.ui.virtual.selection.Row(this.getPane(), selectionDelegate);

        this._manager.attachPointerEvents(this.getPane());

        this._manager.attachKeyEvents(this);

        this._manager.addListener("changeSelection", this._onManagerChangeSelection, this);
      },

      /**
       * Determines, if automatically scrolling of selected item is active.
       * Set <code>false</code> to suspend auto scrolling.
       *
       * @param value {Boolean} Set <code>false</code> to suspend auto scrolling.
       */
      setAutoScrollIntoView: function setAutoScrollIntoView(value) {
        this._manager._autoScrollIntoView = value;
      },

      /**
       * Returns true, if automatically scrolling of selected item is active.
       *
       * @return {Boolean} Returns <code>false</code> if auto scrolling is suspended.
       */
      getAutoScrollIntoView: function getAutoScrollIntoView() {
        return this._manager._autoScrollIntoView;
      },

      /**
       * Method to update the selection, this method can be used when the model has
       * changes.
       */
      _updateSelection: function _updateSelection() {
        if (this._manager == null) {
          return;
        }

        this._onChangeSelection();
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */

      /**
       * Setter for selection property; takes the selection on, and does not change the
       * array instance in `this.selection`
       * 
       * @param value {qx.data.Array} the new selection
       */
      setSelection: function setSelection(value) {
        if (value) {
          this.__selection__P_554_0.replace(value);
        } else {
          this.__selection__P_554_0.removeAll();
        }
      },

      /**
       * Getter for selection property
       * 
       * @return {qx.data.Array}
       */
      getSelection: function getSelection() {
        return this.__selection__P_554_0;
      },

      /**
       * Reset for selection property
       */
      resetSelection: function resetSelection() {
        this.__selection__P_554_0.removeAll();
      },

      /**
       * Init for selection property; takes the selection on, and does not change the
       * array instance in `this.selection`
       * 
       * @param value {qx.data.Array} the new selection
       */
      initSelection: function initSelection(value) {
        this.warn("Using initSelection on " + this.classname + " is probably not what you intended - the selection instance does not change");
        this.setSelection(value);
      },

      /**
       * Apply method for selection property
       * 
       * @param value {qx.data.Array} new value
       * @param old {qx.data.Array} old value
       */
      _applySelection: function _applySelection(value, old) {
        this._onChangeSelection();
      },
      // apply method
      _applySelectionMode: function _applySelectionMode(value, old) {
        this._manager.setMode(value);
      },
      // apply method
      _applyDragSelection: function _applyDragSelection(value, old) {
        this._manager.setDrag(value);
      },
      // apply method
      _applyQuickSelection: function _applyQuickSelection(value, old) {
        this._manager.setQuick(value);
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the internal selection change {@link #selection}.
       *
       * @param e {qx.event.type.Data} the change event.
       */
      _onChangeSelection: function _onChangeSelection(e) {
        if (this.__ignoreManagerChangeSelection__P_554_2 == true) {
          return;
        }

        this.__ignoreChangeSelection__P_554_1 = true;
        var selection = this.getSelection();
        var newSelection = [];

        for (var i = 0; i < selection.getLength(); i++) {
          var item = selection.getItem(i);

          var selectables = this._getSelectables();

          var index = -1;

          if (selectables != null) {
            index = selectables.indexOf(item);
          }

          var row = this._reverseLookup(index);

          if (row >= 0) {
            newSelection.push(row);
          }
        }

        if (this._beforeApplySelection != null && qx.lang.Type.isFunction(this._beforeApplySelection)) {
          this._beforeApplySelection(newSelection);
        }

        try {
          if (!qx.lang.Array.equals(newSelection, this._manager.getSelection())) {
            this._manager.replaceSelection(newSelection);
          }
        } catch (ex) {
          this._manager.selectItem(newSelection[newSelection.length - 1]);
        }

        this.__synchronizeSelection__P_554_3();

        if (this._afterApplySelection != null && qx.lang.Type.isFunction(this._afterApplySelection)) {
          this._afterApplySelection();
        }

        this.__ignoreChangeSelection__P_554_1 = false;
      },

      /**
       * Event handler for the selection change from the <code>_manager</code>.
       *
       * @param e {qx.event.type.Data} the change event.
       */
      _onManagerChangeSelection: function _onManagerChangeSelection(e) {
        if (this.__ignoreChangeSelection__P_554_1 == true) {
          return;
        }

        this.__ignoreManagerChangeSelection__P_554_2 = true;

        this.__synchronizeSelection__P_554_3();

        this.__ignoreManagerChangeSelection__P_554_2 = false;
        this.fireDataEvent("changeValue", e.getData(), e.getOldData());
      },

      /**
       * Synchronized the selection form the manager with the local one.
       */
      __synchronizeSelection__P_554_3: function __synchronizeSelection__P_554_3() {
        if (this.__isSelectionEquals__P_554_4()) {
          return;
        }

        var managerSelection = this._manager.getSelection();

        var newSelection = [];

        for (var i = 0; i < managerSelection.length; i++) {
          var item = this._getDataFromRow(managerSelection[i]);

          if (item != null) {
            newSelection.push(item);
          }
        }

        this.__replaceSelection__P_554_5(newSelection);
      },

      /**
       * Replace the current selection with the passed selection Array.
       *
       * @param newSelection {qx.data.Array} The new selection.
       */
      __replaceSelection__P_554_5: function __replaceSelection__P_554_5(newSelection) {
        var selection = this.getSelection();

        if (newSelection.length > 0) {
          var args = [0, selection.getLength()];
          args = args.concat(newSelection); // dispose data array returned by splice to avoid memory leak

          var temp = selection.splice.apply(selection, args);
          temp.dispose();
        } else {
          selection.removeAll();
        }
      },

      /**
       * Checks whether the local and the manager selection are equal.
       *
       * @return {Boolean} <code>true</code> if the selections are equal,
       *   <code>false</code> otherwise.
       */
      __isSelectionEquals__P_554_4: function __isSelectionEquals__P_554_4() {
        var selection = this.getSelection();

        var managerSelection = this._manager.getSelection();

        if (selection.getLength() !== managerSelection.length) {
          return false;
        }

        for (var i = 0; i < selection.getLength(); i++) {
          var item = selection.getItem(i);

          var selectables = this._getSelectables();

          var index = -1;

          if (selectables != null) {
            index = selectables.indexOf(item);
          }

          var row = this._reverseLookup(index);

          if (row !== managerSelection[i]) {
            return false;
          }

          ;
        }

        return true;
      },

      /**
       * Helper Method to select default item.
       */
      _applyDefaultSelection: function _applyDefaultSelection() {
        if (this._manager != null) {
          this._manager._applyDefaultSelection();
        }
      }
    },
    destruct: function destruct() {
      this._manager.dispose();

      this._manager = null;

      if (this.__selection__P_554_0) {
        this.__selection__P_554_0.dispose();
      }
    }
  });
  qx.ui.virtual.selection.MModel.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.Axis": {
        "construct": true
      },
      "qx.ui.container.Composite": {
        "construct": true
      },
      "qx.ui.virtual.core.ILayer": {},
      "qx.event.Timer": {},
      "qx.ui.virtual.core.CellEvent": {},
      "qx.lang.Array": {},
      "qx.ui.core.queue.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The Pane provides a window of a larger virtual grid.
   *
   * The actual rendering is performed by one or several layers ({@link ILayer}.
   * The pane computes, which cells of the virtual area is visible and instructs
   * the layers to render these cells.
   */
  qx.Class.define("qx.ui.virtual.core.Pane", {
    extend: qx.ui.core.Widget,

    /**
     * @param rowCount {Integer?0} The number of rows of the virtual grid.
     * @param columnCount {Integer?0} The number of columns of the virtual grid.
     * @param cellHeight {Integer?10} The default cell height.
     * @param cellWidth {Integer?10} The default cell width.
     */
    construct: function construct(rowCount, columnCount, cellHeight, cellWidth) {
      qx.ui.core.Widget.constructor.call(this);
      this.__rowConfig__P_544_0 = new qx.ui.virtual.core.Axis(cellHeight, rowCount);
      this.__columnConfig__P_544_1 = new qx.ui.virtual.core.Axis(cellWidth, columnCount);
      this.__scrollTop__P_544_2 = 0;
      this.__scrollLeft__P_544_3 = 0;
      this.__paneHeight__P_544_4 = 0;
      this.__paneWidth__P_544_5 = 0;
      this.__layerWindow__P_544_6 = {};
      this.__jobs__P_544_7 = {}; // create layer container. The container does not have a layout manager
      // layers are positioned using "setUserBounds"

      this.__layerContainer__P_544_8 = new qx.ui.container.Composite();

      this.__layerContainer__P_544_8.setUserBounds(0, 0, 0, 0);

      this._add(this.__layerContainer__P_544_8);

      this.__layers__P_544_9 = [];

      this.__rowConfig__P_544_0.addListener("change", this.fullUpdate, this);

      this.__columnConfig__P_544_1.addListener("change", this.fullUpdate, this);

      this.addListener("resize", this._onResize, this);
      this.addListenerOnce("appear", this._onAppear, this);
      this.addListener("pointerdown", this._onPointerDown, this);
      this.addListener("tap", this._onTap, this);
      this.addListener("dbltap", this._onDbltap, this);
      this.addListener("contextmenu", this._onContextmenu, this);
    },
    events: {
      /** Fired if a cell is tapped. */
      cellTap: "qx.ui.virtual.core.CellEvent",

      /** Fired if a cell is right-clicked. */
      cellContextmenu: "qx.ui.virtual.core.CellEvent",

      /** Fired if a cell is double-tapped. */
      cellDbltap: "qx.ui.virtual.core.CellEvent",

      /** Fired on resize of either the container or the (virtual) content. */
      update: "qx.event.type.Event",

      /** Fired if the pane is scrolled horizontally. */
      scrollX: "qx.event.type.Data",

      /** Fired if the pane is scrolled vertically. */
      scrollY: "qx.event.type.Data"
    },
    properties: {
      // overridden
      width: {
        refine: true,
        init: 400
      },
      // overridden
      height: {
        refine: true,
        init: 300
      }
    },
    members: {
      __rowConfig__P_544_0: null,
      __columnConfig__P_544_1: null,
      __scrollTop__P_544_2: null,
      __scrollLeft__P_544_3: null,
      __paneHeight__P_544_4: null,
      __paneWidth__P_544_5: null,
      __layerWindow__P_544_6: null,
      __jobs__P_544_7: null,
      __layerContainer__P_544_8: null,
      __layers__P_544_9: null,
      __dontFireUpdate__P_544_10: null,
      __columnSizes__P_544_11: null,
      __rowSizes__P_544_12: null,
      __pointerDownCoords__P_544_13: null,

      /*
      ---------------------------------------------------------------------------
        ACCESSOR METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Get the axis object, which defines the row numbers and the row sizes.
       *
       * @return {qx.ui.virtual.core.Axis} The row configuration.
       */
      getRowConfig: function getRowConfig() {
        return this.__rowConfig__P_544_0;
      },

      /**
       * Get the axis object, which defines the column numbers and the column sizes.
       *
       * @return {qx.ui.virtual.core.Axis} The column configuration.
       */
      getColumnConfig: function getColumnConfig() {
        return this.__columnConfig__P_544_1;
      },

      /*
      ---------------------------------------------------------------------------
        LAYER MANAGEMENT
      ---------------------------------------------------------------------------
      */

      /**
       * Returns an array containing the layer container.
       *
       * @return {Object[]} The layer container array.
       */
      getChildren: function getChildren() {
        return [this.__layerContainer__P_544_8];
      },

      /**
       * Add a layer to the layer container.
       *
       * @param layer {qx.ui.virtual.core.ILayer} The layer to add.
       */
      addLayer: function addLayer(layer) {
        {
          this.assertInterface(layer, qx.ui.virtual.core.ILayer);
        }

        this.__layers__P_544_9.push(layer);

        layer.setUserBounds(0, 0, 0, 0);

        this.__layerContainer__P_544_8.add(layer);
      },

      /**
       * Get a list of all layers.
       *
       * @return {qx.ui.virtual.core.ILayer[]} List of the pane's layers.
       */
      getLayers: function getLayers() {
        return this.__layers__P_544_9;
      },

      /**
       * Get a list of all visible layers.
       *
       * @return {qx.ui.virtual.core.ILayer[]} List of the pane's visible layers.
       */
      getVisibleLayers: function getVisibleLayers() {
        var layers = [];

        for (var i = 0; i < this.__layers__P_544_9.length; i++) {
          var layer = this.__layers__P_544_9[i];

          if (layer.isVisible()) {
            layers.push(layer);
          }
        }

        return layers;
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * The maximum horizontal scroll position.
       *
       * @return {Integer} Maximum horizontal scroll position.
       */
      getScrollMaxX: function getScrollMaxX() {
        var paneSize = this.getInnerSize();

        if (paneSize) {
          return Math.max(0, this.__columnConfig__P_544_1.getTotalSize() - paneSize.width);
        }

        return 0;
      },

      /**
       * The maximum vertical scroll position.
       *
       * @return {Integer} Maximum vertical scroll position.
       */
      getScrollMaxY: function getScrollMaxY() {
        var paneSize = this.getInnerSize();

        if (paneSize) {
          return Math.max(0, this.__rowConfig__P_544_0.getTotalSize() - paneSize.height);
        }

        return 0;
      },

      /**
       * Scrolls the content to the given left coordinate.
       *
       * @param value {Integer} The vertical position to scroll to.
       */
      setScrollY: function setScrollY(value) {
        var max = this.getScrollMaxY();

        if (value < 0) {
          value = 0;
        } else if (value > max) {
          value = max;
        }

        if (this.__scrollTop__P_544_2 !== value) {
          var old = this.__scrollTop__P_544_2;
          this.__scrollTop__P_544_2 = value;

          this._deferredUpdateScrollPosition();

          this.fireDataEvent("scrollY", value, old);
        }
      },

      /**
       * Returns the vertical scroll offset.
       *
       * @return {Integer} The vertical scroll offset.
       */
      getScrollY: function getScrollY() {
        return this.__scrollTop__P_544_2;
      },

      /**
       * Scrolls the content to the given top coordinate.
       *
       * @param value {Integer} The horizontal position to scroll to.
       */
      setScrollX: function setScrollX(value) {
        var max = this.getScrollMaxX();

        if (value < 0) {
          value = 0;
        } else if (value > max) {
          value = max;
        }

        if (value !== this.__scrollLeft__P_544_3) {
          var old = this.__scrollLeft__P_544_3;
          this.__scrollLeft__P_544_3 = value;

          this._deferredUpdateScrollPosition();

          this.fireDataEvent("scrollX", value, old);
        }
      },

      /**
       * Returns the horizontal scroll offset.
       *
       * @return {Integer} The horizontal scroll offset.
       */
      getScrollX: function getScrollX() {
        return this.__scrollLeft__P_544_3;
      },

      /**
       * The (virtual) size of the content.
       *
       * @return {Map} Size of the content (keys: <code>width</code> and
       *     <code>height</code>).
       */
      getScrollSize: function getScrollSize() {
        return {
          width: this.__columnConfig__P_544_1.getTotalSize(),
          height: this.__rowConfig__P_544_0.getTotalSize()
        };
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL INTO VIEW SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Scrolls a row into the visible area of the pane.
       *
       * @param row {Integer} The row's index.
       */
      scrollRowIntoView: function scrollRowIntoView(row) {
        var bounds = this.getBounds();

        if (!bounds) {
          this.addListenerOnce("appear", function () {
            // It's important that the registered events are first dispatched.
            qx.event.Timer.once(function () {
              this.scrollRowIntoView(row);
            }, this, 0);
          }, this);
          return;
        }

        var itemTop = this.__rowConfig__P_544_0.getItemPosition(row);

        var itemBottom = itemTop + this.__rowConfig__P_544_0.getItemSize(row);

        var scrollTop = this.getScrollY();

        if (itemTop < scrollTop) {
          this.setScrollY(itemTop);
        } else if (itemBottom > scrollTop + bounds.height) {
          this.setScrollY(itemBottom - bounds.height);
        }
      },

      /**
       * Scrolls a column into the visible area of the pane.
       *
       * @param column {Integer} The column's index.
       */
      scrollColumnIntoView: function scrollColumnIntoView(column) {
        var bounds = this.getBounds();

        if (!bounds) {
          this.addListenerOnce("appear", function () {
            // It's important that the registered events are first dispatched.
            qx.event.Timer.once(function () {
              this.scrollColumnIntoView(column);
            }, this, 0);
          }, this);
          return;
        }

        var itemLeft = this.__columnConfig__P_544_1.getItemPosition(column);

        var itemRight = itemLeft + this.__columnConfig__P_544_1.getItemSize(column);

        var scrollLeft = this.getScrollX();

        if (itemLeft < scrollLeft) {
          this.setScrollX(itemLeft);
        } else if (itemRight > scrollLeft + bounds.width) {
          this.setScrollX(itemRight - bounds.width);
        }
      },

      /**
       * Scrolls a grid cell into the visible area of the pane.
       *
       * @param row {Integer} The cell's row index.
       * @param column {Integer} The cell's column index.
       */
      scrollCellIntoView: function scrollCellIntoView(column, row) {
        var bounds = this.getBounds();

        if (!bounds) {
          this.addListenerOnce("appear", function () {
            // It's important that the registered events are first dispatched.
            qx.event.Timer.once(function () {
              this.scrollCellIntoView(column, row);
            }, this, 0);
          }, this);
          return;
        }

        this.scrollColumnIntoView(column);
        this.scrollRowIntoView(row);
      },

      /*
      ---------------------------------------------------------------------------
        CELL SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Get the grid cell at the given absolute document coordinates. This method
       * can be used to convert the pointer position returned by
       * {@link qx.event.type.Pointer#getDocumentLeft} and
       * {@link qx.event.type.Pointer#getDocumentLeft} into cell coordinates.
       *
       * @param documentX {Integer} The x coordinate relative to the viewport
       *    origin.
       * @param documentY {Integer} The y coordinate relative to the viewport
       *    origin.
       * @return {Map|null} A map containing the <code>row</code> and <code>column</code>
       *    of the found cell. If the coordinate is outside of the pane's bounds
       *    or there is no cell at the coordinate <code>null</code> is returned.
       */
      getCellAtPosition: function getCellAtPosition(documentX, documentY) {
        var rowData, columnData;
        var paneLocation = this.getContentLocation();

        if (!paneLocation || documentY < paneLocation.top || documentY >= paneLocation.bottom || documentX < paneLocation.left || documentX >= paneLocation.right) {
          return null;
        }

        rowData = this.__rowConfig__P_544_0.getItemAtPosition(this.getScrollY() + documentY - paneLocation.top);
        columnData = this.__columnConfig__P_544_1.getItemAtPosition(this.getScrollX() + documentX - paneLocation.left);

        if (!rowData || !columnData) {
          return null;
        }

        return {
          row: rowData.index,
          column: columnData.index
        };
      },

      /*
      ---------------------------------------------------------------------------
        PREFETCH SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       * Increase the layers width beyond the needed width to improve
       * horizontal scrolling. The layers are only resized if invisible parts
       * left/right of the pane window are smaller than minLeft/minRight.
       *
       * @param minLeft {Integer} Only prefetch if the invisible part left of the
       *    pane window if smaller than this (pixel) value.
       * @param maxLeft {Integer} The amount of pixel the layers should reach
       *    left of the pane window.
       * @param minRight {Integer} Only prefetch if the invisible part right of the
       *    pane window if smaller than this (pixel) value.
       * @param maxRight {Integer} The amount of pixel the layers should reach
       *    right of the pane window.
       */
      prefetchX: function prefetchX(minLeft, maxLeft, minRight, maxRight) {
        var layers = this.getVisibleLayers();

        if (layers.length == 0) {
          return;
        }

        var bounds = this.getBounds();

        if (!bounds) {
          return;
        }

        var paneRight = this.__scrollLeft__P_544_3 + bounds.width;
        var rightAvailable = this.__paneWidth__P_544_5 - paneRight;

        if (this.__scrollLeft__P_544_3 - this.__layerWindow__P_544_6.left < Math.min(this.__scrollLeft__P_544_3, minLeft) || this.__layerWindow__P_544_6.right - paneRight < Math.min(rightAvailable, minRight)) {
          var left = Math.min(this.__scrollLeft__P_544_3, maxLeft);
          var right = Math.min(rightAvailable, maxRight);

          this._setLayerWindow(layers, this.__scrollLeft__P_544_3 - left, this.__scrollTop__P_544_2, bounds.width + left + right, bounds.height, false);
        }
      },

      /**
       * Increase the layers height beyond the needed height to improve
       * vertical scrolling. The layers are only resized if invisible parts
       * above/below the pane window are smaller than minAbove/minBelow.
       *
       * @param minAbove {Integer} Only prefetch if the invisible part above the
       *    pane window if smaller than this (pixel) value.
       * @param maxAbove {Integer} The amount of pixel the layers should reach
       *    above the pane window.
       * @param minBelow {Integer} Only prefetch if the invisible part below the
       *    pane window if smaller than this (pixel) value.
       * @param maxBelow {Integer} The amount of pixel the layers should reach
       *    below the pane window.
       */
      prefetchY: function prefetchY(minAbove, maxAbove, minBelow, maxBelow) {
        var layers = this.getVisibleLayers();

        if (layers.length == 0) {
          return;
        }

        var bounds = this.getBounds();

        if (!bounds) {
          return;
        }

        var paneBottom = this.__scrollTop__P_544_2 + bounds.height;
        var belowAvailable = this.__paneHeight__P_544_4 - paneBottom;

        if (this.__scrollTop__P_544_2 - this.__layerWindow__P_544_6.top < Math.min(this.__scrollTop__P_544_2, minAbove) || this.__layerWindow__P_544_6.bottom - paneBottom < Math.min(belowAvailable, minBelow)) {
          var above = Math.min(this.__scrollTop__P_544_2, maxAbove);
          var below = Math.min(belowAvailable, maxBelow);

          this._setLayerWindow(layers, this.__scrollLeft__P_544_3, this.__scrollTop__P_544_2 - above, bounds.width, bounds.height + above + below, false);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENER
      ---------------------------------------------------------------------------
      */

      /**
       * Resize event handler.
       *
       * Updates the visible window.
       */
      _onResize: function _onResize() {
        if (this.getContentElement().getDomElement()) {
          this.__dontFireUpdate__P_544_10 = true;

          this._updateScrollPosition();

          this.__dontFireUpdate__P_544_10 = null;
          this.fireEvent("update");
        }
      },

      /**
       * Resize event handler. Do a full update on first appear.
       */
      _onAppear: function _onAppear() {
        this.fullUpdate();
      },

      /**
       * Event listener for pointer down. Remembers cell position to prevent pointer event when cell position change.
       *
       * @param e {qx.event.type.Pointer} The incoming pointer event.
       */
      _onPointerDown: function _onPointerDown(e) {
        this.__pointerDownCoords__P_544_13 = this.getCellAtPosition(e.getDocumentLeft(), e.getDocumentTop());
      },

      /**
       * Event listener for pointer taps. Fires an cellTap event.
       *
       * @param e {qx.event.type.Pointer} The incoming pointer event.
       */
      _onTap: function _onTap(e) {
        this.__handlePointerCellEvent__P_544_14(e, "cellTap");
      },

      /**
       * Event listener for context menu taps. Fires an cellContextmenu event.
       *
       * @param e {qx.event.type.Pointer} The incoming pointer event.
       */
      _onContextmenu: function _onContextmenu(e) {
        this.__handlePointerCellEvent__P_544_14(e, "cellContextmenu");
      },

      /**
       * Event listener for double taps. Fires an cellDbltap event.
       *
       * @param e {qx.event.type.Pointer} The incoming pointer event.
       */
      _onDbltap: function _onDbltap(e) {
        this.__handlePointerCellEvent__P_544_14(e, "cellDbltap");
      },

      /**
       * Fixed scrollbar position whenever it is out of range
       * it can happen when removing an item from the list reducing
       * the max value for scrollY #8976
       */
      _checkScrollBounds: function _checkScrollBounds() {
        var maxx = this.getScrollMaxX();
        var maxy = this.getScrollMaxY();

        if (this.__scrollLeft__P_544_3 < 0) {
          this.__scrollLeft__P_544_3 = 0;
        } else if (this.__scrollLeft__P_544_3 > maxx) {
          this.__scrollLeft__P_544_3 = maxx;
        }

        if (this.__scrollTop__P_544_2 < 0) {
          this.__scrollTop__P_544_2 = 0;
        } else if (this.__scrollTop__P_544_2 > maxy) {
          this.__scrollTop__P_544_2 = maxy;
        }
      },

      /**
       * Converts a pointer event into a cell event and fires the cell event if the
       * pointer is over a cell.
       *
       * @param e {qx.event.type.Pointer} The pointer event.
       * @param cellEventType {String} The name of the cell event to fire.
       */
      __handlePointerCellEvent__P_544_14: function __handlePointerCellEvent__P_544_14(e, cellEventType) {
        var coords = this.getCellAtPosition(e.getDocumentLeft(), e.getDocumentTop());

        if (!coords) {
          return;
        }

        var pointerDownCoords = this.__pointerDownCoords__P_544_13;

        if (pointerDownCoords == null || pointerDownCoords.row !== coords.row || pointerDownCoords.column !== coords.column) {
          return;
        }

        this.fireNonBubblingEvent(cellEventType, qx.ui.virtual.core.CellEvent, [this, e, coords.row, coords.column]);
      },

      /*
      ---------------------------------------------------------------------------
        PANE UPDATE
      ---------------------------------------------------------------------------
      */
      // overridden
      syncWidget: function syncWidget(jobs) {
        if (this.__jobs__P_544_7._fullUpdate) {
          this._checkScrollBounds();

          this._fullUpdate();
        } else if (this.__jobs__P_544_7._updateScrollPosition) {
          this._checkScrollBounds();

          this._updateScrollPosition();
        }

        this.__jobs__P_544_7 = {};
      },

      /**
       * Sets the size of the layers to contain the cells at the pixel position
       * "left/right" up to "left+minHeight/right+minHeight". The offset of the
       * layer container is adjusted to respect the pane's scroll top and scroll
       * left values.
       *
       * @param layers {qx.ui.virtual.core.ILayer[]} List of layers to update.
       * @param left {Integer} Maximum left pixel coordinate of the layers.
       * @param top {Integer} Maximum top pixel coordinate of the layers.
       * @param minWidth {Integer} The minimum end coordinate of the layers will
       *    be larger than <code>left+minWidth</code>.
       * @param minHeight {Integer} The minimum end coordinate of the layers will
       *    be larger than <code>top+minHeight</code>.
       * @param doFullUpdate {Boolean?false} Whether a full update on the layer
       *    should be performed of if only the layer window should be updated.
       */
      _setLayerWindow: function _setLayerWindow(layers, left, top, minWidth, minHeight, doFullUpdate) {
        var rowCellData = this.__rowConfig__P_544_0.getItemAtPosition(top);

        if (rowCellData) {
          var firstRow = rowCellData.index;

          var rowSizes = this.__rowConfig__P_544_0.getItemSizes(firstRow, minHeight + rowCellData.offset);

          var layerHeight = qx.lang.Array.sum(rowSizes);
          var layerTop = top - rowCellData.offset;
          var layerBottom = top - rowCellData.offset + layerHeight;
        } else {
          var firstRow = 0;
          var rowSizes = [];
          var layerHeight = 0;
          var layerTop = 0;
          var layerBottom = 0;
        }

        var columnCellData = this.__columnConfig__P_544_1.getItemAtPosition(left);

        if (columnCellData) {
          var firstColumn = columnCellData.index;

          var columnSizes = this.__columnConfig__P_544_1.getItemSizes(firstColumn, minWidth + columnCellData.offset);

          var layerWidth = qx.lang.Array.sum(columnSizes);
          var layerLeft = left - columnCellData.offset;
          var layerRight = left - columnCellData.offset + layerWidth;
        } else {
          var firstColumn = 0;
          var columnSizes = [];
          var layerWidth = 0;
          var layerLeft = 0;
          var layerRight = 0;
        }

        this.__layerWindow__P_544_6 = {
          top: layerTop,
          bottom: layerBottom,
          left: layerLeft,
          right: layerRight
        };

        this.__layerContainer__P_544_8.setUserBounds((this.getPaddingLeft() || 0) + (this.__layerWindow__P_544_6.left - this.__scrollLeft__P_544_3), (this.getPaddingTop() || 0) + (this.__layerWindow__P_544_6.top - this.__scrollTop__P_544_2), layerWidth, layerHeight);

        this.__columnSizes__P_544_11 = columnSizes;
        this.__rowSizes__P_544_12 = rowSizes;

        for (var i = 0; i < this.__layers__P_544_9.length; i++) {
          var layer = this.__layers__P_544_9[i];
          layer.setUserBounds(0, 0, layerWidth, layerHeight);

          if (doFullUpdate) {
            layer.fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
          } else {
            layer.updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes);
          }
        }
      },

      /**
       * Check whether the pane was resized and fire an {@link #update} event if
       * it was.
       */
      __checkPaneResize__P_544_15: function __checkPaneResize__P_544_15() {
        if (this.__dontFireUpdate__P_544_10) {
          return;
        }

        var scrollSize = this.getScrollSize();

        if (this.__paneHeight__P_544_4 !== scrollSize.height || this.__paneWidth__P_544_5 !== scrollSize.width) {
          this.__paneHeight__P_544_4 = scrollSize.height;
          this.__paneWidth__P_544_5 = scrollSize.width;
          this.fireEvent("update");
        }
      },

      /**
       * Schedule a full update on all visible layers.
       */
      fullUpdate: function fullUpdate() {
        this.__jobs__P_544_7._fullUpdate = 1;
        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * Whether a full update is scheduled.
       *
       * @return {Boolean} Whether a full update is scheduled.
       */
      isUpdatePending: function isUpdatePending() {
        return !!this.__jobs__P_544_7._fullUpdate;
      },

      /**
       * Perform a full update on all visible layers. All cached data will be
       * discarded.
       */
      _fullUpdate: function _fullUpdate() {
        var layers = this.getVisibleLayers();

        if (layers.length == 0) {
          this.__checkPaneResize__P_544_15();

          return;
        }

        var bounds = this.getBounds();

        if (!bounds) {
          return; // the pane has not yet been rendered -> wait for the appear event
        }

        this._setLayerWindow(layers, this.__scrollLeft__P_544_3, this.__scrollTop__P_544_2, bounds.width, bounds.height, true);

        this.__checkPaneResize__P_544_15();
      },

      /**
       * Schedule an update the visible window of the grid according to the top
       * and left scroll positions.
       */
      _deferredUpdateScrollPosition: function _deferredUpdateScrollPosition() {
        this.__jobs__P_544_7._updateScrollPosition = 1;
        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * Update the visible window of the grid according to the top and left scroll
       * positions.
       */
      _updateScrollPosition: function _updateScrollPosition() {
        var layers = this.getVisibleLayers();

        if (layers.length == 0) {
          this.__checkPaneResize__P_544_15();

          return;
        }

        var bounds = this.getBounds();

        if (!bounds) {
          return; // the pane has not yet been rendered -> wait for the appear event
        } // the visible window of the virtual coordinate space


        var paneWindow = {
          top: this.__scrollTop__P_544_2,
          bottom: this.__scrollTop__P_544_2 + bounds.height,
          left: this.__scrollLeft__P_544_3,
          right: this.__scrollLeft__P_544_3 + bounds.width
        };

        if (this.__layerWindow__P_544_6.top <= paneWindow.top && this.__layerWindow__P_544_6.bottom >= paneWindow.bottom && this.__layerWindow__P_544_6.left <= paneWindow.left && this.__layerWindow__P_544_6.right >= paneWindow.right) {
          // only update layer container offset
          this.__layerContainer__P_544_8.setUserBounds((this.getPaddingLeft() || 0) + (this.__layerWindow__P_544_6.left - paneWindow.left), (this.getPaddingTop() || 0) + (this.__layerWindow__P_544_6.top - paneWindow.top), this.__layerWindow__P_544_6.right - this.__layerWindow__P_544_6.left, this.__layerWindow__P_544_6.bottom - this.__layerWindow__P_544_6.top);
        } else {
          this._setLayerWindow(layers, this.__scrollLeft__P_544_3, this.__scrollTop__P_544_2, bounds.width, bounds.height, false);
        }

        this.__checkPaneResize__P_544_15();
      }
    },
    destruct: function destruct() {
      this._disposeArray("__layers__P_544_9");

      this._disposeObjects("__rowConfig__P_544_0", "__columnConfig__P_544_1", "__layerContainer__P_544_8");

      this.__layerWindow__P_544_6 = this.__jobs__P_544_7 = this.__columnSizes__P_544_11 = this.__rowSizes__P_544_12 = null;
    }
  });
  qx.ui.virtual.core.Pane.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.core.Scroller": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.selection.MModel": {
        "require": true
      },
      "qx.data.controller.ISelection": {
        "require": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.ui.virtual.layer.Row": {},
      "qx.ui.list.provider.WidgetProvider": {},
      "qx.event.type.Data": {},
      "qx.util.DeferredCall": {},
      "qx.util.Delegate": {},
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The <code>qx.ui.list.List</code> is based on the virtual infrastructure and
   * supports filtering, sorting, grouping, single selection, multi selection,
   * data binding and custom rendering.
   *
   * Using the virtual infrastructure has considerable advantages when there is a
   * huge amount of model items to render because the virtual infrastructure only
   * creates widgets for visible items and reuses them. This saves both creation
   * time and memory.
   *
   * With the {@link qx.ui.list.core.IListDelegate} interface it is possible
   * to configure the list's behavior (item and group renderer configuration,
   * filtering, sorting, grouping, etc.).
   *
   * Here's an example of how to use the widget:
   * <pre class="javascript">
   * //create the model data
   * var rawData = [];
   * for (var i = 0; i < 2500; i++) {
   *  rawData[i] = "Item No " + i;
   * }
   * var model = qx.data.marshal.Json.createModel(rawData);
   *
   * //create the list
   * var list = new qx.ui.list.List(model);
   *
   * //configure the lists's behavior
   * var delegate = {
   *   sorter : function(a, b) {
   *     return a > b ? 1 : a < b ? -1 : 0;
   *   }
   * };
   * list.setDelegate(delegate);
   *
   * //Pre-Select "Item No 20"
   * list.getSelection().push(model.getItem(20));
   *
   * //log selection changes
   * list.getSelection().addListener("change", function(e) {
   *   this.debug("Selection: " + list.getSelection().getItem(0));
   * }, this);
   * </pre>
   *
   * @childControl row-layer {qx.ui.virtual.layer.Row} layer for all rows
   */
  qx.Class.define("qx.ui.list.List", {
    extend: qx.ui.virtual.core.Scroller,
    include: [qx.ui.virtual.selection.MModel],
    implement: qx.data.controller.ISelection,

    /**
     * Creates the <code>qx.ui.list.List</code> with the passed model.
     *
     * @param model {qx.data.IListData|null?} model for the list.
     */
    construct: function construct(model) {
      qx.ui.virtual.core.Scroller.constructor.call(this, 0, 1, 20, 100);

      this._init();

      this.__defaultGroups__P_440_0 = new qx.data.Array();
      this.initGroups(this.__defaultGroups__P_440_0);

      if (model != null) {
        this.initModel(model);
      }

      this.initItemHeight();
    },
    events: {
      /**
       * Fired when the length of {@link #model} changes.
       */
      "changeModelLength": "qx.event.type.Data"
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "virtual-list"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 100
      },
      // overridden
      height: {
        refine: true,
        init: 200
      },

      /** Data array containing the data which should be shown in the list. */
      model: {
        check: "qx.data.IListData",
        apply: "_applyModel",
        event: "changeModel",
        nullable: true,
        deferredInit: true
      },

      /** Default item height */
      itemHeight: {
        check: "Integer",
        init: 25,
        apply: "_applyRowHeight",
        themeable: true
      },

      /** Group item height */
      groupItemHeight: {
        check: "Integer",
        init: null,
        nullable: true,
        apply: "_applyGroupRowHeight",
        themeable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as a label. This is only needed if objects are stored in the
       * model.
       */
      labelPath: {
        check: "String",
        apply: "_applyLabelPath",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as an icon. This is only needed if objects are stored in the
       * model and icons should be displayed.
       */
      iconPath: {
        check: "String",
        apply: "_applyIconPath",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as a group label. This is only needed if objects are stored in the
       * model.
       */
      groupLabelPath: {
        check: "String",
        apply: "_applyGroupLabelPath",
        nullable: true
      },

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      labelOptions: {
        apply: "_applyLabelOptions",
        nullable: true
      },

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      iconOptions: {
        apply: "_applyIconOptions",
        nullable: true
      },

      /**
       * A map containing the options for the group label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      groupLabelOptions: {
        apply: "_applyGroupLabelOptions",
        nullable: true
      },

      /**
       * Delegation object which can have one or more functions defined by the
       * {@link qx.ui.list.core.IListDelegate} interface.
       */
      delegate: {
        apply: "_applyDelegate",
        event: "changeDelegate",
        init: null,
        nullable: true
      },

      /**
       * Indicates that the list is managing the {@link #groups} automatically.
       */
      autoGrouping: {
        check: "Boolean",
        init: true
      },

      /**
       * Contains all groups for data binding, but do only manipulate the array
       * when the {@link #autoGrouping} is set to <code>false</code>.
       */
      groups: {
        check: "qx.data.Array",
        event: "changeGroups",
        nullable: false,
        deferredInit: true
      },

      /** 
       * Render list items with variable height, 
       * calculated from the individual item size. 
       */
      variableItemHeight: {
        check: "Boolean",
        apply: "_applyVariableItemHeight",
        nullable: false,
        init: true
      }
    },
    members: {
      /** @type {qx.ui.virtual.layer.Row} background renderer */
      _background: null,

      /** @type {qx.ui.list.provider.IListProvider} provider for cell rendering */
      _provider: null,

      /** @type {qx.ui.virtual.layer.Abstract} layer which contains the items. */
      _layer: null,

      /**
       * @type {Array} lookup table to get the model index from a row. To get the
       *   correct value after applying filter, sorter, group.
       *
       * Note the value <code>-1</code> indicates that the value is a group item.
       */
      __lookupTable__P_440_1: null,

      /** @type {Array} lookup table for getting the group index from the row */
      __lookupTableForGroup__P_440_2: null,

      /**
       * @type {Map} contains all groups with the items as children. The key is
       *   the group name and the value is an <code>Array</code> containing each
       *   item's model index.
       */
      __groupHashMap__P_440_3: null,

      /**
       * @type {Boolean} indicates when one or more <code>String</code> are used for grouping.
       */
      __groupStringsUsed__P_440_4: false,

      /**
       * @type {Boolean} indicates when one or more <code>Object</code> are used for grouping.
       */
      __groupObjectsUsed__P_440_5: false,

      /**
       * @type {Boolean} indicates when a default group is used for grouping.
       */
      __defaultGroupUsed__P_440_6: false,
      __defaultGroups__P_440_0: null,
      __deferredLayerUpdate__P_440_7: null,

      /**
       * Trigger a rebuild from the internal data structure.
       */
      refresh: function refresh() {
        this.__buildUpLookupTable__P_440_8();
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "row-layer":
            control = new qx.ui.virtual.layer.Row(null, null);
            break;
        }

        return control || qx.ui.list.List.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Initialize the virtual list provider.
       */
      _initWidgetProvider: function _initWidgetProvider() {
        this._provider = new qx.ui.list.provider.WidgetProvider(this);
      },

      /**
       * Initializes the virtual list.
       */
      _init: function _init() {
        this._initWidgetProvider();

        this.__lookupTable__P_440_1 = [];
        this.__lookupTableForGroup__P_440_2 = [];
        this.__groupHashMap__P_440_3 = {};
        this.__groupStringsUsed__P_440_4 = false;
        this.__groupObjectsUsed__P_440_5 = false;
        this.__defaultGroupUsed__P_440_6 = false;
        this.getPane().addListener("resize", this._onResize, this);

        this._initBackground();

        this._initLayer();
      },

      /**
       * Initializes the background renderer.
       */
      _initBackground: function _initBackground() {
        this._background = this.getChildControl("row-layer");
        this.getPane().addLayer(this._background);
      },

      /**
       * Initializes the layer for rendering.
       */
      _initLayer: function _initLayer() {
        this._layer = this._provider.createLayer();

        this._layer.addListener("updated", this._onLayerUpdated, this);

        this.getPane().addLayer(this._layer);
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the model data for the given row.
       *
       * @param row {Integer} row to get data for.
       * @return {var|null} the row's model data.
       */
      _getDataFromRow: function _getDataFromRow(row) {
        var data = null;
        var model = this.getModel();

        if (model == null) {
          return null;
        }

        if (this._isGroup(row)) {
          data = this.getGroups().getItem(this._lookupGroup(row));
        } else {
          data = model.getItem(this._lookup(row));
        }

        if (data != null) {
          return data;
        } else {
          return null;
        }
      },

      /**
       * Return the internal lookup table. But do not manipulate the
       * lookup table!
       *
       * @return {Array} The internal lookup table.
       */
      _getLookupTable: function _getLookupTable() {
        return this.__lookupTable__P_440_1;
      },

      /**
       * Performs a lookup from row to model index.
       *
       * @param row {Number} The row to look at.
       * @return {Number} The model index or
       *   <code>-1</code> if the row is a group item.
       */
      _lookup: function _lookup(row) {
        return this.__lookupTable__P_440_1[row];
      },

      /**
       * Performs a lookup from row to group index.
       *
       * @param row {Number} The row to look at.
       * @return {Number} The group index or
       *   <code>-1</code> if the row is a not a group item.
       */
      _lookupGroup: function _lookupGroup(row) {
        return this.__lookupTableForGroup__P_440_2.indexOf(row);
      },

      /**
       * Performs a lookup from model index to row.
       *
       * @param index {Number} The index to look at.
       * @return {Number} The row or <code>-1</code>
       *  if the index is not a model index.
       */
      _reverseLookup: function _reverseLookup(index) {
        if (index < 0) {
          return -1;
        }

        return this.__lookupTable__P_440_1.indexOf(index);
      },

      /**
       * Checks if the passed row is a group or an item.
       *
       * @param row {Integer} row to check.
       * @return {Boolean} <code>true</code> if the row is a group element,
       *  <code>false</code> if the row is an item element.
       */
      _isGroup: function _isGroup(row) {
        return this._lookup(row) == -1;
      },

      /**
       * Returns the selectable model items.
       *
       * @return {qx.data.Array | null} The selectable items.
       */
      _getSelectables: function _getSelectables() {
        return this.getModel();
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // apply method
      _applyModel: function _applyModel(value, old) {
        if (value != null) {
          value.addListener("changeLength", this._onModelChange, this);
        }

        if (old != null) {
          old.removeListener("changeLength", this._onModelChange, this);
        }

        this._onModelChange();
      },
      // apply method
      _applyRowHeight: function _applyRowHeight(value, old) {
        this.getPane().getRowConfig().setDefaultItemSize(value);
      },
      // apply method
      _applyGroupRowHeight: function _applyGroupRowHeight(value, old) {
        this.__updateGroupRowHeight__P_440_9();
      },
      // apply method
      _applyLabelPath: function _applyLabelPath(value, old) {
        this._provider.setLabelPath(value);
      },
      // apply method
      _applyIconPath: function _applyIconPath(value, old) {
        this._provider.setIconPath(value);
      },
      // apply method
      _applyGroupLabelPath: function _applyGroupLabelPath(value, old) {
        this._provider.setGroupLabelPath(value);
      },
      // apply method
      _applyLabelOptions: function _applyLabelOptions(value, old) {
        this._provider.setLabelOptions(value);
      },
      // apply method
      _applyIconOptions: function _applyIconOptions(value, old) {
        this._provider.setIconOptions(value);
      },
      // apply method
      _applyGroupLabelOptions: function _applyGroupLabelOptions(value, old) {
        this._provider.setGroupLabelOptions(value);
      },
      // apply method
      _applyDelegate: function _applyDelegate(value, old) {
        this._provider.setDelegate(value);

        this.__buildUpLookupTable__P_440_8();
      },
      // property apply
      _applyVariableItemHeight: function _applyVariableItemHeight(value, old) {
        if (value) {
          this._setRowItemSize();
        } else {
          this.getPane().getRowConfig().resetItemSizes();
          this.getPane().fullUpdate();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the resize event.
       *
       * @param e {qx.event.type.Data} resize event.
       */
      _onResize: function _onResize(e) {
        this.getPane().getColumnConfig().setItemSize(0, e.getData().width);
      },

      /**
       * Event handler for the model change event.
       *
       * @param e {qx.event.type.Data} model change event.
       */
      _onModelChange: function _onModelChange(e) {
        // we have to remove the bindings before we rebuild the lookup table
        // otherwise bindings might be dispatched to wrong items
        // see: https://github.com/qooxdoo/qooxdoo/issues/196
        this._provider.removeBindings();

        this.__buildUpLookupTable__P_440_8();

        this._applyDefaultSelection();

        if (e instanceof qx.event.type.Data) {
          this.fireDataEvent("changeModelLength", e.getData(), e.getOldData());
        }
      },

      /**
       * Event handler for the updated event of the 
       * qx.ui.virtual.layer.WidgetCell layer.
       *
       * Recalculates the item sizes in a deffered call,
       * which only happens if we have variable item heights
       */
      _onLayerUpdated: function _onLayerUpdated() {
        if (this.isVariableItemHeight() === false) {
          return;
        }

        if (this.__deferredLayerUpdate__P_440_7 === null) {
          this.__deferredLayerUpdate__P_440_7 = new qx.util.DeferredCall(function () {
            this._setRowItemSize();
          }, this);
        }

        this.__deferredLayerUpdate__P_440_7.schedule();
      },

      /*
      ---------------------------------------------------------------------------
        HELPER ROUTINES
      ---------------------------------------------------------------------------
      */

      /**
       * Helper method to update the row count.
       */
      __updateRowCount__P_440_10: function __updateRowCount__P_440_10() {
        this.getPane().getRowConfig().setItemCount(this.__lookupTable__P_440_1.length);
        this.getPane().fullUpdate();
      },

      /**
       * Helper method to update group row heights.
       */
      __updateGroupRowHeight__P_440_9: function __updateGroupRowHeight__P_440_9() {
        /*
         * In case of having variableItemHeight set to true,
         * the group item height has a variable height as well
         * and will be set again in method _setRowItemSize 
         * which is a deferred call, being run after all changes.
         * Resetting the complete item sizes here and setting
         * the height of the group items, only leads to an
         * unnecessary flicker of the list items by shrinking and
         * growing them again.
         */
        if (this.isVariableItemHeight()) {
          return;
        }

        var rc = this.getPane().getRowConfig();
        var gh = this.getGroupItemHeight();
        rc.resetItemSizes();

        if (gh) {
          for (var i = 0, l = this.__lookupTable__P_440_1.length; i < l; ++i) {
            if (this.__lookupTable__P_440_1[i] == -1) {
              rc.setItemSize(i, gh);
            }
          }
        }
      },

      /**
       * Internal method for building the lookup table.
       */
      __buildUpLookupTable__P_440_8: function __buildUpLookupTable__P_440_8() {
        this.__lookupTable__P_440_1 = [];
        this.__lookupTableForGroup__P_440_2 = [];
        this.__groupHashMap__P_440_3 = {};

        if (this.isAutoGrouping()) {
          this.getGroups().removeAll();
        }

        var model = this.getModel();

        if (model != null) {
          this._runDelegateFilter(model);

          this._runDelegateSorter(model);

          this._runDelegateGroup(model);
        }

        this._updateSelection();

        this.__updateGroupRowHeight__P_440_9();

        this.__updateRowCount__P_440_10();
      },

      /**
       * Invokes filtering using the filter given in the delegate.
       *
       * @param model {qx.data.IListData} The model.
       */
      _runDelegateFilter: function _runDelegateFilter(model) {
        var filter = qx.util.Delegate.getMethod(this.getDelegate(), "filter");

        for (var i = 0, l = model.length; i < l; ++i) {
          if (filter == null || filter(model.getItem(i))) {
            this.__lookupTable__P_440_1.push(i);
          }
        }
      },

      /**
       * Invokes sorting using the sorter given in the delegate.
       *
       * @param model {qx.data.IListData} The model.
       */
      _runDelegateSorter: function _runDelegateSorter(model) {
        if (this.__lookupTable__P_440_1.length == 0) {
          return;
        }

        var sorter = qx.util.Delegate.getMethod(this.getDelegate(), "sorter");

        if (sorter != null) {
          this.__lookupTable__P_440_1.sort(function (a, b) {
            return sorter(model.getItem(a), model.getItem(b));
          });
        }
      },

      /**
       * Invokes grouping using the group result given in the delegate.
       *
       * @param model {qx.data.IListData} The model.
       */
      _runDelegateGroup: function _runDelegateGroup(model) {
        var groupMethod = qx.util.Delegate.getMethod(this.getDelegate(), "group");

        if (groupMethod != null) {
          for (var i = 0, l = this.__lookupTable__P_440_1.length; i < l; ++i) {
            var index = this.__lookupTable__P_440_1[i];
            var item = this.getModel().getItem(index);
            var group = groupMethod(item);

            this.__addGroup__P_440_11(group, index);
          }

          this.__lookupTable__P_440_1 = this.__createLookupFromGroup__P_440_12();
        }
      },

      /**
       * Adds a model index the the group.
       *
       * @param group {String|Object|null} the group.
       * @param index {Integer} model index to add.
       */
      __addGroup__P_440_11: function __addGroup__P_440_11(group, index) {
        // if group is null add to default group
        if (group == null) {
          this.__defaultGroupUsed__P_440_6 = true;
          group = "???";
        }

        var name = this.__getUniqueGroupName__P_440_13(group);

        if (this.__groupHashMap__P_440_3[name] == null) {
          this.__groupHashMap__P_440_3[name] = [];

          if (this.isAutoGrouping()) {
            this.getGroups().push(group);
          }
        }

        this.__groupHashMap__P_440_3[name].push(index);
      },

      /**
       * Creates a lookup table form the internal group hash map.
       *
       * @return {Array} the lookup table based on the internal group hash map.
       */
      __createLookupFromGroup__P_440_12: function __createLookupFromGroup__P_440_12() {
        this.__checkGroupStructure__P_440_14();

        var result = [];
        var row = 0;
        var groups = this.getGroups();

        for (var i = 0; i < groups.getLength(); i++) {
          var group = groups.getItem(i); // indicate that the value is a group

          result.push(-1);

          this.__lookupTableForGroup__P_440_2.push(row);

          row++;

          var key = this.__getUniqueGroupName__P_440_13(group);

          var groupMembers = this.__groupHashMap__P_440_3[key];

          if (groupMembers != null) {
            for (var k = 0; k < groupMembers.length; k++) {
              result.push(groupMembers[k]);
              row++;
            }
          }
        }

        return result;
      },

      /**
       * Returns an unique group name for the passed group.
       *
       * @param group {String|Object} Group to find unique group name.
       * @return {String} Unique group name.
       */
      __getUniqueGroupName__P_440_13: function __getUniqueGroupName__P_440_13(group) {
        var name = null;

        if (!qx.lang.Type.isString(group)) {
          var index = this.getGroups().indexOf(group);
          this.__groupObjectsUsed__P_440_5 = true;
          name = "group";

          if (index == -1) {
            name += this.getGroups().getLength();
          } else {
            name += index;
          }
        } else {
          this.__groupStringsUsed__P_440_4 = true;
          var name = group;
        }

        return name;
      },

      /**
       * Checks that <code>Object</code> and <code>String</code> are not mixed
       * as group identifier, otherwise an exception occurs.
       */
      __checkGroupStructure__P_440_14: function __checkGroupStructure__P_440_14() {
        if (this.__groupObjectsUsed__P_440_5 && this.__defaultGroupUsed__P_440_6 || this.__groupObjectsUsed__P_440_5 && this.__groupStringsUsed__P_440_4) {
          throw new Error("GroupingTypeError: You can't mix 'Objects' and 'Strings' as group identifier!");
        }
      },

      /**
       * Get the height of each visible item and set it as the
       * row size
       */
      _setRowItemSize: function _setRowItemSize() {
        var rowConfig = this.getPane().getRowConfig();
        var layer = this._layer;
        var firstRow = layer.getFirstRow();
        var lastRow = firstRow + layer.getRowSizes().length;

        for (var row = firstRow; row < lastRow; row++) {
          var widget = layer.getRenderedCellWidget(row, 0);

          if (widget !== null) {
            var height = widget.getSizeHint().height;
            rowConfig.setItemSize(row, height);
          }
        }
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__deferredLayerUpdate__P_440_7");

      var model = this.getModel();

      if (model != null) {
        model.removeListener("changeLength", this._onModelChange, this);
      }

      var pane = this.getPane();

      if (pane != null) {
        pane.removeListener("resize", this._onResize, this);
      }

      this._background.dispose();

      this._provider.dispose();

      this._layer.dispose();

      this._background = this._provider = this._layer = this.__lookupTable__P_440_1 = this.__lookupTableForGroup__P_440_2 = this.__groupHashMap__P_440_3 = null;

      if (this.__defaultGroups__P_440_0) {
        this.__defaultGroups__P_440_0.dispose();
      }
    }
  });
  qx.ui.list.List.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.selection.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.Pane": {
        "construct": true
      },
      "qx.bom.element.Location": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Abstract base class for selection manager, which manage selectable items
   * rendered in a virtual {@link qx.ui.virtual.core.Pane}.
   */
  qx.Class.define("qx.ui.virtual.selection.Abstract", {
    extend: qx.ui.core.selection.Abstract,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */

    /**
     * @param pane {qx.ui.virtual.core.Pane} The virtual pane on which the
     *    selectable item are rendered
     * @param selectionDelegate {qx.ui.virtual.selection.ISelectionDelegate?null} An optional delegate,
     *    which can be used to customize the behavior of the selection manager
     *    without sub classing it.
     */
    construct: function construct(pane, selectionDelegate) {
      qx.ui.core.selection.Abstract.constructor.call(this);
      {
        this.assertInstance(pane, qx.ui.virtual.core.Pane);
      }
      this._pane = pane;
      this._delegate = selectionDelegate || {};
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // Determines if automatically scrolling of selected item into view is active.
      _autoScrollIntoView: true,

      /*
      ---------------------------------------------------------------------------
        DELEGATE METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _isSelectable: function _isSelectable(item) {
        return this._delegate.isItemSelectable ? this._delegate.isItemSelectable(item) : true;
      },
      // overridden
      _styleSelectable: function _styleSelectable(item, type, enabled) {
        if (this._delegate.styleSelectable) {
          this._delegate.styleSelectable(item, type, enabled);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENTS
      ---------------------------------------------------------------------------
      */

      /**
       * Attach pointer events to the managed pane.
       */
      attachPointerEvents: function attachPointerEvents() {
        var paneElement = this._pane.getContentElement();

        paneElement.addListener("pointerdown", this.handlePointerDown, this);
        paneElement.addListener("tap", this.handleTap, this);
        paneElement.addListener("pointerover", this.handlePointerOver, this);
        paneElement.addListener("pointermove", this.handlePointerMove, this);
        paneElement.addListener("losecapture", this.handleLoseCapture, this);
      },

      /**
       * Detach pointer events from the managed pane.
       *
       * @deprecated {6.0} misspelled, please use detachPointerEvents instead!
       */
      detatchPointerEvents: function detatchPointerEvents() {
        this.detachPointerEvents();
      },

      /**
       * Detach pointer events from the managed pane.
       */
      detachPointerEvents: function detachPointerEvents() {
        var paneElement = this._pane.getContentElement();

        paneElement.removeListener("pointerdown", this.handlePointerDown, this);
        paneElement.removeListener("tap", this.handleTap, this);
        paneElement.removeListener("pointerover", this.handlePointerOver, this);
        paneElement.removeListener("pointermove", this.handlePointerMove, this);
        paneElement.removeListener("losecapture", this.handleLoseCapture, this);
      },

      /**
       * Attach key events to manipulate the selection using the keyboard. The
       * event target doesn't need to be the pane itself. It can be an widget,
       * which received key events. Usually the key event target is the
       * {@link qx.ui.virtual.core.Scroller}.
       *
       * @param target {qx.core.Object} the key event target.
       *
       */
      attachKeyEvents: function attachKeyEvents(target) {
        target.addListener("keypress", this.handleKeyPress, this);
      },

      /**
       * Detach key events.
       *
       * @param target {qx.core.Object} the key event target.
       */
      detachKeyEvents: function detachKeyEvents(target) {
        target.removeListener("keypress", this.handleKeyPress, this);
      },

      /**
       * Attach list events. The selection mode <code>one</code> need to know,
       * when selectable items are added or removed. If this mode is used the
       * <code>list</code> parameter must fire <code>addItem</code> and
       * <code>removeItem</code> events.
       *
       * @param list {qx.core.Object} the event target for <code>addItem</code> and
       *    <code>removeItem</code> events
       */
      attachListEvents: function attachListEvents(list) {
        list.addListener("addItem", this.handleAddItem, this);
        list.addListener("removeItem", this.handleRemoveItem, this);
      },

      /**
       * Detach list events.
       *
       * @param list {qx.core.Object} the event target for <code>addItem</code> and
       *    <code>removeItem</code> events
       */
      detachListEvents: function detachListEvents(list) {
        list.removeListener("addItem", this.handleAddItem, this);
        list.removeListener("removeItem", this.handleRemoveItem, this);
      },

      /*
      ---------------------------------------------------------------------------
        IMPLEMENT ABSTRACT METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _capture: function _capture() {
        this._pane.capture();
      },
      // overridden
      _releaseCapture: function _releaseCapture() {
        this._pane.releaseCapture();
      },
      // overridden
      _getScroll: function _getScroll() {
        return {
          left: this._pane.getScrollX(),
          top: this._pane.getScrollY()
        };
      },
      // overridden
      _scrollBy: function _scrollBy(xoff, yoff) {
        this._pane.setScrollX(this._pane.getScrollX() + xoff);

        this._pane.setScrollY(this._pane.getScrollY() + yoff);
      },
      // overridden
      _getLocation: function _getLocation() {
        var elem = this._pane.getContentElement().getDomElement();

        return elem ? qx.bom.element.Location.get(elem) : null;
      },
      // overridden
      _getDimension: function _getDimension() {
        return this._pane.getInnerSize();
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this._pane = this._delegate = null;
    }
  });
  qx.ui.virtual.selection.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.selection.Abstract": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Row selection manager
   */
  qx.Class.define("qx.ui.virtual.selection.Row", {
    extend: qx.ui.virtual.selection.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the number of all items in the pane. This number may contain
       * unselectable items as well.
       *
       * @return {Integer} number of items
       */
      _getItemCount: function _getItemCount() {
        return this._pane.getRowConfig().getItemCount();
      },

      /*
      ---------------------------------------------------------------------------
        IMPLEMENT ABSTRACT METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _getSelectableFromPointerEvent: function _getSelectableFromPointerEvent(event) {
        var cell = this._pane.getCellAtPosition(event.getDocumentLeft(), event.getDocumentTop());

        if (!cell) {
          return null;
        }

        return this._isSelectable(cell.row) ? cell.row : null;
      },
      // overridden
      getSelectables: function getSelectables(all) {
        var selectables = [];

        for (var i = 0, l = this._getItemCount(); i < l; i++) {
          if (this._isSelectable(i)) {
            selectables.push(i);
          }
        }

        return selectables;
      },
      // overridden
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        var selectables = [];
        var min = Math.min(item1, item2);
        var max = Math.max(item1, item2);

        for (var i = min; i <= max; i++) {
          if (this._isSelectable(i)) {
            selectables.push(i);
          }
        }

        return selectables;
      },
      // overridden
      _getFirstSelectable: function _getFirstSelectable() {
        var count = this._getItemCount();

        for (var i = 0; i < count; i++) {
          if (this._isSelectable(i)) {
            return i;
          }
        }

        return null;
      },
      // overridden
      _getLastSelectable: function _getLastSelectable() {
        var count = this._getItemCount();

        for (var i = count - 1; i >= 0; i--) {
          if (this._isSelectable(i)) {
            return i;
          }
        }

        return null;
      },
      // overridden
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        if (relation == "above") {
          var startIndex = item - 1;
          var endIndex = 0;
          var increment = -1;
        } else if (relation == "under") {
          var startIndex = item + 1;
          var endIndex = this._getItemCount() - 1;
          var increment = 1;
        } else {
          return null;
        }

        for (var i = startIndex; i !== endIndex + increment; i += increment) {
          if (this._isSelectable(i)) {
            return i;
          }
        }

        return null;
      },
      // overridden
      _getPage: function _getPage(lead, up) {
        var paneSize;
        var scrollY;
        var newItem;

        var rowConfig = this._pane.getRowConfig(); // Determine the height of the pane


        paneSize = this._pane.getInnerSize(); // Determine our current y position

        scrollY = this._pane.getScrollY(); // Scroll to the new page

        if (up) {
          // Add item size so we include the immediately previous item, i.e., so
          // that pageDown followed by pageUp returns to the same location
          this._pane.setScrollY(scrollY - paneSize.height + rowConfig.getDefaultItemSize());
        } else {
          this._pane.setScrollY(scrollY + paneSize.height);
        } // Determine new y position, and from that, what row we moved to


        scrollY = this._pane.getScrollY();
        newItem = rowConfig.getItemAtPosition(scrollY);
        return newItem.index;
      },
      // overridden
      _selectableToHashCode: function _selectableToHashCode(item) {
        return item;
      },
      // overridden
      _scrollItemIntoView: function _scrollItemIntoView(item) {
        if (this._autoScrollIntoView) {
          this._pane.scrollRowIntoView(item);
        }
      },
      // overridden
      _getSelectableLocationX: function _getSelectableLocationX(item) {
        return {
          left: 0,
          right: this._pane.getColumnConfig().getTotalSize() - 1
        };
      },
      // overridden
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        var rowConfig = this._pane.getRowConfig();

        var itemTop = rowConfig.getItemPosition(item);
        var itemBottom = itemTop + rowConfig.getItemSize(item) - 1;
        return {
          top: itemTop,
          bottom: itemBottom
        };
      }
    }
  });
  qx.ui.virtual.selection.Row.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A layer is responsible to render one aspect of a virtual pane. The pane tells
   * each layer to render/update a specific window of the virtual grid.
   */
  qx.Interface.define("qx.ui.virtual.core.ILayer", {
    members: {
      /**
       * Do a complete update of the layer. All cached data should be discarded.
       * This method is called e.g. after changes to the grid geometry
       * (row/column sizes, row/column count, ...).
       *
       * Note: This method can only be called after the widgets initial appear
       * event has been fired because it may work with the widget's DOM elements.
       *
       * @param firstRow {Integer} Index of the first row to display.
       * @param firstColumn {Integer} Index of the first column to display.
       * @param rowSizes {Integer[]} Array of heights for each row to display.
       * @param columnSizes {Integer[]} Array of widths for each column to display.
       */
      fullUpdate: function fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        this.assertArgumentsCount(arguments, 6, 6);
        this.assertPositiveInteger(firstRow);
        this.assertPositiveInteger(firstColumn);
        this.assertArray(rowSizes);
        this.assertArray(columnSizes);
      },

      /**
       * Update the layer to display a different window of the virtual grid.
       * This method is called if the pane is scrolled, resized or cells
       * are prefetched. The implementation can assume that no other grid
       * data has been changed since the last "fullUpdate" of "updateLayerWindow"
       * call.
       *
       * Note: This method can only be called after the widgets initial appear
       * event has been fired because it may work with the widget's DOM elements.
       *
       * @param firstRow {Integer} Index of the first row to display.
       * @param firstColumn {Integer} Index of the first column to display.
       * @param rowSizes {Integer[]} Array of heights for each row to display.
       * @param columnSizes {Integer[]} Array of widths for each column to display.
       */
      updateLayerWindow: function updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        this.assertArgumentsCount(arguments, 6, 6);
        this.assertPositiveInteger(firstRow);
        this.assertPositiveInteger(firstColumn);
        this.assertArray(rowSizes);
        this.assertArray(columnSizes);
      },

      /**
       * Update the layer to reflect changes in the data the layer displays.
       */
      updateLayerData: function updateLayerData() {}
    }
  });
  qx.ui.virtual.core.ILayer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.ILayer": {
        "require": true
      },
      "qx.ui.core.queue.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Abstract base class for layers of a virtual pane.
   *
   * This class queues calls to {@link #fullUpdate}, {@link #updateLayerWindow}
   * and {@link #updateLayerData} and only performs the absolute necessary
   * actions. Concrete implementation of this class must at least implement
   * the {@link #_fullUpdate} method. Additionally the two methods
   * {@link #_updateLayerWindow} and {@link #_updateLayerData} may be implemented
   * to increase the performance.
   */
  qx.Class.define("qx.ui.virtual.layer.Abstract", {
    extend: qx.ui.core.Widget,
    type: "abstract",
    implement: [qx.ui.virtual.core.ILayer],

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct() {
      qx.ui.core.Widget.constructor.call(this);
      this.__jobs__P_546_0 = {};
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      anonymous: {
        refine: true,
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __jobs__P_546_0: null,
      __arguments__P_546_1: null,
      __firstRow__P_546_2: null,
      __firstColumn__P_546_3: null,
      __rowSizes__P_546_4: null,
      __columnSizes__P_546_5: null,

      /**
       * Get the first rendered row
       *
       * @return {Integer} The first rendered row
       */
      getFirstRow: function getFirstRow() {
        return this.__firstRow__P_546_2;
      },

      /**
       * Get the first rendered column
       *
       * @return {Integer} The first rendered column
       */
      getFirstColumn: function getFirstColumn() {
        return this.__firstColumn__P_546_3;
      },

      /**
       * Get the sizes of the rendered rows
       *
       * @return {Integer[]} List of row heights
       */
      getRowSizes: function getRowSizes() {
        return this.__rowSizes__P_546_4 || [];
      },

      /**
       * Get the sizes of the rendered column
       *
       * @return {Integer[]} List of column widths
       */
      getColumnSizes: function getColumnSizes() {
        return this.__columnSizes__P_546_5 || [];
      },
      // overridden
      syncWidget: function syncWidget(jobs) {
        // return if the layer is not yet rendered
        // it will rendered in the appear event
        if (!this.getContentElement().getDomElement()) {
          return;
        }

        if (this.__jobs__P_546_0.fullUpdate || this.__jobs__P_546_0.updateLayerWindow && this.__jobs__P_546_0.updateLayerData) {
          this._fullUpdate.apply(this, this.__arguments__P_546_1);
        } else if (this.__jobs__P_546_0.updateLayerWindow) {
          this._updateLayerWindow.apply(this, this.__arguments__P_546_1);
        } else if (this.__jobs__P_546_0.updateLayerData && this.__rowSizes__P_546_4) {
          this._updateLayerData();
        }

        if (this.__jobs__P_546_0.fullUpdate || this.__jobs__P_546_0.updateLayerWindow) {
          var args = this.__arguments__P_546_1;
          this.__firstRow__P_546_2 = args[0];
          this.__firstColumn__P_546_3 = args[1];
          this.__rowSizes__P_546_4 = args[2];
          this.__columnSizes__P_546_5 = args[3];
        }

        this.__jobs__P_546_0 = {};
      },

      /**
       * Update the layer to reflect changes in the data the layer displays.
       *
       * Note: It is guaranteed that this method is only called after the layer
       * has been rendered.
       */
      _updateLayerData: function _updateLayerData() {
        this._fullUpdate(this.__firstRow__P_546_2, this.__firstColumn__P_546_3, this.__rowSizes__P_546_4, this.__columnSizes__P_546_5);
      },

      /**
       * Do a complete update of the layer. All cached data should be discarded.
       * This method is called e.g. after changes to the grid geometry
       * (row/column sizes, row/column count, ...).
       *
       * Note: It is guaranteed that this method is only called after the layer
       * has been rendered.
       *
       * @param firstRow {Integer} Index of the first row to display
       * @param firstColumn {Integer} Index of the first column to display
       * @param rowSizes {Integer[]} Array of heights for each row to display
       * @param columnSizes {Integer[]} Array of widths for each column to display
       */
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        throw new Error("Abstract method '_fullUpdate' called!");
      },

      /**
       * Update the layer to display a different window of the virtual grid.
       * This method is called if the pane is scrolled, resized or cells
       * are prefetched. The implementation can assume that no other grid
       * data has been changed since the last "fullUpdate" of "updateLayerWindow"
       * call.
       *
       * Note: It is guaranteed that this method is only called after the layer
       * has been rendered.
       *
       * @param firstRow {Integer} Index of the first row to display
       * @param firstColumn {Integer} Index of the first column to display
       * @param rowSizes {Integer[]} Array of heights for each row to display
       * @param columnSizes {Integer[]} Array of widths for each column to display
       */
      _updateLayerWindow: function _updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        this._fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
      },
      // interface implementation
      updateLayerData: function updateLayerData() {
        this.__jobs__P_546_0.updateLayerData = true;
        qx.ui.core.queue.Widget.add(this);
      },
      // interface implementation
      fullUpdate: function fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        this.__arguments__P_546_1 = arguments;
        this.__jobs__P_546_0.fullUpdate = true;
        qx.ui.core.queue.Widget.add(this);
      },
      // interface implementation
      updateLayerWindow: function updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        this.__arguments__P_546_1 = arguments;
        this.__jobs__P_546_0.updateLayerWindow = true;
        qx.ui.core.queue.Widget.add(this);
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__jobs__P_546_0 = this.__arguments__P_546_1 = this.__rowSizes__P_546_4 = this.__columnSizes__P_546_5 = null;
    }
  });
  qx.ui.virtual.layer.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.theme.manager.Color": {},
      "qx.theme.manager.Decoration": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Abstract base class for the {@link Row} and {@link Column} layers.
   */
  qx.Class.define("qx.ui.virtual.layer.AbstractBackground", {
    extend: qx.ui.virtual.layer.Abstract,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */

    /**
     * @param colorEven {Color?null} color for even indexes
     * @param colorOdd {Color?null} color for odd indexes
     */
    construct: function construct(colorEven, colorOdd) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);

      if (colorEven) {
        this.setColorEven(colorEven);
      }

      if (colorOdd) {
        this.setColorOdd(colorOdd);
      }

      this.__customColors__P_547_0 = {};
      this.__decorators__P_547_1 = {};
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** color for event indexes */
      colorEven: {
        nullable: true,
        check: "Color",
        apply: "_applyColorEven",
        themeable: true
      },

      /** color for odd indexes */
      colorOdd: {
        nullable: true,
        check: "Color",
        apply: "_applyColorOdd",
        themeable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __colorEven__P_547_2: null,
      __colorOdd__P_547_3: null,
      __customColors__P_547_0: null,
      __decorators__P_547_1: null,

      /*
      ---------------------------------------------------------------------------
        COLOR HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Sets the color for the given index
       *
       * @param index {Integer} Index to set the color for
       * @param color {Color|null} the color to set. A value of <code>null</code>
       *    will reset the color.
       */
      setColor: function setColor(index, color) {
        if (color) {
          this.__customColors__P_547_0[index] = qx.theme.manager.Color.getInstance().resolve(color);
        } else {
          delete this.__customColors__P_547_0[index];
        }
      },

      /**
       * Clear all colors set using {@link #setColor}.
       */
      clearCustomColors: function clearCustomColors() {
        this.__customColors__P_547_0 = {};
        this.updateLayerData();
      },

      /**
       * Get the color at the given index
       *
       * @param index {Integer} The index to get the color for.
       * @return {Color} The color at the given index
       */
      getColor: function getColor(index) {
        var customColor = this.__customColors__P_547_0[index];

        if (customColor) {
          return customColor;
        } else {
          return index % 2 == 0 ? this.__colorEven__P_547_2 : this.__colorOdd__P_547_3;
        }
      },
      // property apply
      _applyColorEven: function _applyColorEven(value, old) {
        if (value) {
          this.__colorEven__P_547_2 = qx.theme.manager.Color.getInstance().resolve(value);
        } else {
          this.__colorEven__P_547_2 = null;
        }

        this.updateLayerData();
      },
      // property apply
      _applyColorOdd: function _applyColorOdd(value, old) {
        if (value) {
          this.__colorOdd__P_547_3 = qx.theme.manager.Color.getInstance().resolve(value);
        } else {
          this.__colorOdd__P_547_3 = null;
        }

        this.updateLayerData();
      },

      /**
       * Sets the decorator for the given index
       *
       * @param index {Integer} Index to set the color for
       * @param decorator {qx.ui.decoration.IDecorator|null} the decorator to set. A value of
       *    <code>null</code> will reset the decorator.
       */
      setBackground: function setBackground(index, decorator) {
        if (decorator) {
          this.__decorators__P_547_1[index] = qx.theme.manager.Decoration.getInstance().resolve(decorator);
        } else {
          delete this.__decorators__P_547_1[index];
        }

        this.updateLayerData();
      },

      /**
       * Get the decorator at the given index
       *
       * @param index {Integer} The index to get the decorator for.
       * @return {qx.ui.decoration.IDecorator} The decorator at the given index
       */
      getBackground: function getBackground(index) {
        return this.__decorators__P_547_1[index];
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this.__customColors__P_547_0 = this.__decorators__P_547_1 = null;
    }
  });
  qx.ui.virtual.layer.AbstractBackground.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.AbstractBackground": {
        "require": true
      },
      "qx.lang.Array": {},
      "qx.bom.element.Style": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The Row layer renders row background colors.
   */
  qx.Class.define("qx.ui.virtual.layer.Row", {
    extend: qx.ui.virtual.layer.AbstractBackground,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "row-layer"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];
        var width = qx.lang.Array.sum(columnSizes);
        var top = 0;
        var row = firstRow;
        var childIndex = 0;

        for (var y = 0; y < rowSizes.length; y++) {
          var color = this.getColor(row);
          var backgroundColor = color ? "background-color:" + color + ";" : "";
          var decorator = this.getBackground(row);
          var styles = decorator ? qx.bom.element.Style.compile(decorator.getStyles()) : "";
          html.push("<div style='", "position: absolute;", "left: 0;", "top:", top, "px;", "height:", rowSizes[y], "px;", "width:", width, "px;", backgroundColor, styles, "'>", "</div>");
          childIndex++;
          top += rowSizes[y];
          row += 1;
        }

        var el = this.getContentElement().getDomElement(); // hide element before changing the child nodes to avoid
        // premature reflow calculations

        el.style.display = "none";
        el.innerHTML = html.join("");
        el.style.display = "block";
        this._width = width;
      },
      // overridden
      _updateLayerWindow: function _updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        if (firstRow !== this.getFirstRow() || rowSizes.length !== this.getRowSizes().length || this._width < qx.lang.Array.sum(columnSizes)) {
          this._fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
        }
      },
      // overridden
      setColor: function setColor(index, color) {
        qx.ui.virtual.layer.Row.prototype.setColor.base.call(this, index, color);

        if (this.__isRowRendered__P_551_0(index)) {
          this.updateLayerData();
        }
      },
      // overridden
      setBackground: function setBackground(index, decorator) {
        qx.ui.virtual.layer.Row.prototype.setBackground.base.call(this, index, decorator);

        if (this.__isRowRendered__P_551_0(index)) {
          this.updateLayerData();
        }
      },

      /**
       * Whether the row with the given index is currently rendered (i.e. in the
       * layer's view port).
       *
       * @param index {Integer} The row's index
       * @return {Boolean} Whether the row is rendered
       */
      __isRowRendered__P_551_0: function __isRowRendered__P_551_0(index) {
        var firstRow = this.getFirstRow();
        var lastRow = firstRow + this.getRowSizes().length - 1;
        return index >= firstRow && index <= lastRow;
      }
    }
  });
  qx.ui.virtual.layer.Row.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A widget cell provider provides the {@link qx.ui.virtual.layer.WidgetCell}
   * with configured widgets to render the cells and pools/releases unused
   * cell widgets.
   */
  qx.Interface.define("qx.ui.virtual.core.IWidgetCellProvider", {
    members: {
      /**
       * This method returns the configured cell for the given cell. The return
       * value may be <code>null</code> to indicate that the cell should be empty.
       *
       * @param row {Integer} The cell's row index.
       * @param column {Integer} The cell's column index.
       * @return {qx.ui.core.LayoutItem} The configured widget for the given cell.
       */
      getCellWidget: function getCellWidget(row, column) {},

      /**
       * Release the given cell widget. Either pool or destroy the widget.
       *
       * @param widget {qx.ui.core.LayoutItem} The cell widget to pool.
       */
      poolCellWidget: function poolCellWidget(widget) {}
    }
  });
  qx.ui.virtual.core.IWidgetCellProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * This interface needs to implemented from all {@link qx.ui.list.List} providers.
   *
   * @internal
   */
  qx.Interface.define("qx.ui.list.provider.IListProvider", {
    members: {
      /**
       * Creates a layer for item and group rendering.
       *
       * @return {qx.ui.virtual.layer.Abstract} new layer.
       */
      createLayer: function createLayer() {},

      /**
       * Creates a renderer for item rendering.
       *
       * @return {var} new item renderer.
       */
      createItemRenderer: function createItemRenderer() {},

      /**
       * Creates a renderer for group rendering.
       *
       * @return {var} new group renderer.
       */
      createGroupRenderer: function createGroupRenderer() {},

      /**
       * Styles a selected item.
       *
       * @param row {Integer} row to style.
       */
      styleSelectabled: function styleSelectabled(row) {},

      /**
       * Styles a not selected item.
       *
       * @param row {Integer} row to style.
       */
      styleUnselectabled: function styleUnselectabled(row) {},

      /**
       * Returns if the passed row can be selected or not.
       *
       * @param row {Integer} row to select.
       * @return {Boolean} <code>true</code> when the row can be selected,
       *    <code>false</code> otherwise.
       */
      isSelectable: function isSelectable(row) {},

      /**
       * The path to the property which holds the information that should be
       * shown as a label. This is only needed if objects are stored in the model.
       *
       * @param path {String} path to the property.
       */
      setLabelPath: function setLabelPath(path) {},

      /**
       * The path to the property which holds the information that should be
       * shown as an icon. This is only needed if objects are stored in the model
       * and if the icon should be shown.
       *
       * @param path {String} path to the property.
       */
      setIconPath: function setIconPath(path) {},

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       *
       * @param options {Map} options for the label binding.
       */
      setLabelOptions: function setLabelOptions(options) {},

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       *
       * @param options {Map} options for the icon binding.
       */
      setIconOptions: function setIconOptions(options) {},

      /**
       * Delegation object, which can have one or more functions defined by the
       * {@link qx.ui.list.core.IListDelegate} interface.
       *
       * @param delegate {Object} delegation object.
       */
      setDelegate: function setDelegate(delegate) {},

      /**
       * Remove all bindings from all bounded items.
       */
      removeBindings: function removeBindings() {}
    }
  });
  qx.ui.list.provider.IListProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The mixin controls the binding between model and item.
   *
   * @internal
   */
  qx.Mixin.define("qx.ui.list.core.MWidgetController", {
    construct: function construct() {
      this.__boundItems__P_441_0 = [];
    },
    properties: {
      /**
       * The path to the property which holds the information that should be
       * shown as a label. This is only needed if objects are stored in the model.
       */
      labelPath: {
        check: "String",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * shown as an icon. This is only needed if objects are stored in the model
       * and if the icon should be shown.
       */
      iconPath: {
        check: "String",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * displayed as a group label. This is only needed if objects are stored in the
       * model.
       */
      groupLabelPath: {
        check: "String",
        nullable: true
      },

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      labelOptions: {
        nullable: true
      },

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      iconOptions: {
        nullable: true
      },

      /**
       * A map containing the options for the group label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      groupLabelOptions: {
        nullable: true
      },

      /**
       * Delegation object, which can have one or more functions defined by the
       * {@link qx.ui.list.core.IListDelegate} interface.
       */
      delegate: {
        event: "changeDelegate",
        init: null,
        nullable: true
      }
    },
    members: {
      /** @type {Array} which contains the bounded items */
      __boundItems__P_441_0: null,

      /**
       * Helper-Method for binding the default properties from
       * the model to the target widget. The used default properties
       * depends on the passed item. When the passed item is
       * a list item the "label" and "icon" property is used.
       * When the passed item is a group item the "value" property is
       * used.
       *
       * This method should only be called in the
       * {@link IListDelegate#bindItem} function
       * implemented by the {@link #delegate} property.
       *
       * @param item {qx.ui.core.Widget} The internally created and used
       *   list or group item.
       * @param index {Integer} The index of the item.
       */
      bindDefaultProperties: function bindDefaultProperties(item, index) {
        if (item.getUserData("cell.type") != "group") {
          // bind model first
          this.bindProperty("", "model", null, item, index);
          this.bindProperty(this.getLabelPath(), "label", this.getLabelOptions(), item, index);

          if (this.getIconPath() != null) {
            this.bindProperty(this.getIconPath(), "icon", this.getIconOptions(), item, index);
          }
        } else {
          this.bindProperty(this.getGroupLabelPath(), "value", this.getGroupLabelOptions(), item, index);
        }
      },

      /**
       * Helper-Method for binding a given property from the model to the target
       * widget.
       * This method should only be called in the
       * {@link IListDelegate#bindItem} function implemented by the
       * {@link #delegate} property.
       *
       * @param sourcePath {String | null} The path to the property in the model.
       *   If you use an empty string, the whole model item will be bound.
       * @param targetProperty {String} The name of the property in the target widget.
       * @param options {Map | null} The options to use for the binding.
       * @param targetWidget {qx.ui.core.Widget} The target widget.
       * @param index {Integer} The index of the current binding.
       */
      bindProperty: function bindProperty(sourcePath, targetProperty, options, targetWidget, index) {
        var type = targetWidget.getUserData("cell.type");

        var bindPath = this.__getBindPath__P_441_1(index, sourcePath, type);

        if (options) {
          options.ignoreConverter = "model";
        }

        var id = this._list.bind(bindPath, targetWidget, targetProperty, options);

        this.__addBinding__P_441_2(targetWidget, id);
      },

      /**
       * Helper-Method for binding a given property from the target widget to
       * the model.
       * This method should only be called in the
       * {@link IListDelegate#bindItem} function implemented by the
       * {@link #delegate} property.
       *
       * @param targetPath {String | null} The path to the property in the model.
       * @param sourceProperty {String} The name of the property in the target.
       * @param options {Map | null} The options to use for the binding.
       * @param sourceWidget {qx.ui.core.Widget} The source widget.
       * @param index {Integer} The index of the current binding.
       */
      bindPropertyReverse: function bindPropertyReverse(targetPath, sourceProperty, options, sourceWidget, index) {
        var type = sourceWidget.getUserData("cell.type");

        var bindPath = this.__getBindPath__P_441_1(index, targetPath, type);

        var id = sourceWidget.bind(sourceProperty, this._list, bindPath, options);

        this.__addBinding__P_441_2(sourceWidget, id);
      },

      /**
       * Remove all bindings from all bounded items.
       */
      removeBindings: function removeBindings() {
        while (this.__boundItems__P_441_0.length > 0) {
          var item = this.__boundItems__P_441_0.pop();

          this._removeBindingsFrom(item);
        }
      },

      /**
       * Configure the passed item if a delegate is set and the needed
       * function {@link IListDelegate#configureItem} is available.
       *
       * @param item {qx.ui.core.Widget} item to configure.
       */
      _configureItem: function _configureItem(item) {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.configureItem != null) {
          delegate.configureItem(item);
        }
      },

      /**
       * Configure the passed item if a delegate is set and the needed
       * function {@link IListDelegate#configureGroupItem} is available.
       *
       * @param item {qx.ui.core.Widget} item to configure.
       */
      _configureGroupItem: function _configureGroupItem(item) {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.configureGroupItem != null) {
          delegate.configureGroupItem(item);
        }
      },

      /**
       * Sets up the binding for the given item and index.
       *
       * @param item {qx.ui.core.Widget} The internally created and used item.
       * @param index {Integer} The index of the item.
       */
      _bindItem: function _bindItem(item, index) {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.bindItem != null) {
          delegate.bindItem(this, item, index);
        } else {
          this.bindDefaultProperties(item, index);
        }
      },

      /**
       * Sets up the binding for the given group item and index.
       *
       * @param item {qx.ui.core.Widget} The internally created and used item.
       * @param index {Integer} The index of the item.
       */
      _bindGroupItem: function _bindGroupItem(item, index) {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.bindGroupItem != null) {
          delegate.bindGroupItem(this, item, index);
        } else {
          this.bindDefaultProperties(item, index);
        }
      },

      /**
       * Removes the binding of the given item.
       *
       * @param item {qx.ui.core.Widget} The item which the binding should
       *   be removed.
       */
      _removeBindingsFrom: function _removeBindingsFrom(item) {
        var bindings = this.__getBindings__P_441_3(item);

        while (bindings.length > 0) {
          var id = bindings.pop();

          try {
            this._list.removeBinding(id);
          } catch (e) {
            item.removeBinding(id);
          }
        }

        if (this.__boundItems__P_441_0.includes(item)) {
          qx.lang.Array.remove(this.__boundItems__P_441_0, item);
        }
      },

      /**
       * Helper method to create the path for binding.
       *
       * @param index {Integer} The index of the item.
       * @param path {String|null} The path to the property.
       * @param type {String} The type <code>["item", "group"]</code>.
       * @return {String} The binding path
       */
      __getBindPath__P_441_1: function __getBindPath__P_441_1(index, path, type) {
        var bindPath = "model[" + index + "]";

        if (type == "group") {
          bindPath = "groups[" + index + "]";
        }

        if (path != null && path != "") {
          bindPath += "." + path;
        }

        return bindPath;
      },

      /**
       * Helper method to save the binding for the widget.
       *
       * @param widget {qx.ui.core.Widget} widget to save binding.
       * @param id {var} the id from the binding.
       */
      __addBinding__P_441_2: function __addBinding__P_441_2(widget, id) {
        var bindings = this.__getBindings__P_441_3(widget);

        if (!bindings.includes(id)) {
          bindings.push(id);
        }

        if (!this.__boundItems__P_441_0.includes(widget)) {
          this.__boundItems__P_441_0.push(widget);
        }
      },

      /**
       * Helper method which returns all bound id from the widget.
       *
       * @param widget {qx.ui.core.Widget} widget to get all binding.
       * @return {Array} all bound id's.
       */
      __getBindings__P_441_3: function __getBindings__P_441_3(widget) {
        var bindings = widget.getUserData("BindingIds");

        if (bindings == null) {
          bindings = [];
          widget.setUserData("BindingIds", bindings);
        }

        return bindings;
      }
    },
    destruct: function destruct() {
      this.__boundItems__P_441_0 = null;
    }
  });
  qx.ui.list.core.MWidgetController.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.IWidgetCellProvider": {
        "require": true
      },
      "qx.ui.list.provider.IListProvider": {
        "require": true
      },
      "qx.ui.list.core.MWidgetController": {
        "require": true
      },
      "qx.ui.virtual.layer.WidgetCell": {},
      "qx.util.Delegate": {},
      "qx.ui.form.ListItem": {},
      "qx.ui.virtual.cell.WidgetCell": {},
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The provider implements the {@link qx.ui.virtual.core.IWidgetCellProvider} API,
   * which can be used as delegate for the widget cell rendering and it
   * provides a API to bind the model with the rendered item.
   *
   * @internal
   */
  qx.Class.define("qx.ui.list.provider.WidgetProvider", {
    extend: qx.core.Object,
    implement: [qx.ui.virtual.core.IWidgetCellProvider, qx.ui.list.provider.IListProvider],
    include: [qx.ui.list.core.MWidgetController],

    /**
     * Creates the <code>WidgetProvider</code>
     *
     * @param list {qx.ui.list.List} list to provide.
     */
    construct: function construct(list) {
      qx.core.Object.constructor.call(this);
      this._list = list;
      this._itemRenderer = this.createItemRenderer();
      this._groupRenderer = this.createGroupRenderer();

      this._itemRenderer.addListener("created", this._onItemCreated, this);

      this._groupRenderer.addListener("created", this._onGroupItemCreated, this);

      this._list.addListener("changeDelegate", this._onChangeDelegate, this);
    },
    members: {
      /** @type {qx.ui.virtual.cell.WidgetCell} the used item renderer */
      _itemRenderer: null,

      /** @type {qx.ui.virtual.cell.WidgetCell} the used group renderer */
      _groupRenderer: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */
      // interface implementation
      getCellWidget: function getCellWidget(row, column) {
        var widget = null;

        if (!this._list._isGroup(row)) {
          widget = this._itemRenderer.getCellWidget();
          widget.setUserData("cell.type", "item");

          this._bindItem(widget, this._list._lookup(row));

          if (this._list._manager.isItemSelected(row)) {
            this._styleSelectabled(widget);
          } else {
            this._styleUnselectabled(widget);
          }
        } else {
          widget = this._groupRenderer.getCellWidget();
          widget.setUserData("cell.type", "group");

          this._bindGroupItem(widget, this._list._lookupGroup(row));
        }

        return widget;
      },
      // interface implementation
      poolCellWidget: function poolCellWidget(widget) {
        this._removeBindingsFrom(widget);

        if (widget.getUserData("cell.type") == "item") {
          this._itemRenderer.pool(widget);
        } else if (widget.getUserData("cell.type") == "group") {
          this._groupRenderer.pool(widget);
        }

        this._onPool(widget);
      },
      // interface implementation
      createLayer: function createLayer() {
        return new qx.ui.virtual.layer.WidgetCell(this);
      },
      // interface implementation
      createItemRenderer: function createItemRenderer() {
        var createWidget = qx.util.Delegate.getMethod(this.getDelegate(), "createItem");

        if (createWidget == null) {
          createWidget = function createWidget() {
            return new qx.ui.form.ListItem();
          };
        }

        var renderer = new qx.ui.virtual.cell.WidgetCell();
        renderer.setDelegate({
          createWidget: createWidget
        });
        return renderer;
      },
      // interface implementation
      createGroupRenderer: function createGroupRenderer() {
        var createWidget = qx.util.Delegate.getMethod(this.getDelegate(), "createGroupItem");

        if (createWidget == null) {
          createWidget = function createWidget() {
            var group = new qx.ui.basic.Label();
            group.setAppearance("group-item");
            return group;
          };
        }

        var renderer = new qx.ui.virtual.cell.WidgetCell();
        renderer.setDelegate({
          createWidget: createWidget
        });
        return renderer;
      },
      // interface implementation
      styleSelectabled: function styleSelectabled(row) {
        var widget = this.__getWidgetFrom__P_442_0(row);

        this._styleSelectabled(widget);
      },
      // interface implementation
      styleUnselectabled: function styleUnselectabled(row) {
        var widget = this.__getWidgetFrom__P_442_0(row);

        this._styleUnselectabled(widget);
      },
      // interface implementation
      isSelectable: function isSelectable(row) {
        if (this._list._isGroup(row)) {
          return false;
        }

        var widget = this._list._layer.getRenderedCellWidget(row, 0);

        if (widget != null) {
          return widget.isEnabled();
        } else {
          return true;
        }
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */

      /**
       * Styles a selected item.
       *
       * @param widget {qx.ui.core.Widget} widget to style.
       */
      _styleSelectabled: function _styleSelectabled(widget) {
        this.__updateStates__P_442_1(widget, {
          selected: 1
        });
      },

      /**
       * Styles a not selected item.
       *
       * @param widget {qx.ui.core.Widget} widget to style.
       */
      _styleUnselectabled: function _styleUnselectabled(widget) {
        this.__updateStates__P_442_1(widget, {});
      },

      /**
       * Calls the delegate <code>onPool</code> method when it is used in the
       * {@link #delegate} property.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      _onPool: function _onPool(item) {
        var onPool = qx.util.Delegate.getMethod(this.getDelegate(), "onPool");

        if (onPool != null) {
          onPool(item);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the created item widget event.
       *
       * @param event {qx.event.type.Data} fired event.
       */
      _onItemCreated: function _onItemCreated(event) {
        var widget = event.getData();

        this._configureItem(widget);
      },

      /**
       * Event handler for the created item widget event.
       *
       * @param event {qx.event.type.Data} fired event.
       */
      _onGroupItemCreated: function _onGroupItemCreated(event) {
        var widget = event.getData();

        this._configureGroupItem(widget);
      },

      /**
       * Event handler for the change delegate event.
       *
       * @param event {qx.event.type.Data} fired event.
       */
      _onChangeDelegate: function _onChangeDelegate(event) {
        this._itemRenderer.dispose();

        this._itemRenderer = this.createItemRenderer();

        this._itemRenderer.addListener("created", this._onItemCreated, this);

        this._groupRenderer.dispose();

        this._groupRenderer = this.createGroupRenderer();

        this._groupRenderer.addListener("created", this._onGroupItemCreated, this);

        this.removeBindings();

        this._list.getPane().fullUpdate();
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Helper method to get the widget from the passed row.
       *
       * @param row {Integer} row to search.
       * @return {qx.ui.core.Widget|null} The found widget or <code>null</code> when no widget found.
       */
      __getWidgetFrom__P_442_0: function __getWidgetFrom__P_442_0(row) {
        return this._list._layer.getRenderedCellWidget(row, 0);
      },

      /**
       * Helper method to update the states from a widget.
       *
       * @param widget {qx.ui.core.Widget} widget to set states.
       * @param states {Map} the state to set.
       */
      __updateStates__P_442_1: function __updateStates__P_442_1(widget, states) {
        if (widget == null) {
          return;
        }

        this._itemRenderer.updateStates(widget, states);
      }
    },
    destruct: function destruct() {
      this._itemRenderer.dispose();

      this._groupRenderer.dispose();

      this._itemRenderer = this._groupRenderer = null;
    }
  });
  qx.ui.list.provider.WidgetProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The axis maps virtual screen coordinates to item indexes. By default all
   * items have the same size but it is also possible to give specific items
   * a different size.
   */
  qx.Class.define("qx.ui.virtual.core.Axis", {
    extend: qx.core.Object,

    /**
     * @param defaultItemSize {Integer} The default size of the items.
     * @param itemCount {Integer} The number of item on the axis.
     */
    construct: function construct(defaultItemSize, itemCount) {
      qx.core.Object.constructor.call(this);
      this.itemCount = itemCount;
      this.defaultItemSize = defaultItemSize; // sparse array

      this.customSizes = {};
    },
    events: {
      /** Every change to the axis configuration triggers this event. */
      "change": "qx.event.type.Event"
    },
    members: {
      __ranges__P_543_0: null,

      /**
       * Get the default size of the items.
       *
       * @return {Integer} The default item size.
       */
      getDefaultItemSize: function getDefaultItemSize() {
        return this.defaultItemSize;
      },

      /**
       * Set the default size the items.
       *
       * @param defaultItemSize {Integer} The default size of the items.
       */
      setDefaultItemSize: function setDefaultItemSize(defaultItemSize) {
        if (this.defaultItemSize !== defaultItemSize) {
          this.defaultItemSize = defaultItemSize;
          this.__ranges__P_543_0 = null;
          this.fireNonBubblingEvent("change");
        }
      },

      /**
       * Get the number of items in the axis.
       *
       * @return {Integer} The number of items.
       */
      getItemCount: function getItemCount() {
        return this.itemCount;
      },

      /**
       * Set the number of items in the axis.
       *
       * @param itemCount {Integer} The new item count.
       */
      setItemCount: function setItemCount(itemCount) {
        if (this.itemCount !== itemCount) {
          this.itemCount = itemCount;
          this.__ranges__P_543_0 = null;
          this.fireNonBubblingEvent("change");
        }
      },

      /**
       * Sets the size of a specific item. This allow item, which have a size
       * different from the default size.
       *
       * @param index {Integer} Index of the item to change.
       * @param size {Integer} New size of the item.
       */
      setItemSize: function setItemSize(index, size) {
        {
          this.assertArgumentsCount(arguments, 2, 2);
          this.assert(size >= 0 || size === null, "'size' must be 'null' or an integer larger than 0.");
        }

        if (this.customSizes[index] == size) {
          return;
        }

        if (size === null) {
          delete this.customSizes[index];
        } else {
          this.customSizes[index] = size;
        }

        this.__ranges__P_543_0 = null;
        this.fireNonBubblingEvent("change");
      },

      /**
       * Get the size of the item at the given index.
       *
       * @param index {Integer} Index of the item to get the size for.
       * @return {Integer} Size of the item.
       */
      getItemSize: function getItemSize(index) {
        // custom size of 0 is not allowed
        return this.customSizes[index] || this.defaultItemSize;
      },

      /**
       * Reset all custom sizes set with {@link #setItemSize}.
       */
      resetItemSizes: function resetItemSizes() {
        this.customSizes = {};
        this.__ranges__P_543_0 = null;
        this.fireNonBubblingEvent("change");
      },

      /**
       * Split the position range into disjunct intervals. Each interval starts
       * with a custom sized cell. Each position is contained in exactly one range.
       * The ranges are sorted according to their start position.
       *
       * Complexity: O(n log n) (n = number of custom sized cells)
       *
       * @return {Map[]} The sorted list of ranges.
       */
      __getRanges__P_543_1: function __getRanges__P_543_1() {
        if (this.__ranges__P_543_0) {
          return this.__ranges__P_543_0;
        }

        var defaultSize = this.defaultItemSize;
        var itemCount = this.itemCount;
        var indexes = [];

        for (var key in this.customSizes) {
          var index = parseInt(key, 10);

          if (index < itemCount) {
            indexes.push(index);
          }
        }

        if (indexes.length == 0) {
          var ranges = [{
            startIndex: 0,
            endIndex: itemCount - 1,
            firstItemSize: defaultSize,
            rangeStart: 0,
            rangeEnd: itemCount * defaultSize - 1
          }];
          this.__ranges__P_543_0 = ranges;
          return ranges;
        }

        indexes.sort(function (a, b) {
          return a > b ? 1 : -1;
        });
        var ranges = [];
        var correctionSum = 0;

        for (var i = 0; i < indexes.length; i++) {
          var index = indexes[i];

          if (index >= itemCount) {
            break;
          }

          var cellSize = this.customSizes[index];
          var rangeStart = index * defaultSize + correctionSum;
          correctionSum += cellSize - defaultSize;
          ranges[i] = {
            startIndex: index,
            firstItemSize: cellSize,
            rangeStart: rangeStart
          };

          if (i > 0) {
            ranges[i - 1].rangeEnd = rangeStart - 1;
            ranges[i - 1].endIndex = index - 1;
          }
        } // fix first range


        if (ranges[0].rangeStart > 0) {
          ranges.unshift({
            startIndex: 0,
            endIndex: ranges[0].startIndex - 1,
            firstItemSize: defaultSize,
            rangeStart: 0,
            rangeEnd: ranges[0].rangeStart - 1
          });
        } // fix last range


        var lastRange = ranges[ranges.length - 1];
        var remainingItemsSize = (itemCount - lastRange.startIndex - 1) * defaultSize;
        lastRange.rangeEnd = lastRange.rangeStart + lastRange.firstItemSize + remainingItemsSize - 1;
        lastRange.endIndex = itemCount - 1;
        this.__ranges__P_543_0 = ranges;
        return ranges;
      },

      /**
       * Returns the range, which contains the position
       *
       * Complexity: O(log n) (n = number of custom sized cells)
       *
       * @param position {Integer} The position.
       * @return {Map} The range, which contains the given position.
       */
      __findRangeByPosition__P_543_2: function __findRangeByPosition__P_543_2(position) {
        var ranges = this.__ranges__P_543_0 || this.__getRanges__P_543_1();

        var start = 0;
        var end = ranges.length - 1; // binary search in the sorted ranges list

        while (true) {
          var pivot = start + (end - start >> 1);
          var range = ranges[pivot];

          if (range.rangeEnd < position) {
            start = pivot + 1;
          } else if (range.rangeStart > position) {
            end = pivot - 1;
          } else {
            return range;
          }
        }
      },

      /**
       * Get the item and the offset into the item at the given position.
       *
       * @param position {Integer|null} The position to get the item for.
       * @return {Map} A map with the keys <code>index</code> and
       *    <code>offset</code>. The index is the index of the item containing the
       *    position and offsets specifies offset into this item. If the position
       *    is outside of the range, <code>null</code> is returned.
       */
      getItemAtPosition: function getItemAtPosition(position) {
        if (position < 0 || position >= this.getTotalSize()) {
          return null;
        }

        var range = this.__findRangeByPosition__P_543_2(position);

        var startPos = range.rangeStart;
        var index = range.startIndex;
        var firstItemSize = range.firstItemSize;

        if (startPos + firstItemSize > position) {
          return {
            index: index,
            offset: position - startPos
          };
        } else {
          var defaultSize = this.defaultItemSize;
          return {
            index: index + 1 + Math.floor((position - startPos - firstItemSize) / defaultSize),
            offset: (position - startPos - firstItemSize) % defaultSize
          };
        }
      },

      /**
       * Returns the range, which contains the position.
       *
       * Complexity: O(log n) (n = number of custom sized cells)
       *
       * @param index {Integer} The index of the item to get the range for.
       * @return {Map} The range for the index.
       */
      __findRangeByIndex__P_543_3: function __findRangeByIndex__P_543_3(index) {
        var ranges = this.__ranges__P_543_0 || this.__getRanges__P_543_1();

        var start = 0;
        var end = ranges.length - 1; // binary search in the sorted ranges list

        while (true) {
          var pivot = start + (end - start >> 1);
          var range = ranges[pivot];

          if (range.endIndex < index) {
            start = pivot + 1;
          } else if (range.startIndex > index) {
            end = pivot - 1;
          } else {
            return range;
          }
        }
      },

      /**
       * Get the start position of the item with the given index.
       *
       * @param index {Integer} The item's index.
       * @return {Integer|null} The start position of the item. If the index is outside
       *    of the axis range <code>null</code> is returned.
       */
      getItemPosition: function getItemPosition(index) {
        if (index < 0 || index >= this.itemCount) {
          return null;
        }

        var range = this.__findRangeByIndex__P_543_3(index);

        if (range.startIndex == index) {
          return range.rangeStart;
        } else {
          return range.rangeStart + range.firstItemSize + (index - range.startIndex - 1) * this.defaultItemSize;
        }
      },

      /**
       * Returns the sum of all cell sizes.
       *
       * @return {Integer} The sum of all item sizes.
       */
      getTotalSize: function getTotalSize() {
        var ranges = this.__ranges__P_543_0 || this.__getRanges__P_543_1();

        return ranges[ranges.length - 1].rangeEnd + 1;
      },

      /**
       * Get an array of item sizes starting with the item at "startIndex". The
       * sum of all sizes in the returned array is at least "minSizeSum".
       *
       * @param startIndex {Integer} The index of the first item.
       * @param minSizeSum {Integer} The minimum sum of the item sizes.
       * @return {Integer[]} List of item sizes starting with the size of the item
       *    at index <code>startIndex</code>. The sum of the item sizes is at least
       *    <code>minSizeSum</code>.
       */
      getItemSizes: function getItemSizes(startIndex, minSizeSum) {
        var customSizes = this.customSizes;
        var defaultSize = this.defaultItemSize;
        var sum = 0;
        var sizes = [];
        var i = 0;

        while (sum < minSizeSum) {
          var itemSize = customSizes[startIndex] != null ? customSizes[startIndex] : defaultSize;
          startIndex++;
          sum += itemSize;
          sizes[i++] = itemSize;

          if (startIndex >= this.itemCount) {
            break;
          }
        }

        return sizes;
      }
    },
    destruct: function destruct() {
      this.customSizes = this.__ranges__P_543_0 = null;
    }
  });
  qx.ui.virtual.core.Axis.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.type.Pointer": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * David Perez Carmona (david-perez)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A cell event instance contains all data for pointer events related to cells in
   * a pane.
   **/
  qx.Class.define("qx.ui.virtual.core.CellEvent", {
    extend: qx.event.type.Pointer,
    properties: {
      /** The table row of the event target. */
      row: {
        check: "Integer",
        nullable: true
      },

      /** The table column of the event target. */
      column: {
        check: "Integer",
        nullable: true
      }
    },
    members: {
      /**
       * Initialize the event.
       *
       * @param scroller {qx.ui.table.pane.Scroller} The tables pane scroller.
       * @param me {qx.event.type.Pointer} The original pointer event.
       * @param row {Integer?null} The cell's row index.
       * @param column {Integer?null} The cell's column index.
       */
      init: function init(scroller, me, row, column) {
        me.clone(this);
        this.setBubbles(false);
        this.setRow(row);
        this.setColumn(column);
      }
    }
  });
  qx.ui.virtual.core.CellEvent.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MChildrenHandling": {
        "require": true
      },
      "qx.ui.virtual.core.IWidgetCellProvider": {
        "construct": true
      },
      "qx.ui.core.Spacer": {},
      "qx.ui.core.FocusHandler": {},
      "qx.ui.core.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The WidgetCell layer renders each cell with a qooxdoo widget. The concrete
   * widget instance for each cell is provided by a cell provider.
   */
  qx.Class.define("qx.ui.virtual.layer.WidgetCell", {
    extend: qx.ui.virtual.layer.Abstract,
    include: [qx.ui.core.MChildrenHandling],

    /**
     * @param widgetCellProvider {qx.ui.virtual.core.IWidgetCellProvider} This
     *    class manages the life cycle of the cell widgets.
     */
    construct: function construct(widgetCellProvider) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this.setZIndex(12);
      {
        this.assertInterface(widgetCellProvider, qx.ui.virtual.core.IWidgetCellProvider);
      }
      this._cellProvider = widgetCellProvider;
      this.__spacerPool__P_552_0 = [];
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      anonymous: {
        refine: true,
        init: false
      }
    },
    events: {
      /**
       * Is fired when the {@link #_fullUpdate} or the
       * {@link #_updateLayerWindow} is finished.
       */
      updated: "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __spacerPool__P_552_0: null,

      /**
      * Returns the widget used to render the given cell. May return null if the
      * cell isn’t rendered currently rendered.
      *
      * @param row {Integer} The cell's row index
      * @param column {Integer} The cell's column index
      * @return {qx.ui.core.LayoutItem|null} the widget used to render the given
      *    cell or <code>null</code>
      */
      getRenderedCellWidget: function getRenderedCellWidget(row, column) {
        if (this._getChildren().length === 0) {
          return null;
        }

        var columnCount = this.getColumnSizes().length;
        var rowCount = this.getRowSizes().length;
        var firstRow = this.getFirstRow();
        var firstColumn = this.getFirstColumn();

        if (row < firstRow || row >= firstRow + rowCount || column < firstColumn || column >= firstColumn + columnCount) {
          return null;
        }

        var childIndex = column - firstColumn + (row - firstRow) * columnCount;

        var widget = this._getChildren()[childIndex];

        if (!widget || widget.getUserData("cell.empty")) {
          return null;
        } else {
          return widget;
        }
      },

      /**
       * Get the spacer widget, for empty cells
       *
       * @return {qx.ui.core.Spacer} The spacer widget.
       */
      _getSpacer: function _getSpacer() {
        var spacer = this.__spacerPool__P_552_0.pop();

        if (!spacer) {
          spacer = new qx.ui.core.Spacer();
          spacer.setUserData("cell.empty", 1);
        }

        return spacer;
      },

      /**
       * Activates one of the still not empty items.
       * @param elementToPool {qx.ui.core.Widget} The widget which gets pooled.
       */
      _activateNotEmptyChild: function _activateNotEmptyChild(elementToPool) {
        // get the current active element
        var active = qx.ui.core.FocusHandler.getInstance().getActiveWidget(); // if the element to pool is active or one of its children

        if (active == elementToPool || qx.ui.core.Widget.contains(elementToPool, active)) {
          // search for a new child to activate
          var children = this._getChildren();

          for (var i = children.length - 1; i >= 0; i--) {
            if (!children[i].getUserData("cell.empty")) {
              children[i].activate();
              break;
            }
          }

          ;
        }
      },
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var cellProvider = this._cellProvider;

        var children = this._getChildren().concat();

        for (var i = 0; i < children.length; i++) {
          var child = children[i];

          if (child.getUserData("cell.empty")) {
            this.__spacerPool__P_552_0.push(child);
          } else {
            this._activateNotEmptyChild(child);

            cellProvider.poolCellWidget(child);
          }
        }

        var top = 0;
        var left = 0;
        var visibleItems = [];

        for (var y = 0; y < rowSizes.length; y++) {
          for (var x = 0; x < columnSizes.length; x++) {
            var row = firstRow + y;
            var column = firstColumn + x;

            var item = cellProvider.getCellWidget(row, column) || this._getSpacer();

            visibleItems.push(item);
            item.setUserBounds(left, top, columnSizes[x], rowSizes[y]);
            item.setUserData("cell.row", row);
            item.setUserData("cell.column", column);

            this._add(item);

            left += columnSizes[x];
          }

          top += rowSizes[y];
          left = 0;
        }

        children.forEach(function (child) {
          if (visibleItems.indexOf(child) === -1) {
            this._remove(child);
          }
        }.bind(this));
        this.fireEvent("updated");
      },
      _updateLayerWindow: function _updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        // compute overlap of old and new window
        //
        //      +---+
        //      |  ##--+
        //      |  ##  |
        //      +--##  |
        //         +---+
        //
        {
          this.assertPositiveInteger(firstRow);
          this.assertPositiveInteger(firstColumn);
          this.assertArray(rowSizes);
          this.assertArray(columnSizes);
        }
        var lastRow = firstRow + rowSizes.length - 1;
        var lastColumn = firstColumn + columnSizes.length - 1;
        var overlap = {
          firstRow: Math.max(firstRow, this.getFirstRow()),
          lastRow: Math.min(lastRow, this._lastRow),
          firstColumn: Math.max(firstColumn, this.getFirstColumn()),
          lastColumn: Math.min(lastColumn, this._lastColumn)
        };
        this._lastColumn = lastColumn;
        this._lastRow = lastRow;

        if (overlap.firstRow > overlap.lastRow || overlap.firstColumn > overlap.lastColumn) {
          return this._fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
        } // collect the widgets to move


        var children = this._getChildren();

        var lineLength = this.getColumnSizes().length;
        var widgetsToMove = [];
        var widgetsToMoveIndexes = {};

        for (var row = firstRow; row <= lastRow; row++) {
          widgetsToMove[row] = [];

          for (var column = firstColumn; column <= lastColumn; column++) {
            if (row >= overlap.firstRow && row <= overlap.lastRow && column >= overlap.firstColumn && column <= overlap.lastColumn) {
              var x = column - this.getFirstColumn();
              var y = row - this.getFirstRow();
              var index = y * lineLength + x;
              widgetsToMove[row][column] = children[index];
              widgetsToMoveIndexes[index] = true;
            }
          }
        }

        var cellProvider = this._cellProvider; // pool widgets

        var children = this._getChildren().concat();

        for (var i = 0; i < children.length; i++) {
          if (!widgetsToMoveIndexes[i]) {
            var child = children[i];

            if (child.getUserData("cell.empty")) {
              this.__spacerPool__P_552_0.push(child);
            } else {
              this._activateNotEmptyChild(child);

              cellProvider.poolCellWidget(child);
            }
          }
        }

        var top = 0;
        var left = 0;
        var visibleItems = [];

        for (var y = 0; y < rowSizes.length; y++) {
          for (var x = 0; x < columnSizes.length; x++) {
            var row = firstRow + y;
            var column = firstColumn + x;

            var item = widgetsToMove[row][column] || cellProvider.getCellWidget(row, column) || this._getSpacer();

            visibleItems.push(item);
            item.setUserBounds(left, top, columnSizes[x], rowSizes[y]);
            item.setUserData("cell.row", row);
            item.setUserData("cell.column", column);

            this._add(item);

            left += columnSizes[x];
          }

          top += rowSizes[y];
          left = 0;
        }

        children.forEach(function (child) {
          if (visibleItems.indexOf(child) === -1) {
            this._remove(child);
          }
        }.bind(this));
        this.fireEvent("updated");
      }
    },
    destruct: function destruct() {
      var children = this._getChildren();

      for (var i = 0; i < children.length; i++) {
        children[i].dispose();
      }

      this._cellProvider = this.__spacerPool__P_552_0 = null;
    }
  });
  qx.ui.virtual.layer.WidgetCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A widget cell renderer manages a pool of widgets to render cells in a
   * {@link qx.ui.virtual.layer.WidgetCell} layer.
   */
  qx.Interface.define("qx.ui.virtual.cell.IWidgetCell", {
    members: {
      /**
       * Get a widget instance to render the cell
       *
       * @param data {var} Data needed for the cell to render.
       * @param states {Map} The states set on the cell (e.g. <i>selected</i>,
       * <i>focused</i>, <i>editable</i>).
       *
       * @return {qx.ui.core.LayoutItem} The cell widget
       */
      getCellWidget: function getCellWidget(data, states) {},

      /**
       * Release the given widget instance.
       *
       * Either pool or dispose the widget.
       *
       * @param widget {qx.ui.core.LayoutItem} The cell widget to pool
       */
      pool: function pool(widget) {},

      /**
       * Update the states of the given widget.
       *
       * @param widget {qx.ui.core.LayoutItem} The cell widget to update
       * @param states {Map} The cell widget's states
       */
      updateStates: function updateStates(widget, states) {},

      /**
       * Update the data the cell widget should display
       *
       * @param widget {qx.ui.core.LayoutItem} The cell widget to update
       * @param data {var} The data to display
       */
      updateData: function updateData(widget, data) {}
    }
  });
  qx.ui.virtual.cell.IWidgetCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.cell.IWidgetCell": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * Abstract base class for widget based cell renderer.
   */
  qx.Class.define("qx.ui.virtual.cell.AbstractWidget", {
    extend: qx.core.Object,
    implement: [qx.ui.virtual.cell.IWidgetCell],
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__pool__P_539_0 = [];
    },
    events: {
      /** Fired when a new <code>LayoutItem</code> is created. */
      "created": "qx.event.type.Data"
    },
    members: {
      __pool__P_539_0: null,

      /**
       * Creates the widget instance.
       *
       * @abstract
       * @return {qx.ui.core.LayoutItem} The widget used to render a cell
       */
      _createWidget: function _createWidget() {
        throw new Error("abstract method call");
      },
      // interface implementation
      updateData: function updateData(widget, data) {
        throw new Error("abstract method call");
      },
      // interface implementation
      updateStates: function updateStates(widget, states) {
        var oldStates = widget.getUserData("cell.states"); // remove old states

        if (oldStates) {
          var newStates = states || {};

          for (var state in oldStates) {
            if (!newStates[state]) {
              widget.removeState(state);
            }
          }
        } else {
          oldStates = {};
        } // apply new states


        if (states) {
          for (var state in states) {
            if (!oldStates.state) {
              widget.addState(state);
            }
          }
        }

        widget.setUserData("cell.states", states);
      },
      // interface implementation
      getCellWidget: function getCellWidget(data, states) {
        var widget = this.__getWidgetFromPool__P_539_1();

        this.updateStates(widget, states);
        this.updateData(widget, data);
        return widget;
      },
      // interface implementation
      pool: function pool(widget) {
        this.__pool__P_539_0.push(widget);
      },

      /**
       * Cleanup all <code>LayoutItem</code> and destroy them.
       */
      _cleanupPool: function _cleanupPool() {
        var widget = this.__pool__P_539_0.pop();

        while (widget) {
          widget.destroy();
          widget = this.__pool__P_539_0.pop();
        }
      },

      /**
       * Returns a <code>LayoutItem</code> from the pool, when the pool is empty
       * a new <code>LayoutItem</code> is created.
       *
       * @return {qx.ui.core.LayoutItem} The cell widget
       */
      __getWidgetFromPool__P_539_1: function __getWidgetFromPool__P_539_1() {
        var widget = this.__pool__P_539_0.shift();

        if (widget == null) {
          widget = this._createWidget();
          this.fireDataEvent("created", widget);
        }

        return widget;
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this._cleanupPool();

      this.__pool__P_539_0 = null;
    }
  });
  qx.ui.virtual.cell.AbstractWidget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.AbstractWidget": {
        "require": true
      },
      "qx.ui.core.Widget": {},
      "qx.util.PropertyUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Cell renderer can be used for Widget rendering. The Widget creation can be configured with the
   * {@link #delegate} property:
   *
   * <pre class="javascript">
   * widgetCell.setDelegate(
   * {
   *   createWidget : function() {
   *     return new qx.ui.form.ListItem();
   *   }
   * });
   * </pre>
   *
   * When the {@link #delegate} property is not used {@link qx.ui.core.Widget} instances are created as
   * fallback.
   *
   * The {@link #updateData} method can be used to update any Widget property. Just use a <code>Map</code>
   * with property name as key:
   *
   * <pre class="javascript">
   * // widget is a qx.ui.form.ListItem instance
   * widgetCell.updateData(widget,
   * {
   *   label: "my label value",
   *   icon: "qx/icon/22/emotes/face-angel.png"
   * });
   * </pre>
   */
  qx.Class.define("qx.ui.virtual.cell.WidgetCell", {
    extend: qx.ui.virtual.cell.AbstractWidget,
    properties: {
      /**
       * Delegation object, which can have one or more functions defined by the
       * {@link qx.ui.virtual.cell.IWidgetCellDelegate} interface.
       */
      delegate: {
        apply: "_applyDelegate",
        init: null,
        nullable: true
      }
    },
    members: {
      // apply method
      _applyDelegate: function _applyDelegate(value, old) {
        this._cleanupPool();
      },
      // overridden
      _createWidget: function _createWidget() {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.createWidget != null) {
          return delegate.createWidget();
        } else {
          return new qx.ui.core.Widget();
        }
      },
      // overridden
      updateData: function updateData(widget, data) {
        for (var key in data) {
          if (qx.Class.hasProperty(widget.constructor, key)) {
            qx.util.PropertyUtil.setUserValue(widget, key, data[key]);
          } else {
            throw new Error("Can't update data! The key '" + key + "' is not a Property!");
          }
        }
      }
    }
  });
  qx.ui.virtual.cell.WidgetCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.core.AbstractVirtualBox": {
        "construct": true,
        "require": true
      },
      "qx.data.controller.ISelection": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.event.Timer": {
        "construct": true
      },
      "qx.ui.core.Spacer": {},
      "qx.ui.form.ListItem": {},
      "qx.ui.basic.Image": {},
      "qx.ui.core.queue.Widget": {},
      "qx.data.SingleValueBinding": {},
      "qx.util.Delegate": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A form virtual widget which allows a single selection. Looks somewhat like
   * a normal button, but opens a virtual list of items to select when tapping
   * on it.
   *
   * @childControl spacer {qx.ui.core.Spacer} Flexible spacer widget.
   * @childControl atom {qx.ui.basic.Atom} Shows the text and icon of the content.
   * @childControl arrow {qx.ui.basic.Image} Shows the arrow to open the drop-down
   *   list.
   */
  qx.Class.define("qx.ui.form.VirtualSelectBox", {
    extend: qx.ui.form.core.AbstractVirtualBox,
    implement: [qx.data.controller.ISelection, qx.ui.form.IField],
    construct: function construct(model) {
      qx.ui.form.core.AbstractVirtualBox.constructor.call(this, model);

      this._createChildControl("atom");

      this._createChildControl("spacer");

      this._createChildControl("arrow"); // Register listener


      this.addListener("pointerover", this._onPointerOver, this);
      this.addListener("pointerout", this._onPointerOut, this);
      this.__bindings__P_428_0 = [];
      this.initSelection(this.getChildControl("dropdown").getSelection());
      this.__searchTimer__P_428_1 = new qx.event.Timer(500);

      this.__searchTimer__P_428_1.addListener("interval", this.__preselect__P_428_2, this);

      this.getSelection().addListener("change", this._updateSelectionValue, this);
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "virtual-selectbox"
      },
      // overridden
      width: {
        refine: true,
        init: 120
      },

      /** Current selected items. */
      selection: {
        check: "qx.data.Array",
        event: "changeSelection",
        apply: "_applySelection",
        nullable: false,
        deferredInit: true
      }
    },
    events: {
      /**
       * This event is fired as soon as the content of the selection property changes, but
       * this is not equal to the change of the selection of the widget. If the selection
       * of the widget changes, the content of the array stored in the selection property
       * changes. This means you have to listen to the change event of the selection array
       * to get an event as soon as the user changes the selected item.
       * <pre class="javascript">obj.getSelection().addListener("change", listener, this);</pre>
       */
      "changeSelection": "qx.event.type.Data",

      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data"
    },
    members: {
      /** @type {String} The search value to {@link #__preselect} an item. */
      __searchValue__P_428_3: "",

      /**
       * @type {qx.event.Timer} The time which triggers the search for pre-selection.
       */
      __searchTimer__P_428_1: null,

      /** @type {Array} Contains the id from all bindings. */
      __bindings__P_428_0: null,

      /**
       * @param selected {var|null} Item to select as value.
       * @returns {null|TypeError} The status of this operation.
       */
      setValue: function setValue(selected) {
        if (null === selected) {
          this.getSelection().removeAll();
          return null;
        }

        this.getSelection().setItem(0, selected);
        return null;
      },

      /**
       * @returns {null|var} The currently selected item or null if there is none.
       */
      getValue: function getValue() {
        var s = this.getSelection();
        return s.length === 0 ? null : s.getItem(0);
      },
      resetValue: function resetValue() {
        this.setValue(null);
      },
      // overridden
      syncWidget: function syncWidget(jobs) {
        this._removeBindings();

        this._addBindings();
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAl API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "spacer":
            control = new qx.ui.core.Spacer();

            this._add(control, {
              flex: 1
            });

            break;

          case "atom":
            control = new qx.ui.form.ListItem("");
            control.setCenter(false);
            control.setAnonymous(true);

            this._add(control, {
              flex: 1
            });

            break;

          case "arrow":
            control = new qx.ui.basic.Image();
            control.setAnonymous(true);

            this._add(control);

            break;
        }

        return control || qx.ui.form.VirtualSelectBox.prototype._createChildControlImpl.base.call(this, id, hash);
      },
      // overridden
      _getAction: function _getAction(event) {
        var keyIdentifier = event.getKeyIdentifier();
        var isOpen = this.getChildControl("dropdown").isVisible();

        var isModifierPressed = this._isModifierPressed(event);

        if (!isOpen && !isModifierPressed && (keyIdentifier === "Enter" || keyIdentifier === "Space")) {
          return "open";
        } else if (isOpen && event.isPrintable()) {
          return "search";
        } else {
          return qx.ui.form.VirtualSelectBox.prototype._getAction.base.call(this, event);
        }
      },

      /**
       * This method is called when the binding can be added to the
       * widget. For e.q. bind the drop-down selection with the widget.
       */
      _addBindings: function _addBindings() {
        var atom = this.getChildControl("atom");

        var modelPath = this._getBindPath("selection", "");

        var id = this.bind(modelPath, atom, "model", null);

        this.__bindings__P_428_0.push(id);

        var labelSourcePath = this._getBindPath("selection", this.getLabelPath());

        id = this.bind(labelSourcePath, atom, "label", this.getLabelOptions());

        this.__bindings__P_428_0.push(id);

        if (this.getIconPath() != null) {
          var iconSourcePath = this._getBindPath("selection", this.getIconPath());

          id = this.bind(iconSourcePath, atom, "icon", this.getIconOptions());

          this.__bindings__P_428_0.push(id);
        }
      },

      /**
       * This method is called when the binding can be removed from the
       * widget. For e.q. remove the bound drop-down selection.
       */
      _removeBindings: function _removeBindings() {
        while (this.__bindings__P_428_0.length > 0) {
          var id = this.__bindings__P_428_0.pop();

          this.removeBinding(id);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      // overridden
      _handlePointer: function _handlePointer(event) {
        qx.ui.form.VirtualSelectBox.prototype._handlePointer.base.call(this, event);

        var type = event.getType();

        if (type === "tap") {
          this.toggle();
        }
      },
      // overridden
      _handleKeyboard: function _handleKeyboard(event) {
        var action = this._getAction(event);

        switch (action) {
          case "search":
            this.__searchValue__P_428_3 += this.__convertKeyIdentifier__P_428_4(event.getKeyIdentifier());

            this.__searchTimer__P_428_1.restart();

            break;

          default:
            qx.ui.form.VirtualSelectBox.prototype._handleKeyboard.base.call(this, event);

            break;
        }
      },

      /**
       * Listener method for "pointerover" event.
       *
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state
       *   is set)</li>
       * </ul>
       *
       * @param event {qx.event.type.Pointer} Pointer event
       */
      _onPointerOver: function _onPointerOver(event) {
        if (!this.isEnabled() || event.getTarget() !== this) {
          return;
        }

        if (this.hasState("abandoned")) {
          this.removeState("abandoned");
          this.addState("pressed");
        }

        this.addState("hovered");
      },

      /**
       * Listener method for "pointerout" event.
       *
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" and removes "pressed" state (if "pressed" state
       *   is set)</li>
       * </ul>
       *
       * @param event {qx.event.type.Pointer} Pointer event
       */
      _onPointerOut: function _onPointerOut(event) {
        if (!this.isEnabled() || event.getTarget() !== this) {
          return;
        }

        this.removeState("hovered");

        if (this.hasState("pressed")) {
          this.removeState("pressed");
          this.addState("abandoned");
        }
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applySelection: function _applySelection(value, old) {
        this.getChildControl("dropdown").setSelection(value);
        qx.ui.core.queue.Widget.add(this);
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Preselects an item in the drop-down, when item starts with the
       * __searchValue value.
       */
      __preselect__P_428_2: function __preselect__P_428_2() {
        this.__searchTimer__P_428_1.stop();

        var searchValue = this.__searchValue__P_428_3;

        if (searchValue === null || searchValue === "") {
          return;
        }

        var model = this.getModel();
        var list = this.getChildControl("dropdown").getChildControl("list");
        var selection = list.getSelection();

        var length = list._getLookupTable().length;

        var startIndex = model.indexOf(selection.getItem(0));

        var startRow = list._reverseLookup(startIndex);

        for (var i = 1; i <= length; i++) {
          var row = (i + startRow) % length;
          var item = model.getItem(list._lookup(row));

          if (!item) {
            // group items aren't in the model
            continue;
          }

          var value = item;

          if (this.getLabelPath()) {
            value = qx.data.SingleValueBinding.resolvePropertyChain(item, this.getLabelPath());
            var labelOptions = this.getLabelOptions();

            if (labelOptions) {
              var converter = qx.util.Delegate.getMethod(labelOptions, "converter");

              if (converter) {
                value = converter(value, item);
              }
            }
          }

          if (value.toLowerCase().startsWith(searchValue.toLowerCase())) {
            selection.push(item);
            break;
          }
        }

        this.__searchValue__P_428_3 = "";
      },

      /**
       * Converts the keyIdentifier to a printable character e.q. <code>"Space"</code>
       * to <code>" "</code>.
       *
       * @param keyIdentifier {String} The keyIdentifier to convert.
       * @return {String} The converted keyIdentifier.
       */
      __convertKeyIdentifier__P_428_4: function __convertKeyIdentifier__P_428_4(keyIdentifier) {
        if (keyIdentifier === "Space") {
          return " ";
        } else {
          return keyIdentifier;
        }
      },

      /**
       * Called when selection changes.
       *
       * @param event {qx.event.type.Data} {@link qx.data.Array} change event.
       */
      _updateSelectionValue: function _updateSelectionValue(event) {
        var d = event.getData();
        var old = d.removed.length ? d.removed[0] : null;
        this.fireDataEvent("changeValue", d.added[0], old);
      }
    },
    destruct: function destruct() {
      this._removeBindings();

      this.getSelection().removeListener("change", this._updateSelectionValue, this);

      this.__searchTimer__P_428_1.removeListener("interval", this.__preselect__P_428_2, this);

      this.__searchTimer__P_428_1.dispose();

      this.__searchTimer__P_428_1 = null;
    }
  });
  qx.ui.form.VirtualSelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This interface defines the necessary features a form renderer should have.
   * Keep in mind that all renderes has to be widgets.
   */
  qx.Interface.define("qx.ui.form.renderer.IFormRenderer", {
    members: {
      /**
       * Add a group of form items with the corresponding names. The names should
       * be displayed as hint for the user what to do with the form item.
       * The title is optional and can be used as grouping for the given form
       * items.
       *
       * @param items {qx.ui.core.Widget[]} An array of form items to render.
       * @param names {String[]} An array of names for the form items.
       * @param title {String?} A title of the group you are adding.
       * @param itemsOptions {Array?null} The added additional data.
       * @param headerOptions {Map?null} The options map as defined by the form
       *   for the current group header.
       */
      addItems: function addItems(items, names, title, itemsOptions, headerOptions) {},

      /**
       * Adds a button the form renderer.
       *
       * @param button {qx.ui.form.Button} A button which should be added to
       *   the form.
       * @param options {Map?null} The added additional data.
       */
      addButton: function addButton(button, options) {}
    }
  });
  qx.ui.form.renderer.IFormRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.renderer.IFormRenderer": {
        "require": true
      },
      "qx.locale.Manager": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Abstract renderer for {@link qx.ui.form.Form}. This abstract renderer should
   * be the superclass of all form renderer. It takes the form, which is
   * supplied as constructor parameter and configures itself. So if you need to
   * set some additional information on your renderer before adding the widgets,
   * be sure to do that before calling this.base(arguments, form).
   */
  qx.Class.define("qx.ui.form.renderer.AbstractRenderer", {
    type: "abstract",
    extend: qx.ui.core.Widget,
    implement: qx.ui.form.renderer.IFormRenderer,

    /**
     * @param form {qx.ui.form.Form} The form to render.
     */
    construct: function construct(form) {
      qx.ui.core.Widget.constructor.call(this);
      this._labels = []; // translation support

      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
        this._names = [];
      }
      this._form = form;

      this._render();

      form.addListener("change", this._onFormChange, this);
    },
    properties: {
      /**
       * A string that is appended to the label if it is not empty.
       * Defaults to " :"
       */
      labelSuffix: {
        check: "String",
        init: " :",
        event: "changeLabelSuffix",
        nullable: true
      },

      /**
       * A string that is appended to the label and the label suffix if the corresponding
       * form field is mandatory. Defaults to space plus a red asterisk.
       */
      requiredSuffix: {
        check: "String",
        init: " <span style='color:red'>*</span> ",
        event: "changeRequiredSuffix",
        nullable: false
      }
    },
    members: {
      _names: null,
      _form: null,
      _labels: null,

      /**
       * Renders the form: adds the items and buttons.
       */
      _render: function _render() {
        // add the groups
        var groups = this._form.getGroups();

        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          this.addItems(group.items, group.labels, group.title, group.options, group.headerOptions);
        } // add the buttons


        var buttons = this._form.getButtons();

        var buttonOptions = this._form.getButtonOptions();

        for (var i = 0; i < buttons.length; i++) {
          this.addButton(buttons[i], buttonOptions[i]);
        }
      },

      /**
       * Handler responsible for updating the rendered widget as soon as the
       * form changes.
       */
      _onFormChange: function _onFormChange() {
        this._removeAll(); // remove all created labels


        for (var i = 0; i < this._labels.length; i++) {
          this._labels[i].dispose();
        }

        this._labels = [];

        this._render();
      },

      /**
       * Helper to bind the item's visibility to the label's visibility.
       * @param item {qx.ui.core.Widget} The form element.
       * @param label {qx.ui.basic.Label} The label for the form element.
       */
      _connectVisibility: function _connectVisibility(item, label) {
        // map the items visibility to the label
        item.bind("visibility", label, "visibility");
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale: function _onChangeLocale(e) {
        for (var i = 0; i < this._names.length; i++) {
          var entry = this._names[i];

          if (entry.name && entry.name.translate) {
            entry.name = entry.name.translate();
          }

          var newText = this._createLabelText(entry.name, entry.item);

          entry.label.setValue(newText);
        }
      },

      /**
       * Creates the label text for the given form item.
       *
       * @param name {String} The content of the label without the
       *   trailing * and :
       * @param item {qx.ui.form.IForm} The item, which has the required state.
       * @return {String} The text for the given item.
       */
      _createLabelText: function _createLabelText(name, item) {
        var requiredSuffix = "";

        if (item.getRequired()) {
          requiredSuffix = this.getRequiredSuffix();
        } // Create the label. Append a suffix only if there's text to display.


        var labelSuffix = name.length > 0 || item.getRequired() ? this.getLabelSuffix() : "";
        return name + requiredSuffix + labelSuffix;
      },
      // interface implementation
      addItems: function addItems(items, names, title) {
        throw new Error("Abstract method call");
      },
      // interface implementation
      addButton: function addButton(button) {
        throw new Error("Abstract method call");
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
      this._names = null;

      this._form.removeListener("change", this._onFormChange, this);

      this._form = null;
    }
  });
  qx.ui.form.renderer.AbstractRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.renderer.AbstractRenderer": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Double column renderer for {@link qx.ui.form.Form}.
   */
  qx.Class.define("qx.ui.form.renderer.Double", {
    extend: qx.ui.form.renderer.AbstractRenderer,
    construct: function construct(form) {
      var layout = new qx.ui.layout.Grid();
      layout.setSpacing(6);
      layout.setColumnAlign(0, "right", "top");
      layout.setColumnAlign(1, "left", "top");
      layout.setColumnAlign(2, "right", "top");
      layout.setColumnAlign(3, "left", "top");

      this._setLayout(layout);

      qx.ui.form.renderer.AbstractRenderer.constructor.call(this, form);
    },
    members: {
      _row: 0,
      _buttonRow: null,
      // overridden
      _onFormChange: function _onFormChange() {
        if (this._buttonRow) {
          this._buttonRow.destroy();

          this._buttonRow = null;
        }

        this._row = 0;

        qx.ui.form.renderer.Double.prototype._onFormChange.base.call(this);
      },

      /**
       * Add a group of form items with the corresponding names. The names are
       * displayed as label.
       * The title is optional and is used as grouping for the given form
       * items.
       *
       * @param items {qx.ui.core.Widget[]} An array of form items to render.
       * @param names {String[]} An array of names for the form items.
       * @param title {String?} A title of the group you are adding.
       */
      addItems: function addItems(items, names, title) {
        // add the header
        if (title != null) {
          this._add(this._createHeader(title), {
            row: this._row,
            column: 0,
            colSpan: 4
          });

          this._row++;
        } // add the items


        for (var i = 0; i < items.length; i++) {
          var label = this._createLabel(names[i], items[i]);

          this._add(label, {
            row: this._row,
            column: i * 2 % 4
          });

          var item = items[i];
          label.setBuddy(item);

          this._connectVisibility(item, label);

          this._add(item, {
            row: this._row,
            column: i * 2 % 4 + 1
          });

          if (i % 2 == 1) {
            this._row++;
          } // store the names for translation


          {
            this._names.push({
              name: names[i],
              label: label,
              item: items[i]
            });
          }
        }

        if (i % 2 == 1) {
          this._row++;
        }
      },

      /**
       * Adds a button the form renderer. All buttons will be added in a
       * single row at the bottom of the form.
       *
       * @param button {qx.ui.form.Button} The button to add.
       */
      addButton: function addButton(button) {
        if (this._buttonRow == null) {
          // create button row
          this._buttonRow = new qx.ui.container.Composite();

          this._buttonRow.setMarginTop(5);

          var hbox = new qx.ui.layout.HBox();
          hbox.setAlignX("right");
          hbox.setSpacing(5);

          this._buttonRow.setLayout(hbox); // add the button row


          this._add(this._buttonRow, {
            row: this._row,
            column: 0,
            colSpan: 4
          }); // increase the row


          this._row++;
        } // add the button


        this._buttonRow.add(button);
      },

      /**
       * Returns the set layout for configuration.
       *
       * @return {qx.ui.layout.Grid} The grid layout of the widget.
       */
      getLayout: function getLayout() {
        return this._getLayout();
      },

      /**
       * Creates a label for the given form item.
       *
       * @param name {String} The content of the label without the
       *   trailing * and :
       * @param item {qx.ui.core.Widget} The item, which has the required state.
       * @return {qx.ui.basic.Label} The label for the given item.
       */
      _createLabel: function _createLabel(name, item) {
        var label = new qx.ui.basic.Label(this._createLabelText(name, item)); // store labels for disposal

        this._labels.push(label);

        label.setRich(true);
        return label;
      },

      /**
       * Creates a header label for the form groups.
       *
       * @param title {String} Creates a header label.
       * @return {qx.ui.basic.Label} The header for the form groups.
       */
      _createHeader: function _createHeader(title) {
        var header = new qx.ui.basic.Label(title); // store labels for disposal

        this._labels.push(header);

        header.setFont("bold");

        if (this._row != 0) {
          header.setMarginTop(10);
        }

        header.setAlignX("left");
        return header;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      // first, remove all buttons from the bottom row because they
      // should not be disposed
      if (this._buttonRow) {
        this._buttonRow.removeAll();

        this._disposeObjects("_buttonRow");
      }
    }
  });
  qx.ui.form.renderer.Double.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.renderer.AbstractRenderer": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Single column renderer for {@link qx.ui.form.Form}.
   */
  qx.Class.define("qx.ui.form.renderer.Single", {
    extend: qx.ui.form.renderer.AbstractRenderer,
    construct: function construct(form) {
      var layout = new qx.ui.layout.Grid();
      layout.setSpacing(6);
      layout.setColumnFlex(1, 1);
      layout.setColumnAlign(0, "right", "top");

      this._setLayout(layout);

      qx.ui.form.renderer.AbstractRenderer.constructor.call(this, form);
    },
    members: {
      _row: 0,
      _buttonRow: null,
      // overridden
      _onFormChange: function _onFormChange() {
        if (this._buttonRow) {
          this._buttonRow.destroy();

          this._buttonRow = null;
        }

        this._row = 0;

        qx.ui.form.renderer.Single.prototype._onFormChange.base.call(this);
      },

      /**
       * Add a group of form items with the corresponding names. The names are
       * displayed as label.
       * The title is optional and is used as grouping for the given form
       * items.
       *
       * @param items {qx.ui.core.Widget[]} An array of form items to render.
       * @param names {String[]} An array of names for the form items.
       * @param title {String?} A title of the group you are adding.
       */
      addItems: function addItems(items, names, title) {
        // add the header
        if (title != null) {
          this._add(this._createHeader(title), {
            row: this._row,
            column: 0,
            colSpan: 2
          });

          this._row++;
        } // add the items


        for (var i = 0; i < items.length; i++) {
          var label = this._createLabel(names[i], items[i]);

          this._add(label, {
            row: this._row,
            column: 0
          });

          var item = items[i];
          label.setBuddy(item);

          this._add(item, {
            row: this._row,
            column: 1
          });

          this._row++;

          this._connectVisibility(item, label); // store the names for translation


          {
            this._names.push({
              name: names[i],
              label: label,
              item: items[i]
            });
          }
        }
      },

      /**
       * Adds a button the form renderer. All buttons will be added in a
       * single row at the bottom of the form.
       *
       * @param button {qx.ui.form.Button} The button to add.
       */
      addButton: function addButton(button) {
        if (this._buttonRow == null) {
          // create button row
          this._buttonRow = new qx.ui.container.Composite();

          this._buttonRow.setMarginTop(5);

          var hbox = new qx.ui.layout.HBox();
          hbox.setAlignX("right");
          hbox.setSpacing(5);

          this._buttonRow.setLayout(hbox); // add the button row


          this._add(this._buttonRow, {
            row: this._row,
            column: 0,
            colSpan: 2
          }); // increase the row


          this._row++;
        } // add the button


        this._buttonRow.add(button);
      },

      /**
       * Returns the set layout for configuration.
       *
       * @return {qx.ui.layout.Grid} The grid layout of the widget.
       */
      getLayout: function getLayout() {
        return this._getLayout();
      },

      /**
       * Creates a label for the given form item.
       *
       * @param name {String} The content of the label without the
       *   trailing * and :
       * @param item {qx.ui.core.Widget} The item, which has the required state.
       * @return {qx.ui.basic.Label} The label for the given item.
       */
      _createLabel: function _createLabel(name, item) {
        var label = new qx.ui.basic.Label(this._createLabelText(name, item)); // store labels for disposal

        this._labels.push(label);

        label.setRich(true);
        label.setAppearance("form-renderer-label");
        return label;
      },

      /**
       * Creates a header label for the form groups.
       *
       * @param title {String} Creates a header label.
       * @return {qx.ui.basic.Label} The header for the form groups.
       */
      _createHeader: function _createHeader(title) {
        var header = new qx.ui.basic.Label(title); // store labels for disposal

        this._labels.push(header);

        header.setFont("bold");

        if (this._row != 0) {
          header.setMarginTop(10);
        }

        header.setAlignX("left");
        return header;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      // first, remove all buttons from the button row because they
      // should not be disposed
      if (this._buttonRow) {
        this._buttonRow.removeAll();

        this._disposeObjects("_buttonRow");
      }
    }
  });
  qx.ui.form.renderer.Single.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.renderer.Single": {
        "require": true
      },
      "qx.ui.form.renderer.IFormRenderer": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Renderer using the placeholder property of {@link qx.ui.form.AbstractField}
   * to visualize the name.
   */
  qx.Class.define("qx.ui.form.renderer.SinglePlaceholder", {
    extend: qx.ui.form.renderer.Single,
    implement: qx.ui.form.renderer.IFormRenderer,
    members: {
      // overridden
      addItems: function addItems(items, names, title) {
        // add the header
        if (title != null) {
          this._add(this._createHeader(title), {
            row: this._row,
            column: 0,
            colSpan: 2
          });

          this._row++;
        } // add the items


        for (var i = 0; i < items.length; i++) {
          if (items[i].setPlaceholder === undefined) {
            throw new Error("Only widgets with placeholders supported.");
          }

          items[i].setPlaceholder(names[i]);

          this._add(items[i], {
            row: this._row,
            column: 0
          });

          this._row++;
        }
      }
    }
  });
  qx.ui.form.renderer.SinglePlaceholder.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.groupbox.GroupBox": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.CheckBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * A group box, which has a check box near the legend.
   *
   * @childControl legend {qx.ui.form.CheckBox} checkbox to en-/disable the
   *   groupbox content
   */
  qx.Class.define("qx.ui.groupbox.CheckGroupBox", {
    extend: qx.ui.groupbox.GroupBox,
    implement: [qx.ui.form.IExecutable, qx.ui.form.IBooleanForm, qx.ui.form.IModel],
    include: [qx.ui.form.MModelProperty],
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "check-groupbox"
      }
    },
    events: {
      /** Fired when the included checkbox changed its value */
      "changeValue": "qx.event.type.Data",

      /** Fired if the {@link #execute} method is invoked.*/
      "execute": "qx.event.type.Event"
    },
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "legend":
            control = new qx.ui.form.CheckBox();
            control.setValue(true);
            control.setAllowGrowX(true);
            control.addListener("changeValue", this._onRadioChangeValue, this);
            control.addListener("resize", this._repositionFrame, this);
            control.addListener("execute", this._onExecute, this);

            this._add(control, {
              left: 0,
              right: 0
            });

        }

        return control || qx.ui.groupbox.CheckGroupBox.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.groupbox.CheckGroupBox.prototype._applyEnabled.base.call(this, value, old);

        this.getChildrenContainer().setEnabled(value && this.getValue());
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for execute event of checkbox.
       *
       * @param e {qx.event.type.Event} Event which holds the current status
       */
      _onExecute: function _onExecute(e) {
        this.fireEvent("execute");
      },

      /**
       * Event listener for change event of checkbox
       *
       * @param e {qx.event.type.Data} Data event which holds the current status
       */
      _onRadioChangeValue: function _onRadioChangeValue(e) {
        var checked = e.getData() ? true : false; // Disable content

        this.getChildrenContainer().setEnabled(checked); // Fire event to the outside

        this.fireDataEvent("changeValue", checked, e.getOldData());
      },

      /*
      ---------------------------------------------------------------------------
        REDIRECTIONS TO LEGEND (CHECKBOX COMPATIBILITY MODE)
      ---------------------------------------------------------------------------
      */
      // interface implementation
      execute: function execute() {
        this.getChildControl("legend").execute();
      },
      // interface implementation
      setCommand: function setCommand(command) {
        this.getChildControl("legend").setCommand(command);
      },
      // interface implementation
      getCommand: function getCommand() {
        return this.getChildControl("legend").getCommand();
      },

      /**
       * The value of the groupbox.
       *
       * @return {Boolean} <code>true</code> when enabled.
       */
      getValue: function getValue() {
        return this.getChildControl("legend").getValue();
      },

      /**
       * Configures the value of the groupbox.
       *
       * @param value {Boolean} <code>true</code> when enabled.
       */
      setValue: function setValue(value) {
        this.getChildControl("legend").setValue(value);
      },

      /**
       * Resets the value.
       */
      resetValue: function resetValue() {
        this.getChildControl("legend").resetValue();
      }
    }
  });
  qx.ui.groupbox.CheckGroupBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.groupbox.GroupBox": {
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      },
      "qx.ui.form.IExecutable": {
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.RadioButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * A group box, which has a radio button near the legend.
   *
   * @childControl legend {qx.ui.form.RadioButton} radio button to en-/disable the groupbox content
   */
  qx.Class.define("qx.ui.groupbox.RadioGroupBox", {
    extend: qx.ui.groupbox.GroupBox,
    implement: [qx.ui.form.IRadioItem, qx.ui.form.IExecutable, qx.ui.form.IBooleanForm, qx.ui.form.IModel],
    include: [qx.ui.form.MModelProperty],

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "radio-groupbox"
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the included radiobutton changed its value */
      "changeValue": "qx.event.type.Data",

      /** Fired if the {@link #execute} method is invoked.*/
      "execute": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "legend":
            control = new qx.ui.form.RadioButton();
            control.setAllowGrowX(true);
            control.setValue(true);
            control.addListener("changeValue", this._onRadioChangeValue, this);
            control.addListener("resize", this._repositionFrame, this);
            control.addListener("execute", this._onExecute, this);

            this._add(control, {
              left: 0,
              right: 0
            });

        }

        return control || qx.ui.groupbox.RadioGroupBox.prototype._createChildControlImpl.base.call(this, id);
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.groupbox.RadioGroupBox.prototype._applyEnabled.base.call(this, value, old);

        this.getChildrenContainer().setEnabled(value && this.getValue());
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event listener for execute event of checkbox.
       *
       * @param e {qx.event.type.Event} Event which holds the current status
       */
      _onExecute: function _onExecute(e) {
        this.fireEvent("execute");
      },

      /**
       * Event listener for changeValue event of radio button
       *
       * @param e {qx.event.type.Data} Data event which holds the current status
       */
      _onRadioChangeValue: function _onRadioChangeValue(e) {
        var checked = e.getData() ? true : false; // Disable content

        this.getChildrenContainer().setEnabled(checked); // Fire event to the outside

        this.fireDataEvent("changeValue", checked, e.getOldData());
      },

      /*
      ---------------------------------------------------------------------------
        REDIRECTIONS TO LEGEND (FOR RADIO GROUP SUPPORT)
      ---------------------------------------------------------------------------
      */
      // interface implementation
      execute: function execute() {
        this.getChildControl("legend").execute();
      },
      // interface implementation
      setCommand: function setCommand(command) {
        this.getChildControl("legend").setCommand(command);
      },
      // interface implementation
      getCommand: function getCommand() {
        return this.getChildControl("legend").getCommand();
      },

      /**
       * Returns the radio group
       *
       * @return {qx.ui.form.RadioGroup} The radio manager
       */
      getGroup: function getGroup() {
        return this.getChildControl("legend").getGroup();
      },

      /**
       * Sets the radio group to use
       *
       * @param value {qx.ui.form.RadioGroup} The radio group to use
       */
      setGroup: function setGroup(value) {
        if (value != null) {
          value.add(this);
        }

        return;
      },

      /**
       * The value of the groupbox
       *
       * @return {Boolean} <code>true</code> when enabled.
       */
      getValue: function getValue() {
        return this.getChildControl("legend").getValue();
      },

      /**
       * Configures the value of the groupbox.
       *
       * @param value {Boolean} <code>true</code> when enabled.
       */
      setValue: function setValue(value) {
        this.getChildControl("legend").setValue(value);
      },

      /**
       * Resets the value.
       */
      resetValue: function resetValue() {
        this.getChildControl("legend").resetValue();
      },

      /**
       * Returns the configured legend. Only used for RadioManager compatibility.
       *
       * @return {String} The configured legend.
       */
      getLabel: function getLabel() {
        return this.getChildControl("legend").getLabel();
      }
    }
  });
  qx.ui.groupbox.RadioGroupBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.lang.Type": {},
      "qx.ui.layout.Canvas": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2015 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */

  /**
   * The Progress bar is designed to simply display the current % complete
   * for a process.
   *
   * The Value is limited between 0 and Maximum value.
   * It's not allowed to set a Maximum value of 0.  If you set a Maximum value
   * bigger than 0, but smaller than Value, it will be limited to Value.
   *
   * The following example creates and adds a progress bar to the root element.
   * A listener is used to show the user if the value is changed,
   * and another one when the progress is complete.
   *
   * <pre class='javascript'>
   * var pb = new qx.ui.indicator.ProgressBar();
   * this.getRoot().add(pb, { left : 20, top: 20});
   *
   * pb.addListener("change", function(e) {
   *   this.debug(e.getData()); // % complete
   *   this.debug(pb.getValue()); // absolute value
   * });
   *
   * pb.addListener("complete", function(e) {
   *   this.debug("complete");
   * });
   *
   * //set a value
   * pb.setValue(20);
   * </pre>
   *
   * @childControl progress {qx.ui.container.Composite} The progress bar
   */
  qx.Class.define("qx.ui.indicator.ProgressBar", {
    extend: qx.ui.container.Composite,

    /**
     * @param value {Number ? 0} Progress bar value
     * @param maximum {Number ? 100} Progress bar maximum value
     */
    construct: function construct(value, maximum) {
      qx.ui.container.Composite.constructor.call(this);

      this._createChildControl("progress");

      this.setLayout(new qx.ui.layout.HBox());

      if (maximum != null) {
        this.setMaximum(maximum);
      }

      if (value != null) {
        this.setValue(value);
      }
    },
    properties: {
      appearance: {
        refine: true,
        init: "progressbar"
      },

      /** Maximum value of the progress bar */
      maximum: {
        init: 100,
        event: "changeMaximum",
        apply: "_applyMaximum"
      },

      /** Current value of the progress bar */
      value: {
        init: 0,
        event: "changeValue",
        apply: "_applyValue"
      }
    },
    events: {
      /**
       * Fired when the process is complete (value === maximum value)
       */
      complete: "qx.event.type.Event",

      /**
       * Fired when the % complete value is changed.
       */
      change: "qx.event.type.Data"
    },
    members: {
      // property apply
      _applyValue: function _applyValue(value, old) {
        var max = this.getMaximum(); //do nothing if is not a number

        if (!qx.lang.Type.isNumber(value) || !isFinite(value)) {
          value = old;
        }

        if (value < 0) {
          // limit value to 0
          value = 0;
        } else if (value > max) {
          // limit value to max
          value = max;
        } //set value


        this.setValue(value); //update progress

        this._changeProgress(value / max);
      },
      // property apply
      _applyMaximum: function _applyMaximum(value, old) {
        var max = value;
        var val = this.getValue(); //do nothing if is not a number, is negative or zero

        if (!qx.lang.Type.isNumber(max) || !isFinite(max) || max <= 0) {
          max = old;
        } //limit max to a greater than 0 value


        if (max < val) {
          max = val;
        } //set max


        this.setMaximum(max); //update progress

        this._changeProgress(val / max);
      },
      //overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "progress":
            control = new qx.ui.container.Composite(new qx.ui.layout.Canvas());

            this._add(control, {
              width: "0%"
            });

            break;
        }

        return control || qx.ui.indicator.ProgressBar.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Update the progress bar.
       *
       * @param value {Number} future value of progress bar
       */
      _changeProgress: function _changeProgress(value) {
        var bar = this.getChildControl("progress");
        var to = Math.floor(value * 100);
        var from = parseInt(bar.getLayoutProperties().width, 10);
        bar.setLayoutProperties({
          width: to + "%"
        }); //fire change event

        if (to != from) {
          this.fireDataEvent("change", to, from);
        } //fire complete event if 100% complete


        if (to === 100) {
          this.fireEvent("complete");
        }
      }
    }
  });
  qx.ui.indicator.ProgressBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Util": {},
      "qx.theme.manager.Decoration": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Docks children to one of the edges.
   *
   * *Features*
   *
   * * Percent width for left/right/center attached children
   * * Percent height for top/bottom/center attached children
   * * Minimum and maximum dimensions
   * * Prioritized growing/shrinking (flex)
   * * Auto sizing
   * * Margins and Spacings
   * * Alignment in orthogonal axis (e.g. alignX of north attached)
   * * Different sort options for children
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>edge</strong> <em>(String)</em>: The edge where the layout item
   *   should be docked. This may be one of <code>north</code>, <code>east</code>,
   *   <code>south</code>, <code>west</code> or <code>center</code>. (Required)</li>
   * <li><strong>width</strong> <em>(String)</em>: Defines a percent
   *   width for the item. The percent width,
   *   when specified, is used instead of the width defined by the size hint.
   *   This is only supported for children added to the north or south edge or
   *   are centered in the middle of the layout.
   *   The minimum and maximum width still takes care of the elements limitations.
   *   It has no influence on the layout's size hint. Percents are mainly useful for
   *   widgets which are sized by the outer hierarchy.
   * </li>
   * <li><strong>height</strong> <em>(String)</em>: Defines a percent
   *   height for the item. The percent height,
   *   when specified, is used instead of the height defined by the size hint.
   *   This is only supported for children added to the west or east edge or
   *   are centered in the middle of the layout.
   *   The minimum and maximum height still takes care of the elements limitations.
   *   It has no influence on the layout's size hint. Percents are mainly useful for
   *   widgets which are sized by the outer hierarchy.
   * </li>
   * </ul>
   *
   * *Example*
   *
   * <pre class="javascript">
   * var layout = new qx.ui.layout.Dock();
   *
   * var w1 = new qx.ui.core.Widget();
   * var w2 = new qx.ui.core.Widget();
   * var w3 = new qx.ui.core.Widget();
   *
   * w1.setHeight(200);
   * w2.setWidth(150);
   *
   * var container = new qx.ui.container.Composite(layout);
   * container.add(w1, {edge:"north"});
   * container.add(w2, {edge:"west"});
   * container.add(w3, {edge:"center"});
   * </pre>
   *
   * *Detailed Description*
   *
   * Using this layout, items may be "docked" to a specific side
   * of the available space. Each displayed item reduces the available space
   * for the following children. Priorities depend on the position of
   * the child in the internal children list.
   *
   * *External Documentation*
   *
   * <a href='https://qooxdoo.org/documentation/#/desktop/layout/dock.md'>
   * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.
   */
  qx.Class.define("qx.ui.layout.Dock", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param spacingX {Integer?0} The horizontal spacing. Sets {@link #spacingX}.
     * @param spacingY {Integer?0} The vertical spacing. Sets {@link #spacingY}.
     * @param separatorX {String|qx.ui.decoration.IDecorator} Separator to render between columns
     * @param separatorY {String|qx.ui.decoration.IDecorator} Separator to render between rows
     */
    construct: function construct(spacingX, spacingY, separatorX, separatorY) {
      qx.ui.layout.Abstract.constructor.call(this);

      if (spacingX) {
        this.setSpacingX(spacingX);
      }

      if (spacingY) {
        this.setSpacingY(spacingY);
      }

      if (separatorX) {
        this.setSeparatorX(separatorX);
      }

      if (separatorY) {
        this.setSeparatorY(separatorY);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The way the widgets should be displayed (in conjunction with their
       * position in the childrens array).
       */
      sort: {
        check: ["auto", "y", "x"],
        init: "auto",
        apply: "_applySort"
      },

      /** Separator lines to use between the horizontal objects */
      separatorX: {
        check: "Decorator",
        nullable: true,
        apply: "_applyLayoutChange"
      },

      /** Separator lines to use between the vertical objects */
      separatorY: {
        check: "Decorator",
        nullable: true,
        apply: "_applyLayoutChange"
      },

      /**
       * Whether separators should be collapsed so when a spacing is
       * configured the line go over into each other
       */
      connectSeparators: {
        check: "Boolean",
        init: false,
        apply: "_applyLayoutChange"
      },

      /** Horizontal spacing between two children */
      spacingX: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /** Vertical spacing between two children */
      spacingY: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __children__P_434_0: null,
      __edges__P_434_1: null,
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        this.assertInArray(name, ["flex", "edge", "height", "width"], "The property '" + name + "' is not supported by the Dock layout!");

        if (name === "edge") {
          this.assertInArray(value, ["north", "south", "west", "east", "center"]);
        } else if (name === "flex") {
          this.assertNumber(value);
          this.assert(value >= 0);
        } else {
          this.assertMatch(value, qx.ui.layout.Util.PERCENT_VALUE);
        }
      },
      // property apply
      _applySort: function _applySort() {
        // easiest way is to invalidate the cache
        this._invalidChildrenCache = true; // call normal layout change

        this._applyLayoutChange();
      },

      /**
       * @type {Map} Maps edge IDs to numeric values
       *
       * @lint ignoreReferenceField(__edgeMap)
       */
      __edgeMap__P_434_2: {
        north: 1,
        south: 2,
        west: 3,
        east: 4,
        center: 5
      },

      /**
       * @type {Map} Maps edges to align values
       *
       * @lint ignoreReferenceField(__alignMap)
       */
      __alignMap__P_434_3: {
        1: "top",
        2: "bottom",
        3: "left",
        4: "right"
      },

      /**
       * Rebuilds cache for sorted children list.
       *
       */
      __rebuildCache__P_434_4: function __rebuildCache__P_434_4() {
        var all = this._getLayoutChildren();

        var child, center;
        var length = all.length;
        var high = [];
        var low = [];
        var edge = [];
        var yfirst = this.getSort() === "y";
        var xfirst = this.getSort() === "x";

        for (var i = 0; i < length; i++) {
          child = all[i];
          edge = child.getLayoutProperties().edge;

          if (edge === "center") {
            if (center) {
              throw new Error("It is not allowed to have more than one child aligned to 'center'!");
            }

            center = child;
          } else if (xfirst || yfirst) {
            if (edge === "north" || edge === "south") {
              yfirst ? high.push(child) : low.push(child);
            } else if (edge === "west" || edge === "east") {
              yfirst ? low.push(child) : high.push(child);
            }
          } else {
            high.push(child);
          }
        } // Combine sorted children list


        var result = high.concat(low);

        if (center) {
          result.push(center);
        }

        this.__children__P_434_0 = result; // Cache edges for faster access

        var edges = [];

        for (var i = 0; i < length; i++) {
          edge = result[i].getLayoutProperties().edge;
          edges[i] = this.__edgeMap__P_434_2[edge] || 5;
        }

        this.__edges__P_434_1 = edges; // Clear invalidation marker

        delete this._invalidChildrenCache;
      },

      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        // Rebuild flex/width caches
        if (this._invalidChildrenCache) {
          this.__rebuildCache__P_434_4();
        }

        var util = qx.ui.layout.Util;
        var children = this.__children__P_434_0;
        var edges = this.__edges__P_434_1;
        var length = children.length;
        var flexibles, child, hint, props, flex, grow, width, height, offset;
        var widths = [];
        var heights = [];

        var separatorWidths = this._getSeparatorWidths();

        var spacingX = this.getSpacingX();
        var spacingY = this.getSpacingY(); // **************************************
        //   Caching children data
        // **************************************

        var allocatedWidth = -spacingX;
        var allocatedHeight = -spacingY;

        if (separatorWidths.x) {
          allocatedWidth -= separatorWidths.x + spacingX;
        }

        if (separatorWidths.y) {
          allocatedHeight -= separatorWidths.y + spacingY;
        }

        for (var i = 0; i < length; i++) {
          child = children[i];
          props = child.getLayoutProperties();
          hint = child.getSizeHint();
          width = hint.width;
          height = hint.height;

          if (props.width != null) {
            width = Math.floor(availWidth * parseFloat(props.width) / 100);

            if (width < hint.minWidth) {
              width = hint.minWidth;
            } else if (width > hint.maxWidth) {
              width = hint.maxWidth;
            }
          }

          if (props.height != null) {
            height = Math.floor(availHeight * parseFloat(props.height) / 100);

            if (height < hint.minHeight) {
              height = hint.minHeight;
            } else if (height > hint.maxHeight) {
              height = hint.maxHeight;
            }
          }

          widths[i] = width;
          heights[i] = height; // Update allocated width

          switch (edges[i]) {
            // north+south
            case 1:
            case 2:
              allocatedHeight += height + child.getMarginTop() + child.getMarginBottom() + spacingY;

              if (separatorWidths.y) {
                allocatedHeight += separatorWidths.y + spacingY;
              }

              break;
            // west+east

            case 3:
            case 4:
              allocatedWidth += width + child.getMarginLeft() + child.getMarginRight() + spacingX;

              if (separatorWidths.x) {
                allocatedWidth += separatorWidths.x + spacingX;
              }

              break;
            // center

            default:
              allocatedWidth += width + child.getMarginLeft() + child.getMarginRight() + spacingX;
              allocatedHeight += height + child.getMarginTop() + child.getMarginBottom() + spacingY;

              if (separatorWidths.x) {
                allocatedWidth += separatorWidths.x + spacingX;
              }

              if (separatorWidths.y) {
                allocatedHeight += separatorWidths.y + spacingY;
              }

          }
        } // **************************************
        //   Horizontal flex support
        // **************************************


        if (allocatedWidth != availWidth) {
          flexibles = {};
          grow = allocatedWidth < availWidth;

          for (var i = 0; i < length; i++) {
            child = children[i];

            switch (edges[i]) {
              case 3:
              case 4:
              case 5:
                flex = child.getLayoutProperties().flex; // Default flex for centered children is '1'

                if (flex == null && edges[i] == 5) {
                  flex = 1;
                }

                if (flex > 0) {
                  hint = child.getSizeHint();
                  flexibles[i] = {
                    min: hint.minWidth,
                    value: widths[i],
                    max: hint.maxWidth,
                    flex: flex
                  };
                }

            }
          }

          var result = util.computeFlexOffsets(flexibles, availWidth, allocatedWidth);

          for (var i in result) {
            offset = result[i].offset;
            widths[i] += offset;
            allocatedWidth += offset;
          }
        } // **************************************
        //   Vertical flex support
        // **************************************
        // Process height for flex stretching/shrinking


        if (allocatedHeight != availHeight) {
          flexibles = {};
          grow = allocatedHeight < availHeight;

          for (var i = 0; i < length; i++) {
            child = children[i];

            switch (edges[i]) {
              case 1:
              case 2:
              case 5:
                flex = child.getLayoutProperties().flex; // Default flex for centered children is '1'

                if (flex == null && edges[i] == 5) {
                  flex = 1;
                }

                if (flex > 0) {
                  hint = child.getSizeHint();
                  flexibles[i] = {
                    min: hint.minHeight,
                    value: heights[i],
                    max: hint.maxHeight,
                    flex: flex
                  };
                }

            }
          }

          var result = util.computeFlexOffsets(flexibles, availHeight, allocatedHeight);

          for (var i in result) {
            offset = result[i].offset;
            heights[i] += offset;
            allocatedHeight += offset;
          }
        } // **************************************
        //   Layout children
        // **************************************
        // Pre configure separators


        this._clearSeparators(); // Prepare loop


        var separatorX = this.getSeparatorX(),
            separatorY = this.getSeparatorY();
        var connectSeparators = this.getConnectSeparators();
        var nextTop = 0,
            nextLeft = 0;
        var left, top, width, height, used, edge;
        var separatorLeft, separatorTop, separatorWidth, separatorHeight;
        var marginTop, marginBottom, marginLeft, marginRight;
        var alignMap = this.__alignMap__P_434_3;

        for (var i = 0; i < length; i++) {
          // Cache child data
          child = children[i];
          edge = edges[i];
          hint = child.getSizeHint(); // Cache child margins

          marginTop = child.getMarginTop();
          marginBottom = child.getMarginBottom();
          marginLeft = child.getMarginLeft();
          marginRight = child.getMarginRight(); // Calculate child layout

          switch (edge) {
            // north + south
            case 1:
            case 2:
              // Full available width
              width = availWidth - marginLeft - marginRight; // Limit width to min/max

              if (width < hint.minWidth) {
                width = hint.minWidth;
              } else if (width > hint.maxWidth) {
                width = hint.maxWidth;
              } // Child preferred height


              height = heights[i]; // Compute position

              top = nextTop + util.computeVerticalAlignOffset(alignMap[edge], height, availHeight, marginTop, marginBottom);
              left = nextLeft + util.computeHorizontalAlignOffset(child.getAlignX() || "left", width, availWidth, marginLeft, marginRight); // Render the separator

              if (separatorWidths.y) {
                if (edge == 1) {
                  separatorTop = nextTop + height + marginTop + spacingY + marginBottom;
                } else {
                  separatorTop = nextTop + availHeight - height - marginTop - spacingY - marginBottom - separatorWidths.y;
                }

                separatorLeft = left;
                separatorWidth = availWidth;

                if (connectSeparators && separatorLeft > 0) {
                  separatorLeft -= spacingX + marginLeft;
                  separatorWidth += spacingX * 2;
                } else {
                  separatorLeft -= marginLeft;
                }

                this._renderSeparator(separatorY, {
                  left: separatorLeft + padding.left,
                  top: separatorTop + padding.top,
                  width: separatorWidth,
                  height: separatorWidths.y
                });
              } // Update available height


              used = height + marginTop + marginBottom + spacingY;

              if (separatorWidths.y) {
                used += separatorWidths.y + spacingY;
              }

              availHeight -= used; // Update coordinates, for next child

              if (edge == 1) {
                nextTop += used;
              }

              break;
            // west + east

            case 3:
            case 4:
              // Full available height
              height = availHeight - marginTop - marginBottom; // Limit height to min/max

              if (height < hint.minHeight) {
                height = hint.minHeight;
              } else if (height > hint.maxHeight) {
                height = hint.maxHeight;
              } // Child preferred width


              width = widths[i]; // Compute position

              left = nextLeft + util.computeHorizontalAlignOffset(alignMap[edge], width, availWidth, marginLeft, marginRight);
              top = nextTop + util.computeVerticalAlignOffset(child.getAlignY() || "top", height, availHeight, marginTop, marginBottom); // Render the separator

              if (separatorWidths.x) {
                if (edge == 3) {
                  separatorLeft = nextLeft + width + marginLeft + spacingX + marginRight;
                } else {
                  separatorLeft = nextLeft + availWidth - width - marginLeft - spacingX - marginRight - separatorWidths.x;
                }

                separatorTop = top;
                separatorHeight = availHeight;

                if (connectSeparators && separatorTop > 0) {
                  separatorTop -= spacingY + marginTop;
                  separatorHeight += spacingY * 2;
                } else {
                  separatorTop -= marginTop;
                }

                this._renderSeparator(separatorX, {
                  left: separatorLeft + padding.left,
                  top: separatorTop + padding.top,
                  width: separatorWidths.x,
                  height: separatorHeight
                });
              } // Update available height


              used = width + marginLeft + marginRight + spacingX;

              if (separatorWidths.x) {
                used += separatorWidths.x + spacingX;
              }

              availWidth -= used; // Update coordinates, for next child

              if (edge == 3) {
                nextLeft += used;
              }

              break;
            // center

            default:
              // Calculated width/height
              width = availWidth - marginLeft - marginRight;
              height = availHeight - marginTop - marginBottom; // Limit width to min/max

              if (width < hint.minWidth) {
                width = hint.minWidth;
              } else if (width > hint.maxWidth) {
                width = hint.maxWidth;
              } // Limit height to min/max


              if (height < hint.minHeight) {
                height = hint.minHeight;
              } else if (height > hint.maxHeight) {
                height = hint.maxHeight;
              } // Compute coordinates (respect margins and alignments for both axis)


              left = nextLeft + util.computeHorizontalAlignOffset(child.getAlignX() || "left", width, availWidth, marginLeft, marginRight);
              top = nextTop + util.computeVerticalAlignOffset(child.getAlignY() || "top", height, availHeight, marginTop, marginBottom);
          } // Apply layout


          child.renderLayout(left + padding.left, top + padding.top, width, height);
        }
      },

      /**
       * Computes the dimensions each separator on both the <code>x</code> and
       * <code>y</code> axis needs.
       *
       * @return {Map} Map with the keys <code>x</code> and
       *   <code>y</code>
       */
      _getSeparatorWidths: function _getSeparatorWidths() {
        var separatorX = this.getSeparatorX(),
            separatorY = this.getSeparatorY();

        if (separatorX || separatorY) {
          var decorationManager = qx.theme.manager.Decoration.getInstance();
        }

        if (separatorX) {
          var separatorInstanceX = decorationManager.resolve(separatorX);
          var separatorInsetsX = separatorInstanceX.getInsets();
          var separatorWidthX = separatorInsetsX.left + separatorInsetsX.right;
        }

        if (separatorY) {
          var separatorInstanceY = decorationManager.resolve(separatorY);
          var separatorInsetsY = separatorInstanceY.getInsets();
          var separatorWidthY = separatorInsetsY.top + separatorInsetsY.bottom;
        }

        return {
          x: separatorWidthX || 0,
          y: separatorWidthY || 0
        };
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        // Rebuild flex/width caches
        if (this._invalidChildrenCache) {
          this.__rebuildCache__P_434_4();
        }

        var children = this.__children__P_434_0;
        var edges = this.__edges__P_434_1;
        var length = children.length;
        var hint, child;
        var marginX, marginY;
        var widthX = 0,
            minWidthX = 0;
        var heightX = 0,
            minHeightX = 0;
        var widthY = 0,
            minWidthY = 0;
        var heightY = 0,
            minHeightY = 0;

        var separatorWidths = this._getSeparatorWidths();

        var spacingX = this.getSpacingX(),
            spacingY = this.getSpacingY();
        var spacingSumX = -spacingX,
            spacingSumY = -spacingY;

        if (separatorWidths.x) {
          spacingSumX -= separatorWidths.x + spacingX;
        }

        if (separatorWidths.y) {
          spacingSumY -= separatorWidths.y + spacingY;
        } // Detect children sizes


        for (var i = 0; i < length; i++) {
          child = children[i];
          hint = child.getSizeHint(); // Pre-cache margin sums

          marginX = child.getMarginLeft() + child.getMarginRight();
          marginY = child.getMarginTop() + child.getMarginBottom(); // Ok, this part is a bit complicated :)

          switch (edges[i]) {
            case 1:
            case 2:
              // Find the maximum width used by these fully stretched items
              // The recommended width used by these must add the currently
              // occupied width by the orthogonal ordered children.
              widthY = Math.max(widthY, hint.width + widthX + marginX);
              minWidthY = Math.max(minWidthY, hint.minWidth + minWidthX + marginX); // Add the needed heights of this widget

              heightY += hint.height + marginY;
              minHeightY += hint.minHeight + marginY; // Add spacing

              spacingSumY += spacingY;

              if (separatorWidths.y) {
                spacingSumY += separatorWidths.y + spacingY;
              }

              break;

            case 3:
            case 4:
              // Find the maximum height used by these fully stretched items
              // The recommended height used by these must add the currently
              // occupied height by the orthogonal ordered children.
              heightX = Math.max(heightX, hint.height + heightY + marginY);
              minHeightX = Math.max(minHeightX, hint.minHeight + minHeightY + marginY); // Add the needed widths of this widget

              widthX += hint.width + marginX;
              minWidthX += hint.minWidth + marginX; // Add spacing

              spacingSumX += spacingX;

              if (separatorWidths.x) {
                spacingSumX += separatorWidths.x + spacingX;
              }

              break;

            default:
              // A centered widget must be added to both sums as
              // it stretches into the remaining available space.
              widthX += hint.width + marginX;
              minWidthX += hint.minWidth + marginX;
              heightY += hint.height + marginY;
              minHeightY += hint.minHeight + marginY; // Add spacing

              spacingSumX += spacingX;

              if (separatorWidths.x) {
                spacingSumX += separatorWidths.x + spacingX;
              }

              spacingSumY += spacingY;

              if (separatorWidths.y) {
                spacingSumY += separatorWidths.y + spacingY;
              }

          }
        }

        var minWidth = Math.max(minWidthX, minWidthY) + spacingSumX;
        var width = Math.max(widthX, widthY) + spacingSumX;
        var minHeight = Math.max(minHeightX, minHeightY) + spacingSumY;
        var height = Math.max(heightX, heightY) + spacingSumY; // Return hint

        return {
          minWidth: minWidth,
          width: width,
          minHeight: minHeight,
          height: height
        };
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__edges__P_434_1 = this.__children__P_434_0 = null;
    }
  });
  qx.ui.layout.Dock.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.LineSizeIterator": {},
      "qx.ui.layout.Util": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
     http://qooxdoo.org
  
     Copyright:
       2008 Dihedrals.com, http://www.dihedrals.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Chris Banford (zermattchris)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A basic layout, which supports positioning of child widgets in a 'flowing'
   * manner, starting at the container's top/left position, placing children left to right
   * (like a HBox) until the there's no remaining room for the next child. When
   * out of room on the current line of elements, a new line is started, cleared
   * below the tallest child of the preceding line -- a bit like using 'float'
   * in CSS, except that a new line wraps all the way back to the left.
   *
   * *Features*
   *
   * <ul>
   * <li> Reversing children order </li>
   * <li> Manual line breaks </li>
   * <li> Horizontal alignment of lines </li>
   * <li> Vertical alignment of individual widgets within a line </li>
   * <li> Margins with horizontal margin collapsing </li>
   * <li> Horizontal and vertical spacing </li>
   * <li> Height for width calculations </li>
   * <li> Auto-sizing </li>
   * </ul>
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>lineBreak</strong> <em>(Boolean)</em>: If set to <code>true</code>
   *   a forced line break will happen after this child widget.
   * </li>
   * <li><strong>stretch</strong> <em>(Boolean)</em>: If set to <code>true</code>
   *   the widget will be stretched to the remaining line width. This requires
   *   lineBreak to be true.
   * </li>
  
   * </ul>
   *
   * *Example*
   *
   * Here is a little example of how to use the Flow layout.
   *
   * <pre class="javascript">
   *  var flowlayout = new qx.ui.layout.Flow();
   *
   *  flowlayout.setAlignX( "center" );  // Align children to the X axis of the container (left|center|right)
   *
   *  var container = new qx.ui.container.Composite(flowlayout);
   *  this.getRoot().add(container, {edge: 0});
   *
   *  var button1 = new qx.ui.form.Button("1. First Button", "flowlayout/test.png");
   *  container.add(button1);
   *
   *  var button2 = new qx.ui.form.Button("2. Second longer Button...", "flowlayout/test.png");
   *  // Have this child create a break in the current Line (next child will always start a new Line)
   *  container.add(button2, {lineBreak: true});
   *
   *  var button3 = new qx.ui.form.Button("3rd really, really, really long Button", "flowlayout/test.png");
   *  button3.setHeight(100);  // tall button
   *  container.add(button3);
   *
   *  var button4 = new qx.ui.form.Button("Number 4", "flowlayout/test.png");
   *  button4.setAlignY("bottom");
   *  container.add(button4);
   *
   *  var button5 = new qx.ui.form.Button("20px Margins around the great big 5th button!");
   *  button5.setHeight(100);  // tall button
   *  button5.setMargin(20);
   *  container.add(button5, {lineBreak: true});    // Line break after this button.
   *
   *  var button6 = new qx.ui.form.Button("Number 6", "flowlayout/test.png");
   *  button6.setAlignY("middle");  // Align this child to the vertical center of this line.
   *  container.add(button6);
   *
   *  var button7 = new qx.ui.form.Button("7th a wide, short button", "flowlayout/test.png");
   *  button7.setMaxHeight(20);  // short button
   *  container.add(button7);
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='https://qooxdoo.org/documentation/#/desktop/layout/flow.md'>
   * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.
   */
  qx.Class.define("qx.ui.layout.Flow", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param spacingX {Integer?0} The spacing between child widgets {@link #spacingX}.
     * @param spacingY {Integer?0} The spacing between the lines {@link #spacingY}.
     * @param alignX {String?"left"} Horizontal alignment of the whole children
     *     block {@link #alignX}.
     */
    construct: function construct(spacingX, spacingY, alignX) {
      qx.ui.layout.Abstract.constructor.call(this);

      if (spacingX) {
        this.setSpacingX(spacingX);
      }

      if (spacingY) {
        this.setSpacingY(spacingY);
      }

      if (alignX) {
        this.setAlignX(alignX);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Horizontal alignment of the whole children block. The horizontal
       * alignment of the child is completely ignored in HBoxes (
       * {@link qx.ui.core.LayoutItem#alignX}).
       */
      alignX: {
        check: ["left", "center", "right"],
        init: "left",
        apply: "_applyLayoutChange"
      },

      /**
       * Vertical alignment of each child. Can be overridden through
       * {@link qx.ui.core.LayoutItem#alignY}.
       */
      alignY: {
        check: ["top", "middle", "bottom"],
        init: "top",
        apply: "_applyLayoutChange"
      },

      /** Horizontal spacing between two children */
      spacingX: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /**
       * The vertical spacing between the lines.
       */
      spacingY: {
        check: "Integer",
        init: 0,
        apply: "_applyLayoutChange"
      },

      /** Whether the actual children list should be laid out in reversed order. */
      reversed: {
        check: "Boolean",
        init: false,
        apply: "_applyLayoutChange"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        var validProperties = ["lineBreak", "stretch"];
        this.assertInArray(name, validProperties, "The property '" + name + "' is not supported by the flow layout!");
      },
      // overridden
      connectToWidget: function connectToWidget(widget) {
        qx.ui.layout.Flow.prototype.connectToWidget.base.call(this, widget); // Necessary to be able to calculate the lines for the flow layout.
        // Otherwise the layout calculates the needed width and height by using
        // only one line of items which is leading to the wrong height. This
        // wrong height does e.g. suppress scrolling since the scroll pane does
        // not know about the correct needed height.

        if (widget) {
          widget.setAllowShrinkY(false);
        }
      },

      /**
       * The FlowLayout tries to add as many Children as possible to the current 'Line'
       * and when it sees that the next Child won't fit, it starts on a new Line, continuing
       * until all the Children have been added.
       * To enable alignX "left", "center", "right" renderLayout has to calculate the positions
       * of all a Line's children before it draws them.
       *
       * @param availWidth {Integer} Final width available for the content (in pixel)
       * @param availHeight {Integer} Final height available for the content (in pixel)
       * @param padding {Map} Map containing the padding values. Keys:
       * <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>
       */
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        var children = this._getLayoutChildren();

        if (this.getReversed()) {
          children = children.concat().reverse();
        }

        var lineCalculator = new qx.ui.layout.LineSizeIterator(children, this.getSpacingX());
        var lineTop = padding.top;

        while (lineCalculator.hasMoreLines()) {
          var line = lineCalculator.computeNextLine(availWidth);

          this.__renderLine__P_435_0(line, lineTop, availWidth, padding);

          lineTop += line.height + this.getSpacingY();
        }
      },

      /**
       * Render a line in the flow layout
       *
       * @param line {Map} A line configuration as returned by
       *    {@link LineSizeIterator#computeNextLine}.
       * @param lineTop {Integer} The line's top position
       * @param availWidth {Integer} The available line width
       * @param padding {Map} Map containing the padding values. Keys:
       * <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>
       */
      __renderLine__P_435_0: function __renderLine__P_435_0(line, lineTop, availWidth, padding) {
        var util = qx.ui.layout.Util;
        var left = padding.left;

        if (this.getAlignX() != "left") {
          left = padding.left + availWidth - line.width;

          if (this.getAlignX() == "center") {
            left = padding.left + Math.round((availWidth - line.width) / 2);
          }
        }

        for (var i = 0; i < line.children.length; i++) {
          var child = line.children[i];
          var size = child.getSizeHint();
          var marginTop = child.getMarginTop();
          var marginBottom = child.getMarginBottom();
          var top = util.computeVerticalAlignOffset(child.getAlignY() || this.getAlignY(), marginTop + size.height + marginBottom, line.height, marginTop, marginBottom);
          var layoutProps = child.getLayoutProperties();

          if (layoutProps.stretch && layoutProps.stretch) {
            size.width += availWidth - line.width;
          }

          child.renderLayout(left + line.gapsBefore[i], lineTop + top, size.width, size.height);
          left += line.gapsBefore[i] + size.width;
        }
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        return this.__computeSize__P_435_1(Infinity);
      },
      // overridden
      hasHeightForWidth: function hasHeightForWidth() {
        return true;
      },
      // overridden
      getHeightForWidth: function getHeightForWidth(width) {
        return this.__computeSize__P_435_1(width).height;
      },

      /**
       * Returns the list of children fitting in the last row of the given width.
       * @param width {Number} The width to use for the calculation.
       * @return {Array} List of children in the first row.
       */
      getLastLineChildren: function getLastLineChildren(width) {
        var lineCalculator = new qx.ui.layout.LineSizeIterator(this._getLayoutChildren(), this.getSpacingX());
        var lineData = [];

        while (lineCalculator.hasMoreLines()) {
          lineData = lineCalculator.computeNextLine(width).children;
        }

        return lineData;
      },

      /**
       * Compute the preferred size optionally constrained by the available width
       *
       * @param availWidth {Integer} The available width
       * @return {Map} Map containing the preferred height and width of the layout
       */
      __computeSize__P_435_1: function __computeSize__P_435_1(availWidth) {
        var lineCalculator = new qx.ui.layout.LineSizeIterator(this._getLayoutChildren(), this.getSpacingX());
        var height = 0;
        var width = 0;
        var lineCount = 0;

        while (lineCalculator.hasMoreLines()) {
          var line = lineCalculator.computeNextLine(availWidth);
          lineCount += 1;
          width = Math.max(width, line.width);
          height += line.height;
        }

        return {
          width: width,
          height: height + this.getSpacingY() * (lineCount - 1)
        };
      }
    }
  });
  qx.ui.layout.Flow.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
     http://qooxdoo.org
  
     Copyright:
       2008 Dihedrals.com, http://www.dihedrals.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Chris Banford (zermattchris)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This class iterates over the lines in a flow layout.
   *
   * @internal
   */
  qx.Class.define("qx.ui.layout.LineSizeIterator", {
    extend: Object,

    /**
     * @param children {qx.ui.core.Widget[]} The children of the flow layout to
     *    compute the lines from
     * @param spacing {Integer} The horizontal spacing between the children
     */
    construct: function construct(children, spacing) {
      this.__children__P_438_0 = children;
      this.__spacing__P_438_1 = spacing;
      this.__hasMoreLines__P_438_2 = children.length > 0;
      this.__childIndex__P_438_3 = 0;
    },
    members: {
      __children__P_438_0: null,
      __spacing__P_438_1: null,
      __hasMoreLines__P_438_2: null,
      __childIndex__P_438_3: null,

      /**
       * Computes the properties of the next line taking the available width into
       * account
       *
       * @param availWidth {Integer} The available width for the next line
       * @return {Map} A map containing the line's properties.
       */
      computeNextLine: function computeNextLine(availWidth) {
        var availWidth = availWidth || Infinity;

        if (!this.__hasMoreLines__P_438_2) {
          throw new Error("No more lines to compute");
        }

        var children = this.__children__P_438_0;
        var lineHeight = 0;
        var lineWidth = 0;
        var lineChildren = [];
        var gapsBefore = [];

        for (var i = this.__childIndex__P_438_3; i < children.length; i++) {
          var child = children[i];
          var size = child.getSizeHint();

          var gapBefore = this.__computeGapBeforeChild__P_438_4(i);

          var childWidth = size.width + gapBefore;
          var isFirstChild = i == this.__childIndex__P_438_3;

          if (!isFirstChild && lineWidth + childWidth > availWidth) {
            this.__childIndex__P_438_3 = i;
            break;
          }

          var childHeight = size.height + child.getMarginTop() + child.getMarginBottom();
          lineChildren.push(child);
          gapsBefore.push(gapBefore);
          lineWidth += childWidth;
          lineHeight = Math.max(lineHeight, childHeight);

          if (child.getLayoutProperties().lineBreak) {
            this.__childIndex__P_438_3 = i + 1;
            break;
          }
        }

        if (i >= children.length) {
          this.__hasMoreLines__P_438_2 = false;
        }

        return {
          height: lineHeight,
          width: lineWidth,
          children: lineChildren,
          gapsBefore: gapsBefore
        };
      },

      /**
       * Computes the gap before the child at the given index
       *
       * @param childIndex {Integer} The index of the child widget
       * @return {Integer} The gap before the given child
       */
      __computeGapBeforeChild__P_438_4: function __computeGapBeforeChild__P_438_4(childIndex) {
        var isFirstInLine = childIndex == this.__childIndex__P_438_3;

        if (isFirstInLine) {
          return this.__children__P_438_0[childIndex].getMarginLeft();
        } else {
          return Math.max(this.__children__P_438_0[childIndex - 1].getMarginRight(), this.__children__P_438_0[childIndex].getMarginLeft(), this.__spacing__P_438_1);
        }
      },

      /**
       * Whether there are more lines
       *
       * @return {Boolean} Whether there are more lines
       */
      hasMoreLines: function hasMoreLines() {
        return this.__hasMoreLines__P_438_2;
      }
    }
  });
  qx.ui.layout.LineSizeIterator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Objects which are used as delegates for the <code>qx.ui.list.List</code> may
   * implement any of the methods described in this interface. The delegate does
   * not need to implement all the methods of this interface. If a method is not
   * implemented the <code>qx.ui.list.List</code> provides a default
   * implementation.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * actually implemented.
   */
  qx.Interface.define("qx.ui.list.core.IListDelegate", {
    members: {
      /**
       * Gives the user the opportunity to set individual styles and properties
       * on the item widget cells created by the controller.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      configureItem: function configureItem(item) {},

      /**
       * Gives the user the opportunity to set individual styles and properties
       * on the group widget cells created by the controller.
       *
       * @param item {qx.ui.core.Widget} Group to modify.
       */
      configureGroupItem: function configureGroupItem(item) {},

      /**
       * Creates an item cell which will be used for rendering. Be sure to
       * implement the {@link #bindItem} function as well to get the needed
       * properties bound.
       *
       * @return {qx.ui.core.Widget} A new created item cell.
       */
      createItem: function createItem() {},

      /**
       * Creates a group cell which will be used for rendering. Be sure to
       * implement the {@link #bindGroupItem} function as well to get the needed
       * properties bound.
       *
       * @return {qx.ui.core.Widget} A new created item cell.
       */
      createGroupItem: function createGroupItem() {},

      /**
       * Sets up the binding for the given item and index.
       *
       * For every property you want to bind, use
       * {@link MWidgetController#bindProperty} like this:
       * <code>
       * controller.bindProperty("path.in.the.model", "label", options, item, id);
       * </code>
       *
       * @param controller {qx.ui.list.core.MWidgetController} The currently used controller.
       * @param item {qx.ui.core.Widget} The created and used item.
       * @param id {Integer} The id for the binding.
       */
      bindItem: function bindItem(controller, item, id) {},

      /**
       * Sets up the binding for the given group item and index.
       *
       * For every property you want to bind, use
       * {@link MWidgetController#bindProperty} like this:
       * <code>
       * controller.bindProperty(null, "value", options, item, id);
       * </code>
       *
       * @param controller {qx.ui.list.core.MWidgetController} The currently used controller.
       * @param item {qx.ui.core.Widget} The created and used group item.
       * @param id {Integer} The id for the binding.
       */
      bindGroupItem: function bindGroupItem(controller, item, id) {},

      /**
       * Gives the user the opportunity to filter the model. The filter
       * method has to return <code>true</code> if the given data should be
       * shown and <code>false</code> if the given data should be ignored.
       *
       * @param data {var} The data to be checked.
       * @return {Boolean} <code>true</code> if the data passes the filter,
       *   <code>false</code> otherwise.
       */
      filter: function filter(data) {},

      /**
       * Gives the user the opportunity to sort the model. The sorting method
       * should return a negative value if a < b, zero if a = b, or a positive
       * value if a > b.
       *
       * @param a {var} value to compare.
       * @param b {var} value to compare.
       * @return {Integer} should return a negative value if a < b, zero
       *   if a = b, or a positive value if a > b.
       */
      sorter: function sorter(a, b) {},

      /**
       * Gives the user the opportunity to group the model. The group method
       * should return unique identifier for the passed data.
       *
       * Note: When you returning <code>null</code> the passed data will added
       * to the default group, which is <code>???</code> from the type
       * <code>String</code>. But keep in mind that you can only use the default
       * group feature when each other group identifier is also a <code>String</code>.
       * Otherwise an exception occurs, because you can't mix <code>Object</code>
       * and <code>String</code> group identifiers.
       *
       * @param data {var} The data to be checked.
       * @return {String|Object|null} The group identifier for the data.
       */
      group: function group(data) {},

      /**
       * Gives the user the opportunity to reset properties or states.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      onPool: function onPool(item) {}
    }
  });
  qx.ui.list.core.IListDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menu.AbstractButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Renders a special checkbox button inside a menu. The button behaves like
   * a normal {@link qx.ui.form.CheckBox} and shows a check icon when
   * checked; normally shows no icon when not checked (depends on the theme).
   */
  qx.Class.define("qx.ui.menu.CheckBox", {
    extend: qx.ui.menu.AbstractButton,
    implement: [qx.ui.form.IBooleanForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Initial label
     * @param menu {qx.ui.menu.Menu} Initial sub menu
     */
    construct: function construct(label, menu) {
      qx.ui.menu.AbstractButton.constructor.call(this); // Initialize with incoming arguments

      if (label != null) {
        // try to translate every time you create a checkbox [BUG #2699]
        if (label.translate) {
          this.setLabel(label.translate());
        } else {
          this.setLabel(label);
        }
      }

      if (menu != null) {
        this.setMenu(menu);
      }

      this.addListener("execute", this._onExecute, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "menu-checkbox"
      },

      /** Whether the button is checked */
      value: {
        check: "Boolean",
        init: false,
        apply: "_applyValue",
        event: "changeValue",
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden (from MExecutable to keep the icon out of the binding)

      /**
       * @lint ignoreReferenceField(_bindableProperties)
       */
      _bindableProperties: ["enabled", "label", "toolTipText", "value", "menu"],
      // property apply
      _applyValue: function _applyValue(value, old) {
        value ? this.addState("checked") : this.removeState("checked");
      },

      /**
       * Handler for the execute event.
       *
       * @param e {qx.event.type.Event} The execute event.
       */
      _onExecute: function _onExecute(e) {
        this.toggleValue();
      }
    }
  });
  qx.ui.menu.CheckBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menu.AbstractButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      },
      "qx.ui.form.IBooleanForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Renders a special radio button inside a menu. The button behaves like
   * a normal {@link qx.ui.form.RadioButton} and shows a radio icon when
   * checked; normally shows no icon when not checked (depends on the theme).
   */
  qx.Class.define("qx.ui.menu.RadioButton", {
    extend: qx.ui.menu.AbstractButton,
    include: [qx.ui.form.MModelProperty],
    implement: [qx.ui.form.IRadioItem, qx.ui.form.IBooleanForm, qx.ui.form.IModel],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Initial label
     * @param menu {qx.ui.menu.Menu} Initial sub menu
     */
    construct: function construct(label, menu) {
      qx.ui.menu.AbstractButton.constructor.call(this); // Initialize with incoming arguments

      if (label != null) {
        this.setLabel(label);
      }

      if (menu != null) {
        this.setMenu(menu);
      }

      this.addListener("execute", this._onExecute, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "menu-radiobutton"
      },

      /** The value of the widget. True, if the widget is checked. */
      value: {
        check: "Boolean",
        nullable: true,
        event: "changeValue",
        apply: "_applyValue",
        init: false
      },

      /** The assigned qx.ui.form.RadioGroup which handles the switching between registered buttons */
      group: {
        check: "qx.ui.form.RadioGroup",
        nullable: true,
        apply: "_applyGroup"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden (from MExecutable to keep the icon out of the binding)

      /**
       * @lint ignoreReferenceField(_bindableProperties)
       */
      _bindableProperties: ["enabled", "label", "toolTipText", "value", "menu"],
      // property apply
      _applyValue: function _applyValue(value, old) {
        value ? this.addState("checked") : this.removeState("checked");
      },
      // property apply
      _applyGroup: function _applyGroup(value, old) {
        if (old) {
          old.remove(this);
        }

        if (value) {
          value.add(this);
        }
      },

      /**
       * Handler for the execute event.
       *
       * @param e {qx.event.type.Event} The execute event.
       */
      _onExecute: function _onExecute(e) {
        var grp = this.getGroup();

        if (grp && grp.getAllowEmptySelection()) {
          this.toggleValue();
        } else {
          this.setValue(true);
        }
      }
    }
  });
  qx.ui.menu.RadioButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.toolbar.ToolBar": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Container for menubar buttons to display a classic application menu.
   */
  qx.Class.define("qx.ui.menubar.MenuBar", {
    extend: qx.ui.toolbar.ToolBar,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Appearance of the widget */
      appearance: {
        refine: true,
        init: "menubar"
      }
    }
  });
  qx.ui.menubar.MenuBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.basic.Image": {},
      "qx.bom.element.Style": {},
      "qx.ui.mobile.basic.Label": {},
      "qx.ui.mobile.container.Composite": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * A multi-purpose widget, which combines a label with an icon.
   *
   * The intended purpose of qx.ui.mobile.basic.Atom is to easily align the common icon-text
   * combination in different ways.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var atom = new qx.ui.mobile.basic.Atom("Icon Right", "icon/32/actions/go-next.png");
   *   this.getRoot().add(atom);
   * </pre>
   *
   * This example creates an atom with the label "Icon Right" and an icon.
   */
  qx.Class.define("qx.ui.mobile.basic.Atom", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Label to use
     * @param icon {String?null} Icon to use
     */
    construct: function construct(label, icon) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      this.__createChildren__P_447_0(label, icon);

      this.addCssClass("gap");
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "atom"
      },

      /** The label/caption/text of the qx.ui.mobile.basic.Atom instance */
      label: {
        apply: "_applyLabel",
        nullable: true,
        check: "String",
        event: "changeLabel"
      },

      /** Any URI String supported by qx.ui.mobile.basic.Image to display an icon */
      icon: {
        check: "String",
        apply: "_applyIcon",
        nullable: true,
        event: "changeIcon"
      },

      /**
       * Configure the visibility of the sub elements/widgets.
       * Possible values: both, text, icon
       */
      show: {
        init: "both",
        check: ["both", "label", "icon"],
        inheritable: true,
        apply: "_applyShow"
      },

      /**
       * The position of the icon in relation to the text.
       * Only useful/needed if text and icon is configured and 'show' is configured as 'both' (default)
       */
      iconPosition: {
        init: "left",
        check: ["top", "right", "bottom", "left"],
        apply: "_applyIconPosition"
      }
    },
    members: {
      __layout__P_447_1: null,
      __label__P_447_2: null,
      __icon__P_447_3: null,
      __childrenContainer__P_447_4: null,
      // property apply
      _applyIconPosition: function _applyIconPosition(value, old) {
        var verticalLayout = ["top", "bottom"].indexOf(value) != -1;
        var hasNoLabel = !this.__label__P_447_2;

        this.__createLayout__P_447_5(verticalLayout, hasNoLabel);

        var isReverse = ["right", "bottom"].indexOf(value) != -1;

        this.__childrenContainer__P_447_4.setLayout(this.__layout__P_447_1);

        this.__layout__P_447_1.setReversed(isReverse);

        this._domUpdated();
      },
      // property apply
      _applyShow: function _applyShow(value, old) {
        if (this.__label__P_447_2) {
          if (value === 'both' || value === 'label') {
            this.__label__P_447_2.show();
          } else if (value === 'icon') {
            this.__label__P_447_2.exclude();
          }
        }

        if (this.__icon__P_447_3) {
          if (value === 'both' || value === 'icon') {
            this.__icon__P_447_3.show();
          } else if (value === 'label') {
            this.__icon__P_447_3.exclude();
          }
        }
      },
      // property apply
      _applyLabel: function _applyLabel(value, old) {
        if (this.__label__P_447_2) {
          this.__label__P_447_2.setValue(value);
        } else {
          this.__label__P_447_2 = this._createLabelWidget(value);
        }
      },
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        if (this.__icon__P_447_3) {
          this.__icon__P_447_3.setSource(value);
        } else {
          this.__icon__P_447_3 = this._createIconWidget(value);
        }
      },

      /**
       * Takes care of lazily creating the layout and disposing an already
       * present layout if necessary.
       *
       * @param verticalLayout {Boolean} Whether icon and label should be vertically aligned.
       * @param hasNoLabel {Boolean} Whether the atom currently contains a label.
       */
      __createLayout__P_447_5: function __createLayout__P_447_5(verticalLayout, hasNoLabel) {
        if (verticalLayout || hasNoLabel) {
          if (this.__layout__P_447_1) {
            if (this.__layout__P_447_1.classname !== "qx.ui.mobile.layout.VBox") {
              this.__layout__P_447_1.dispose();

              this.__layout__P_447_1 = new qx.ui.mobile.layout.VBox();
            }
          } // layout == null
          else {
              this.__layout__P_447_1 = new qx.ui.mobile.layout.VBox();
            }
        } // horizontal layout and has label
        else {
            if (this.__layout__P_447_1) {
              if (this.__layout__P_447_1.classname !== "qx.ui.mobile.layout.HBox") {
                this.__layout__P_447_1.dispose();

                this.__layout__P_447_1 = new qx.ui.mobile.layout.HBox();
              }
            } // layout == null
            else {
                this.__layout__P_447_1 = new qx.ui.mobile.layout.HBox();
              }
          }
      },

      /**
       * Returns the icon widget.
       *
       * @return {qx.ui.mobile.basic.Image} The icon widget.
       */
      getIconWidget: function getIconWidget() {
        return this.__icon__P_447_3;
      },

      /**
       * Returns the label widget.
       *
       * @return {qx.ui.mobile.basic.Label} The label widget.
       */
      getLabelWidget: function getLabelWidget() {
        return this.__label__P_447_2;
      },

      /**
       * Creates the icon widget.
       *
       * @param iconUrl {String} The icon url.
       * @return {qx.ui.mobile.basic.Image} The created icon widget.
       */
      _createIconWidget: function _createIconWidget(iconUrl) {
        var iconWidget = new qx.ui.mobile.basic.Image(iconUrl);
        qx.bom.element.Style.set(iconWidget.getContentElement(), "display", "block");
        iconWidget.setAnonymous(true);
        iconWidget.addCssClass("gap");
        return iconWidget;
      },

      /**
       * Creates the label widget.
       *
       * @param label {String} The text that should be displayed.
       * @return {qx.ui.mobile.basic.Label} The created label widget.
       */
      _createLabelWidget: function _createLabelWidget(label) {
        var labelWidget = new qx.ui.mobile.basic.Label(label);
        labelWidget.setAnonymous(true);
        labelWidget.setWrap(false);
        labelWidget.addCssClass("gap");
        return labelWidget;
      },

      /**
       * This function is responsible for creating and adding 2 children controls to the Button widget.
       * A label and an icon.
       * @param label {String} the text of the button
       * @param icon {String} A path to an image resource
       *
       */
      __createChildren__P_447_0: function __createChildren__P_447_0(label, icon) {
        this.__label__P_447_2 = this._createLabelWidget(label);

        if (label) {
          this.setLabel(label);
        }

        this.__icon__P_447_3 = this._createIconWidget(icon);

        if (icon) {
          this.setIcon(icon);
        } else {
          this.__icon__P_447_3.exclude();
        }

        var verticalLayout = ["top", "bottom"].indexOf(this.getIconPosition()) != -1; // If Atom has no Label, only Icon is shown, and should vertically centered.

        var hasNoLabel = !this.__label__P_447_2;

        this.__createLayout__P_447_5(verticalLayout, hasNoLabel);

        if (this.__childrenContainer__P_447_4) {
          this.__childrenContainer__P_447_4.dispose();
        }

        this.__childrenContainer__P_447_4 = new qx.ui.mobile.container.Composite(this.__layout__P_447_1);

        this.__childrenContainer__P_447_4.addCssClass("qx-flex-center");

        this.__childrenContainer__P_447_4.setAnonymous(true);

        if (this.__icon__P_447_3) {
          this.__childrenContainer__P_447_4.add(this.__icon__P_447_3);
        }

        if (this.__label__P_447_2) {
          this.__label__P_447_2.addCssClass("qx-flex-center");

          this.__childrenContainer__P_447_4.add(this.__label__P_447_2);
        } // Show/Hide Label/Icon


        if (this.getShow() === 'icon' && this.__label__P_447_2) {
          this.__label__P_447_2.exclude();
        }

        if (this.getShow() === 'label' && this.__icon__P_447_3) {
          this.__icon__P_447_3.exclude();
        }

        this._add(this.__childrenContainer__P_447_4);
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__layout__P_447_1", "__label__P_447_2", "__icon__P_447_3", "__childrenContainer__P_447_4");
    }
  });
  qx.ui.mobile.basic.Atom.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.layout.AbstractBox": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A horizontal box layout.
   *
   * The horizontal box layout lays out widgets in a horizontal row, from left
   * to right.
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>flex</strong> <em>(Integer)</em>: The flex property determines how the container
   *   distributes remaining empty space among its children. If items are made
   *   flexible, they can grow or shrink accordingly. Their relative flex values
   *   determine how the items are being resized, i.e. the larger the flex ratio
   *   of two items, the larger the resizing of the first item compared to the
   *   second.
   * </li>
   * </ul>
   *
   * *Example*
   *
   * Here is a little example of how to use the HBox layout.
   *
   * <pre class="javascript">
   * var layout = new qx.ui.mobile.layout.HBox().set({alignX:"center"});
   *
   * var container = new qx.ui.mobile.container.Composite(layout);
   *
   * container.add(new qx.ui.mobile.basic.Label("1"));
   * container.add(new qx.ui.mobile.basic.Label("2"), {flex:1});
   * container.add(new qx.ui.mobile.basic.Label("3"));
   * </pre>
   */
  qx.Class.define("qx.ui.mobile.layout.HBox", {
    extend: qx.ui.mobile.layout.AbstractBox,

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      // overridden
      _getCssClasses: function _getCssClasses() {
        return ["qx-hbox"];
      }
    }
  });
  qx.ui.mobile.layout.HBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.util.ResourceManager": {},
      "qx.io.ImageLoader": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The image widget displays an image file.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var image = new qx.ui.mobile.basic.Image("path/to/icon.png");
   *
   *   this.getRoot().add(image);
   * </pre>
   *
   * This example create a widget to display the image
   * <code>path/to/icon.png</code>.
   *
   */
  qx.Class.define("qx.ui.mobile.basic.Image", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param source {String?null} The URL of the image to display.
     */
    construct: function construct(source) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (qx.ui.mobile.basic.Image.ROOT === null) {
        qx.ui.mobile.basic.Image.ROOT = qx.core.Init.getApplication().getRoot();
      }

      if (source) {
        this.setSource(source);
      } else {
        this.initSource();
      }

      qx.ui.mobile.basic.Image.ROOT.addListener("changeAppScale", this._onChangeAppScale, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired if the image source can not be loaded.
       */
      loadingFailed: "qx.event.type.Event",

      /**
       * Fired if the image has been loaded.
       */
      loaded: "qx.event.type.Event"
    },
    statics: {
      /** @type {qx.ui.mobile.core.Root} the mobile application root */
      ROOT: null,

      /** @type {String} a 1px*1px sized transparent image. */
      PLACEHOLDER_IMAGE: null
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The URL of the image to display.
       */
      source: {
        check: "String",
        nullable: true,
        init: null,
        apply: "_applySource"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "img";
      },
      // property apply
      _applySource: function _applySource(value, old) {
        var resourceManager = qx.util.ResourceManager.getInstance();
        var source = value;

        if (source && source.indexOf('data:') != 0) {
          var uri = resourceManager.toUri(source);

          if (resourceManager.has(source)) {
            var highResSource = resourceManager.findHighResolutionSource(source, qx.ui.mobile.basic.Image.ROOT.getAppScale());

            if (highResSource) {
              this._createHighResolutionOverlay(highResSource, source);

              source = qx.ui.mobile.basic.Image.PLACEHOLDER_IMAGE;
              uri = resourceManager.toUri(highResSource);
            } else {
              source = uri;
            }
          }

          if (!qx.io.ImageLoader.isFailed(uri) && !qx.io.ImageLoader.isLoaded(uri)) {
            qx.io.ImageLoader.load(uri, this.__loaderCallback__P_448_0, this);
          }
        }

        this._setSource(source);
      },

      /**
      * Event handler for "changeAppScale" on application root.
      * Reloads the image source.
      */
      _onChangeAppScale: function _onChangeAppScale() {
        this._applySource(this.getSource());
      },

      /**
      * Creates an overlay for this image which shows the image defined by the parameter 'highResSource',
      * but has the same size and position as the source image.
      * The original image widget is hidden by this method.
      *
      * @param highResSource {String} Image source of the high-resolution image.
      * @param lowResSource {String} Image source of the low-resolution image.
      */
      _createHighResolutionOverlay: function _createHighResolutionOverlay(highResSource, lowResSource) {
        // Replace the source through transparent pixel for making the high-resolution background image visible.
        var resourceManager = qx.util.ResourceManager.getInstance();

        this._setStyle("backgroundImage", "url(" + resourceManager.toUri(highResSource) + ")");

        this._setStyle("backgroundSize", "100%");

        this._setStyle("backgroundRepeat", "no-repeat");

        this._setStyle("backgroundPosition", "50% 50%");

        this._setStyle("width", resourceManager.getImageWidth(lowResSource) / 16 + "rem");

        this._setStyle("height", resourceManager.getImageHeight(lowResSource) / 16 + "rem");
      },

      /**
       * Event handler fired after the preloader has finished loading the icon
       *
       * @param source {String} Image source which was loaded
       * @param imageInfo {Map} Dimensions of the loaded image
       */
      __loaderCallback__P_448_0: function __loaderCallback__P_448_0(source, imageInfo) {
        // Ignore the callback on already disposed images
        if (this.$$disposed === true) {
          return;
        } // Output a warning if the image could not loaded and quit


        if (imageInfo.failed) {
          this.warn("Image could not be loaded: " + source);
          this.fireEvent("loadingFailed");
        } else if (imageInfo.aborted) {
          // ignore the rest because it is aborted
          return;
        } else {
          this.fireEvent("loaded");
        }

        this._domUpdated();
      },

      /**
       * Sets the source attribute of the image tag.
       *
       * @param source {String} Image source which was loaded
       */
      _setSource: function _setSource(source) {
        this._setAttribute("src", source);
      },

      /**
       * Sets the attribute draggable to the given value "isDraggable".
       * @param isDraggable {Boolean} target value.
       */
      setDraggable: function setDraggable(isDraggable) {
        if (isDraggable) {
          this._setAttribute("draggable", "true");
        } else {
          this._setAttribute("draggable", "false");
        }
      }
    },
    defer: function defer(statics) {
      statics.PLACEHOLDER_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    },
    destruct: function destruct() {
      qx.ui.mobile.basic.Image.ROOT.removeListener("changeAppScale", this._onChangeAppScale, this);
    }
  });
  qx.ui.mobile.basic.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.locale.Manager": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The label widget displays a text or HTML content.
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var label = new qx.ui.mobile.basic.Label("Hello World");
   *
   *   this.getRoot().add(label);
   * </pre>
   *
   * This example create a widget to display the label.
   *
   */
  qx.Class.define("qx.ui.mobile.basic.Label", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {String?null} Text or HTML content to display
     */
    construct: function construct(value) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (value) {
        this.setValue(value);
      }

      this.initWrap();
      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "label"
      },

      /**
       * Text or HTML content to display
       */
      value: {
        nullable: true,
        init: null,
        check: "String",
        apply: "_applyValue",
        event: "changeValue"
      },
      // overridden
      anonymous: {
        refine: true,
        init: true
      },

      /**
       * Controls whether text wrap is activated or not.
       */
      wrap: {
        check: "Boolean",
        init: true,
        apply: "_applyWrap"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // property apply
      _applyValue: function _applyValue(value, old) {
        this._setHtml(value);
      },
      // property apply
      _applyWrap: function _applyWrap(value, old) {
        if (value) {
          this.removeCssClass("no-wrap");
        } else {
          this.addCssClass("no-wrap");
        }
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale: function _onChangeLocale(e) {
        var content = this.getValue();

        if (content && content.translate) {
          this.setValue(content.translate());
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
    }
  });
  qx.ui.mobile.basic.Label.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.element.Style": {},
      "qx.bom.client.Scroll": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * This mixin resizes the container element to the height of the parent element.
   * Use this when the height can not be set by CSS.
   *
   */
  qx.Mixin.define("qx.ui.mobile.core.MResize", {
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Whether the resize should fire the "domupdated" event. Set this to "true"
       *  whenever other elements should react on this size change (e.g. when the size
       *  change does not infect the size of the application, but other widgets should
       *  react).
       */
      fireDomUpdatedOnResize: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __lastHeight__P_456_0: null,
      __lastWidth__P_456_1: null,

      /**
       * Removes fixed size from container.
       */
      releaseFixedSize: function releaseFixedSize() {
        var parent = this.getLayoutParent();

        if (parent && parent.getContainerElement()) {
          var element = this.getContainerElement();
          qx.bom.element.Style.set(element, "height", "auto");
          qx.bom.element.Style.set(element, "width", "auto");
        }
      },

      /**
       * Resizes the container element to the height of the parent element.
       */
      fixSize: function fixSize() {
        var parent = this.getLayoutParent();

        if (parent && parent.getContainerElement()) {
          var height = parent.getContainerElement().offsetHeight;
          var width = parent.getContainerElement().offsetWidth; // Only fix size, when value are above zero.

          if (height === 0 || width === 0) {
            return;
          }

          if (!this.getFireDomUpdatedOnResize()) {
            this._setHeight(height);

            this._setWidth(width);
          } else if (this.__lastHeight__P_456_0 != height && this.__lastWidth__P_456_1 != width) {
            this._setHeight(height);

            this._setWidth(width);

            this.__lastWidth__P_456_1 = width;
            this.__lastHeight__P_456_0 = height;

            this._domUpdated();
          }
        }
      },

      /**
       * Sets the height of the container element.
       *
       * @param height {Integer} The height to set
       */
      _setHeight: function _setHeight(height) {
        var element = this.getContainerElement();

        if (qx.core.Environment.get("qx.mobile.nativescroll")) {
          qx.bom.element.Style.set(element, "minHeight", height + "px");
        } else {
          qx.bom.element.Style.set(element, "height", height + "px");
        }
      },

      /**
       * Sets the width of the container element.
       *
       * @param width {Integer} The width to set
       */
      _setWidth: function _setWidth(width) {
        var element = this.getContainerElement();

        if (qx.core.Environment.get("qx.mobile.nativescroll")) {
          qx.bom.element.Style.set(element, "minWidth", width + "px");
        } else {
          qx.bom.element.Style.set(element, "width", width + "px");
        }
      }
    }
  });
  qx.ui.mobile.core.MResize.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.core.MResize": {
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.bom.Event": {
        "construct": true
      },
      "qx.event.Registration": {
        "construct": true
      },
      "qx.ui.mobile.layout.VBox": {
        "construct": true
      },
      "qx.util.DisposeUtil": {},
      "qx.bom.element.Style": {},
      "qx.ui.mobile.basic.Label": {},
      "qx.bom.element.Dimension": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Creates a Carousel widget.
   * A carousel is a widget which can switch between several sub pages {@link  qx.ui.mobile.container.Composite}.
   * A page switch is triggered by a swipe to left, for next page, or a swipe to right for
   * previous page.
   *
   * A carousel shows by default a pagination indicator at the bottom of the carousel.
   * This pagination indicator can be hidden by property <code>showPagination</code>.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *
   *  var carousel = new qx.ui.mobile.container.Carousel();
   *  var carouselPage1 = new qx.ui.mobile.container.Composite();
   *  var carouselPage2 = new qx.ui.mobile.container.Composite();
   *
   *  carouselPage1.add(new qx.ui.mobile.basic.Label("This is a carousel. Please swipe left."));
   *  carouselPage2.add(new qx.ui.mobile.basic.Label("Now swipe right."));
   *
   *  carousel.add(carouselPage1);
   *  carousel.add(carouselPage2);
   * </pre>
   *
   */
  qx.Class.define("qx.ui.mobile.container.Carousel", {
    extend: qx.ui.mobile.container.Composite,
    include: qx.ui.mobile.core.MResize,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
    * @param transitionDuration {Integer ? 0.4} transition duration on carouselPage change in seconds.
    */
    construct: function construct(transitionDuration) {
      qx.ui.mobile.container.Composite.constructor.call(this);

      if (transitionDuration) {
        this.setTransitionDuration(transitionDuration);
      }

      this.__snapPointsX__P_449_0 = [];
      this.__onMoveOffset__P_449_1 = [0, 0];
      this.__lastOffset__P_449_2 = [0, 0];
      this.__boundsX__P_449_3 = [0, 0];
      this.__pages__P_449_4 = [];
      this.__paginationLabels__P_449_5 = [];
      var carouselScroller = this.__carouselScroller__P_449_6 = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox());
      carouselScroller.setTransformUnit("px");
      carouselScroller.addCssClass("carousel-scroller");
      carouselScroller.addListener("pointerdown", this._onPointerDown, this);
      carouselScroller.addListener("pointerup", this._onPointerUp, this);
      carouselScroller.addListener("track", this._onTrack, this);
      carouselScroller.addListener("swipe", this._onSwipe, this);
      this.addListener("touchmove", qx.bom.Event.preventDefault, this);
      this.addListener("appear", this._onContainerUpdate, this);
      qx.event.Registration.addListener(this.__carouselScroller__P_449_6.getContainerElement(), "transitionEnd", this._onScrollerTransitionEnd, this);
      qx.event.Registration.addListener(window, "orientationchange", this._onContainerUpdate, this);
      qx.event.Registration.addListener(window, "resize", this._onContainerUpdate, this);
      qx.event.Registration.addListener(this.getContentElement(), "scroll", this._onNativeScroll, this);
      var pagination = this.__pagination__P_449_7 = new qx.ui.mobile.container.Composite();
      pagination.setLayout(new qx.ui.mobile.layout.HBox());
      pagination.setTransformUnit("px");
      pagination.addCssClass("carousel-pagination");
      this.setLayout(new qx.ui.mobile.layout.VBox());

      this._add(carouselScroller, {
        flex: 1
      });

      this._add(pagination, {
        flex: 1
      });
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "carousel"
      },

      /** Property for setting visibility of pagination indicator */
      showPagination: {
        check: "Boolean",
        init: true,
        apply: "_applyShowPagination"
      },

      /** Defines whether the carousel should scroll back to first or last page
       * when the start/end of carousel pages is reached  */
      scrollLoop: {
        check: "Boolean",
        init: true
      },

      /**
       * Defines the height of the carousel. If value is equal to <code>null</code>
       * the height is set to <code>100%</code>.
       */
      height: {
        check: "Number",
        init: 200,
        nullable: true,
        apply: "_updateCarouselLayout"
      },

      /**
       * The current visible page index.
       */
      currentIndex: {
        check: "Number",
        init: 0,
        apply: "_scrollToPage",
        event: "changeCurrentIndex"
      },

      /**
       * Duration of the carousel page transition.
       */
      transitionDuration: {
        check: "Number",
        init: 0.5
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __carouselScroller__P_449_6: null,
      __carouselScrollerWidth__P_449_8: null,
      __carouselWidth__P_449_9: null,
      __paginationLabels__P_449_5: null,
      __pagination__P_449_7: null,
      __snapPointsX__P_449_0: null,
      __onMoveOffset__P_449_1: null,
      __lastOffset__P_449_2: null,
      __boundsX__P_449_3: null,
      __pages__P_449_4: null,
      __showTransition__P_449_10: null,
      __isPageScrollTarget__P_449_11: null,
      __deltaX__P_449_12: null,
      __deltaY__P_449_13: null,
      // overridden

      /**
       * Adds a page to the end of the carousel.
       * @param page {qx.ui.mobile.container.Composite} The composite which should be added as a page to the end of carousel.
       */
      add: function add(page) {
        {
          if (!page instanceof qx.ui.mobile.container.Composite) {
            throw new Error("Page is expected to be an instance of qx.ui.mobile.container.Composite.");
          }
        }
        page.addCssClass("carousel-page");

        this.__pages__P_449_4.push(page);

        this.__carouselScroller__P_449_6.add(page, {
          flex: 1
        });

        var paginationLabel = this._createPaginationLabel();

        this.__paginationLabels__P_449_5.push(paginationLabel);

        this.__pagination__P_449_7.add(paginationLabel);

        this._setTransitionDuration(0);

        this._onContainerUpdate();
      },

      /**
       * Removes a carousel page from carousel identified by its index.
       * @param pageIndex {Integer} The page index which should be removed from carousel.
       * @return {qx.ui.mobile.container.Composite} the page which was removed from carousel.
       */
      removePageByIndex: function removePageByIndex(pageIndex) {
        if (this.__pages__P_449_4 && this.__pages__P_449_4.length > pageIndex) {
          if (pageIndex <= this.getCurrentIndex() && this.getCurrentIndex() !== 0) {
            this.setCurrentIndex(this.getCurrentIndex() - 1);
          }

          var targetPage = this.__pages__P_449_4[pageIndex];
          var paginationLabel = this.__paginationLabels__P_449_5[pageIndex];

          this.__carouselScroller__P_449_6.remove(targetPage);

          this.__pagination__P_449_7.remove(paginationLabel);

          paginationLabel.removeListener("tap", this._onPaginationLabelTap, {
            self: this,
            targetIndex: pageIndex - 1
          });
          qx.util.DisposeUtil.destroyContainer(paginationLabel);

          this.__pages__P_449_4.splice(pageIndex, 1);

          this.__paginationLabels__P_449_5.splice(pageIndex, 1);

          this._onContainerUpdate();

          return targetPage;
        }
      },
      // overridden
      removeAll: function removeAll() {
        var removedPages = [];

        if (this.__pages__P_449_4) {
          for (var i = this.__pages__P_449_4.length - 1; i >= 0; i--) {
            removedPages.push(this.removePageByIndex(i));
          }
        }

        return removedPages;
      },

      /**
       * Scrolls the carousel to next page.
       */
      nextPage: function nextPage() {
        if (this.getCurrentIndex() == this.__pages__P_449_4.length - 1) {
          if (this.isScrollLoop() && this.__pages__P_449_4.length > 1) {
            this._doScrollLoop();
          }
        } else {
          this.setCurrentIndex(this.getCurrentIndex() + 1);
        }
      },

      /**
       * Scrolls the carousel to previous page.
       */
      previousPage: function previousPage() {
        if (this.getCurrentIndex() === 0) {
          if (this.isScrollLoop() && this.__pages__P_449_4.length > 1) {
            this._doScrollLoop();
          }
        } else {
          this.setCurrentIndex(this.getCurrentIndex() - 1);
        }
      },

      /**
      * Returns the current page count of this carousel.
      * @return {Integer} the current page count
      */
      getPageCount: function getPageCount() {
        if (this.__pages__P_449_4) {
          return this.__pages__P_449_4.length;
        }

        return 0;
      },

      /**
       * Scrolls the carousel to the page with the given pageIndex.
       * @param pageIndex {Integer} the target page index, which should be visible
       * @param showTransition {Boolean ? true} flag if a transition should be shown or not
       */
      _scrollToPage: function _scrollToPage(pageIndex, showTransition) {
        if (pageIndex >= this.__pages__P_449_4.length || pageIndex < 0) {
          return;
        }

        this._updatePagination(pageIndex);

        var snapPoint = -pageIndex * this.__carouselWidth__P_449_9;

        this._updateScrollerPosition(snapPoint); // Update lastOffset, because snapPoint has changed.


        this.__lastOffset__P_449_2[0] = snapPoint;
      },

      /**
       * Manages the the scroll loop. First fades out carousel scroller >>
       * waits till fading is done >> scrolls to pageIndex >> waits till scrolling is done
       * >> fades scroller in.
       */
      _doScrollLoop: function _doScrollLoop() {
        this._setTransitionDuration(this.getTransitionDuration());

        setTimeout(function () {
          this._setScrollersOpacity(0);
        }.bind(this), 0);
      },

      /**
      * Event handler for <code>transitionEnd</code> event on carouselScroller.
      */
      _onScrollerTransitionEnd: function _onScrollerTransitionEnd() {
        var opacity = qx.bom.element.Style.get(this.__carouselScroller__P_449_6.getContainerElement(), "opacity");

        if (opacity === 0) {
          var pageIndex = null;

          if (this.getCurrentIndex() == this.__pages__P_449_4.length - 1) {
            pageIndex = 0;
          }

          if (this.getCurrentIndex() === 0) {
            pageIndex = this.__pages__P_449_4.length - 1;
          }

          this._setTransitionDuration(0);

          this.setCurrentIndex(pageIndex);
          setTimeout(function () {
            this._setTransitionDuration(this.getTransitionDuration());

            this._setScrollersOpacity(1);
          }.bind(this), 0);
        }
      },

      /**
       * Factory method for a paginationLabel.
       * @return {qx.ui.mobile.container.Composite} the created pagination label.
       */
      _createPaginationLabel: function _createPaginationLabel() {
        var paginationIndex = this.__pages__P_449_4.length;
        var paginationLabel = new qx.ui.mobile.container.Composite();
        var paginationLabelText = new qx.ui.mobile.basic.Label("" + paginationIndex);
        paginationLabel.add(paginationLabelText);
        paginationLabel.addCssClass("carousel-pagination-label");
        paginationLabel.addListener("tap", this._onPaginationLabelTap, {
          self: this,
          targetIndex: paginationIndex - 1
        });
        return paginationLabel;
      },

      /**
       * Changes the opacity of the carouselScroller element.
       * @param opacity {Integer} the target value of the opacity.
       */
      _setScrollersOpacity: function _setScrollersOpacity(opacity) {
        if (this.__carouselScroller__P_449_6) {
          qx.bom.element.Style.set(this.__carouselScroller__P_449_6.getContainerElement(), "opacity", opacity);
        }
      },

      /**
       * Called when showPagination property is changed.
       * Manages <code>show()</code> and <code>hide()</code> of pagination container.
       */
      _applyShowPagination: function _applyShowPagination(value, old) {
        if (value) {
          if (this.__pages__P_449_4.length > 1) {
            this.__pagination__P_449_7.show();
          }
        } else {
          this.__pagination__P_449_7.hide();
        }
      },

      /**
       * Handles a tap on paginationLabel.
       */
      _onPaginationLabelTap: function _onPaginationLabelTap() {
        this.self.setCurrentIndex(this.targetIndex);
      },

      /**
       * Updates the layout of the carousel the carousel scroller and its pages.
       */
      _updateCarouselLayout: function _updateCarouselLayout() {
        if (!this.getContainerElement()) {
          return;
        }

        var carouselSize = qx.bom.element.Dimension.getSize(this.getContainerElement());
        this.__carouselWidth__P_449_9 = carouselSize.width;

        if (this.getHeight() !== null) {
          this._setStyle("height", this.getHeight() / 16 + "rem");
        } else {
          this._setStyle("height", "100%");
        }

        qx.bom.element.Style.set(this.__carouselScroller__P_449_6.getContentElement(), "width", this.__pages__P_449_4.length * carouselSize.width + "px");

        for (var i = 0; i < this.__pages__P_449_4.length; i++) {
          var pageContentElement = this.__pages__P_449_4[i].getContentElement();

          qx.bom.element.Style.set(pageContentElement, "width", carouselSize.width + "px");
          qx.bom.element.Style.set(pageContentElement, "height", carouselSize.height + "px");
        }

        if (this.__pages__P_449_4.length == 1) {
          this.__pagination__P_449_7.exclude();
        } else {
          if (this.isShowPagination()) {
            this.__pagination__P_449_7.show();
          }
        }

        this._refreshScrollerPosition();
      },

      /**
       * Synchronizes the positions of the scroller to the current shown page index.
       */
      _refreshScrollerPosition: function _refreshScrollerPosition() {
        this.__carouselScrollerWidth__P_449_8 = qx.bom.element.Dimension.getWidth(this.__carouselScroller__P_449_6.getContentElement());

        this._scrollToPage(this.getCurrentIndex());
      },

      /**
       * Handles window resize, device orientatonChange or page appear events.
       */
      _onContainerUpdate: function _onContainerUpdate() {
        this._setTransitionDuration(0);

        this._updateCarouselLayout();

        this._refreshScrollerPosition();
      },

      /**
       * Returns the current horizontal position of the carousel scrolling container.
       * @return {Number} the horizontal position
       */
      _getScrollerOffset: function _getScrollerOffset() {
        var transformMatrix = qx.bom.element.Style.get(this.__carouselScroller__P_449_6.getContentElement(), "transform");
        var transformValueArray = transformMatrix.substr(7, transformMatrix.length - 8).split(', ');
        var i = 4; // Check if MSCSSMatrix is used.

        if ('MSCSSMatrix' in window && !('WebKitCSSMatrix' in window)) {
          i = transformValueArray.length - 4;
        }

        return Math.floor(parseInt(transformValueArray[i], 10));
      },

      /**
       * Event handler for <code>pointerdown</code> events.
       * @param evt {qx.event.type.Pointer} The pointer event.
       */
      _onPointerDown: function _onPointerDown(evt) {
        if (!evt.isPrimary()) {
          return;
        }

        this.__lastOffset__P_449_2[0] = this._getScrollerOffset();
        this.__isPageScrollTarget__P_449_11 = null;
        this.__boundsX__P_449_3[0] = -this.__carouselScrollerWidth__P_449_8 + this.__carouselWidth__P_449_9;

        this._updateScrollerPosition(this.__lastOffset__P_449_2[0]);
      },

      /**
       * Event handler for <code>track</code> events.
       * @param evt {qx.event.type.Track} The track event.
       */
      _onTrack: function _onTrack(evt) {
        if (!evt.isPrimary()) {
          return;
        }

        this._setTransitionDuration(0);

        this.__deltaX__P_449_12 = evt.getDelta().x;
        this.__deltaY__P_449_13 = evt.getDelta().y;

        if (this.__isPageScrollTarget__P_449_11 === null) {
          this.__isPageScrollTarget__P_449_11 = evt.getDelta().axis == "y";
        }

        if (!this.__isPageScrollTarget__P_449_11) {
          this.__onMoveOffset__P_449_1[0] = Math.floor(this.__deltaX__P_449_12 + this.__lastOffset__P_449_2[0]);

          if (this.__onMoveOffset__P_449_1[0] >= this.__boundsX__P_449_3[1]) {
            this.__onMoveOffset__P_449_1[0] = this.__boundsX__P_449_3[1];
          }

          if (this.__onMoveOffset__P_449_1[0] <= this.__boundsX__P_449_3[0]) {
            this.__onMoveOffset__P_449_1[0] = this.__boundsX__P_449_3[0];
          }

          this._updateScrollerPosition(this.__onMoveOffset__P_449_1[0]);

          evt.preventDefault();
        }
      },

      /**
      * Handler for <code>pointerup</code> event on carousel scroller.
      * @param evt {qx.event.type.Pointer} the pointerup event.
      */
      _onPointerUp: function _onPointerUp(evt) {
        if (!evt.isPrimary()) {
          return;
        }

        this._setTransitionDuration(this.getTransitionDuration());

        this._refreshScrollerPosition();
      },

      /**
       * Handler for swipe event on carousel scroller.
       * @param evt {qx.event.type.Swipe} The swipe event.
       */
      _onSwipe: function _onSwipe(evt) {
        if (!evt.isPrimary()) {
          return;
        }

        if (evt.getDuration() < 750 && Math.abs(evt.getDistance()) > 50) {
          var duration = this._calculateTransitionDuration(this.__deltaX__P_449_12, evt.getDuration());

          duration = Math.min(this.getTransitionDuration(), duration);

          this._setTransitionDuration(duration);

          if (evt.getDirection() == "left") {
            this.nextPage();
          } else if (evt.getDirection() == "right") {
            this.previousPage();
          }
        } else {
          this._snapCarouselPage();
        }
      },

      /**
      * Calculates the duration the transition will need till the next carousel
      * snap point is reached.
      * @param deltaX {Integer} the distance on axis between pointerdown and pointerup.
      * @param duration {Number} the swipe duration.
      * @return {Number} the transition duration.
      */
      _calculateTransitionDuration: function _calculateTransitionDuration(deltaX, duration) {
        var distanceX = this.__carouselWidth__P_449_9 - Math.abs(deltaX);
        var transitionDuration = distanceX / Math.abs(deltaX) * duration;
        return transitionDuration / 1000;
      },

      /**
       * Handles the native scroll event on the carousel container.
       * This is needed for preventing "scrollIntoView" method.
       *
       * @param evt {qx.event.type.Native} the native scroll event.
       */
      _onNativeScroll: function _onNativeScroll(evt) {
        var nativeEvent = evt.getNativeEvent();
        nativeEvent.srcElement.scrollLeft = 0;
        nativeEvent.srcElement.scrollTop = 0;
      },

      /**
      * Applies the CSS property "transitionDuration" to the carouselScroller.
      * @param value {Number} the target value of the transitionDuration.
      */
      _setTransitionDuration: function _setTransitionDuration(value) {
        qx.bom.element.Style.set(this.__carouselScroller__P_449_6.getContentElement(), "transitionDuration", value + "s");
      },

      /**
       * Snaps carouselScroller offset to a carouselPage.
       * It determines which carouselPage is the nearest and moves
       * carouselScrollers offset till nearest carouselPage's left border is aligned to carousel's left border.
       */
      _snapCarouselPage: function _snapCarouselPage() {
        this._setTransitionDuration(this.getTransitionDuration());

        var leastDistance = 10000;
        var nearestPageIndex = 0; // Determine nearest snapPoint.

        for (var i = 0; i < this.__pages__P_449_4.length; i++) {
          var snapPoint = -i * this.__carouselWidth__P_449_9;
          var distance = this.__onMoveOffset__P_449_1[0] - snapPoint;

          if (Math.abs(distance) < leastDistance) {
            leastDistance = Math.abs(distance);
            nearestPageIndex = i;
          }
        }

        if (this.getCurrentIndex() == nearestPageIndex) {
          this._refreshScrollerPosition();
        } else {
          this.setCurrentIndex(nearestPageIndex);
        }
      },

      /**
       * Updates the pagination indicator of this carousel.
       * Removes the active state from from paginationLabel with oldActiveIndex,
       * Adds actives state to paginationLabel new ActiveIndex.
       * @param newActiveIndex {Integer} Index of paginationLabel which should have active state
       */
      _updatePagination: function _updatePagination(newActiveIndex) {
        for (var i = 0; i < this.__paginationLabels__P_449_5.length; i++) {
          this.__paginationLabels__P_449_5[i].removeCssClass("active");
        }

        var newActiveLabel = this.__paginationLabels__P_449_5[newActiveIndex];

        if (newActiveLabel && newActiveLabel.getContainerElement()) {
          newActiveLabel.addCssClass("active");
        }

        if (this.__paginationLabels__P_449_5.length) {
          var paginationStyle = window.getComputedStyle(this.__pagination__P_449_7.getContentElement());
          var paginationWidth = parseFloat(paginationStyle.width, 10);

          if (isNaN(paginationWidth)) {
            return;
          }

          var paginationLabelWidth = paginationWidth / this.__paginationLabels__P_449_5.length;
          var left = null;
          var translate = this.__carouselWidth__P_449_9 / 2 - newActiveIndex * paginationLabelWidth - paginationLabelWidth / 2;

          if (paginationWidth < this.__carouselWidth__P_449_9) {
            left = this.__carouselWidth__P_449_9 / 2 - paginationWidth / 2 + "px";
            translate = 0;
          }

          qx.bom.element.Style.set(this.__pagination__P_449_7.getContentElement(), "left", left);

          this.__pagination__P_449_7.setTranslateX(translate);
        }
      },

      /**
       * Assign new position of carousel scrolling container.
       * @param x {Integer} scroller's x position.
       */
      _updateScrollerPosition: function _updateScrollerPosition(x) {
        if (isNaN(x) || this.__carouselScroller__P_449_6.getContentElement() === null) {
          return;
        }

        this.__carouselScroller__P_449_6.setTranslateX(x);
      },

      /**
       * Remove all listeners.
       */
      _removeListeners: function _removeListeners() {
        this.__carouselScroller__P_449_6.removeListener("pointerdown", this._onPointerDown, this);

        this.__carouselScroller__P_449_6.removeListener("track", this._onTrack, this);

        this.__carouselScroller__P_449_6.removeListener("pointerup", this._onPointerUp, this);

        this.__carouselScroller__P_449_6.removeListener("swipe", this._onSwipe, this);

        this.__carouselScroller__P_449_6.removeListener("touchmove", qx.bom.Event.preventDefault, this);

        this.removeListener("appear", this._onContainerUpdate, this);
        qx.event.Registration.removeListener(window, "orientationchange", this._onContainerUpdate, this);
        qx.event.Registration.removeListener(window, "resize", this._onContainerUpdate, this);
        qx.event.Registration.removeListener(this.getContentElement(), "scroll", this._onNativeScroll, this);
      }
    },
    destruct: function destruct() {
      this._removeListeners();

      this._disposeObjects("__carouselScroller__P_449_6", " __pagination");

      qx.util.DisposeUtil.destroyContainer(this);
      qx.util.DisposeUtil.disposeArray(this, "__paginationLabels__P_449_5");
      this.__pages__P_449_4 = this.__paginationLabels__P_449_5 = this.__snapPointsX__P_449_0 = this.__onMoveOffset__P_449_1 = this.__lastOffset__P_449_2 = this.__boundsX__P_449_3 = this.__isPageScrollTarget__P_449_11 = null;
    }
  });
  qx.ui.mobile.container.Carousel.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Creates a Collapsible widget.
   * It contains a {@link qx.ui.mobile.basic.Label Label} for the header and a {@link qx.ui.mobile.container.Composite Composite}
   * for the content.
   *
   * The visibility of the content composite toggles when user taps on header.
   *
   * *Example*
   *
   * Here is an example of how to use the widget.
   *
   * <pre class='javascript'>
   *  var collapsible = new qx.ui.mobile.container.Collapsible("Collapsible Header");
   *  collapsible.setCombined(false);
   *  collapsible.setCollapsed(false);
   *
   *  var label = new qx.ui.mobile.basic.Label("This is the content of the Collapsible.");
   *  collapsible.add(label);
   *
   * </pre>
   *
   */
  qx.Class.define("qx.ui.mobile.container.Collapsible", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
    * @param title {String?} the text which should be displayed in the Collapsible's header label.
    */
    construct: function construct(title) {
      qx.ui.mobile.core.Widget.constructor.call(this);
      this._header = this._createHeader();

      this._header.addCssClass("collapsible-header");

      this._header.addListener("tap", this.toggleCollapsed, this);

      this.setTitle(title);
      this._content = this._createContent();

      this._content.addCssClass("collapsible-content");

      this._add(this._header);

      this._add(this._content);

      this.initCollapsed();
      this.initCombined();
      this.addCssClass("gap");
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "collapsible"
      },

      /** The collapsed state of this widget. */
      collapsed: {
        check: "Boolean",
        init: true,
        nullable: false,
        apply: "_applyCollapsed",
        event: "changeCollapsed"
      },

      /** Controls whether the Collapsible's content
          should be visually associated with its headers. */
      combined: {
        check: "Boolean",
        init: true,
        apply: "_applyCombined"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _header: null,
      _content: null,

      /**
      * Adds a new child widget to the Collapsible's content composite.
      * @param child {qx.ui.mobile.core.Widget} the widget to add.
      * @param layoutProperties {Map?} (default:null) Optional layout data for widget.
      */
      add: function add(child, layoutProperties) {
        if (child && this._content instanceof qx.ui.mobile.container.Composite) {
          this._content.add(child, layoutProperties);
        }
      },

      /**
      * Setter for the Collapsible's header title.
      * @param title {String} the Collapsible's title.
      */
      setTitle: function setTitle(title) {
        if (title && this._header instanceof qx.ui.mobile.basic.Label) {
          this._header.setValue(title);
        }
      },

      /**
      * Getter for the Collapsible's header label.
      * @return {qx.ui.mobile.basic.Label} the header.
      */
      getHeader: function getHeader() {
        return this._header;
      },

      /**
      * Getter for the Collapsible's content composite.
      * @return {qx.ui.mobile.container.Composite} the content composite.
      */
      getContent: function getContent() {
        return this._content;
      },

      /**
      * Factory method for the Collapsible's header.
      * @return {qx.ui.mobile.basic.Label} the label which represents the header.
      */
      _createHeader: function _createHeader() {
        var header = new qx.ui.mobile.basic.Label();
        header.setAnonymous(false);
        header.setActivatable(true);
        return header;
      },

      /**
      * Factory method for the Collapsible's content.
      * @return {qx.ui.mobile.container.Composite} the content composite.
      */
      _createContent: function _createContent() {
        return new qx.ui.mobile.container.Composite();
      },
      // property apply
      _applyCollapsed: function _applyCollapsed(value, old) {
        if (value === true) {
          this._content.exclude();

          this.addCssClass("collapsed");
        } else {
          this._content.show();

          this.removeCssClass("collapsed");
        }
      },
      // property apply
      _applyCombined: function _applyCombined(value, old) {
        if (value === true) {
          this.addCssClass("combined");
        } else {
          this.removeCssClass("combined");
        }
      }
    },
    destruct: function destruct() {
      this._header.removeListener("tap", this.toggleCollapsed, this);

      this._disposeObjects("_header", "_content");
    }
  });
  qx.ui.mobile.container.Collapsible.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.bom.Element": {},
      "qx.bom.element.Style": {},
      "qx.bom.element.Location": {},
      "qx.util.DisposeUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Creates a drawer widget inside the given parent widget. The parent widget can
   * be assigned as a constructor argument. If no parent is set, the application's
   * root will be assumed as parent. A drawer widget can be assigned to left, right,
   * top or bottom edge of its parent by property <code>orientation</code>. The drawer floats
   * in on <code>show()</code> and floats out on <code>hide()</code>. Additionally the drawer is shown by
   * swiping in reverse direction on the parent edge to where the drawer is placed
   * to: Orientation: <code>left</code>, Swipe: <code>right</code> on parents edge: Drawer is shown etc.
   * The drawer is hidden when user taps the parent area outside of the drawer.
   * This behaviour can be deactivated by the property <code>hideOnParentTap</code>.
   *
   * <pre class='javascript'>
   *
   *  var drawer = new qx.ui.mobile.container.Drawer();
   *  drawer.setOrientation("right");
   *  drawer.setTapOffset(100);
   *
   *  var button = new qx.ui.mobile.form.Button("A Button");
   *  drawer.add(button);
   * </pre>
   *
   *
   */
  qx.Class.define("qx.ui.mobile.container.Drawer", {
    extend: qx.ui.mobile.container.Composite,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param parent {qx.ui.mobile.container.Composite?null} The widget to which
     * the drawer should be added, if null it is added to app root.
     * @param layout {qx.ui.mobile.layout.Abstract?null} The layout that should be
     * used for this container.
     */
    construct: function construct(parent, layout) {
      qx.ui.mobile.container.Composite.constructor.call(this);

      if (layout) {
        this.setLayout(layout);
      }

      this.initOrientation();
      this.initPositionZ();

      if (parent) {
        {
          this.assertInstance(parent, qx.ui.mobile.container.Composite);
        }
        parent.add(this);
      } else {
        qx.core.Init.getApplication().getRoot().add(this);
      }

      qx.core.Init.getApplication().addListener("back", this._onBack, this);
      this.__parent__P_450_0 = this.getLayoutParent();

      this.__parent__P_450_0.addCssClass("drawer-parent");

      this.__parent__P_450_0.addListener("swipe", this._onParentSwipe, this);

      this.__parent__P_450_0.addListener("pointerdown", this._onParentPointerDown, this);

      this.__pointerStartPosition__P_450_1 = [0, 0];
      this.forceHide();
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the drawer changes its size.
       */
      resize: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "drawer"
      },

      /** Property for setting the orientation of the drawer.
       * Allowed values are: <code>left</code>,<code>right</code>,<code>top</code>,<code>bottom</code> */
      orientation: {
        check: "String",
        init: "left",
        apply: "_applyOrientation"
      },

      /** The size of the drawer in <code>px</code>. This value is interpreted as width if
      * orientation is <code>left | right</code>, as height if orientation is
      * <code>top | bottom</code>. */
      size: {
        check: "Integer",
        init: 300,
        apply: "_applySize",
        event: "resize"
      },

      /** Indicates whether the drawer should hide when the parent area of it is tapped.  */
      hideOnParentTap: {
        check: "Boolean",
        init: true
      },

      /**
       * Indicates whether the drawer should hide when a back action appear form a key event.
       */
      hideOnBack: {
        check: "Boolean",
        init: true
      },

      /** Sets the size of the tapping area, where the drawer reacts on swipes for opening itself. */
      tapOffset: {
        check: "Integer",
        init: 20
      },

      /** The duration time of the transition between shown/hidden state in ms. */
      transitionDuration: {
        check: "Integer",
        init: 500,
        apply: "_applyTransitionDuration"
      },

      /** Sets the drawer zIndex position relative to its parent. */
      positionZ: {
        check: ["above", "below"],
        init: "above",
        apply: "_applyPositionZ"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __pointerStartPosition__P_450_1: null,
      __parent__P_450_0: null,
      __transitionEnabled__P_450_2: null,
      __inTransition__P_450_3: null,
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        this.removeCssClass(old);
        this.addCssClass(value); // Reapply width of height size depending on orientation.

        this._applySize(this.getSize());
      },
      // property apply
      _applyPositionZ: function _applyPositionZ(value, old) {
        this.removeCssClass(old);
        this.addCssClass(value);

        if (this.__parent__P_450_0) {
          this.__parent__P_450_0.setTranslateX(0);

          this.__parent__P_450_0.setTranslateY(0);
        }
      },
      // property apply
      _applySize: function _applySize(value) {
        var height = null;
        var width = null;
        var remSize = value / 16;

        if (this.getOrientation() == "left" || this.getOrientation() == "right") {
          width = remSize + "rem";
        } else {
          height = remSize + "rem";
        }

        this._setStyle("height", height);

        this._setStyle("width", width);
      },
      // property apply
      _applyTransitionDuration: function _applyTransitionDuration(value, old) {
        this.__transitionEnabled__P_450_2 = value > 0;
      },

      /**
       * Shows the drawer.
       */
      show: function show() {
        if (!this.isHidden() || this.__inTransition__P_450_3 === true) {
          return;
        }

        this.__inTransition__P_450_3 = true; // Make drawer visible before "changeVisibility" event is fired, after transition.

        this._setStyle("visibility", "visible");

        this.__parent__P_450_0.addCssClass("blocked");

        if (this.getPositionZ() == "below") {
          if (this.getOrientation() == "left") {
            this.__parent__P_450_0.setTranslateX(this.getSize());
          } else if (this.getOrientation() == "right") {
            this.__parent__P_450_0.setTranslateX(-this.getSize());
          } else if (this.getOrientation() == "top") {
            this.__parent__P_450_0.setTranslateY(this.getSize());
          } else if (this.getOrientation() == "bottom") {
            this.__parent__P_450_0.setTranslateY(-this.getSize());
          }
        }

        if (this.getTransitionDuration() > 0) {
          this._enableTransition();

          var callArguments = arguments;

          var transitionTarget = this._getTransitionTarget().getContentElement();

          var listenerId = qx.bom.Element.addListener(transitionTarget, "transitionEnd", function (evt) {
            qx.ui.mobile.container.Drawer.prototype.show.base.call(this);

            this._disableTransition();

            this.__inTransition__P_450_3 = false;
            qx.bom.Element.removeListenerById(transitionTarget, listenerId);
          }, this);
          setTimeout(function () {
            this.removeCssClass("hidden");
          }.bind(this), 0);
        } else {
          qx.ui.mobile.container.Drawer.prototype.show.base.call(this);
          this.__inTransition__P_450_3 = false;
          this.removeCssClass("hidden");
        }
      },

      /**
       * Hides the drawer.
       */
      hide: function hide() {
        if (this.isHidden() || this.__inTransition__P_450_3 === true) {
          return;
        }

        this.__inTransition__P_450_3 = true;

        if (this.getPositionZ() == "below") {
          this.__parent__P_450_0.setTranslateX(0);

          this.__parent__P_450_0.setTranslateY(0);
        }

        if (this.getTransitionDuration() > 0) {
          this._enableTransition();

          var callArguments = arguments;

          var transitionTarget = this._getTransitionTarget().getContentElement();

          var listenerId = qx.bom.Element.addListener(transitionTarget, "transitionEnd", function (evt) {
            qx.ui.mobile.container.Drawer.prototype.hide.base.call(this);

            this._disableTransition();

            this.__parent__P_450_0.removeCssClass("blocked");

            this.__inTransition__P_450_3 = false;
            qx.bom.Element.removeListenerById(transitionTarget, listenerId);
          }, this);
          setTimeout(function () {
            this.addCssClass("hidden");
          }.bind(this), 0);
        } else {
          qx.ui.mobile.container.Drawer.prototype.hide.base.call(this);
          this.addCssClass("hidden");
          this.__inTransition__P_450_3 = false;

          this.__parent__P_450_0.removeCssClass("blocked");
        }
      },

      /**
       * Strict way to hide this drawer. Removes the blocker from the parent,
       * and hides the drawer without any animation. Should be called when drawer's
       * parent is animated and drawer should hide immediately.
       */
      forceHide: function forceHide() {
        this._disableTransition();

        if (this.getPositionZ() == "below") {
          this.__parent__P_450_0.setTranslateX(0);

          this.__parent__P_450_0.setTranslateY(0);
        }

        this.__parent__P_450_0.removeCssClass("blocked");

        this.addCssClass("hidden");
      },
      // overridden
      isHidden: function isHidden() {
        return this.hasCssClass("hidden");
      },

      /**
       * Enables the transition on this drawer.
       */
      _enableTransition: function _enableTransition() {
        qx.bom.element.Style.set(this._getTransitionTarget().getContentElement(), "transition", "all " + this.getTransitionDuration() + "ms ease-in-out");
      },

      /**
        * Disables the transition on this drawer.
        */
      _disableTransition: function _disableTransition() {
        qx.bom.element.Style.set(this._getTransitionTarget().getContentElement(), "transition", null);
      },

      /**
      * Returns the target widget which is responsible for the transition handling.
      * @return {qx.ui.mobile.core.Widget} the transition target widget.
      */
      _getTransitionTarget: function _getTransitionTarget() {
        if (this.getPositionZ() == "below") {
          return this.__parent__P_450_0;
        } else {
          return this;
        }
      },

      /**
       * Toggle the visibility of the drawer.
       * @return {Boolean} the new visibility state.
       */
      toggleVisibility: function toggleVisibility() {
        if (this.isHidden()) {
          this.show();
          return true;
        } else {
          this.hide();
          return false;
        }
      },

      /**
       * Handles a back event which appears on the application.
       *
       * @param evt {qx.event.type.Data} The back event.
       */
      _onBack: function _onBack(evt) {
        var triggeredByKeyEvent = !!evt.getData();

        if (triggeredByKeyEvent && !this.isHidden() && this.getHideOnBack()) {
          evt.preventDefault();
          this.hide();
        }
      },

      /**
       * Handles a tap on drawers' root.
       * @param evt {qx.module.event.Pointer} Handled pointer event.
       */
      _onParentPointerDown: function _onParentPointerDown(evt) {
        this.__pointerStartPosition__P_450_1 = [evt.getViewportLeft(), evt.getViewportTop()];
        var isShown = !this.hasCssClass("hidden");

        if (isShown && this.isHideOnParentTap()) {
          var location = qx.bom.element.Location.get(this.getContainerElement());
          var orientation = this.getOrientation();

          if (orientation == "left" && this.__pointerStartPosition__P_450_1[0] > location.right || orientation == "top" && this.__pointerStartPosition__P_450_1[1] > location.bottom || orientation == "bottom" && this.__pointerStartPosition__P_450_1[1] < location.top || orientation == "right" && this.__pointerStartPosition__P_450_1[0] < location.left) {
            // First event on overlayed page should be ignored.
            evt.preventDefault();
            this.hide();
          }
        }
      },

      /**
       * Handles a swipe on layout parent.
       * @param evt {qx.module.event.Pointer} Handled pointer event.
       */
      _onParentSwipe: function _onParentSwipe(evt) {
        var direction = evt.getDirection();
        var isHidden = this.hasCssClass("hidden");

        if (isHidden) {
          var location = qx.bom.element.Location.get(this.getContainerElement());

          if (direction == "right" && this.getOrientation() == "left" && this.__pointerStartPosition__P_450_1[0] < location.right + this.getTapOffset() && this.__pointerStartPosition__P_450_1[0] > location.right || direction == "left" && this.getOrientation() == "right" && this.__pointerStartPosition__P_450_1[0] > location.left - this.getTapOffset() && this.__pointerStartPosition__P_450_1[0] < location.left || direction == "down" && this.getOrientation() == "top" && this.__pointerStartPosition__P_450_1[1] < this.getTapOffset() + location.bottom && this.__pointerStartPosition__P_450_1[1] > location.bottom || direction == "up" && this.getOrientation() == "bottom" && this.__pointerStartPosition__P_450_1[1] > location.top - this.getTapOffset() && this.__pointerStartPosition__P_450_1[1] < location.top) {
            this.show();
          }
        }
      }
    },
    destruct: function destruct() {
      qx.core.Init.getApplication().removeListener("back", this._onBack, this);

      this.__parent__P_450_0.removeListener("swipe", this._onParentSwipe, this);

      this.__parent__P_450_0.removeListener("pointerdown", this._onParentPointerDown, this);

      qx.util.DisposeUtil.destroyContainer(this);
      this.__pointerStartPosition__P_450_1 = this.__parent__P_450_0 = this.__transitionEnabled__P_450_2 = null;
    }
  });
  qx.ui.mobile.container.Drawer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * All widgets that are added to the navigation container should implement this interface.
   */
  qx.Interface.define("qx.ui.mobile.container.INavigation", {
    members: {
      /**
       * Returns the title widget that is merged into the navigation bar.
       *
       * @return {qx.ui.mobile.navigationbar.Title} The title of the navigation bar
       */
      getTitleWidget: function getTitleWidget() {},

      /**
       * Returns the left container that is merged into the navigation bar.
       *
       * @return {qx.ui.mobile.container.Composite} The left container of the navigation bar
       */
      getLeftContainer: function getLeftContainer() {},

      /**
       * Returns the right container that is merged into the navigation bar.
       *
       * @return {qx.ui.mobile.container.Composite} The right container of the navigation bar
       */
      getRightContainer: function getRightContainer() {}
    }
  });
  qx.ui.mobile.container.INavigation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Objects which are used as delegates for the {@link qx.ui.mobile.container.Scroll#delegate} may
   * implement any of the methods described in this interface. The delegate does
   * not need to implement all the methods of this interface.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * actually implemented.
   */
  qx.Interface.define("qx.ui.mobile.container.IScrollDelegate", {
    members: {
      /**
       * Calculates the scroll offset if container scrolls to a widget/element through <code>scrollToElement()|scrollToWidget()</code>.
       *
       * @return {Array} an array with x,y offset.
       */
      getScrollOffset: function getScrollOffset() {}
    }
  });
  qx.ui.mobile.container.IScrollDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dom.Element": {},
      "qx.bom.element.Class": {},
      "qx.bom.element.Dimension": {},
      "qx.util.ResourceManager": {},
      "qx.bom.request.Script": {},
      "qx.lang.Object": {},
      "qx.bom.client.Scroll": {},
      "qx.lang.Array": {},
      "qx.event.Registration": {},
      "qx.bom.Event": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   * Mixin for the {@link Scroll} container. Used when the variant
   * <code>qx.mobile.nativescroll</code> is set to "off". Uses the iScroll script to simulate
   * the CSS position:fixed style. Position fixed is not available in iOS and
   * Android < 2.2.
   *
   * @ignore(iScroll)
   * @asset(qx/mobile/js/iscroll*.js)
   */
  qx.Mixin.define("qx.ui.mobile.container.MIScroll", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      this.__initScroll__P_451_0();

      this.__registerEventListeners__P_451_1();
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __scroll__P_451_2: null,

      /**
       * Mixin method. Creates the scroll element.
       *
       * @return {Element} The scroll element
       */
      _createScrollElement: function _createScrollElement() {
        var scroll = qx.dom.Element.create("div");
        qx.bom.element.Class.add(scroll, "iscroll");
        return scroll;
      },

      /**
       * Mixin method. Returns the scroll content element..
       *
       * @return {Element} The scroll content element
       */
      _getScrollContentElement: function _getScrollContentElement() {
        return this.getContainerElement().childNodes[0];
      },

      /**
      * Returns the current scroll position
      * @return {Array} an array with the <code>[scrollLeft,scrollTop]</code>.
      */
      _getPosition: function _getPosition() {
        return [this._currentX, this._currentY];
      },

      /**
      * Returns the scrolling height of the inner container.
      * @return {Number} the scrolling height.
      */
      _getScrollHeight: function _getScrollHeight() {
        if (!this.getContainerElement()) {
          return 0;
        }

        return this._getScrollContentElement().scrollHeight - this.getContainerElement().offsetHeight;
      },

      /**
      * Returns the scrolling width of the inner container.
      * @return {Number} the scrolling width.
      */
      _getScrollWidth: function _getScrollWidth() {
        if (!this.getContainerElement()) {
          return 0;
        }

        return this._getScrollContentElement().scrollWidth - this.getContainerElement().offsetWidth;
      },

      /**
      * Scrolls the wrapper contents to the x/y coordinates in a given period.
      *
      * @param x {Integer} X coordinate to scroll to.
      * @param y {Integer} Y coordinate to scroll to.
      * @param time {Integer} Time slice in which scrolling should
      *              be done.
      */
      _scrollTo: function _scrollTo(x, y, time) {
        if (this._isScrollable()) {
          // Normalize scrollable values
          var lowerLimitY = qx.bom.element.Dimension.getHeight(this._getScrollContentElement()) - this.getContainerElement().offsetHeight;

          if (y > lowerLimitY) {
            y = lowerLimitY;
          }

          var lowerLimitX = qx.bom.element.Dimension.getWidth(this._getScrollContentElement()) - this.getContainerElement().offsetWidth;

          if (x > lowerLimitX) {
            x = lowerLimitX;
          }

          if (this.__scroll__P_451_2) {
            this.__scroll__P_451_2.scrollTo(-x, -y, time);
          } else {
            // Case when iScroll is not loaded yet, but user tries
            // to set a different scroll position. Position is applied on "__onScrollLoaded".
            this._setCurrentY(x);

            this._setCurrentY(y);
          }
        }
      },

      /**
       * Loads and inits the iScroll instance.
       *
       * @ignore(iScroll)
       */
      __initScroll__P_451_0: function __initScroll__P_451_0() {
        if (!window.iScroll) {
          {
            var resource = "qx/mobile/js/iscroll.js";
          }
          var path = qx.util.ResourceManager.getInstance().toUri(resource);
          {
            path += "?" + new Date().getTime();
          }
          var loader = new qx.bom.request.Script();
          loader.on("load", this.__onScrollLoaded__P_451_3, this);
          loader.open("GET", path);
          loader.send();
        } else {
          this.addListenerOnce("appear", function () {
            this._setScroll(this.__createScrollInstance__P_451_4());
          }, this);
        }
      },

      /**
       * Creates the iScroll instance.
       *
       * @return {Object} The iScroll instance
       * @ignore(iScroll)
       */
      __createScrollInstance__P_451_4: function __createScrollInstance__P_451_4() {
        var defaultScrollProperties = this._getDefaultScrollProperties();

        var customScrollProperties = {};

        if (this._scrollProperties != null) {
          customScrollProperties = this._scrollProperties;
        }

        var iScrollProperties = qx.lang.Object.mergeWith(defaultScrollProperties, customScrollProperties, true);
        return new iScroll(this.getContainerElement(), iScrollProperties);
      },

      /**
       * Returns a map with default iScroll properties for the iScroll instance.
       * @return {Object} Map with default iScroll properties
       */
      _getDefaultScrollProperties: function _getDefaultScrollProperties() {
        var container = this;
        return {
          hideScrollbar: true,
          fadeScrollbar: true,
          hScrollbar: false,
          scrollbarClass: "scrollbar",
          useTransform: true,
          useTransition: true,
          onScrollEnd: function onScrollEnd() {
            // Alert interested parties that we scrolled to end of page.
            if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
              container._setCurrentX(-this.x);

              container._setCurrentY(-this.y);

              container.fireEvent("scrollEnd");

              if (this.y == this.maxScrollY) {
                container.fireEvent("pageEnd");
              }
            }
          },
          onScrollMove: function onScrollMove() {
            // Alert interested parties that we scrolled to end of page.
            if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
              container._setCurrentX(-this.x);

              container._setCurrentY(-this.y);

              if (this.y == this.maxScrollY) {
                container.fireEvent("pageEnd");
              }
            }
          },
          onBeforeScrollStart: function onBeforeScrollStart(e) {
            // QOOXDOO ENHANCEMENT: Do not prevent default for form elements

            /* When updating iScroll, please check out that doubleTapTimer is not active (commented out)
             * in code. DoubleTapTimer creates a fake click event. Android 4.1. and newer
             * is able to fire native events, which  create side effect with the fake event of iScroll. */
            var target = e.target;

            while (target.nodeType != 1) {
              target = target.parentNode;
            }

            if (target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA' && target.tagName != 'LABEL') {
              // Remove focus from input elements, so that the keyboard and the mouse cursor is hidden
              var elements = [];
              var inputElements = qx.lang.Array.cast(document.getElementsByTagName("input"), Array);
              var textAreaElements = qx.lang.Array.cast(document.getElementsByTagName("textarea"), Array);
              elements = elements.concat(inputElements);
              elements = elements.concat(textAreaElements);

              for (var i = 0, length = elements.length; i < length; i++) {
                elements[i].blur();
              }

              e.preventDefault();
            }
          }
        };
      },

      /**
       * Registers all needed event listener.
       */
      __registerEventListeners__P_451_1: function __registerEventListeners__P_451_1() {
        qx.event.Registration.addListener(window, "orientationchange", this._refresh, this);
        qx.event.Registration.addListener(window, "resize", this._refresh, this);
        this.addListener("touchmove", qx.bom.Event.stopPropagation);
        this.addListener("domupdated", this._refresh, this);
      },

      /**
       * Unregisters all needed event listener.
       */
      __unregisterEventListeners__P_451_5: function __unregisterEventListeners__P_451_5() {
        qx.event.Registration.removeListener(window, "orientationchange", this._refresh, this);
        qx.event.Registration.removeListener(window, "resize", this._refresh, this);
        this.removeListener("touchmove", qx.bom.Event.stopPropagation);
        this.removeListener("domupdated", this._refresh, this);
      },

      /**
       * Load callback. Called when the iScroll script is loaded.
       *
       * @param request {qx.bom.request.Script} The Script request object
       */
      __onScrollLoaded__P_451_3: function __onScrollLoaded__P_451_3(request) {
        if (request.status < 400) {
          if (!this.isDisposed()) {
            this._setScroll(this.__createScrollInstance__P_451_4());

            this._scrollTo(this._currentX, this._currentY);
          }
        } else {
          {
            this.error("Could not load iScroll");
          }
        }
      },

      /**
       * Setter for the scroll instance.
       *
       * @param scroll {Object} iScroll instance.
       */
      _setScroll: function _setScroll(scroll) {
        this.__scroll__P_451_2 = scroll;
      },

      /**
       * Delegation method for iScroll. Disabled the iScroll objects.
       * Prevents any further scrolling of this container.
       */
      disable: function disable() {
        if (this.__scroll__P_451_2) {
          this.__scroll__P_451_2.disable();
        }
      },

      /**
       * Delegation method for iScroll. Enables the iScroll object.
       */
      enable: function enable() {
        if (this.__scroll__P_451_2) {
          this.__scroll__P_451_2.enable();
        }
      },

      /**
       * Calls the refresh function of iScroll. Needed to recalculate the
       * scrolling container.
       */
      _refresh: function _refresh() {
        if (this.__scroll__P_451_2) {
          this.__scroll__P_451_2.refresh();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__unregisterEventListeners__P_451_5(); // Cleanup iScroll


      if (this.__scroll__P_451_2) {
        this.__scroll__P_451_2.destroy();
      }

      this.__scroll__P_451_2 = null;
    }
  });
  qx.ui.mobile.container.MIScroll.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Animation": {
        "require": true
      },
      "qx.module.Manipulating": {
        "require": true
      },
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Event": {
        "construct": true
      },
      "qx.bom.client.OperatingSystem": {
        "construct": true
      },
      "qx.bom.element.Location": {},
      "qx.bom.element.Animation": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "os.name": {
          "construct": true,
          "className": "qx.bom.client.OperatingSystem"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * @require(qx.module.Animation)
   * @require(qx.module.Manipulating)
   *
   * Mixin for the {@link Scroll} container. Used when the variant
   * <code>qx.mobile.nativescroll</code> is set to "on".
   */
  qx.Mixin.define("qx.ui.mobile.container.MNativeScroll", {
    construct: function construct() {
      this.addCssClass("native");
      this._snapPoints = [];
      this.addListenerOnce("appear", this._onAppear, this);
      this.addListener("trackstart", this._onTrackStart, this);
      this.addListener("trackend", this._onTrackEnd, this);
      qx.bom.Event.addNativeListener(this._getContentElement(), "scroll", this._onScroll.bind(this));

      if (qx.core.Environment.get("os.name") == "ios") {
        this.addListener("touchmove", this._onTouchMove, this);
      }
    },
    members: {
      _snapPoints: null,
      _onTrack: null,
      _snapTimeoutId: null,

      /**
      * Event handler for <code>appear</code> event.
      */
      _onAppear: function _onAppear() {
        this._calcSnapPoints();
      },

      /**
      * Event handler for <code>touchmove</code> event.
      * Needed for preventing iOS page bounce.
      * @param evt {qx.event.type.Touch} touchmove event.
      */
      _onTouchMove: function _onTouchMove(evt) {
        // If scroll container is scrollable
        if (this._isScrollableY()) {
          evt.stopPropagation();
        } else {
          evt.preventDefault();
        }
      },

      /**
       * Event handler for <code>trackstart</code> events.
       * @param evt {qx.event.type.Track} touchmove event.
       */
      _onTrackStart: function _onTrackStart(evt) {
        this._onTrack = true;

        if (qx.core.Environment.get("os.name") == "ios") {
          this._preventPageBounce();
        }
      },

      /**
       * Prevents the iOS page bounce if scroll container reaches the upper or lower vertical scroll limit.
       */
      _preventPageBounce: function _preventPageBounce() {
        // If scroll container is scrollable
        if (this._isScrollableY()) {
          var element = this.getContentElement();
          var scrollTop = element.scrollTop;
          var maxScrollTop = element.scrollHeight - this.getLayoutParent().getContentElement().offsetHeight;

          if (scrollTop === 0) {
            element.scrollTop = 1;
          } else if (scrollTop == maxScrollTop) {
            element.scrollTop = maxScrollTop - 1;
          }
        }
      },

      /**
      * Event handler for <code>trackend</code> events.
      * @param evt {qx.event.type.Track} touchmove event.
      */
      _onTrackEnd: function _onTrackEnd(evt) {
        this._onTrack = false;

        if (this._snapTimeoutId) {
          clearTimeout(this._snapTimeoutId);
        }

        this._snapTimeoutId = setTimeout(function () {
          this._snap();
        }.bind(this), 100);
        evt.stopPropagation();
      },

      /**
      * Event handler for <code>scroll</code> events.
      */
      _onScroll: function _onScroll() {
        var scrollLeft = this.getContentElement().scrollLeft;
        var scrollTop = this.getContentElement().scrollTop;

        this._setCurrentX(scrollLeft);

        this._setCurrentY(scrollTop);

        if (this._snapTimeoutId) {
          clearTimeout(this._snapTimeoutId);
        }

        this._snapTimeoutId = setTimeout(function () {
          if (!this._onTrack) {
            this._snap();
          }
        }.bind(this), 100);
      },

      /**
      * Calculates the snapping points for the x/y axis.
      */
      _calcSnapPoints: function _calcSnapPoints() {
        if (this._scrollProperties) {
          var snap = this._scrollProperties.snap;

          if (snap) {
            this._snapPoints = [];
            var snapTargets = this.getContentElement().querySelectorAll(snap);

            for (var i = 0; i < snapTargets.length; i++) {
              var snapPoint = qx.bom.element.Location.getRelative(this._getContentElement(), snapTargets[i], "scroll", "scroll");

              this._snapPoints.push(snapPoint);
            }
          }
        }
      },

      /**
      * Determines the next snap points for the passed current position.
      * @param current {Integer} description
      * @param snapProperty {String} "top" or "left"
      * @return {Integer} the determined snap point.
      */
      _determineSnapPoint: function _determineSnapPoint(current, snapProperty) {
        for (var i = 0; i < this._snapPoints.length; i++) {
          var snapPoint = this._snapPoints[i];

          if (current <= -snapPoint[snapProperty]) {
            if (i > 0) {
              var previousSnapPoint = this._snapPoints[i - 1];
              var previousSnapDiff = Math.abs(current + previousSnapPoint[snapProperty]);
              var nextSnapDiff = Math.abs(current + snapPoint[snapProperty]);

              if (previousSnapDiff < nextSnapDiff) {
                return -previousSnapPoint[snapProperty];
              } else {
                return -snapPoint[snapProperty];
              }
            } else {
              return -snapPoint[snapProperty];
            }
          }
        }

        return current;
      },

      /**
      * Snaps the scrolling area to the nearest snap point.
      */
      _snap: function _snap() {
        this.fireEvent("scrollEnd");
        var element = this.getContentElement();

        if (element.scrollTop < 1 || element.scrollTop > this._getScrollHeight()) {
          return;
        }

        var current = this._getPosition();

        var nextX = this._determineSnapPoint(current[0], "left");

        var nextY = this._determineSnapPoint(current[1], "top");

        if (nextX != current[0] || nextY != current[1]) {
          this._scrollTo(nextX, nextY, 300);
        }
      },

      /**
       * Refreshes the scroll container. Recalculates the snap points.
       */
      _refresh: function _refresh() {
        this._calcSnapPoints();
      },

      /**
       * Mixin method. Creates the scroll element.
       *
       * @return {Element} The scroll element
       */
      _createScrollElement: function _createScrollElement() {
        return null;
      },

      /**
       * Returns the current scroll position
       * @return {Array} an array with <code>[scrollLeft,scrollTop]</code>.
       */
      _getPosition: function _getPosition() {
        return [this.getContentElement().scrollLeft, this.getContentElement().scrollTop];
      },

      /**
       * Mixin method. Returns the scroll content element.
       *
       * @return {Element} The scroll content element
       */
      _getScrollContentElement: function _getScrollContentElement() {
        return null;
      },

      /**
      * Returns the scrolling height of the inner container.
      * @return {Number} the scrolling height.
      */
      _getScrollHeight: function _getScrollHeight() {
        if (!this.getContentElement()) {
          return 0;
        }

        return this.getContentElement().scrollHeight - this.getContentElement().offsetHeight;
      },

      /**
      * Returns the scrolling width of the inner container.
      * @return {Number} the scrolling width.
      */
      _getScrollWidth: function _getScrollWidth() {
        if (!this.getContentElement()) {
          return 0;
        }

        return this.getContentElement().scrollWidth - this.getContentElement().offsetWidth;
      },

      /**
       * Scrolls the wrapper contents to the x/y coordinates in a given period.
       *
       * @param x {Integer} X coordinate to scroll to.
       * @param y {Integer} Y coordinate to scroll to.
       * @param time {Integer} is always <code>0</code> for this mixin.
       */
      _scrollTo: function _scrollTo(x, y, time) {
        var element = this.getContentElement();

        if (!time) {
          element.scrollLeft = x;
          element.scrollTop = y;
          return;
        }

        var startY = element.scrollTop;
        var startX = element.scrollLeft;

        if (element) {
          qx.bom.element.Animation.animate(element, {
            "duration": time,
            "keyFrames": {
              0: {
                "scrollTop": startY,
                "scrollLeft": startX
              },
              100: {
                "scrollTop": y,
                "scrollLeft": x
              }
            },
            "keep": 100,
            "timing": "ease-out"
          });
        }
      }
    },
    destruct: function destruct() {
      qx.bom.Event.removeNativeListener(this._getContentElement(), "scroll", this._onScroll.bind(this));
      this.removeListener("touchmove", this._onTouchMove, this);
      this.removeListener("appear", this._onAppear, this);
      this.removeListener("trackstart", this._onTrackStart, this);
      this.removeListener("trackend", this._onTrackEnd, this);
    }
  });
  qx.ui.mobile.container.MNativeScroll.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Scroll": {},
      "qx.ui.mobile.core.Root": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The mixin contains all functionality to provide methods
   * for scroll container handling: determine the parent scroll container.
   *
   */
  qx.Mixin.define("qx.ui.mobile.container.MScrollHandling", {
    members: {
      /**
       * Returns the parent scroll container of this widget.
       * @return {qx.ui.mobile.container.Scroll} the parent scroll container or <code>null</code>
       */
      _getParentScrollContainer: function _getParentScrollContainer() {
        var scroll = this;

        while (!(scroll instanceof qx.ui.mobile.container.Scroll)) {
          if (scroll.getLayoutParent) {
            var layoutParent = scroll.getLayoutParent();

            if (layoutParent === null || layoutParent instanceof qx.ui.mobile.core.Root) {
              return null;
            }

            scroll = layoutParent;
          } else {
            return null;
          }
        }

        return scroll;
      }
    }
  });
  qx.ui.mobile.container.MScrollHandling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "defer": "runtime",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.lang.Type": {},
      "qx.bom.Selector": {},
      "qx.bom.element.Location": {},
      "qx.bom.element.Dimension": {},
      "qx.bom.client.Scroll": {
        "defer": "runtime"
      },
      "qx.ui.mobile.container.MIScroll": {
        "defer": "runtime"
      },
      "qx.ui.mobile.container.MNativeScroll": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "defer": true,
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Container, which allows, depending on the set variant <code>qx.mobile.nativescroll</code>,
   * vertical and horizontal scrolling if the contents is larger than the container.
   *
   * Note that this class can only have one child widget. This container has a
   * fixed layout, which cannot be changed.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // create the scroll widget
   *   var scroll = new qx.ui.mobile.container.Scroll();
   *
   *   // add a children
   *   scroll.add(new qx.ui.mobile.basic.Label("Name: "));
   *
   *   this.getRoot().add(scroll);
   * </pre>
   *
   * This example creates a scroll container and adds a label to it.
   */
  qx.Class.define("qx.ui.mobile.container.Scroll", {
    extend: qx.ui.mobile.container.Composite,

    /**
    * @param scrollProperties {Object} A map with scroll properties which are passed to the scrolling container (may contain iScroll properties).
    */
    construct: function construct(scrollProperties) {
      qx.ui.mobile.container.Composite.constructor.call(this);

      if (scrollProperties) {
        this._scrollProperties = scrollProperties;
      }

      this.addListener("appear", this._updateWaypoints, this);
      this._waypointsX = [];
      this._waypointsY = [];
      this._currentX = 0;
      this._currentY = 0;
    },
    events: {
      /** Fired when the scroll container reaches its end position (including momentum/inertia). */
      scrollEnd: "qx.event.type.Event",

      /** Fired when the user scrolls to the end of scroll area. */
      pageEnd: "qx.event.type.Event",

      /** Fired when a vertical or horizontal waypoint is triggered. Data:
      * <code> {"offset": 0,
      *        "input": "10%",
      *        "index": 0,
      *        "element" : 0}</code>
      */
      waypoint: "qx.event.type.Data",

      /**
      * Fired when a momentum starts on an iOS device.
      */
      momentumStart: "qx.event.type.Event",

      /**
      * Fired when a momentum ends on an iOS device.
      */
      momentumEnd: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "scroll"
      },

      /**
       * Delegation object which can have one or more functions defined by the
       * {@link qx.ui.mobile.container.IScrollDelegate} interface.
       *
       * @internal
       */
      delegate: {
        init: null,
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _scrollProperties: null,
      _activeWaypointX: null,
      _activeWaypointY: null,
      _waypointsX: null,
      _waypointsY: null,
      _calculatedWaypointsX: null,
      _calculatedWaypointsY: null,
      _currentX: null,
      _currentY: null,

      /**
      * Sets the current x position.
      * @param value {Number} the current horizontal position.
      */
      _setCurrentX: function _setCurrentX(value) {
        var old = this._currentX;
        this._currentX = value;

        this._fireWaypoint(value, old, "x");
      },

      /**
      * Sets the current y position.
      * @param value {Number} the current vertical position.
      */
      _setCurrentY: function _setCurrentY(value) {
        var old = this._currentY;
        this._currentY = value;

        this._fireWaypoint(value, old, "y");
      },

      /**
       * Sets the horizontal trigger points, where a <code>waypoint</code> event will be fired.
       * @param waypoints {Array} description
       */
      setWaypointsX: function setWaypointsX(waypoints) {
        this._waypointsX = waypoints;
      },

      /**
       * Sets the vertical trigger points, where a <code>waypoint</code> event will be fired.
       * @param waypoints {Array} an array with waypoint descriptions. Allowed are percentage description as string, or pixel trigger points defined as numbers. <code>["20%",200]</code>
       */
      setWaypointsY: function setWaypointsY(waypoints) {
        this._waypointsY = waypoints;
      },

      /**
       * Returns the scroll height.
       * @return {Number} the scroll height.
       */
      getScrollHeight: function getScrollHeight() {
        return this._getScrollHeight();
      },

      /**
       * Returns the scroll width.
       * @return {Number} the scroll width.
       */
      getScrollWidth: function getScrollWidth() {
        return this._getScrollWidth();
      },

      /**
       * Re-calculates the internal waypoint offsets.
       */
      _updateWaypoints: function _updateWaypoints() {
        this._calculatedWaypointsX = [];
        this._calculatedWaypointsY = [];

        this._calcWaypoints(this._waypointsX, this._calculatedWaypointsX, this.getScrollWidth(), "x");

        this._calcWaypoints(this._waypointsY, this._calculatedWaypointsY, this.getScrollHeight());
      },

      /**
       * Validates and checks the waypoint offsets.
       * @param waypoints {Array} an array with waypoint descriptions.
       * @param results {Array} the array where calculated waypoints will be added.
       * @param scrollSize {Number} the vertical or horizontal scroll size.
       * @param axis {String?} "x" or "y".
       */
      _calcWaypoints: function _calcWaypoints(waypoints, results, scrollSize, axis) {
        axis = axis || "y";
        var offset = 0;

        for (var i = 0; i < waypoints.length; i++) {
          var waypoint = waypoints[i];

          if (qx.lang.Type.isString(waypoint)) {
            if (waypoint.endsWith("%")) {
              offset = parseInt(waypoint, 10) * (scrollSize / 100);
              results.push({
                "offset": offset,
                "input": waypoint,
                "index": i,
                "element": null,
                "axis": axis
              });
            } else {
              // Dynamically created waypoints, based upon a selector.
              var element = this.getContentElement();
              var waypointElements = qx.bom.Selector.query(waypoint, element);

              for (var j = 0; j < waypointElements.length; j++) {
                var position = qx.bom.element.Location.getRelative(waypointElements[j], element);

                if (axis === "y") {
                  offset = position.top + this.getContentElement().scrollTop;
                } else if (axis === "x") {
                  offset = position.left + this.getContentElement().scrollLeft;
                }

                results.push({
                  "offset": position.top + this._currentY,
                  "input": waypoint,
                  "index": i,
                  "element": j,
                  "axis": axis
                });
              }
            }
          } else if (qx.lang.Type.isNumber(waypoint)) {
            results.push({
              "offset": waypoint,
              "input": waypoint,
              "index": i,
              "element": null,
              "axis": axis
            });
          }
        }

        results.sort(function (a, b) {
          return a.offset - b.offset;
        });
      },

      /**
       * Fires a waypoints event when scroll position changes.
       * @param value {Number} old scroll position.
       * @param old {Number} old scroll position.
       * @param axis {String} "x" or "y".
       */
      _fireWaypoint: function _fireWaypoint(value, old, axis) {
        var waypoints = this._calculatedWaypointsY;

        if (axis === "x") {
          waypoints = this._calculatedWaypointsX;
        }

        if (waypoints === null) {
          return;
        }

        var nextWaypoint = null;

        for (var i = 0; i < waypoints.length; i++) {
          var waypoint = waypoints[i];

          if (waypoint.offset !== null) {
            if (value > -1 && value >= waypoint.offset || value < 0 && waypoint.offset < 0 && value <= waypoint.offset) {
              nextWaypoint = waypoint;
            } else {
              break;
            }
          }
        }

        if (nextWaypoint === null) {
          if (axis === "x") {
            this._activeWaypointX = null;
          } else {
            this._activeWaypointY = null;
          }

          return;
        }

        var direction = null;

        if (old <= value) {
          direction = "down";

          if (axis == "x") {
            direction = "left";
          }
        } else {
          direction = "up";

          if (axis == "x") {
            direction = "right";
          }
        }

        var activeWaypoint = this._activeWaypointY;

        if (axis === "x") {
          activeWaypoint = this._activeWaypointX;
        }

        if (activeWaypoint === null || activeWaypoint.index !== nextWaypoint.index || activeWaypoint.element !== nextWaypoint.element) {
          activeWaypoint = nextWaypoint;
          this._activeWaypointY = activeWaypoint;

          if (axis === "x") {
            this._activeWaypointX = activeWaypoint;
          }

          this.fireDataEvent("waypoint", {
            "axis": axis,
            "index": nextWaypoint.index,
            "element": nextWaypoint.element,
            "direction": direction
          });
        }
      },
      // overridden
      _createContainerElement: function _createContainerElement() {
        var element = qx.ui.mobile.container.Scroll.prototype._createContainerElement.base.call(this);

        var scrollElement = this._createScrollElement();

        if (scrollElement) {
          return scrollElement;
        }

        return element;
      },
      // overridden
      _getContentElement: function _getContentElement() {
        var contentElement = qx.ui.mobile.container.Scroll.prototype._getContentElement.base.call(this);

        var scrollContentElement = this._getScrollContentElement();

        return scrollContentElement || contentElement;
      },

      /**
       * Calls the refresh function the used scrolling method. Needed to recalculate the
       * scrolling container.
       */
      refresh: function refresh() {
        this._refresh();

        this._updateWaypoints();
      },

      /**
       * Scrolls the wrapper contents to the x/y coordinates in a given time.
       *
       * @param x {Integer} X coordinate to scroll to.
       * @param y {Integer} Y coordinate to scroll to.
       * @param time {Integer} Time slice in which scrolling should
       *              be done.
       */
      scrollTo: function scrollTo(x, y, time) {
        this._scrollTo(x, y, time);
      },

      /**
       * Returns the current scroll position
       * @return {Array} an array with <code>[scrollLeft,scrollTop]</code>.
       */
      getPosition: function getPosition() {
        return this._getPosition();
      },

      /**
       * Detects whether this scroll container is scrollable or not.
       * @return {Boolean} <code>true</code> or <code>false</code>
       */
      isScrollable: function isScrollable() {
        return this._isScrollable();
      },

      /**
       * Detects whether this scroll container is scrollable or not.
       * @return {Boolean} <code>true</code> or <code>false</code>
       */
      _isScrollable: function _isScrollable() {
        return this._isScrollableX() || this._isScrollableY();
      },

      /**
       * Detects whether this scroll container is scrollable on x axis or not.
       * @return {Boolean} <code>true</code> or <code>false</code>
       */
      _isScrollableX: function _isScrollableX() {
        if (this.getLayoutParent() === null) {
          return false;
        }

        var parentWidth = this.getContainerElement().clientWidth;
        var contentWidth = this.getContentElement().scrollWidth;

        var scrollContentElement = this._getScrollContentElement();

        if (scrollContentElement) {
          contentWidth = qx.bom.element.Dimension.getWidth(scrollContentElement);
        }

        return parentWidth < contentWidth;
      },

      /**
       * Detects whether this scroll container is scrollable on y axis or not.
       * @return {Boolean} <code>true</code> or <code>false</code>
       */
      _isScrollableY: function _isScrollableY() {
        if (this.getLayoutParent() === null) {
          return false;
        }

        var parentHeight = this.getContainerElement().clientHeight;
        var contentHeight = this.getContentElement().scrollHeight;

        var scrollContentElement = this._getScrollContentElement();

        if (scrollContentElement) {
          contentHeight = qx.bom.element.Dimension.getHeight(scrollContentElement);
        }

        return parentHeight < contentHeight;
      },

      /**
       * Scrolls the wrapper contents to the widgets coordinates in a given
       * period.
       *
       * @param target {Element} the element to which the scroll container should scroll to.
       * @param time {Integer?0} Time slice in which scrolling should
       *              be done (in seconds).
       *
       */
      scrollToElement: function scrollToElement(target, time) {
        this._scrollToElement(target, time);
      },

      /**
      * Scrolls the wrapper contents to the widgets coordinates in a given
      * period.
      *
      * @param element {String} the element to which the scroll container should scroll to.
      * @param time {Integer?0} Time slice in which scrolling should be done (in seconds).
      *
      */
      _scrollToElement: function _scrollToElement(element, time) {
        if (this._getContentElement() && this._isScrollable()) {
          if (typeof time === "undefined") {
            time = 0;
          }

          var location = qx.bom.element.Location.getRelative(this._getContentElement(), element, "scroll", "scroll");

          var offset = this._getScrollOffset();

          this._scrollTo(-location.left - offset[0], -location.top - offset[1], time);
        }
      },

      /**
       *
       * Determines the scroll offset for the <code>_scrollToElement</code> method.
       * If a delegate is available, the method calls
       * <code>qx.ui.mobile.container.IScrollDelegate.getScrollOffset()</code> for offset calculation.
       *
       * @return {Array} an array with x,y offset.
       */
      _getScrollOffset: function _getScrollOffset() {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.getScrollOffset) {
          return delegate.getScrollOffset.bind(this)();
        } else {
          return [0, 0];
        }
      },

      /**
       * Scrolls the wrapper contents to the widgets coordinates in a given
       * period.
       *
       * @param widget {qx.ui.mobile.core.Widget} the widget, the scroll container should scroll to.
       * @param time {Integer} Time slice in which scrolling should
       *              be done.
       */
      scrollToWidget: function scrollToWidget(widget, time) {
        if (widget) {
          this._scrollToElement(widget.getContentElement(), time);
        }
      }
    },
    defer: function defer(statics) {
      if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
        qx.Class.include(statics, qx.ui.mobile.container.MIScroll);
      } else {
        qx.Class.include(statics, qx.ui.mobile.container.MNativeScroll);
      }
    },
    destruct: function destruct() {
      this.removeListener("appear", this._updateWaypoints, this);
      this._waypointsX = this._waypointsY = null;
    }
  });
  qx.ui.mobile.container.Scroll.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.VBox": {
        "construct": true
      },
      "qx.ui.mobile.container.INavigation": {},
      "qx.ui.mobile.layout.Card": {},
      "qx.ui.mobile.navigationbar.NavigationBar": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The navigation controller includes already a {@link qx.ui.mobile.navigationbar.NavigationBar}
   * and a {@link qx.ui.mobile.container.Composite} container with a {@link qx.ui.mobile.layout.Card} layout.
   * All widgets that implement the {@link qx.ui.mobile.container.INavigation}
   * interface can be added to the container. The added widget provide the title
   * widget and the left/right container, which will be automatically merged into
   * navigation bar.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var container = new qx.ui.mobile.container.Navigation();
   *   this.getRoot(container);
   *   var page = new qx.ui.mobile.page.NavigationPage();
   *   container.add(page);
   *   page.show();
   * </pre>
   */
  qx.Class.define("qx.ui.mobile.container.Navigation", {
    extend: qx.ui.mobile.container.Composite,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.mobile.container.Composite.constructor.call(this, new qx.ui.mobile.layout.VBox());
      this.__navigationBar__P_452_0 = this._createNavigationBar();

      if (this.__navigationBar__P_452_0) {
        this._add(this.__navigationBar__P_452_0);
      }

      this.__content__P_452_1 = this._createContent();

      this._add(this.__content__P_452_1, {
        flex: 1
      });
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "navigation"
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the navigation bar gets updated */
      "update": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __navigationBar__P_452_0: null,
      __content__P_452_1: null,
      __layout__P_452_2: null,
      // overridden
      add: function add(widget) {
        {
          this.assertInterface(widget, qx.ui.mobile.container.INavigation);
        }
        this.getContent().add(widget);
      },
      // overridden
      remove: function remove(widget) {
        {
          this.assertInterface(widget, qx.ui.mobile.container.INavigation);
        }
        this.getContent().remove(widget);
      },

      /**
       * Returns the content container. Add all your widgets to this container.
       *
       * @return {qx.ui.mobile.container.Composite} The content container
       */
      getContent: function getContent() {
        return this.__content__P_452_1;
      },

      /**
       * Returns the assigned card layout.
       * @return {qx.ui.mobile.layout.Card} assigned Card Layout.
       */
      getLayout: function getLayout() {
        return this.__layout__P_452_2;
      },

      /**
       * Returns the navigation bar.
       *
       * @return {qx.ui.mobile.navigationbar.NavigationBar} The navigation bar.
       */
      getNavigationBar: function getNavigationBar() {
        return this.__navigationBar__P_452_0;
      },

      /**
       * Creates the content container.
       *
       * @return {qx.ui.mobile.container.Composite} The created content container
       */
      _createContent: function _createContent() {
        this.__layout__P_452_2 = new qx.ui.mobile.layout.Card();

        this.__layout__P_452_2.addListener("updateLayout", this._onUpdateLayout, this);

        this.__layout__P_452_2.addListener("animationStart", this._onAnimationStart, this);

        this.__layout__P_452_2.addListener("animationEnd", this._onAnimationEnd, this);

        return new qx.ui.mobile.container.Composite(this.__layout__P_452_2);
      },

      /**
      * Handler for the "animationStart" event on the layout.
      */
      _onAnimationStart: function _onAnimationStart() {
        this.addCssClass("blocked");
      },

      /**
      * Handler for the "animationEnd" event on the layout.
      */
      _onAnimationEnd: function _onAnimationEnd() {
        this.removeCssClass("blocked");
      },

      /**
       * Event handler. Called when the "updateLayout" event occurs.
       *
       * @param evt {qx.event.type.Data} The causing event
       */
      _onUpdateLayout: function _onUpdateLayout(evt) {
        var data = evt.getData();
        var widget = data.widget;
        var action = data.action;

        if (action == "visible") {
          this._update(widget);
        }
      },

      /**
       * Updates the navigation bar depending on the set widget.
       *
       * @param widget {qx.ui.mobile.core.Widget} The widget that should be merged into the navigation bar.
       */
      _update: function _update(widget) {
        var navigationBar = this.getNavigationBar();

        this._setStyle("transitionDuration", widget.getNavigationBarToggleDuration() + "s");

        if (widget.isNavigationBarHidden()) {
          this.addCssClass("hidden");
        } else {
          navigationBar.show();
          this.removeCssClass("hidden");
        }

        navigationBar.removeAll();

        if (widget.basename) {
          this._setAttribute("data-target-page", widget.basename.toLowerCase());
        }

        var leftContainer = widget.getLeftContainer();

        if (leftContainer) {
          navigationBar.add(leftContainer);
        }

        var title = widget.getTitleWidget();

        if (title) {
          navigationBar.add(title, {
            flex: 1
          });
        }

        var rightContainer = widget.getRightContainer();

        if (rightContainer) {
          navigationBar.add(rightContainer);
        }

        this.fireDataEvent("update", widget);
      },

      /**
       * Creates the navigation bar.
       *
       * @return {qx.ui.mobile.navigationbar.NavigationBar} The created navigation bar
       */
      _createNavigationBar: function _createNavigationBar() {
        return new qx.ui.mobile.navigationbar.NavigationBar();
      }
    },
    destruct: function destruct() {
      this.getLayout().removeListener("animationStart", this._onAnimationStart, this);
      this.getLayout().removeListener("animationEnd", this._onAnimationEnd, this);

      this._disposeObjects("__navigationBar__P_452_0", "__content__P_452_1", "__layout__P_452_2");

      this.__navigationBar__P_452_0 = this.__content__P_452_1 = this.__layout__P_452_2 = null;
    }
  });
  qx.ui.mobile.container.Navigation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.event.handler.Transition": {},
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.layout.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.CardAnimation": {
        "construct": true
      },
      "qx.bom.client.CssTransform": {},
      "qx.bom.AnimationFrame": {},
      "qx.ui.mobile.core.MResize": {},
      "qx.event.Registration": {},
      "qx.bom.element.Class": {},
      "qx.bom.element.Animation": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.transform.3d": {
          "className": "qx.bom.client.CssTransform"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * A card layout.
   *
   * The card layout lays out widgets in a stack. Call show to display a widget.
   * Only the widget which show method is called is displayed. All other widgets are excluded.
   *
   *
   * *Example*
   *
   * Here is a little example of how to use the Card layout.
   *
   * <pre class="javascript">
   * var layout = new qx.ui.mobile.layout.Card());
   * var container = new qx.ui.mobile.container.Composite(layout);
   *
   * var label1 = new qx.ui.mobile.basic.Label("1");
   * container.add(label1);
   * var label2 = new qx.ui.mobile.basic.Label("2");
   * container.add(label2);
   *
   * label2.show();
   * </pre>
   *
   * @use(qx.event.handler.Transition)
   */
  qx.Class.define("qx.ui.mobile.layout.Card", {
    extend: qx.ui.mobile.layout.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.mobile.layout.Abstract.constructor.call(this);
      this.__cardAnimation__P_473_0 = new qx.ui.mobile.layout.CardAnimation();
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the animation of a page transition starts */
      animationStart: "qx.event.type.Data",

      /** Fired when the animation of a page transition ends */
      animationEnd: "qx.event.type.Data"
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      /** The default animation to use for page transition */
      defaultAnimation: {
        check: "String",
        init: "slide"
      },

      /** Flag which indicates, whether animation is needed, or widgets should only swap. */
      showAnimation: {
        check: "Boolean",
        init: true
      },

      /** Transition duration of each animation. */
      animationDuration: {
        check: "Integer",
        init: 350
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      __nextWidget__P_473_1: null,
      __currentWidget__P_473_2: null,
      __inAnimation__P_473_3: null,
      __animation__P_473_4: null,
      __reverse__P_473_5: null,
      __cardAnimation__P_473_0: null,
      // overridden
      _getCssClasses: function _getCssClasses() {
        return ["layout-card", "qx-vbox"];
      },
      // overridden
      connectToChildWidget: function connectToChildWidget(widget) {
        qx.ui.mobile.layout.Card.prototype.connectToChildWidget.base.call(this);

        if (widget) {
          widget.addCssClass("layout-card-item");
          widget.addCssClass("qx-flex1");
          widget.exclude();
        }
      },
      // overridden
      disconnectFromChildWidget: function disconnectFromChildWidget(widget) {
        qx.ui.mobile.layout.Card.prototype.disconnectFromChildWidget.base.call(this);
        widget.removeCssClass("layout-card-item");
      },
      // overridden
      updateLayout: function updateLayout(widget, action, properties) {
        if (action == "visible") {
          this._showWidget(widget, properties);
        }

        qx.ui.mobile.layout.Card.prototype.updateLayout.base.call(this, widget, action, properties);
      },

      /**
       * Setter for this.__cardAnimation.
       * @param value {qx.ui.mobile.layout.CardAnimation} the new CardAnimation object.
       */
      setCardAnimation: function setCardAnimation(value) {
        this.__cardAnimation__P_473_0 = value;
      },

      /**
       * Getter for this.__cardAnimation.
       * @return {qx.ui.mobile.layout.CardAnimation} the current CardAnimation object.
       */
      getCardAnimation: function getCardAnimation() {
        return this.__cardAnimation__P_473_0;
      },

      /**
       * Shows the widget with the given properties.
       *
       * @param widget {qx.ui.mobile.core.Widget} The target widget
       * @param properties {Map} The layout properties to set. Key / value pairs.
       */
      _showWidget: function _showWidget(widget, properties) {
        if (this.__nextWidget__P_473_1 == widget) {
          return;
        }

        if (this.__inAnimation__P_473_3) {
          this.__stopAnimation__P_473_6();
        }

        this.__nextWidget__P_473_1 = widget;

        if (this.__currentWidget__P_473_2 && this.getShowAnimation() && qx.core.Environment.get("css.transform.3d")) {
          properties = properties || {}; // both are explicit identity checks for null

          if (properties.animation === null || this.getCardAnimation().getMap()[properties.animation] === null) {
            this._swapWidget();

            return;
          }

          this.__animation__P_473_4 = properties.animation || this.getDefaultAnimation();

          if (properties.action && properties.action === "back") {
            this.__reverse__P_473_5 = true;
          } else {
            properties.reverse = properties.reverse === null ? false : properties.reverse;
            this.__reverse__P_473_5 = properties.reverse;
          }

          qx.bom.AnimationFrame.request(function () {
            this.__startAnimation__P_473_7(widget);
          }, this);
        } else {
          this._swapWidget();
        }
      },

      /**
       * Excludes the current widget and sets the next widget to the current widget.
       */
      _swapWidget: function _swapWidget() {
        if (this.__currentWidget__P_473_2) {
          this.__currentWidget__P_473_2.removeCssClass("active");

          this.__currentWidget__P_473_2.exclude();
        }

        this.__currentWidget__P_473_2 = this.__nextWidget__P_473_1;

        this.__currentWidget__P_473_2.addCssClass("active");
      },

      /**
       * Fix size, only if widget has mixin MResize set,
       * and nextWidget is set.
       *
       * @param widget {qx.ui.mobile.core.Widget} The target widget which should have a fixed size.
       */
      _fixWidgetSize: function _fixWidgetSize(widget) {
        if (widget) {
          var hasResizeMixin = qx.Class.hasMixin(widget.constructor, qx.ui.mobile.core.MResize);

          if (hasResizeMixin) {
            // Size has to be fixed for animation.
            widget.fixSize();
          }
        }
      },

      /**
       * Releases recently fixed widget size (width/height). This is needed for allowing further
       * flexbox layouting.
       *
       * @param widget {qx.ui.mobile.core.Widget} The target widget which should have a flexible size.
       */
      _releaseWidgetSize: function _releaseWidgetSize(widget) {
        if (widget) {
          var hasResizeMixin = qx.Class.hasMixin(widget.constructor, qx.ui.mobile.core.MResize);

          if (hasResizeMixin) {
            // Size has to be released after animation.
            widget.releaseFixedSize();
          }
        }
      },

      /**
       * Starts the animation for the page transition.
       *
       * @param widget {qx.ui.mobile.core.Widget} The target widget
       */
      __startAnimation__P_473_7: function __startAnimation__P_473_7(widget) {
        if (widget.isDisposed()) {
          return;
        } // Fix size of current and next widget, then start animation.


        this.__inAnimation__P_473_3 = true;
        this.fireDataEvent("animationStart", [this.__currentWidget__P_473_2, widget]);

        var fromElement = this.__currentWidget__P_473_2.getContainerElement();

        var toElement = widget.getContainerElement();
        qx.event.Registration.addListener(fromElement, "animationEnd", this._onAnimationEnd, this);
        qx.event.Registration.addListener(toElement, "animationEnd", this._onAnimationEnd, this);

        var fromCssClasses = this.__getAnimationClasses__P_473_8("out");

        var toCssClasses = this.__getAnimationClasses__P_473_8("in");

        this._widget.addCssClass("animationParent");

        var toElementAnimation = this.__cardAnimation__P_473_0.getAnimation(this.__animation__P_473_4, "in", this.__reverse__P_473_5);

        var fromElementAnimation = this.__cardAnimation__P_473_0.getAnimation(this.__animation__P_473_4, "out", this.__reverse__P_473_5);

        qx.bom.element.Class.addClasses(toElement, toCssClasses);
        qx.bom.element.Class.addClasses(fromElement, fromCssClasses);
        qx.bom.element.Animation.animate(toElement, toElementAnimation);
        qx.bom.element.Animation.animate(fromElement, fromElementAnimation);
      },

      /**
       * Event handler. Called when the animation of the page transition ends.
       *
       * @param evt {qx.event.type.Event} The causing event
       */
      _onAnimationEnd: function _onAnimationEnd(evt) {
        this.__stopAnimation__P_473_6();

        this.fireDataEvent("animationEnd", [this.__currentWidget__P_473_2, this.__nextWidget__P_473_1]);
      },

      /**
       * Stops the animation for the page transition.
       */
      __stopAnimation__P_473_6: function __stopAnimation__P_473_6() {
        if (this.__inAnimation__P_473_3) {
          var fromElement = this.__currentWidget__P_473_2.getContainerElement();

          var toElement = this.__nextWidget__P_473_1.getContainerElement();

          qx.event.Registration.removeListener(fromElement, "animationEnd", this._onAnimationEnd, this);
          qx.event.Registration.removeListener(toElement, "animationEnd", this._onAnimationEnd, this);
          qx.bom.element.Class.removeClasses(fromElement, this.__getAnimationClasses__P_473_8("out"));
          qx.bom.element.Class.removeClasses(toElement, this.__getAnimationClasses__P_473_8("in"));

          this._swapWidget();

          this._widget.removeCssClass("animationParent");

          this.__inAnimation__P_473_3 = false;
        }
      },

      /**
       * Returns the animation CSS classes for a given direction. The direction
       * can be <code>in</code> or <code>out</code>.
       *
       * @param direction {String} The direction of the animation. <code>in</code> or <code>out</code>.
       * @return {String[]} The CSS classes for the set animation.
       */
      __getAnimationClasses__P_473_8: function __getAnimationClasses__P_473_8(direction) {
        var classes = ["animationChild", this.__animation__P_473_4, direction];

        if (this.__reverse__P_473_5) {
          classes.push("reverse");
        }

        return classes;
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__cardAnimation__P_473_0");
    }
  });
  qx.ui.mobile.layout.Card.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A navigation bar widget.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var bar = new qx.ui.mobile.navigationbar.NavigationBar();
   *   var backButton = new qx.ui.mobile.navigationbar.BackButton();
   *   bar.add(backButton);
   *   var title = new qx.ui.mobile.navigationbar.Title();
   *   var.add(title, {flex:1});
   *
   *   this.getRoot.add(bar);
   * </pre>
   *
   * This example creates a navigation bar and adds a back button and a title to it.
   */
  qx.Class.define("qx.ui.mobile.navigationbar.NavigationBar", {
    extend: qx.ui.mobile.container.Composite,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout);

      if (!layout) {
        this.setLayout(new qx.ui.mobile.layout.HBox().set({
          alignY: "middle"
        }));
      }
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "navigationbar"
      }
    }
  });
  qx.ui.mobile.navigationbar.NavigationBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.util.Animation": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
   * Christopher Zuendorf (czuendorf)
  
   ************************************************************************ */

  /**
   * Contains all animations which are needed for page transitions on {@link qx.ui.mobile.layout.Card}.
   * Provides a convenience method {@link qx.ui.mobile.layout.CardAnimation#getAnimation} which
   * makes it possibility to resolve the right animation for a pageTransition out of the cardAnimationMap.
   */
  qx.Class.define("qx.ui.mobile.layout.CardAnimation", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this._cardAnimationsMap = {
        "none": null,
        "slide": {
          "in": qx.util.Animation.SLIDE_LEFT_IN,
          "out": qx.util.Animation.SLIDE_LEFT_OUT,
          "reverse": {
            "in": qx.util.Animation.SLIDE_RIGHT_IN,
            "out": qx.util.Animation.SLIDE_RIGHT_OUT
          }
        },
        "fade": {
          "in": qx.util.Animation.FADE_IN,
          "out": qx.util.Animation.FADE_OUT,
          "reverse": {
            "in": qx.util.Animation.FADE_IN,
            "out": qx.util.Animation.FADE_OUT
          }
        },
        "pop": {
          "in": qx.util.Animation.POP_IN,
          "out": qx.util.Animation.POP_OUT,
          "reverse": {
            "in": qx.util.Animation.POP_IN,
            "out": qx.util.Animation.POP_OUT
          }
        },
        "slideup": {
          "in": qx.util.Animation.SLIDE_UP_IN,
          "out": qx.util.Animation.SLIDE_UP_OUT,
          "reverse": {
            "in": qx.util.Animation.SLIDE_DOWN_IN,
            "out": qx.util.Animation.SLIDE_DOWN_OUT
          }
        },
        "flip": {
          "in": qx.util.Animation.FLIP_LEFT_IN,
          "out": qx.util.Animation.FLIP_LEFT_OUT,
          "reverse": {
            "in": qx.util.Animation.FLIP_RIGHT_IN,
            "out": qx.util.Animation.FLIP_RIGHT_OUT
          }
        },
        "swap": {
          "in": qx.util.Animation.SWAP_LEFT_IN,
          "out": qx.util.Animation.SWAP_LEFT_OUT,
          "reverse": {
            "in": qx.util.Animation.SWAP_RIGHT_IN,
            "out": qx.util.Animation.SWAP_RIGHT_OUT
          }
        },
        "cube": {
          "in": qx.util.Animation.CUBE_LEFT_IN,
          "out": qx.util.Animation.CUBE_LEFT_OUT,
          "reverse": {
            "in": qx.util.Animation.CUBE_RIGHT_IN,
            "out": qx.util.Animation.CUBE_RIGHT_OUT
          }
        }
      };
    },
    members: {
      _cardAnimationsMap: null,

      /**
      * Returns a map with properties for {@link qx.bom.element.Animation} according to the given input parameters.
      * @param animationName {String} the animation key
      * @param direction {String} the animation direction ("in" | "out")
      * @param reverse {Boolean} flag which indicates whether it is a reverse animation.
      * @return {Map} animation property map, intended for the usage with {@link qx.bom.element.Animation}
      */
      getAnimation: function getAnimation(animationName, direction, reverse) {
        {
          if (!reverse) {
            this.assertNotUndefined(this._cardAnimationsMap[animationName], "Animation '" + animationName + "' is not defined.");
            this.assertNotUndefined(this._cardAnimationsMap[animationName][direction], "Animation '" + animationName + " " + direction + "' is not defined.");
          } else {
            this.assertNotUndefined(this._cardAnimationsMap[animationName], "Animation Reverse'" + animationName + "' is not defined.");
            this.assertNotUndefined(this._cardAnimationsMap[animationName]["reverse"], "Animation Reverse'" + animationName + "' is not defined.");
            this.assertNotUndefined(this._cardAnimationsMap[animationName]["reverse"][direction], "Animation Reverse'" + animationName + " " + direction + "' is not defined.");
          }
        }
        var animation = this._cardAnimationsMap[animationName];
        var animationObject = {};

        if (!reverse) {
          animationObject = animation[direction];
        } else {
          animationObject = animation["reverse"][direction];
        }

        return animationObject;
      },

      /**
       * Getter for the cardAnimationsMap.
       * @return {Map} the cardAnimationsMap.
       */
      getMap: function getMap() {
        return this._cardAnimationsMap;
      }
    },
    destruct: function destruct() {
      this._cardAnimationsMap = null;
    }
  });
  qx.ui.mobile.layout.CardAnimation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
   * Christopher Zuendorf (czuendorf)
  
   ************************************************************************ */

  /**
   * Contains property maps for the usage with qx.bom.element.Animation {@link qx.bom.element.Animation}.
   * These animations can be used for page transitions for example.
   */
  qx.Bootstrap.define("qx.util.Animation", {
    statics: {
      /** Target slides in from right. */
      SLIDE_LEFT_IN: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            translate: ["100%"]
          },
          100: {
            translate: ["0%"]
          }
        }
      },

      /** Target slides out from right.*/
      SLIDE_LEFT_OUT: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            translate: ["0px"]
          },
          100: {
            translate: ["-100%"]
          }
        }
      },

      /** Target slides in from left.*/
      SLIDE_RIGHT_IN: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            translate: ["-100%"]
          },
          100: {
            translate: ["0%"]
          }
        }
      },

      /** Target slides out from left.*/
      SLIDE_RIGHT_OUT: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            translate: ["0px"]
          },
          100: {
            translate: ["100%"]
          }
        }
      },

      /** Target fades in. */
      FADE_IN: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            opacity: ["0"]
          },
          100: {
            opacity: ["1"]
          }
        }
      },

      /** Target fades out. */
      FADE_OUT: {
        duration: 350,
        timing: "linear",
        origin: "bottom center",
        keyFrames: {
          0: {
            opacity: ["1"]
          },
          100: {
            opacity: ["0"]
          }
        }
      },

      /** Target pops in from center. */
      POP_IN: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            scale: [".2", ".2"]
          },
          100: {
            scale: ["1", "1"]
          }
        }
      },

      /** Target pops out from center. */
      POP_OUT: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            scale: ["1", "1"]
          },
          100: {
            scale: [".2", ".2"]
          }
        }
      },

      /** Target shrinks its height. */
      SHRINK_HEIGHT: {
        duration: 400,
        timing: "linear",
        origin: "top center",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["1", "1"],
            opacity: 1
          },
          100: {
            scale: ["1", "0"],
            opacity: 0
          }
        }
      },

      /** Target grows its height. */
      GROW_HEIGHT: {
        duration: 400,
        timing: "linear",
        origin: "top center",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["1", "0"],
            opacity: 0
          },
          100: {
            scale: ["1", "1"],
            opacity: 1
          }
        }
      },

      /** Target shrinks its width. */
      SHRINK_WIDTH: {
        duration: 400,
        timing: "linear",
        origin: "left center",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["1", "1"],
            opacity: 1
          },
          100: {
            scale: ["0", "1"],
            opacity: 0
          }
        }
      },

      /** Target grows its width. */
      GROW_WIDTH: {
        duration: 400,
        timing: "linear",
        origin: "left center",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["0", "1"],
            opacity: 0
          },
          100: {
            scale: ["1", "1"],
            opacity: 1
          }
        }
      },

      /** Target shrinks in both width and height. */
      SHRINK: {
        duration: 400,
        timing: "linear",
        origin: "left top",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["1", "1"],
            opacity: 1
          },
          100: {
            scale: ["0", "0"],
            opacity: 0
          }
        }
      },

      /** Target grows in both width and height. */
      GROW: {
        duration: 400,
        timing: "linear",
        origin: "left top",
        keep: 100,
        keyFrames: {
          0: {
            scale: ["0", "0"],
            opacity: 0
          },
          100: {
            scale: ["1", "1"],
            opacity: 1
          }
        }
      },

      /** Target slides in to top. */
      SLIDE_UP_IN: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            translate: ["0px", "100%"]
          },
          100: {
            translate: ["0px", "0px"]
          }
        }
      },

      /** Target slides out to top.*/
      SLIDE_UP_OUT: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            translate: ["0px", "0px"]
          },
          100: {
            translate: ["0px", "0px"]
          }
        }
      },

      /** Target slides out to bottom.*/
      SLIDE_DOWN_IN: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            translate: ["0px", "0px"]
          },
          100: {
            translate: ["0px", "0px"]
          }
        }
      },

      /** Target slides down to bottom.*/
      SLIDE_DOWN_OUT: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            translate: ["0px", "0px"]
          },
          100: {
            translate: ["0px", "100%"]
          }
        }
      },

      /** Target flips (turns) left from back side to front side. */
      FLIP_LEFT_IN: {
        duration: 350,
        timing: "linear",
        origin: "center",
        keyFrames: {
          0: {
            opacity: 0
          },
          49: {
            opacity: 0
          },
          50: {
            rotate: ["0deg", "90deg"],
            scale: [".8", "1"],
            opacity: 1
          },
          100: {
            rotate: ["0deg", "0deg"],
            scale: ["1", "1"],
            opacity: 1
          }
        }
      },

      /** Target flips (turns) left from front side to back side. */
      FLIP_LEFT_OUT: {
        duration: 350,
        timing: "linear",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            scale: ["1", "1"]
          },
          100: {
            rotate: ["0deg", "-180deg"],
            scale: [".8", "1"]
          }
        }
      },

      /** Target flips (turns) right from back side to front side. */
      FLIP_RIGHT_IN: {
        duration: 350,
        timing: "linear",
        origin: "center center",
        keyFrames: {
          0: {
            opacity: 0
          },
          49: {
            opacity: 0
          },
          50: {
            rotate: ["0deg", "-90deg"],
            scale: [".8", "1"],
            opacity: 1
          },
          100: {
            rotate: ["0deg", "0deg"],
            scale: ["1", "1"],
            opacity: 1
          }
        }
      },

      /** Target flips (turns) right from front side to back side. */
      FLIP_RIGHT_OUT: {
        duration: 350,
        timing: "linear",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            scale: ["1", "1"]
          },
          100: {
            rotate: ["0deg", "180deg"],
            scale: [".8", "1"]
          }
        }
      },

      /** Target moves in to left. */
      SWAP_LEFT_IN: {
        duration: 700,
        timing: "ease-out",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "-70deg"],
            translate: ["0px", "0px", "-800px"],
            opacity: "0"
          },
          35: {
            rotate: ["0deg", "-20deg"],
            translate: ["-180px", "0px", "-400px"],
            opacity: "1"
          },
          100: {
            rotate: ["0deg", "0deg"],
            translate: ["0px", "0px", "0px"],
            opacity: "1"
          }
        }
      },

      /** Target moves out to left.  */
      SWAP_LEFT_OUT: {
        duration: 700,
        timing: "ease-out",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            translate: ["0px", "0px", "0px"],
            opacity: "1"
          },
          35: {
            rotate: ["0deg", "20deg"],
            translate: ["-180px", "0px", "-400px"],
            opacity: ".5"
          },
          100: {
            rotate: ["0deg", "70deg"],
            translate: ["0px", "0px", "-800px"],
            opacity: "0"
          }
        }
      },

      /** Target moves in to right. */
      SWAP_RIGHT_IN: {
        duration: 700,
        timing: "ease-out",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "70deg"],
            translate: ["0px", "0px", "-800px"],
            opacity: "0"
          },
          35: {
            rotate: ["0deg", "20deg"],
            translate: ["-180px", "0px", "-400px"],
            opacity: "1"
          },
          100: {
            rotate: ["0deg", "0deg"],
            translate: ["0px", "0px", "0px"],
            opacity: "1"
          }
        }
      },

      /** Target moves out to right. */
      SWAP_RIGHT_OUT: {
        duration: 700,
        timing: "ease-out",
        origin: "center center",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            translate: ["0px", "0px", "0px"],
            opacity: "1"
          },
          35: {
            rotate: ["0deg", "-20deg"],
            translate: ["180px", "0px", "-400px"],
            opacity: ".5"
          },
          100: {
            rotate: ["0deg", "-70deg"],
            translate: ["0px", "0px", "-800px"],
            opacity: "0"
          }
        }
      },

      /** Target moves in with cube animation from right to left.  */
      CUBE_LEFT_IN: {
        duration: 550,
        timing: "linear",
        origin: "100% 50%",
        keyFrames: {
          0: {
            rotate: ["0deg", "90deg"],
            scale: ".5",
            translate: ["0", "0", "0px"],
            opacity: [".5"]
          },
          100: {
            rotate: ["0deg", "0deg"],
            scale: "1",
            translate: ["0", "0", "0"],
            opacity: ["1"]
          }
        }
      },

      /** Target moves out with cube animation from right to left.  */
      CUBE_LEFT_OUT: {
        duration: 550,
        timing: "linear",
        origin: "0% 50%",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            scale: "1",
            translate: ["0", "0", "0px"],
            opacity: ["1"]
          },
          100: {
            rotate: ["0deg", "-90deg"],
            scale: ".5",
            translate: ["0", "0", "0"],
            opacity: [".5"]
          }
        }
      },

      /** Target moves in with cube animation from left to right.  */
      CUBE_RIGHT_IN: {
        duration: 550,
        timing: "linear",
        origin: "0% 50%",
        keyFrames: {
          0: {
            rotate: ["0deg", "-90deg"],
            scale: ".5",
            translate: ["0", "0", "0px"],
            opacity: [".5"]
          },
          100: {
            rotate: ["0deg", "0deg"],
            scale: "1",
            translate: ["0", "0", "0"],
            opacity: ["1"]
          }
        }
      },

      /** Target moves out with cube animation from left to right.  */
      CUBE_RIGHT_OUT: {
        duration: 550,
        timing: "linear",
        origin: "100% 50%",
        keyFrames: {
          0: {
            rotate: ["0deg", "0deg"],
            scale: "1",
            translate: ["0", "0", "0px"],
            opacity: ["1"]
          },
          100: {
            rotate: ["0deg", "90deg"],
            scale: ".5",
            translate: ["0", "0", "0"],
            opacity: [".5"]
          }
        }
      }
    }
  });
  qx.util.Animation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.data.Array": {
        "construct": true
      },
      "qx.bom.AnimationFrame": {},
      "qx.ui.mobile.container.Scroll": {},
      "qx.bom.element.Style": {},
      "qx.ui.mobile.list.List": {},
      "qx.Bootstrap": {},
      "qx.util.DisposeUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   *
   * The picker widget gives the user the possibility to select a value out of an array
   * of values. The picker widget can be added to a {@link qx.ui.mobile.dialog.Popup} or to any other container.
   *
   * The picker widget is able to display multiple picker slots, for letting the user choose
   * several values at one time, in one single control.
   *
   * You can add an array with objects which contain the keys <code>title</code>, a <code>subtitle</code> or an <code>image</code> (all optional).
   *
   * <pre>
   * var picker = new qx.ui.mobile.control.Picker();
   * picker.setHeight(200);
   * picker.addListener("changeSelection", function(evt) {
   *   var data = evt.getData();
   * },this);
   *
   * var slotData1 = [{title:"Windows Phone"}, {title:"iOS",subtitle:"Version 7.1"}, {title:"Android"}];
   * var slotData2 = [{title:"Tablet"}, {title:"Smartphone"}, {title:"Phablet"}];
   *
   * picker.addSlot(new qx.data.Array(slotData1));
   * picker.addSlot(new qx.data.Array(slotData2));
   * </pre>
   *
   */
  qx.Class.define("qx.ui.mobile.control.Picker", {
    extend: qx.ui.mobile.container.Composite,
    construct: function construct() {
      qx.ui.mobile.container.Composite.constructor.call(this);
      this._pickerModel = new qx.data.Array();
      this._slots = new qx.data.Array();
      this.addListener("appear", this._onAppear, this);
      this.initVisibleItems();
    },
    events: {
      /**
       * Fired when the selection of a slot has changed.
       * Example:
       * <code> {
       *   index: 0,
       *   item: [Object],
       *   slot: 0
       * }</code>
       */
      changeSelection: "qx.event.type.Data"
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "picker"
      },

      /**
      * Controls how much visible items are shown inside the picker.
      */
      visibleItems: {
        init: 5,
        check: [3, 5, 7, 9],
        apply: "_applyVisibleItems"
      },

      /**
      * Controls the picker height.
      */
      height: {
        init: 200,
        check: "Number"
      }
    },
    members: {
      _slots: null,
      _pickerModel: null,

      /**
      * Handler for <code>appear</code> event of this widget.
      */
      _onAppear: function _onAppear() {
        var itemHeight = this._calcItemHeight();

        this._slots.forEach(function (slot, index) {
          qx.bom.AnimationFrame.request(function () {
            slot.container.scrollTo(0, slot.selectedIndex * itemHeight);
          });
        }, this);
      },
      // property apply
      _applyVisibleItems: function _applyVisibleItems(value) {
        this._setAttribute("data-items", value);
      },

      /**
      * Returns the internal used picker model which contains one or more picker slot models.
      * @return {qx.data.Array} the picker model.
      */
      getModel: function getModel() {
        return this._pickerModel;
      },

      /**
       * Creates a picker slot.
       * @param slotModel {qx.data.Array} the picker slot model.
       * @param slotIndex {Number} the index of this slot.
       * @param delegate {qx.ui.mobile.list.IListDelegate?null} the list delegate object for this slot list.
       * @return {qx.ui.mobile.container.Scroll} the picker slot as a scroll container.
       */
      _createPickerSlot: function _createPickerSlot(slotModel, slotIndex, delegate) {
        var scrollContainer = new qx.ui.mobile.container.Scroll({
          "snap": ".list-item",
          "vScrollbar": false
        });
        scrollContainer.setWaypointsY([".list-item"]);
        qx.bom.element.Style.set(scrollContainer.getContentElement(), "height", this.getHeight() + "px");
        var slot = {
          container: scrollContainer,
          selectedIndex: 0
        };

        this._slots.push(slot);

        scrollContainer.addListener("waypoint", this._onWaypoint, {
          self: this,
          slot: slot,
          slotIndex: slotIndex,
          slotModel: slotModel
        });
        var list = new qx.ui.mobile.list.List(delegate);
        list.setItemHeight(this._calcItemHeight());
        list.addListener("changeSelection", this._onChangeSelection, {
          self: this,
          slotIndex: slotIndex
        });
        list.setModel(slotModel);
        var slotWrapper = new qx.ui.mobile.container.Composite(); // Generate placeholder items at before and after picker data list,
        // for making sure the first and last item can be scrolled
        // to the center of the picker.

        var placeholderItemCount = Math.floor(this.getVisibleItems() / 2);

        for (var i = 0; i < placeholderItemCount; i++) {
          slotWrapper.add(this._createPlaceholderItem());
        }

        slotWrapper.add(list);

        for (var j = 0; j < placeholderItemCount; j++) {
          slotWrapper.add(this._createPlaceholderItem());
        }

        scrollContainer.add(slotWrapper);
        this.add(scrollContainer);
        scrollContainer.refresh();
        return scrollContainer;
      },

      /**
      * Creates a placeholder list item, for making sure the selected item is vertically centered.
      * @return {qx.ui.mobile.container.Composite} the placeholder list item.
      */
      _createPlaceholderItem: function _createPlaceholderItem() {
        var placeholderItem = new qx.ui.mobile.container.Composite();
        qx.bom.element.Style.set(placeholderItem.getContentElement(), "minHeight", this._calcItemHeight() + "px");
        placeholderItem.addCssClass("list-item");
        placeholderItem.addCssClass("placeholder-item");
        return placeholderItem;
      },

      /**
      * Calculates the item height of a picker item.
      * @return {Number} height of the picker item.
      */
      _calcItemHeight: function _calcItemHeight() {
        return this.getHeight() / this.getVisibleItems();
      },

      /**
      * Handler for <code>changeSelection</code> event on picker list.
      * @param evt {qx.event.type.Data} the events data.
      */
      _onChangeSelection: function _onChangeSelection(evt) {
        qx.Bootstrap.bind(this.self.setSelectedIndex, this.self, this.slotIndex, evt.getData()).call();
      },

      /**
      * Handler for <code>waypoint</code> event on scroll container.
      * @param evt {qx.event.type.Data} the waypoint data.
      */
      _onWaypoint: function _onWaypoint(evt) {
        var elementIndex = evt.getData().element;
        this.slot.selectedIndex = elementIndex;
        this.self.fireDataEvent("changeSelection", {
          index: elementIndex,
          item: this.slotModel.getItem(elementIndex),
          slot: this.slotIndex
        });
      },

      /**
      * Getter for the selectedIndex of a picker slot, identified by its index.
      * @param slotIndex {Integer} the index of the target picker slot.
      * @return {Integer} the index of the target picker slot, or null if slotIndex is unknown.
      */
      getSelectedIndex: function getSelectedIndex(slotIndex) {
        return this._slots.getItem(slotIndex).selectedIndex;
      },

      /**
       * Setter for the selectedIndex of a picker slot, identified by its index.
       * @param slotIndex {Integer} the index of the target picker slot.
       * @param selectedIndex {Integer} the selectedIndex of the slot.
       */
      setSelectedIndex: function setSelectedIndex(slotIndex, selectedIndex) {
        var slot = this._slots.getItem(slotIndex);

        slot.selectedIndex = selectedIndex;

        if (this.isVisible()) {
          slot.container.scrollTo(0, selectedIndex * this._calcItemHeight());
        }
      },

      /**
       * Returns the picker slot count, added to this picker.
       * @return {Integer} count of picker slots.
       */
      getSlotCount: function getSlotCount() {
        return this._pickerModel.getLength();
      },

      /**
       * Adds an picker slot to the end of the array.
       * @param slotModel {qx.data.Array} the picker slot model to display.
       * @param delegate {qx.ui.mobile.list.IListDelegate?null} the list delegate object for this slot.
       */
      addSlot: function addSlot(slotModel, delegate) {
        if (slotModel !== null && slotModel instanceof qx.data.Array) {
          this._pickerModel.push(slotModel);

          var slotIndex = this._pickerModel.length - 1;

          var scrollContainer = this._createPickerSlot(slotModel, slotIndex, delegate);

          slotModel.addListener("changeBubble", this._onSlotDataChange, scrollContainer);
          slotModel.addListener("change", this._onSlotDataChange, scrollContainer);
        }
      },

      /**
       * Removes the picker slot at the given slotIndex.
       * @param slotIndex {Integer} the index of the target picker slot.
       */
      removeSlot: function removeSlot(slotIndex) {
        if (this._pickerModel.length > slotIndex && slotIndex > -1) {
          var slotModel = this._pickerModel.getItem(slotIndex);

          var scrollContainer = this._slots.getItem(slotIndex).container;

          slotModel.removeListener("changeBubble", this._onSlotDataChange, scrollContainer);
          slotModel.removeListener("change", this._onSlotDataChange, scrollContainer);
          qx.util.DisposeUtil.destroyContainer(scrollContainer);

          this._pickerModel.removeAt(slotIndex);

          this._slots.removeAt(slotIndex);
        }
      },

      /**
      * Handles the <code>changeBubble</code> and <codechange></code> event on a picker slot model.
      */
      _onSlotDataChange: function _onSlotDataChange() {
        window.setTimeout(function () {
          this.refresh();
        }.bind(this), 0);
      }
    },
    destruct: function destruct() {
      this._pickerModel.dispose();

      this._slots.dispose();

      qx.util.DisposeUtil.destroyContainer(this);
    }
  });
  qx.ui.mobile.control.Picker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.list.provider.Provider": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.bom.element.Class": {},
      "qx.bom.element.Attribute": {},
      "qx.dom.Element": {},
      "qx.bom.element.Dimension": {},
      "qx.bom.element.Style": {},
      "qx.bom.AnimationFrame": {},
      "qx.lang.Type": {},
      "qx.bom.Selector": {},
      "qx.lang.Object": {},
      "qx.util.Delegate": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The list widget displays the data of a model in a list.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *
   *    // Data for the list
   *    var data = [
   *       {title : "Row1", subtitle : "Sub1"},
   *       {title : "Row2", subtitle : "Sub2"},
   *       {title : "Row3", subtitle : "Sub3"}
   *   ];
   *
   *   // Create the list with a delegate that
   *   var list = new qx.ui.mobile.list.List({
   *     configureItem: function(item, data, row)
   *     {
   *       item.setImage("path/to/image.png");
   *       item.setTitle(data.title);
   *       item.setSubtitle(data.subtitle);
   *     },
   *
   *     configureGroupItem: function(item, data) {
   *       item.setTitle(data.title);
   *     },
   *
   *     group: function(data, row) {
   *      return {
   *       title: row < 2 ? "Selectable" : "Unselectable"
   *     };
   *    }
   *   });
   *
   *   // Set the model of the list
   *   list.setModel(new qx.data.Array(data));
   *
   *   // Add an changeSelection event
   *   list.addListener("changeSelection", function(evt) {
   *     alert("Index: " + evt.getData())
   *   }, this);
   *
   *   this.getRoot().add(list);
   * </pre>
   *
   * This example creates a list with a delegate that configures the list item with
   * the given data. A listener for the event {@link #changeSelection} is added.
   */
  qx.Class.define("qx.ui.mobile.list.List", {
    extend: qx.ui.mobile.core.Widget,

    /**
     * @param delegate {qx.ui.mobile.list.IListDelegate?null} The {@link #delegate} to use
     */
    construct: function construct(delegate) {
      qx.ui.mobile.core.Widget.constructor.call(this);
      this.__provider__P_474_0 = new qx.ui.mobile.list.provider.Provider(this);
      this.addListener("tap", this._onTap, this);
      this.addListener("trackstart", this._onTrackStart, this);
      this.addListener("track", this._onTrack, this);
      this.addListener("trackend", this._onTrackEnd, this);

      if (delegate) {
        this.setDelegate(delegate);
      } else {
        this.setDelegate(this);
      }

      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      }
    },
    events: {
      /**
       * Fired when the selection is changed.
       */
      changeSelection: "qx.event.type.Data",

      /**
       * Fired when the group selection is changed.
       */
      changeGroupSelection: "qx.event.type.Data",

      /**
       * Fired when an item should be removed from list.
       */
      removeItem: "qx.event.type.Data"
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "list"
      },

      /**
       * Delegation object which can have one or more functions defined by the
       * {@link qx.ui.mobile.list.IListDelegate} interface.
       */
      delegate: {
        apply: "_applyDelegate",
        event: "changeDelegate",
        init: null,
        nullable: true
      },

      /**
       * The model to use to render the list.
       */
      model: {
        check: "qx.data.Array",
        apply: "_applyModel",
        event: "changeModel",
        nullable: true,
        init: null
      },

      /**
       * Number of items to display. Auto set by model.
       * Reset to limit the amount of data that should be displayed.
       */
      itemCount: {
        check: "Integer",
        init: 0
      },

      /**
      * The height of a list item.
      */
      itemHeight: {
        check: "Number",
        init: null,
        nullable: true
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      __provider__P_474_0: null,
      __minDeleteDistance__P_474_1: null,
      __isScrollingBlocked__P_474_2: null,
      __trackElement__P_474_3: null,
      // overridden
      _getTagName: function _getTagName() {
        return "ul";
      },

      /**
       * Default list delegate. Expects a map which contains an image, a subtitle, and a title:
       * <code>{title : "Row1", subtitle : "Sub1", image : "path/to/image.png"}</code>
       *
       * @param item {qx.ui.mobile.list.renderer.Abstract} Instance of list item renderer to modify
       * @param data {var} The data of the row. Can be used to configure the given item.
       * @param row {Integer} The row index.
       */
      configureItem: function configureItem(item, data, row) {
        if (typeof data.image != "undefined") {
          item.setImage(data.image);
        }

        if (typeof data.subtitle != "undefined") {
          item.setSubtitle(data.subtitle);
        }

        if (typeof data.title != "undefined") {
          item.setTitle(data.title);
        }

        if (typeof data.enabled != "undefined") {
          item.setEnabled(data.enabled);
        }

        if (typeof data.removable != "undefined") {
          item.setRemovable(data.removable);
        }

        if (typeof data.selectable != "undefined") {
          item.setSelectable(data.selectable);
        }

        if (typeof data.activatable != "undefined") {
          item.setActivatable(data.activatable);
        }

        if (typeof data.arrow != "undefined") {
          item.setShowArrow(data.arrow);
        }

        if (typeof data.selected != "undefined") {
          item.setSelected(data.selected);
        }
      },

      /**
       * Event handler for the "tap" event.
       *
       * @param evt {qx.event.type.Tap} The tap event
       */
      _onTap: function _onTap(evt) {
        var element = this._getElement(evt);

        if (!element) {
          return;
        }

        var row = -1;

        if (qx.bom.element.Class.has(element, "list-item")) {
          if (qx.bom.element.Attribute.get(element, "data-selectable") != "false" && qx.dom.Element.hasChild(this.getContainerElement(), element)) {
            row = parseInt(element.getAttribute("data-row"), 10);
          }

          if (row != -1) {
            this.fireDataEvent("changeSelection", row);
          }
        } else {
          var group = parseInt(element.getAttribute("data-group"), 10);

          if (qx.bom.element.Attribute.get(element, "data-selectable") != "false") {
            this.fireDataEvent("changeGroupSelection", group);
          }
        }
      },

      /**
      * Event handler for <code>trackstart</code> event.
      * @param evt {qx.event.type.Track} the <code>trackstart</code> event
      */
      _onTrackStart: function _onTrackStart(evt) {
        this.__isScrollingBlocked__P_474_2 = null;
        this.__trackElement__P_474_3 = null;

        var element = this._getElement(evt);

        if (element && qx.bom.element.Class.has(element, "list-item") && qx.bom.element.Class.has(element, "removable")) {
          this.__trackElement__P_474_3 = element;
          this.__minDeleteDistance__P_474_1 = qx.bom.element.Dimension.getWidth(element) / 2;
          qx.bom.element.Class.add(element, "track");
        }
      },

      /**
      * Event handler for <code>track</code> event.
      * @param evt {qx.event.type.Track} the <code>track</code> event
      */
      _onTrack: function _onTrack(evt) {
        if (!this.__trackElement__P_474_3) {
          return;
        }

        var element = this.__trackElement__P_474_3;
        var delta = evt.getDelta();
        var deltaX = Math.round(delta.x * 0.1) / 0.1;

        if (this.__isScrollingBlocked__P_474_2 === null) {
          this.__isScrollingBlocked__P_474_2 = delta.axis == "x";
        }

        if (!this.__isScrollingBlocked__P_474_2) {
          return;
        }

        var opacity = 1 - Math.abs(deltaX) / this.__minDeleteDistance__P_474_1;

        opacity = Math.round(opacity * 100) / 100;
        qx.bom.element.Style.set(element, "transform", "translate3d(" + deltaX + "px,0,0)");
        qx.bom.element.Style.set(element, "opacity", opacity);
        evt.preventDefault();
      },

      /**
      * Event handler for <code>trackend</code> event.
      * @param evt {qx.event.type.Track} the <code>trackend</code> event
      */
      _onTrackEnd: function _onTrackEnd(evt) {
        if (!this.__trackElement__P_474_3) {
          return;
        }

        var element = this.__trackElement__P_474_3;

        if (Math.abs(evt.getDelta().x) > this.__minDeleteDistance__P_474_1) {
          var row = parseInt(element.getAttribute("data-row"), 10);
          this.fireDataEvent("removeItem", row);
        } else {
          qx.bom.AnimationFrame.request(function () {
            qx.bom.element.Style.set(element, "transform", "translate3d(0,0,0)");
            qx.bom.element.Style.set(element, "opacity", "1");
            qx.bom.element.Class.remove(element, "track");
          }.bind(this));
        }
      },

      /**
      * Returns the target list item.
      * @param evt {Event} the input event
      * @return {Element} the target list item.
      */
      _getElement: function _getElement(evt) {
        var element = evt.getOriginalTarget(); // Click on border: do nothing.

        if (element.tagName == "UL") {
          return null;
        }

        while (element.tagName != "LI") {
          element = element.parentNode;
        }

        return element;
      },
      // property apply
      _applyModel: function _applyModel(value, old) {
        if (old != null) {
          old.removeListener("changeBubble", this.__onModelChangeBubble__P_474_4, this);
        }

        if (value != null) {
          value.addListener("changeBubble", this.__onModelChangeBubble__P_474_4, this);
        }

        if (old != null) {
          old.removeListener("change", this.__onModelChange__P_474_5, this);
        }

        if (value != null) {
          value.addListener("change", this.__onModelChange__P_474_5, this);
        }

        if (old != null) {
          old.removeListener("changeLength", this.__onModelChangeLength__P_474_6, this);
        }

        if (value != null) {
          value.addListener("changeLength", this.__onModelChangeLength__P_474_6, this);
        }

        this.__render__P_474_7();
      },
      // property apply
      _applyDelegate: function _applyDelegate(value, old) {
        this.__provider__P_474_0.setDelegate(value);
      },

      /**
       * Listen on model 'changeLength' event.
       * @param evt {qx.event.type.Data} data event which contains model change data.
       */
      __onModelChangeLength__P_474_6: function __onModelChangeLength__P_474_6(evt) {
        this.__render__P_474_7();
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale: function _onChangeLocale(e) {
        this.__render__P_474_7();
      },

      /**
       * Reacts on model 'change' event.
       * @param evt {qx.event.type.Data} data event which contains model change data.
       */
      __onModelChange__P_474_5: function __onModelChange__P_474_5(evt) {
        if (evt && evt.getData() && evt.getData().type == "order") {
          this.__render__P_474_7();
        }
      },

      /**
       * Reacts on model 'changeBubble' event.
       * @param evt {qx.event.type.Data} data event which contains model changeBubble data.
       */
      __onModelChangeBubble__P_474_4: function __onModelChangeBubble__P_474_4(evt) {
        if (evt) {
          var data = evt.getData();
          var isArray = qx.lang.Type.isArray(data.old) && qx.lang.Type.isArray(data.value);

          if (!isArray || isArray && data.old.length == data.value.length) {
            var rows = this._extractRowsToRender(data.name);

            for (var i = 0; i < rows.length; i++) {
              this.__renderRow__P_474_8(rows[i]);
            }
          }
        }
      },

      /**
       * Extracts all rows, which should be rendered from "changeBubble" event's
       * data.name.
       * @param name {String} The 'data.name' String of the "changeBubble" event,
       *    which contains the rows that should be rendered.
       * @return {Integer[]} An array with integer values, representing the rows which should
       *  be rendered.
       */
      _extractRowsToRender: function _extractRowsToRender(name) {
        var rows = [];

        if (!name) {
          return rows;
        } // "[0-2].propertyName" | "[0].propertyName" | "0"


        var containsPoint = name.indexOf(".") != -1;

        if (containsPoint) {
          // "[0-2].propertyName" | "[0].propertyName"
          var candidate = name.split(".")[0]; // Normalize

          candidate = candidate.replace("[", "");
          candidate = candidate.replace("]", ""); // "[0-2]" | "[0]"

          var isRange = candidate.indexOf("-") != -1;

          if (isRange) {
            var rangeMembers = candidate.split("-"); // 0

            var startRange = parseInt(rangeMembers[0], 10); // 2

            var endRange = parseInt(rangeMembers[1], 10);

            for (var i = startRange; i <= endRange; i++) {
              rows.push(i);
            }
          } else {
            // "[0]"
            rows.push(parseInt(candidate.match(/\d+/)[0], 10));
          }
        } else {
          // "0"
          var match = name.match(/\d+/);

          if (match.length == 1) {
            rows.push(parseInt(match[0], 10));
          }
        }

        return rows;
      },

      /**
       * Renders a specific row identified by its index.
       * @param index {Integer} index of the row which should be rendered.
       */
      __renderRow__P_474_8: function __renderRow__P_474_8(index) {
        var renderedItems = qx.bom.Selector.query(".list-item", this.getContentElement());
        var oldNode = renderedItems[index];

        var newNode = this.__provider__P_474_0.getItemElement(this.getModel().getItem(index), index);

        this.getContentElement().replaceChild(newNode, oldNode);

        this._domUpdated();
      },

      /**
      * @internal
      * Returns the height of one single list item.
      * @return {Integer} the height of a list item in px.
      */
      getListItemHeight: function getListItemHeight() {
        var listItemHeight = 0;

        if (this.getModel() != null && this.getModel().length > 0) {
          var listHeight = qx.bom.element.Style.get(this.getContentElement(), "height");
          listItemHeight = parseInt(listHeight) / this.getModel().length;
        }

        return listItemHeight;
      },

      /**
       * Renders the list.
       */
      __render__P_474_7: function __render__P_474_7() {
        this._setHtml("");

        var model = this.getModel();
        this.setItemCount(model ? model.getLength() : 0);
        var groupIndex = 0;

        for (var index = 0; index < this.getItemCount(); index++) {
          if (this.__hasGroup__P_474_9()) {
            var groupElement = this._renderGroup(index, groupIndex);

            if (groupElement) {
              groupIndex++;
              this.getContentElement().appendChild(groupElement);
            }
          }

          var item = model.getItem(index);

          var itemElement = this.__provider__P_474_0.getItemElement(item, index);

          var itemHeight = null;

          if (this.getItemHeight() !== null) {
            itemHeight = this.getItemHeight() + "px";
          } // Fixed height


          qx.bom.element.Style.set(itemElement, "minHeight", itemHeight);
          qx.bom.element.Style.set(itemElement, "maxHeight", itemHeight);
          this.getContentElement().appendChild(itemElement);
        }

        this._domUpdated();
      },

      /**
       * Triggers a re-rendering of this list.
       */
      render: function render() {
        this.__render__P_474_7();
      },

      /**
      * Renders a group header.
      *
      * @param itemIndex {Integer} the current list item index.
      * @param groupIndex {Integer} the group index.
      * @return {Element} the group element or <code>null</code> if no group was needed.
      */
      _renderGroup: function _renderGroup(itemIndex, groupIndex) {
        var group = this.__getGroup__P_474_10(itemIndex);

        if (itemIndex === 0) {
          return this.__provider__P_474_0.getGroupElement(group, groupIndex);
        } else {
          var previousGroup = this.__getGroup__P_474_10(itemIndex - 1);

          if (!qx.lang.Object.equals(group, previousGroup)) {
            return this.__provider__P_474_0.getGroupElement(group, groupIndex);
          }
        }
      },

      /**
      * Checks whether the delegate support group rendering.
      * @return {Boolean} true if the delegate object supports grouping function.
      */
      __hasGroup__P_474_9: function __hasGroup__P_474_9() {
        return qx.util.Delegate.getMethod(this.getDelegate(), "group") !== null;
      },

      /**
       * Returns the group for this item, identified by its index
       * @param index {Integer} the item index.
       * @return {Object} the group object, to which the item belongs to.
       */
      __getGroup__P_474_10: function __getGroup__P_474_10(index) {
        var item = this.getModel().getItem(index);
        var group = qx.util.Delegate.getMethod(this.getDelegate(), "group");
        return group(item, index);
      }
    },
    destruct: function destruct() {
      this.__trackElement__P_474_3 = null;

      this._disposeObjects("__provider__P_474_0");

      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
    }
  });
  qx.ui.mobile.list.List.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.bom.Element": {},
      "qx.util.Delegate": {},
      "qx.ui.mobile.list.renderer.group.Default": {},
      "qx.ui.mobile.list.renderer.Default": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Provides a list item element for a certain row and its data.
   * Uses the {@link qx.ui.mobile.list.renderer.Default} list item renderer as a
   * default renderer when no other renderer is given by the {@link qx.ui.mobile.list.List#delegate}.
   */
  qx.Class.define("qx.ui.mobile.list.provider.Provider", {
    extend: qx.core.Object,
    properties: {
      /**
       * Delegation object which can have one or more functions defined by the
       * {@link qx.ui.mobile.list.IListDelegate} interface. Set by the list.
       *
       * @internal
       */
      delegate: {
        event: "changeDelegate",
        init: null,
        nullable: true,
        apply: "_applyDelegate"
      }
    },
    members: {
      __itemRenderer__P_475_0: null,
      __groupRenderer__P_475_1: null,

      /**
       * Sets the item renderer.
       *
       * @param renderer {qx.ui.mobile.list.renderer.Abstract} The used item renderer
       */
      _setItemRenderer: function _setItemRenderer(renderer) {
        this.__itemRenderer__P_475_0 = renderer;
      },

      /**
       * Returns the set item renderer.
       *
       * @return {qx.ui.mobile.list.renderer.Abstract} The used item renderer
       */
      _getItemRenderer: function _getItemRenderer() {
        return this.__itemRenderer__P_475_0;
      },

      /**
      * Sets the group renderer.
      * @param renderer {qx.ui.mobile.list.renderer.group.Abstract} the group renderer.
      */
      _setGroupRenderer: function _setGroupRenderer(renderer) {
        this.__groupRenderer__P_475_1 = renderer;
      },

      /**
      * Gets the group renderer.
      * @return {qx.ui.mobile.list.renderer.group.Abstract} the group renderer.
      */
      _getGroupRenderer: function _getGroupRenderer() {
        return this.__groupRenderer__P_475_1;
      },

      /**
       * Returns the list item element for a given row.
       *
       * @param data {var} The data of the row.
       * @param row {Integer} The row index.
       *
       * @return {Element} the list item element.
       */
      getItemElement: function getItemElement(data, row) {
        this.__itemRenderer__P_475_0.reset();

        this._configureItem(data, row); // Clone the element and all it's events


        var clone = qx.bom.Element.clone(this.__itemRenderer__P_475_0.getContainerElement(), true);
        clone.setAttribute("data-row", row);
        return clone;
      },

      /**
       * Returns the group item element for a given row.
       *
       * @param data {var} The data of the group.
       * @param group {Integer} The group index.
       *
       * @return {Element} the group item element.
       */
      getGroupElement: function getGroupElement(data, group) {
        this.__groupRenderer__P_475_1.reset();

        this._configureGroupItem(data, group); // Clone the element and all it's events


        var clone = qx.bom.Element.clone(this.__groupRenderer__P_475_1.getContainerElement(), true);
        clone.removeAttribute("id");
        clone.setAttribute("data-group", group);
        return clone;
      },

      /**
       * Configure the list item renderer with the passed data.
       *
       * @param data {var} The data of the row.
       * @param row {Integer} The row index.
       */
      _configureItem: function _configureItem(data, row) {
        var delegate = this.getDelegate();

        if (delegate != null && delegate.configureItem != null) {
          delegate.configureItem(this.__itemRenderer__P_475_0, data, row);
        }
      },

      /**
      * Configures the group renderer with the passed group data.
      * @param data {var} The data of the group.
      * @param group {Integer} The group index.
      */
      _configureGroupItem: function _configureGroupItem(data, group) {
        var configureGroupItem = qx.util.Delegate.getMethod(this.getDelegate(), "configureGroupItem");

        if (configureGroupItem) {
          configureGroupItem(this.__groupRenderer__P_475_1, data, group);
        }
      },

      /**
       * Creates an instance of the group renderer to use. When no delegate method
       * is given the function will return an instance of {@link qx.ui.mobile.list.renderer.group.Default}.
       *
       * @return {qx.ui.mobile.list.renderer.group.Abstract} An instance of the group renderer.
      */
      _createGroupRenderer: function _createGroupRenderer() {
        var createGroupRenderer = qx.util.Delegate.getMethod(this.getDelegate(), "createGroupRenderer");
        var groupRenderer = null;

        if (createGroupRenderer == null) {
          groupRenderer = new qx.ui.mobile.list.renderer.group.Default();
        } else {
          groupRenderer = createGroupRenderer();
        }

        return groupRenderer;
      },

      /**
       * Creates an instance of the item renderer to use. When no delegate method
       * is given the function will return an instance of {@link qx.ui.mobile.list.renderer.Default}.
       *
       * @return {qx.ui.mobile.list.renderer.Abstract} An instance of the item renderer.
       *
       */
      _createItemRenderer: function _createItemRenderer() {
        var createItemRenderer = qx.util.Delegate.getMethod(this.getDelegate(), "createItemRenderer");
        var itemRenderer = null;

        if (createItemRenderer == null) {
          itemRenderer = new qx.ui.mobile.list.renderer.Default();
        } else {
          itemRenderer = createItemRenderer();
        }

        return itemRenderer;
      },
      // property apply
      _applyDelegate: function _applyDelegate(value, old) {
        this._setItemRenderer(this._createItemRenderer());

        this._setGroupRenderer(this._createGroupRenderer());
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__itemRenderer__P_475_0", "__groupRenderer__P_475_1");
    }
  });
  qx.ui.mobile.list.provider.Provider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Base class for all group item renderer.
   */
  qx.Class.define("qx.ui.mobile.list.renderer.group.Abstract", {
    extend: qx.ui.mobile.container.Composite,
    type: "abstract",
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout);
      this.initSelectable();
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "group-item"
      },

      /**
       * Whether the row is selectable.
       */
      selectable: {
        check: "Boolean",
        init: false,
        apply: "_applyAttribute"
      },
      //overridden
      activatable: {
        refine: true,
        init: true
      }
    },
    members: {
      // abstract method

      /**
       * Resets all defined child widgets. Override this method in your custom
       * list item renderer and reset all widgets displaying data. Needed as the
       * renderer is used for every row and otherwise data of a different row
       * might be displayed, when not all data displaying widgets are used for the row.
       * Gets called automatically by the {@link qx.ui.mobile.list.provider.Provider}.
       *
       */
      reset: function reset() {
        {
          throw new Error("Abstract method call");
        }
      },
      // overridden
      _getTagName: function _getTagName() {
        return "li";
      }
    }
  });
  qx.ui.mobile.list.renderer.group.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.list.renderer.group.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.basic.Image": {},
      "qx.ui.mobile.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The default group renderer. Used as the default renderer by the
   * {@link qx.ui.mobile.list.provider.Provider}. Configure the renderer
   * by setting the {@link qx.ui.mobile.list.List#delegate} property.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // Create the list with a delegate that
   *   // configures the list item.
   *   var list = new qx.ui.mobile.list.List({
   *     configureItem: function(item, data, row)
   *     {
   *       item.setImage("path/to/image.png");
   *       item.setTitle(data.title);
   *       item.setSubtitle(data.subtitle);
   *     },
   *
   *     configureGroupItem: function(item, data, group) {
   *       item.setTitle(group + " " + data.title);
   *     },
   *
   *     group: function(data, row) {
   *      return {
   *       title: row < 4 ? "Selectable" : "Unselectable"
   *     };
   *    }
   *  });
   * </pre>
   *
   * This example creates a list with a delegate that configures the list items and groups with
   * the given data.
   */
  qx.Class.define("qx.ui.mobile.list.renderer.group.Default", {
    extend: qx.ui.mobile.list.renderer.group.Abstract,
    construct: function construct(layout) {
      qx.ui.mobile.list.renderer.group.Abstract.constructor.call(this, layout || new qx.ui.mobile.layout.HBox().set({
        alignY: "middle"
      }));

      this._init();
    },
    members: {
      __image__P_477_0: null,
      __title__P_477_1: null,
      __rightContainer__P_477_2: null,

      /**
       * Returns the image widget which is used for this renderer.
       *
       * @return {qx.ui.mobile.basic.Image} The image widget
       */
      getImageWidget: function getImageWidget() {
        return this.__image__P_477_0;
      },

      /**
       * Returns the title widget which is used for this renderer.
       *
       * @return {qx.ui.mobile.basic.Label} The title widget
       */
      getTitleWidget: function getTitleWidget() {
        return this.__title__P_477_1;
      },

      /**
       * Sets the source of the image widget.
       *
       * @param source {String} The source to set
       */
      setImage: function setImage(source) {
        this.__image__P_477_0.setSource(source);
      },

      /**
       * Sets the value of the title widget.
       *
       * @param title {String} The value to set
       */
      setTitle: function setTitle(title) {
        if (title && title.translate) {
          this.__title__P_477_1.setValue(title.translate());
        } else {
          this.__title__P_477_1.setValue(title);
        }
      },

      /**
       * Setter for the data attribute <code></code>
       * @param groupTitle {String} the title of the group
       */
      setGroup: function setGroup(groupTitle) {
        this._setAttribute("data-group", groupTitle);
      },

      /**
       * Inits the widgets for the renderer.
       *
       */
      _init: function _init() {
        this.__image__P_477_0 = this._createImage();
        this.add(this.__image__P_477_0);
        this.__rightContainer__P_477_2 = this._createRightContainer();
        this.add(this.__rightContainer__P_477_2, {
          flex: 1
        });
        this.__title__P_477_1 = this._createTitle();

        this.__rightContainer__P_477_2.add(this.__title__P_477_1);
      },

      /**
       * Creates and returns the right container composite. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.container.Composite} the right container.
       */
      _createRightContainer: function _createRightContainer() {
        return new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
      },

      /**
       * Creates and returns the image widget. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.basic.Image} the image widget.
       */
      _createImage: function _createImage() {
        var image = new qx.ui.mobile.basic.Image();
        image.setAnonymous(true);
        image.addCssClass("group-item-image");
        return image;
      },

      /**
       * Creates and returns the title widget. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.basic.Label} the title widget.
       */
      _createTitle: function _createTitle() {
        var title = new qx.ui.mobile.basic.Label();
        title.setWrap(false);
        title.addCssClass("group-item-title");
        return title;
      },
      // overridden
      reset: function reset() {
        this.__image__P_477_0.setSource(null);

        this.__title__P_477_1.setValue("");
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__image__P_477_0", "__title__P_477_1", "__rightContainer__P_477_2");
    }
  });
  qx.ui.mobile.list.renderer.group.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Base class for all list item renderer.
   */
  qx.Class.define("qx.ui.mobile.list.renderer.Abstract", {
    extend: qx.ui.mobile.container.Composite,
    type: "abstract",

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout);
      this.initSelectable();
      this.initRemovable();
      this.initShowArrow();
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "list-item"
      },

      /**
       * Whether the row is selected.
       */
      selected: {
        check: "Boolean",
        init: false,
        apply: "_applySelected"
      },

      /**
       * Whether the row is selectable.
       */
      selectable: {
        check: "Boolean",
        init: true,
        apply: "_applyAttribute"
      },

      /**
       * Whether the row is removable.
       */
      removable: {
        check: "Boolean",
        init: false,
        apply: "_applyRemovable"
      },

      /**
       * Whether to show an arrow in the row.
       */
      showArrow: {
        check: "Boolean",
        init: false,
        apply: "_applyShowArrow"
      },
      //overridden
      activatable: {
        refine: true,
        init: true
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      // abstract method

      /**
       * Resets all defined child widgets. Override this method in your custom
       * list item renderer and reset all widgets displaying data. Needed as the
       * renderer is used for every row and otherwise data of a different row
       * might be displayed, when not all data displaying widgets are used for the row.
       * Gets called automatically by the {@link qx.ui.mobile.list.provider.Provider}.
       *
       */
      reset: function reset() {
        {
          throw new Error("Abstract method call");
        }
      },
      // overridden
      _getTagName: function _getTagName() {
        return "li";
      },

      /**
       * Returns the row index of a certain DOM element in the list from the given event.
       *
       * @param evt {qx.event.type.Event} The causing event.
       * @return {Integer} the index of the row.
       */
      getRowIndexFromEvent: function getRowIndexFromEvent(evt) {
        return this.getRowIndex(evt.getOriginalTarget());
      },

      /**
       * Returns the row index of a certain DOM element in the list.
       *
       * @param element {Element} DOM element to retrieve the index from.
       * @return {Integer} the index of the row.
       */
      getRowIndex: function getRowIndex(element) {
        while (element.tagName != "LI") {
          element = element.parentNode;
        }

        return element.getAttribute("data-row");
      },
      // property apply
      _applyShowArrow: function _applyShowArrow(value, old) {
        if (value) {
          this.addCssClass("arrow");
        } else {
          this.removeCssClass("arrow");
        }
      },
      // property apply
      _applyRemovable: function _applyRemovable(value, old) {
        if (value) {
          this.addCssClass("removable");
        } else {
          this.removeCssClass("removable");
        }
      },
      // property apply
      _applySelected: function _applySelected(value, old) {
        if (value) {
          this.addCssClass("selected");
        } else {
          this.removeCssClass("selected");
        }
      }
    }
  });
  qx.ui.mobile.list.renderer.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.list.renderer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.basic.Image": {},
      "qx.ui.mobile.basic.Label": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The default list item renderer. Used as the default renderer by the
   * {@link qx.ui.mobile.list.provider.Provider}. Configure the renderer
   * by setting the {@link qx.ui.mobile.list.List#delegate} property.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *
   *   // Create the list with a delegate that
   *   // configures the list item.
   *   var list = new qx.ui.mobile.list.List({
   *     configureItem : function(item, data, row)
   *     {
   *       item.setImage("path/to/image.png");
   *       item.setTitle(data.title);
   *       item.setSubtitle(data.subtitle);
   *     }
   *   });
   * </pre>
   *
   * This example creates a list with a delegate that configures the list item with
   * the given data.
   */
  qx.Class.define("qx.ui.mobile.list.renderer.Default", {
    extend: qx.ui.mobile.list.renderer.Abstract,
    construct: function construct(layout) {
      qx.ui.mobile.list.renderer.Abstract.constructor.call(this, layout || new qx.ui.mobile.layout.HBox().set({
        alignY: "middle"
      }));

      this._init();
    },
    members: {
      __image__P_476_0: null,
      __title__P_476_1: null,
      __subtitle__P_476_2: null,
      __rightContainer__P_476_3: null,

      /**
       * Returns the image widget which is used for this renderer.
       *
       * @return {qx.ui.mobile.basic.Image} The image widget
       */
      getImageWidget: function getImageWidget() {
        return this.__image__P_476_0;
      },

      /**
       * Returns the title widget which is used for this renderer.
       *
       * @return {qx.ui.mobile.basic.Label} The title widget
       */
      getTitleWidget: function getTitleWidget() {
        return this.__title__P_476_1;
      },

      /**
       * Returns the subtitle widget which is used for this renderer.
       *
       * @return {qx.ui.mobile.basic.Label} The subtitle widget
       */
      getSubtitleWidget: function getSubtitleWidget() {
        return this.__subtitle__P_476_2;
      },

      /**
       * Sets the source of the image widget.
       *
       * @param source {String} The source to set
       */
      setImage: function setImage(source) {
        this.__image__P_476_0.setSource(source);
      },

      /**
       * Sets the value of the title widget.
       *
       * @param title {String} The value to set
       */
      setTitle: function setTitle(title) {
        if (title && title.translate) {
          this.__title__P_476_1.setValue(title.translate());
        } else {
          this.__title__P_476_1.setValue(title);
        }
      },

      /**
       * Sets the value of the subtitle widget.
       *
       * @param subtitle {String} The value to set
       */
      setSubtitle: function setSubtitle(subtitle) {
        if (subtitle && subtitle.translate) {
          this.__subtitle__P_476_2.setValue(subtitle.translate());
        } else {
          this.__subtitle__P_476_2.setValue(subtitle);
        }
      },

      /**
       * Inits the widgets for the renderer.
       *
       */
      _init: function _init() {
        this.__image__P_476_0 = this._createImage();
        this.add(this.__image__P_476_0);
        this.__rightContainer__P_476_3 = this._createRightContainer();
        this.add(this.__rightContainer__P_476_3, {
          flex: 1
        });
        this.__title__P_476_1 = this._createTitle();

        this.__rightContainer__P_476_3.add(this.__title__P_476_1);

        this.__subtitle__P_476_2 = this._createSubtitle();

        this.__rightContainer__P_476_3.add(this.__subtitle__P_476_2);
      },

      /**
       * Creates and returns the right container composite. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.container.Composite} the right container.
       */
      _createRightContainer: function _createRightContainer() {
        return new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
      },

      /**
       * Creates and returns the image widget. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.basic.Image} the image widget.
       */
      _createImage: function _createImage() {
        var image = new qx.ui.mobile.basic.Image();
        image.setAnonymous(true);
        image.addCssClass("list-item-image");
        return image;
      },

      /**
       * Creates and returns the title widget. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.basic.Label} the title widget.
       */
      _createTitle: function _createTitle() {
        var title = new qx.ui.mobile.basic.Label();
        title.setWrap(false);
        title.addCssClass("list-item-title");
        return title;
      },

      /**
       * Creates and returns the subtitle widget. Override this to adapt the widget code.
       *
       * @return {qx.ui.mobile.basic.Label} the subtitle widget.
       */
      _createSubtitle: function _createSubtitle() {
        var subtitle = new qx.ui.mobile.basic.Label();
        subtitle.setWrap(false);
        subtitle.addCssClass("list-item-subtitle");
        return subtitle;
      },
      // overridden
      reset: function reset() {
        this.__image__P_476_0.setSource(null);

        this.__title__P_476_1.setValue("");

        this.__subtitle__P_476_2.setValue("");
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__image__P_476_0", "__title__P_476_1", "__subtitle__P_476_2", "__rightContainer__P_476_3");
    }
  });
  qx.ui.mobile.list.renderer.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.bom.Viewport": {},
      "qx.bom.element.Dimension": {},
      "qx.event.Registration": {},
      "qx.bom.Event": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * This class blocks events and can be included into all widgets.
   *
   */
  qx.Class.define("qx.ui.mobile.core.Blocker", {
    extend: qx.ui.mobile.core.Widget,
    type: "singleton",
    statics: {
      ROOT: null
    },
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (qx.ui.mobile.core.Blocker.ROOT == null) {
        qx.ui.mobile.core.Blocker.ROOT = qx.core.Init.getApplication().getRoot();
      }

      this.forceHide();
      qx.ui.mobile.core.Blocker.ROOT.add(this);
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "blocker"
      }
    },
    members: {
      __count__P_453_0: 0,

      /**
       * Shows the blocker. When the show method is called a counter is incremented.
       * The {@link #hide} method needs to be called as many times as the {@link #show}
       * method. This behavior is useful, when you want to show a loading indicator.
       */
      show: function show() {
        if (this.__count__P_453_0 == 0) {
          this._updateSize();

          this.__registerEventListener__P_453_1();

          qx.ui.mobile.core.Blocker.prototype.show.base.call(this);
        }

        this.__count__P_453_0++;
      },

      /**
       * Hides the blocker. The blocker is only hidden when the hide method
       * is called as many times as the {@link #show} method.
       */
      hide: function hide() {
        this.__count__P_453_0--;

        if (this.__count__P_453_0 <= 0) {
          this.__count__P_453_0 = 0;

          this.__unregisterEventListener__P_453_2();

          this.exclude();
        }
      },

      /**
       * Force the blocker to hide, even when the show counter is larger than
       * zero.
       */
      forceHide: function forceHide() {
        this.__count__P_453_0 = 0;
        this.hide();
      },

      /**
       * Whether the blocker is shown or not.
       * @return {Boolean} <code>true</code> if the blocker is shown
       */
      isShown: function isShown() {
        return this.__count__P_453_0 > 0;
      },

      /**
       * Event handler. Called whenever the size of the blocker should be updated.
       */
      _updateSize: function _updateSize() {
        if (qx.ui.mobile.core.Blocker.ROOT == this.getLayoutParent()) {
          this.getContainerElement().style.top = qx.bom.Viewport.getScrollTop() + "px";
          this.getContainerElement().style.left = qx.bom.Viewport.getScrollLeft() + "px";
          this.getContainerElement().style.width = qx.bom.Viewport.getWidth() + "px";
          this.getContainerElement().style.height = qx.bom.Viewport.getHeight() + "px";
        } else if (this.getLayoutParent() != null) {
          var dimension = qx.bom.element.Dimension.getSize(this.getLayoutParent().getContainerElement());
          this.getContainerElement().style.width = dimension.width + "px";
          this.getContainerElement().style.height = dimension.height + "px";
        }
      },

      /**
       * Event handler. Called when the scroll event occurs.
       *
       * @param evt {Event} The scroll event
       */
      _onScroll: function _onScroll(evt) {
        this._updateSize();
      },

      /**
       * Registers all needed event listener.
       */
      __registerEventListener__P_453_1: function __registerEventListener__P_453_1() {
        qx.event.Registration.addListener(window, "resize", this._updateSize, this);
        qx.event.Registration.addListener(window, "scroll", this._onScroll, this);
        this.addListener("pointerdown", qx.bom.Event.preventDefault, this);
        this.addListener("pointerup", qx.bom.Event.preventDefault, this);
      },

      /**
       * Unregisters all needed event listener.
       */
      __unregisterEventListener__P_453_2: function __unregisterEventListener__P_453_2() {
        qx.event.Registration.removeListener(window, "resize", this._updateSize, this);
        qx.event.Registration.removeListener(window, "scroll", this._onScroll, this);
        this.removeListener("pointerdown", qx.bom.Event.preventDefault, this);
        this.removeListener("pointerup", qx.bom.Event.preventDefault, this);
      }
    },
    destruct: function destruct() {
      qx.ui.mobile.core.Blocker.ROOT.remove(this);

      this.__unregisterEventListener__P_453_2();
    }
  });
  qx.ui.mobile.core.Blocker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.basic.Atom": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.basic.Image": {
        "construct": true
      },
      "qx.bom.element.Animation": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The widget displays a busy indicator.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var busyIndicator = new qx.ui.mobile.dialog.BusyIndicator("Please wait");
   *   this.getRoot().add(busyIndicator);
   * </pre>
   *
   * This example create a widget to display the busy indicator.
   */
  qx.Class.define("qx.ui.mobile.dialog.BusyIndicator", {
    extend: qx.ui.mobile.basic.Atom,

    /**
     * @param label {String} Label to use
     */
    construct: function construct(label) {
      // the image passed as second argument is a blank 1px transparent png
      qx.ui.mobile.basic.Atom.constructor.call(this, label, qx.ui.mobile.basic.Image.PLACEHOLDER_IMAGE);
      this.addListener("appear", this._onAppear, this);
      this.addListener("disappear", this._onDisappear, this);
    },
    properties: {
      /**
       * The spinner css class to use.
       */
      spinnerClass: {
        apply: "_applySpinnerClass",
        nullable: false,
        check: "String",
        init: "spinner"
      }
    },
    statics: {
      SPINNER_ANIMATION: null
    },
    members: {
      __animationHandle__P_459_0: null,

      /**
       * Listener for appear event.
       */
      _onAppear: function _onAppear() {
        this.__animationHandle__P_459_0 = qx.bom.element.Animation.animate(this.getIconWidget().getContainerElement(), qx.ui.mobile.dialog.BusyIndicator.SPINNER_ANIMATION);
      },

      /**
       * Handler for disappear event.
       */
      _onDisappear: function _onDisappear() {
        this.__animationHandle__P_459_0.stop();
      },
      // overridden
      _createIconWidget: function _createIconWidget(iconUrl) {
        var iconWidget = qx.ui.mobile.dialog.BusyIndicator.prototype._createIconWidget.base.call(this, iconUrl);

        iconWidget.addCssClass(this.getSpinnerClass());
        return iconWidget;
      },
      // property apply
      _applySpinnerClass: function _applySpinnerClass(value, old) {
        if (old) {
          this.getIconWidget().removeCssClass(old);
        }

        if (value) {
          this.getIconWidget().addCssClass(value);
        }
      }
    },
    destruct: function destruct() {
      this.removeListener("appear", this._onAppear, this);
      this.removeListener("disappear", this._onDisappear, this);

      if (this.__animationHandle__P_459_0) {
        this.__animationHandle__P_459_0.stop();
      }

      this.__animationHandle__P_459_0 = null;
    },
    defer: function defer() {
      qx.ui.mobile.dialog.BusyIndicator.SPINNER_ANIMATION = {
        duration: 750,
        timing: "linear",
        origin: "center center",
        repeat: "infinite",
        keyFrames: {
          0: {
            rotate: "0deg"
          },
          100: {
            rotate: "359deg"
          }
        }
      };
    }
  });
  qx.ui.mobile.dialog.BusyIndicator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.bom.client.PhoneGap": {},
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.dialog.Popup": {},
      "qx.core.Init": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.dialog.BusyIndicator": {},
      "qx.ui.mobile.basic.Label": {},
      "qx.ui.mobile.form.TextField": {},
      "qx.ui.mobile.form.Button": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "phonegap": {
          "className": "qx.bom.client.PhoneGap"
        },
        "phonegap.notification": {
          "className": "qx.bom.client.PhoneGap"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * Very basic dialog manager. Displays a native alert or confirm dialog if
   * the application is running in a PhoneGap environment. For debugging in a browser
   * it displays the browser <code>alert</code> or <code>confirm</code> dialog. In the near
   * future this should be replaced by dialog widgets.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *    var buttons = [];
   *    buttons.push(qx.locale.Manager.tr("OK"));
   *    buttons.push(qx.locale.Manager.tr("Cancel"));
   *    var title = "Delete item";
   *    var text = "Do you want to delete the item?"
   *    qx.ui.mobile.dialog.Manager.getInstance().confirm(title, text, function(index) {
   *      if (index==1) {
   *        // delete the item
   *      }
   *    }, this, buttons);
   * </pre>
   *
   * This example displays a confirm dialog and defines a button click handler.
   */
  qx.Class.define("qx.ui.mobile.dialog.Manager", {
    extend: qx.core.Object,
    type: "singleton",

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      INPUT_DIALOG: 1,
      MESSAGE_DIALOG: 2,
      WARNING_DIALOG: 3,
      ERROR_DIALOG: 4,
      WAITING_DIALOG: 5
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Displays an alert box. When the application is running in a PhoneGap
       * environment, a native alert box is shown. When debugging in a browser, a
       * browser alert is shown.
       *
       * @param title {String} The title of the alert box
       * @param text {String} The text to display in the alert box
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed
       * @param scope {Object} The scope of the handler
       * @param button {String} The button title
       * @return {qx.ui.mobile.dialog.Popup|Object} a reference to an alert dialog
       *          instance. An <code>Object</code>, if environment is
       *          <code>phonegap</code>, or a {@link qx.ui.mobile.dialog.Popup}
       *          if not.
       * @lint ignoreDeprecated(alert)
       */
      alert: function alert(title, text, handler, scope, button) {
        // TOOD : MOVE THIS TO PHONEGAP CLASS
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("phonegap.notification")) {
          var callback = function callback() {
            if (handler) {
              handler.call(scope);
            }
          };

          var button = this.__processDialogButtons__P_460_0(button);

          return navigator.notification.alert(text, callback, title, button);
        } else {
          return this.__showNonNativeDialog__P_460_1(title, text, handler, scope, [button], qx.ui.mobile.dialog.Manager.MESSAGE_DIALOG);
        }
      },

      /**
       * Displays a confirm box. When the application is running in a PhoneGap
       * environment, a native confirm box is shown. When debugging in a browser, a
       * browser confirm is shown.
       *
       * @param title {String} The title of the confirm box
       * @param text {String} The text to display in the confirm box
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 0.
       * @param scope {Object} The scope of the handler
       * @param buttons {String[]} Each text entry of the array represents a button and
       *     its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @lint ignoreDeprecated(confirm)
       */
      confirm: function confirm(title, text, handler, scope, buttons) {
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("phonegap.notification")) {
          var callback = function callback(index) {
            handler.call(scope, index - 1);
          };

          var buttons = this.__processDialogButtons__P_460_0(buttons);

          return navigator.notification.confirm(text, callback, title, buttons);
        } else {
          return this.__showNonNativeDialog__P_460_1(title, text, handler, scope, buttons, qx.ui.mobile.dialog.Manager.MESSAGE_DIALOG);
        }
      },

      /**
       * Displays an input dialog.
       *
       * @param title {String} The title of the input dialog.
       * @param text {String} The text to display in the input dialog.
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 1.
       * @param scope {Object} The scope of the handler
       * @param buttons {String[]} Each text entry of the array represents a button and
       *     its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @lint ignoreDeprecated(confirm)
       */
      input: function input(title, text, handler, scope, buttons) {
        return this.__showNonNativeDialog__P_460_1(title, text, handler, scope, buttons, qx.ui.mobile.dialog.Manager.INPUT_DIALOG);
      },

      /**
       * Displays an error dialog. When the application is running in an PhoneGap
       * environment, a native error dialog is shown. For debugging in a browser, a
       * browser confirm is shown.
       *
       * @param title {String} The title of the error dialog.
       * @param text {String} The text to display in the error dialog.
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 1.
       * @param scope {Object} The scope of the handler
       * @param button {String} The text entry represents a button and its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @lint ignoreDeprecated(confirm)
       */
      error: function error(title, text, handler, scope, button) {
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("phonegap.notification")) {
          var callback = function callback() {
            if (handler) {
              handler.call(scope);
            }
          };

          var button = this.__processDialogButtons__P_460_0(button);

          return navigator.notification.alert(text, callback, title, button);
        } else {
          return this.__showNonNativeDialog__P_460_1(title, text, handler, scope, button, qx.ui.mobile.dialog.Manager.ERROR_DIALOG);
        }
      },

      /**
       * Displays a warning dialog. When the application is running in an PhoneGap
       * environment, a native warning dialog is shown. For debugging in a browser, a
       * browser confirm is shown.
       *
       * @param title {String} The title of the warning dialog.
       * @param text {String} The text to display in the warning dialog.
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 1.
       * @param scope {Object} The scope of the handler
       * @param button {String} The text entry represents a button and its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @lint ignoreDeprecated(confirm)
       */
      warning: function warning(title, text, handler, scope, button) {
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("phonegap.notification")) {
          var callback = function callback() {
            if (handler) {
              handler.call(scope);
            }
          };

          var button = this.__processDialogButtons__P_460_0(button);

          return navigator.notification.alert(text, callback, title, button);
        } else {
          return this.__showNonNativeDialog__P_460_1(title, text, handler, scope, button, qx.ui.mobile.dialog.Manager.WARNING_DIALOG);
        }
      },

      /**
       * Displays a waiting dialog.
       *
       * @param title {String} The title of the waiting dialog.
       * @param text {String} The text to display in the waiting dialog.
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 1.
       * @param scope {Object} The scope of the handler
       * @param buttons {String[]} Each text entry of the array represents a button and
       *     its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @lint ignoreDeprecated(confirm)
       */
      wait: function wait(title, text, handler, scope, buttons) {
        return this.__showNonNativeDialog__P_460_1(title, text, handler, scope, buttons, qx.ui.mobile.dialog.Manager.WAITING_DIALOG);
      },

      /**
       * Processes the dialog buttons. Converts them to PhoneGap compatible strings.
       *
       * @param buttons {String[]} Each text entry of the array represents a button and
       *     its title
       * @return {String} The concatenated, PhoneGap compatible, button string
       */
      __processDialogButtons__P_460_0: function __processDialogButtons__P_460_0(buttons) {
        if (buttons) {
          if (buttons instanceof Array) {
            buttons = buttons.join(",");
          } else {
            buttons = "" + buttons;
          }
        }

        return buttons;
      },

      /**
       * Shows a dialog widget.
       *
       * @param title {String} The title of the dialog.
       * @param text {String} The text to display in the dialog.
       * @param handler {Function} The handler to call when the <code>OK</code> button
       *     was pressed. The first parameter of the function is the <code>index</code>
       *     of the pressed button, starting from 1.
       * @param scope {Object} The scope of the handler
       * @param buttons {String[]} Each text entry of the array represents a button and
       *     its title
       * @return {qx.ui.mobile.dialog.Popup} The dialog widget
       * @param dialogType {Integer} One of the static dialog types.
       */
      __showNonNativeDialog__P_460_1: function __showNonNativeDialog__P_460_1(title, text, handler, scope, buttons, dialogType) {
        var widget = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox().set({
          alignY: "middle"
        }));
        var dialog = new qx.ui.mobile.dialog.Popup(widget);
        dialog.setModal(true);
        dialog.setTitle(title); // prevent the back action until the dialog is visible

        var onBackButton = function onBackButton(evt) {
          if (dialog.isVisible() && !!evt.getData()) {
            evt.preventDefault();
          }
        };

        dialog.addListener("changeVisibility", function (evt) {
          var application = qx.core.Init.getApplication();

          if (evt.getData() === "visible") {
            application.addListener("back", onBackButton, this);
          } else {
            application.removeListener("back", onBackButton, this);
          }
        });

        if (dialogType == qx.ui.mobile.dialog.Manager.WAITING_DIALOG) {
          var waitingWidget = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox().set({
            alignX: "center"
          }));
          widget.add(waitingWidget);
          waitingWidget.add(new qx.ui.mobile.dialog.BusyIndicator(text));
        } else {
          var labelWidget = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox().set({
            alignX: "center"
          }));
          labelWidget.add(new qx.ui.mobile.basic.Label(text));
          labelWidget.addCssClass("gap");
          widget.add(labelWidget);

          if (dialogType == qx.ui.mobile.dialog.Manager.INPUT_DIALOG) {
            var inputWidget = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox().set({
              alignX: "center"
            }));
            inputWidget.addCssClass("gap");
            var inputText = new qx.ui.mobile.form.TextField();
            inputWidget.add(inputText);
            widget.add(inputWidget);
          }

          var buttonContainer = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.HBox().set({
            alignX: "center"
          }));
          buttonContainer.addCssClass("gap");

          for (var i = 0, l = buttons.length; i < l; i++) {
            var button = new qx.ui.mobile.form.Button(buttons[i]);
            /* see the comment in android.css for width: 0 for toolbar-button class*/

            button.addCssClass('dialog-button');
            buttonContainer.add(button, {
              flex: 1
            });

            var callback = function (index) {
              return function () {
                dialog.hide();

                if (handler) {
                  handler.call(scope, index, inputText ? inputText.getValue() : null);
                }

                dialog.destroy();
              };
            }(i);

            button.addListener("tap", callback);
          }

          widget.add(buttonContainer);
        }

        dialog.show();

        if (inputText) {
          inputText.getContainerElement().focus();
        }

        return dialog;
      }
    }
  });
  qx.ui.mobile.dialog.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.bom.element.Location": {},
      "qx.bom.element.Dimension": {},
      "qx.util.placement.Placement": {},
      "qx.ui.mobile.core.Blocker": {},
      "qx.lang.Function": {},
      "qx.event.Registration": {},
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.basic.Atom": {},
      "qx.log.Logger": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The popup represents a widget that gets shown above other widgets,
   * usually to present more info/details regarding an item in the application.
   *
   * There are 3 usages for now:
   *
   * <pre class='javascript'>
   * var widget = new qx.ui.mobile.form.Button("Error!");
   * var popup = new qx.ui.mobile.dialog.Popup(widget);
   * popup.show();
   * </pre>
   * Here we show a popup consisting of a single buttons alerting the user
   * that an error has occurred.
   * It will be centered to the screen.
   * <pre class='javascript'>
   * var label = new qx.ui.mobile.basic.Label("Item1");
   * var widget = new qx.ui.mobile.form.Button("Error!");
   * var popup = new qx.ui.mobile.dialog.Popup(widget, label);
   * popup.show();
   * widget.addListener("tap", function(){
   *   popup.hide();
   * });
   *
   * </pre>
   *
   * In this case everything is as above, except that the popup will get shown next to "label"
   * so that the user can understand that the info presented is about the "Item1"
   * we also add a tap listener to the button that will hide out popup.
   *
   * Once created, the instance is reused between show/hide calls.
   *
   * <pre class='javascript'>
   * var widget = new qx.ui.mobile.form.Button("Error!");
   * var popup = new qx.ui.mobile.dialog.Popup(widget);
   * popup.placeTo(25,100);
   * popup.show();
   * </pre>
   *
   * Same as the first example, but this time the popup will be shown at the 25,100 coordinates.
   *
   *
   */
  qx.Class.define("qx.ui.mobile.dialog.Popup", {
    extend: qx.ui.mobile.core.Widget,
    statics: {
      ROOT: null
    },

    /**
     * @param widget {qx.ui.mobile.core.Widget} the widget that will be shown in the popup
     * @param anchor {qx.ui.mobile.core.Widget?} optional parameter, a widget to attach this popup to
     */
    construct: function construct(widget, anchor) {
      qx.ui.mobile.core.Widget.constructor.call(this);
      this.exclude();

      if (qx.ui.mobile.dialog.Popup.ROOT == null) {
        qx.ui.mobile.dialog.Popup.ROOT = qx.core.Init.getApplication().getRoot();
      }

      qx.ui.mobile.dialog.Popup.ROOT.add(this);
      this.__anchor__P_462_0 = anchor;

      if (widget) {
        this._initializeChild(widget);
      }
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "popup"
      },

      /**
       * The label/caption/text of the qx.ui.mobile.basic.Atom instance
       */
      title: {
        apply: "_applyTitle",
        nullable: true,
        check: "String",
        event: "changeTitle"
      },

      /**
       * Any URI String supported by qx.ui.mobile.basic.Image to display an icon
       */
      icon: {
        check: "String",
        apply: "_applyIcon",
        nullable: true,
        event: "changeIcon"
      },

      /**
       * Whether the popup should be displayed modal.
       */
      modal: {
        init: false,
        check: "Boolean",
        nullable: false
      },

      /**
       * Indicates whether the a modal popup should disappear when user taps/clicks on Blocker.
       */
      hideOnBlockerTap: {
        check: "Boolean",
        init: false
      }
    },
    members: {
      __isShown__P_462_1: false,
      __childrenContainer__P_462_2: null,
      __percentageTop__P_462_3: null,
      __anchor__P_462_0: null,
      __widget__P_462_4: null,
      __titleWidget__P_462_5: null,
      __lastPopupDimension__P_462_6: null,

      /**
       * Event handler. Called whenever the position of the popup should be updated.
       */
      _updatePosition: function _updatePosition() {
        // Traverse single anchor classes for removal, for preventing 'domupdated' event if no CSS classes changed.
        var anchorClasses = ['top', 'bottom', 'left', 'right', 'anchor'];

        for (var i = 0; i < anchorClasses.length; i++) {
          this.removeCssClass(anchorClasses[i]);
        }

        if (this.__anchor__P_462_0) {
          this.addCssClass('anchor');
          var rootHeight = qx.ui.mobile.dialog.Popup.ROOT.getHeight();
          var rootWidth = qx.ui.mobile.dialog.Popup.ROOT.getWidth();
          var rootPosition = qx.bom.element.Location.get(qx.ui.mobile.dialog.Popup.ROOT.getContainerElement());
          var anchorPosition = qx.bom.element.Location.get(this.__anchor__P_462_0.getContainerElement());
          var popupDimension = qx.bom.element.Dimension.getSize(this.getContainerElement());
          this.__lastPopupDimension__P_462_6 = popupDimension;
          var computedPopupPosition = qx.util.placement.Placement.compute(popupDimension, {
            width: rootPosition.left + rootWidth,
            height: rootPosition.top + rootHeight
          }, anchorPosition, {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, "bottom-left", "keep-align", "keep-align"); // Reset Anchor.

          this._resetPosition();

          var isTop = anchorPosition.top > computedPopupPosition.top;
          var isLeft = anchorPosition.left > computedPopupPosition.left;
          computedPopupPosition.top = computedPopupPosition.top - rootPosition.top;
          computedPopupPosition.left = computedPopupPosition.left - rootPosition.left;
          var isOutsideViewPort = computedPopupPosition.top < 0 || computedPopupPosition.left < 0 || computedPopupPosition.left + popupDimension.width > rootWidth || computedPopupPosition.top + popupDimension.height > rootHeight;

          if (isOutsideViewPort) {
            this._positionToCenter();
          } else {
            if (isTop) {
              this.addCssClass('bottom');
            } else {
              this.addCssClass('top');
            }

            if (isLeft) {
              this.addCssClass('right');
            } else {
              this.addCssClass('left');
            }

            this.placeTo(computedPopupPosition.left, computedPopupPosition.top);
          }
        } else if (this.__childrenContainer__P_462_2) {
          // No Anchor
          this._positionToCenter();
        }
      },

      /**
       * This method shows the popup.
       * First it updates the position, then registers the event handlers, and shows it.
       */
      show: function show() {
        if (!this.__isShown__P_462_1) {
          qx.core.Init.getApplication().fireEvent("popup");

          this.__registerEventListener__P_462_7(); // Move outside of viewport


          this.placeTo(-1000, -1000); // Needs to be added to screen, before rendering position, for calculating
          // objects height.

          qx.ui.mobile.dialog.Popup.prototype.show.base.call(this); // Now render position.

          this._updatePosition();
        }

        this.__isShown__P_462_1 = true;

        if (this.getModal() === true) {
          qx.ui.mobile.core.Blocker.getInstance().show();

          if (this.getHideOnBlockerTap()) {
            qx.ui.mobile.core.Blocker.getInstance().addListener("tap", this.hide, this);
          }
        }
      },

      /**
       * Hides the popup.
       */
      hide: function hide() {
        if (this.__isShown__P_462_1) {
          this.__unregisterEventListener__P_462_8();

          this.exclude();
        }

        this.__isShown__P_462_1 = false;

        if (this.getModal()) {
          qx.ui.mobile.core.Blocker.getInstance().hide();
        }

        qx.ui.mobile.core.Blocker.getInstance().removeListener("tap", this.hide, this);
      },

      /**
       * Hides the popup after a given time delay.
       * @param delay {Integer} time delay in ms.
       */
      hideWithDelay: function hideWithDelay(delay) {
        if (delay) {
          qx.lang.Function.delay(this.hide, delay, this);
        } else {
          this.hide();
        }
      },

      /**
       * Returns the shown state of this popup.
       * @return {Boolean} whether the popup is shown or not.
       */
      isShown: function isShown() {
        return this.__isShown__P_462_1;
      },

      /**
       * Toggles the visibility of this popup.
       */
      toggleVisibility: function toggleVisibility() {
        if (this.__isShown__P_462_1 == true) {
          this.hide();
        } else {
          this.show();
        }
      },

      /**
       * This method positions the popup widget at the coordinates specified.
       * @param left {Integer} - the value the will be set to container's left style property
       * @param top {Integer} - the value the will be set to container's top style property
       */
      placeTo: function placeTo(left, top) {
        this._setStyle("left", left + "px");

        this._setStyle("top", top + "px");
      },

      /**
       * Tracks the user tap on root and hides the widget if <code>pointerdown</code> event
       * occurs outside of the widgets bounds.
       * @param evt {qx.event.type.Pointer} the pointer event.
       */
      _trackUserTap: function _trackUserTap(evt) {
        var clientX = evt.getViewportLeft();
        var clientY = evt.getViewportTop();
        var popupLocation = qx.bom.element.Location.get(this.getContainerElement());
        var isOutsideWidget = clientX < popupLocation.left || clientX > popupLocation.left + this.__lastPopupDimension__P_462_6.width || clientY > popupLocation.top + this.__lastPopupDimension__P_462_6.height || clientY < popupLocation.top;

        if (isOutsideWidget) {
          this.hide();
        }
      },

      /**
       * Centers this widget to window's center position.
       */
      _positionToCenter: function _positionToCenter() {
        var container = this.getContainerElement();
        container.style.position = "absolute";
        container.style.marginLeft = -parseInt(container.offsetWidth / 2) + "px";
        container.style.marginTop = -parseInt(container.offsetHeight / 2) + "px";
        container.style.left = "50%";
        container.style.top = "50%";
      },

      /**
       * Resets the position of this element (left, top, margins...)
       */
      _resetPosition: function _resetPosition() {
        var container = this.getContainerElement();
        container.style.left = "0px";
        container.style.top = "0px";
        container.style.marginLeft = null;
        container.style.marginTop = null;
      },

      /**
       * Registers all needed event listeners
       */
      __registerEventListener__P_462_7: function __registerEventListener__P_462_7() {
        qx.core.Init.getApplication().addListener("stop", this.hide, this);
        qx.core.Init.getApplication().addListener("popup", this.hide, this);
        qx.event.Registration.addListener(window, "resize", this._updatePosition, this);

        if (this.__anchor__P_462_0) {
          this.__anchor__P_462_0.addCssClass("anchor-target");

          qx.ui.mobile.dialog.Popup.ROOT.addListener("pointerdown", this._trackUserTap, this);
        }
      },

      /**
       * Unregisters all needed event listeners
       */
      __unregisterEventListener__P_462_8: function __unregisterEventListener__P_462_8() {
        qx.core.Init.getApplication().removeListener("stop", this.hide, this);
        qx.core.Init.getApplication().removeListener("popup", this.hide, this);
        qx.event.Registration.removeListener(window, "resize", this._updatePosition, this);

        if (this.__anchor__P_462_0) {
          this.__anchor__P_462_0.removeCssClass("anchor-target");

          qx.ui.mobile.dialog.Popup.ROOT.removeListener("pointerdown", this._trackUserTap, this);
        }
      },

      /**
       * This method creates the container where the popup's widget will be placed
       * and adds it to the popup.
       * @param widget {qx.ui.mobile.core.Widget} - what to show in the popup
       *
       */
      _initializeChild: function _initializeChild(widget) {
        if (this.__childrenContainer__P_462_2 == null) {
          this.__childrenContainer__P_462_2 = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());

          this.__childrenContainer__P_462_2.setDefaultCssClass("popup-content");

          this._add(this.__childrenContainer__P_462_2);
        }

        if (this._createTitleWidget()) {
          this.__childrenContainer__P_462_2.remove(this._createTitleWidget());

          this.__childrenContainer__P_462_2.add(this._createTitleWidget());
        }

        this.__childrenContainer__P_462_2.add(widget, {
          flex: 1
        });

        widget.addListener("domupdated", this._updatePosition, this);
        this.__widget__P_462_4 = widget;
      },

      /**
       * Creates the title atom widget.
       *
       * @return {qx.ui.mobile.basic.Atom} The title atom widget.
       */
      _createTitleWidget: function _createTitleWidget() {
        if (this.__titleWidget__P_462_5) {
          return this.__titleWidget__P_462_5;
        }

        if (this.getTitle() || this.getIcon()) {
          this.__titleWidget__P_462_5 = new qx.ui.mobile.basic.Atom(this.getTitle(), this.getIcon());

          this.__titleWidget__P_462_5.addCssClass('popup-title');

          return this.__titleWidget__P_462_5;
        } else {
          return null;
        }
      },
      // property apply
      _applyTitle: function _applyTitle(value, old) {
        if (value) {
          if (this.__titleWidget__P_462_5) {
            this.__titleWidget__P_462_5.setLabel(value);
          } else {
            this.__titleWidget__P_462_5 = new qx.ui.mobile.basic.Atom(value, this.getIcon());

            this.__titleWidget__P_462_5.addCssClass('popup-title');

            if (this.__widget__P_462_4) {
              this.__childrenContainer__P_462_2.addBefore(this._createTitleWidget(), this.__widget__P_462_4);
            } else {
              if (this.__childrenContainer__P_462_2) {
                this.__childrenContainer__P_462_2.add(this._createTitleWidget());
              }
            }
          }
        }
      },
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        if (value) {
          if (this.__titleWidget__P_462_5) {
            this.__titleWidget__P_462_5.setIcon(value);
          } else {
            this.__titleWidget__P_462_5 = new qx.ui.mobile.basic.Atom(this.getTitle(), value);

            this.__titleWidget__P_462_5.addCssClass('popup-title');

            if (this.__widget__P_462_4) {
              this.__childrenContainer__P_462_2.addBefore(this._createTitleWidget(), this.__widget__P_462_4);
            } else {
              if (this.__childrenContainer__P_462_2) {
                this.__childrenContainer__P_462_2.add(this._createTitleWidget());
              }
            }
          }
        }
      },

      /**
       * Adds the widget that will be shown in this popup. This method can be used in the case when you have removed the widget from the popup
       * or you haven't passed it in the constructor.
       * @param widget {qx.ui.mobile.core.Widget} - what to show in the popup
       */
      add: function add(widget) {
        this.removeWidget();

        this._initializeChild(widget);
      },

      /**
       * A widget to attach this popup to.
       *
       * @param widget {qx.ui.mobile.core.Widget} The anchor widget.
       */
      setAnchor: function setAnchor(widget) {
        this.__anchor__P_462_0 = widget;

        this._updatePosition();
      },

      /**
       * Returns the title widget.
       *
       * @return {qx.ui.mobile.basic.Atom} The title widget.
       */
      getTitleWidget: function getTitleWidget() {
        return this.__titleWidget__P_462_5;
      },

      /**
       * This method removes the widget shown in the popup.
       * @return {qx.ui.mobile.core.Widget|null} The removed widget or <code>null</code>
       * if the popup doesn't have an attached widget
       */
      removeWidget: function removeWidget() {
        if (this.__widget__P_462_4) {
          this.__widget__P_462_4.removeListener("domupdated", this._updatePosition, this);

          this.__childrenContainer__P_462_2.remove(this.__widget__P_462_4);

          return this.__widget__P_462_4;
        } else {
          {
            qx.log.Logger.debug(this, "this popup has no widget attached yet");
          }
          return null;
        }
      }
    },
    destruct: function destruct() {
      this.__unregisterEventListener__P_462_8();

      this._disposeObjects("__childrenContainer__P_462_2");

      this.__isShown__P_462_1 = this.__percentageTop__P_462_3 = this._anchor = this.__widget__P_462_4 = this.__lastPopupDimension__P_462_6 = null;
    }
  });
  qx.ui.mobile.dialog.Popup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * The mixin contains all functionality to provide methods
   * for form elements to manipulate their state. [usually "valid" and "invalid"]
   *
   */
  qx.Mixin.define("qx.ui.mobile.form.MState", {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * The states of the element
       */
      __states__P_465_0: null,

      /**
       * Adds a state to the element
       * @param state {String} the state to be added
       *
       */
      addState: function addState(state) {
        if (this.__states__P_465_0 === null) {
          this.__states__P_465_0 = {};
        }

        this.__states__P_465_0[state] = true;
        this.addCssClass(state);
      },

      /**
       * Checks whether the element has the state passed as argument
       * @param state {String} the state to be checked
       * @return {Boolean} true if the element has the state, false if it doesn't.
       *
       */
      hasState: function hasState(state) {
        return this.__states__P_465_0 !== null && this.__states__P_465_0[state];
      },

      /**
       * Removes a state from the element
       * @param state {String} the state to be removed
       *
       */
      removeState: function removeState(state) {
        if (this.hasState(state)) {
          delete this.__states__P_465_0[state];
          this.removeCssClass(state);
        }
      },

      /**
       * Replaces a state of the element with a new state.
       * If the element doesn't have the state to be removed, then th new state will
       * just be added.
       * @param oldState {String} the state to be replaced
       * @param newState {String} the state to get injected in the oldState's place
       *
       */
      replaceState: function replaceState(oldState, newState) {
        if (this.hasState(oldState)) {
          delete this.__states__P_465_0[oldState];
          this.__states__P_465_0[newState] = true;
          this.removeCssClass(oldState);
          this.addCssClass(newState);
        } else {
          this.addState(newState);
        }
      }
    }
  });
  qx.ui.mobile.form.MState.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.mobile.container.MScrollHandling": {
        "require": true
      },
      "qx.ui.mobile.form.MState": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.mobile.form.TextField": {},
      "qx.ui.mobile.form.NumberField": {},
      "qx.bom.AnimationFrame": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Abstract class for all input fields.
   */
  qx.Class.define("qx.ui.mobile.form.Input", {
    extend: qx.ui.mobile.core.Widget,
    include: [qx.ui.form.MForm, qx.ui.form.MModelProperty, qx.ui.mobile.container.MScrollHandling, qx.ui.mobile.form.MState],
    implement: [qx.ui.form.IForm, qx.ui.form.IModel],
    type: "abstract",
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);

      this._setAttribute("type", this._getType());

      this.addCssClass("gap");
      this.addListener("focus", this._onSelected, this);
    },
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "input";
      },

      /**
       * Returns the type of the input field. Override this method in the
       * specialized input class.
       */
      _getType: function _getType() {
        {
          throw new Error("Abstract method call");
        }
      },

      /**
       * Handles the <code>click</code> and <code>focus</code> event on this input widget.
       * @param evt {qx.event.type.Event} <code>click</code> or <code>focus</code> event
       */
      _onSelected: function _onSelected(evt) {
        if (!(evt.getTarget() instanceof qx.ui.mobile.form.TextField) && !(evt.getTarget() instanceof qx.ui.mobile.form.NumberField)) {
          return;
        }

        var scrollContainer = this._getParentScrollContainer();

        if (scrollContainer === null) {
          return;
        }

        setTimeout(function () {
          scrollContainer.scrollToWidget(this.getLayoutParent(), 0); // Refresh caret position after scrolling.

          this._setStyle("position", "relative");

          qx.bom.AnimationFrame.request(function () {
            this._setStyle("position", null);
          }, this);
        }.bind(this), 300);
      }
    },
    destruct: function destruct() {
      this.removeListener("focus", this._onSelected, this);
    }
  });
  qx.ui.mobile.form.Input.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.event.handler.Input": {
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.Registration": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The mixin contains all functionality to provide a value property for input
   * widgets.
   *
   * @require(qx.event.handler.Input)
   */
  qx.Mixin.define("qx.ui.mobile.form.MValue", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {var?null} The value of the widget.
     */
    construct: function construct(value) {
      if (value) {
        this.setValue(value);
      }

      if (this._getTagName() == "input" || this._getTagName() == "textarea") {
        qx.event.Registration.addListener(this.getContentElement(), "change", this._onChangeContent, this);
        qx.event.Registration.addListener(this.getContentElement(), "input", this._onInput, this);
      }

      this.addListener("focus", this._onFocus, this);
      this.addListener("blur", this._onBlur, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * The event is fired on every keystroke modifying the value of the field.
       *
       * The method {@link qx.event.type.Data#getData} returns the
       * current value of the text field.
       */
      "input": "qx.event.type.Data",

      /**
       * The event is fired each time the text field looses focus and the
       * text field values has changed.
       *
       * If you change {@link #liveUpdate} to true, the changeValue event will
       * be fired after every keystroke and not only after every focus loss. In
       * that mode, the changeValue event is equal to the {@link #input} event.
       *
       * The method {@link qx.event.type.Data#getData} returns the
       * current text value of the field.
       */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether the {@link #changeValue} event should be fired on every key
       * input. If set to true, the changeValue event is equal to the
       * {@link #input} event.
       */
      liveUpdate: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __oldValue__P_466_0: null,
      __inputTimeoutHandle__P_466_1: null,
      __hasFocus__P_466_2: null,

      /**
       * Converts the incoming value.
       *
       * @param value {var} The value to convert
       * @return {var} The converted value
       */
      _convertValue: function _convertValue(value) {
        if (typeof value === 'boolean') {
          return value;
        } else if (typeof value === 'number') {
          return value;
        } else {
          return value || "";
        }
      },

      /**
      * Handler for <code>focus</code> event.
      */
      _onFocus: function _onFocus() {
        this.__hasFocus__P_466_2 = true;
      },

      /**
      * Handler for <code>blur</code> event.
      */
      _onBlur: function _onBlur() {
        this.__hasFocus__P_466_2 = false;
      },

      /**
      * Returns whether this widget has focus or not.
      * @return {Boolean} <code>true</code> or <code>false</code>
      */
      hasFocus: function hasFocus() {
        return this.__hasFocus__P_466_2;
      },

      /**
       * Sets the value.
       *
       * @param value {var} The value to set
       */
      setValue: function setValue(value) {
        value = this._convertValue(value);

        if (this.__oldValue__P_466_0 != value) {
          if (this._setValue) {
            this._setValue(value);
          } else {
            this._setAttribute("value", value);
          }

          this.__fireChangeValue__P_466_3(value);
        }
      },

      /**
       * Returns the set value.
       *
       * @return {var} The set value
       */
      getValue: function getValue() {
        return this._convertValue(this._getValue ? this._getValue() : this._getAttribute("value"));
      },

      /**
       * Resets the value.
       */
      resetValue: function resetValue() {
        this.setValue(null);
      },

      /**
       * Event handler. Called when the {@link #changeValue} event occurs.
       *
       * @param evt {qx.event.type.Data} The event, containing the changed content.
       */
      _onChangeContent: function _onChangeContent(evt) {
        this.__fireChangeValue__P_466_3(this._convertValue(evt.getData()));
      },

      /**
       * Event handler. Called when the {@link #input} event occurs.
       *
       * @param evt {qx.event.type.Data} The event, containing the changed content.
       */
      _onInput: function _onInput(evt) {
        var data = evt.getData();
        this.fireDataEvent("input", data, true);

        if (this.getLiveUpdate()) {
          if (this._setValue) {
            this._setValue(data);
          } else {
            this.__fireChangeValue__P_466_3(this._convertValue(data));
          }
        }
      },

      /**
      * Returns the caret position of this widget.
      * @return {Integer} the caret position.
      */
      _getCaretPosition: function _getCaretPosition() {
        var val = this.getContentElement().value;

        if (val && this._getAttribute("type") !== "number") {
          return val.slice(0, this.getContentElement().selectionStart).length;
        } else {
          return val.length;
        }
      },

      /**
       * Sets the caret position on this widget.
       * @param position {Integer} the caret position.
       */
      _setCaretPosition: function _setCaretPosition(position) {
        if (position != null && this.hasFocus()) {
          if (this._getAttribute("type") !== "number" && this.getContentElement().setSelectionRange) {
            this.getContentElement().setSelectionRange(position, position);
          }
        }
      },

      /**
       * Fires the {@link #changeValue} event.
       *
       * @param value {var} The current value to fire.
       */
      __fireChangeValue__P_466_3: function __fireChangeValue__P_466_3(value) {
        if (this.__oldValue__P_466_0 != value) {
          this.__oldValue__P_466_0 = value;
          this.fireDataEvent("changeValue", value);
        }
      }
    },
    destruct: function destruct() {
      this.removeListener("focus", this._onFocus, this);
      this.removeListener("blur", this._onBlur, this);
    }
  });
  qx.ui.mobile.form.MValue.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.event.handler.Input": {
        "require": true
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.OperatingSystem": {},
      "qx.bom.Element": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "os.name": {
          "className": "qx.bom.client.OperatingSystem"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The mixin contains all functionality to provide common properties for
   * text fields.
   *
   * @require(qx.event.handler.Input)
   */
  qx.Mixin.define("qx.ui.mobile.form.MText", {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {var?null} The value of the widget.
     */
    construct: function construct(value) {
      this.initMaxLength();
      this.initPlaceholder();
      this.initReadOnly();
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
        * Maximal number of characters that can be entered in the input field.
        */
      maxLength: {
        check: "PositiveInteger",
        nullable: true,
        init: null,
        apply: "_applyMaxLength"
      },

      /**
       * String value which will be shown as a hint if the field is all of:
       * unset, unfocused and enabled. Set to <code>null</code> to not show a placeholder
       * text.
       */
      placeholder: {
        check: "String",
        nullable: true,
        init: null,
        apply: "_applyPlaceholder"
      },

      /** Whether the field is read only */
      readOnly: {
        check: "Boolean",
        nullable: true,
        init: null,
        apply: "_applyAttribute"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // property apply
      _applyMaxLength: function _applyMaxLength(value, old) {
        this._setAttribute("maxlength", value);
      },
      // property apply
      _applyPlaceholder: function _applyPlaceholder(value, old) {
        // Android is not able to indent placeholder.
        // Adding a space before the placeholder text, as a fix.
        if (qx.core.Environment.get("os.name") == "android" && value !== null) {
          value = " " + value;
        }

        this._setAttribute("placeholder", value);
      },

      /**
       * Points the focus of the form to this widget.
       */
      focus: function focus() {
        if (this.isReadOnly() || this.getEnabled() == false) {
          return;
        }

        var targetElement = this.getContainerElement();

        if (targetElement) {
          qx.bom.Element.focus(targetElement);
        }
      },

      /**
       * Removes the focus from this widget.
       */
      blur: function blur() {
        var targetElement = this.getContainerElement();

        if (targetElement) {
          qx.bom.Element.blur(targetElement);
        }
      }
    }
  });
  qx.ui.mobile.form.MText.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Input": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.mobile.form.MText": {
        "require": true
      },
      "qx.ui.form.IStringForm": {
        "require": true
      },
      "qx.bom.client.OperatingSystem": {
        "construct": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "os.name": {
          "construct": true,
          "className": "qx.bom.client.OperatingSystem"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The TextField is a single-line text input field.
   */
  qx.Class.define("qx.ui.mobile.form.TextField", {
    extend: qx.ui.mobile.form.Input,
    include: [qx.ui.mobile.form.MValue, qx.ui.mobile.form.MText],
    implement: [qx.ui.form.IStringForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {var?null} The value of the widget.
     */
    construct: function construct(value) {
      qx.ui.mobile.form.Input.constructor.call(this);
      this.addListener("keypress", this._onKeyPress, this);

      if (qx.core.Environment.get("os.name") == "ios") {
        // IOS does not blur input fields automatically if a parent DOM element
        // was set invisible, so blur manually on disappear
        this.addListener("disappear", this.blur, this);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "text-field"
      }
    },
    members: {
      // overridden
      _getType: function _getType() {
        return "text";
      },

      /**
      * Event handler for <code>keypress</code> event.
      * @param evt {qx.event.type.KeySequence} the keypress event.
      */
      _onKeyPress: function _onKeyPress(evt) {
        // On return
        if (evt.getKeyCode() == 13) {
          this.blur();
        }
      }
    },
    destruct: function destruct() {
      this.removeListener("keypress", this._onKeyPress, this);

      if (qx.core.Environment.get("os.name") == "ios") {
        this.removeListener("disappear", this.blur, this);
      }
    }
  });
  qx.ui.mobile.form.TextField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.basic.Atom": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A Button widget.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.mobile.form.Button("Hello World");
   *
   *   button.addListener("tap", function(e) {
   *     alert("Button was clicked");
   *   }, this);
   *
   *   this.getRoot.add(button);
   * </pre>
   *
   * This example creates a button with the label "Hello World" and attaches an
   * event listener to the {@link qx.ui.mobile.core.Widget#tap} event.
   */
  qx.Class.define("qx.ui.mobile.form.Button", {
    extend: qx.ui.mobile.basic.Atom,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "button"
      },
      // overridden
      activatable: {
        refine: true,
        init: true
      }
    },
    members: {
      /**
       * Sets the value.
       *
       * @param value {String} The value to set
       */
      setValue: function setValue(value) {
        this.setLabel(value);
      },

      /**
       * Returns the set value.
       *
       * @return {String} The set value
       */
      getValue: function getValue() {
        return this.getLabel();
      }
    }
  });
  qx.ui.mobile.form.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Input": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.mobile.form.MText": {
        "require": true
      },
      "qx.ui.form.IStringForm": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The NumberField is a single-line number input field. It uses HTML5 input field type
   * "number" and the attribute "min" ,"max" and "step". The attributes can be used
   * for form validation {@link qx.ui.form.validation.Manager}.
   */
  qx.Class.define("qx.ui.mobile.form.NumberField", {
    extend: qx.ui.mobile.form.Input,
    include: [qx.ui.mobile.form.MValue, qx.ui.mobile.form.MText],
    implement: [qx.ui.form.IStringForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {var?null} The value of the widget.
     */
    construct: function construct(value) {
      qx.ui.mobile.form.Input.constructor.call(this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "number-field"
      },

      /**
       * The minimum text field value (may be negative). This value must be smaller
       * than {@link #minimum}.
       */
      minimum: {
        check: "Number",
        init: '',
        apply: "_onChangeMinimum"
      },

      /**
       * The maximum text field value (may be negative). This value must be larger
       * than {@link #maximum}.
       */
      maximum: {
        check: "Number",
        init: '',
        apply: "_onChangeMaximum"
      },

      /**
       * The amount to increment on each event.
       */
      step: {
        check: "Number",
        init: '',
        apply: "_onChangeStep"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getType: function _getType() {
        return "number";
      },

      /**
       * Called when changed the property step.
       * Delegates value change on DOM element.
       */
      _onChangeStep: function _onChangeStep(value, old) {
        this._setAttribute("step", value);
      },

      /**
       * Called when changed the property maximum.
       * Delegates value change on DOM element.
       */
      _onChangeMaximum: function _onChangeMaximum(value, old) {
        this._setAttribute("max", value);
      },

      /**
       * Called when changed the property minimum.
       * Delegates value change on DOM element.
       */
      _onChangeMinimum: function _onChangeMinimum(value, old) {
        this._setAttribute("min", value);
      }
    }
  });
  qx.ui.mobile.form.NumberField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.dialog.Popup": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true
      },
      "qx.ui.mobile.form.Button": {},
      "qx.ui.mobile.container.Scroll": {},
      "qx.bom.element.Style": {},
      "qx.ui.mobile.list.List": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * This widget displays a menu. A dialog menu extends a popup and contains a
   * list, which provides the user the possibility to select one value.
   * The selected value is identified through selected index.
   *
   *
   * *Example*
   * <pre class='javascript'>
   *
   * var model = new qx.data.Array(["item1","item2","item3"]);
   *
   * var menu = new qx.ui.mobile.dialog.Menu(model);
   * menu.show();
   * menu.addListener("changeSelection", function(evt){
   *    var selectedIndex = evt.getData().index;
   *    var selectedItem = evt.getData().item;
   * }, this);
   * </pre>
   *
   * This example creates a menu with several choosable items.
   */
  qx.Class.define("qx.ui.mobile.dialog.Menu", {
    extend: qx.ui.mobile.dialog.Popup,

    /**
     * @param itemsModel {qx.data.Array ?}, the model which contains the choosable items of the menu.
     * @param anchor {qx.ui.mobile.core.Widget ?} The anchor widget for this item. If no anchor is available, the menu will be displayed modal and centered on screen.
     */
    construct: function construct(itemsModel, anchor) {
      // Create the list with a delegate that
      // configures the list item.
      this.__selectionList__P_461_0 = this._createSelectionList();

      if (itemsModel) {
        this.__selectionList__P_461_0.setModel(itemsModel);
      }

      this.__menuContainer__P_461_1 = new qx.ui.mobile.container.Composite();
      this.__clearButton__P_461_2 = this._createClearButton();
      this.__listScroller__P_461_3 = this._createListScroller(this.__selectionList__P_461_0);

      this.__menuContainer__P_461_1.add(this.__listScroller__P_461_3);

      this.__menuContainer__P_461_1.add(this.__clearButton__P_461_2);

      qx.ui.mobile.dialog.Popup.constructor.call(this, this.__menuContainer__P_461_1, anchor);

      if (anchor) {
        this.setModal(false);
      } else {
        this.setModal(true);
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the selection is changed.
       */
      changeSelection: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "menu"
      },

      /**
       *  Class which is assigned to selected items.
       *  Useful for re-styling your menu via LESS.
       */
      selectedItemClass: {
        init: "item-selected"
      },

      /**
       * Class which is assigned to unselected items.
       * Useful for re-styling your menu via LESS.
       */
      unselectedItemClass: {
        init: "item-unselected"
      },

      /**
       * Defines if the menu has a null value in the list, which can be chosen
       * by the user. The label
       */
      nullable: {
        init: false,
        check: "Boolean",
        apply: "_applyNullable"
      },

      /**
       * The label of the null value entry of the list. Only relevant
       * when nullable property is set to <code>true</code>.
       */
      clearButtonLabel: {
        init: "None",
        check: "String",
        apply: "_applyClearButtonLabel"
      },

      /**
       * The selected index of this menu.
       */
      selectedIndex: {
        check: "Integer",
        apply: "_applySelectedIndex",
        nullable: true
      },

      /**
      * This value defines how much list items are visible inside the menu.
      */
      visibleListItems: {
        check: "Integer",
        apply: "_updatePosition",
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __selectionList__P_461_0: null,
      __clearButton__P_461_2: null,
      __listScroller__P_461_3: null,
      __menuContainer__P_461_1: null,
      // overridden
      show: function show() {
        qx.ui.mobile.dialog.Menu.prototype.show.base.call(this);
        this.scrollToItem(this.getSelectedIndex());
      },

      /**
       * Creates the clearButton. Override this to customize the widget.
       *
       * @return {qx.ui.mobile.form.Button} the clearButton of this menu.
       */
      _createClearButton: function _createClearButton() {
        var clearButton = new qx.ui.mobile.form.Button(this.getClearButtonLabel());
        clearButton.addListener("tap", this.__onClearButtonTap__P_461_4, this);
        clearButton.exclude();
        return clearButton;
      },

      /**
       * Creates the scroll container for the selectionList. Override this to customize the widget.
       * @param selectionList {qx.ui.mobile.list.List} The selectionList of this menu.
       * @return {qx.ui.mobile.container.Scroll} the scroll container which contains the selectionList of this menu.
       */
      _createListScroller: function _createListScroller(selectionList) {
        var listScroller = new qx.ui.mobile.container.Scroll({
          "snap": ".list-item"
        });
        listScroller.add(selectionList, {
          flex: 1
        });
        listScroller.addCssClass("menu-scroller");
        return listScroller;
      },

      /**
      * Getter for the scroll container which contains a @see {qx.ui.mobile.list.List} with the choosable items.
      * @return {qx.ui.mobile.container.Scroll} the scroll container which contains the selectionList of this menu.
      */
      _getListScroller: function _getListScroller() {
        return this.__listScroller__P_461_3;
      },
      // overridden
      _updatePosition: function _updatePosition() {
        var parentHeight = qx.ui.mobile.dialog.Popup.ROOT.getHeight();
        var listScrollerHeight = parseInt(parentHeight, 10) * 0.75;
        listScrollerHeight = parseInt(listScrollerHeight, 10);

        if (this.getVisibleListItems() !== null) {
          var newListScrollerHeight = this.__selectionList__P_461_0.getListItemHeight() * this.getVisibleListItems();
          listScrollerHeight = Math.min(newListScrollerHeight, listScrollerHeight);
        }

        qx.bom.element.Style.set(this.__listScroller__P_461_3.getContainerElement(), "maxHeight", listScrollerHeight + "px");

        qx.ui.mobile.dialog.Menu.prototype._updatePosition.base.call(this);
      },

      /**
       * Creates the selection list. Override this to customize the widget.
       *
       * @return {qx.ui.mobile.list.List} The selectionList of this menu.
       */
      _createSelectionList: function _createSelectionList() {
        var self = this;
        var selectionList = new qx.ui.mobile.list.List({
          configureItem: function configureItem(item, data, row) {
            item.setTitle(data);
            item.setShowArrow(false);
            var isItemSelected = self.getSelectedIndex() == row;

            if (isItemSelected) {
              item.removeCssClass(self.getUnselectedItemClass());
              item.addCssClass(self.getSelectedItemClass());
            } else {
              item.removeCssClass(self.getSelectedItemClass());
              item.addCssClass(self.getUnselectedItemClass());
            }
          }
        }); // Add an changeSelection event

        selectionList.addListener("changeSelection", this.__onListChangeSelection__P_461_5, this);
        selectionList.addListener("tap", this._onSelectionListTap, this);
        return selectionList;
      },

      /**
      * Getter for the selectionList of the menu.
      * @return {qx.ui.mobile.list.List} The selectionList of this menu.
      */
      getSelectionList: function getSelectionList() {
        return this.__selectionList__P_461_0;
      },

      /** Handler for tap event on selection list. */
      _onSelectionListTap: function _onSelectionListTap() {
        this.hideWithDelay(500);
      },

      /**
       * Sets the choosable items of the menu.
       * @param itemsModel {qx.data.Array}, the model of choosable items in the menu.
       */
      setItems: function setItems(itemsModel) {
        if (this.__selectionList__P_461_0) {
          this.__selectionList__P_461_0.setModel(null);

          this.__selectionList__P_461_0.setModel(itemsModel);
        }
      },

      /**
       * Fires an event which contains index and data.
       * @param evt {qx.event.type.Data}, contains the selected index number.
       */
      __onListChangeSelection__P_461_5: function __onListChangeSelection__P_461_5(evt) {
        this.setSelectedIndex(evt.getData());
      },

      /**
       * Event handler for tap on clear button.
       */
      __onClearButtonTap__P_461_4: function __onClearButtonTap__P_461_4() {
        this.fireDataEvent("changeSelection", {
          index: null,
          item: null
        });
        this.hide();
      },
      // property apply
      _applySelectedIndex: function _applySelectedIndex(value, old) {
        var listModel = this.__selectionList__P_461_0.getModel();

        if (listModel !== null) {
          var selectedItem = listModel.getItem(value);
          this.fireDataEvent("changeSelection", {
            index: value,
            item: selectedItem
          });
        }

        this._render();
      },
      // property apply
      _applyNullable: function _applyNullable(value, old) {
        if (value) {
          this.__clearButton__P_461_2.setVisibility("visible");
        } else {
          this.__clearButton__P_461_2.setVisibility("excluded");
        }
      },
      // property apply
      _applyClearButtonLabel: function _applyClearButtonLabel(value, old) {
        this.__clearButton__P_461_2.setValue(value);
      },

      /**
       * Triggers (re-)rendering of menu items.
       */
      _render: function _render() {
        var tmpModel = this.__selectionList__P_461_0.getModel();

        this.__selectionList__P_461_0.setModel(null);

        this.__selectionList__P_461_0.setModel(tmpModel);
      },

      /**
       * Scrolls the scroll wrapper of the selectionList to the item with given index.
       * @param index {Integer}, the index of the listItem to which the listScroller should scroll to.
       */
      scrollToItem: function scrollToItem(index) {
        if (index !== null && this.__selectionList__P_461_0.getModel() != null) {
          var listItems = qxWeb("#" + this.__listScroller__P_461_3.getId() + " .list-item");
          var targetListItemElement = listItems[index];

          this.__listScroller__P_461_3.scrollToElement(targetListItemElement);
        }
      }
    },
    destruct: function destruct() {
      this.__selectionList__P_461_0.removeListener("tap", this._onSelectionListTap, this);

      this._disposeObjects("__selectionList__P_461_0", "__clearButton__P_461_2", "__listScroller__P_461_3", "__menuContainer__P_461_1");
    }
  });
  qx.ui.mobile.dialog.Menu.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Creates a HTML canvas widget in your mobile application.
   *
   * *Example*
   *
   * Here is an example of how to use the canvas widget.
   *
   * <pre class='javascript'>
   * var canvas = new qx.ui.mobile.embed.Canvas();
   *
   * canvas.setWidth(150);
   * canvas.setHeight(150);
   * this.getContent().add(canvas);
   *
   * var ctx = canvas.getContext2d();
   * ctx.strokeStyle = '#3D72C9';
   * ctx.beginPath();
   * ctx.arc(75,85,50,0,Math.PI*2,true);
   * ctx.moveTo(110,85);
   * ctx.arc(75,85,35,0,Math.PI,false);
   * ctx.moveTo(65,75);
   * ctx.arc(60,75,5,0,Math.PI*2,true);
   * ctx.moveTo(95,75);
   * ctx.arc(90,75,5,0,Math.PI*2,true);
   * ctx.stroke();
   * </pre>
   *
   */
  qx.Class.define("qx.ui.mobile.embed.Canvas", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     */
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "canvas";
      },

      /**
       * Get the canvas element [<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvas">W3C-HMTL5</a>]
       *
       * @return {Element} The canvas DOM element.
       */
      getCanvas: function getCanvas() {
        return this.getContainerElement();
      },

      /**
       * Set the width attribute of the canvas element. This property controls the
       * size of the canvas coordinate space.
       *
       * @param width {Integer} canvas width
       */
      setWidth: function setWidth(width) {
        this.getContainerElement().width = width;
      },

      /**
       * Get the width attribute of the canvas element
       *
       * @return {Integer} canvas width
       */
      getWidth: function getWidth() {
        return this.getContainerElement().width;
      },

      /**
       * Set the height attribute of the canvas element. This property controls the
       * size of the canvas coordinate space.
       *
       * @param height {Integer} canvas height
       */
      setHeight: function setHeight(height) {
        this.getContainerElement().height = height;
      },

      /**
       * Get the height attribute of the canvas element
       *
       * @return {Integer} canvas height
       */
      getHeight: function getHeight() {
        return this.getContainerElement().height;
      },

      /**
       * Get the canvas' 2D rendering context
       * [<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasrenderingcontext2d">W3C-HTML5</a>].
       * All drawing operations are performed on this context.
       *
       * @return {CanvasRenderingContext2D} The 2D rendering context.
       */
      getContext2d: function getContext2d() {
        return this.getContainerElement().getContext("2d");
      }
    }
  });
  qx.ui.mobile.embed.Canvas.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The Html widget embeds plain HTML code into the application
   *
   * *Example*
   *
   * Here is a little example of how to use the html widget.
   *
   * <pre class='javascript'>
   * var html = new qx.ui.mobile.embed.Html();
   * html.setHtml("<h1>Hello World</h1>");
   * </pre>
   *
   */
  qx.Class.define("qx.ui.mobile.embed.Html", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param html {String?null} Initial HTML content
     */
    construct: function construct(html) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (html) {
        this.setHtml(html);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Any text string which can contain HTML, too */
      html: {
        check: "String",
        init: null,
        nullable: true,
        event: "changeHtml",
        apply: "_applyHtml"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // property apply
      _applyHtml: function _applyHtml(value, old) {
        this._setHtml(value);
      }
    }
  });
  qx.ui.mobile.embed.Html.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Input": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The Checkbox is the mobile correspondent of the html checkbox.
   *
   * *Example*
   *
   * <pre class='javascript'>
   *   var checkBox = new qx.ui.mobile.form.CheckBox();
   *   var title = new qx.ui.mobile.form.Title("Title");
   *
   *   checkBox.setModel("Title Activated");
   *   checkBox.bind("model", title, "value");
   *
   *   checkBox.addListener("changeValue", function(evt){
   *     this.setModel(evt.getdata() ? "Title Activated" : "Title Deactivated");
   *   });
   *
   *   this.getRoot.add(checkBox);
   *   this.getRoot.add(title);
   * </pre>
   *
   * This example adds 2 widgets , a checkBox and a Title and binds them together by their model and value properties.
   * When the user taps on the checkbox, its model changes and it is reflected in the Title's value.
   *
   */
  qx.Class.define("qx.ui.mobile.form.CheckBox", {
    extend: qx.ui.mobile.form.Input,
    include: [qx.ui.mobile.form.MValue],
    implement: [qx.ui.form.IField],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {Boolean?false} The value of the checkbox.
     */
    construct: function construct(value) {
      qx.ui.mobile.form.Input.constructor.call(this);

      if (typeof value != undefined) {
        this._state = value;
      }

      this.addListener("tap", this._onTap, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "checkbox"
      }
    },
    members: {
      _state: null,
      // overridden
      _getTagName: function _getTagName() {
        return "span";
      },
      // overridden
      _getType: function _getType() {
        return null;
      },

      /**
       * Handler for tap events.
       */
      _onTap: function _onTap() {
        // Toggle State.
        this.setValue(!this.getValue());
      },

      /**
       * Sets the value [true/false] of this checkbox.
       * It is called by setValue method of qx.ui.mobile.form.MValue mixin
       * @param value {Boolean} the new value of the checkbox
       */
      _setValue: function _setValue(value) {
        if (value == true) {
          this.addCssClass("checked");
        } else {
          this.removeCssClass("checked");
        }

        this._setAttribute("checked", value);

        this._state = value;
      },

      /**
       * Gets the value [true/false] of this checkbox.
       * It is called by getValue method of qx.ui.mobile.form.MValue mixin
       * @return {Boolean} the value of the checkbox
       */
      _getValue: function _getValue() {
        return this._state;
      }
    },

    /*
    *****************************************************************************
        DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.removeListener("tap", this._onTap, this);
    }
  });
  qx.ui.mobile.form.CheckBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.Form": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Representation of a form. A form widget can contain one or more {@link Row} widgets.
   *
   * *Example*
   *
   * Here is an example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var title = new qx.ui.mobile.form.Title("Group");
   *   var form = new qx.ui.mobile.form.Form();
   *   form.add(new qx.ui.mobile.form.TextField(), "Username: ");
   *
   *   this.getRoot().add(title);
   *   this.getRoot().add(new qx.ui.mobile.form.renderer.Single(form));
   * </pre>
   *
   * This example creates a form and adds a row with a text field in it.
   */
  qx.Class.define("qx.ui.mobile.form.Form", {
    extend: qx.ui.form.Form,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.form.Form.constructor.call(this);
      this.__invalidItems__P_463_0 = [];
    },
    members: {
      /**
       * the renderer this form uses to be displayed
       */
      __renderer__P_463_1: null,

      /**
       * Contains all invalid items.
       */
      __invalidItems__P_463_0: null,

      /**
       * Setter for the renderer private variable
       * @param renderer {qx.ui.mobile.form.renderer.AbstractRenderer} the renderer
       */
      setRenderer: function setRenderer(renderer) {
        this.__renderer__P_463_1 = renderer;
      },

      /**
       * Validates the form using the
       * {@link qx.ui.form.validation.Manager#validate} method.
       * @lint ignoreDeprecated(alert)
       *
       * @return {Boolean | null} The validation result.
       */
      validate: function validate() {
        var validateResult = qx.ui.mobile.form.Form.prototype.validate.base.call(this);
        this.__invalidItems__P_463_0 = [];

        if (this.__renderer__P_463_1 != null) {
          this.__renderer__P_463_1.resetForm();
        }

        var groups = this.getGroups();

        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];

          for (var j = 0; j < group.items.length; j++) {
            var item = group.items[j];

            if (!item.isValid()) {
              this.__invalidItems__P_463_0.push(item);

              if (this.__renderer__P_463_1 != null) {
                this.__renderer__P_463_1.showErrorForItem(item);
              } else {
                alert('error ' + item.getInvalidMessage());
              }
            }
          }
        }

        if (this.__renderer__P_463_1 != null) {
          this.__renderer__P_463_1._domUpdated();
        }

        return validateResult;
      },

      /**
       * Makes a row visible, identified by its group and row index.
       * @param groupIndex {Integer} the index of the group to which the row belongs to
       * @param rowIndex {Integer} the index of the row inside the target group
       */
      showRow: function showRow(groupIndex, rowIndex) {
        var item = this._getItemByIndex(groupIndex, rowIndex);

        if (item) {
          this.__renderer__P_463_1.showItem(item);
        }
      },

      /**
       * Makes a row invisible, identified by its group and row index.
       * @param groupIndex {Integer} the index of the group to which the row belongs to
       * @param rowIndex {Integer} the index of the row inside the target group
       */
      hideRow: function hideRow(groupIndex, rowIndex) {
        var item = this._getItemByIndex(groupIndex, rowIndex);

        if (item) {
          this.__renderer__P_463_1.hideItem(item);
        }
      },

      /**
       * Gets the item with the given group and rowIndex.
       * @param groupIndex {Integer} the index of the group to which the row belongs to
       * @param rowIndex {Integer} the index of the row inside the target group
       * @return {qx.ui.form.IForm | null} The validation result.
       */
      _getItemByIndex: function _getItemByIndex(groupIndex, rowIndex) {
        var groups = this.getGroups();
        var group = groups[groupIndex];

        if (group) {
          var item = group.items[rowIndex];
          return item;
        }

        return null;
      },
      // overridden
      reset: function reset() {
        qx.ui.mobile.form.Form.prototype.reset.base.call(this);

        this.__renderer__P_463_1.resetForm();
      },

      /**
      * Returns the invalid items of the form, which were determined by {@link qx.ui.mobile.form.Form#validate} before.
      * It returns an empty array if no items are invalid.
      * @return {qx.ui.mobile.core.Widget[]} The invalid items of the form.
      */
      getInvalidItems: function getInvalidItems() {
        return this.__invalidItems__P_463_0;
      }
    }
  });
  qx.ui.mobile.form.Form.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * A group widget arranges several widgets visual.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var title = new qx.ui.mobile.form.Title("Group");
   *   var list = new qx.ui.mobile.list.List();
   *   var group = new qx.ui.mobile.form.Group([list]);
   *
   *   this.getRoot.add(title);
   *   this.getRoot.add(group);
   * </pre>
   *
   * This example creates a group and adds a list to it.
   */
  qx.Class.define("qx.ui.mobile.form.Group", {
    extend: qx.ui.mobile.container.Composite,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param widgets {qx.ui.mobile.core.Widget[]}
     * @param showBorder {Boolean?} initial value of the property showBorder.
     */
    construct: function construct(widgets, showBorder) {
      qx.ui.mobile.container.Composite.constructor.call(this);
      this.addCssClass("bordered");

      if (showBorder != null) {
        this.setShowBorder(showBorder);
      } // Convenience: Add all widgets of array to group.


      if (widgets) {
        for (var i = 0; i < widgets.length; i++) {
          this.add(widgets[i]);
        }
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "group"
      },

      /**
       * Defines whether a border should drawn around the group.
       */
      showBorder: {
        check: "Boolean",
        init: true,
        apply: "_onChangeShowBorder"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Reacts on change of showBorder property.
       */
      _onChangeShowBorder: function _onChangeShowBorder() {
        if (this.isShowBorder() == true) {
          this.addCssClass("bordered");
        } else {
          this.removeCssClass("bordered");
        }
      }
    }
  });
  qx.ui.mobile.form.Group.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.bom.client.Css": {},
      "qx.bom.client.Event": {},
      "qx.event.Registration": {},
      "qx.event.type.Tap": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.flexboxSyntax": {
          "className": "qx.bom.client.Css"
        },
        "event.dispatchevent": {
          "className": "qx.bom.client.Event"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The label widget displays a text or HTML content in form context.
   *
   * It uses the html tag <label>, for making it possible to set the
   * "for" attribute.
   *
   * The "for" attribute specifies which form element a label is bound to.
   * A tap on the label is forwarded to the bound element.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var checkBox = new qx.ui.mobile.form.CheckBox();
   *   var label = new qx.ui.mobile.form.Label("Label for CheckBox");
   *
   *   label.setLabelFor(checkBox.getId());
   *
   *   this.getRoot().add(label);
   *   this.getRoot().add(checkBox);
   * </pre>
   *
   * This example create a widget to display the label.
   *
   */
  qx.Class.define("qx.ui.mobile.form.Label", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {String?null} Text or HTML content to display
     */
    construct: function construct(value) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (value) {
        this.setValue(value);
      }

      this.addCssClass("gap");

      this._setLayout(new qx.ui.mobile.layout.HBox().set({
        "alignY": "middle",
        "alignX": "left"
      }));

      this.initWrap();
      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      }
      this.addListener("tap", this._onTap, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "label"
      },

      /**
       * Text or HTML content to display
       */
      value: {
        nullable: true,
        init: null,
        apply: "_applyValue",
        event: "changeValue"
      },
      // overridden
      anonymous: {
        refine: true,
        init: false
      },

      /**
       * Controls whether text wrap is activated or not.
       */
      wrap: {
        check: "Boolean",
        init: true,
        apply: "_applyWrap"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __forWidget__P_464_0: null,
      // overridden
      _getTagName: function _getTagName() {
        return "label";
      },
      // property apply
      _applyValue: function _applyValue(value, old) {
        var html = value; // [BUG #7871] Bugfix for IE 10 for enabling word-wrap within a flexbox layout.

        if (qx.core.Environment.get("css.flexboxSyntax") === "flexbox") {
          html = "<p>" + value + "</p>";
        }

        this._setHtml(html);
      },
      // property apply
      _applyWrap: function _applyWrap(value, old) {
        if (value) {
          this.removeCssClass("no-wrap");
        } else {
          this.addCssClass("no-wrap");
        }
      },

      /**
      * Event handler for the <code>changeEnabled</code> event on the target.
      * @param evt {qx.event.type.Data} the changeEnabled event.
      */
      _changeEnabled: function _changeEnabled(evt) {
        if (evt) {
          this.setEnabled(evt.getData());
        }
      },

      /**
       * Setter for the "for" attribute of this label.
       * The "for" attribute specifies which form element a label is bound to.
       *
       * @param elementId {String} The id of the element the label is bound to.
       *
       */
      setLabelFor: function setLabelFor(elementId) {
        if (this.__forWidget__P_464_0) {
          this.__forWidget__P_464_0.removeListener("changeEnabled", this._changeEnabled, this);
        }

        this.__forWidget__P_464_0 = qx.ui.mobile.core.Widget.getWidgetById(elementId);

        if (this.__forWidget__P_464_0) {
          this.__forWidget__P_464_0.addListener("changeEnabled", this._changeEnabled, this);

          this.setEnabled(this.__forWidget__P_464_0.getEnabled());
        }

        this._setAttribute("for", elementId);
      },

      /**
       * Handler for <code>tap</code> event on the Label. This event will be delegated to target widget.
       * @param evt {qx.event.type.Pointer} The tap event.
       */
      _onTap: function _onTap(evt) {
        if (this.__forWidget__P_464_0 && qx.core.Environment.get("event.dispatchevent")) {
          var target = this.__forWidget__P_464_0.getContentElement();

          qx.event.Registration.fireEvent(target, "tap", qx.event.type.Tap, [evt.getNativeEvent(), target, null, true, true]);
        }
      },

      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale: function _onChangeLocale(e) {
        var content = this.getValue();

        if (content && content.translate) {
          this.setValue(content.translate());
        }
      }
    },
    destruct: function destruct() {
      this.removeListener("tap", this._onTap, this);

      if (this.__forWidget__P_464_0) {
        this.__forWidget__P_464_0.removeListener("changeEnabled", this._changeEnabled, this);

        this.__forWidget__P_464_0 = null;
      }

      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      }
    }
  });
  qx.ui.mobile.form.Label.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.TextField": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The PasswordField is a single-line password input field.
   */
  qx.Class.define("qx.ui.mobile.form.PasswordField", {
    extend: qx.ui.mobile.form.TextField,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "password-field"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getType: function _getType() {
        return "password";
      }
    }
  });
  qx.ui.mobile.form.PasswordField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Input": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.event.Registration": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The Radio button for mobile.
   *
   * *Example*
   *
   * <pre class='javascript'>
   *    var form = new qx.ui.mobile.form.Form();
   *
   *    var radio1 = new qx.ui.mobile.form.RadioButton();
   *    var radio2 = new qx.ui.mobile.form.RadioButton();
   *    var radio3 = new qx.ui.mobile.form.RadioButton();
   *
   *    var group = new qx.ui.mobile.form.RadioGroup(radio1, radio2, radio3);
  
   *    form.add(radio1, "Germany");
   *    form.add(radio2, "UK");
   *    form.add(radio3, "USA");
   *
   *    this.getRoot.add(new qx.ui.mobile.form.renderer.Single(form));
   * </pre>
   *
   *
   */
  qx.Class.define("qx.ui.mobile.form.RadioButton", {
    extend: qx.ui.mobile.form.Input,
    include: [qx.ui.mobile.form.MValue],
    implement: [qx.ui.form.IField],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {Boolean?null} The value of the checkbox.
     */
    construct: function construct(value) {
      qx.ui.mobile.form.Input.constructor.call(this);
      this.addListener("tap", this._onTap, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the selection value is changed.
       */
      changeValue: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "radio"
      },

      /** The assigned qx.ui.form.RadioGroup which handles the switching between registered buttons */
      group: {
        check: "qx.ui.mobile.form.RadioGroup",
        nullable: true,
        apply: "_applyGroup"
      }
    },
    members: {
      _state: null,
      // overridden
      _getTagName: function _getTagName() {
        return "span";
      },
      // overridden
      _getType: function _getType() {
        return null;
      },

      /**
       * Reacts on tap on radio button.
       */
      _onTap: function _onTap() {
        this.fireDataEvent("changeValue", {}); // Toggle State.

        this.setValue(true);
      },

      /**
       * The assigned {@link qx.ui.form.RadioGroup} which handles the switching between registered buttons
       * @param value {qx.ui.form.RadioGroup} the new radio group to which this radio button belongs.
       * @param old {qx.ui.form.RadioGroup} the old radio group of this radio button.
       */
      _applyGroup: function _applyGroup(value, old) {
        if (old) {
          old.remove(this);
        }

        if (value) {
          value.add(this);
        }
      },

      /**
       * Sets the value [true/false] of this radio button.
       * It is called by setValue method of qx.ui.mobile.form.MValue mixin
       * @param value {Boolean} the new value of the radio button
       */
      _setValue: function _setValue(value) {
        if (value == true) {
          this.addCssClass("checked");
        } else {
          this.removeCssClass("checked");
        }

        this._state = value;
      },

      /**
       * Gets the value [true/false] of this radio button.
       * It is called by getValue method of qx.ui.mobile.form.MValue mixin
       * @return {Boolean} the value of the radio button
       */
      _getValue: function _getValue() {
        return this._state;
      }
    },

    /*
    *****************************************************************************
        DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      qx.event.Registration.removeListener(this, "tap", this._onTap, this);
    }
  });
  qx.ui.mobile.form.RadioButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.RadioGroup": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The Radio button group for mobile usage.
   *
   * *Example*
   *
   * <pre class='javascript'>
   *    var form = new qx.ui.mobile.form.Form();
   *
   *    var radio1 = new qx.ui.mobile.form.RadioButton();
   *    var radio2 = new qx.ui.mobile.form.RadioButton();
   *    var radio3 = new qx.ui.mobile.form.RadioButton();
   *
   *    var radiogroup = new qx.ui.mobile.form.RadioGroup(radio1, radio2, radio3);
  
   *    form.add(radio1, "Germany");
   *    form.add(radio2, "UK");
   *    form.add(radio3, "USA");
   *
   *    this.getRoot.add(new qx.ui.mobile.form.renderer.Single(form));
   * </pre>
   *
   *
   */
  qx.Class.define("qx.ui.mobile.form.RadioGroup", {
    extend: qx.ui.form.RadioGroup
  });
  qx.ui.mobile.form.RadioGroup.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The Row widget represents a row in a {@link Form}.
   */
  qx.Class.define("qx.ui.mobile.form.Row", {
    extend: qx.ui.mobile.container.Composite,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param layout {qx.ui.mobile.layout.Abstract?null} The layout that should be used for this
     *     container
     */
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout);
      this.initSelectable();
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "form-row"
      },

      /**
       * Whether the widget is selectable or not.
       */
      selectable: {
        check: "Boolean",
        init: false,
        apply: "_applyAttribute"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "li";
      }
    }
  });
  qx.ui.mobile.form.Row.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.mobile.form.MText": {
        "require": true
      },
      "qx.ui.mobile.form.MState": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.mobile.dialog.Menu": {},
      "qx.lang.Type": {},
      "qx.core.ValidationError": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The SelectBox
   *
   * an example, how to use the SelectBox:
   * *Example*
   *
   * <pre class='javascript'>
   *    var page1 = new qx.ui.mobile.page.Page();
   *    page1.addListener("initialize", function()
   *    {
   *      var sel = new qx.ui.mobile.form.SelectBox();
   *      page1.add(sel);
   *      var model = new qx.data.Array(["item1","item2"]);
   *      sel.setModel(model);
   *      model.push("item3");
   *
   *      var but = new qx.ui.mobile.form.Button("setSelection");
   *      page1.add(but);
   *      but.addListener("tap", function(){
   *        sel.setSelection("item3");
   *      }, this);
   *
   *      sel.addListener("changeSelection", function(evt) {
   *        console.log(evt.getData());
   *      }, this);
   *
   *      var title = new qx.ui.mobile.form.Title("item2");
   *      title.bind("value",sel,"value");
   *      sel.bind("value",title,"value");
   *      page1.add(title);
   *   },this);
   *
   *   page1.show();
   *  </pre>
   */
  qx.Class.define("qx.ui.mobile.form.SelectBox", {
    extend: qx.ui.mobile.core.Widget,
    include: [qx.ui.mobile.form.MValue, qx.ui.form.MForm, qx.ui.mobile.form.MText, qx.ui.mobile.form.MState],
    implement: [qx.ui.form.IForm, qx.ui.form.IField, qx.ui.form.IModel],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this); // This text node is for compatibility reasons, because Firefox can not
      // change appearance of SelectBoxes.

      this._setAttribute("type", "text");

      this.setReadOnly(true);
      this.addListener("focus", this.blur);
      this.addListener("tap", this._onTap, this); // Selection dialog creation.

      this.__selectionDialog__P_467_0 = this._createSelectionDialog();
      this.addCssClass("gap"); // When selectionDialogs changes selection, get chosen selectedIndex from it.

      this.__selectionDialog__P_467_0.addListener("changeSelection", this._onChangeSelection, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when user selects an item.
       */
      changeSelection: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "selectbox"
      },
      // overridden
      activatable: {
        refine: true,
        init: true
      },

      /**
       * Defines if the SelectBox has a clearButton, which resets the selection.
       */
      nullable: {
        init: true,
        check: "Boolean",
        apply: "_applyNullable"
      },

      /**
       * The model to use to render the list.
       */
      model: {
        check: "qx.data.Array",
        apply: "_applyModel",
        event: "changeModel",
        nullable: true,
        init: null
      },

      /**
       * The selected index of this SelectBox.
       */
      selection: {
        init: null,
        validate: "_validateSelection",
        apply: "_applySelection",
        nullable: true
      }
    },
    members: {
      __selectionDialog__P_467_0: null,
      // overridden
      _getTagName: function _getTagName() {
        // No select here, see BUG #6054
        return "input";
      },

      /**
       * Creates the menu dialog. Override this to customize the widget.
       *
       * @return {qx.ui.mobile.dialog.Menu} A dialog, containing a selection list.
       */
      _createSelectionDialog: function _createSelectionDialog() {
        var menu = new qx.ui.mobile.dialog.Menu(); // Special appearance for SelectBox menu items.

        menu.setSelectedItemClass("selectbox-selected");
        menu.setUnselectedItemClass("selectbox-unselected"); // Hide selectionDialog on tap on blocker.

        menu.setHideOnBlockerTap(true);
        return menu;
      },

      /**
       * Returns the SelectionDialog.
       * @return {qx.ui.mobile.dialog.Menu} the SelectionDialog.
       */
      getSelectionDialog: function getSelectionDialog() {
        return this.__selectionDialog__P_467_0;
      },

      /**
       * Sets the dialog title on the selection dialog.
       * @param title {String} the title to set on selection dialog.
       */
      setDialogTitle: function setDialogTitle(title) {
        this.__selectionDialog__P_467_0.setTitle(title);
      },

      /**
       * Set the ClearButton label of the selection dialog.
       * @param value {String} the value to set on the ClearButton at selection dialog.
       */
      setClearButtonLabel: function setClearButtonLabel(value) {
        this.__selectionDialog__P_467_0.setClearButtonLabel(value);
      },

      /**
       * Sets the selected text value of this SelectBox.
       * @param value {String} the text value which should be selected.
       */
      _setValue: function _setValue(value) {
        if (this.getModel() == null) {
          return;
        }

        if (value == "") {
          if (this.isNullable()) {
            this.setSelection(null);
          } else {
            this.setSelection(0);
          }
        } else if (value != null) {
          this.setSelection(this.getModel().indexOf(value));
        } else {
          this.setSelection(null);
        }
      },

      /**
       * Get the text value of this
       * It is called by setValue method of qx.ui.mobile.form.MValue mixin.
       * @return {Number} the new selected index of the SelectBox.
       */
      _getValue: function _getValue() {
        return this._getAttribute("value");
      },

      /**
       * Renders this SelectBox. Override this if you would like to display the
       * values of the SelectBox in a different way than the default.
       */
      _render: function _render() {
        if (this.getModel() != null && this.getModel().length > 0) {
          var selectedItem = this.getModel().getItem(this.getSelection());

          this._setAttribute("value", selectedItem);
        }

        this._domUpdated();
      },

      /**
       * Sets the model property to the new value
       * @param value {qx.data.Array}, the new model
       * @param old {qx.data.Array?}, the old model
       */
      _applyModel: function _applyModel(value, old) {
        value.addListener("change", this._render, this);

        if (old != null) {
          old.removeListener("change", this._render, this);
        }

        this._render();
      },

      /**
       * Refreshs selection dialogs model, and shows it.
       */
      __showSelectionDialog__P_467_1: function __showSelectionDialog__P_467_1() {
        if (this.isEnabled() == true) {
          // Set index before items, because setItems() triggers rendering.
          this.__selectionDialog__P_467_0.setSelectedIndex(this.getSelection());

          this.__selectionDialog__P_467_0.setItems(this.getModel());

          this.__selectionDialog__P_467_0.show();
        }
      },

      /**
       * Gets the selectedIndex out of change selection event and renders view.
       * @param evt {qx.event.type.Data} data event.
       */
      _onChangeSelection: function _onChangeSelection(evt) {
        this.setSelection(evt.getData().index);

        this._render();
      },

      /**
      * Handler for <code>tap</code> event on this widget.
      * @param evt {qx.event.type.Tap} the handling tap event.
      */
      _onTap: function _onTap(evt) {
        this.__showSelectionDialog__P_467_1(); // request focus so that it leaves previous widget
        // such as text field and hide virtual keyboard.


        evt.getOriginalTarget().focus();
      },

      /**
       * Validates the selection value.
       * @param value {Integer} the selection value to validate.
       */
      _validateSelection: function _validateSelection(value) {
        if (value != null && qx.lang.Type.isNumber(value) == false) {
          throw new qx.core.ValidationError("Validation Error: Input value is not a number");
        }

        if (this.getModel() === null) {
          throw new qx.core.ValidationError("Validation Error: Please apply model before selection");
        }

        if (!this.isNullable() && value === null) {
          throw new qx.core.ValidationError("Validation Error: SelectBox is not nullable");
        }

        if (value != null && (value < 0 || value >= this.getModel().getLength())) {
          throw new qx.core.ValidationError("Validation Error: Input value is out of model range");
        }
      },
      // property apply
      _applySelection: function _applySelection(value, old) {
        var selectedItem = this.getModel().getItem(value);
        this.fireDataEvent("changeSelection", {
          index: value,
          item: selectedItem
        });

        this._render();
      },
      // property apply
      _applyNullable: function _applyNullable(value, old) {
        // Delegate nullable property.
        this.__selectionDialog__P_467_0.setNullable(value);
      }
    },
    destruct: function destruct() {
      this.__selectionDialog__P_467_0.removeListener("changeSelection", this._onChangeSelection, this);

      this._disposeObjects("__selectionDialog__P_467_0", "__selectionDialogTitle__P_467_2");

      this.removeListener("focus", this.blur);
      this.removeListener("tap", this._onTap, this);
    }
  });
  qx.ui.mobile.form.SelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.mobile.form.MState": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.form.INumberForm": {
        "require": true
      },
      "qx.dom.Element": {},
      "qx.event.Registration": {},
      "qx.bom.element.Dimension": {},
      "qx.bom.element.Location": {},
      "qx.bom.AnimationFrame": {},
      "qx.bom.element.Style": {},
      "qx.bom.element.Attribute": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The Slider widget provides horizontal slider.
   *
   * The Slider is the classic widget for controlling a bounded value.
   * It lets the user move a slider handle along a horizontal
   * groove and translates the handle's position into an integer value
   * within the defined range.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *    var slider= new qx.ui.mobile.form.Slider().set({
   *       minimum : 0,
   *       maximum : 10,
   *       step : 2
   *     });
   *     slider.addListener("changeValue", handler, this);
   *
   *   this.getRoot.add(slider);
   * </pre>
   *
   * This example creates a slider and attaches an
   * event listener to the {@link #changeValue} event.
   */
  qx.Class.define("qx.ui.mobile.form.Slider", {
    extend: qx.ui.mobile.core.Widget,
    include: [qx.ui.mobile.form.MValue, qx.ui.form.MForm, qx.ui.form.MModelProperty, qx.ui.mobile.form.MState],
    implement: [qx.ui.form.IForm, qx.ui.form.IModel, qx.ui.form.INumberForm],
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);

      this._registerEventListener();

      this._refresh();

      this.addCssClass("gap");
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "slider"
      },

      /**
       * The minimum slider value (may be negative). This value must be smaller
       * than {@link #maximum}.
       */
      minimum: {
        check: "Number",
        init: 0,
        apply: "_refresh",
        event: "changeMinimum"
      },

      /**
       * The maximum slider value (may be negative). This value must be larger
       * than {@link #minimum}.
       */
      maximum: {
        check: "Number",
        init: 100,
        apply: "_refresh",
        event: "changeMaximum"
      },

      /**
       * The amount to increment on each event. Typically corresponds
       * to the user moving the knob.
       */
      step: {
        check: "Number",
        init: 1,
        event: "changeStep"
      },

      /**
       * Reverses the display direction of the slider knob. If true, the maxmium of
       * the slider is on the left side and minimum on the right side.
       */
      reverseDirection: {
        check: "Boolean",
        init: false,
        apply: "_refresh"
      },

      /**
       * Adjusts which slider value should be displayed inside the knob.
       * If <code>null</code> no value will be displayed.
       */
      displayValue: {
        init: "percent",
        check: ["value", "percent"],
        nullable: true,
        apply: "_applyDisplayValue"
      }
    },
    members: {
      _knobElement: null,
      _containerElementWidth: null,
      _containerElementLeft: null,
      _pixelPerStep: null,
      __value__P_468_0: 0,

      /**
       * Increments the current value.
       */
      nextValue: function nextValue() {
        this.setValue(this.getValue() + this.getStep());
      },

      /**
       * Decrements the current value.
       */
      previousValue: function previousValue() {
        this.setValue(this.getValue() - this.getStep());
      },
      // overridden
      _createContainerElement: function _createContainerElement() {
        var container = qx.ui.mobile.form.Slider.prototype._createContainerElement.base.call(this);

        container.appendChild(this._createKnobElement());
        return container;
      },

      /**
       * Creates the knob element.
       *
       * @return {Element} The created knob element
       */
      _createKnobElement: function _createKnobElement() {
        return qx.dom.Element.create("div");
      },

      /**
       * Registers all needed event listener.
       */
      _registerEventListener: function _registerEventListener() {
        this.addListener("pointerdown", this._onPointerDown, this);
        this.addListener("track", this._onTrack, this);
        this.addListener("appear", this._refresh, this);
        qx.event.Registration.addListener(window, "resize", this._refresh, this);
        qx.event.Registration.addListener(window, "orientationchange", this._refresh, this);
        this.addListenerOnce("domupdated", this._refresh, this);
      },

      /**
       * Unregisters all needed event listener.
       */
      _unregisterEventListener: function _unregisterEventListener() {
        this.removeListener("pointerdown", this._onPointerDown, this);
        this.removeListener("track", this._onTrack, this);
        this.removeListener("appear", this._refresh, this);
        qx.event.Registration.removeListener(window, "resize", this._refresh, this);
        qx.event.Registration.removeListener(window, "orientationchange", this._refresh, this);
        this.removeListener("domupdated", this._refresh, this);
      },

      /**
       * Refreshes the slider and the knob position.
       */
      _refresh: function _refresh() {
        this._updateSizes();

        this._updateKnobPosition();
      },

      /**
       * Updates all internal sizes of the slider.
       */
      _updateSizes: function _updateSizes() {
        var containerElement = this.getContainerElement();

        if (containerElement) {
          this._containerElementWidth = qx.bom.element.Dimension.getWidth(containerElement);
          this._containerElementLeft = qx.bom.element.Location.getLeft(containerElement);
          this._pixelPerStep = this._getPixelPerStep(this._containerElementWidth);
        }
      },

      /**
       * Event handler. Called when the <code>pointerdown</code> event occurs.
       *
       * @param evt {qx.event.type.Pointer} The pointer event.
       */
      _onPointerDown: function _onPointerDown(evt) {
        if (evt.isPrimary()) {
          this._updateSizes();

          var position = this._getPosition(evt.getDocumentLeft());

          this.setValue(this._positionToValue(position));
          evt.stopPropagation();
        }
      },

      /**
       * Event handler. Called when the <code>track</code> event occurs.
       *
       * @param evt {qx.event.type.Track} The track event.
       */
      _onTrack: function _onTrack(evt) {
        var position = this._getPosition(evt.getDocumentLeft());

        this.setValue(this._positionToValue(position));
        evt.stopPropagation();
        evt.preventDefault();
      },

      /**
       * Returns the current position of the knob.
       *
       * @param documentLeft {Integer} The left position of the knob
       * @return {Integer} The current position of the container element.
       */
      _getPosition: function _getPosition(documentLeft) {
        return documentLeft - this._containerElementLeft;
      },

      /**
       * Returns the knob DOM element.
       *
       * @return {Element} The knob DOM element.
       */
      _getKnobElement: function _getKnobElement() {
        if (!this._knobElement) {
          var element = this.getContainerElement();

          if (element) {
            this._knobElement = element.childNodes[0];
          }
        }

        return this._knobElement;
      },

      /**
       * Sets the value of this slider.
       * It is called by setValue method of qx.ui.mobile.form.MValue mixin
       * @param value {Integer} the new value of the slider
       */
      _setValue: function _setValue(value) {
        this.__value__P_468_0 = value;
        qx.bom.AnimationFrame.request(this._refresh, this);
      },

      /**
       * Gets the value [true/false] of this slider.
       * It is called by getValue method of qx.ui.mobile.form.MValue mixin
       * @return {Integer} the value of the slider
       */
      _getValue: function _getValue() {
        return this.__value__P_468_0;
      },

      /**
       * Updates the knob position based on the current value.
       */
      _updateKnobPosition: function _updateKnobPosition() {
        var percent = this._valueToPercent(this.getValue());

        var width = this._containerElementWidth;
        var position = Math.floor(this._percentToPosition(width, percent));

        var knobElement = this._getKnobElement();

        if (knobElement) {
          qx.bom.element.Style.set(this._getKnobElement(), "width", width - (width - position) + "px");
          qx.bom.element.Attribute.set(this._getKnobElement(), "data-value", this.getValue());
          qx.bom.element.Attribute.set(this._getKnobElement(), "data-percent", Math.floor(percent));
        }
      },
      // Property apply
      _applyDisplayValue: function _applyDisplayValue(value, old) {
        if (old != null) {
          this.removeCssClass(old);
        }

        if (value != null) {
          this.addCssClass(value);
        }
      },

      /**
       * Converts the given value to percent.
       *
       * @param value {Integer} The value to convert
       * @return {Integer} The value in percent
       */
      _valueToPercent: function _valueToPercent(value) {
        var min = this.getMinimum();

        var value = this._limitValue(value);

        var percent = (value - min) * 100 / this._getRange();

        if (this.isReverseDirection()) {
          return 100 - percent;
        } else {
          return percent;
        }
      },

      /**
       * Converts the given position to the corresponding value.
       *
       * @param position {Integer} The position to convert
       * @return {Integer} The converted value
       */
      _positionToValue: function _positionToValue(position) {
        var value = this.getMinimum() + Math.round(position / this._pixelPerStep) * this.getStep();
        value = this._limitValue(value);

        if (this.isReverseDirection()) {
          var center = this.getMinimum() + this._getRange() / 2;
          var dist = center - value;
          value = center + dist;
        }

        return value;
      },

      /**
       * Converts the given percent to the position of the knob.
       *
       * @param width {Integer} The width of the slider container element
       * @param percent {Integer} The percent to convert
       * @return {Integer} The position of the knob
       */
      _percentToPosition: function _percentToPosition(width, percent) {
        return width * (percent / 100);
      },

      /**
       * Limits a value to the set {@link #minimum} and {@link #maximum} properties.
       *
       * @param value {Integer} The value to limit
       * @return {Integer} The limited value
       */
      _limitValue: function _limitValue(value) {
        value = Math.min(value, this.getMaximum());
        value = Math.max(value, this.getMinimum());
        return value;
      },

      /**
       * Return the number of pixels per step.
       *
       * @param width {Integer} The width of the slider container element
       * @return {Integer} The pixels per step
       */
      _getPixelPerStep: function _getPixelPerStep(width) {
        return width / this._getOverallSteps();
      },

      /**
       * Return the overall number of steps.
       *
       * @return {Integer} The number of steps
       */
      _getOverallSteps: function _getOverallSteps() {
        return this._getRange() / this.getStep();
      },

      /**
       * Return the range between {@link #maximum} and {@link #minimum}.
       *
       * @return {Integer} The range between {@link #maximum} and {@link #minimum}
       */
      _getRange: function _getRange() {
        return this.getMaximum() - this.getMinimum();
      }
    },
    destruct: function destruct() {
      this._knobElement = null;

      this._unregisterEventListener();
    }
  });
  qx.ui.mobile.form.Slider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.mobile.form.MText": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.mobile.form.MState": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.bom.client.Scroll": {
        "construct": true
      },
      "qx.ui.mobile.container.Scroll": {},
      "qx.ui.mobile.core.Root": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "construct": true,
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * The TextArea is a multi-line text input field.
   */
  qx.Class.define("qx.ui.mobile.form.TextArea", {
    extend: qx.ui.mobile.core.Widget,
    include: [qx.ui.mobile.form.MValue, qx.ui.mobile.form.MText, qx.ui.form.MForm, qx.ui.form.MModelProperty, qx.ui.mobile.form.MState],
    implement: [qx.ui.form.IField, qx.ui.form.IForm, qx.ui.form.IModel],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param value {var?null} The value of the widget.
     */
    construct: function construct(value) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
        this.addListener("appear", this._fixChildElementsHeight, this);
        this.addListener("input", this._fixChildElementsHeight, this);
        this.addListener("changeValue", this._fixChildElementsHeight, this);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "text-area"
      }
    },
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "textarea";
      },

      /**
       * Synchronizes the elements.scrollHeight and its height.
       * Needed for making textArea scrollable.
       * @param evt {qx.event.type.Data} a custom event.
       */
      _fixChildElementsHeight: function _fixChildElementsHeight(evt) {
        this.getContentElement().style.height = 'auto';
        this.getContentElement().style.height = this.getContentElement().scrollHeight + 'px';

        var scroll = this.__getScrollContainer__P_469_0();

        if (scroll) {
          scroll.refresh();
        }
      },

      /**
      * Returns the parent scroll container of this widget.
      * @return {qx.ui.mobile.container.Scroll} the parent scroll container or <code>null</code>
      */
      __getScrollContainer__P_469_0: function __getScrollContainer__P_469_0() {
        var scroll = this;

        while (!(scroll instanceof qx.ui.mobile.container.Scroll)) {
          if (scroll.getLayoutParent) {
            var layoutParent = scroll.getLayoutParent();

            if (layoutParent == null || layoutParent instanceof qx.ui.mobile.core.Root) {
              return null;
            }

            scroll = layoutParent;
          } else {
            return null;
          }
        }

        return scroll;
      }
    },
    destruct: function destruct() {
      if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
        this.removeListener("appear", this._fixChildElementsHeight, this);
        this.removeListener("input", this._fixChildElementsHeight, this);
        this.removeListener("changeValue", this._fixChildElementsHeight, this);
      }
    }
  });
  qx.ui.mobile.form.TextArea.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.basic.Label": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Shows a title text for {@link Form} or {@link Group}.
   */
  qx.Class.define("qx.ui.mobile.form.Title", {
    extend: qx.ui.mobile.basic.Label,
    properties: {
      wrap: {
        refine: true,
        init: false
      },
      // overridden
      defaultCssClass: {
        refine: true,
        init: "form-title"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "h2";
      }
    }
  });
  qx.ui.mobile.form.Title.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.MValue": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.mobile.form.MState": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.mobile.container.Composite": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * A toggle Button widget
   *
   * If the user tap the button, the button toggles between the <code>ON</code>
   * and <code>OFF</code> state.
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.mobile.form.ToggleButton(false,"YES","NO");
   *
   *   button.addListener("changeValue", function(e) {
   *     alert(e.getData());
   *   }, this);
   *
   *   this.getRoot.add(button);
   * </pre>
   *
   * This example creates a toggle button and attaches an
   * event listener to the {@link #changeValue} event.
   */
  qx.Class.define("qx.ui.mobile.form.ToggleButton", {
    extend: qx.ui.mobile.core.Widget,
    include: [qx.ui.mobile.form.MValue, qx.ui.form.MForm, qx.ui.form.MModelProperty, qx.ui.mobile.form.MState],
    implement: [qx.ui.form.IField, qx.ui.form.IForm, qx.ui.form.IModel],

    /**
     * @param value {Boolean?null} The value of the button
     * @param labelChecked {Boolean?"ON"} The value of the text display when toggleButton is active
     * @param labelUnchecked {Boolean?"OFF"} The value of the text display when toggleButton is inactive
     */
    construct: function construct(value, labelChecked, labelUnchecked) {
      qx.ui.mobile.core.Widget.constructor.call(this);

      if (labelChecked && labelUnchecked) {
        this.__labelUnchecked__P_470_0 = labelUnchecked;
        this.__labelChecked__P_470_1 = labelChecked;
      }

      this._setAttribute("data-label-checked", this.__labelChecked__P_470_1);

      this._setAttribute("data-label-unchecked", this.__labelUnchecked__P_470_0);

      this.__switch__P_470_2 = this._createSwitch();

      this._add(this.__switch__P_470_2);

      if (value) {
        this.setValue(value);
      }

      this.addListener("tap", this._onTap, this);
      this.addListener("swipe", this._onSwipe, this);
      this.addCssClass("gap");
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "togglebutton"
      }
    },
    members: {
      __switch__P_470_2: null,
      __value__P_470_3: false,
      __labelUnchecked__P_470_0: "OFF",
      __labelChecked__P_470_1: "ON",
      __lastToggleTimestamp__P_470_4: 0,

      /**
       * Returns the child control of the toggle button.
       *
       * @return {qx.ui.mobile.container.Composite} the child control.
       */
      _getChild: function _getChild() {
        return this.__switch__P_470_2;
      },

      /**
       * Creates the switch control of the widget.
       * @return {qx.ui.mobile.container.Composite} The switch control.
       */
      _createSwitch: function _createSwitch() {
        var toggleButtonSwitch = new qx.ui.mobile.container.Composite();
        toggleButtonSwitch.addCssClass("togglebutton-switch");
        return toggleButtonSwitch;
      },

      /**
       * Sets the value [true/false] of this toggle button.
       * It is called by setValue method of qx.ui.mobile.form.MValue mixin
       * @param value {Boolean} the new value of the toggle button
       */
      _setValue: function _setValue(value) {
        if (typeof value !== 'boolean') {
          throw new Error("value for " + this + " should be boolean");
        }

        if (value) {
          this.addCssClass("checked");
        } else {
          this.removeCssClass("checked");
        }

        this.__value__P_470_3 = value;
      },

      /**
       * Gets the value [true/false] of this toggle button.
       * It is called by getValue method of qx.ui.mobile.form.MValue mixin
       * @return {Boolean} the value of the toggle button
       */
      _getValue: function _getValue() {
        return this.__value__P_470_3;
      },

      /**
       * Toggles the value of the button.
       */
      toggle: function toggle() {
        this.setValue(!this.getValue());
      },

      /**
       * Event handler. Called when the tap event occurs.
       * Toggles the button.
       *
       * @param evt {qx.event.type.Tap} The tap event.
       */
      _onTap: function _onTap(evt) {
        if (this._checkLastPointerTime()) {
          this.toggle();
        }
      },

      /**
       * Event handler. Called when the swipe event occurs.
       * Toggles the button, when.
       *
       * @param evt {qx.event.type.Swipe} The swipe event.
       */
      _onSwipe: function _onSwipe(evt) {
        if (this._checkLastPointerTime()) {
          var direction = evt.getDirection();

          if (direction == "left") {
            if (this.__value__P_470_3 == true) {
              this.toggle();
            }
          } else {
            if (this.__value__P_470_3 == false) {
              this.toggle();
            }
          }
        }
      },

      /**
       * Checks if last touch event (swipe,tap) is more than 500ms ago.
       * Bugfix for several simulator/emulator, when tap is immediately followed by a swipe.
       * @return {Boolean} <code>true</code> if the last event was more than 500ms ago
       */
      _checkLastPointerTime: function _checkLastPointerTime() {
        var elapsedTime = new Date().getTime() - this.__lastToggleTimestamp__P_470_4;

        this.__lastToggleTimestamp__P_470_4 = new Date().getTime();
        return elapsedTime > 500;
      }
    },
    destruct: function destruct() {
      this.removeListener("tap", this._onTap, this);
      this.removeListener("swipe", this._onSwipe, this);

      this._disposeObjects("__switch__P_470_2", "__labelUnchecked__P_470_0", "__labelChecked__P_470_1");
    }
  });
  qx.ui.mobile.form.ToggleButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.renderer.IFormRenderer": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * AbstractRenderer is an abstract class used to encapsulate
   * behaviours of how a form can be rendered into a mobile page.
   * Its subclasses can extend it and override {@link #addItems} and {@link #addButton}
   * methods in order to customize the way the form gets into the DOM.
   *
   *
   */
  qx.Class.define("qx.ui.mobile.form.renderer.AbstractRenderer", {
    type: "abstract",
    extend: qx.ui.mobile.core.Widget,
    implement: qx.ui.form.renderer.IFormRenderer,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param form {qx.ui.mobile.form.Form} The form to be rendered
     */
    construct: function construct(form) {
      qx.ui.mobile.core.Widget.constructor.call(this);
      this._form = form;

      this._render();

      form.addListener("change", this._onFormChange, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "form"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _form: null,

      /**
       * Handler responsible for updating the rendered widget as soon as the
       * form changes.
       */
      _onFormChange: function _onFormChange() {
        this._removeAll();

        this.resetForm();

        this._render();
      },

      /**
       * Renders the for: adds the items and buttons.
       */
      _render: function _render() {
        // add the groups
        var groups = this._form.getGroups();

        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          this.addItems(group.items, group.labels, group.title, group.options, group.headerOptions);
        } // add the buttons


        var buttons = this._form.getButtons();

        var buttonOptions = this._form.getButtonOptions();

        for (var i = 0; i < buttons.length; i++) {
          this.addButton(buttons[i], buttonOptions[i]);
        }

        this._form.setRenderer(this);
      },
      // interface implementation
      addItems: function addItems(items, names, title) {
        throw new Error("Abstract method call");
      },
      // interface implementation
      addButton: function addButton(button) {
        throw new Error("Abstract method call");
      },

      /**
       * Shows an error to the user when a form element is in invalid state
       * usually it prints an error message, so that user can rectify the filling of the form element.
       * @param item {qx.ui.mobile.core.Widget} the form item
       */
      showErrorForItem: function showErrorForItem(item) {
        throw new Error("Abstract method call");
      },

      /**
       *
       * Resets the errors for the form by removing any error messages
       * inserted into DOM in the case of invalid form elements
       *
       */
      resetForm: function resetForm() {
        throw new Error("Abstract method call");
      }
    }
  });
  qx.ui.mobile.form.renderer.AbstractRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.renderer.AbstractRenderer": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.ToggleButton": {
        "require": true
      },
      "qx.ui.mobile.form.RadioButton": {
        "require": true
      },
      "qx.ui.mobile.form.TextField": {
        "require": true
      },
      "qx.ui.mobile.form.PasswordField": {
        "require": true
      },
      "qx.ui.mobile.form.NumberField": {
        "require": true
      },
      "qx.ui.mobile.form.CheckBox": {
        "require": true
      },
      "qx.ui.mobile.form.SelectBox": {
        "require": true
      },
      "qx.ui.mobile.form.TextArea": {},
      "qx.bom.client.Scroll": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.container.Scroll": {},
      "qx.ui.mobile.form.Row": {},
      "qx.ui.mobile.form.Label": {},
      "qx.ui.mobile.basic.Label": {},
      "qx.dom.Element": {},
      "qx.bom.element.Class": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * Single renderer is a class used to render forms into a mobile page.
   * It displays a label above or next to each form element.
   *
   */
  qx.Class.define("qx.ui.mobile.form.renderer.Single", {
    extend: qx.ui.mobile.form.renderer.AbstractRenderer,
    construct: function construct(form) {
      this.__errorMessageContainers__P_471_0 = [];
      this._rows = [];
      this._labels = [];
      qx.ui.mobile.form.renderer.AbstractRenderer.constructor.call(this, form);
      this.addCssClass("single");
    },
    statics: {
      /** @type {Array} qx.Mobile form widgets which are rendered in one single line. */
      ONE_LINE_WIDGETS: [qx.ui.mobile.form.ToggleButton, qx.ui.mobile.form.RadioButton, qx.ui.mobile.form.TextField, qx.ui.mobile.form.PasswordField, qx.ui.mobile.form.NumberField, qx.ui.mobile.form.CheckBox, qx.ui.mobile.form.SelectBox]
    },
    members: {
      _rows: null,
      _labels: null,
      _onFormChange: function _onFormChange() {
        this._disposeArray("_labels");

        this._disposeArray("_rows");

        this._rows = [];
        this._labels = [];

        qx.ui.mobile.form.renderer.Single.prototype._onFormChange.base.call(this);
      },

      /**
       * A collection of error containers used to keep the error messages
       * resulted after form validation.
       * Also useful to clear them when the validation passes.
       */
      __errorMessageContainers__P_471_0: null,
      // override
      _getTagName: function _getTagName() {
        return "ul";
      },

      /**
      * Determines whether the given item can be display in one line
      * or whether a separate line for the text label is needed.
      * @param item {qx.ui.mobile.core.Widget} the widget which should be added.
      * @return {Boolean} it indicates whether the widget can be displayed
      *  in same line as the label.
      */
      _isOneLineWidget: function _isOneLineWidget(item) {
        var widgets = qx.ui.mobile.form.renderer.Single.ONE_LINE_WIDGETS;

        for (var i = 0; i < widgets.length; i++) {
          var widget = widgets[i];

          if (item instanceof widget) {
            return true;
          }
        }

        return false;
      },
      // override
      addItems: function addItems(items, names, title) {
        if (title !== null) {
          this._addGroupHeader(title);
        }

        this._addGroupHeaderRow();

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i];
          var name = names[i];
          var isLastItem = i == items.length - 1;

          if (item instanceof qx.ui.mobile.form.TextArea) {
            if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
              this._addToScrollContainer(item, name);
            } else {
              this._addRow(item, name, new qx.ui.mobile.layout.VBox());
            }
          } else {
            if (this._isOneLineWidget(item)) {
              this._addRow(item, name, new qx.ui.mobile.layout.HBox());
            } else {
              this._addRow(item, name, new qx.ui.mobile.layout.VBox());
            }
          }

          if (!item.isValid()) {
            this.showErrorForItem(item);
          }

          if (!isLastItem) {
            this._addSeparationRow();
          }
        }

        this._addGroupFooterRow();
      },

      /**
       * Wraps the given item with a {@link qx.ui.mobile.container.Scroll scroll} container.
       * @param item {qx.ui.mobile.core.Widget} A form item to render.
       * @param name {String} A name for the form item.
       */
      _addToScrollContainer: function _addToScrollContainer(item, name) {
        var scrollContainer = new qx.ui.mobile.container.Scroll();
        scrollContainer.addCssClass("form-row-scroll");
        scrollContainer.add(item, {
          flex: 1
        });

        this._addRow(scrollContainer, name, new qx.ui.mobile.layout.VBox());
      },

      /**
      * Adds a label and its according widget in a row and applies the given layout.
      * @param item {qx.ui.mobile.core.Widget} A form item to render.
      * @param name {String} A name for the form item.
      * @param layout {qx.ui.mobile.layout.Abstract} layout of the rendered row.
      */
      _addRow: function _addRow(item, name, layout) {
        var row = new qx.ui.mobile.form.Row(layout);
        row.addCssClass("form-row-content");

        if (name !== null) {
          var label = new qx.ui.mobile.form.Label(name);
          label.setLabelFor(item.getId());
          row.add(label, {
            flex: 1
          });

          this._labels.push(label);
        }

        row.add(item);

        this._add(row);

        this._rows.push(row);
      },

      /**
       * Adds a separation line into the form.
       */
      _addSeparationRow: function _addSeparationRow() {
        var row = new qx.ui.mobile.form.Row();
        row.addCssClass("form-separation-row");

        this._add(row);

        this._rows.push(row);
      },

      /**
       * Adds an row group header.
       */
      _addGroupHeaderRow: function _addGroupHeaderRow() {
        var row = new qx.ui.mobile.form.Row();
        row.addCssClass("form-row-group-first");

        this._add(row);

        this._rows.push(row);
      },

      /**
       * Adds an row group footer.
       */
      _addGroupFooterRow: function _addGroupFooterRow() {
        var row = new qx.ui.mobile.form.Row();
        row.addCssClass("form-row-group-last");

        this._add(row);

        this._rows.push(row);
      },

      /**
       * Adds a row with the name of a group of elements
       * When you want to group certain form elements, this methods implements
       * the way the header of that group is presented.
       * @param title {String} the title shown in the group header
       */
      _addGroupHeader: function _addGroupHeader(title) {
        var row = new qx.ui.mobile.form.Row();
        row.addCssClass("form-row-group-title");
        var titleLabel = new qx.ui.mobile.basic.Label(title);
        row.add(titleLabel);

        this._add(row);

        this._labels.push(titleLabel);

        this._rows.push(row);
      },
      // override
      addButton: function addButton(button) {
        var row = new qx.ui.mobile.form.Row(new qx.ui.mobile.layout.HBox());
        row.add(button, {
          flex: 1
        });

        this._add(row);

        this._rows.push(row);
      },
      // override
      showErrorForItem: function showErrorForItem(item) {
        var errorNode = qx.dom.Element.create('div');
        errorNode.innerHTML = item.getInvalidMessage();
        qx.bom.element.Class.add(errorNode, 'form-element-error');
        qx.dom.Element.insertAfter(errorNode, this._getParentRow(item).getContainerElement());

        this.__errorMessageContainers__P_471_0.push(errorNode);
      },

      /**
       * Shows a single item of this form
       * @param item {qx.ui.form.IForm} form item which should be hidden.
       */
      showItem: function showItem(item) {
        this._getParentRow(item).removeCssClass("exclude");
      },

      /**
       * Hides a single item of this form
       * @param item {qx.ui.form.IForm} form item which should be hidden.
       */
      hideItem: function hideItem(item) {
        this._getParentRow(item).addCssClass("exclude");
      },

      /**
      * Returns the parent row of the item.
      *
      * @param item {qx.ui.form.IForm} the form item.
      * @return {qx.ui.mobile.core.Widget} the parent row.
      */
      _getParentRow: function _getParentRow(item) {
        var parent = item.getLayoutParent();

        while (!parent.hasCssClass("form-row")) {
          parent = parent.getLayoutParent();
        }

        return parent;
      },
      // override
      resetForm: function resetForm() {
        for (var i = 0; i < this.__errorMessageContainers__P_471_0.length; i++) {
          qx.dom.Element.remove(this.__errorMessageContainers__P_471_0[i]);
        }
      }
    },

    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct: function destruct() {
      this.resetForm();

      this._disposeArray("_labels");

      this._disposeArray("_rows");
    }
  });
  qx.ui.mobile.form.renderer.Single.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.renderer.Single": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.form.TextArea": {},
      "qx.bom.client.Scroll": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.form.Row": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.mobile.nativescroll": {
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * SinglePlaceholder is a class used to render forms into a mobile page.
   * It presents a label into the placeholder of the form elements
   *
   */
  qx.Class.define("qx.ui.mobile.form.renderer.SinglePlaceholder", {
    extend: qx.ui.mobile.form.renderer.Single,

    /**
     * @param form {qx.ui.mobile.form.Form} The target form of this renderer
     */
    construct: function construct(form) {
      qx.ui.mobile.form.renderer.Single.constructor.call(this, form);
      this.removeCssClass("single");
      this.addCssClass("single-placeholder");
    },
    members: {
      // override
      addItems: function addItems(items, names, title) {
        if (title != null) {
          this._addGroupHeader(title);
        }

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i];
          var name = names[i];

          if (item instanceof qx.ui.mobile.form.TextArea) {
            if (qx.core.Environment.get("qx.mobile.nativescroll") == false) {
              this._addToScrollContainer(item, name);
            } else {
              this._addRow(item, name, new qx.ui.mobile.layout.VBox());
            }
          } else {
            if (item.setPlaceholder === undefined) {
              this._addRow(item, name, new qx.ui.mobile.layout.HBox());
            } else {
              var row = new qx.ui.mobile.form.Row(new qx.ui.mobile.layout.HBox());
              item.setPlaceholder(name);
              row.add(item, {
                flex: 1
              });

              this._add(row);
            }
          }

          if (!item.isValid()) {
            this.showErrorForItem(item);
          }
        }
      }
    }
  });
  qx.ui.mobile.form.renderer.SinglePlaceholder.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Objects which are used as delegates for the {@link qx.ui.mobile.list.List#delegate} may
   * implement any of the methods described in this interface. The delegate does
   * not need to implement all the methods of this interface. If a method is not
   * implemented the {@link qx.ui.mobile.list.provider.Provider} provides a default
   * implementation.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * actually implemented.
   */
  qx.Interface.define("qx.ui.mobile.list.IListDelegate", {
    members: {
      /**
       * Configure the list item renderer with the given data. Mandatory method.
       * At least this method has to be defined for the delegate.
       *
       * @param item {qx.ui.mobile.list.renderer.Abstract} Instance of list item renderer to modify
       * @param data {var} The data of the row. Can be used to configure the given item.
       * @param row {Integer} The row index.
       */
      configureItem: function configureItem(item, data, row) {},

      /**
       * Creates an instance of the item renderer to use.
       *
       * @return {qx.ui.mobile.list.renderer.Abstract} An instance of the item renderer.
       */
      createItemRenderer: function createItemRenderer() {}
    }
  });
  qx.ui.mobile.list.IListDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Button": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A navigation bar button widget.
   */
  qx.Class.define("qx.ui.mobile.navigationbar.Button", {
    extend: qx.ui.mobile.form.Button,

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "navigationbar-button"
      }
    }
  });
  qx.ui.mobile.navigationbar.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.navigationbar.Button": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A navigation bar back button widget.
   */
  qx.Class.define("qx.ui.mobile.navigationbar.BackButton", {
    extend: qx.ui.mobile.navigationbar.Button,

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "navigationbar-backbutton"
      }
    }
  });
  qx.ui.mobile.navigationbar.BackButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.basic.Label": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A navigation bar title widget.
   */
  qx.Class.define("qx.ui.mobile.navigationbar.Title", {
    extend: qx.ui.mobile.basic.Label,
    properties: {
      wrap: {
        refine: true,
        init: false
      },
      // overridden
      defaultCssClass: {
        refine: true,
        init: "title"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getTagName: function _getTagName() {
        return "h1";
      }
    }
  });
  qx.ui.mobile.navigationbar.Title.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.core.Init": {
        "construct": true
      },
      "qx.bom.client.Device": {
        "construct": true
      },
      "qx.event.Registration": {
        "construct": true
      },
      "qx.bom.Viewport": {
        "construct": true
      },
      "qx.ui.mobile.container.Drawer": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.layout.VBox": {},
      "qx.ui.mobile.navigationbar.Button": {},
      "qx.ui.mobile.container.Navigation": {},
      "qx.lang.Type": {},
      "qx.ui.mobile.page.NavigationPage": {},
      "qx.lang.String": {},
      "qx.bom.element.Style": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "device.type": {
          "construct": true,
          "className": "qx.bom.client.Device"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Christopher Zuendorf (czuendorf)
  
  ************************************************************************ */

  /**
   * The page manager decides automatically whether the added pages should be
   * displayed in a master/detail view (for tablet) or as a plain card layout (for
   * smartphones).
   *
   * *Example*
   *
   * Here is a little example of how to use the manager.
   *
   * <pre class='javascript'>
   *  var manager = new qx.ui.mobile.page.Manager();
   *  var page1 = new qx.ui.mobile.page.NavigationPage();
   *  var page2 = new qx.ui.mobile.page.NavigationPage();
   *  var page3 = new qx.ui.mobile.page.NavigationPage();
   *  manager.addMaster(page1);
   *  manager.addDetail([page2,page3]);
   *
   *  page1.show();
   * </pre>
   *
   *
   */
  qx.Class.define("qx.ui.mobile.page.Manager", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param isTablet {Boolean?} flag which triggers the manager to layout for tablet (or big screens/displays) or mobile devices. If parameter is null,
     * qx.core.Environment.get("device.type") is called for decision.
     * @param root {qx.ui.mobile.core.Widget?} widget which should be used as root for this manager.
     */
    construct: function construct(isTablet, root) {
      qx.core.Object.constructor.call(this);
      root = root || qx.core.Init.getApplication().getRoot();

      if (typeof isTablet !== "undefined" && isTablet !== null) {
        this.__isTablet__P_478_0 = isTablet;
      } else {
        // If isTablet is undefined, call environment variable "device.type".
        // When "tablet" or "desktop" type >> do tablet layouting.
        this.__isTablet__P_478_0 = qx.core.Environment.get("device.type") == "desktop" || qx.core.Environment.get("device.type") == "tablet";
      }

      this.__detailNavigation__P_478_1 = this._createDetailNavigation();

      this.__detailNavigation__P_478_1.getNavigationBar().hide();

      if (this.__isTablet__P_478_0) {
        this.__masterNavigation__P_478_2 = this._createMasterNavigation();

        this.__masterNavigation__P_478_2.getNavigationBar().hide();

        this.__masterContainer__P_478_3 = this._createMasterContainer();
        this.__detailContainer__P_478_4 = this._createDetailContainer();
        this.__masterButton__P_478_5 = this._createMasterButton();

        this.__masterButton__P_478_5.addListener("tap", this._onMasterButtonTap, this);

        this.__hideMasterButton__P_478_6 = this._createHideMasterButton();

        this.__hideMasterButton__P_478_6.addListener("tap", this._onHideMasterButtonTap, this);

        this.__masterNavigation__P_478_2.addListener("update", this._onMasterContainerUpdate, this);

        this.__detailNavigation__P_478_1.addListener("update", this._onDetailContainerUpdate, this);

        root.add(this.__detailContainer__P_478_4, {
          flex: 1
        });

        this.__masterContainer__P_478_3.add(this.__masterNavigation__P_478_2, {
          flex: 1
        });

        this.__detailContainer__P_478_4.add(this.__detailNavigation__P_478_1, {
          flex: 1
        });

        qx.event.Registration.addListener(window, "orientationchange", this._onLayoutChange, this);

        this.__masterContainer__P_478_3.addListener("resize", this._onLayoutChange, this); // On Tablet Mode, no Animation should be shown by default.


        this.__masterNavigation__P_478_2.getLayout().setShowAnimation(false);

        this.__detailNavigation__P_478_1.getLayout().setShowAnimation(false);

        this.__masterContainer__P_478_3.forceHide();

        setTimeout(function () {
          if (qx.bom.Viewport.isLandscape()) {
            this.__masterContainer__P_478_3.show();
          }
        }.bind(this), 300);
      } else {
        root.add(this.__detailNavigation__P_478_1, {
          flex: 1
        });
      }
    },
    properties: {
      /**
       * The caption/label of the Master Button and Popup Title.
       */
      masterTitle: {
        init: "Master",
        check: "String",
        apply: "_applyMasterTitle"
      },

      /**
       * The caption/label of the Hide Master Button.
       */
      hideMasterButtonCaption: {
        init: "Hide",
        check: "String",
        apply: "_applyHideMasterButtonCaption"
      },

      /**
       * This flag controls whether the MasterContainer can be hidden on Landscape.
       */
      allowMasterHideOnLandscape: {
        init: true,
        check: "Boolean"
      },

      /**
       *  This flag controls whether the MasterContainer hides on portrait view,
       *  when a Detail Page fires the lifecycle event "start".
       */
      hideMasterOnDetailStart: {
        init: true,
        check: "Boolean"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __isTablet__P_478_0: null,
      __detailNavigation__P_478_1: null,
      __masterNavigation__P_478_2: null,
      __masterButton__P_478_5: null,
      __hideMasterButton__P_478_6: null,
      __masterPages__P_478_7: null,
      __detailPages__P_478_8: null,
      __masterContainer__P_478_3: null,
      __detailContainer__P_478_4: null,

      /**
       * Creates the master container.
       *
       * @return {qx.ui.mobile.container.Composite} The created container
       */
      _createMasterContainer: function _createMasterContainer() {
        var masterContainer = new qx.ui.mobile.container.Drawer(null, new qx.ui.mobile.layout.HBox()).set({
          hideOnParentTap: false,
          hideOnBack: false
        });
        masterContainer.addCssClass("master-detail-master");
        masterContainer.addListener("changeVisibility", this._onMasterChangeVisibility, this);
        return masterContainer;
      },

      /**
       * Creates the detail container.
       *
       * @return {qx.ui.mobile.container.Composite} The created container
       */
      _createDetailContainer: function _createDetailContainer() {
        var detailContainer = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
        detailContainer.setDefaultCssClass("master-detail-detail");
        return detailContainer;
      },

      /**
       * Getter for the Master Container
       * @return {qx.ui.mobile.container.Drawer} The Master Container.
       */
      getMasterContainer: function getMasterContainer() {
        return this.__masterContainer__P_478_3;
      },

      /**
       * Getter for the Detail Container
       * @return {qx.ui.mobile.container.Composite} The Detail Container.
       */
      getDetailContainer: function getDetailContainer() {
        return this.__detailContainer__P_478_4;
      },

      /**
       * Returns the button for showing/hiding the masterContainer.
       * @return {qx.ui.mobile.navigationbar.Button}
       */
      getMasterButton: function getMasterButton() {
        return this.__masterButton__P_478_5;
      },

      /**
       * Returns the masterNavigation.
       * @return {qx.ui.mobile.container.Navigation}
       */
      getMasterNavigation: function getMasterNavigation() {
        return this.__masterNavigation__P_478_2;
      },

      /**
       * Returns the detailNavigation.
       * @return {qx.ui.mobile.container.Navigation}
       */
      getDetailNavigation: function getDetailNavigation() {
        return this.__detailNavigation__P_478_1;
      },

      /**
      * Factory method for the master button, which is responsible for showing/hiding masterContainer.
      * @return {qx.ui.mobile.navigationbar.Button}
      */
      _createMasterButton: function _createMasterButton() {
        return new qx.ui.mobile.navigationbar.Button(this.getMasterTitle());
      },

      /**
       * Factory method for the hide master button, which is responsible for hiding masterContainer on Landscape view.
       * @return {qx.ui.mobile.navigationbar.Button}
       */
      _createHideMasterButton: function _createHideMasterButton() {
        return new qx.ui.mobile.navigationbar.Button("Hide");
      },

      /**
      * Factory method for masterNavigation.
      * @return {qx.ui.mobile.container.Navigation}
      */
      _createMasterNavigation: function _createMasterNavigation() {
        return new qx.ui.mobile.container.Navigation();
      },

      /**
       * Factory method for detailNavigation.
       * @return {qx.ui.mobile.container.Navigation}
       */
      _createDetailNavigation: function _createDetailNavigation() {
        return new qx.ui.mobile.container.Navigation();
      },

      /**
       * Adds an array of NavigationPages to masterContainer, if __isTablet is true. Otherwise it will be added to detailContainer.
       * @param pages {qx.ui.mobile.page.NavigationPage[]|qx.ui.mobile.page.NavigationPage} Array of NavigationPages or single NavigationPage.
       */
      addMaster: function addMaster(pages) {
        if (this.__isTablet__P_478_0) {
          if (pages) {
            if (!qx.lang.Type.isArray(pages)) {
              pages = [pages];
            }

            for (var i = 0; i < pages.length; i++) {
              var masterPage = pages[i];
              masterPage.addListener("start", this._onMasterPageStart, this);
            }

            if (this.__masterPages__P_478_7) {
              this.__masterPages__P_478_7.concat(pages);
            } else {
              this.__masterPages__P_478_7 = pages;
            }

            this._add(pages, this.__masterNavigation__P_478_2);
          }
        } else {
          this.addDetail(pages);
        }
      },

      /**
       * Adds an array of NavigationPage to the detailContainer.
       * @param pages {qx.ui.mobile.page.NavigationPage[]|qx.ui.mobile.page.NavigationPage} Array of NavigationPages or single NavigationPage.
       */
      addDetail: function addDetail(pages) {
        this._add(pages, this.__detailNavigation__P_478_1);

        if (pages && this.__isTablet__P_478_0) {
          if (!qx.lang.Type.isArray(pages)) {
            pages = [pages];
          }

          for (var i = 0; i < pages.length; i++) {
            var detailPage = pages[i];
            detailPage.addListener("start", this._onDetailPageStart, this);
          }

          if (this.__detailPages__P_478_8) {
            this.__detailPages__P_478_8.concat(pages);
          } else {
            this.__detailPages__P_478_8 = pages;
          }
        }
      },

      /**
       * Called when a detailPage reaches lifecycle state "start".
       * @param evt {qx.event.type.Event} source event.
       */
      _onDetailPageStart: function _onDetailPageStart(evt) {
        if (qx.bom.Viewport.isPortrait() && this.isHideMasterOnDetailStart()) {
          this.__masterContainer__P_478_3.hide();
        }
      },

      /**
       * Called when a masterPage reaches lifecycle state "start". Then property masterTitle will be update with masterPage's title.
       * @param evt {qx.event.type.Event} source event.
       */
      _onMasterPageStart: function _onMasterPageStart(evt) {
        var masterPage = evt.getTarget();
        var masterPageTitle = masterPage.getTitle();
        this.setMasterTitle(masterPageTitle);
      },

      /**
       * Adds an array of NavigationPage to the target container.
       * @param pages {qx.ui.mobile.page.NavigationPage[]|qx.ui.mobile.page.NavigationPage} Array of NavigationPages, or NavigationPage.
       * @param target {qx.ui.mobile.container.Navigation} target navigation container.
       */
      _add: function _add(pages, target) {
        if (!qx.lang.Type.isArray(pages)) {
          pages = [pages];
        }

        for (var i = 0; i < pages.length; i++) {
          var page = pages[i];
          {
            this.assertInstance(page, qx.ui.mobile.page.NavigationPage);
          }

          if (this.__isTablet__P_478_0 && !page.getShowBackButtonOnTablet()) {
            page.setShowBackButton(false);
          }

          page.setIsTablet(this.__isTablet__P_478_0);
          target.add(page);
        }
      },

      /**
       * Called when masterContainer is updated.
       * @param evt {qx.event.type.Data} source event.
       */
      _onMasterContainerUpdate: function _onMasterContainerUpdate(evt) {
        var widget = evt.getData();
        widget.getRightContainer().remove(this.__hideMasterButton__P_478_6);
        widget.getRightContainer().add(this.__hideMasterButton__P_478_6);
      },

      /**
       * Called when detailContainer is updated.
       * @param evt {qx.event.type.Data} source event.
       */
      _onDetailContainerUpdate: function _onDetailContainerUpdate(evt) {
        var widget = evt.getData();
        widget.getLeftContainer().remove(this.__masterButton__P_478_5);
        widget.getLeftContainer().add(this.__masterButton__P_478_5);
      },

      /**
      * Called when user taps on masterButton.
      */
      _onMasterButtonTap: function _onMasterButtonTap() {
        this.__masterContainer__P_478_3.show();
      },

      /**
      * Called when user taps on hideMasterButton.
      */
      _onHideMasterButtonTap: function _onHideMasterButtonTap() {
        this._removeDetailContainerGap();

        this.__masterContainer__P_478_3.hide();
      },

      /**
      * Event handler for <code>changeVisibility</code> event on master container.
      * @param evt {qx.event.type.Data} the change event.
      */
      _onMasterChangeVisibility: function _onMasterChangeVisibility(evt) {
        var isMasterVisible = "visible" === evt.getData();

        if (qx.bom.Viewport.isLandscape()) {
          if (this.isAllowMasterHideOnLandscape()) {
            if (isMasterVisible) {
              this._createDetailContainerGap();

              this.__masterButton__P_478_5.exclude();

              this.__hideMasterButton__P_478_6.show();
            } else {
              this.__masterButton__P_478_5.show();

              this.__hideMasterButton__P_478_6.show();
            }
          } else {
            this.__masterButton__P_478_5.exclude();

            this.__hideMasterButton__P_478_6.exclude();
          }
        } else {
          this._removeDetailContainerGap();

          this.__masterButton__P_478_5.show();

          this.__hideMasterButton__P_478_6.show();
        }
      },

      /**
      * Called when layout of masterDetailContainer changes.
      */
      _onLayoutChange: function _onLayoutChange() {
        if (this.__isTablet__P_478_0) {
          if (qx.bom.Viewport.isLandscape()) {
            this.__masterContainer__P_478_3.setHideOnParentTap(false);

            if (this.__masterContainer__P_478_3.isHidden()) {
              this.__masterContainer__P_478_3.show();
            } else {
              this._removeDetailContainerGap();

              this.__masterContainer__P_478_3.hide();
            }
          } else {
            this._removeDetailContainerGap();

            this.__masterContainer__P_478_3.setHideOnParentTap(true);

            this.__masterContainer__P_478_3.hide();
          }
        }
      },

      /**
      * Returns the corresponding CSS property key which fits to the drawer's orientation.
      * @return {String} the CSS property key.
      */
      _getGapPropertyKey: function _getGapPropertyKey() {
        return "padding" + qx.lang.String.capitalize(this.__masterContainer__P_478_3.getOrientation());
      },

      /**
       * Moves detailContainer to the right edge of MasterContainer.
       * Creates spaces for aligning master and detail container aside each other.
       */
      _createDetailContainerGap: function _createDetailContainerGap() {
        qx.bom.element.Style.set(this.__detailContainer__P_478_4.getContainerElement(), this._getGapPropertyKey(), this.__masterContainer__P_478_3.getSize() / 16 + "rem");
        qx.event.Registration.fireEvent(window, "resize");
      },

      /**
       * Moves detailContainer to the left edge of viewport.
       */
      _removeDetailContainerGap: function _removeDetailContainerGap() {
        qx.bom.element.Style.set(this.__detailContainer__P_478_4.getContainerElement(), this._getGapPropertyKey(), null);
        qx.event.Registration.fireEvent(window, "resize");
      },

      /**
      * Called on property changes of hideMasterButtonCaption.
      * @param value {String} new caption
      * @param old {String} previous caption
      */
      _applyHideMasterButtonCaption: function _applyHideMasterButtonCaption(value, old) {
        if (this.__isTablet__P_478_0) {
          this.__hideMasterButton__P_478_6.setLabel(value);
        }
      },

      /**
      * Called on property changes of masterTitle.
      * @param value {String} new title
      * @param old {String} previous title
      */
      _applyMasterTitle: function _applyMasterTitle(value, old) {
        if (this.__isTablet__P_478_0) {
          this.__masterButton__P_478_5.setLabel(value);
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this.__masterPages__P_478_7) {
        for (var i = 0; i < this.__masterPages__P_478_7.length; i++) {
          var masterPage = this.__masterPages__P_478_7[i];
          masterPage.removeListener("start", this._onMasterPageStart, this);
        }
      }

      if (this.___detailPages__P_478_9) {
        for (var j = 0; j < this.___detailPages__P_478_9.length; j++) {
          var detailPage = this.___detailPages__P_478_9[j];
          detailPage.removeListener("start", this._onDetailPageStart, this);
        }
      }

      if (this.__isTablet__P_478_0) {
        this.__masterContainer__P_478_3.removeListener("changeVisibility", this._onMasterChangeVisibility, this);

        this.__masterContainer__P_478_3.removeListener("resize", this._onLayoutChange, this);

        qx.event.Registration.removeListener(window, "orientationchange", this._onLayoutChange, this);
      }

      this.__masterPages__P_478_7 = this.__detailPages__P_478_8 = null;

      this._disposeObjects("__detailNavigation__P_478_1", "__masterNavigation__P_478_2", "__masterButton__P_478_5");
    }
  });
  qx.ui.mobile.page.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.core.MResize": {
        "require": true
      },
      "qx.ui.mobile.layout.VBox": {
        "construct": true
      },
      "qx.bom.Event": {
        "defer": "runtime"
      },
      "qx.bom.client.PhoneGap": {
        "defer": "runtime"
      },
      "qx.bom.client.OperatingSystem": {
        "defer": "runtime"
      },
      "qx.core.Init": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "phonegap": {
          "className": "qx.bom.client.PhoneGap",
          "defer": true
        },
        "os.name": {
          "className": "qx.bom.client.OperatingSystem",
          "defer": true
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A page is a widget which provides a screen with which users
   * can interact in order to do something. Most times a page provides a single task
   * or a group of related tasks.
   *
   * A qooxdoo mobile application is usually composed of one or more loosely bound
   * pages. Typically there is one page that presents the "main" view.
   *
   * Pages can have one or more child widgets from the {@link qx.ui.mobile}
   * namespace. Normally a page provides a {@link qx.ui.mobile.navigationbar.NavigationBar}
   * for the navigation between pages.
   *
   * To navigate between two pages, just call the {@link #show} method of the page
   * that should be shown. Depending on the used page manager a page transition will be animated.
   * There are several animations available. Have
   * a look at the {@link qx.ui.mobile.page.Manager} manager or {@link qx.ui.mobile.layout.Card} card layout for more information.
   *
   * A page has predefined lifecycle methods that get called by the used page manager
   * when a page gets shown. Each time another page is requested to be shown the currently shown page
   * is stopped. The other page, will be, if shown for the first time, initialized and started
   * afterwards. For all called lifecycle methods an event is fired.
   *
   * Call of the {@link #show} method triggers the following lifecycle methods:
   *
   * * <strong>initialize</strong>: Initializes the page to show
   * * <strong>start</strong>: Gets called when the page to show is started
   * * <strong>stop</strong>:  Stops the current page
   *
   * IMPORTANT: Define all child widgets of a page when the {@link #initialize} lifecycle
   * method is called, either by listening to the {@link #initialize} event or overriding
   * the {@link #_initialize} method. This is because a page can be instanced during
   * application startup and would then decrease performance when the widgets would be
   * added during constructor call. The <code>initialize</code> event and the
   * {@link #_initialize} lifecycle method are only called when the page is shown
   * for the first time.
   *
   */
  qx.Class.define("qx.ui.mobile.page.Page", {
    extend: qx.ui.mobile.container.Composite,
    include: qx.ui.mobile.core.MResize,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout || new qx.ui.mobile.layout.VBox());
    },

    /*
     *****************************************************************************
        STATICS
     *****************************************************************************
     */
    statics: {
      _currentPage: null,

      /**
       * Event handler. Called when the device is ready.
       */
      _onDeviceReady: function _onDeviceReady() {
        qx.bom.Event.addNativeListener(document, "backbutton", qx.ui.mobile.page.Page._onBackButton);
        qx.bom.Event.addNativeListener(document, "menubutton", qx.ui.mobile.page.Page._onMenuButton);
      },

      /**
       * Event handler. Called when the back button of the device was pressed.
       */
      _onBackButton: function _onBackButton() {
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("os.name") == "android") {
          var exit = true;

          if (qx.ui.mobile.page.Page._currentPage) {
            exit = qx.ui.mobile.page.Page._currentPage.back(true);
          }

          if (exit) {
            navigator.app.exitApp();
          }
        }
      },

      /**
       * Event handler. Called when the menu button of the device was pressed.
       */
      _onMenuButton: function _onMenuButton() {
        if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("os.name") == "android") {
          if (qx.ui.mobile.page.Page._currentPage) {
            qx.ui.mobile.page.Page._currentPage.menu();
          }
        }
      }
    },
    events: {
      /** Fired when the lifecycle method {@link #initialize} is called */
      "initialize": "qx.event.type.Event",

      /** Fired when the lifecycle method {@link #start} is called */
      "start": "qx.event.type.Event",

      /** Fired when the lifecycle method {@link #stop} is called */
      "stop": "qx.event.type.Event",

      /** Fired when the lifecycle method {@link #pause} is called */
      "pause": "qx.event.type.Event",

      /** Fired when the lifecycle method {@link #resume} is called */
      "resume": "qx.event.type.Event",

      /**
       * Fired when the method {@link #back} is called and not prevented by
       * {@link qx.application.Mobile#back}. Data indicating whether
       * the action was triggered by a key event or not.
       */
      "back": "qx.event.type.Data",

      /** Fired when the method {@link #menu} is called */
      "menu": "qx.event.type.Event",

      /** Fired when the method {@link #wait} is called */
      "wait": "qx.event.type.Event"
    },
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "page"
      },

      /**
       * The current active life cycle state of this page.
       */
      lifeCycleState: {
        init: null,
        check: ["initialize", "start", "stop", "resume", "wait", "pause"],
        apply: "_applyLifeCycleState"
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      __initialized__P_480_0: false,
      // overridden
      show: function show(properties) {
        if (qx.ui.mobile.page.Page._currentPage) {
          qx.ui.mobile.page.Page._currentPage.stop();
        }

        qx.ui.mobile.page.Page._currentPage = this;
        this.initialize();
        this.start();
        qx.ui.mobile.page.Page.prototype.show.base.call(this, properties);
      },
      // overridden
      exclude: function exclude(properties) {
        this.stop();
        qx.ui.mobile.page.Page.prototype.exclude.base.call(this, properties);
      },

      /**
       * Fires the <code>back</code> event. Call this method if you want to request
       * a back action. For Android PhoneGap applications this method gets called
       * by the used page manager when the back button was pressed. Return <code>true</code>
       * to exit the application.
       *
       * The back request can prevented by calling the {@link qx.event.type.Event#preventDefault} on
       * the {@link qx.application.Mobile#back} event.
       *
       * @param triggeredByKeyEvent {Boolean} Whether the back action was triggered by a key event.
       * @return {Boolean} Whether the exit should be exit or not. Return <code>true</code
       *     to exit the application. Only needed for Android PhoneGap applications.
       */
      back: function back(triggeredByKeyEvent) {
        if (qx.core.Init.getApplication().fireDataEvent("back", triggeredByKeyEvent, null, true)) {
          this.fireDataEvent("back", triggeredByKeyEvent);

          var value = this._back(triggeredByKeyEvent);

          return value || false;
        } else {
          return false;
        }
      },

      /**
       * Override this method if you want to perform a certain action when back
       * is called.
       *
       * @param triggeredByKeyEvent {Boolean} Whether the back action was triggered by a key event.
       * @return {Boolean} Whether the exit should be exit or not. Return <code>true</code
       *     to exit the application. Only needed for Android PhoneGap applications.
       * @see #back
       * @abstract
       */
      _back: function _back(triggeredByKeyEvent) {},

      /**
       * Only used by Android PhoneGap applications. Called by the used page manager
       * when the menu button was pressed. Fires the <code>menu</code> event.
       */
      menu: function menu() {
        this.fireEvent("menu");
      },

      /*
      ---------------------------------------------------------------------------
        Lifecycle Methods
      ---------------------------------------------------------------------------
      */

      /**
       * Lifecycle method. Called by the page manager when the page is shown.
       * Fires the <code>initialize</code> event. You should create and add all your
       * child widgets of the view,  either by listening to the {@link #initialize} event or overriding
       * the {@link #_initialize} method. This is because a page can be instanced during
       * application startup and would then decrease performance when the widgets would be
       * added during constructor call. The {@link #_initialize} lifecycle method and the
       * <code>initialize</code> are only called once when the page is shown for the first time.
       */
      initialize: function initialize() {
        if (!this.isInitialized()) {
          this._initialize();

          this.__initialized__P_480_0 = true;
          this.setLifeCycleState("initialize");
        }
      },

      /**
       * Override this method if you would like to perform a certain action when initialize
       * is called.
       *
       * @see #initialize
       */
      _initialize: function _initialize() {},

      /**
       * Returns the status of the initialization of the page.
       *
       * @return {Boolean} Whether the page is already initialized or not
       */
      isInitialized: function isInitialized() {
        return this.__initialized__P_480_0;
      },

      /**
       * Lifecycle method. Called by the page manager after the {@link #initialize}
       * method when the page is shown. Fires the <code>start</code> event. You should
       * register all your event listener when this event occurs, so that no page
       * updates are done when page is not shown.
       */
      start: function start() {
        this._start();

        this.setLifeCycleState("start");
      },

      /**
       * Override this method if you would like to perform a certain action when start
       * is called.
       *
       * @see #start
       */
      _start: function _start() {},

      /**
       * Lifecycle method. Called by the page manager when another page is shown.
       * Fires the <code>stop</code> event. You should unregister all your event
       * listener when this event occurs, so that no page updates are down when page is not shown.
       */
      stop: function stop() {
        if (!this.isInitialized()) {
          return;
        }

        this._stop();

        this.setLifeCycleState("stop");
      },

      /**
       * Override this method if you would like to perform a certain action when stop
       * is called.
       *
       * @see #stop
       */
      _stop: function _stop() {},

      /**
       * Lifecycle method. Not used right now. Should be called when the current page
       * is interrupted, e.g. by a dialog, so that page view updates can be interrupted.
       * Fires the <code>pause</code> event.
       */
      pause: function pause() {
        this._pause();

        this.setLifeCycleState("pause");
      },

      /**
       * Override this method if you would like to perform a certain action when pause
       * is called.
       *
       * @see #pause
       */
      _pause: function _pause() {},

      /**
       * Lifecycle method. Not used right now. Should be called when the current page
       * is resuming from a interruption, e.g. when a dialog is closed, so that page
       * can resume updating the view.
       * Fires the <code>resume</code> event.
       */
      resume: function resume() {
        this._resume();

        this.setLifeCycleState("resume");
      },

      /**
       * Override this method if you would like to perform a certain action when resume
       * is called.
       *
       * @see #resume
       */
      _resume: function _resume() {},

      /**
       * Lifecycle method. Not used right now. Should be called when the current page
       * waits for data request etc.
       * Fires the <code>wait</code> event.
       */
      wait: function wait() {
        this._wait();

        this.setLifeCycleState("wait");
      },

      /**
       * Override this method if you would like to perform a certain action when wait
       * is called.
       *
       * @see #wait
       */
      _wait: function _wait() {},
      // property apply
      _applyLifeCycleState: function _applyLifeCycleState(value, old) {
        if (value == "start" || value == "stop") {
          qx.core.Init.getApplication().fireEvent(value);
        }

        this.fireEvent(value);
      }
    },

    /*
     *****************************************************************************
         DEFER
     *****************************************************************************
     */
    defer: function defer(statics) {
      if (qx.core.Environment.get("phonegap") && qx.core.Environment.get("os.name") == "android") {
        qx.bom.Event.addNativeListener(document, "deviceready", statics._onDeviceReady);
      }
    }
  });
  qx.ui.mobile.page.Page.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.page.Page": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.container.INavigation": {
        "require": true
      },
      "qx.ui.mobile.navigationbar.Title": {},
      "qx.ui.mobile.layout.HBox": {},
      "qx.ui.mobile.container.Composite": {},
      "qx.ui.mobile.navigationbar.BackButton": {},
      "qx.ui.mobile.navigationbar.Button": {},
      "qx.ui.mobile.container.Scroll": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * Specialized page. This page includes already a {@link qx.ui.mobile.navigationbar.NavigationBar}
   * and and a {@link qx.ui.mobile.container.Scroll} container.
   * The NavigationPage can only be used with a page manager {@link qx.ui.mobile.page.Manager}.
  
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *
   *  var manager = new qx.ui.mobile.page.Manager();
   *  var page = new qx.ui.mobile.page.NavigationPage();
   *  page.setTitle("Page Title");
   *  page.setShowBackButton(true);
   *  page.setBackButtonText("Back")
   *  page.addListener("initialize", function()
   *  {
   *    var button = new qx.ui.mobile.form.Button("Next Page");
   *    page.getContent().add(button);
   *  },this);
   *
   *  page.addListener("back", function()
   *  {
   *    otherPage.show({animation:"cube", reverse:true});
   *  },this);
   *
   *  manager.addDetail(page);
   *  page.show();
   * </pre>
   *
   * This example creates a NavigationPage with a title and a back button. In the
   * <code>initialize</code> lifecycle method a button is added.
   */
  qx.Class.define("qx.ui.mobile.page.NavigationPage", {
    extend: qx.ui.mobile.page.Page,
    implement: qx.ui.mobile.container.INavigation,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param wrapContentByGroup {Boolean} Defines whether a group box should wrap the content. This can be used for defining a page margin.
     * @param layout {qx.ui.mobile.layout.Abstract} The layout of this page.
     */
    construct: function construct(wrapContentByGroup, layout) {
      qx.ui.mobile.page.Page.constructor.call(this);

      if (wrapContentByGroup != null) {
        this._wrapContentByGroup = wrapContentByGroup;
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the user tapped on the navigation button */
      action: "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The title of the page */
      title: {
        check: "String",
        init: "",
        event: "changeTitle",
        apply: "_applyTitle"
      },

      /** The back button text */
      backButtonText: {
        check: "String",
        init: "",
        apply: "_applyBackButtonText"
      },

      /** The action button text */
      buttonText: {
        check: "String",
        init: "",
        apply: "_applyActionButtonText"
      },

      /** The action button icon */
      buttonIcon: {
        check: "String",
        init: null,
        nullable: true,
        apply: "_applyActionButtonIcon"
      },

      /**
       * Whether to show the back button.
       */
      showBackButton: {
        check: "Boolean",
        init: false,
        apply: "_applyShowBackButton"
      },

      /**
       * Indicates whether the back button should be shown on tablet.
       */
      showBackButtonOnTablet: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether to show the action button.
       */
      showButton: {
        check: "Boolean",
        init: false,
        apply: "_applyShowButton"
      },

      /**
       * Toggles visibility of NavigationBar in
       * wrapping container {@link qx.ui.mobile.container.Navigation}
       */
      navigationBarHidden: {
        check: "Boolean",
        init: false
      },

      /**
       * Sets the transition duration (in seconds) for the effect when hiding/showing
       * the NavigationBar through boolean property navigationBarHidden.
       */
      navigationBarToggleDuration: {
        check: "Number",
        init: 0.8
      },

      /**
       * The CSS class to add to the content per default.
       */
      contentCssClass: {
        check: "String",
        init: "content",
        nullable: true,
        apply: "_applyContentCssClass"
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      _isTablet: false,
      _wrapContentByGroup: true,
      __backButton__P_479_0: null,
      __actionButton__P_479_1: null,
      __content__P_479_2: null,
      __scrollContainer__P_479_3: null,
      __title__P_479_4: null,
      __leftContainer__P_479_5: null,
      __rightContainer__P_479_6: null,
      // interface implementation
      getTitleWidget: function getTitleWidget() {
        if (!this.__title__P_479_4) {
          this.__title__P_479_4 = this._createTitleWidget();
        }

        return this.__title__P_479_4;
      },

      /**
       * Creates the navigation bar title.
       *
       * @return {qx.ui.mobile.navigationbar.Title} The created title widget
       */
      _createTitleWidget: function _createTitleWidget() {
        return new qx.ui.mobile.navigationbar.Title(this.getTitle());
      },
      // property apply
      _applyTitle: function _applyTitle(value, old) {
        if (this.__title__P_479_4) {
          this.__title__P_479_4.setValue(value);
        }
      },
      // interface implementation
      getLeftContainer: function getLeftContainer() {
        if (!this.__leftContainer__P_479_5) {
          this.__leftContainer__P_479_5 = this._createLeftContainer();
        }

        return this.__leftContainer__P_479_5;
      },
      // interface implementation
      getRightContainer: function getRightContainer() {
        if (!this.__rightContainer__P_479_6) {
          this.__rightContainer__P_479_6 = this._createRightContainer();
        }

        return this.__rightContainer__P_479_6;
      },

      /**
       * Creates the left container for the navigation bar.
       *
       * @return {qx.ui.mobile.container.Composite} Creates the left container for the navigation bar.
       */
      _createLeftContainer: function _createLeftContainer() {
        var layout = new qx.ui.mobile.layout.HBox();
        var container = new qx.ui.mobile.container.Composite(layout);
        container.addCssClass("left-container");
        this.__backButton__P_479_0 = this._createBackButton();

        this.__backButton__P_479_0.addListener("tap", this._onBackButtonTap, this);

        this._showBackButton();

        container.add(this.__backButton__P_479_0);
        return container;
      },

      /**
       * Creates the right container for the navigation bar.
       *
       * @return {qx.ui.mobile.container.Composite} Creates the right container for the navigation bar.
       */
      _createRightContainer: function _createRightContainer() {
        var layout = new qx.ui.mobile.layout.HBox();
        var container = new qx.ui.mobile.container.Composite(layout);
        container.addCssClass("right-container");
        this.__actionButton__P_479_1 = this._createButton();

        this.__actionButton__P_479_1.addListener("tap", this._onButtonTap, this);

        this._showButton();

        container.add(this.__actionButton__P_479_1);
        return container;
      },

      /**
        * Creates the navigation bar back button.
        * Creates the scroll container.
        *
        * @return {qx.ui.mobile.navigationbar.BackButton} The created back button widget
        */
      _createBackButton: function _createBackButton() {
        return new qx.ui.mobile.navigationbar.BackButton(this.getBackButtonText());
      },

      /**
        * Creates the navigation bar button.
        * Creates the content container.
        *
        * @return {qx.ui.mobile.navigationbar.Button} The created button widget
        */
      _createButton: function _createButton() {
        return new qx.ui.mobile.navigationbar.Button(this.getButtonText(), this.getButtonIcon());
      },

      /**
       * Returns the content container. Add all your widgets to this container.
       *
       * @return {qx.ui.mobile.container.Composite} The content container
       */
      getContent: function getContent() {
        return this.__content__P_479_2;
      },

      /**
       * Returns the back button widget.
       *
       * @return {qx.ui.mobile.navigationbar.BackButton} The back button widget
       */
      _getBackButton: function _getBackButton() {
        return this.__backButton__P_479_0;
      },

      /**
       * Returns the action button widget.
       *
       * @return {qx.ui.mobile.navigationbar.Button} The action button widget
       */
      _getButton: function _getButton() {
        return this.__actionButton__P_479_1;
      },

      /**
       * Sets the isTablet flag.
       * @param isTablet {Boolean} value of the isTablet flag.
       */
      setIsTablet: function setIsTablet(isTablet) {
        this._isTablet = isTablet;
      },

      /**
       * Returns the isTablet flag.
       * @return {Boolean} the isTablet flag of this page.
       */
      isTablet: function isTablet() {
        return this._isTablet;
      },

      /**
       * Returns the scroll container.
       *
       * @return {qx.ui.mobile.container.Scroll} The scroll container
       */
      _getScrollContainer: function _getScrollContainer() {
        return this.__scrollContainer__P_479_3;
      },

      /**
       * Adds a widget, below the NavigationBar.
       *
       * @param widget {qx.ui.mobile.core.Widget} The widget to add, after NavigationBar.
       */
      addAfterNavigationBar: function addAfterNavigationBar(widget) {
        if (widget && this.__scrollContainer__P_479_3) {
          this.addBefore(widget, this.__scrollContainer__P_479_3);
        }
      },
      // property apply
      _applyBackButtonText: function _applyBackButtonText(value, old) {
        if (this.__backButton__P_479_0) {
          this.__backButton__P_479_0.setValue(value);
        }
      },
      // property apply
      _applyActionButtonText: function _applyActionButtonText(value, old) {
        if (this.__actionButton__P_479_1) {
          this.__actionButton__P_479_1.setValue(value);
        }
      },
      // property apply
      _applyActionButtonIcon: function _applyActionButtonIcon(value, old) {
        if (this.__actionButton__P_479_1) {
          this.__actionButton__P_479_1.setIcon(value);
        }
      },
      // property apply
      _applyShowBackButton: function _applyShowBackButton(value, old) {
        this._showBackButton();
      },
      // property apply
      _applyShowButton: function _applyShowButton(value, old) {
        this._showButton();
      },
      // property apply
      _applyContentCssClass: function _applyContentCssClass(value, old) {
        if (this.__content__P_479_2) {
          this.__content__P_479_2.setDefaultCssClass(value);
        }
      },

      /**
       * Helper method to show the back button.
       */
      _showBackButton: function _showBackButton() {
        if (this.__backButton__P_479_0) {
          if (this.getShowBackButton()) {
            this.__backButton__P_479_0.show();
          } else {
            this.__backButton__P_479_0.exclude();
          }
        }
      },

      /**
       * Helper method to show the button.
       */
      _showButton: function _showButton() {
        if (this.__actionButton__P_479_1) {
          if (this.getShowButton()) {
            this.__actionButton__P_479_1.show();
          } else {
            this.__actionButton__P_479_1.exclude();
          }
        }
      },
      // overridden
      _initialize: function _initialize() {
        qx.ui.mobile.page.NavigationPage.prototype._initialize.base.call(this);

        this.__scrollContainer__P_479_3 = this._createScrollContainer();
        this.__content__P_479_2 = this._createContent();

        if (this.__content__P_479_2) {
          this.__scrollContainer__P_479_3.add(this.__content__P_479_2, {
            flex: 1
          });
        }

        if (this.__scrollContainer__P_479_3) {
          this.add(this.__scrollContainer__P_479_3, {
            flex: 1
          });
        }
      },

      /**
       * Creates the scroll container.
       *
       * @return {qx.ui.mobile.container.Scroll} The created scroll container
       */
      _createScrollContainer: function _createScrollContainer() {
        return new qx.ui.mobile.container.Scroll();
      },

      /**
       * Creates the content container.
       *
       * @return {qx.ui.mobile.container.Composite} The created content container
       */
      _createContent: function _createContent() {
        var content = new qx.ui.mobile.container.Composite();
        content.setDefaultCssClass(this.getContentCssClass());

        if (this._wrapContentByGroup == true) {
          content.addCssClass("group");
        }

        return content;
      },

      /**
       * Event handler. Called when the tap event occurs on the back button.
       *
       * @param evt {qx.event.type.Tap} The tap event
       */
      _onBackButtonTap: function _onBackButtonTap(evt) {
        this.back();
      },

      /**
       * Event handler. Called when the tap event occurs on the button.
       *
       * @param evt {qx.event.type.Tap} The tap event
       */
      _onButtonTap: function _onButtonTap(evt) {
        this.fireEvent("action");
      }
    },
    destruct: function destruct() {
      this._disposeObjects("__leftContainer__P_479_5", "__rightContainer__P_479_6", "__backButton__P_479_0", "__actionButton__P_479_1", "__title__P_479_4");

      this.__leftContainer__P_479_5 = this.__rightContainer__P_479_6 = this.__backButton__P_479_0 = this.__actionButton__P_479_1 = null;
      this.__title__P_479_4 = this.__content__P_479_2 = this.__scrollContainer__P_479_3 = null;
      this._isTablet = null;
    }
  });
  qx.ui.mobile.page.NavigationPage.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.ui.mobile.tabbar.TabButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * This widget displays a tab bar.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var tabBar = new qx.ui.mobile.tabbar.TabBar();
   *   var tabButton1 = new qx.ui.mobile.tabbar.TabButton("Tab 1");
   *   tabButton1.setView(view1);
   *   tabBar.add(tabButton1);
   *   var tabButton2 = new qx.ui.mobile.tabbar.TabButton("Tab 2");
   *   tabButton2.setView(view2);
   *   tabBar.add(tabButton2);
   *
   *   this.getRoot.add(tabBar);
   * </pre>
   *
   * This example creates a tab bar and adds two tab buttons to it.
   */
  qx.Class.define("qx.ui.mobile.tabbar.TabBar", {
    extend: qx.ui.mobile.core.Widget,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);

      this._setLayout(new qx.ui.mobile.layout.HBox());

      this.addListener("tap", this._onTap, this);
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "tabBar"
      },

      /**
       * Sets the selected tab.
       */
      selection: {
        check: "qx.ui.mobile.tabbar.TabButton",
        nullable: true,
        init: null,
        apply: "_applySelection",
        event: "changeSelection"
      }
    },

    /*
     *****************************************************************************
        MEMBERS
     *****************************************************************************
     */
    members: {
      /**
       * Event handler. Called when a tab event occurs.
       *
       * @param evt {qx.event.type.Tap} The event object
       */
      _onTap: function _onTap(evt) {
        var target = evt.getTarget();

        while (!(target instanceof qx.ui.mobile.tabbar.TabButton)) {
          if (target.getLayoutParent) {
            var layoutParent = target.getLayoutParent();

            if (layoutParent == null || layoutParent instanceof qx.ui.mobile.tabbar.TabBar) {
              target = null;
              break;
            }

            target = layoutParent;
          } else {
            target = null;
            break;
          }
        }

        if (target !== null) {
          this.setSelection(target);
        }
      },
      // property apply
      _applySelection: function _applySelection(value, old) {
        if (old) {
          old.removeCssClass("selected");

          if (old.getView()) {
            old.getView().exclude();
          }
        }

        if (value) {
          value.addCssClass("selected");

          if (value.getView()) {
            value.getView().show();
          }
        }
      },

      /**
       * Adds a tab button to the tab bar.
       *
       * @param button {qx.ui.mobile.tabbar.TabButton} The button to add
       */
      add: function add(button) {
        this._add(button, {
          flex: 1
        });

        if (!this.getSelection()) {
          this.setSelection(button);
        }

        button.addListener("changeView", this._onChangeView, this);
      },

      /**
       * Event handler. Called when the view was changed.
       *
       * @param evt {qx.event.type.Data} The event
       */
      _onChangeView: function _onChangeView(evt) {
        if (this.getSelection() == evt.getTarget()) {
          evt.getData().show();
        }
      },

      /**
       * Removes a tab button from the tab bar.
       *
       * @param button {qx.ui.mobile.tabbar.TabButton} The button to remove
       */
      remove: function remove(button) {
        this._remove(button);

        if (this.getSelection() == button) {
          this.setSelection(null);
        }

        button.removeListener("changeView", this._onChangeView, this);
      }
    },
    destruct: function destruct() {
      this.removeListener("tap", this._onTap, this);
    }
  });
  qx.ui.mobile.tabbar.TabBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Button": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */

  /**
   * A tab button widget.
   *
   * A tab button can be added to the tab bar and is associated with a
   * {@link #view}.
   */
  qx.Class.define("qx.ui.mobile.tabbar.TabButton", {
    extend: qx.ui.mobile.form.Button,

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "tabButton"
      },

      /**
       * The associated view.
       */
      view: {
        check: "qx.ui.mobile.core.Widget",
        nullable: false,
        init: null,
        apply: "_applyView",
        event: "changeView"
      }
    },
    members: {
      // property apply
      _applyView: function _applyView(value, old) {
        value.exclude();
      }
    }
  });
  qx.ui.mobile.tabbar.TabButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.form.Button": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * A button used in toolbars.
   *
   */
  qx.Class.define("qx.ui.mobile.toolbar.Button", {
    extend: qx.ui.mobile.form.Button,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "toolbar-button"
      }
    }
  });
  qx.ui.mobile.toolbar.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.core.Widget": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * A separator widget used to separate widgets in a toolbar.
   *
   */
  qx.Class.define("qx.ui.mobile.toolbar.Separator", {
    extend: qx.ui.mobile.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.mobile.core.Widget.constructor.call(this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "toolbar-separator"
      }
    }
  });
  qx.ui.mobile.toolbar.Separator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.mobile.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.mobile.layout.HBox": {
        "construct": true
      },
      "qx.ui.mobile.toolbar.Separator": {},
      "qx.lang.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gabriel Munteanu (gabios)
  
  ************************************************************************ */

  /**
   * A toolbar widget.
   *
   */
  qx.Class.define("qx.ui.mobile.toolbar.ToolBar", {
    extend: qx.ui.mobile.container.Composite,

    /*
     *****************************************************************************
        CONSTRUCTOR
     *****************************************************************************
     */
    construct: function construct(layout) {
      qx.ui.mobile.container.Composite.constructor.call(this, layout);

      if (!layout) {
        this.setLayout(new qx.ui.mobile.layout.HBox().set({
          alignY: "middle"
        }));
      }
    },

    /*
    *****************************************************************************
        PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      defaultCssClass: {
        refine: true,
        init: "toolbar"
      }
    },
    members: {
      /**
        * Flag to keep the show/hidden state of the toolbar
        */
      __hidden__P_481_0: false,

      /**
        * Adds a new child widget.
        *
        * @param child {qx.ui.mobile.core.Widget} the widget to add.
        * @param layoutProperties {Map?null} Optional layout data for widget.
        */
      add: function add(child, layoutProperties) {
        if (!(child instanceof qx.ui.mobile.toolbar.Separator)) {
          layoutProperties = layoutProperties ? layoutProperties : {};
          qx.lang.Object.mergeWith(layoutProperties, {
            flex: 1
          }, false);
        }

        qx.ui.mobile.toolbar.ToolBar.prototype.add.base.call(this, child, layoutProperties);
      }
    }
  });
  qx.ui.mobile.toolbar.ToolBar.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.progressive.structure.Default": {
        "construct": true
      },
      "qx.ui.progressive.State": {},
      "qx.event.Timer": {},
      "qx.ui.core.queue.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * <i>Progressive</i>.
   *
   * Follow progressive instructions provided by a data model.  A variable
   * number of instructions are executed at one time, after which control is
   * returned briefly to the browser.  This allows browser rendering between
   * batches of instructions, improving the visual experience.
   *
   * <i>Progressive</i> may be used for various purposes.  Two predefined
   * purposes for which "renderers" are provided, are a progressively-rendered
   * table which allows variable row height, and a program load/initialization
   * renderer with progress bar.  (Note that the term "renderer" is interpreted
   * quite broadly.  A renderer needn't actually render; rather it is just some
   * set of activities that takes place at one time, e.g a row of table data or
   * a single widget added to the document or a sending a request to a server,
   * etc.)
   */
  qx.Class.define("qx.ui.progressive.Progressive", {
    extend: qx.ui.container.Composite,

    /**
     * @param structure {qx.ui.progressive.structure.Abstract}
     *   The structure of the Progressive pane.
     */
    construct: function construct(structure) {
      qx.ui.container.Composite.constructor.call(this, new qx.ui.layout.VBox()); // Create an object in which we'll track renderers that have been added

      this.__renderer__P_483_0 = {}; // Prepare to have our pane structure added to us.

      this.set({
        backgroundColor: "white"
      }); // If no structure is provided...

      if (!structure) {
        // ... then create a default one.
        structure = new qx.ui.progressive.structure.Default();
      } // Prepare our pane structure


      this.__structure__P_483_1 = structure;
      structure.applyStructure(this); // We've not yet done our initial render

      this.__bInitialRenderComplete__P_483_2 = false; // We're not currently rendering

      this.__bRendering__P_483_3 = false; // Number of elements available to be rendered.  Useful for progress
      // handlers, e.g. a progress bar or status counter.

      this.__initialNumElements__P_483_4 = 0;
    },
    events: {
      /**
       * Event fired when rendering begins.
       *
       * The event data is an object with the following members:
       * <dl>
       *   <dt>state</dt>
       *   <dd>
       *     The state object.
       *   </dd>
       *
       *   <dt>initial</dt>
       *     The number of elements that are available to be rendered
       *   <dd>
       *   </dd>
       * </dl>
       */
      "renderStart": "qx.event.type.Data",

      /**
       * Event fired when rendering ends.  The data is the state object.
       */
      "renderEnd": "qx.event.type.Data",

      /**
       * This event is fired after each batch of elements is rendered, and
       * control is about to be yielded to the browser.  This is an appropriate
       * event to listen for, to implement a progress bar.
       *
       * The event data is an object with the following members:
       * <dl>
       *   <dt>initial</dt>
       *   <dd>
       *     The number of elements that were available at the start of this
       *     rendering request.
       *   </dd>
       *
       *   <dt>remaining</dt>
       *   <dd>
       *     The number of elements still remaining to be rendered.
       *   </dd>
       * </dl>
       */
      "progress": "qx.event.type.Data",

      /**
       * This event is fired after each element is rendered.
       *
       * The event data is an object with the following members:
       * <dl>
       *   <dt>initial</dt>
       *   <dd>
       *     The number of elements that were available at the start of this
       *     rendering request.
       *   </dd>
       *
       *   <dt>remaining</dt>
       *   <dd>
       *     The number of elements still remaining to be rendered.
       *   </dd>
       *
       *   <dt>element</dt>
       *   <dd>
       *     The object, returned by the data model's getNextElement() method,
       *     that was just rendered.
       *   </dd>
       * </dl>
       *
       * Note: Unless batchSize is set to 1 or we happen to be at the end of a
       *       batch, widgets will not be rendered at this time.  Use this event
       *       for programmatically processing rendered elements, but not for
       *       such things as progress bars.  Instead, where only user-visible
       *       changes such as progress bars are being updated, use the
       *       "progress" event.
       */
      "progressDetail": "qx.event.type.Data"
    },
    properties: {
      /** The data model. */
      dataModel: {
        check: "qx.ui.progressive.model.Abstract",
        apply: "_applyDataModel"
      },

      /**
       * Number of elements to render at one time.  After this number of
       * elements has been rendered, control will be yielded to the browser
       * allowing the elements to actually be displayed.  A short-interval timer
       * will be set, to regain control to render the next batch of elements.
       */
      batchSize: {
        check: "Integer",
        init: 20
      },

      /**
       * Flush the widget queue after each batch is rendered.  This is
       * particularly relevant for such things as progressive loading, where
       * the whole purpose is to be able to see the loading progressing.
       */
      flushWidgetQueueAfterBatch: {
        check: "Boolean",
        init: false
      },

      /**
       * Delay between rendering elements. Zero is normally adequate, but
       * there are times that the user wants more time between rendering
       * some elements.
       */
      interElementTimeout: {
        check: "Integer",
        init: 0
      }
    },
    members: {
      __renderer__P_483_0: null,
      __bRendering__P_483_3: null,
      __t1__P_483_5: null,
      __initialNumElements__P_483_4: null,
      __bInitialRenderComplete__P_483_2: null,
      __structure__P_483_1: null,

      /**
       * Return the structure object
       *
       * @return {qx.ui.progressive.structure.Abstract} The structure object
       */
      getStructure: function getStructure() {
        return this.__structure__P_483_1;
      },

      /**
       * Add a renderer that can be referenced by the data model.
       *
       * @param name {String}
       *   Name referenced in the data model when this renderer is to be used.
       *
       * @param renderer {qx.ui.progressive.renderer.Abstract}
       *   Renderer object used if the data model references the specified name.
       *
       */
      addRenderer: function addRenderer(name, renderer) {
        this.__renderer__P_483_0[name] = renderer;
        renderer.join(this, name);
      },

      /**
       * Remove a previously added renderer.
       *
       * @param name {String}
       *   Remove the renderer which was assigned this name.
       *
       */
      removeRenderer: function removeRenderer(name) {
        if (!this.__renderer__P_483_0[name]) {
          throw new Error("No existing renderer named " + name);
        }

        delete this.__renderer__P_483_0[name];
      },

      /**
       * Render the elements available from the data model.  Elements are
       * rendered in batches of size {@link #batchSize}.  After each batch of
       * elements are rendered, control is returned temporarily to the
       * browser, so that actual screen updates can take place.  A timer is
       * used to regain control a short while later, in order to render the
       * next batch of element.
       *
       */
      render: function render() {
        // Prevent render calls while we're already rendering
        if (this.__bRendering__P_483_3) {
          return;
        }

        this.__bRendering__P_483_3 = true;
        var state = new qx.ui.progressive.State({
          progressive: this,
          model: this.getDataModel(),
          pane: this.__structure__P_483_1.getPane(),
          batchSize: this.getBatchSize(),
          rendererData: this.__createStateRendererData__P_483_6(),
          userData: {}
        }); // Record render start time

        this.__t1__P_483_5 = new Date(); // Render the first batch of elements.  Subsequent batches will be via
        // timer started from this.__renderElementBatch().

        if (this.__bInitialRenderComplete__P_483_2) {
          // Get the starting number of elements
          this.__initialNumElements__P_483_4 = state.getModel().getElementCount(); // Let listeners know we're beginning to render

          this.fireDataEvent("renderStart", {
            state: state,
            initial: this.__initialNumElements__P_483_4
          }); // Begin rendering

          this.__renderElementBatch__P_483_7(state);
        } else {
          // Ensure we leave enough time that 'this' has been rendered, so that
          // this.getContentElement().getDomElement() is valid and has
          // properties.  It's needed by some renderers.
          //
          // FIXME: Why isn't an event listener for "appear" an adequate delay???
          //        (It's done with a timer like this in Table's Pane too.)
          qx.event.Timer.once(function () {
            this.__initialNumElements__P_483_4 = state.getModel().getElementCount();
            this.fireDataEvent("renderStart", {
              state: state,
              initial: this.__initialNumElements__P_483_4
            });

            this.__renderElementBatch__P_483_7(state);

            this.__bInitialRenderComplete__P_483_2 = true;
          }, this, 10);
        }
      },

      /**
       * Called when the dataModel property is changed.
       *
       * @param value {qx.ui.progressive.model.Abstract}
       *   The new data model.
       *
       * @param old {qx.ui.progressive.model.Abstract}
       *   The old data model.
       *
       */
      _applyDataModel: function _applyDataModel(value, old) {
        if (old) {
          // Remove the old event listener
          old.removeListener("dataAvailable", this.__dataAvailable__P_483_8, this); // Dispose the old model

          old.dispose();
        } // Add an event listener so we know when data is available in the model


        value.addListener("dataAvailable", this.__dataAvailable__P_483_8, this);
      },

      /**
       * Render a batch of elements.  The batch size is determined by the
       * Progressive's batch size at the time that rendering began.  That batch
       * size was copied into the {@link qx.ui.progressive.State} object and is
       * used herein.
       *
       * @param state {qx.ui.progressive.State}
       *   The current state of rendering.
       *
       */
      __renderElementBatch__P_483_7: function __renderElementBatch__P_483_7(state) {
        var current;
        var element;
        var renderer;

        for (var i = state.getBatchSize(); i > 0; i--) {
          // Retrieve the current element
          current = state.getModel().getNextElement();

          if (!current) {
            // No more elements.  We're done.
            this.debug("Render time: " + (new Date() - this.__t1__P_483_5) + "ms");
            this.__bRendering__P_483_3 = false; // Notify any progress handlers that are listening

            this.fireDataEvent("renderEnd", state); // We don't need our render state any longer

            state.dispose(); // See ya!

            return;
          } // Get the element member


          element = current.element; // Get the element's renderer

          renderer = this.__renderer__P_483_0[element.renderer]; // Render this element

          renderer.render(state, element); // Notify any progress detail handlers that are listening

          this.fireDataEvent("progressDetail", {
            initial: this.__initialNumElements__P_483_4,
            remaining: current.remaining,
            element: element
          });
        } // Notify any progress handlers that are listening


        this.fireDataEvent("progress", {
          initial: this.__initialNumElements__P_483_4,
          remaining: current.remaining
        }); // Flush the widget queue

        if (this.getFlushWidgetQueueAfterBatch()) {
          qx.ui.core.queue.Manager.flush();
        } // Set a timer to render the next element


        qx.event.Timer.once(function () {
          this.__renderElementBatch__P_483_7(state);
        }, this, this.getInterElementTimeout());
      },

      /**
       * Create the map of empty objects for use by the renderers.
       * @return {Map} renderer data map
       */
      __createStateRendererData__P_483_6: function __createStateRendererData__P_483_6() {
        var rendererData = {};

        for (var name in this.__renderer__P_483_0) {
          rendererData[name] = {};
        }

        return rendererData;
      },

      /**
       * Event callback for the "dataAvailable" event.
       *
       * @param e {qx.event.type.Data}
       *   A "dataAvailable" event's data contains the initial number of elements
       *
       */
      __dataAvailable__P_483_8: function __dataAvailable__P_483_8(e) {
        this.__initialNumElements__P_483_4 = e.getData();
        this.render();
      }
    },

    /**
     */
    destruct: function destruct() {
      // For each renderer...
      for (var name in this.__renderer__P_483_0) {
        // ... dispose it
        this.__renderer__P_483_0[name].dispose();
      } // Clean up references


      this.__t1__P_483_5 = this.__renderer__P_483_0 = this.__structure__P_483_1 = null;
    }
  });
  qx.ui.progressive.Progressive.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Abstract structure definition for Progressive
   */
  qx.Class.define("qx.ui.progressive.structure.Abstract", {
    type: "abstract",
    extend: qx.core.Object,

    /**
     * The abstract structure for use by Progressive.  It defines the pane
     * container in which items are progressively rendered.
     *
     * @param pane {qx.ui.core.Widget|null}
     *   The container to use as the pane, applied to the Progressive
     *   structure.  If null, a qx.ui.core.Widget will be instantiated for
     *   use as the pane.
     */
    construct: function construct(pane) {
      qx.core.Object.constructor.call(this); // If no pane was specified. Create one.

      if (!pane) {
        this.__container__P_494_0 = new qx.ui.core.Widget();
        this.__pane__P_494_1 = this.__container__P_494_0;
      } else {
        this.__container__P_494_0 = null;
        this.__pane__P_494_1 = pane;
      }

      this.__pane__P_494_1.getContentElement().setStyle("overflowY", "auto");
    },
    members: {
      __container__P_494_0: null,
      __pane__P_494_1: null,

      /**
       * Apply the structure typically defined in the constructor to the
       * Progressive.
       *
       * @param progressive {qx.ui.progressive.Progressive}
       *   The Progressive to which the structure is to be applied.
       */
      applyStructure: function applyStructure(progressive) {
        throw new Error("applyStructure() is abstract");
      },

      /**
       * Get the pane in which this Progressive renders.
       *
       * @return {qx.ui.core.Widget}
       */
      getPane: function getPane() {
        return this.__pane__P_494_1;
      }
    },
    destruct: function destruct() {
      if (this.__container__P_494_0) {
        this.__container__P_494_0.dispose();
      }

      this.__container__P_494_0 = this.__pane__P_494_1 = null;
    }
  });
  qx.ui.progressive.structure.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.structure.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.progressive.headfoot.Null": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Structure definition for Progressive
   */
  qx.Class.define("qx.ui.progressive.structure.Default", {
    extend: qx.ui.progressive.structure.Abstract,

    /**
     * The default structure for use by Progressive.  It includes a header, a
     * footer, and a pane.
     *
     * @param header {qx.ui.progressive.headfoot.Abstract|null}
     *   The heading to apply to the Progressive structure.  If null, then no
     *   header will be visible.
     *
     * @param footer {qx.ui.progressive.headfoot.Abstract|null}
     *   The footer to apply to the Progressive structure.  If null then no
     *   footer will be visible.
     *
     * @param pane {qx.ui.core.Widget|null}
     *   The container to use as the pane, applied to the Progressive
     *   structure.  If null, a qx.ui.core.Widget will be instantiated for
     *   use as the pane.
     */
    construct: function construct(header, footer, pane) {
      qx.ui.progressive.structure.Abstract.constructor.call(this, pane); // If no header was specified, use null header

      if (!header) {
        this.__nullHeader__P_495_0 = new qx.ui.progressive.headfoot.Null();
        this.__header__P_495_1 = this.__nullHeader__P_495_0;
      } else {
        this.__nullHeader__P_495_0 = null;
        this.__header__P_495_1 = header;
      } // If no footer was specified, use a null footer


      if (!footer) {
        this.__nullFooter__P_495_2 = new qx.ui.progressive.headfoot.Null();
        this.__footer__P_495_3 = this.__nullFooter__P_495_2;
      } else {
        this.__nullFooter__P_495_2 = null;
        this.__footer__P_495_3 = footer;
      }
    },
    members: {
      __header__P_495_1: null,
      __footer__P_495_3: null,
      __nullHeader__P_495_0: null,
      __nullFooter__P_495_2: null,
      // overridden
      applyStructure: function applyStructure(progressive) {
        // Tell the header/footer components who their Progressive is
        this.__header__P_495_1.join(progressive);

        this.__footer__P_495_3.join(progressive); // Add the header, pane, and footer to the Progressive.


        progressive.add(this.__header__P_495_1);
        progressive.add(this.getPane(), {
          flex: 1
        });
        progressive.add(this.__footer__P_495_3);
      },

      /**
       * Return the header
       *
       * @return {qx.ui.progressive.headfoot.Abstract}
       */
      getHeader: function getHeader() {
        return this.__header__P_495_1;
      },

      /**
       * Return the footer
       *
       * @return {qx.ui.progressive.headfoot.Abstract}
       */
      getFooter: function getFooter() {
        return this.__footer__P_495_3;
      }
    },
    destruct: function destruct() {
      if (this.__nullHeader__P_495_0) {
        this.__nullHeader__P_495_0.dispose();

        this.__nullHeader__P_495_0 = null;
      }

      if (this.__nullFooter__P_495_2) {
        this.__nullFooter__P_495_2.dispose();

        this.__nullFooter__P_495_2 = null;
      }

      this.__header__P_495_1 = this.__footer__P_495_3 = null;
    }
  });
  qx.ui.progressive.structure.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * State of rendering by Progressive.
   */
  qx.Class.define("qx.ui.progressive.State", {
    extend: qx.core.Object,

    /**
     * @param initialState {Map}
     *   Map containing these members:
     *   <dl>
     *     <dt>progressive</dt>
     *       <dd>see {@link #progressive}</dd>
     *     <dt>model</dt>
     *       <dd>see {@link #model}</dd>
     *     <dt>pane</dt>
     *       <dd>see {@link #pane}</dd>
     *     <dt>batchSize</dt>
     *       <dd>see {@link #batchSize}</dd>
     *     <dt>rendererData</dt>
     *       <dd>see {@link #rendererData}</dd>
     *     <dt>userData</dt>
     *       <dd>see {@link #userData}</dd>
     *   </dl>
     */
    construct: function construct(initialState) {
      qx.core.Object.constructor.call(this);
      this.setProgressive(initialState.progressive);
      this.setModel(initialState.model);
      this.setPane(initialState.pane);
      this.setBatchSize(initialState.batchSize);
      this.setRendererData(initialState.rendererData);
      this.setUserData(initialState.userData);
    },
    properties: {
      /**
       * The {@link qx.ui.progressive.Progressive} with which this {@link
       * State} is associated. This property should be treated as read-only.
       */
      progressive: {
        nullable: true
      },

      /**
       * The data model being used. This property should be treated as
       * read-only.
       */
      model: {
        nullable: true
      },

      /**
       * The widget in which the element data should be rendered.  This property
       * should be treated as read-only.
       */
      pane: {
        nullable: true
      },

      /**
       * How many elements are rendered at a time, before yielding to the
       * browser.  This property should be treated as read-only.
       */
      batchSize: {},

      /**
       * Add a place for renderers' private data.  If multiple renderers are
       * being used, each renderer should place its own private data in the the
       * state object area reserved for that renderer's use:
       * state.getRendererData()[element.renderer].  This property should be
       * accessed only by renderers, and all elements of the array other than a
       * renderer's own element should be treated as read-only.
       *
       * IMPORTANT NOTE:  It is the renderer's responsibility to clean up its
       *                  own mess.  If the renderer places data here, it should
       *                  also add an event listener for "renderEnd" so that it
       *                  can clean up.
       */
      rendererData: {},

      /**
       * User data.  This is useful, for example, by communication between
       * the renderStart event listener and the renderers.
       *
       * IMPORTANT NOTE:  It is the user's responsibility to clean up his
       *                  own mess.  If you place data here, you should
       *                  also add an event listener for "renderEnd" to
       *                  dispose any objects you placed here.
       */
      userData: {}
    },
    destruct: function destruct() {
      // Remove references to other objects
      this.setProgressive(null);
      this.setModel(null);
      this.setPane(null);
    }
  });
  qx.ui.progressive.State.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * The abstract class for a header or footer for use with Progressive's Table
   * renderer.
   */
  qx.Class.define("qx.ui.progressive.headfoot.Abstract", {
    type: "abstract",
    extend: qx.ui.container.Composite,
    construct: function construct() {
      qx.ui.container.Composite.constructor.call(this, new qx.ui.layout.HBox());
    },
    members: {
      __progressive__P_484_0: null,

      /**
       * Join this header/footer to a Progressive.  This makes the Progressive
       * object available to the header/footer through the _progressive member.
       *
       * @param progressive {qx.ui.progressive.Progressive}
       *   Progressive object to which we're being joined.
       *
       */
      join: function join(progressive) {
        this.__progressive__P_484_0 = progressive;
      }
    },
    destruct: function destruct() {
      this.__progressive__P_484_0 = null;
    }
  });
  qx.ui.progressive.headfoot.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.headfoot.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A null header/footer.  This is not displayed.
   */
  qx.Class.define("qx.ui.progressive.headfoot.Null", {
    extend: qx.ui.progressive.headfoot.Abstract,
    construct: function construct() {
      qx.ui.progressive.headfoot.Abstract.constructor.call(this); // We're null, so don't display.

      this.exclude();
    }
  });
  qx.ui.progressive.headfoot.Null.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.headfoot.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true
      },
      "qx.ui.basic.Atom": {
        "construct": true
      },
      "qx.theme.manager.Color": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * The standard footer used with Progressive's Table renderer, to show
   * progress of loading data into the table.
   */
  qx.Class.define("qx.ui.progressive.headfoot.Progress", {
    extend: qx.ui.progressive.headfoot.Abstract,

    /**
     * @param columnWidths {qx.ui.progressive.renderer.table.Widths}
     *   The set of widths, minimum widths, and maximum widths to be used for
     *   each of the columns in the table.
     *
     * @param labelArr {Array}
     *   Array of labels, one for each of the columns.
     *
     */
    construct: function construct(columnWidths, labelArr) {
      qx.ui.progressive.headfoot.Abstract.constructor.call(this); // Set a default height for the progress bar

      this.setHeight(16);
      this.setPadding(0);
      this.__colors__P_485_0 = {};

      this.__linkColors__P_485_1();

      this.set({
        backgroundColor: this.__colors__P_485_0.background
      }); // Create a widget that continually increases its width for progress bar

      this.__progressBar__P_485_2 = new qx.ui.core.Widget();

      this.__progressBar__P_485_2.set({
        width: 0,
        backgroundColor: this.__colors__P_485_0.indicatorDone
      });

      this.add(this.__progressBar__P_485_2); // Create a flex area between the progress bar and the percent done

      var spacer = new qx.ui.core.Widget();
      spacer.set({
        backgroundColor: this.__colors__P_485_0.indicatorUndone
      });
      this.add(spacer, {
        flex: 1
      }); // We also like to show progress as a percentage done string.

      this.__percentDone__P_485_3 = new qx.ui.basic.Atom("0%");

      this.__percentDone__P_485_3.set({
        width: 100,
        backgroundColor: this.__colors__P_485_0.percentBackground,
        textColor: this.__colors__P_485_0.percentText
      });

      this.add(this.__percentDone__P_485_3); // We're initially invisible

      this.exclude();
    },
    members: {
      __total__P_485_4: null,
      __colors__P_485_0: null,
      __progressBar__P_485_2: null,
      __percentDone__P_485_3: null,
      // overridden
      _onChangeTheme: function _onChangeTheme() {
        qx.ui.progressive.headfoot.Progress.prototype._onChangeTheme.base.call(this);

        this.__linkColors__P_485_1();
      },

      /**
       * Helper to link the theme colors to the current class.
       */
      __linkColors__P_485_1: function __linkColors__P_485_1() {
        // link to color theme
        var colorMgr = qx.theme.manager.Color.getInstance();
        this.__colors__P_485_0.background = colorMgr.resolve("progressive-progressbar-background");
        this.__colors__P_485_0.indicatorDone = colorMgr.resolve("progressive-progressbar-indicator-done");
        this.__colors__P_485_0.indicatorUndone = colorMgr.resolve("progressive-progressbar-indicator-undone");
        this.__colors__P_485_0.percentBackground = colorMgr.resolve("progressive-progressbar-percent-background");
        this.__colors__P_485_0.percentText = colorMgr.resolve("progressive-progressbar-percent-text");
      },
      // overridden
      join: function join(progressive) {
        // Save the progressive handle
        qx.ui.progressive.headfoot.Progress.prototype.join.base.call(this, progressive); // Listen for the "renderStart" event, to save the number of elements on
        // the queue, and to set ourself visible

        progressive.addListener("renderStart", function (e) {
          this.__total__P_485_4 = e.getData().initial;
          this.show();
        }, this); // Listen for the "progress" event, to update the progress bar

        progressive.addListener("progress", function (e) {
          var complete = 1.0 - e.getData().remaining / this.__total__P_485_4;

          var mySize = this.getBounds();

          if (mySize) {
            var barWidth = Math.floor((mySize.width - this.__percentDone__P_485_3.getBounds().width) * complete);
            var percent = Math.floor(complete * 100) + "%";

            if (!isNaN(barWidth)) {
              this.__progressBar__P_485_2.setMinWidth(barWidth);

              this.__percentDone__P_485_3.setLabel(percent);
            }
          }
        }, this); // Listen for the "renderEnd" event to make ourself invisible

        progressive.addListener("renderEnd", function (e) {
          this.exclude();
        }, this);
      }
    },
    destruct: function destruct() {
      this.__colors__P_485_0 = null;

      this._disposeObjects("__progressBar__P_485_2", "__percentDone__P_485_3");
    }
  });
  qx.ui.progressive.headfoot.Progress.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.headfoot.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.basic.Atom": {
        "construct": true
      },
      "qx.ui.core.Widget": {
        "construct": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.bom.element.Scroll": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A header for a standard table.
   */
  qx.Class.define("qx.ui.progressive.headfoot.TableHeading", {
    extend: qx.ui.progressive.headfoot.Abstract,

    /**
     * @param columnWidths {qx.ui.progressive.renderer.table.Widths}
     *   The set of widths, minimum widths, and maximum widths to be used for
     *   each of the columns in the table.
     *
     * @param labelArr {Array}
     *   Array of labels, one for each of the columns.
     *
     */
    construct: function construct(columnWidths, labelArr) {
      qx.ui.progressive.headfoot.Abstract.constructor.call(this); // Save the Widths object containing all of our column widths

      this.__columnWidths__P_486_0 = columnWidths; // Get the array of column width data

      var columnData = columnWidths.getData(); // Create a place to put labels

      this.__labels__P_486_1 = []; // For each label...

      for (var i = 0; i < columnData.length; i++) {
        // ... create an atom to hold the label
        var label = new qx.ui.basic.Atom(labelArr[i]);
        label.setAppearance("progressive-table-header-cell"); // Add the label to this heading.

        this.add(label); // Save this label so we can resize it later

        this.__labels__P_486_1[i] = label;
      } // Add a spacer to take up the scroll-bar width


      var spacer = new qx.ui.core.Widget();
      spacer.set({
        height: 16,
        appearance: "progressive-table-header-cell",
        minWidth: 0,
        width: 0
      });
      this.add(spacer, {
        flex: 1
      }); // Arrange to be called when the window appears or is resized, so we
      // can set each style sheet's left and width field appropriately.

      this.addListener("resize", this._resizeColumns, this); // This layout is not connected to a widget but to this class. This class
      // must implement the method "getLayoutChildren", which must return all
      // columns (LayoutItems) which should be recalculated. The call
      // "layout.renderLayout" will call the method "renderLayout" on each
      // column data object The advantage of the use of the normal layout
      // manager is that the semantics of flex and percent are exactly the same
      // as in the widget code.

      this.__layout__P_486_2 = new qx.ui.layout.HBox();

      this.__layout__P_486_2.connectToWidget(this);
    },
    properties: {
      appearance: {
        refine: true,
        init: "progressive-table-header"
      }
    },
    members: {
      __columnWidths__P_486_0: null,
      __bCalculateWidths__P_486_3: null,
      __labels__P_486_1: null,
      __layout__P_486_2: null,
      // overridden
      join: function join(progressive) {
        // Save the progressive handle
        qx.ui.progressive.headfoot.TableHeading.prototype.join.base.call(this, progressive);
      },

      /**
       * This method is required by the box layout. If returns an array of items
       * to relayout.
       * @return {Array} List of child items
       */
      getLayoutChildren: function getLayoutChildren() {
        if (this.__bCalculateWidths__P_486_3) {
          return this.__columnWidths__P_486_0.getData();
        } else {
          return qx.ui.progressive.headfoot.TableHeading.prototype.getLayoutChildren.base.call(this);
        }
      },

      /**
       * Event handler for the "resize" event.  We recalculate and set the
       * new widths of each of our columns.
       *
       * @param e {qx.event.type.Event}
       *   Ignored.
       *
       */
      _resizeColumns: function _resizeColumns(e) {
        var insets = this.getInsets();
        var width = this.getBounds().width - qx.bom.element.Scroll.getScrollbarWidth() - insets.left - insets.right; // Compute the column widths

        this.__bCalculateWidths__P_486_3 = true;
        var padding = {
          top: this.getPaddingTop(),
          right: this.getPaddingRight(),
          bottom: this.getPaddingBottom(),
          left: this.getPaddingLeft()
        };

        this.__layout__P_486_2.renderLayout(width, 100, padding);

        this.__bCalculateWidths__P_486_3 = false; // Get the column data

        var columnData = this.__columnWidths__P_486_0.getData(); // Get the column width data.  For each label...


        for (var i = 0; i < columnData.length; i++) {
          // ... reset the width of the corresponding column (label)
          this.__labels__P_486_1[i].setWidth(columnData[i].getComputedWidth());
        }
      }
    },
    destruct: function destruct() {
      this.__columnWidths__P_486_0 = this.__labels__P_486_1 = null;

      this._disposeObjects("_layout");
    }
  });
  qx.ui.progressive.headfoot.TableHeading.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Data Model for Progressive renderer.
   */
  qx.Class.define("qx.ui.progressive.model.Abstract", {
    type: "abstract",
    extend: qx.core.Object,
    events: {
      /**
       * This event is fired when new data has been added to the data model.  It
       * typically informs Progressive to begin its rendering process.
       *
       * The event data is an integer: the number of elements now available on
       * the element queue.
       */
      "dataAvailable": "qx.event.type.Data"
    },
    members: {
      /**
       * Get the number of data elements currently available.
       *
       * @throws {Error} An error if this method is called.
       * @return {Integer}
       */
      getElementCount: function getElementCount() {
        throw new Error("getElementCount() is abstract");
      },

      /**
       * Get the next available element from the data model.
       *
       * @throws {Error} An error if this method is called.
       * @return {Object}
       *   The returned object must provide at least the following members:
       *   <dl>
       *     <dt>
       *       renderer</dt>
       *     <dd>
       *       The name of a renderer.  That name is used by {@link
       *       qx.ui.progressive.Progressive} to select the renderer to be used
       *       to render this element.  The name should match one provided to
       *       {@link qx.ui.progressive.Progressive#addRenderer}.
       *     </dd>
       *
       *     <dt>
       *       data
       *     </dt>
       *     <dd>
       *       The data to be passed to the renderer.  The data may be of any
       *       type that the renderer knows how to render.
       *     </dd>
       *   </dl>
       */
      getNextElement: function getNextElement() {
        throw new Error("getNextElement() is abstract");
      }
    }
  });
  qx.ui.progressive.model.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.model.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Data Model for Progressive renderer.
   */
  qx.Class.define("qx.ui.progressive.model.Default", {
    extend: qx.ui.progressive.model.Abstract,
    construct: function construct() {
      qx.ui.progressive.model.Abstract.constructor.call(this);
      this.__elements__P_487_0 = [];
    },
    members: {
      __elements__P_487_0: null,

      /**
       * Add elements to be progressively rendered.  Each element must be an
       * object which contains at least two members: renderer (the renderer
       * name) and data.
       *
       * @param elems {Array}
       *   An array of elements to be added to the element queue
       */
      addElements: function addElements(elems) {
        // Add the new elements to our elements queue.
        this.__elements__P_487_0 = this.__elements__P_487_0.concat(elems); // Tell Progressive that data is available

        this.fireDataEvent("dataAvailable", this.__elements__P_487_0.length);
      },

      /**
       * Add a single element to be progressively rendered.  The element must
       * be an object which contains at least two members: renderer (the
       * renderer name) and data.
       *
       * @param elem {var}
       *   An element to be added to the element queue
       */
      addElement: function addElement(elem) {
        // Add the new elements to our elements queue.
        this.__elements__P_487_0.push(elem); // Tell Progressive that data is available


        this.fireDataEvent("dataAvailable", this.__elements__P_487_0.length);
      },
      // overridden
      getElementCount: function getElementCount() {
        return this.__elements__P_487_0.length;
      },
      // overridden
      getNextElement: function getNextElement() {
        // Do we have any remaining elements?
        if (this.__elements__P_487_0.length > 0) {
          // Yup.  Give 'em the first one and remove it from our queue.
          return {
            element: this.__elements__P_487_0.shift(),
            remaining: this.__elements__P_487_0.length
          };
        }

        return null;
      }
    },
    destruct: function destruct() {
      this.__elements__P_487_0 = null;
    }
  });
  qx.ui.progressive.model.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Abstract renderer for Progressive.
   */
  qx.Class.define("qx.ui.progressive.renderer.Abstract", {
    type: "abstract",
    extend: qx.core.Object,
    members: {
      /**
       * Render the provided element in the renderer's unique way.
       *
       * @param state {qx.ui.progressive.State}
       *   Data relevant to the current rendering session.
       *
       * @param element {Object}
       *   An object containing at least the following members:
       *   <dl>
       *     <dt>
       *       renderer</dt>
       *     <dd>
       *       The name of a renderer.  That name is used by {@link
       *       qx.ui.progressive.Progressive} to select the renderer to be used
       *       to render this element.  The name should match one provided to
       *       {@link qx.ui.progressive.Progressive#addRenderer}.
       *     </dd>
       *
       *     <dt>
       *       data
       *     </dt>
       *     <dd>
       *       The data to be passed to the renderer.  The data may be of any
       *       type that the renderer knows how to render.
       *     </dd>
       *   </dl>
       *
       */
      render: function render(state, element) {
        throw new Error("render() is abstract");
      },

      /**
       * Join this renderer to its {@link qx.ui.progressive.Progressive}.
       *
       * @param progressive {qx.ui.progressive.Progressive}
       *   The Progressive object to which we are being joined.
       *
       * @param name {String}
       *   The name by which the data model will reference this renderer.  This
       *   is important to know in order to access the appropriate member of the
       *   {@link qx.ui.progressive.State}'s renderer array.  That array is
       *   accessed from the renderer by
       *   state.getRendererData()[element.renderer] where element.renderer will
       *   be the name provided here.
       */
      join: function join(progressive, name) {// nothing to do in the default case
      }
    }
  });
  qx.ui.progressive.renderer.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.Abstract": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Function "renderer" for Progressive.
   * This is a renderer that simply calls the function provided by the data
   * element.
   */
  qx.Class.define("qx.ui.progressive.renderer.FunctionCaller", {
    extend: qx.ui.progressive.renderer.Abstract,
    members: {
      // overridden
      render: function render(state, element) {
        element.data(state.getUserData());
      }
    }
  });
  qx.ui.progressive.renderer.FunctionCaller.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Default": {
        "construct": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.theme.manager.Meta": {
        "construct": true
      },
      "qx.bom.client.Css": {
        "require": true
      },
      "qx.bom.Style": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.manager.Color": {},
      "qx.bom.Stylesheet": {},
      "qx.bom.element.Scroll": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.textoverflow": {
          "load": true,
          "className": "qx.bom.client.Css"
        },
        "css.userselect": {
          "load": true,
          "className": "qx.bom.client.Css"
        },
        "css.userselect.none": {
          "load": true,
          "className": "qx.bom.client.Css"
        },
        "qx.tableResizeDebug": {},
        "css.boxmodel": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
     qooxdoo - the new era of web development
     http://qooxdoo.org
     Copyright:
      2008 Derrell Lipman
     License:
      MIT: https://opensource.org/licenses/MIT
      See the LICENSE file in the project's top-level directory for details.
     Authors:
      * Derrell Lipman (derrell)
  ************************************************************************ */

  /**
   * Table Row renderer for Progressive.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.Row", {
    extend: qx.ui.progressive.renderer.Abstract,

    /**
     * @param columnWidths {qx.ui.progressive.renderer.table.Widths}
     *   Information that indicates how to resize each of the column widths
     */
    construct: function construct(columnWidths) {
      qx.ui.progressive.renderer.Abstract.constructor.call(this); // Save the column widths

      this.__columnWidths__P_488_0 = columnWidths; // Create space to store renderers for each column

      this.__renderers__P_488_1 = {}; // We need a default cell renderer to use if none is specified

      this.__defaultCellRenderer__P_488_2 = new qx.ui.progressive.renderer.table.cell.Default(); // We don't yet know who our Progressive will be

      this.__progressive__P_488_3 = null;
      this.__colors__P_488_4 = {};

      this.__linkColors__P_488_5(); // This layout is not connected to a widget but to this class. This class
      // must implement the method "getLayoutChildren", which must return all
      // columns (LayoutItems) which should be recalculated. The call
      // "layout.renderLayout" will call the method "renderLayout" on each
      // column data object The advantage of the use of the normal layout
      // manager is that the semantics of flex and percent are exactly the same
      // as in the widget code.


      this.__layout__P_488_6 = new qx.ui.layout.HBox();

      this.__layout__P_488_6.connectToWidget(this); // dynamic theme switch


      {
        qx.theme.manager.Meta.getInstance().addListener("changeTheme", this.__linkColors__P_488_5, this);
      }
    },
    statics: {
      /**
       * Storage for each progressive.
       *
       * @internal
       */
      __clazz__P_488_7: null,

      /**
       * Default row padding.
       *
       * @internal
       */
      __padding__P_488_8: 6,
      // modify padding parameter below too if this changes

      /**
       * Default style sheet for table cells.
       *
       * @internal
       */
      __tableCellStyleSheet__P_488_9: "  position: absolute;  top: 0px;  height: 100%;  overflow:hidden;" + (qx.core.Environment.get("css.textoverflow") ? qx.bom.Style.getCssName(qx.core.Environment.get("css.textoverflow")) + ':ellipsis;' : "") + "  white-space:nowrap;" + "  border-right:1px solid #f2f2f2;" + "  border-bottom:1px solid #eeeeee;" + "  padding : 0px 6px 0px 6px;" + "  cursor:default;" + "  font-size: 11px;" + "  font-family: 'Segoe UI', Corbel, Calibri, Tahoma, 'Lucida Sans Unicode', sans-serif;" + (qx.core.Environment.get("css.userselect") ? qx.bom.Style.getCssName(qx.core.Environment.get("css.userselect")) + ':' + qx.core.Environment.get("css.userselect.none") + ';' : '')
    },
    properties: {
      /** The default height of a row, if not altered by a cell renderer. */
      defaultRowHeight: {
        init: 16
      }
    },
    members: {
      __progressive__P_488_3: null,
      __name__P_488_10: null,
      __hash__P_488_11: null,
      __columnWidths__P_488_0: null,
      __renderers__P_488_1: null,
      __defaultCellRenderer__P_488_2: null,
      __colors__P_488_4: null,
      __layout__P_488_6: null,

      /**
       * Helper to link the theme colors to the current class
       */
      __linkColors__P_488_5: function __linkColors__P_488_5() {
        // link to color theme
        var colorMgr = qx.theme.manager.Color.getInstance();
        this.__colors__P_488_4.bgcol = [];
        this.__colors__P_488_4.bgcol[0] = colorMgr.resolve("progressive-table-row-background-even");
        this.__colors__P_488_4.bgcol[1] = colorMgr.resolve("progressive-table-row-background-odd");
      },
      // overridden
      join: function join(progressive, name) {
        // Are we already joined?
        if (this.__progressive__P_488_3) {
          // Yup.  Let 'em know they can't do that.
          throw new Error("Renderer is already joined to a Progressive.");
        } // Save the Progressive to which we're joined


        this.__progressive__P_488_3 = progressive; // Save the name that Progressive knows us by

        this.__name__P_488_10 = name; // If we haven't created style sheets for this table yet...

        var tr = qx.ui.progressive.renderer.table.Row;

        if (!tr.__clazz__P_488_7) {
          tr.__clazz__P_488_7 = {};
        }

        var hash = progressive.toHashCode();

        if (!tr.__clazz__P_488_7[hash]) {
          // ... then do it now.
          tr.__clazz__P_488_7[hash] = {
            rowstylesheet: null,
            cellstylesheet: []
          };
          var stylesheet = ".qx-progressive-" + hash + "-row {" + "  width : 100%;" + "}";
          tr.__clazz__P_488_7[hash].rowstylesheet = qx.bom.Stylesheet.createElement(stylesheet);

          var columnData = this.__columnWidths__P_488_0.getData();

          for (var i = 0; i < columnData.length; i++) {
            var stylesheet = ".qx-progressive-" + hash + "-col-" + i + " {" + tr.__tableCellStyleSheet__P_488_9 + "}";
            tr.__clazz__P_488_7[hash].cellstylesheet[i] = qx.bom.Stylesheet.createElement(stylesheet);
          } // Save the hash too


          this.__hash__P_488_11 = hash; // Arrange to be called when the window appears or is resized, so we
          // can set each style sheet's left and width field appropriately.

          var pane = progressive.getStructure().getPane();
          pane.addListener("resize", this._resizeColumns, this);
        }
      },

      /**
       * Add a cell renderer for use within a row rendered by this row
       * renderer.
       *
       * @param column {Integer}
       *   The column number for which the cell renderer applies
       *
       * @param renderer {qx.ui.progressive.renderer.table.cell.Abstract}
       *   The cell renderer for the specified column.
       *
       */
      addRenderer: function addRenderer(column, renderer) {
        var columnData = this.__columnWidths__P_488_0.getData();

        if (column < 0 || column >= columnData.length) {
          throw new Error("Column " + column + " out of range (max: " + (columnData.length - 1) + ")");
        }

        this.__renderers__P_488_1[column] = renderer;
      },

      /**
       * Remove a cell renderer previously added with {@link #addRenderer}.
       *
       * @param column {Integer}
       *   The column for which the cell renderer is to be removed.
       *
       */
      removeRenderer: function removeRenderer(column) {
        var columnData = this.__columnWidths__P_488_0.getData();

        if (column < 0 || column >= columnData.length) {
          throw new Error("Column " + column + " out of range (max: " + (columnData.length - 1) + ")");
        }

        if (!this.__renderers__P_488_1[column]) {
          throw new Error("No existing renderer for column " + column);
        }

        delete this.__renderers__P_488_1[column];
      },
      // overridden
      render: function render(state, element) {
        var data = element.data;
        var html = [];
        var cellInfo;
        var renderer;
        var height = 0; // Initialize row counter, if necessary.  We'll use this for shading
        // alternate rows.

        if (state.getRendererData()[this.__name__P_488_10].end === undefined) {
          state.getRendererData()[this.__name__P_488_10] = {
            end: 0,
            start: 1,
            rows: 0,
            totalHeight: 0
          };
        } // Create the div for this row


        var div = document.createElement("div"); // For each cell...

        for (var i = 0; i < data.length; i++) {
          var stylesheet = "qx-progressive-" + this.__hash__P_488_11 + "-col-" + i; // Determine what renderer to use for this column

          renderer = this.__renderers__P_488_1[i] || this.__defaultCellRenderer__P_488_2; // Specify information that cell renderer will need

          cellInfo = {
            state: state,
            rowDiv: div,
            stylesheet: stylesheet,
            element: element,
            dataIndex: i,
            cellData: data[i],
            height: height
          }; // Render this cell

          html.push(renderer.render(cellInfo)); // If this cell's height was greater than our current maximum...

          if (cellInfo.height > height) {
            // ... then it becomes our row height
            height = cellInfo.height;
          }
        }

        height = height > 0 ? height : this.getDefaultRowHeight(); // Get a reference to our renderer data

        var rendererData = state.getRendererData()[this.__name__P_488_10]; // Track total height so we can determine if there's a vertical scrollbar


        rendererData.totalHeight += height; // Set properties for the row div

        div.style.position = "relative";
        div.style.height = height + "px";
        div.className = "qx-progressive-" + this.__hash__P_488_11 + "-row";
        div.innerHTML = html.join(""); // Add this row to the table

        switch (element.location) {
          case "end":
            // Determine color of row based on state of last added row
            var index = rendererData.end || 0; // Set the background color of this row

            div.style.backgroundColor = this.__colors__P_488_4.bgcol[index]; // Update state for next time

            rendererData.end = index == 0 ? 1 : 0; // Append our new row to the pane.

            state.getPane().getContentElement().getDomElement().appendChild(div);
            break;

          case "start":
            // Get the pane element
            var elem = state.getPane().getContentElement().getDomElement(); // Get its children array

            var children = elem.childNodes; // Are there any children?

            if (children.length > 0) {
              // Yup.  Determine color of row based on state of last added row
              var index = rendererData.start; // Set the background color of this row

              div.style.backgroundColor = this.__colors__P_488_4.bgcol[index]; // Update state for next time

              rendererData.start = index == 0 ? 1 : 0; // Insert our new row before the first child.

              elem.insertBefore(div, children[0]);
              break;
            } else {
              /* No children yet.  We can append our new row. */
              elem.appendChild(div);
            }

            break;

          default:
            throw new Error("Invalid location: " + element.location);
        } // Increment row count


        ++rendererData.rows;
      },

      /**
       * This method is required by the box layout. If returns an array of items
       * to relayout.
       * @return {Array} Array of column data.
       */
      getLayoutChildren: function getLayoutChildren() {
        return this.__columnWidths__P_488_0.getData();
      },

      /**
       * Event handler for the "resize" event.  We recalculate the
       * widths of each of the columns, and modify the stylesheet rule
       * applicable to each column, to apply the new widths.
       *
       * @param e {qx.event.type.Event}
       *   Ignored
       *
       */
      _resizeColumns: function _resizeColumns(e) {
        var pane = this.__progressive__P_488_3.getStructure().getPane();

        var width = pane.getBounds().width - qx.bom.element.Scroll.getScrollbarWidth(); // Get the style sheet rule name for this row

        var stylesheet = ".qx-progressive-" + this.__hash__P_488_11 + "-row"; // Remove the style rule for this row

        var tr = qx.ui.progressive.renderer.table.Row;
        qx.bom.Stylesheet.removeRule(tr.__clazz__P_488_7[this.__hash__P_488_11].rowstylesheet, stylesheet); // Create the new rule for this row

        var rule = "width: " + width + "px;"; // Apply the new rule

        qx.bom.Stylesheet.addRule(tr.__clazz__P_488_7[this.__hash__P_488_11].rowstylesheet, stylesheet, rule); // Compute the column widths

        this.__layout__P_488_6.renderLayout(width, 100, {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }); // Get the column data


        var columnData = this.__columnWidths__P_488_0.getData(); // Reset each of the column style sheets to deal with width changes


        for (var i = 0, left = 0; i < columnData.length; i++, left += width) {
          // Get the style sheet rule name for this cell
          var stylesheet = ".qx-progressive-" + this.__hash__P_488_11 + "-col-" + i; // Remove the style rule for this column

          var tr = qx.ui.progressive.renderer.table.Row;
          qx.bom.Stylesheet.removeRule(tr.__clazz__P_488_7[this.__hash__P_488_11].cellstylesheet[i], stylesheet); // Get this column width.

          width = columnData[i].getComputedWidth();
          {
            if (qx.core.Environment.get("qx.tableResizeDebug")) {
              this.debug("col " + i + ": width=" + width);
            }
          } // Make our width calculations box-model independent

          var inset;

          if (qx.core.Environment.get("css.boxmodel") == "content") {
            inset = qx.ui.progressive.renderer.table.Row.__padding__P_488_8 * 2;
          } else {
            inset = -1;
          } // Create the new rule, based on calculated widths


          var widthRule = width - inset + "px;";
          var paddingRule = "0px " + qx.ui.progressive.renderer.table.Row.__padding__P_488_8 + "px " + "0px " + qx.ui.progressive.renderer.table.Row.__padding__P_488_8 + "px;";
          var leftRule = left + "px;";
          var rule = tr.__tableCellStyleSheet__P_488_9 + "width: " + widthRule + "left: " + leftRule + "padding: " + paddingRule; // Apply the new rule

          qx.bom.Stylesheet.addRule(tr.__clazz__P_488_7[this.__hash__P_488_11].cellstylesheet[i], stylesheet, rule);
        }
      }
    },
    destruct: function destruct() {
      // remove dynamic theme listener
      qx.theme.manager.Meta.getInstance().removeListener("changeTheme", this.__linkColors__P_488_5, this);
      var name;

      for (name in this.__renderers__P_488_1) {
        this.__renderers__P_488_1[name] = null;
      } // Remove any style sheets that we had added


      var tr = qx.ui.progressive.renderer.table.Row;

      var hash = this.__progressive__P_488_3.toHashCode();

      if (tr.__clazz__P_488_7 && tr.__clazz__P_488_7[hash]) {
        // Remove the row stylesheet
        if (tr.__clazz__P_488_7[hash].rowstylesheet) {
          // Get the style sheet rule name for this row
          var stylesheet = ".qx-progressive-" + this.__hash__P_488_11 + "-row"; // Remove the style rule for this row

          var tr = qx.ui.progressive.renderer.table.Row;
          qx.bom.Stylesheet.removeRule(tr.__clazz__P_488_7[this.__hash__P_488_11].rowstylesheet, stylesheet);
        } // Remove each of the column style sheets


        if (tr.__clazz__P_488_7[hash].cellstylesheet) {
          for (var i = tr.__clazz__P_488_7[hash].cellstylesheet.length - 1; i >= 0; i--) {
            // Get the style sheet rule name for this cell
            var stylesheet = ".qx-progressive-" + this.__hash__P_488_11 + "-col-" + i;
            var rule = tr.__clazz__P_488_7[this.__hash__P_488_11].cellstylesheet[i]; // Remove the style rule for this column

            var tr = qx.ui.progressive.renderer.table.Row;
            qx.bom.Stylesheet.removeRule(rule, stylesheet);
          }
        }
      }

      if (this.__progressive__P_488_3 && this.__progressive__P_488_3.getRendererData) {
        var rendererData = this.__progressive__P_488_3.getRendererData();

        if (rendererData && rendererData[this.__name__P_488_10] && rendererData[this.__name__P_488_10].end !== undefined) {
          rendererData[this.__name__P_488_10] = null;
        }
      }

      this.__colors__P_488_4 = this.__renderers__P_488_1 = this.__progressive__P_488_3 = this.__columnWidths__P_488_0 = null;

      this._disposeObjects("__layout__P_488_6", "__defaultCellRenderer__P_488_2", "__columnData__P_488_12");
    }
  });
  qx.ui.progressive.renderer.table.Row.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Cell Renderer for Progressive's Table.
   *
   * Many of the methods in this class accept a parameter called cellInfo.  This
   * parameter is an object with the following members:
   *
   * <dl>
   *   <dt>
   *     state
   *   </dt>
   *   <dd>
   *     The {@link qx.ui.progressive.State} object pertaining to this rendering
   *     session.
   *   </dd>
   *
   *   <dt>
   *     rowDiv
   *   </dt>
   *   <dd>
   *     The "div" DOM element of the row in which this cell is to be added.
   *   </dd>
   *
   *   <dt>
   *     element
   *   </dt>
   *   <dd>
   *     The entire element object returned by the data model.
   *   </dd>
   *
   *   <dt>
   *     dataIndex
   *   </dt>
   *   <dd>
   *     The index into the data element provided by the data model.
   *     Effectively, this is the column number.
   *   </dd>
   *
   *   <dt>
   *     cellData
   *   </dt>
   *   <dd>
   *     The data from the data model, to be rendered.  This the specific column
   *     data for the column being rendered, and is a shorthand for
   *     element.data[element.dataIndex].
   *   </dd>
   *
   *   <dt>
   *     height <span style="color:red;">Input/Output parameter!</span>
   *   </dt>
   *   <dd>
   *     On input to a cell renderer, this contains the height, as determined to
   *     date, for the current row.  The first column being rendered will
   *     receive a height of zero.  Upon return, it may leave the height at
   *     zero, meaning that it will accept any minimum height, or may specify a
   *     minimum height by setting this member.  Subsequent column cell renderers
   *     will receive the maximum height specified by any previous cell
   *     renderer.  Upon completion of calling each of the cell renderers for a
   *     row, the row height will be set to the value found in this member.
   *   </dd>
   * </dl>
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Abstract", {
    type: "abstract",
    extend: qx.core.Object,
    members: {
      /**
       * Retrieve any style characteristics the cell renderer wants applied to
       * this cell.
       *
       * @param cellInfo {Object}
       *   See {@link qx.ui.progressive.renderer.table.cell.Abstract} class
       *   description for details
       *
       * @return {String}
       *   The style characteristics to be applied to this cell.
       */
      _getCellStyle: function _getCellStyle(cellInfo) {
        return "";
      },

      /**
       * Retrieve any extra attributes the cell renderer wants applied to this
       * cell.  Extra attributes could be such things as
       * "onclick='handleClick()';"
       *
       * @param cellInfo {Object}
       *   See {@link qx.ui.progressive.renderer.table.cell.Abstract} class
       *   description for details
       *
       * @return {String}
       *   The extra attributes to be applied to this cell.
       */
      _getCellExtras: function _getCellExtras(cellInfo) {
        return "";
      },

      /**
       * Retrieve the HTML content to be added to the cell div.
       *
       * @param cellInfo {Object}
       *   See {@link qx.ui.progressive.renderer.table.cell.Abstract} class
       *   description for details
       *
       * @return {String}
       *   The HTML content to be added to the cell div.
       */
      _getContentHtml: function _getContentHtml(cellInfo) {
        return cellInfo.cellData || "";
      },

      /**
       * Given the provided cell information, generate the HTML for this
       * cell.
       *
       * @param cellInfo {Object}
       *   See {@link qx.ui.progressive.renderer.table.cell.Abstract} class
       *   description for details
       *
       * @return {String}
       *   The HTML required to create this cell.
       */
      render: function render(cellInfo) {
        var html = [];

        var style = this._getCellStyle(cellInfo); // Render this cell


        html.push("<div ", "class='", cellInfo.stylesheet, "' ");

        if (style) {
          html.push("style='", style, "'");
        }

        html.push(this._getCellExtras(cellInfo), ">", this._getContentHtml(cellInfo), "</div>");
        return html.join("");
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.bom.String": {},
      "qx.ui.progressive.renderer.table.Row": {},
      "qx.util.format.NumberFormat": {},
      "qx.util.format.DateFormat": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Renderer for Progressive.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Default", {
    extend: qx.ui.progressive.renderer.table.cell.Abstract,

    /**
     */
    construct: function construct() {
      qx.ui.progressive.renderer.table.cell.Abstract.constructor.call(this);
    },
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        return qx.bom.String.escape(this._formatValue(cellInfo.cellData));
      },

      /**
       * Formats a value in a reasonably predictable fashion.
       *
       *
       * @param value {var}
       *   The value to be formatted
       *
       * @return {String}
       * <ul>
       *   <li>
       *     Numbers are formatted with two fractional digits.
       *   </li>
       *   <li>
       *     Dates are formatted in the default format of
       *     {@link qx.util.format.DateFormat}.
       *   </li>
       *   <li>
       *     Any type not otherwise handled, including String values, are
       *     simply returned unaltered.
       *   </li>
       * </ul>
       */
      _formatValue: function _formatValue(value) {
        var ret;

        if (value == null) {
          return "";
        }

        if (typeof value == "string") {
          return value;
        } else if (typeof value == "number") {
          if (!qx.ui.progressive.renderer.table.Row._numberFormat) {
            var numberFormat = new qx.util.format.NumberFormat();
            numberFormat.setMaximumFractionDigits(2);
            qx.ui.progressive.renderer.table.Row._numberFormat = numberFormat;
          }

          ret = qx.ui.progressive.renderer.table.Row._numberFormat.format(value);
        } else if (value instanceof Date) {
          ret = qx.util.format.DateFormat.getDateInstance().format(value);
        } else {
          ret = value;
        }

        return ret;
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.util.format.IFormat": {
        "require": true
      },
      "qx.core.IDisposable": {
        "require": true
      },
      "qx.lang.Type": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.locale.Number": {},
      "qx.lang.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A formatter and parser for numbers.
   * 
   * NOTE: Instances of this class must be disposed of after use
   *
   */
  qx.Class.define("qx.util.format.NumberFormat", {
    extend: qx.core.Object,
    implement: [qx.util.format.IFormat, qx.core.IDisposable],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param locale {String} optional locale to be used
     * @throws {Error} If the argument is not a string.
     */
    construct: function construct(locale) {
      qx.core.Object.constructor.call(this);

      if (arguments.length > 0) {
        if (arguments.length === 1) {
          if (qx.lang.Type.isString(locale)) {
            this.setLocale(locale);
          } else {
            throw new Error("Wrong argument type. String is expected.");
          }
        } else {
          throw new Error("Wrong number of arguments.");
        }
      }

      if (!locale) {
        this.setLocale(qx.locale.Manager.getInstance().getLocale());
        {
          qx.locale.Manager.getInstance().bind("locale", this, "locale");
        }
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The minimum number of integer digits (digits before the decimal separator).
       * Missing digits will be filled up with 0 ("19" -> "0019").
       */
      minimumIntegerDigits: {
        check: "Number",
        init: 0
      },

      /**
       * The maximum number of integer digits (superfluous digits will be cut off
       * ("1923" -> "23").
       */
      maximumIntegerDigits: {
        check: "Number",
        nullable: true
      },

      /**
       * The minimum number of fraction digits (digits after the decimal separator).
       * Missing digits will be filled up with 0 ("1.5" -> "1.500")
       */
      minimumFractionDigits: {
        check: "Number",
        init: 0
      },

      /**
       * The maximum number of fraction digits (digits after the decimal separator).
       * Superfluous digits will cause rounding ("1.8277" -> "1.83")
       */
      maximumFractionDigits: {
        check: "Number",
        nullable: true
      },

      /** Whether thousand groupings should be used {e.g. "1,432,234.65"}. */
      groupingUsed: {
        check: "Boolean",
        init: true
      },

      /** The prefix to put before the number {"EUR " -> "EUR 12.31"}. */
      prefix: {
        check: "String",
        init: "",
        event: "changeNumberFormat"
      },

      /** Sets the postfix to put after the number {" %" -> "56.13 %"}. */
      postfix: {
        check: "String",
        init: "",
        event: "changeNumberFormat"
      },

      /** Locale used */
      locale: {
        check: "String",
        init: null,
        event: "changeLocale"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Formats a number.
       *
       * @param num {Number} the number to format.
       * @return {String} the formatted number as a string.
       */
      format: function format(num) {
        // handle special cases
        if (isNaN(num)) {
          return "NaN";
        }

        switch (num) {
          case Infinity:
            return "Infinity";

          case -Infinity:
            return "-Infinity";
        }

        var negative = num < 0;

        if (negative) {
          num = -num;
        }

        if (this.getMaximumFractionDigits() != null) {
          // Do the rounding
          var mover = Math.pow(10, this.getMaximumFractionDigits());
          num = Math.round(num * mover) / mover;
        }

        var integerDigits = String(Math.floor(num)).length;
        var numStr = "" + num; // Prepare the integer part

        var integerStr = numStr.substring(0, integerDigits);

        while (integerStr.length < this.getMinimumIntegerDigits()) {
          integerStr = "0" + integerStr;
        }

        if (this.getMaximumIntegerDigits() != null && integerStr.length > this.getMaximumIntegerDigits()) {
          // NOTE: We cut off even though we did rounding before, because there
          //     may be rounding errors ("12.24000000000001" -> "12.24")
          integerStr = integerStr.substring(integerStr.length - this.getMaximumIntegerDigits());
        } // Prepare the fraction part


        var fractionStr = numStr.substring(integerDigits + 1);

        while (fractionStr.length < this.getMinimumFractionDigits()) {
          fractionStr += "0";
        }

        if (this.getMaximumFractionDigits() != null && fractionStr.length > this.getMaximumFractionDigits()) {
          // We have already rounded -> Just cut off the rest
          fractionStr = fractionStr.substring(0, this.getMaximumFractionDigits());
        } // Add the thousand groupings


        if (this.getGroupingUsed()) {
          var origIntegerStr = integerStr;
          integerStr = "";
          var groupPos;

          for (groupPos = origIntegerStr.length; groupPos > 3; groupPos -= 3) {
            integerStr = "" + qx.locale.Number.getGroupSeparator(this.getLocale()) + origIntegerStr.substring(groupPos - 3, groupPos) + integerStr;
          }

          integerStr = origIntegerStr.substring(0, groupPos) + integerStr;
        } // Workaround: prefix and postfix are null even their defaultValue is "" and
        //             allowNull is set to false?!?


        var prefix = this.getPrefix() ? this.getPrefix() : "";
        var postfix = this.getPostfix() ? this.getPostfix() : ""; // Assemble the number

        var str = prefix + (negative ? "-" : "") + integerStr;

        if (fractionStr.length > 0) {
          str += "" + qx.locale.Number.getDecimalSeparator(this.getLocale()) + fractionStr;
        }

        str += postfix;
        return str;
      },

      /**
       * Parses a number.
       *
       * @param str {String} the string to parse.
       * @return {Double} the number.
       * @throws {Error} If the number string does not match the number format.
       */
      parse: function parse(str) {
        // use the escaped separators for regexp
        var groupSepEsc = qx.lang.String.escapeRegexpChars(qx.locale.Number.getGroupSeparator(this.getLocale()) + "");
        var decimalSepEsc = qx.lang.String.escapeRegexpChars(qx.locale.Number.getDecimalSeparator(this.getLocale()) + "");
        var regex = new RegExp("^(" + qx.lang.String.escapeRegexpChars(this.getPrefix()) + ')?([-+]){0,1}' + '([0-9]{1,3}(?:' + groupSepEsc + '{0,1}[0-9]{3}){0,}){0,1}' + '(' + decimalSepEsc + '\\d+){0,1}(' + qx.lang.String.escapeRegexpChars(this.getPostfix()) + ")?$");
        var hit = regex.exec(str);

        if (hit == null) {
          throw new Error("Number string '" + str + "' does not match the number format");
        } // hit[1] = potential prefix


        var negative = hit[2] == "-";
        var integerStr = hit[3] || "0";
        var fractionStr = hit[4]; // hit[5] = potential postfix
        // Remove the thousand groupings

        integerStr = integerStr.replace(new RegExp(groupSepEsc, "g"), "");
        var asStr = (negative ? "-" : "") + integerStr;

        if (fractionStr != null && fractionStr.length != 0) {
          // Remove the leading decimal separator from the fractions string
          fractionStr = fractionStr.replace(new RegExp(decimalSepEsc), "");
          asStr += "." + fractionStr;
        }

        return parseFloat(asStr);
      }
    },
    destruct: function destruct() {
      {
        qx.locale.Manager.getInstance().removeRelatedBindings(this);
      }
    }
  });
  qx.util.format.NumberFormat.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.ColumnData": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Column width array for a whole set of columns
   */
  qx.Class.define("qx.ui.progressive.renderer.table.Widths", {
    extend: qx.core.Object,

    /**
     * @param numColumns {Integer}
     *   The number of columns being used.
     */
    construct: function construct(numColumns) {
      qx.core.Object.constructor.call(this); // Create an array of the specified number of columns, and use the default
      // column data.

      this.__columnData__P_489_0 = [];

      for (var i = 0; i < numColumns; i++) {
        this.__columnData__P_489_0[i] = new qx.ui.core.ColumnData();
      }
    },
    members: {
      __columnData__P_489_0: null,

      /**
       * Get the array of column data.
       *
       * @return {Array}
       *   Array of column data
       *
       */
      getData: function getData() {
        return this.__columnData__P_489_0;
      },

      /**
       * Set the width, minimum width and/or maximum width of a column at one
       * time.
       *
       * @param column {Integer}
       *   The column number whose attributes are being set.
       *
       * @param map {Map}
       *   An object with any or all of the three members, "width", "minWidth",
       *   "maxWidth".  The property values are as described for {@link
       *   #setWidth}, {@link #setMinWidth} and {@link #setMaxWidth}
       *   respectively.
       *
       */
      set: function set(column, map) {
        for (var key in map) {
          switch (key) {
            case "width":
              this.setWidth(column, map[key]);
              break;

            case "minWidth":
              this.setMinWidth(column, map[key]);
              break;

            case "maxWidth":
              this.setMaxWidth(column, map[key]);
              break;

            default:
              throw new Error("Unrecognized key: " + key);
          }
        }
      },

      /**
       * Set the width of a column.
       *
       *
       * @param column {Integer} The column whose width is to be set
       *
       * @param width {Integer|String}
       *   The width of the specified column.  The width may be specified as
       *   integer number of pixels (e.g. 100), a string representing percentage
       *   of the inner width of the Table (e.g. "25%"), or a string
       *   representing a flex width (e.g. "1*").
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setWidth: function setWidth(column, width) {
        if (column > this.__columnData__P_489_0.length - 1 || column < 0) {
          throw new Error("Column number out of range");
        }

        this.__columnData__P_489_0[column].setColumnWidth(width);
      },

      /**
       * Set the minimum width of a column.
       *
       *
       * @param column {Integer}
       *   The column whose minimum width is to be set
       *
       * @param width {Integer}
       *   The minimum width of the specified column.
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setMinWidth: function setMinWidth(column, width) {
        if (column > this.__columnData__P_489_0.length - 1 || column < 0) {
          throw new Error("Column number out of range");
        }

        this.__columnData__P_489_0[column].setMinWidth(width);
      },

      /**
       * Set the maximum width of a column.
       *
       *
       * @param column {Integer}
       *   The column whose maximum width is to be set
       *
       * @param width {Integer}
       *   The maximum width of the specified column.
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setMaxWidth: function setMaxWidth(column, width) {
        if (column > this.__columnData__P_489_0.length - 1 || column < 0) {
          throw new Error("Column number out of range");
        }

        this.__columnData__P_489_0[column].setMaxWidth(width);
      }
    }
  });
  qx.ui.progressive.renderer.table.Widths.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      },
      "qx.util.ResourceManager": {
        "construct": true
      },
      "qx.bom.client.Css": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.alphaimageloaderneeded": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Abstract Icon cell renderer.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Icon", {
    type: "abstract",
    extend: qx.ui.progressive.renderer.table.cell.Abstract,

    /** Create a new instance of an Icon cell renderer */
    construct: function construct() {
      qx.ui.progressive.renderer.table.cell.Abstract.constructor.call(this);
      var aliasManager = qx.util.AliasManager.getInstance();
      var resourceManager = qx.util.ResourceManager.getInstance();
      var blankImg = aliasManager.resolve("qx/static/blank.gif");
      this.__imageBlank__P_492_0 = resourceManager.toUri(blankImg);
    },
    members: {
      /**
       * A blank image for use as a spacer in place of another image
       */
      __imageBlank__P_492_0: null,

      /**
       * Retrieve the URI for a blank image
       *
       * @return {String}
       *   The URI of the blank image.
       */
      getBlankImage: function getBlankImage() {
        return this.__imageBlank__P_492_0;
      },

      /**
       * Identify the image to be displayed in the cell.
       *
       * @param cellInfo {Map}
       *   Information about the cell being renderered, including:
       *   <ul>
       *     <li>state</li>
       *     <li>rowDiv</li>
       *     <li>stylesheet</li>
       *     <li>element</li>
       *     <li>dataIndex</li>
       *     <li>cellData</li>
       *     <li>height</li>
       *   </ul>
       *
       * @return {Map}
       *   The returned map should contain at least the <i>url</i> field, but
       *   may contain any others of these:
       *
       *   <dl>
       *     <dt>
       *       url
       *     </dt>
       *     <dd>
       *       The URL of the image to be displayed
       *     </dd>
       *
       *     <dt>
       *       imageWidth
       *     </dt>
       *     <dd>
       *       The width at which the image should be displayed
       *     </dd>
       *
       *     <dt>
       *       imageHeight
       *     </dt>
       *     <dd>
       *       The height at which the image should be displayed
       *     </dd>
       *
       *     <dt>
       *       extras
       *     </dt>
       *     <dd>
       *       Any extra attributes to be include in the 'image' tag.
       *     </dd>
       *   </dl>
       */
      _identifyImage: function _identifyImage(cellInfo) {
        throw new Error("_identifyImage() is abstract");
      },
      // overridden
      _getCellStyle: function _getCellStyle(cellInfo) {
        var ret = qx.ui.progressive.renderer.table.cell.Icon.prototype._getCellStyle.base.call(this, cellInfo) + "text-align:center;" + "vertical-align:middle;";
        return ret;
      },
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        var html = [];

        var imageData = this.__getImageData__P_492_1(cellInfo); // Start the image tag


        html.push('<img '); // Add magic to make png images work in IE

        if (qx.core.Environment.get("css.alphaimageloaderneeded") && /\.png$/i.test(imageData.url)) {
          html.push('src="', this.__imageBlank__P_492_0, '" style="filter:', "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='", imageData.url, "',sizingMethod='scale')", '" ');
        } else {
          html.push('src="', imageData.url, '" ');
        } // If image width is specified...


        if (imageData.imageWidth) {
          // ... then add it.
          html.push(" width='", imageData.imageWidth, "px'");
        } // If image height is specified...


        if (imageData.imageHeight) {
          // ... then add it.
          html.push(" height='", imageData.imageHeight, "px'");
        } // Move the image off of the top border


        html.push(" style='padding-top:2px;'"); // If a tooltip is specified...

        if (imageData.tooltip) {
          // ... then add it.
          html.push(" title='", imageData.tooltip, "'");
        } // If there are any extra parameters specified, add them now.


        if (imageData.extras) {
          html.push(imageData.extras);
        } // All done.


        html.push(">"); // Give 'em what they came for

        return html.join("");
      },

      /**
       * Obtain the image data (url, tooltip) that's appropriate for this cell
       *
       * @param cellInfo {Map}
       *   Information about the cell being renderered, including:
       *   <ul>
       *     <li>state</li>
       *     <li>rowDiv</li>
       *     <li>stylesheet</li>
       *     <li>element</li>
       *     <li>dataIndex</li>
       *     <li>cellData</li>
       *     <li>height</li>
       *   </ul>
       *
       * @return {Map}
       *   See {@link #_identifyImage}
       */
      __getImageData__P_492_1: function __getImageData__P_492_1(cellInfo) {
        // Query the subclass about image and tooltip
        var imageData = this._identifyImage(cellInfo); // If subclass refuses to give map, construct it


        if (imageData == null || typeof imageData == "string") {
          imageData = {
            url: imageData,
            tooltip: null
          };
        } // If subclass gave null as url, replace with url to empty image


        if (imageData.url == null) {
          imageData.url = this.__imageBlank__P_492_0;
        }

        return imageData;
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.Icon.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Icon": {
        "construct": true,
        "require": true
      },
      "qx.theme.manager.Meta": {
        "construct": true
      },
      "qx.util.AliasManager": {},
      "qx.util.ResourceManager": {},
      "qx.bom.client.Css": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.alphaimageloaderneeded": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Boolean Renderer.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Boolean", {
    extend: qx.ui.progressive.renderer.table.cell.Icon,
    construct: function construct() {
      qx.ui.progressive.renderer.table.cell.Icon.constructor.call(this);

      this.__resolveImages__P_490_0(); // dynamic theme switch


      {
        qx.theme.manager.Meta.getInstance().addListener("changeTheme", this.__resolveImages__P_490_0, this);
      }
    },
    properties: {
      /**
       * Whether to add code which will toggle the checkbox on/off.  (There is
       * not yet code here to generate an event when this occurs, so it's not
       * yet very useful.)
       */
      allowToggle: {
        check: "Boolean",
        init: false
      }
    },
    members: {
      __iconUrlTrue__P_490_1: null,
      __iconUrlFalse__P_490_2: null,
      __numericAllowed__P_490_3: null,
      __conditions__P_490_4: null,
      __defaultTextAlign__P_490_5: null,
      __defaultColor__P_490_6: null,
      __defaultFontStyle__P_490_7: null,
      __defaultFontWeight__P_490_8: null,

      /**
       * Resolve the boolean images using the alias and resource manager.
       */
      __resolveImages__P_490_0: function __resolveImages__P_490_0() {
        var aliasManager = qx.util.AliasManager.getInstance();
        var resourceManager = qx.util.ResourceManager.getInstance();
        var boolTrueImg = aliasManager.resolve("decoration/table/boolean-true.png");
        var boolFalseImg = aliasManager.resolve("decoration/table/boolean-false.png");
        this.__iconUrlTrue__P_490_1 = resourceManager.toUri(boolTrueImg);
        this.__iconUrlFalse__P_490_2 = resourceManager.toUri(boolFalseImg);
      },
      // overridden
      _identifyImage: function _identifyImage(cellInfo) {
        var imageData = {
          imageWidth: 11,
          imageHeight: 11
        };

        switch (cellInfo.cellData) {
          case true:
            imageData.url = this.__iconUrlTrue__P_490_1;
            imageData.extras = "celldata='1' ";
            break;

          case false:
            imageData.url = this.__iconUrlFalse__P_490_2;
            imageData.extras = "celldata='0' ";
            break;

          default:
            imageData.url = null;
            break;
        }

        if (this.getAllowToggle()) {
          // Toggle the boolean value if clicked
          imageData.extras += "onclick=\"var node = this.attributes.getNamedItem('celldata'); var value = node.nodeValue; var src; if (value == '0') {";

          if (qx.core.Environment.get("css.alphaimageloaderneeded") && /\.png$/i.test(this.__iconUrlTrue__P_490_1)) {
            imageData.extras += "  this.src='" + this.getBlankImage() + "'; " + "  var loader = 'DXImageTransform.Microsoft.AlphaImageLoader'; " + "  var filters = this.filters.item(loader); " + "  filters.src='" + this.__iconUrlTrue__P_490_1 + "'; " + "  filters.sizingMethod = 'scale'; ";
          } else {
            imageData.extras += "  this.src='" + this.__iconUrlTrue__P_490_1 + "'; ";
          }

          imageData.extras += "  node.nodeValue='1'; } else {";

          if (qx.core.Environment.get("css.alphaimageloaderneeded") && /\.png$/i.test(this.__iconUrlFalse__P_490_2)) {
            imageData.extras += "  this.src='" + this.getBlankImage() + "'; " + "  var loader = 'DXImageTransform.Microsoft.AlphaImageLoader'; " + "  var filters = this.filters.item(loader); " + "  filters.src='" + this.__iconUrlFalse__P_490_2 + "'; " + "  filters.sizingMethod = 'scale'; ";
          } else {
            imageData.extras += "  this.src='" + this.__iconUrlFalse__P_490_2 + "'; ";
          }

          imageData.extras += "  node.nodeValue='0'; }";
          imageData.extras += // IE doesn't allow setNamedItem() if not explicitly an "attribute"
          "try {   this.attributes.setNamedItem(node); } catch (e) {   var namedItem = document.createAttribute('celldata');   namedItem.value = node.nodeValue;   this.attributes.setNamedItem(namedItem); }\"";
        }

        return imageData;
      },
      // overridden
      _getCellStyle: function _getCellStyle(cellInfo) {
        var ret = qx.ui.progressive.renderer.table.cell.Boolean.prototype._getCellStyle.base.call(this, cellInfo);

        return ret;
      }
    },
    destruct: function destruct() {
      this.__iconUrlTrue__P_490_1 = this.__iconUrlFalse__P_490_2 = null; // remove dynamic theme listener

      {
        qx.theme.manager.Meta.getInstance().removeListener("changeTheme", this.__resolveImages__P_490_0, this);
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.Boolean.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Tartan Solutions, Inc, http://www.tartansolutions.com
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Dan Hummon
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Renderer for Progressive.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Conditional", {
    extend: qx.ui.progressive.renderer.table.cell.Abstract,

    /**
     * @param align {String}
     *   The default alignment to format the cell with if the condition matches.
     *
     * @param color {String}
     *   The default color to format the cell with if the condition matches.
     *
     * @param style {String}
     *   The default style to format the cell with if the condition matches.
     *
     * @param weight {String}
     *   The default weight to format the cell with if the condition matches.
     */
    construct: function construct(align, color, style, weight) {
      qx.ui.progressive.renderer.table.cell.Abstract.constructor.call(this);
      this.__numericAllowed__P_491_0 = ["==", "!=", ">", "<", ">=", "<="];
      this.__betweenAllowed__P_491_1 = ["between", "!between"];
      this.__conditions__P_491_2 = [];
      this.__defaultTextAlign__P_491_3 = align || "";
      this.__defaultColor__P_491_4 = color || "";
      this.__defaultFontStyle__P_491_5 = style || "";
      this.__defaultFontWeight__P_491_6 = weight || "";
    },
    members: {
      __numericAllowed__P_491_0: null,
      __betweenAllowed__P_491_1: null,
      __conditions__P_491_2: null,
      __defaultTextAlign__P_491_3: null,
      __defaultColor__P_491_4: null,
      __defaultFontStyle__P_491_5: null,
      __defaultFontWeight__P_491_6: null,

      /**
       * Applies the cell styles to the style map.
       *
       * @param condition {Array}
       *   The matched condition
       *
       * @param style {Map}
       *   map of already applied styles.
       */
      __applyFormatting__P_491_7: function __applyFormatting__P_491_7(condition, style) {
        if (condition.align) {
          style["text-align"] = condition.align;
        }

        if (condition.color) {
          style["color"] = condition.color;
        }

        if (condition.style) {
          style["font-style"] = condition.style;
        }

        if (condition.weight) {
          style["font-weight"] = condition.weight;
        }
      },

      /**
       * The addNumericCondition method is used to add a basic numeric condition
       * to the cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the
       * align, color, style and weight arguments. Null will allow pre-existing
       * formatting to pass through, where an empty string will clear it back to
       * the default formatting set in the constructor.
       *
       *
       *
       * @param condition {String}
       *   The type of condition. Accepted strings are "==", "!=", ">", "<",
       *   ">=", and "<=".
       *
       * @param value1 {Integer}
       *   The value to compare against.
       *
       * @param align {String}
       *   The alignment to format the cell with if the condition matches.
       *
       * @param color {String}
       *   The color to format the cell with if the condition matches.
       *
       * @param style {String}
       *   The style to format the cell with if the condition matches.
       *
       * @param weight {String}
       *   The weight to format the cell with if the condition matches.
       *
       * @param target {String}
       *   The text value of the column to compare against. If this is null,
       *   comparisons will be against the contents of this cell.
       *
       * @throws {Error} If the condition can not be recognized or the value
       * is null.
       */
      addNumericCondition: function addNumericCondition(condition, value1, align, color, style, weight, target) {
        if (!this.__numericAllowed__P_491_0.includes(condition) || value1 == null) {
          throw new Error("Condition not recognized or value is null!");
        }

        this.__conditions__P_491_2.push({
          condition: condition,
          align: align,
          color: color,
          style: style,
          weight: weight,
          value1: value1,
          target: target
        });
      },

      /**
       * The addBetweenCondition method is used to add a between condition to
       * the cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the
       * align, color, style and weight arguments. Null will allow pre-existing
       * formatting to pass through, where an empty string will clear it back to
       * the default formatting set in the constructor.
       *
       *
       *
       * @param condition {String}
       *   The type of condition. Accepted strings are "between" and "!between".
       *
       * @param value1 {Integer}
       *   The first value to compare against.
       *
       * @param value2 {Integer}
       *   The second value to compare against.
       *
       * @param align {String}
       *   The alignment to format the cell with if the condition matches.
       *
       * @param color {String}
       *   The color to format the cell with if the condition matches.
       *
       * @param style {String}
       *   The style to format the cell with if the condition matches.
       *
       * @param weight {String}
       *   The weight to format the cell with if the condition matches.
       *
       * @param target {String}
       *   The text value of the column to compare against. If this is null,
       *   comparisons will be against the contents of this cell.
       *
       *
       * @throws {Error} If the condition can not recognized or one of the
       * values is null.
       */
      addBetweenCondition: function addBetweenCondition(condition, value1, value2, align, color, style, weight, target) {
        if (!this.__betweenAllowed__P_491_1.includes(condition) || value1 == null || value2 == null) {
          throw new Error("Condition not recognized or value1/value2 is null!");
        }

        this.__conditions__P_491_2.push({
          condition: condition,
          align: align,
          color: color,
          style: style,
          weight: weight,
          value1: value1,
          value2: value2,
          target: target
        });
      },

      /**
       * The addRegex method is used to add a regular expression condition to
       * the cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the
       * align, color, style and weight arguments. Null will allow pre-existing
       * formatting to pass through, where an empty string will clear it back to
       * the default formatting set in the constructor.
       *
       *
       *
       * @param regex {String}
       *   The regular expression to match against.
       *
       * @param align {String}
       *   The alignment to format the cell with if the condition matches.
       *
       * @param color {String}
       *   The color to format the cell with if the condition matches.
       *
       * @param style {String}
       *   The style to format the cell with if the condition matches.
       *
       * @param weight {String}
       *   The weight to format the cell with if the condition matches.
       *
       * @param target {String}
       *   The text value of the column to compare against. If this is null,
       *   comparisons will be against the contents of this cell.
       *
       * @throws {Error} If the regex is null.
       */
      addRegex: function addRegex(regex, align, color, style, weight, target) {
        if (!regex) {
          throw new Error("regex cannot be null!");
        }

        this.__conditions__P_491_2.push({
          condition: "regex",
          align: align,
          color: color,
          style: style,
          weight: weight,
          regex: regex,
          target: target
        });
      },

      /**
       * Overridden; called whenever the cell updates. The cell will iterate
       * through each available condition and apply formatting for those that
       * match. Multiple conditions can match, but later conditions will
       * override earlier ones. Conditions with null values will stack with
       * other conditions that apply to that value.
       *
       *
       * @param cellInfo {Map}
       *   The information about the cell.  See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @return {String}
       */
      _getCellStyle: function _getCellStyle(cellInfo) {
        if (this.__conditions__P_491_2.length == 0) {
          return cellInfo.style || "";
        }

        var i;
        var bTestPassed;
        var compareValue;
        var style = {
          "text-align": this.__defaultTextAlign__P_491_3,
          "color": this.__defaultColor__P_491_4,
          "font-style": this.__defaultFontStyle__P_491_5,
          "font-weight": this.__defaultFontWeight__P_491_6
        };

        for (i = 0; i < this.__conditions__P_491_2.length; i++) {
          var test = this.__conditions__P_491_2[i];
          bTestPassed = false;

          if (this.__numericAllowed__P_491_0.includes(test.condition)) {
            if (test.target == null) {
              compareValue = cellInfo.cellData;
            } else {
              compareValue = cellInfo.element.data[test.target];
            }

            switch (test.condition) {
              case "==":
                if (compareValue == test.value1) {
                  bTestPassed = true;
                }

                break;

              case "!=":
                if (compareValue != test.value1) {
                  bTestPassed = true;
                }

                break;

              case ">":
                if (compareValue > test.value1) {
                  bTestPassed = true;
                }

                break;

              case "<":
                if (compareValue < test.value1) {
                  bTestPassed = true;
                }

                break;

              case ">=":
                if (compareValue >= test.value1) {
                  bTestPassed = true;
                }

                break;

              case "<=":
                if (compareValue <= test.value1) {
                  bTestPassed = true;
                }

                break;
            }
          } else if (this.__betweenAllowed__P_491_1.includes(test.condition)) {
            if (test.target == null) {
              compareValue = cellInfo.cellData;
            } else {
              compareValue = cellInfo.element.data[test.target];
            }

            switch (test.condition) {
              case "between":
                if (compareValue >= test.value1 && compareValue <= test.value2) {
                  bTestPassed = true;
                }

                break;

              case "!between":
                if (compareValue < test.value1 && compareValue > test.value2) {
                  bTestPassed = true;
                }

                break;
            }
          } else if (test.condition == "regex") {
            if (test.target == null) {
              compareValue = cellInfo.cellData;
            } else {
              compareValue = cellInfo.element.data[test.target];
            }

            var the_pattern = new RegExp(test.value1, 'g');
            bTestPassed = the_pattern.test(compareValue);
          } // Apply formatting, if any.


          if (bTestPassed) {
            this.__applyFormatting__P_491_7(test, style);
          }

          var styleString = [];

          for (var key in style) {
            if (style[key]) {
              styleString.push(key, ":", style[key], ";");
            }
          }
        }

        return styleString.join("");
      }
    },
    destruct: function destruct() {
      this.__numericAllowed__P_491_0 = this.__betweenAllowed__P_491_1 = this.__conditions__P_491_2 = null;
    }
  });
  qx.ui.progressive.renderer.table.cell.Conditional.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Abstract": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Html Renderer.
   *
   *  Renderer the specified HTML in the cell.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Html", {
    /*
     * Nothing specific to do here, as the Abstract class already does
     * everything we need.
     */
    extend: qx.ui.progressive.renderer.table.cell.Abstract
  });
  qx.ui.progressive.renderer.table.cell.Html.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Icon": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {},
      "qx.util.ResourceManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Tartan Solutions, Inc, http://www.tartansolutions.com
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Dan Hummon
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Boolean Renderer.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.Image", {
    extend: qx.ui.progressive.renderer.table.cell.Icon,

    /**
     * @param height {Integer ? 16}
     *   The height of the image. The default is 16.
     *
     * @param width {Integer ? 16}
     *   The width of the image. The default is 16.
     */
    construct: function construct(width, height) {
      qx.ui.progressive.renderer.table.cell.Icon.constructor.call(this);

      if (width === undefined) {
        this.__imageWidth__P_493_0 = width;
      } else {
        this.__imageWidth__P_493_0 = 16;
      }

      if (height === undefined) {
        this.__imageHeight__P_493_1 = height;
      } else {
        this.__imageHeight__P_493_1 = 16;
      }
    },
    members: {
      __imageWidth__P_493_0: null,
      __imageHeight__P_493_1: null,
      // overridden
      _identifyImage: function _identifyImage(cellInfo) {
        var imageData = {
          imageWidth: this.__imageWidth__P_493_0,
          imageHeight: this.__imageHeight__P_493_1
        };
        var height; // String data is the unresolved url for the image.
        // Object data is a map containing the url, tooltip, and a height

        if (typeof cellInfo.cellData == "string") {
          imageData.url = cellInfo.cellData;
        } else {
          imageData.url = cellInfo.cellData.url;
          imageData.tooltip = cellInfo.cellData.tooltip;
          height = cellInfo.cellData.height;
        }

        if (imageData.url == "") {
          imageData.url = this._imageBlank;
        } else {
          var aliasManager = qx.util.AliasManager.getInstance();
          var resourceManager = qx.util.ResourceManager.getInstance();
          var resolved = aliasManager.resolve(imageData.url);
          imageData.url = resourceManager.toUri(resolved);
        } // Adjust the row height, if necessary, to let this image fit


        if (height) {
          cellInfo.height = height;
        }

        return imageData;
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.progressive.renderer.table.cell.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Table Cell Renderer for Progressive.
   */
  qx.Class.define("qx.ui.progressive.renderer.table.cell.String", {
    extend: qx.ui.progressive.renderer.table.cell.Abstract,

    /**
     */
    construct: function construct() {
      qx.ui.progressive.renderer.table.cell.Abstract.constructor.call(this);
    },
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        return qx.bom.String.escape(cellInfo.cellData);
      }
    }
  });
  qx.ui.progressive.renderer.table.cell.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.event.handler.ElementResize": {
        "defer": "runtime"
      },
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.root.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MLayoutHandling": {
        "defer": "runtime",
        "require": true
      },
      "qx.ui.layout.Basic": {
        "construct": true
      },
      "qx.ui.core.queue.Layout": {
        "construct": true
      },
      "qx.ui.core.FocusHandler": {
        "construct": true
      },
      "qx.bom.client.Engine": {
        "construct": true
      },
      "qx.dom.Node": {
        "construct": true
      },
      "qx.event.Registration": {
        "construct": true,
        "defer": "runtime"
      },
      "qx.bom.element.Dimension": {},
      "qx.bom.element.Style": {},
      "qx.html.Root": {},
      "qx.event.Timer": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "construct": true,
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Alexander Steitz (aback)
  
  ************************************************************************ */

  /**
   * This classes could be used to insert qooxdoo islands into existing
   * web pages. You can use the isles to place any qooxdoo powered widgets
   * inside a layout made using traditional HTML markup and CSS.
   *
   * The size of the widget in each dimension can either be determined by the
   * size hint of the inline's children or by the size of the root DOM element. If
   * <code>dynamicX</code>/<code>dynamicY</code> is true the width/height of the DOM
   * element is used.
   *
   * This class uses {@link qx.ui.layout.Basic} as default layout. The layout
   * can be changed using the {@link #setLayout} method.
   *
   * To position popups and tooltips please have a look at {@link qx.ui.root.Page}.
   *
   * @use(qx.event.handler.ElementResize)
   * @ignore(qx.ui.popup, qx.ui.popup.Manager.*)
   * @ignore(qx.ui.menu, qx.ui.menu.Manager.*)
   */
  qx.Class.define("qx.ui.root.Inline", {
    extend: qx.ui.root.Abstract,
    include: [qx.ui.core.MLayoutHandling],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param el {Element} DOM element to use as isle for qooxdoo content. Please
     *    note that existing content gets removed on the first layout flush.
     * @param dynamicX {Boolean} If <code>true</code> the widget's width is
     *    determined by the DOM element's width. Otherwise the children's size hint
     *    is used.
     * @param dynamicY {Boolean} If <code>true</code> the widget's height is
     *    determined by the DOM element's height. Otherwise the children's size hint
     *    is used.
     */
    construct: function construct(el, dynamicX, dynamicY) {
      // check the parameter
      {
        this.assertElement(el, "Please use a DOM element to create an inline root.");
      } // Temporary storage of element to use

      this.__elem__P_498_0 = el; // Avoid any problems with dynamic resizing

      el.style.overflow = "hidden"; // Avoid any problems with broken layout

      el.style.textAlign = "left";
      this.__dynX__P_498_1 = dynamicX || false;
      this.__dynY__P_498_2 = dynamicY || false;

      this.__initDynamicMode__P_498_3();

      qx.ui.root.Abstract.constructor.call(this); // Use static layout

      this._setLayout(new qx.ui.layout.Basic()); // Directly schedule layout for root element


      qx.ui.core.queue.Layout.add(this); // Register as root

      qx.ui.core.FocusHandler.getInstance().connectTo(this); // Avoid the automatically scroll in to view.
      // See http://bugzilla.qooxdoo.org/show_bug.cgi?id=3236 for details.

      if (qx.core.Environment.get("engine.name") == "mshtml") {
        this.setKeepFocus(true);
      } // Resize handling for the window


      var window = qx.dom.Node.getWindow(el);
      qx.event.Registration.addListener(window, "resize", this._onWindowResize, this); // quick fix for [BUG #7680]

      this.getContentElement().setStyle("-webkit-backface-visibility", "hidden");
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __dynX__P_498_1: false,
      __dynY__P_498_2: false,
      __elem__P_498_0: null,

      /**
       * Performs several checks for dynamic mode and adds the "resize" listener
       */
      __initDynamicMode__P_498_3: function __initDynamicMode__P_498_3() {
        if (this.__dynX__P_498_1 || this.__dynY__P_498_2) {
          // Check the DOM element for an usable width and height
          var elementDimensions = qx.bom.element.Dimension.getSize(this.__elem__P_498_0);

          if (this.__dynX__P_498_1 && elementDimensions.width < 1) {
            throw new Error("The root element " + this.__elem__P_498_0 + " of " + this + " needs a width when its width size should be used!");
          }

          if (this.__dynY__P_498_2) {
            if (elementDimensions.height < 1) {
              throw new Error("The root element " + this.__elem__P_498_0 + " of " + this + " needs a height when its height size should be used!");
            } // check for implicit height. Set the height explicit to prevent that
            // the element grows indefinitely


            if (elementDimensions.height >= 1 && qx.bom.element.Style.get(this.__elem__P_498_0, "height", 3) == "") {
              qx.bom.element.Style.set(this.__elem__P_498_0, "height", elementDimensions.height + "px");
            }
          }

          qx.event.Registration.addListener(this.__elem__P_498_0, "resize", this._onResize, this);
        }
      },
      // overridden
      _createContentElement: function _createContentElement() {
        var el = this.__elem__P_498_0;

        if (this.__dynX__P_498_1 || this.__dynY__P_498_2) {
          var rootEl = document.createElement("div");
          el.appendChild(rootEl);
        } else {
          rootEl = el;
        }

        var root = new qx.html.Root(rootEl); // Make relative

        rootEl.style.position = "relative"; // Store reference to the widget in the DOM element.

        root.connectWidget(this); // fire event asynchronously, otherwise the browser will fire the event
        // too early and no listener will be informed since they're not added
        // at this time

        qx.event.Timer.once(function (e) {
          this.fireEvent("appear");
        }, this, 0);
        return root;
      },

      /**
       * Listener for the element's resize event
       *
       * @param e {qx.event.type.Event} Event object
       */
      _onResize: function _onResize(e) {
        var data = e.getData();

        if (data.oldWidth !== data.width && this.__dynX__P_498_1 || data.oldHeight !== data.height && this.__dynY__P_498_2) {
          qx.ui.core.queue.Layout.add(this);
        }
      },

      /**
       * Listener for the window's resize event.
       */
      _onWindowResize: function _onWindowResize() {
        // close all popups
        if (qx.ui.popup && qx.ui.popup.Manager) {
          qx.ui.popup.Manager.getInstance().hideAll();
        } // close all menus


        if (qx.ui.menu && qx.ui.menu.Manager) {
          qx.ui.menu.Manager.getInstance().hideAll();
        }
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var dynX = this.__dynX__P_498_1;
        var dynY = this.__dynY__P_498_2;

        if (!dynX || !dynY) {
          var hint = qx.ui.root.Inline.prototype._computeSizeHint.base.call(this);
        } else {
          hint = {};
        }

        var Dimension = qx.bom.element.Dimension;

        if (dynX) {
          var width = Dimension.getContentWidth(this.__elem__P_498_0);
          hint.width = width;
          hint.minWidth = width;
          hint.maxWidth = width;
        }

        if (dynY) {
          var height = Dimension.getContentHeight(this.__elem__P_498_0);
          hint.height = height;
          hint.minHeight = height;
          hint.maxHeight = height;
        }

        return hint;
      }
    },

    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer: function defer(statics, members) {
      qx.ui.core.MLayoutHandling.remap(members);
    },

    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct: function destruct() {
      qx.event.Registration.removeListener(this.__elem__P_498_0, "resize", this._onResize, this);
      this.__elem__P_498_0 = null;
    }
  });
  qx.ui.root.Inline.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.html.Element": {
        "construct": true,
        "require": true
      },
      "qx.bom.client.Engine": {
        "construct": true
      },
      "qx.util.ResourceManager": {
        "construct": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "construct": true,
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************ */

  /**
   * A special blocker element for the splitpane which is based on
   * {@link qx.html.Element} and takes care of the positioning of the div.
   *
   * @internal
   * @asset(qx/static/blank.gif)
   */
  qx.Class.define("qx.ui.splitpane.Blocker", {
    extend: qx.html.Element,

    /**
     * @param orientation {String} The orientation of the split pane control.
     */
    construct: function construct(orientation) {
      var styles = {
        position: "absolute",
        zIndex: 11
      }; // IE needs some extra love here to convince it to block events.

      if (qx.core.Environment.get("engine.name") == "mshtml") {
        styles.backgroundImage = "url(" + qx.util.ResourceManager.getInstance().toUri("qx/static/blank.gif") + ")";
        styles.backgroundRepeat = "repeat";
      }

      qx.html.Element.constructor.call(this, "div", styles); // Initialize orientation

      if (orientation) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      }
    },
    properties: {
      /**
       * The orientation of the blocker which should be the same as the
       * orientation of the splitpane.
       */
      orientation: {
        init: "horizontal",
        check: ["horizontal", "vertical"],
        apply: "_applyOrientation"
      }
    },
    members: {
      // property apply
      _applyOrientation: function _applyOrientation(value, old) {
        if (value == "horizontal") {
          this.setStyle("height", "100%");
          this.setStyle("cursor", "col-resize");
          this.setStyle("top", null);
        } else {
          this.setStyle("width", "100%");
          this.setStyle("left", null);
          this.setStyle("cursor", "row-resize");
        }
      },

      /**
       * Takes the two parameters and set the propper width of the blocker.
       *
       * @param offset {Number} The offset of the splitpane.
       * @param spliterSize {Number} The width of the splitter.
       */
      setWidth: function setWidth(offset, spliterSize) {
        var width = spliterSize + 2 * offset;
        this.setStyle("width", width + "px");
      },

      /**
       * Takes the two parameter and sets the propper height of the blocker.
       *
       * @param offset {Number} The offset of the splitpane.
       * @param spliterSize {Number} The height of the splitter.
       */
      setHeight: function setHeight(offset, spliterSize) {
        var height = spliterSize + 2 * offset;
        this.setStyle("height", height + "px");
      },

      /**
       * Takes the two parameter and sets the propper left position of
       * the blocker.
       *
       * @param offset {Number} The offset of the splitpane.
       * @param splitterLeft {Number} The left position of the splitter.
       */
      setLeft: function setLeft(offset, splitterLeft) {
        var left = splitterLeft - offset;
        this.setStyle("left", left + "px");
      },

      /**
       * Takes the two parameter and sets the propper top position of
       * the blocker.
       *
       * @param offset {Number} The offset of the splitpane.
       * @param splitterTop {Number} The top position of the splitter.
       */
      setTop: function setTop(offset, splitterTop) {
        var top = splitterTop - offset;
        this.setStyle("top", top + "px");
      }
    }
  });
  qx.ui.splitpane.Blocker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "require": true
      },
      "qx.ui.layout.Util": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Layouter for horizontal split panes.
   *
   * @internal
   */
  qx.Class.define("qx.ui.splitpane.HLayout", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        this.assert(name === "type" || name === "flex", "The property '" + name + "' is not supported by the split layout!");

        if (name == "flex") {
          this.assertNumber(value);
        }

        if (name == "type") {
          this.assertString(value);
        }
      },
      // overridden
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        var children = this._getLayoutChildren();

        var length = children.length;
        var child, type;
        var begin, splitter, slider, end;
        var paddingLeft = padding.left || 0;
        var paddingTop = padding.top || 0;

        for (var i = 0; i < length; i++) {
          child = children[i];
          type = child.getLayoutProperties().type;

          if (type === "splitter") {
            splitter = child;
          } else if (type === "slider") {
            slider = child;
          } else if (!begin) {
            begin = child;
          } else {
            end = child;
          }
        }

        if (begin && end) {
          var beginFlex = begin.getLayoutProperties().flex;
          var endFlex = end.getLayoutProperties().flex;

          if (beginFlex == null) {
            beginFlex = 1;
          }

          if (endFlex == null) {
            endFlex = 1;
          }

          var beginHint = begin.getSizeHint();
          var splitterHint = splitter.getSizeHint();
          var endHint = end.getSizeHint();
          var beginWidth = beginHint.width;
          var splitterWidth = splitterHint.width;
          var endWidth = endHint.width;

          if (beginFlex > 0 && endFlex > 0) {
            var flexSum = beginFlex + endFlex;
            var flexAvailable = availWidth - splitterWidth;
            var beginWidth = Math.round(flexAvailable / flexSum * beginFlex);
            var endWidth = flexAvailable - beginWidth;
            var sizes = qx.ui.layout.Util.arrangeIdeals(beginHint.minWidth, beginWidth, beginHint.maxWidth, endHint.minWidth, endWidth, endHint.maxWidth);
            beginWidth = sizes.begin;
            endWidth = sizes.end;
          } else if (beginFlex > 0) {
            beginWidth = availWidth - splitterWidth - endWidth;

            if (beginWidth < beginHint.minWidth) {
              beginWidth = beginHint.minWidth;
            }

            if (beginWidth > beginHint.maxWidth) {
              beginWidth = beginHint.maxWidth;
            }
          } else if (endFlex > 0) {
            endWidth = availWidth - beginWidth - splitterWidth;

            if (endWidth < endHint.minWidth) {
              endWidth = endHint.minWidth;
            }

            if (endWidth > endHint.maxWidth) {
              endWidth = endHint.maxWidth;
            }
          }

          begin.renderLayout(paddingLeft, paddingTop, beginWidth, availHeight);
          splitter.renderLayout(beginWidth + paddingLeft, paddingTop, splitterWidth, availHeight);
          end.renderLayout(beginWidth + splitterWidth + paddingLeft, paddingTop, endWidth, availHeight);
        } else {
          // Hide the splitter completely
          splitter.renderLayout(0, 0, 0, 0); // Render one child

          if (begin) {
            begin.renderLayout(paddingLeft, paddingTop, availWidth, availHeight);
          } else if (end) {
            end.renderLayout(paddingLeft, paddingTop, availWidth, availHeight);
          }
        }
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var children = this._getLayoutChildren();

        var length = children.length;
        var child, hint, props;
        var minWidth = 0,
            width = 0,
            maxWidth = 0;
        var minHeight = 0,
            height = 0,
            maxHeight = 0;

        for (var i = 0; i < length; i++) {
          child = children[i];
          props = child.getLayoutProperties(); // The slider is not relevant for auto sizing

          if (props.type === "slider") {
            continue;
          }

          hint = child.getSizeHint();
          minWidth += hint.minWidth;
          width += hint.width;
          maxWidth += hint.maxWidth;

          if (hint.minHeight > minHeight) {
            minHeight = hint.minHeight;
          }

          if (hint.height > height) {
            height = hint.height;
          }

          if (hint.maxHeight > maxHeight) {
            maxHeight = hint.maxHeight;
          }
        }

        return {
          minWidth: minWidth,
          width: width,
          maxWidth: maxWidth,
          minHeight: minHeight,
          height: height,
          maxHeight: maxHeight
        };
      }
    }
  });
  qx.ui.splitpane.HLayout.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.splitpane.Slider": {},
      "qx.ui.splitpane.Splitter": {},
      "qx.ui.splitpane.Blocker": {},
      "qx.ui.splitpane.VLayout": {},
      "qx.ui.splitpane.HLayout": {},
      "qx.ui.core.queue.Manager": {},
      "qx.bom.element.Location": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A split panes divides an area into two panes. The ratio between the two
   * panes is configurable by the user using the splitter.
   *
   * @childControl slider {qx.ui.splitpane.Slider} shown during resizing the splitpane
   * @childControl splitter {qx.ui.splitpane.Splitter} splitter to resize the splitpane
   */
  qx.Class.define("qx.ui.splitpane.Pane", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Creates a new instance of a SplitPane. It allows the user to dynamically
     * resize the areas dropping the border between.
     *
     * @param orientation {String} The orientation of the split pane control.
     * Allowed values are "horizontal" (default) and "vertical".
     */
    construct: function construct(orientation) {
      qx.ui.core.Widget.constructor.call(this);
      this.__children__P_500_0 = []; // Initialize orientation

      if (orientation) {
        this.setOrientation(orientation);
      } else {
        this.initOrientation();
      } // add all pointer listener to the blocker


      this.__blocker__P_500_1.addListener("pointerdown", this._onPointerDown, this);

      this.__blocker__P_500_1.addListener("pointerup", this._onPointerUp, this);

      this.__blocker__P_500_1.addListener("pointermove", this._onPointerMove, this);

      this.__blocker__P_500_1.addListener("pointerout", this._onPointerOut, this);

      this.__blocker__P_500_1.addListener("losecapture", this._onPointerUp, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "splitpane"
      },

      /**
       * Distance between pointer and splitter when the cursor should change
       * and enable resizing.
       */
      offset: {
        check: "Integer",
        init: 6,
        apply: "_applyOffset"
      },

      /**
       * The orientation of the splitpane control.
       */
      orientation: {
        init: "horizontal",
        check: ["horizontal", "vertical"],
        apply: "_applyOrientation"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __splitterOffset__P_500_2: null,
      __activeDragSession__P_500_3: false,
      __lastPointerX__P_500_4: null,
      __lastPointerY__P_500_5: null,
      __isHorizontal__P_500_6: null,
      __beginSize__P_500_7: null,
      __endSize__P_500_8: null,
      __children__P_500_0: null,
      __blocker__P_500_1: null,
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          // Create and add slider
          case "slider":
            control = new qx.ui.splitpane.Slider(this);
            control.exclude();

            this._add(control, {
              type: id
            });

            break;
          // Create splitter

          case "splitter":
            control = new qx.ui.splitpane.Splitter(this);

            this._add(control, {
              type: id
            });

            control.addListener("move", this.__onSplitterMove__P_500_9, this);
            break;
        }

        return control || qx.ui.splitpane.Pane.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Move handler for the splitter which takes care of the external
       * triggered resize of children.
       *
       * @param e {qx.event.type.Data} The data even of move.
       */
      __onSplitterMove__P_500_9: function __onSplitterMove__P_500_9(e) {
        this.__setBlockerPosition__P_500_10(e.getData());
      },

      /**
       * Creates a blocker for the splitter which takes all bouse events and
       * also handles the offset and cursor.
       *
       * @param orientation {String} The orientation of the pane.
       */
      __createBlocker__P_500_11: function __createBlocker__P_500_11(orientation) {
        this.__blocker__P_500_1 = new qx.ui.splitpane.Blocker(orientation);
        this.getContentElement().add(this.__blocker__P_500_1);
        var splitter = this.getChildControl("splitter");
        var splitterWidth = splitter.getWidth();

        if (!splitterWidth) {
          splitter.addListenerOnce("appear", function () {
            this.__setBlockerPosition__P_500_10();
          }, this);
        } // resize listener to remove the blocker in case the splitter
        // is removed.


        splitter.addListener("resize", function (e) {
          var bounds = e.getData();

          if (this.getChildControl("splitter").isKnobVisible() && (bounds.height == 0 || bounds.width == 0)) {
            this.__blocker__P_500_1.hide();
          } else {
            this.__blocker__P_500_1.show();
          }
        }, this);
      },

      /**
       * Returns the blocker used over the splitter. this could be used for
       * adding event listeners like tap or dbltap.
       *
       * @return {qx.ui.splitpane.Blocker} The used blocker element.
       *
       * @internal
       */
      getBlocker: function getBlocker() {
        return this.__blocker__P_500_1;
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Apply routine for the orientation property.
       *
       * Sets the pane's layout to vertical or horizontal split layout.
       *
       * @param value {String} The new value of the orientation property
       * @param old {String} The old value of the orientation property
       */
      _applyOrientation: function _applyOrientation(value, old) {
        var slider = this.getChildControl("slider");
        var splitter = this.getChildControl("splitter"); // Store boolean flag for faster access

        this.__isHorizontal__P_500_6 = value === "horizontal";

        if (!this.__blocker__P_500_1) {
          this.__createBlocker__P_500_11(value);
        } // update the blocker


        this.__blocker__P_500_1.setOrientation(value); // Dispose old layout


        var oldLayout = this._getLayout();

        if (oldLayout) {
          oldLayout.dispose();
        } // Create new layout


        var newLayout = value === "vertical" ? new qx.ui.splitpane.VLayout() : new qx.ui.splitpane.HLayout();

        this._setLayout(newLayout); // Update states for splitter and slider


        splitter.removeState(old);
        splitter.addState(value);
        splitter.getChildControl("knob").removeState(old);
        splitter.getChildControl("knob").addState(value);
        slider.removeState(old);
        slider.addState(value); // flush (needs to be done for the blocker update) and update the blocker

        qx.ui.core.queue.Manager.flush();

        this.__setBlockerPosition__P_500_10();
      },
      // property apply
      _applyOffset: function _applyOffset(value, old) {
        this.__setBlockerPosition__P_500_10();
      },

      /**
       * Helper for setting the blocker to the right position, which depends on
       * the offset, orientation and the current position of the splitter.
       *
       * @param bounds {Map?null} If the bounds of the splitter are known,
       *   they can be added.
       */
      __setBlockerPosition__P_500_10: function __setBlockerPosition__P_500_10(bounds) {
        var splitter = this.getChildControl("splitter");
        var offset = this.getOffset();
        var splitterBounds = splitter.getBounds();
        var splitterElem = splitter.getContentElement().getDomElement(); // do nothing if the splitter is not ready

        if (!splitterElem) {
          return;
        } // recalculate the dimensions of the blocker


        if (this.__isHorizontal__P_500_6) {
          // get the width either of the given bounds or of the read bounds
          var width = null;

          if (bounds) {
            width = bounds.width;
          } else if (splitterBounds) {
            width = splitterBounds.width;
          }

          var left = bounds && bounds.left;

          if (width || !this.getChildControl("splitter").isKnobVisible()) {
            if (isNaN(left)) {
              left = qx.bom.element.Location.getPosition(splitterElem).left;
            }

            this.__blocker__P_500_1.setWidth(offset, width || 6);

            this.__blocker__P_500_1.setLeft(offset, left);
          } // vertical case

        } else {
          // get the height either of the given bounds or of the read bounds
          var height = null;

          if (bounds) {
            height = bounds.height;
          } else if (splitterBounds) {
            height = splitterBounds.height;
          }

          var top = bounds && bounds.top;

          if (height || !this.getChildControl("splitter").isKnobVisible()) {
            if (isNaN(top)) {
              top = qx.bom.element.Location.getPosition(splitterElem).top;
            }

            this.__blocker__P_500_1.setHeight(offset, height || 6);

            this.__blocker__P_500_1.setTop(offset, top);
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Adds a widget to the pane.
       *
       * Sets the pane's layout to vertical or horizontal split layout. Depending on the
       * pane's layout the first widget will be the left or top widget, the second one
       * the bottom or right widget. Adding more than two widgets will overwrite the
       * existing ones.
       *
       * @param widget {qx.ui.core.Widget} The widget to be inserted into pane.
       * @param flex {Number} The (optional) layout property for the widget's flex value.
       */
      add: function add(widget, flex) {
        if (flex == null) {
          this._add(widget);
        } else {
          this._add(widget, {
            flex: flex
          });
        }

        this.__children__P_500_0.push(widget);
      },

      /**
       * Removes the given widget from the pane.
       *
       * @param widget {qx.ui.core.Widget} The widget to be removed.
       */
      remove: function remove(widget) {
        this._remove(widget);

        qx.lang.Array.remove(this.__children__P_500_0, widget);
      },

      /**
       * Returns an array containing the pane's content.
       *
       * @return {qx.ui.core.Widget[]} The pane's child widgets
       */
      getChildren: function getChildren() {
        return this.__children__P_500_0;
      },

      /*
      ---------------------------------------------------------------------------
        POINTER LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Handler for pointerdown event.
       *
       * Shows slider widget and starts drag session if pointer is near/on splitter widget.
       *
       * @param e {qx.event.type.Pointer} pointerdown event
       */
      _onPointerDown: function _onPointerDown(e) {
        // Only proceed if left pointer button is pressed and the splitter is active
        if (!e.isLeftPressed()) {
          return;
        }

        var splitter = this.getChildControl("splitter"); // Store offset between pointer event coordinates and splitter

        var splitterLocation = splitter.getContentLocation();
        var paneLocation = this.getContentLocation();
        this.__splitterOffset__P_500_2 = this.__isHorizontal__P_500_6 ? e.getDocumentLeft() - splitterLocation.left + paneLocation.left : e.getDocumentTop() - splitterLocation.top + paneLocation.top; // Synchronize slider to splitter size and show it

        var slider = this.getChildControl("slider");
        var splitterBounds = splitter.getBounds();
        slider.setUserBounds(splitterBounds.left, splitterBounds.top, splitterBounds.width || 6, splitterBounds.height || 6);
        slider.setZIndex(splitter.getZIndex() + 1);
        slider.show(); // Enable session

        this.__activeDragSession__P_500_3 = true;

        this.__blocker__P_500_1.capture();

        e.stop();
      },

      /**
       * Handler for pointermove event.
       *
       * @param e {qx.event.type.Pointer} pointermove event
       */
      _onPointerMove: function _onPointerMove(e) {
        this._setLastPointerPosition(e.getDocumentLeft(), e.getDocumentTop()); // Check if slider is already being dragged


        if (this.__activeDragSession__P_500_3) {
          // Compute new children sizes
          this.__computeSizes__P_500_12(); // Update slider position


          var slider = this.getChildControl("slider");
          var pos = this.__beginSize__P_500_7;

          if (this.__isHorizontal__P_500_6) {
            slider.setDomLeft(pos);

            this.__blocker__P_500_1.setStyle("left", pos - this.getOffset() + "px");
          } else {
            slider.setDomTop(pos);

            this.__blocker__P_500_1.setStyle("top", pos - this.getOffset() + "px");
          }

          e.stop();
        }
      },

      /**
       * Handler for pointerout event
       *
       * @param e {qx.event.type.Pointer} pointerout event
       */
      _onPointerOut: function _onPointerOut(e) {
        this._setLastPointerPosition(e.getDocumentLeft(), e.getDocumentTop());
      },

      /**
       * Handler for pointerup event
       *
       * Sets widget sizes if dragging session has been active.
       *
       * @param e {qx.event.type.Pointer} pointerup event
       */
      _onPointerUp: function _onPointerUp(e) {
        if (!this.__activeDragSession__P_500_3) {
          return;
        } // Set sizes to both widgets


        this._finalizeSizes(); // Hide the slider


        var slider = this.getChildControl("slider");
        slider.exclude(); // Cleanup

        this.__activeDragSession__P_500_3 = false;
        this.releaseCapture();
        e.stop();
      },

      /*
      ---------------------------------------------------------------------------
        INTERVAL HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Updates widgets' sizes based on the slider position.
       */
      _finalizeSizes: function _finalizeSizes() {
        var beginSize = this.__beginSize__P_500_7;
        var endSize = this.__endSize__P_500_8;

        if (beginSize == null) {
          return;
        }

        var children = this._getChildren();

        var firstWidget = children[2];
        var secondWidget = children[3]; // Read widgets' flex values

        var firstFlexValue = firstWidget.getLayoutProperties().flex;
        var secondFlexValue = secondWidget.getLayoutProperties().flex; // Both widgets have flex values

        if (firstFlexValue != 0 && secondFlexValue != 0) {
          firstWidget.setLayoutProperties({
            flex: beginSize
          });
          secondWidget.setLayoutProperties({
            flex: endSize
          });
        } // Update both sizes
        else {
            // Set widths to static widgets
            if (this.__isHorizontal__P_500_6) {
              firstWidget.setWidth(beginSize);
              secondWidget.setWidth(endSize);
            } else {
              firstWidget.setHeight(beginSize);
              secondWidget.setHeight(endSize);
            }
          }
      },

      /**
       * Computes widgets' sizes based on the pointer coordinate.
       */
      __computeSizes__P_500_12: function __computeSizes__P_500_12() {
        if (this.__isHorizontal__P_500_6) {
          var min = "minWidth",
              size = "width",
              max = "maxWidth",
              pointer = this.__lastPointerX__P_500_4;
        } else {
          var min = "minHeight",
              size = "height",
              max = "maxHeight",
              pointer = this.__lastPointerY__P_500_5;
        }

        var children = this._getChildren();

        var beginHint = children[2].getSizeHint();
        var endHint = children[3].getSizeHint(); // Area given to both widgets

        var allocatedSize = children[2].getBounds()[size] + children[3].getBounds()[size]; // Calculate widget sizes

        var beginSize = pointer - this.__splitterOffset__P_500_2;
        var endSize = allocatedSize - beginSize; // Respect minimum limits

        if (beginSize < beginHint[min]) {
          endSize -= beginHint[min] - beginSize;
          beginSize = beginHint[min];
        } else if (endSize < endHint[min]) {
          beginSize -= endHint[min] - endSize;
          endSize = endHint[min];
        } // Respect maximum limits


        if (beginSize > beginHint[max]) {
          endSize += beginSize - beginHint[max];
          beginSize = beginHint[max];
        } else if (endSize > endHint[max]) {
          beginSize += endSize - endHint[max];
          endSize = endHint[max];
        } // Store sizes


        this.__beginSize__P_500_7 = beginSize;
        this.__endSize__P_500_8 = endSize;
      },

      /**
       * Determines whether this is an active drag session
       *
       * @return {Boolean} True if active drag session, otherwise false.
       */
      _isActiveDragSession: function _isActiveDragSession() {
        return this.__activeDragSession__P_500_3;
      },

      /**
       * Sets the last pointer position.
       *
       * @param x {Integer} the x position of the pointer.
       * @param y {Integer} the y position of the pointer.
       */
      _setLastPointerPosition: function _setLastPointerPosition(x, y) {
        this.__lastPointerX__P_500_4 = x;
        this.__lastPointerY__P_500_5 = y;
      }
    },
    destruct: function destruct() {
      this.__children__P_500_0 = null;
    }
  });
  qx.ui.splitpane.Pane.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The slider of the SplitPane (used during drag sessions for fast feedback)
   *
   * @internal
   */
  qx.Class.define("qx.ui.splitpane.Slider", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      allowShrinkX: {
        refine: true,
        init: false
      },
      // overridden
      allowShrinkY: {
        refine: true,
        init: false
      }
    }
  });
  qx.ui.splitpane.Slider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.basic.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The splitter is the element between the two panes.
   *
   * @internal
   *
   * @childControl knob {qx.ui.basic.Image} knob to resize the splitpane
   */
  qx.Class.define("qx.ui.splitpane.Splitter", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param parentWidget {qx.ui.splitpane.Pane} The underlaying split pane.
     */
    construct: function construct(parentWidget) {
      qx.ui.core.Widget.constructor.call(this); // set layout

      if (parentWidget.getOrientation() == "vertical") {
        this._setLayout(new qx.ui.layout.HBox(0, "center"));

        this._getLayout().setAlignY("middle");
      } else {
        this._setLayout(new qx.ui.layout.VBox(0, "middle"));

        this._getLayout().setAlignX("center");
      } // create knob child control


      if (this.isKnobVisible()) {
        this._createChildControl("knob");
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      allowShrinkX: {
        refine: true,
        init: false
      },
      // overridden
      allowShrinkY: {
        refine: true,
        init: false
      },

      /**
       * The visibility of the splitter button.
       * Allows to remove the splitter button in favor of other visual separation
       * means like background color differences.
       */
      knobVisible: {
        check: "Boolean",
        init: true,
        themeable: true,
        apply: "_applyKnobVisible"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          // Create splitter knob
          case "knob":
            control = new qx.ui.basic.Image();

            this._add(control);

            break;
        }

        return control || qx.ui.splitpane.Splitter.prototype._createChildControlImpl.base.call(this, id);
      },
      // property apply
      _applyKnobVisible: function _applyKnobVisible(value, old) {
        this.getChildControl("knob").setVisibility(value ? "visible" : "excluded");
      }
    }
  });
  qx.ui.splitpane.Splitter.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.layout.Abstract": {
        "require": true
      },
      "qx.ui.layout.Util": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Layouter for vertical split panes.
   *
   * @internal
   */
  qx.Class.define("qx.ui.splitpane.VLayout", {
    extend: qx.ui.layout.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty: function verifyLayoutProperty(item, name, value) {
        this.assert(name === "type" || name === "flex", "The property '" + name + "' is not supported by the split layout!");

        if (name == "flex") {
          this.assertNumber(value);
        }

        if (name == "type") {
          this.assertString(value);
        }
      },
      // overridden
      renderLayout: function renderLayout(availWidth, availHeight, padding) {
        var children = this._getLayoutChildren();

        var length = children.length;
        var child, type;
        var begin, splitter, slider, end;
        var paddingLeft = padding.left || 0;
        var paddingTop = padding.top || 0;

        for (var i = 0; i < length; i++) {
          child = children[i];
          type = child.getLayoutProperties().type;

          if (type === "splitter") {
            splitter = child;
          } else if (type === "slider") {
            slider = child;
          } else if (!begin) {
            begin = child;
          } else {
            end = child;
          }
        }

        if (begin && end) {
          var beginFlex = begin.getLayoutProperties().flex;
          var endFlex = end.getLayoutProperties().flex;

          if (beginFlex == null) {
            beginFlex = 1;
          }

          if (endFlex == null) {
            endFlex = 1;
          }

          var beginHint = begin.getSizeHint();
          var splitterHint = splitter.getSizeHint();
          var endHint = end.getSizeHint();
          var beginHeight = beginHint.height;
          var splitterHeight = splitterHint.height;
          var endHeight = endHint.height;

          if (beginFlex > 0 && endFlex > 0) {
            var flexSum = beginFlex + endFlex;
            var flexAvailable = availHeight - splitterHeight;
            var beginHeight = Math.round(flexAvailable / flexSum * beginFlex);
            var endHeight = flexAvailable - beginHeight;
            var sizes = qx.ui.layout.Util.arrangeIdeals(beginHint.minHeight, beginHeight, beginHint.maxHeight, endHint.minHeight, endHeight, endHint.maxHeight);
            beginHeight = sizes.begin;
            endHeight = sizes.end;
          } else if (beginFlex > 0) {
            beginHeight = availHeight - splitterHeight - endHeight;

            if (beginHeight < beginHint.minHeight) {
              beginHeight = beginHint.minHeight;
            }

            if (beginHeight > beginHint.maxHeight) {
              beginHeight = beginHint.maxHeight;
            }
          } else if (endFlex > 0) {
            endHeight = availHeight - beginHeight - splitterHeight;

            if (endHeight < endHint.minHeight) {
              endHeight = endHint.minHeight;
            }

            if (endHeight > endHint.maxHeight) {
              endHeight = endHint.maxHeight;
            }
          }

          begin.renderLayout(paddingLeft, paddingTop, availWidth, beginHeight);
          splitter.renderLayout(paddingLeft, beginHeight + paddingTop, availWidth, splitterHeight);
          end.renderLayout(paddingLeft, beginHeight + splitterHeight + paddingTop, availWidth, endHeight);
        } else {
          // Hide the splitter completely
          splitter.renderLayout(0, 0, 0, 0); // Render one child

          if (begin) {
            begin.renderLayout(paddingLeft, paddingTop, availWidth, availHeight);
          } else if (end) {
            end.renderLayout(paddingLeft, paddingTop, availWidth, availHeight);
          }
        }
      },
      // overridden
      _computeSizeHint: function _computeSizeHint() {
        var children = this._getLayoutChildren();

        var length = children.length;
        var child, hint, props;
        var minHeight = 0,
            height = 0,
            maxHeight = 0;
        var minWidth = 0,
            width = 0,
            maxWidth = 0;

        for (var i = 0; i < length; i++) {
          child = children[i];
          props = child.getLayoutProperties(); // The slider is not relevant for auto sizing

          if (props.type === "slider") {
            continue;
          }

          hint = child.getSizeHint();
          minHeight += hint.minHeight;
          height += hint.height;
          maxHeight += hint.maxHeight;

          if (hint.minWidth > minWidth) {
            minWidth = hint.minWidth;
          }

          if (hint.width > width) {
            width = hint.width;
          }

          if (hint.maxWidth > maxWidth) {
            maxWidth = hint.maxWidth;
          }
        }

        return {
          minHeight: minHeight,
          height: height,
          maxHeight: maxHeight,
          minWidth: minWidth,
          width: width,
          maxWidth: maxWidth
        };
      }
    }
  });
  qx.ui.splitpane.VLayout.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A factory creating widgets to use for editing table cells.
   */
  qx.Interface.define("qx.ui.table.ICellEditorFactory", {
    members: {
      /**
       * Creates a cell editor.
       *
       * The cellInfo map contains the following properties:
       * <ul>
       * <li>value (var): the cell's value.</li>
       * <li>row (int): the model index of the row the cell belongs to.</li>
       * <li>col (int): the model index of the column the cell belongs to.</li>
       * <li>xPos (int): the x position of the cell in the table pane.</li>
       * <li>table (qx.ui.table.Table) reference to the table, the cell belongs to. </li>
       * </ul>
       *
       * @abstract
       * @param cellInfo {Map} A map containing the information about the cell to
       *      create.
       * @return {qx.ui.core.Widget} the widget that should be used as cell editor.
       */
      createCellEditor: function createCellEditor(cellInfo) {
        return true;
      },

      /**
       * Returns the current value of a cell editor.
       *
       * @abstract
       * @param cellEditor {qx.ui.core.Widget} The cell editor formally created by
       *      {@link #createCellEditor}.
       * @return {var} the current value from the editor.
       */
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        return true;
      }
    }
  });
  qx.ui.table.ICellEditorFactory.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A cell renderer for data cells.
   */
  qx.Interface.define("qx.ui.table.ICellRenderer", {
    members: {
      /**
       * Creates the HTML for a data cell.
       *
       * The cellInfo map contains the following properties:
       * <ul>
       * <li>value (var): the cell's value.</li>
       * <li>rowData (var): contains the row data for the row, the cell belongs to.
       *   The kind of this object depends on the table model, see
       *   {@link qx.ui.table.ITableModel#getRowData}</li>
       * <li>row (int): the model index of the row the cell belongs to.</li>
       * <li>col (int): the model index of the column the cell belongs to.</li>
       * <li>table (qx.ui.table.Table): the table the cell belongs to.</li>
       * <li>xPos (int): the x position of the cell in the table pane.</li>
       * <li>selected (boolean): whether the cell is selected.</li>
       * <li>focusedRow (boolean): whether the cell is in the same row as the
       *   focused cell.</li>
       * <li>editable (boolean): whether the cell is editable.</li>
       * <li>style (string): The CSS styles that should be applied to the outer HTML
       *   element.</li>
       * <li>styleLeft (string): The left position of the cell.</li>
       * <li>styleWidth (string): The cell's width (pixel).</li>
       * <li>styleHeight (string): The cell's height (pixel).</li>
       * </ul>
       *
       * @param cellInfo {Map} A map containing the information about the cell to
       *     create.
       * @param htmlArr {String[]} Target string container. The HTML of the data
       *     cell should be appended to this array.
       *
       * @return {Boolean|undefined}
       *   A return value of <i>true</i> specifies that no additional cells in
       *   the row shall be rendered. This may be used, for example, for
       *   separator rows or for other special rendering purposes. Traditional
       *   cell renderers had no defined return value, so returned nothing
       *   (undefined). If this method returns either false or nothing, then
       *   rendering continues with the next cell in the row, which the normal
       *   mode of operation.
       */
      createDataCellHtml: function createDataCellHtml(cellInfo, htmlArr) {
        return true;
      }
    }
  });
  qx.ui.table.ICellRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Interface for creating the column visibility menu
   */
  qx.Interface.define("qx.ui.table.IColumnMenuButton", {
    properties: {
      /**
       * The menu which is displayed when this button is pressed.
       */
      menu: {}
    },
    members: {
      /**
       * Instantiate a sub-widget.
       *
       * @param item {String}
       *   One of the following strings, indicating what type of
       *   column-menu-specific object to instantiate:
       *   <dl>
       *     <dt>menu</dt>
       *     <dd>
       *       Instantiate a menu which will appear when the column visibility
       *       button is pressed. No options are provided in this case.
       *     </dd>
       *     <dt>menu-button</dt>
       *     <dd>
       *       Instantiate a button to correspond to a column within the
       *       table. The options are a map containing <i>text</i>, the name of
       *       the column; <i>column</i>, the column number; and
       *       <i>bVisible</i>, a boolean indicating whether this column is
       *       currently visible. The instantiated return object must implement
       *       interface {@link qx.ui.table.IColumnMenuItem}
       *     </dd>
       *     <dt>user-button</dt>
       *     <dd>
       *       Instantiate a button for other than a column name. This is used,
       *       for example, to add the "Reset column widths" button when the
       *       Resize column model is requested. The options is a map containing
       *       <i>text</i>, the text to present in the button.
       *     </dd>
       *     <dt>separator</dt>
       *     <dd>
       *       Instantiate a separator object to added to the menu. This is
       *       used, for example, to separate the table column name list from
       *       the "Reset column widths" button when the Resize column model is
       *       requested. No options are provided in this case.
       *     </dd>
       *   </dl>
       *
       * @param options {Map}
       *   Options specific to the <i>item</i> being requested.
       *
       * @return {qx.ui.core.Widget}
       *   The instantiated object as specified by <i>item</i>.
       */
      factory: function factory(item, options) {
        return true;
      },

      /**
       * Empty the menu of all items, in preparation for building a new column
       * visibility menu.
       *
       */
      empty: function empty() {
        return true;
      }
    }
  });
  qx.ui.table.IColumnMenuButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Interface for a column menu item corresponding to a table column.
   */
  qx.Interface.define("qx.ui.table.IColumnMenuItem", {
    properties: {
      /**
       * Whether the table column associated with this menu item is visible
       * Should be of type {Boolean}!
       */
      columnVisible: {}
    },
    events: {
      /**
       * Dispatched when a column changes visibility state. The event data is a
       * boolean indicating whether the table column associated with this menu
       * item is now visible.
       */
      changeColumnVisible: "qx.event.type.Data"
    }
  });
  qx.ui.table.IColumnMenuItem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A cell renderer for header cells.
   */
  qx.Interface.define("qx.ui.table.IHeaderRenderer", {
    members: {
      /**
       * Creates a header cell.
       *
       * The cellInfo map contains the following properties:
       * <ul>
       * <li>col (int): the model index of the column.</li>
       * <li>xPos (int): the x position of the column in the table pane.</li>
       * <li>name (string): the name of the column.</li>
       * <li>editable (boolean): whether the column is editable.</li>
       * <li>sorted (boolean): whether the column is sorted.</li>
       * <li>sortedAscending (boolean): whether sorting is ascending.</li>
       * </ul>
       *
       * @abstract
       * @param cellInfo {Map} A map containing the information about the cell to
       *      create.
       * @return {qx.ui.core.Widget} the widget that renders the header cell.
       */
      createHeaderCell: function createHeaderCell(cellInfo) {
        return true;
      },

      /**
       * Updates a header cell.
       *
       * @abstract
       * @param cellInfo {Map} A map containing the information about the cell to
       *      create. This map has the same structure as in {@link #createHeaderCell}.
       * @param cellWidget {qx.ui.core.Widget} the widget that renders the header cell. This is
       *      the same widget formally created by {@link #createHeaderCell}.
       */
      updateHeaderCell: function updateHeaderCell(cellInfo, cellWidget) {
        return true;
      }
    }
  });
  qx.ui.table.IHeaderRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * Interface for a row renderer.
   */
  qx.Interface.define("qx.ui.table.IRowRenderer", {
    members: {
      /**
       * Updates a data row.
       *
       * The rowInfo map contains the following properties:
       * <ul>
       * <li>rowData (var): contains the row data for the row.
       *   The kind of this object depends on the table model, see
       *   {@link ITableModel#getRowData()}</li>
       * <li>row (int): the model index of the row.</li>
       * <li>selected (boolean): whether a cell in this row is selected.</li>
       * <li>focusedRow (boolean): whether the focused cell is in this row.</li>
       * <li>table (qx.ui.table.Table): the table the row belongs to.</li>
       * </ul>
       *
       * @abstract
       * @param rowInfo {Map} A map containing the information about the row to
       *      update.
       * @param rowElement {Element} the DOM element that renders the data row.
       */
      updateDataRowElement: function updateDataRowElement(rowInfo, rowElement) {},

      /**
       * Get the row's height CSS style taking the box model into account
       *
       * @param height {Integer} The row's (border-box) height in pixel
       */
      getRowHeightStyle: function getRowHeightStyle(height) {},

      /**
       * Create a style string, which will be set as the style property of the row.
       *
       * @param rowInfo {Map} A map containing the information about the row to
       *      update. See {@link #updateDataRowElement} for more information.
       */
      createRowStyle: function createRowStyle(rowInfo) {},

      /**
       * Create a HTML class string, which will be set as the class property of the row.
       *
       * @param rowInfo {Map} A map containing the information about the row to
       *      update. See {@link #updateDataRowElement} for more information.
       */
      getRowClass: function getRowClass(rowInfo) {}
    }
  });
  qx.ui.table.IRowRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * The data model of a table.
   */
  qx.Interface.define("qx.ui.table.ITableModel", {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the table data changed (the stuff shown in the table body).
       * The data property of the event may be null or a map having the following attributes:
       * <ul>
       *   <li>firstRow: The index of the first row that has changed.</li>
       *   <li>lastRow: The index of the last row that has changed.</li>
       *   <li>firstColumn: The model index of the first column that has changed.</li>
       *   <li>lastColumn: The model index of the last column that has changed.</li>
       * </ul>
       */
      "dataChanged": "qx.event.type.Data",

      /**
       * Fired when the meta data changed (the stuff shown in the table header).
       */
      "metaDataChanged": "qx.event.type.Event",

      /**
       * Fired after the table is sorted (but before the metaDataChanged event)
       */
      "sorted": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the number of rows in the model.
       *
       * @abstract
       * @return {Integer} the number of rows.
       */
      getRowCount: function getRowCount() {},

      /**
       *
       * Returns the data of one row. This function may be overridden by models which hold
       * all data of a row in one object. By using this function, clients have a way of
       * quickly retrieving the entire row data.
       *
       * <b>Important:</b>Models which do not have their row data accessible in one object
       * may return null.
       *
       * @param rowIndex {Integer} the model index of the row.
       * @return {Object} the row data as an object or null if the model does not support row data
       *                    objects. The details on the object returned are determined by the model
       *                    implementation only.
       */
      getRowData: function getRowData(rowIndex) {},

      /**
       * Returns the number of columns in the model.
       *
       * @abstract
       * @return {Integer} the number of columns.
       */
      getColumnCount: function getColumnCount() {},

      /**
       * Returns the ID of column. The ID may be used to identify columns
       * independent from their index in the model. E.g. for being aware of added
       * columns when saving the width of a column.
       *
       * @abstract
       * @param columnIndex {Integer} the index of the column.
       * @return {String} the ID of the column.
       */
      getColumnId: function getColumnId(columnIndex) {},

      /**
       * Returns the index of a column.
       *
       * @abstract
       * @param columnId {String} the ID of the column.
       * @return {Integer} the index of the column.
       */
      getColumnIndexById: function getColumnIndexById(columnId) {},

      /**
       * Returns the name of a column. This name will be shown to the user in the
       * table header.
       *
       * @abstract
       * @param columnIndex {Integer} the index of the column.
       * @return {String} the name of the column.
       */
      getColumnName: function getColumnName(columnIndex) {},

      /**
       * Returns whether a column is editable.
       *
       * @param columnIndex {Integer} the column to check.
       * @return {Boolean} whether the column is editable.
       */
      isColumnEditable: function isColumnEditable(columnIndex) {},

      /**
       * Returns whether a column is sortable.
       *
       * @param columnIndex {Integer} the column to check.
       * @return {Boolean} whether the column is sortable.
       */
      isColumnSortable: function isColumnSortable(columnIndex) {},

      /**
       * Sorts the model by a column.
       *
       * @param columnIndex {Integer} the column to sort by.
       * @param ascending {Boolean} whether to sort ascending.
       */
      sortByColumn: function sortByColumn(columnIndex, ascending) {},

      /**
       * Returns the column index the model is sorted by. If the model is not sorted
       * -1 is returned.
       *
       * @return {Integer} the column index the model is sorted by.
       */
      getSortColumnIndex: function getSortColumnIndex() {},

      /**
       * Returns whether the model is sorted ascending.
       *
       * @return {Boolean} whether the model is sorted ascending.
       */
      isSortAscending: function isSortAscending() {},

      /**
       * Prefetches some rows. This is a hint to the model that the specified rows
       * will be read soon.
       *
       * @param firstRowIndex {Integer} the index of first row.
       * @param lastRowIndex {Integer} the index of last row.
       */
      prefetchRows: function prefetchRows(firstRowIndex, lastRowIndex) {},

      /**
       * Returns a cell value by column index.
       *
       * @abstract
       * @param columnIndex {Integer} the index of the column.
       * @param rowIndex {Integer} the index of the row.
       * @return {var} The value of the cell.
       * @see #getValueById
       */
      getValue: function getValue(columnIndex, rowIndex) {},

      /**
       * Returns a cell value by column ID.
       *
       * Whenever you have the choice, use {@link #getValue()} instead,
       * because this should be faster.
       *
       * @param columnId {String} the ID of the column.
       * @param rowIndex {Integer} the index of the row.
       * @return {var} the value of the cell.
       */
      getValueById: function getValueById(columnId, rowIndex) {},

      /**
       * Sets a cell value by column index.
       *
       * @abstract
       * @param columnIndex {Integer} The index of the column.
       * @param rowIndex {Integer} the index of the row.
       * @param value {var} The new value.
       * @see #setValueById
       */
      setValue: function setValue(columnIndex, rowIndex, value) {},

      /**
       * Sets a cell value by column ID.
       *
       * Whenever you have the choice, use {@link #setValue()} instead,
       * because this should be faster.
       *
       * @param columnId {String} The ID of the column.
       * @param rowIndex {Integer} The index of the row.
       * @param value {var} The new value.
       */
      setValueById: function setValueById(columnId, rowIndex, value) {}
    }
  });
  qx.ui.table.ITableModel.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menu.Menu": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006-2009 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * This mixin allows easily adding handlers for context menus on table columns.
   */
  qx.Mixin.define("qx.ui.table.MTableContextMenu", {
    construct: function construct() {
      // Add an event listener to handle context menu events.  The actual menu
      // is built by a function registered with a call to
      // setContextMenuHandler(col, handler).
      this.addListener("cellContextmenu", function (e) {
        var contextMenu = this.getContextMenu(); // Dispose of any previously existing context menu

        if (contextMenu && !contextMenu.isDisposed()) {
          // Dispose of the context menu.
          contextMenu.hide();
          this.setContextMenu(null);
          this.getApplicationRoot().remove(contextMenu);
          contextMenu.dispose();
          contextMenu = null;
        } // Get the context menu handler for the column on which the context
        // menu request was issued.


        var col = e.getColumn();
        var contextMenuHandler = this.getContextMenuHandler(col); // If there's no context menu handler for this column, we have nothing
        // to do.

        if (typeof contextMenuHandler !== "function") {
          return;
        } // Get the context object for the handler function


        var handlerContext = this.__contextMenuHandlerContext__P_502_0[col]; // Get the data model

        var tableModel = this.getTableModel(); // Create a context menu for this tree.

        contextMenu = new qx.ui.menu.Menu(); // Don't display context menus from the context menu

        contextMenu.addListener("contextmenu", function (e) {
          e.preventDefault();
        }); // This prevents the display of context menu on table header cells

        contextMenu.addListenerOnce("disappear", function () {
          this.setContextMenu(null);
        }, this); // Call the context menu handler for this column.

        var bShowContextMenu = contextMenuHandler.call(handlerContext, col, e.getRow(), this, tableModel, contextMenu); // If we were told not to display the context menu...

        if (!bShowContextMenu) {
          // ... then we're all done here.
          contextMenu.dispose();
          return;
        } // Set the context menu


        this.setContextMenu(contextMenu);
      }, this); // Provide an array in which context menu handlers will be stored.  The
      // array is indexed by column number.

      this.__contextMenuHandler__P_502_1 = [];
      this.__contextMenuHandlerContext__P_502_0 = [];
    },
    members: {
      __contextMenuHandler__P_502_1: null,
      __contextMenuHandlerContext__P_502_0: null,

      /**
       * Add a handler for a context menu which is initiated in a specific
       * column.
       *
       * @param col {Integer}
       *   The column number in which the context menu request originated
       *
       * @param handler {Function}
       *   The function to call when a context menu request originates in the
       *   specified column. The handler is called with the following arguments:
       *   <ul>
       *     <li>
       *       <b>column</b>: (Integer)
       *       The number of the column in which the right click was issued
       *     </li>
       *     <li>
       *       <b>row</b>: (Integer)
       *       The number of the row in which the right click was issued
       *     </li>
       *     <li>
       *       <b>table</b>: {@link qx.ui.table.Table}
       *       The table in which the right click was issued
       *     </li>
       *     <li>
       *       <b>dataModel</b>: {@link qx.ui.table.model.Abstract}
       *       Complete data model of the table
       *     </li>
       *     <li>
       *       <b>contextMenu</b>: {@link qx.ui.menu.Menu}
       *       Menu in which buttons can be added to implement this context menu
       *     </li>
       *   </ul>
       *   The function must return a (Boolean), indicating whether the context
       *   menu should be shown or not. The context menu will be shown when the
       *   handler function returns <code>true</code>. When the handler function
       *   returns <code>false</code> the context menu will <b>not</b> be shown.
       *
       * @param context {Object?this}
       *   Optional execution context for the callback (i.e. "this").
       *   If not provided, the {@link qx.ui.table.Table} object this mixin is
       *   applied to is used.
       *
       */
      setContextMenuHandler: function setContextMenuHandler(col, handler, context) {
        this.__contextMenuHandler__P_502_1[col] = handler;
        this.__contextMenuHandlerContext__P_502_0[col] = context || this;
      },

      /**
       * Return the registered context menu handler for a column.
       *
       * @param col {Integer}
       *   The column number for which the context menu handler is requested
       *
       * @return {Function}
       *   The handler function which has been registered for the specified
       *   column. The arguments of the handler is documented in
       *   {@link #setContextMenuHandler}.
       */
      getContextMenuHandler: function getContextMenuHandler(col) {
        return this.__contextMenuHandler__P_502_1[col];
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__contextMenuHandler__P_502_1 = null;
      this.__contextMenuHandlerContext__P_502_0 = null;
    }
  });
  qx.ui.table.MTableContextMenu.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MDragDropScrolling": {
        "require": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.container.Composite": {
        "construct": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.table.rowrenderer.Default": {
        "construct": true
      },
      "qx.locale.Manager": {
        "construct": true
      },
      "qx.ui.table.columnmenu.Button": {},
      "qx.ui.table.selection.Manager": {},
      "qx.ui.table.selection.Model": {},
      "qx.ui.table.columnmodel.Basic": {},
      "qx.ui.table.pane.Pane": {},
      "qx.ui.table.pane.Header": {},
      "qx.ui.table.pane.Scroller": {},
      "qx.ui.table.pane.Model": {},
      "qx.ui.basic.Label": {},
      "qx.ui.table.model.Simple": {},
      "qx.event.Registration": {},
      "qx.log.Logger": {},
      "qx.ui.table.pane.FocusIndicator": {},
      "qx.lang.Number": {},
      "qx.event.Timer": {},
      "qx.core.Assert": {},
      "qx.ui.table.IColumnMenuItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Table
   *
   * A detailed description can be found in the package description
   * {@link qx.ui.table}.
   *
   * @childControl statusbar {qx.ui.basic.Label} label to show the status of the table
   * @childControl column-button {qx.ui.table.columnmenu.Button} button to open the column menu
   */
  qx.Class.define("qx.ui.table.Table", {
    extend: qx.ui.core.Widget,
    include: qx.ui.core.MDragDropScrolling,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param tableModel {qx.ui.table.ITableModel ? null}
     *   The table model to read the data from.
     *
     * @param custom {Map ? null}
     *   A map provided to override the various supplemental classes allocated
     *   within this constructor.  Each property must be a function which
     *   returns an object instance, as indicated by shown the defaults listed
     *   here:
     *
     *   <dl>
     *     <dt>initiallyHiddenColumns</dt>
     *       <dd>
     *         {Array?}
     *         A list of column numbers that should be initially invisible. Any
     *         column not mentioned will be initially visible, and if no array
     *         is provided, all columns will be initially visible.
     *       </dd>
     *     <dt>selectionManager</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.selection.Manager(obj);
     *         }
     *       </pre></dd>
     *     <dt>selectionModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.selection.Model(obj);
     *         }
     *       </pre></dd>
     *     <dt>tableColumnModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.columnmodel.Basic(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Model(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePane</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Pane(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneHeader</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Header(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneScroller</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Scroller(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Model(obj);
     *         }
     *       </pre></dd>
     *     <dt>columnMenu</dt>
     *       <dd><pre class='javascript'>
     *         function()
     *         {
     *           return new qx.ui.table.columnmenu.Button();
     *         }
     *       </pre></dd>
     *   </dl>
     */
    construct: function construct(tableModel, custom) {
      qx.ui.core.Widget.constructor.call(this); //
      // Use default objects if custom objects are not specified
      //

      if (!custom) {
        custom = {};
      }

      if (custom.initiallyHiddenColumns) {
        this.setInitiallyHiddenColumns(custom.initiallyHiddenColumns);
      }

      if (custom.selectionManager) {
        this.setNewSelectionManager(custom.selectionManager);
      }

      if (custom.selectionModel) {
        this.setNewSelectionModel(custom.selectionModel);
      }

      if (custom.tableColumnModel) {
        this.setNewTableColumnModel(custom.tableColumnModel);
      }

      if (custom.tablePane) {
        this.setNewTablePane(custom.tablePane);
      }

      if (custom.tablePaneHeader) {
        this.setNewTablePaneHeader(custom.tablePaneHeader);
      }

      if (custom.tablePaneScroller) {
        this.setNewTablePaneScroller(custom.tablePaneScroller);
      }

      if (custom.tablePaneModel) {
        this.setNewTablePaneModel(custom.tablePaneModel);
      }

      if (custom.columnMenu) {
        this.setNewColumnMenu(custom.columnMenu);
      }

      this._setLayout(new qx.ui.layout.VBox()); // Create the child widgets


      this.__scrollerParent__P_503_0 = new qx.ui.container.Composite(new qx.ui.layout.HBox());

      this._add(this.__scrollerParent__P_503_0, {
        flex: 1
      }); // Allocate a default data row renderer


      this.setDataRowRenderer(new qx.ui.table.rowrenderer.Default(this)); // Create the models

      this.__selectionManager__P_503_1 = this.getNewSelectionManager()(this);
      this.setSelectionModel(this.getNewSelectionModel()(this));
      this.setTableModel(tableModel || this.getEmptyTableModel()); // create the main meta column

      this.setMetaColumnCounts([-1]); // Make focusable

      this.setTabIndex(1);
      this.addListener("keydown", this._onKeyDown);
      this.addListener("focus", this._onFocusChanged);
      this.addListener("blur", this._onFocusChanged); // attach the resize listener to the last child of the layout. This
      // ensures that all other children are laid out before

      var spacer = new qx.ui.core.Widget().set({
        height: 0
      });

      this._add(spacer);

      spacer.addListener("resize", this._onResize, this);
      this.__focusedCol__P_503_2 = null;
      this.__focusedRow__P_503_3 = null; // add an event listener which updates the table content on locale change

      {
        qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
      }
      this.initStatusBarVisible(); // If the table model has an init() method...

      tableModel = this.getTableModel();

      if (tableModel.init && typeof tableModel.init == "function") {
        // ... then call it now to allow the table model to affect table
        // properties.
        tableModel.init(this);
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Dispatched before adding the column list to the column visibility menu.
       * The event data is a map with two properties: table and menu.  Listeners
       * may add additional items to the menu, which appear at the top of the
       * menu.
       */
      "columnVisibilityMenuCreateStart": "qx.event.type.Data",

      /**
       * Dispatched after adding the column list to the column visibility menu.
       * The event data is a map with two properties: table and menu.  Listeners
       * may add additional items to the menu, which appear at the bottom of the
       * menu.
       */
      "columnVisibilityMenuCreateEnd": "qx.event.type.Data",

      /**
       * Dispatched when the width of the table has changed.
       */
      "tableWidthChanged": "qx.event.type.Event",

      /**
       * Dispatched when updating scrollbars discovers that a vertical scrollbar
       * is needed when it previously was not, or vice versa.  The data is a
       * boolean indicating whether a vertical scrollbar is now being used.
       */
      "verticalScrollBarChanged": "qx.event.type.Data",

      /**
       * Dispatched when a data cell has been tapped.
       */
      "cellTap": "qx.ui.table.pane.CellEvent",

      /**
       * Dispatched when a data cell has been tapped.
       */
      "cellDbltap": "qx.ui.table.pane.CellEvent",

      /**
       * Dispatched when the context menu is needed in a data cell
       */
      "cellContextmenu": "qx.ui.table.pane.CellEvent",

      /**
       * Dispatched after a cell editor is flushed.
       *
       * The data is a map containing this properties:
       * <ul>
       *   <li>row</li>
       *   <li>col</li>
       *   <li>value</li>
       *   <li>oldValue</li>
       * </ul>
       */
      "dataEdited": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** Events that must be redirected to the scrollers. */
      __redirectEvents__P_503_4: {
        cellTap: 1,
        cellDbltap: 1,
        cellContextmenu: 1
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "table"
      },
      focusable: {
        refine: true,
        init: true
      },
      minWidth: {
        refine: true,
        init: 50
      },

      /**
       * The list of columns that are initially hidden. This property is set by
       * the constructor, from the value received in
       * custom.initiallyHiddenColumns, and is only used when a column model is
       * initialized. It can be of great benefit in tables with numerous columns
       * where most are not initially visible. The process of creating the
       * headers for all of the columns, only to have those columns discarded
       * shortly thereafter when setColumnVisibility(false) is called, is a
       * waste of (significant, in some browsers) time. Specifying the
       * non-visible columns at constructor time can therefore avoid the initial
       * creation of all of those superfluous widgets.
       */
      initiallyHiddenColumns: {
        init: null
      },

      /**
       * Whether the widget contains content which may be selected by the user.
       *
       * If the value set to <code>true</code> the native browser selection can
       * be used for text selection. But it is normally useful for
       * forms fields, longer texts/documents, editors, etc.
       *
       * Note: This has no effect on Table!
       */
      selectable: {
        refine: true,
        init: false
      },

      /** The selection model. */
      selectionModel: {
        check: "qx.ui.table.selection.Model",
        apply: "_applySelectionModel",
        event: "changeSelectionModel"
      },

      /** The table model. */
      tableModel: {
        check: "qx.ui.table.ITableModel",
        apply: "_applyTableModel",
        event: "changeTableModel"
      },

      /** The height of the table rows. */
      rowHeight: {
        check: "Number",
        init: 20,
        apply: "_applyRowHeight",
        event: "changeRowHeight",
        themeable: true
      },

      /**
       * Force line height to match row height.  May be disabled if cell
       * renderers being used wish to render multiple lines of data within a
       * cell.  (With the default setting, all but the first of multiple lines
       * of data will not be visible.)
       */
      forceLineHeight: {
        check: "Boolean",
        init: true
      },

      /**
       *  Whether the header cells are visible. When setting this to false,
       *  you'll likely also want to set the {#columnVisibilityButtonVisible}
       *  property to false as well, to entirely remove the header row.
       */
      headerCellsVisible: {
        check: "Boolean",
        init: true,
        apply: "_applyHeaderCellsVisible",
        themeable: true
      },

      /** The height of the header cells. */
      headerCellHeight: {
        check: "Integer",
        init: 16,
        apply: "_applyHeaderCellHeight",
        event: "changeHeaderCellHeight",
        nullable: true,
        themeable: true
      },

      /** Whether to show the status bar */
      statusBarVisible: {
        check: "Boolean",
        init: true,
        apply: "_applyStatusBarVisible"
      },

      /** The Statusbartext, set it, if you want some more Information */
      additionalStatusBarText: {
        nullable: true,
        init: null,
        apply: "_applyAdditionalStatusBarText"
      },

      /** Whether to show the column visibility button */
      columnVisibilityButtonVisible: {
        check: "Boolean",
        init: true,
        apply: "_applyColumnVisibilityButtonVisible",
        themeable: true
      },

      /**
       * @type {Integer[]} The number of columns per meta column. If the last array entry is -1,
       * this meta column will get the remaining columns.
       */
      metaColumnCounts: {
        check: "Object",
        apply: "_applyMetaColumnCounts"
      },

      /**
       * Whether the focus should moved when the pointer is moved over a cell. If false
       * the focus is only moved on pointer taps.
       */
      focusCellOnPointerMove: {
        check: "Boolean",
        init: false,
        apply: "_applyFocusCellOnPointerMove"
      },

      /**
       * Whether row focus change by keyboard also modifies selection
       */
      rowFocusChangeModifiesSelection: {
        check: "Boolean",
        init: true
      },

      /**
       * Whether the cell focus indicator should be shown
       */
      showCellFocusIndicator: {
        check: "Boolean",
        init: true,
        apply: "_applyShowCellFocusIndicator"
      },

      /**
       * By default, the "cellContextmenu" event is fired only when a data cell
       * is right-clicked. It is not fired when a right-click occurs in the
       * empty area of the table below the last data row. By turning on this
       * property, "cellContextMenu" events will also be generated when a
       * right-click occurs in that empty area. In such a case, row identifier
       * in the event data will be null, so event handlers can check (row ===
       * null) to handle this case.
       */
      contextMenuFromDataCellsOnly: {
        check: "Boolean",
        init: true,
        apply: "_applyContextMenuFromDataCellsOnly"
      },

      /**
       * Whether the table should keep the first visible row complete. If set to false,
       * the first row may be rendered partial, depending on the vertical scroll value.
       */
      keepFirstVisibleRowComplete: {
        check: "Boolean",
        init: true,
        apply: "_applyKeepFirstVisibleRowComplete"
      },

      /**
       * Whether the table cells should be updated when only the selection or the
       * focus changed. This slows down the table update but allows to react on a
       * changed selection or a changed focus in a cell renderer.
       */
      alwaysUpdateCells: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether to reset the selection when a header cell is tapped. Since
       * most data models do not have provisions to retain a selection after
       * sorting, the default is to reset the selection in this case. Some data
       * models, however, do have the capability to retain the selection, so
       * when using those, this property should be set to false.
       */
      resetSelectionOnHeaderTap: {
        check: "Boolean",
        init: true,
        apply: "_applyResetSelectionOnHeaderTap"
      },

      /**
       * Whether to reset the selection when the unpopulated table area is tapped.
       * The default is false which keeps the behaviour as before
       */
      resetSelectionOnTapBelowRows: {
        check: "Boolean",
        init: false,
        apply: "_applyResetSelectionOnTapBelowRows"
      },

      /** The renderer to use for styling the rows. */
      dataRowRenderer: {
        check: "qx.ui.table.IRowRenderer",
        init: null,
        nullable: true,
        event: "changeDataRowRenderer"
      },

      /**
       * A function to call when before modal cell editor is opened.
       *
       * @signature function(cellEditor, cellInfo)
       *
       * @param cellEditor {qx.ui.window.Window}
       *   The modal window which has been created for this cell editor
       *
       * @param cellInfo {Map}
       *   Information about the cell for which this cell editor was created.
       *   It contains the following properties:
       *       col, row, xPos, value
       *
       */
      modalCellEditorPreOpenFunction: {
        check: "Function",
        init: null,
        nullable: true
      },

      /**
       * By default, all Scrollers' (meta-columns') horizontal scrollbars are
       * shown if any one is required. Allow not showing any that are not
       * required.
       */
      excludeScrollerScrollbarsIfNotNeeded: {
        check: "Boolean",
        init: false,
        nullable: false
      },

      /**
       * A function to instantiate a new column menu button.
       */
      newColumnMenu: {
        check: "Function",
        init: function init() {
          return new qx.ui.table.columnmenu.Button();
        }
      },

      /**
       * A function to instantiate a selection manager.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property must
       * be set before calling the Table constructor.
       */
      newSelectionManager: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.table.selection.Manager(obj);
        }
      },

      /**
       * A function to instantiate a selection model.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property must
       * be set before calling the Table constructor.
       */
      newSelectionModel: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.table.selection.Model(obj);
        }
      },

      /**
       * A function to instantiate a table column model.  This allows subclasses
       * of Table to subclass this internal class.  To take effect, this
       * property must be set before calling the Table constructor.
       */
      newTableColumnModel: {
        check: "Function",
        init: function init(table) {
          return new qx.ui.table.columnmodel.Basic(table);
        }
      },

      /**
       * A function to instantiate a table pane.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property
       * must be set before calling the Table constructor.
       */
      newTablePane: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.table.pane.Pane(obj);
        }
      },

      /**
       * A function to instantiate a table pane.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property
       * must be set before calling the Table constructor.
       */
      newTablePaneHeader: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.table.pane.Header(obj);
        }
      },

      /**
       * A function to instantiate a table pane scroller.  this allows
       * subclasses of Table to subclass this internal class.  To take effect,
       * this property must be set before calling the Table constructor.
       */
      newTablePaneScroller: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.table.pane.Scroller(obj);
        }
      },

      /**
       * A function to instantiate a table pane model.  this allows subclasses
       * of Table to subclass this internal class.  To take effect, this
       * property must be set before calling the Table constructor.
       */
      newTablePaneModel: {
        check: "Function",
        init: function init(columnModel) {
          return new qx.ui.table.pane.Model(columnModel);
        }
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __focusedCol__P_503_2: null,
      __focusedRow__P_503_3: null,
      __scrollerParent__P_503_0: null,
      __selectionManager__P_503_1: null,
      __additionalStatusBarText__P_503_5: null,
      __lastRowCount__P_503_6: null,
      __internalChange__P_503_7: null,
      __columnMenuButtons__P_503_8: null,
      __columnModel__P_503_9: null,
      __emptyTableModel__P_503_10: null,
      __hadVerticalScrollBar__P_503_11: null,
      __timer__P_503_12: null,
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "statusbar":
            control = new qx.ui.basic.Label();
            control.set({
              allowGrowX: true
            });

            this._add(control);

            break;

          case "column-button":
            control = this.getNewColumnMenu()();
            control.set({
              focusable: false
            }); // Create the initial menu too

            var menu = control.factory("menu", {
              table: this
            }); // Add a listener to initialize the column menu when it becomes visible

            menu.addListener("appear", this._initColumnMenu, this);
            break;
        }

        return control || qx.ui.table.Table.prototype._createChildControlImpl.base.call(this, id);
      },
      // property modifier
      _applySelectionModel: function _applySelectionModel(value, old) {
        this.__selectionManager__P_503_1.setSelectionModel(value);

        if (old != null) {
          old.removeListener("changeSelection", this._onSelectionChanged, this);
        }

        value.addListener("changeSelection", this._onSelectionChanged, this);
      },
      // property modifier
      _applyRowHeight: function _applyRowHeight(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].updateVerScrollBarMaximum();
        }
      },
      // property modifier
      _applyHeaderCellsVisible: function _applyHeaderCellsVisible(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          if (value) {
            scrollerArr[i]._showChildControl("header");
          } else {
            scrollerArr[i]._excludeChildControl("header");
          }
        } // also hide the column visibility button


        if (this.getColumnVisibilityButtonVisible()) {
          this._applyColumnVisibilityButtonVisible(value);
        }
      },
      // property modifier
      _applyHeaderCellHeight: function _applyHeaderCellHeight(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].getHeader().setHeight(value);
        }
      },

      /**
       * Get an empty table model instance to use for this table. Use this table
       * to configure the table with no table model.
       *
       * @return {qx.ui.table.ITableModel} The empty table model
       */
      getEmptyTableModel: function getEmptyTableModel() {
        if (!this.__emptyTableModel__P_503_10) {
          this.__emptyTableModel__P_503_10 = new qx.ui.table.model.Simple();

          this.__emptyTableModel__P_503_10.setColumns([]);

          this.__emptyTableModel__P_503_10.setData([]);
        }

        return this.__emptyTableModel__P_503_10;
      },
      // property modifier
      _applyTableModel: function _applyTableModel(value, old) {
        this.getTableColumnModel().init(value.getColumnCount(), this);

        if (old != null) {
          old.removeListener("metaDataChanged", this._onTableModelMetaDataChanged, this);
          old.removeListener("dataChanged", this._onTableModelDataChanged, this);
        }

        value.addListener("metaDataChanged", this._onTableModelMetaDataChanged, this);
        value.addListener("dataChanged", this._onTableModelDataChanged, this); // Update the status bar

        this._updateStatusBar();

        this._updateTableData(0, value.getRowCount(), 0, value.getColumnCount());

        this._onTableModelMetaDataChanged(); // If the table model has an init() method, call it. We don't, however,
        // call it if this is the initial setting of the table model, as the
        // scrollers are not yet initialized. In that case, the init method is
        // called explicitly by the Table constructor.


        if (old && value.init && typeof value.init == "function") {
          value.init(this);
        }
      },

      /**
       * Get the The table column model.
       *
       * @return {qx.ui.table.columnmodel.Basic} The table's column model
       */
      getTableColumnModel: function getTableColumnModel() {
        if (!this.__columnModel__P_503_9) {
          var columnModel = this.__columnModel__P_503_9 = this.getNewTableColumnModel()(this);
          columnModel.addListener("visibilityChanged", this._onColVisibilityChanged, this);
          columnModel.addListener("widthChanged", this._onColWidthChanged, this);
          columnModel.addListener("orderChanged", this._onColOrderChanged, this); // Get the current table model

          var tableModel = this.getTableModel();
          columnModel.init(tableModel.getColumnCount(), this); // Reset the table column model in each table pane model

          var scrollerArr = this._getPaneScrollerArr();

          for (var i = 0; i < scrollerArr.length; i++) {
            var paneScroller = scrollerArr[i];
            var paneModel = paneScroller.getTablePaneModel();
            paneModel.setTableColumnModel(columnModel);
          }
        }

        return this.__columnModel__P_503_9;
      },
      // property modifier
      _applyStatusBarVisible: function _applyStatusBarVisible(value, old) {
        if (value) {
          this._showChildControl("statusbar");
        } else {
          this._excludeChildControl("statusbar");
        }

        if (value) {
          this._updateStatusBar();
        }
      },
      // property modifier
      _applyAdditionalStatusBarText: function _applyAdditionalStatusBarText(value, old) {
        this.__additionalStatusBarText__P_503_5 = value;

        this._updateStatusBar();
      },
      // property modifier
      _applyColumnVisibilityButtonVisible: function _applyColumnVisibilityButtonVisible(value, old) {
        if (value) {
          this._showChildControl("column-button");
        } else {
          this._excludeChildControl("column-button");
        }
      },
      // property modifier
      _applyMetaColumnCounts: function _applyMetaColumnCounts(value, old) {
        var metaColumnCounts = value;

        var scrollerArr = this._getPaneScrollerArr();

        var handlers = {};

        if (value > old) {
          // Save event listeners on the redirected events so we can re-apply
          // them to new scrollers.
          var manager = qx.event.Registration.getManager(scrollerArr[0]);

          for (var evName in qx.ui.table.Table.__redirectEvents__P_503_4) {
            handlers[evName] = {};
            handlers[evName].capture = manager.getListeners(scrollerArr[0], evName, true);
            handlers[evName].bubble = manager.getListeners(scrollerArr[0], evName, false);
          }
        } // Remove the panes not needed any more


        this._cleanUpMetaColumns(metaColumnCounts.length); // Update the old panes


        var leftX = 0;

        for (var i = 0; i < scrollerArr.length; i++) {
          var paneScroller = scrollerArr[i];
          var paneModel = paneScroller.getTablePaneModel();
          paneModel.setFirstColumnX(leftX);
          paneModel.setMaxColumnCount(metaColumnCounts[i]);
          leftX += metaColumnCounts[i];
        } // Add the new panes


        if (metaColumnCounts.length > scrollerArr.length) {
          var columnModel = this.getTableColumnModel();

          for (var i = scrollerArr.length; i < metaColumnCounts.length; i++) {
            var paneModel = this.getNewTablePaneModel()(columnModel);
            paneModel.setFirstColumnX(leftX);
            paneModel.setMaxColumnCount(metaColumnCounts[i]);
            leftX += metaColumnCounts[i];
            var paneScroller = this.getNewTablePaneScroller()(this);
            paneScroller.setTablePaneModel(paneModel); // Register event listener for vertical scrolling

            paneScroller.addListener("changeScrollY", this._onScrollY, this); // Apply redirected events to this new scroller

            for (evName in qx.ui.table.Table.__redirectEvents__P_503_4) {
              // On first setting of meta columns (constructing phase), there
              // are no handlers to deal with yet.
              if (!handlers[evName]) {
                break;
              }

              if (handlers[evName].capture && handlers[evName].capture.length > 0) {
                var capture = handlers[evName].capture;

                for (var j = 0; j < capture.length; j++) {
                  // Determine what context to use.  If the context does not
                  // exist, we assume that the context is this table.  If it
                  // does exist and it equals the first pane scroller (from
                  // which we retrieved the listeners) then set the context
                  // to be this new pane scroller.  Otherwise leave the context
                  // as it was set.
                  var context = capture[j].context;

                  if (!context) {
                    context = this;
                  } else if (context == scrollerArr[0]) {
                    context = paneScroller;
                  }

                  paneScroller.addListener(evName, capture[j].handler, context, true);
                }
              }

              if (handlers[evName].bubble && handlers[evName].bubble.length > 0) {
                var bubble = handlers[evName].bubble;

                for (var j = 0; j < bubble.length; j++) {
                  // Determine what context to use.  If the context does not
                  // exist, we assume that the context is this table.  If it
                  // does exist and it equals the first pane scroller (from
                  // which we retrieved the listeners) then set the context
                  // to be this new pane scroller.  Otherwise leave the context
                  // as it was set.
                  var context = bubble[j].context;

                  if (!context) {
                    context = this;
                  } else if (context == scrollerArr[0]) {
                    context = paneScroller;
                  }

                  paneScroller.addListener(evName, bubble[j].handler, context, false);
                }
              }
            } // last meta column is flexible


            var flex = i == metaColumnCounts.length - 1 ? 1 : 0;

            this.__scrollerParent__P_503_0.add(paneScroller, {
              flex: flex
            });

            scrollerArr = this._getPaneScrollerArr();
          }
        } // Update all meta columns


        for (var i = 0; i < scrollerArr.length; i++) {
          var paneScroller = scrollerArr[i];
          var isLast = i == scrollerArr.length - 1; // Set the right header height

          paneScroller.getHeader().setHeight(this.getHeaderCellHeight()); // Put the column visibility button in the top right corner of the last meta column

          paneScroller.setTopRightWidget(isLast ? this.getChildControl("column-button") : null);
        }

        if (!this.isColumnVisibilityButtonVisible()) {
          this._excludeChildControl("column-button");
        }

        this._updateScrollerWidths();

        this._updateScrollBarVisibility();
      },
      // property modifier
      _applyFocusCellOnPointerMove: function _applyFocusCellOnPointerMove(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].setFocusCellOnPointerMove(value);
        }
      },
      // property modifier
      _applyShowCellFocusIndicator: function _applyShowCellFocusIndicator(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].setShowCellFocusIndicator(value);
        }
      },
      // property modifier
      _applyContextMenuFromDataCellsOnly: function _applyContextMenuFromDataCellsOnly(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].setContextMenuFromDataCellsOnly(value);
        }
      },
      // property modifier
      _applyKeepFirstVisibleRowComplete: function _applyKeepFirstVisibleRowComplete(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onKeepFirstVisibleRowCompleteChanged();
        }
      },
      // property modifier
      _applyResetSelectionOnHeaderTap: function _applyResetSelectionOnHeaderTap(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].setResetSelectionOnHeaderTap(value);
        }
      },
      // property modifier
      _applyResetSelectionOnTapBelowRows: function _applyResetSelectionOnTapBelowRows(value, old) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].setResetSelectionOnTapBelowRows(value);
        }
      },

      /**
       * Returns the selection manager.
       *
       * @return {qx.ui.table.selection.Manager} the selection manager.
       */
      getSelectionManager: function getSelectionManager() {
        return this.__selectionManager__P_503_1;
      },

      /**
       * Returns an array containing all TablePaneScrollers in this table.
       *
       * @return {qx.ui.table.pane.Scroller[]} all TablePaneScrollers in this table.
       */
      _getPaneScrollerArr: function _getPaneScrollerArr() {
        return this.__scrollerParent__P_503_0.getChildren();
      },

      /**
       * Returns a TablePaneScroller of this table.
       *
       * @param metaColumn {Integer} the meta column to get the TablePaneScroller for.
       * @return {qx.ui.table.pane.Scroller} the qx.ui.table.pane.Scroller.
       */
      getPaneScroller: function getPaneScroller(metaColumn) {
        return this._getPaneScrollerArr()[metaColumn];
      },

      /**
       * Cleans up the meta columns.
       *
       * @param fromMetaColumn {Integer} the first meta column to clean up. All following
       *      meta columns will be cleaned up, too. All previous meta columns will
       *      stay unchanged. If 0 all meta columns will be cleaned up.
       */
      _cleanUpMetaColumns: function _cleanUpMetaColumns(fromMetaColumn) {
        var scrollerArr = this._getPaneScrollerArr();

        if (scrollerArr != null) {
          for (var i = scrollerArr.length - 1; i >= fromMetaColumn; i--) {
            scrollerArr[i].destroy();
          }
        }
      },

      /**
       * Event handler. Called when the locale has changed.
       *
       * @param evt {Event} the event.
       */
      _onChangeLocale: function _onChangeLocale(evt) {
        this.updateContent();

        this._updateStatusBar();
      },
      // overridden
      _onChangeTheme: function _onChangeTheme() {
        qx.ui.table.Table.prototype._onChangeTheme.base.call(this);

        this.getDataRowRenderer().initThemeValues();
        this.updateContent();

        this._updateStatusBar();
      },

      /**
       * Event handler. Called when the selection has changed.
       *
       * @param evt {Map} the event.
       */
      _onSelectionChanged: function _onSelectionChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onSelectionChanged();
        }

        this._updateStatusBar();
      },

      /**
       * Event handler. Called when the table model meta data has changed.
       *
       * @param evt {Map} the event.
       */
      _onTableModelMetaDataChanged: function _onTableModelMetaDataChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onTableModelMetaDataChanged();
        }

        this._updateStatusBar();
      },

      /**
       * Event handler. Called when the table model data has changed.
       *
       * @param evt {Map} the event.
       */
      _onTableModelDataChanged: function _onTableModelDataChanged(evt) {
        var data = evt.getData();

        this._updateTableData(data.firstRow, data.lastRow, data.firstColumn, data.lastColumn, data.removeStart, data.removeCount);
      },
      // overridden
      _onContextMenuOpen: function _onContextMenuOpen(e) {// This is Widget's context menu handler which typically retrieves
        // and displays the menu as soon as it receives a "contextmenu" event.
        // We want to allow the cellContextmenu handler to create the menu,
        // so we'll override this method with a null one, and do the menu
        // placement and display handling in our _onContextMenu method.
      },

      /**
       * To update the table if the table model has changed and remove selection.
       *
       * @param firstRow {Integer} The index of the first row that has changed.
       * @param lastRow {Integer} The index of the last row that has changed.
       * @param firstColumn {Integer} The model index of the first column that has changed.
       * @param lastColumn {Integer} The model index of the last column that has changed.
       * @param removeStart {Integer ? null} The first index of the interval (including), to remove selection.
       * @param removeCount {Integer ? null} The count of the interval, to remove selection.
       */
      _updateTableData: function _updateTableData(firstRow, lastRow, firstColumn, lastColumn, removeStart, removeCount) {
        var scrollerArr = this._getPaneScrollerArr(); // update selection if rows were removed


        if (removeCount) {
          this.getSelectionModel().removeSelectionInterval(removeStart, removeStart + removeCount - 1, true); // remove focus if the focused row has been removed

          if (this.__focusedRow__P_503_3 >= removeStart && this.__focusedRow__P_503_3 < removeStart + removeCount) {
            this.setFocusedCell();
          }
        }

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onTableModelDataChanged(firstRow, lastRow, firstColumn, lastColumn);
        }

        var rowCount = this.getTableModel().getRowCount();

        if (rowCount != this.__lastRowCount__P_503_6) {
          this.__lastRowCount__P_503_6 = rowCount;

          this._updateScrollBarVisibility();

          this._updateStatusBar();
        }
      },

      /**
       * Event handler. Called when a TablePaneScroller has been scrolled vertically.
       *
       * @param evt {Map} the event.
       */
      _onScrollY: function _onScrollY(evt) {
        if (!this.__internalChange__P_503_7) {
          this.__internalChange__P_503_7 = true; // Set the same scroll position to all meta columns

          var scrollerArr = this._getPaneScrollerArr();

          for (var i = 0; i < scrollerArr.length; i++) {
            scrollerArr[i].setScrollY(evt.getData());
          }

          this.__internalChange__P_503_7 = false;
        }
      },

      /**
       * Event handler. Called when a key was pressed.
       *
       * @param evt {qx.event.type.KeySequence} the event.
       * @deprecated {6.0} please use _onKeyDown instead!
       */
      _onKeyPress: function _onKeyPress(evt) {
        qx.log.Logger.deprecatedMethodWarning(this._onKeyPress, "The method '_onKeyPress()' is deprecated. Please use '_onKeyDown()' instead.");
        qx.log.Logger.deprecateMethodOverriding(this, qx.ui.table.Table, "_onKeyPress", "The method '_onKeyPress()' is deprecated. Please use '_onKeyDown()' instead.");

        this._onKeyDown(evt);
      },

      /**
       * Event handler. Called when on key down event
       *
       * @param evt {qx.event.type.KeySequence} the event.
       */
      _onKeyDown: function _onKeyDown(evt) {
        if (!this.getEnabled()) {
          return;
        } // No editing mode


        var oldFocusedRow = this.__focusedRow__P_503_3;
        var consumed = false; // Handle keys that are independent from the modifiers

        var identifier = evt.getKeyIdentifier();

        if (this.isEditing()) {
          // Editing mode
          if (evt.getModifiers() == 0) {
            switch (identifier) {
              case "Enter":
                this.stopEditing();
                var oldFocusedRow = this.__focusedRow__P_503_3;
                this.moveFocusedCell(0, 1);

                if (this.__focusedRow__P_503_3 != oldFocusedRow) {
                  consumed = this.startEditing();
                }

                break;

              case "Escape":
                this.cancelEditing();
                this.focus();
                break;

              default:
                consumed = false;
                break;
            }
          }
        } else {
          consumed = true; // No editing mode

          if (evt.isCtrlPressed()) {
            // Handle keys that depend on modifiers
            switch (identifier) {
              case "A":
                // Ctrl + A
                var rowCount = this.getTableModel().getRowCount();

                if (rowCount > 0) {
                  this.getSelectionModel().setSelectionInterval(0, rowCount - 1);
                }

                break;

              default:
                consumed = false;
                break;
            }
          } else {
            // Handle keys that are independent from the modifiers
            switch (identifier) {
              case "Space":
                this.__selectionManager__P_503_1.handleSelectKeyDown(this.__focusedRow__P_503_3, evt);

                break;

              case "F2":
              case "Enter":
                this.startEditing();
                consumed = true;
                break;

              case "Home":
                this.setFocusedCell(this.__focusedCol__P_503_2, 0, true);
                break;

              case "End":
                var rowCount = this.getTableModel().getRowCount();
                this.setFocusedCell(this.__focusedCol__P_503_2, rowCount - 1, true);
                break;

              case "Left":
                this.moveFocusedCell(-1, 0);
                break;

              case "Right":
                this.moveFocusedCell(1, 0);
                break;

              case "Up":
                this.moveFocusedCell(0, -1);
                break;

              case "Down":
                this.moveFocusedCell(0, 1);
                break;

              case "PageUp":
              case "PageDown":
                var scroller = this.getPaneScroller(0);
                var pane = scroller.getTablePane();
                var rowHeight = this.getRowHeight();
                var direction = identifier == "PageUp" ? -1 : 1;
                rowCount = pane.getVisibleRowCount() - 1;
                scroller.setScrollY(scroller.getScrollY() + direction * rowCount * rowHeight);
                this.moveFocusedCell(0, direction * rowCount);
                break;

              default:
                consumed = false;
            }
          }
        }

        if (oldFocusedRow != this.__focusedRow__P_503_3 && this.getRowFocusChangeModifiesSelection()) {
          // The focus moved -> Let the selection manager handle this event
          this.__selectionManager__P_503_1.handleMoveKeyDown(this.__focusedRow__P_503_3, evt);
        }

        if (consumed) {
          evt.preventDefault();
          evt.stopPropagation();
        }
      },

      /**
       * Event handler. Called when the table gets the focus.
       *
       * @param evt {Map} the event.
       */
      _onFocusChanged: function _onFocusChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onFocusChanged();
        }
      },

      /**
       * Event handler. Called when the visibility of a column has changed.
       *
       * @param evt {Map} the event.
       */
      _onColVisibilityChanged: function _onColVisibilityChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onColVisibilityChanged();
        }

        var data = evt.getData();

        if (this.__columnMenuButtons__P_503_8 != null && data.col != null && data.visible != null) {
          this.__columnMenuButtons__P_503_8[data.col].setColumnVisible(data.visible);
        }

        this._updateScrollerWidths();

        this._updateScrollBarVisibility();
      },

      /**
       * Event handler. Called when the width of a column has changed.
       *
       * @param evt {Map} the event.
       */
      _onColWidthChanged: function _onColWidthChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          var data = evt.getData();
          scrollerArr[i].setColumnWidth(data.col, data.newWidth);
        }

        this._updateScrollerWidths();

        this._updateScrollBarVisibility();
      },

      /**
       * Event handler. Called when the column order has changed.
       *
       * @param evt {Map} the event.
       */
      _onColOrderChanged: function _onColOrderChanged(evt) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].onColOrderChanged();
        } // A column may have been moved between meta columns


        this._updateScrollerWidths();

        this._updateScrollBarVisibility();
      },

      /**
       * Gets the TablePaneScroller at a certain x position in the page. If there is
       * no TablePaneScroller at this position, null is returned.
       *
       * @param pageX {Integer} the position in the page to check (in pixels).
       * @return {qx.ui.table.pane.Scroller} the TablePaneScroller or null.
       */
      getTablePaneScrollerAtPageX: function getTablePaneScrollerAtPageX(pageX) {
        var metaCol = this._getMetaColumnAtPageX(pageX);

        return metaCol != -1 ? this.getPaneScroller(metaCol) : null;
      },

      /**
       * Sets the currently focused cell. A value of <code>null</code> hides the
       * focus cell.
       *
       * @param col {Integer?null} the model index of the focused cell's column.
       * @param row {Integer?null} the model index of the focused cell's row.
       * @param scrollVisible {Boolean ? false} whether to scroll the new focused cell
       *          visible.
       */
      setFocusedCell: function setFocusedCell(col, row, scrollVisible) {
        if (!this.isEditing() && (col != this.__focusedCol__P_503_2 || row != this.__focusedRow__P_503_3)) {
          if (col === null) {
            col = 0;
          }

          this.__focusedCol__P_503_2 = col;
          this.__focusedRow__P_503_3 = row;

          var scrollerArr = this._getPaneScrollerArr();

          for (var i = 0; i < scrollerArr.length; i++) {
            scrollerArr[i].setFocusedCell(col, row);
          }

          if (col != null && scrollVisible) {
            this.scrollCellVisible(col, row);
          }
        }
      },

      /**
       * Resets (clears) the current selection
       */
      resetSelection: function resetSelection() {
        this.getSelectionModel().resetSelection();
      },

      /**
       * Resets the focused cell.
       */
      resetCellFocus: function resetCellFocus() {
        this.setFocusedCell(null, null, false);
      },

      /**
       * Returns the column of the currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedColumn: function getFocusedColumn() {
        return this.__focusedCol__P_503_2;
      },

      /**
       * Returns the row of the currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedRow: function getFocusedRow() {
        return this.__focusedRow__P_503_3;
      },

      /**
       * Select whether the focused row is highlighted
       *
       * @param bHighlight {Boolean}
       *   Flag indicating whether the focused row should be highlighted.
       *
       */
      highlightFocusedRow: function highlightFocusedRow(bHighlight) {
        this.getDataRowRenderer().setHighlightFocusRow(bHighlight);
      },

      /**
       * Remove the highlighting of the current focus row.
       *
       * This is used to temporarily remove the highlighting of the currently
       * focused row, and is expected to be used most typically by adding a
       * listener on the "pointerout" event, so that the focus highlighting is
       * suspended when the pointer leaves the table:
       *
       *     table.addListener("pointerout", table.clearFocusedRowHighlight);
       *
       * @param evt {qx.event.type.Pointer} Incoming pointer event
       */
      clearFocusedRowHighlight: function clearFocusedRowHighlight(evt) {
        if (evt) {
          var relatedTarget = evt.getRelatedTarget();

          if (relatedTarget instanceof qx.ui.table.pane.Pane || relatedTarget instanceof qx.ui.table.pane.FocusIndicator) {
            return;
          }
        } // Remove focus from any cell that has it


        this.resetCellFocus(); // Now, for each pane scroller...

        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          // ... repaint without focus.
          scrollerArr[i].onFocusChanged();
        }
      },

      /**
       * Moves the focus.
       *
       * @param deltaX {Integer} The delta by which the focus should be moved on the x axis.
       * @param deltaY {Integer} The delta by which the focus should be moved on the y axis.
       */
      moveFocusedCell: function moveFocusedCell(deltaX, deltaY) {
        var col = this.__focusedCol__P_503_2;
        var row = this.__focusedRow__P_503_3; // could also be undefined [BUG #4676]

        if (col == null || row == null) {
          return;
        }

        if (deltaX != 0) {
          var columnModel = this.getTableColumnModel();
          var x = columnModel.getVisibleX(col);
          var colCount = columnModel.getVisibleColumnCount();
          x = qx.lang.Number.limit(x + deltaX, 0, colCount - 1);
          col = columnModel.getVisibleColumnAtX(x);
        }

        if (deltaY != 0) {
          var tableModel = this.getTableModel();
          row = qx.lang.Number.limit(row + deltaY, 0, tableModel.getRowCount() - 1);
        }

        this.setFocusedCell(col, row, true);
      },

      /**
       * Scrolls a cell visible.
       *
       * @param col {Integer} the model index of the column the cell belongs to.
       * @param row {Integer} the model index of the row the cell belongs to.
       */
      scrollCellVisible: function scrollCellVisible(col, row) {
        // get the dom element
        var elem = this.getContentElement().getDomElement(); // if the dom element is not available, the table hasn't been rendered

        if (!elem) {
          // postpone the scroll until the table has appeared
          this.addListenerOnce("appear", function () {
            this.scrollCellVisible(col, row);
          }, this);
        }

        var columnModel = this.getTableColumnModel();
        var x = columnModel.getVisibleX(col);

        var metaColumn = this._getMetaColumnAtColumnX(x);

        if (metaColumn != -1) {
          this.getPaneScroller(metaColumn).scrollCellVisible(col, row);
        }
      },

      /**
       * Returns whether currently a cell is editing.
       *
       * @return {var} whether currently a cell is editing.
       */
      isEditing: function isEditing() {
        if (this.__focusedCol__P_503_2 != null) {
          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol__P_503_2);

          var metaColumn = this._getMetaColumnAtColumnX(x);

          return this.getPaneScroller(metaColumn).isEditing();
        }

        return false;
      },

      /**
       * Starts editing the currently focused cell. Does nothing if already editing
       * or if the column is not editable.
       *
       * @return {Boolean} whether editing was started
       */
      startEditing: function startEditing() {
        if (this.__focusedCol__P_503_2 != null) {
          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol__P_503_2);

          var metaColumn = this._getMetaColumnAtColumnX(x);

          var started = this.getPaneScroller(metaColumn).startEditing();
          return started;
        }

        return false;
      },

      /**
       * Stops editing and writes the editor's value to the model.
       */
      stopEditing: function stopEditing() {
        if (this.__focusedCol__P_503_2 != null) {
          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol__P_503_2);

          var metaColumn = this._getMetaColumnAtColumnX(x);

          this.getPaneScroller(metaColumn).stopEditing();
        }
      },

      /**
       * Stops editing without writing the editor's value to the model.
       */
      cancelEditing: function cancelEditing() {
        if (this.__focusedCol__P_503_2 != null) {
          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol__P_503_2);

          var metaColumn = this._getMetaColumnAtColumnX(x);

          this.getPaneScroller(metaColumn).cancelEditing();
        }
      },

      /**
       * Update the table content of every attached table pane.
       */
      updateContent: function updateContent() {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].getTablePane().updateContent(true);
        }
      },

      /**
       * Activates the blocker widgets on all column headers and the
       * column button
       */
      blockHeaderElements: function blockHeaderElements() {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].getHeader().getBlocker().blockContent(20);
        }

        this.getChildControl("column-button").getBlocker().blockContent(20);
      },

      /**
       * Deactivates the blocker widgets on all column headers and the
       * column button
       */
      unblockHeaderElements: function unblockHeaderElements() {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          scrollerArr[i].getHeader().getBlocker().unblock();
        }

        this.getChildControl("column-button").getBlocker().unblock();
      },

      /**
       * Gets the meta column at a certain x position in the page. If there is no
       * meta column at this position, -1 is returned.
       *
       * @param pageX {Integer} the position in the page to check (in pixels).
       * @return {Integer} the index of the meta column or -1.
       */
      _getMetaColumnAtPageX: function _getMetaColumnAtPageX(pageX) {
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          var pos = scrollerArr[i].getContentLocation();

          if (pageX >= pos.left && pageX <= pos.right) {
            return i;
          }
        }

        return -1;
      },

      /**
       * Returns the meta column a column is shown in. If the column is not shown at
       * all, -1 is returned.
       *
       * @param visXPos {Integer} the visible x position of the column.
       * @return {Integer} the meta column the column is shown in.
       */
      _getMetaColumnAtColumnX: function _getMetaColumnAtColumnX(visXPos) {
        var metaColumnCounts = this.getMetaColumnCounts();
        var rightXPos = 0;

        for (var i = 0; i < metaColumnCounts.length; i++) {
          var counts = metaColumnCounts[i];
          rightXPos += counts;

          if (counts == -1 || visXPos < rightXPos) {
            return i;
          }
        }

        return -1;
      },

      /**
       * Updates the text shown in the status bar.
       */
      _updateStatusBar: function _updateStatusBar() {
        var tableModel = this.getTableModel();

        if (this.getStatusBarVisible()) {
          var selectedRowCount = this.getSelectionModel().getSelectedCount();
          var rowCount = tableModel.getRowCount();
          var text;

          if (rowCount >= 0) {
            if (selectedRowCount == 0) {
              text = this.trn("one row", "%1 rows", rowCount, rowCount);
            } else {
              text = this.trn("one of one row", "%1 of %2 rows", rowCount, selectedRowCount, rowCount);
            }
          }

          if (this.__additionalStatusBarText__P_503_5) {
            if (text) {
              text += this.__additionalStatusBarText__P_503_5;
            } else {
              text = this.__additionalStatusBarText__P_503_5;
            }
          }

          if (text) {
            this.getChildControl("statusbar").setValue(text);
          }
        }
      },

      /**
       * Updates the widths of all scrollers.
       */
      _updateScrollerWidths: function _updateScrollerWidths() {
        // Give all scrollers except for the last one the wanted width
        // (The last one has a flex with)
        var scrollerArr = this._getPaneScrollerArr();

        for (var i = 0; i < scrollerArr.length; i++) {
          var isLast = i == scrollerArr.length - 1;
          var width = scrollerArr[i].getTablePaneModel().getTotalWidth();
          scrollerArr[i].setPaneWidth(width);
          var flex = isLast ? 1 : 0;
          scrollerArr[i].setLayoutProperties({
            flex: flex
          });
        }
      },

      /**
       * Updates the visibility of the scrollbars in the meta columns.
       */
      _updateScrollBarVisibility: function _updateScrollBarVisibility() {
        if (!this.getBounds()) {
          return;
        }

        var horBar = qx.ui.table.pane.Scroller.HORIZONTAL_SCROLLBAR;
        var verBar = qx.ui.table.pane.Scroller.VERTICAL_SCROLLBAR;

        var scrollerArr = this._getPaneScrollerArr(); // Check which scroll bars are needed


        var horNeeded = false;
        var verNeeded = false;
        var excludeScrollerScrollbarsIfNotNeeded; // Determine whether we need to render horizontal scrollbars for meta
        // columns that don't themselves actually require it

        excludeScrollerScrollbarsIfNotNeeded = this.getExcludeScrollerScrollbarsIfNotNeeded();

        if (!excludeScrollerScrollbarsIfNotNeeded) {
          for (var i = 0; i < scrollerArr.length; i++) {
            var isLast = i == scrollerArr.length - 1; // Only show the last vertical scrollbar

            var bars = scrollerArr[i].getNeededScrollBars(horNeeded, !isLast);

            if (bars & horBar) {
              horNeeded = true;
            }

            if (isLast && bars & verBar) {
              verNeeded = true;
            }
          }
        } // Set the needed scrollbars


        for (var i = 0; i < scrollerArr.length; i++) {
          isLast = i == scrollerArr.length - 1; // If we don't want to include scrollbars for meta columns that don't
          // require it, find out whether this meta column requires it.

          if (excludeScrollerScrollbarsIfNotNeeded) {
            horNeeded = !!(scrollerArr[i].getNeededScrollBars(false, !isLast) & horBar); // Show the horizontal scrollbar if needed. Specify null to indicate
            // that the scrollbar should be hidden rather than excluded.

            scrollerArr[i].setHorizontalScrollBarVisible(horNeeded || null);
          } else {
            // Show the horizontal scrollbar if needed.
            scrollerArr[i].setHorizontalScrollBarVisible(horNeeded);
          } // If this is the last meta-column...


          if (isLast) {
            // ... then get the current (old) use of vertical scroll bar
            verNeeded = !!(scrollerArr[i].getNeededScrollBars(false, false) & verBar);

            if (this.__hadVerticalScrollBar__P_503_11 == null) {
              this.__hadVerticalScrollBar__P_503_11 = scrollerArr[i].getVerticalScrollBarVisible();
              this.__timer__P_503_12 = qx.event.Timer.once(function () {
                // reset the last visible state of the vertical scroll bar
                // in a timeout to prevent infinite loops.
                this.__hadVerticalScrollBar__P_503_11 = null;
                this.__timer__P_503_12 = null;
              }, this, 0);
            }
          }

          scrollerArr[i].setVerticalScrollBarVisible(isLast && verNeeded); // If this is the last meta-column and the use of a vertical scroll bar
          // has changed...

          if (isLast && verNeeded != this.__hadVerticalScrollBar__P_503_11) {
            // ... then dispatch an event to any awaiting listeners
            this.fireDataEvent("verticalScrollBarChanged", verNeeded);
          }
        }
      },

      /**
       * Initialize the column menu
       */
      _initColumnMenu: function _initColumnMenu() {
        var tableModel = this.getTableModel();
        var columnModel = this.getTableColumnModel();
        var columnButton = this.getChildControl("column-button"); // Remove all items from the menu. We'll rebuild it here.

        columnButton.empty(); // Inform listeners who may want to insert menu items at the beginning

        var menu = columnButton.getMenu();
        var data = {
          table: this,
          menu: menu,
          columnButton: columnButton
        };
        this.fireDataEvent("columnVisibilityMenuCreateStart", data);
        this.__columnMenuButtons__P_503_8 = {};

        for (var col = 0, l = tableModel.getColumnCount(); col < l; col++) {
          var menuButton = columnButton.factory("menu-button", {
            text: tableModel.getColumnName(col),
            column: col,
            bVisible: columnModel.isColumnVisible(col)
          });
          qx.core.Assert.assertInterface(menuButton, qx.ui.table.IColumnMenuItem);
          menuButton.addListener("changeColumnVisible", this._createColumnVisibilityCheckBoxHandler(col), this);
          this.__columnMenuButtons__P_503_8[col] = menuButton;
        } // Inform listeners who may want to insert menu items at the end


        data = {
          table: this,
          menu: menu,
          columnButton: columnButton
        };
        this.fireDataEvent("columnVisibilityMenuCreateEnd", data);
      },

      /**
       * Creates a handler for a check box of the column visibility menu.
       *
       * @param col {Integer} the model index of column to create the handler for.
       * @return {Function} The created event handler.
       */
      _createColumnVisibilityCheckBoxHandler: function _createColumnVisibilityCheckBoxHandler(col) {
        return function (evt) {
          var columnModel = this.getTableColumnModel();
          columnModel.setColumnVisible(col, evt.getData());
        };
      },

      /**
       * Sets the width of a column.
       *
       * @param col {Integer} the model index of column.
       * @param width {Integer} the new width in pixels.
       */
      setColumnWidth: function setColumnWidth(col, width) {
        this.getTableColumnModel().setColumnWidth(col, width);
      },

      /**
       * Resize event handler
       */
      _onResize: function _onResize() {
        this.fireEvent("tableWidthChanged");

        this._updateScrollerWidths();

        this._updateScrollBarVisibility();
      },
      // overridden
      addListener: function addListener(type, listener, self, capture) {
        if (qx.ui.table.Table.__redirectEvents__P_503_4[type]) {
          // start the id with the type (needed for removing)
          var id = [type];

          for (var i = 0, arr = this._getPaneScrollerArr(); i < arr.length; i++) {
            id.push(arr[i].addListener.apply(arr[i], arguments));
          } // join the id's of every event with "


          return id.join('"');
        } else {
          return qx.ui.table.Table.prototype.addListener.base.call(this, type, listener, self, capture);
        }
      },
      // overridden
      removeListener: function removeListener(type, listener, self, capture) {
        if (qx.ui.table.Table.__redirectEvents__P_503_4[type]) {
          for (var i = 0, arr = this._getPaneScrollerArr(); i < arr.length; i++) {
            arr[i].removeListener.apply(arr[i], arguments);
          }
        } else {
          qx.ui.table.Table.prototype.removeListener.base.call(this, type, listener, self, capture);
        }
      },
      // overridden
      removeListenerById: function removeListenerById(id) {
        var ids = id.split('"'); // type is the first entry of the connected id

        var type = ids.shift();

        if (qx.ui.table.Table.__redirectEvents__P_503_4[type]) {
          var removed = true;

          for (var i = 0, arr = this._getPaneScrollerArr(); i < arr.length; i++) {
            removed = arr[i].removeListenerById.call(arr[i], ids[i]) && removed;
          }

          return removed;
        } else {
          return qx.ui.table.Table.prototype.removeListenerById.base.call(this, id);
        }
      },
      destroy: function destroy() {
        this.getChildControl("column-button").getMenu().destroy();
        qx.ui.table.Table.prototype.destroy.base.call(this);
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      // remove the event listener which handled the locale change
      {
        qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
      } // we allocated these objects on init so we have to clean them up.

      var selectionModel = this.getSelectionModel();

      if (selectionModel) {
        selectionModel.dispose();
      }

      var dataRowRenderer = this.getDataRowRenderer();

      if (dataRowRenderer) {
        dataRowRenderer.dispose();
      }

      this._cleanUpMetaColumns(0);

      this.getTableColumnModel().dispose();

      this._disposeObjects("__selectionManager__P_503_1", "__scrollerParent__P_503_0", "__emptyTableModel__P_503_10", "__emptyTableModel__P_503_10", "__columnModel__P_503_9", "__timer__P_503_12");

      this._disposeMap("__columnMenuButtons__P_503_8");
    }
  });
  qx.ui.table.Table.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.IRowRenderer": {
        "require": true
      },
      "qx.theme.manager.Meta": {
        "construct": true
      },
      "qx.theme.manager.Font": {},
      "qx.theme.manager.Color": {},
      "qx.bom.element.Style": {},
      "qx.bom.Font": {},
      "qx.bom.client.Css": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxmodel": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2007 Visionet GmbH, http://www.visionet.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132) STZ-IDA
       * Dietrich Streifert (level420) Visionet
  
  ************************************************************************ */

  /**
   * The default data row renderer.
   */
  qx.Class.define("qx.ui.table.rowrenderer.Default", {
    extend: qx.core.Object,
    implement: qx.ui.table.IRowRenderer,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.initThemeValues(); // dynamic theme switch

      {
        qx.theme.manager.Meta.getInstance().addListener("changeTheme", this.initThemeValues, this);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Whether the focused row should be highlighted. */
      highlightFocusRow: {
        check: "Boolean",
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _colors: null,
      _fontStyle: null,
      _fontStyleString: null,

      /**
       * Initializes the colors from the color theme.
       * @internal
       */
      initThemeValues: function initThemeValues() {
        this._fontStyleString = "";
        this._fontStyle = {};
        this._colors = {}; // link to font theme

        this._renderFont(qx.theme.manager.Font.getInstance().resolve("default")); // link to color theme


        var colorMgr = qx.theme.manager.Color.getInstance();
        this._colors.bgcolFocusedSelected = colorMgr.resolve("table-row-background-focused-selected");
        this._colors.bgcolFocused = colorMgr.resolve("table-row-background-focused");
        this._colors.bgcolSelected = colorMgr.resolve("table-row-background-selected");
        this._colors.bgcolEven = colorMgr.resolve("table-row-background-even");
        this._colors.bgcolOdd = colorMgr.resolve("table-row-background-odd");
        this._colors.colSelected = colorMgr.resolve("table-row-selected");
        this._colors.colNormal = colorMgr.resolve("table-row");
        this._colors.horLine = colorMgr.resolve("table-row-line");
      },

      /**
       * the sum of the vertical insets. This is needed to compute the box model
       * independent size
       */
      _insetY: 1,
      // borderBottom

      /**
       * Render the new font and update the table pane content
       * to reflect the font change.
       *
       * @param font {qx.bom.Font} The font to use for the table row
       */
      _renderFont: function _renderFont(font) {
        if (font) {
          this._fontStyle = font.getStyles();
          this._fontStyleString = qx.bom.element.Style.compile(this._fontStyle);
          this._fontStyleString = this._fontStyleString.replace(/"/g, "'");
        } else {
          this._fontStyleString = "";
          this._fontStyle = qx.bom.Font.getDefaultStyles();
        }
      },
      // interface implementation
      updateDataRowElement: function updateDataRowElement(rowInfo, rowElem) {
        var fontStyle = this._fontStyle;
        var style = rowElem.style; // set font styles

        qx.bom.element.Style.setStyles(rowElem, fontStyle);

        if (rowInfo.focusedRow && this.getHighlightFocusRow()) {
          style.backgroundColor = rowInfo.selected ? this._colors.bgcolFocusedSelected : this._colors.bgcolFocused;
        } else {
          if (rowInfo.selected) {
            style.backgroundColor = this._colors.bgcolSelected;
          } else {
            style.backgroundColor = rowInfo.row % 2 == 0 ? this._colors.bgcolEven : this._colors.bgcolOdd;
          }
        }

        style.color = rowInfo.selected ? this._colors.colSelected : this._colors.colNormal;
        style.borderBottom = "1px solid " + this._colors.horLine;
      },

      /**
       * Get the row's height CSS style taking the box model into account
       *
       * @param height {Integer} The row's (border-box) height in pixel
       * @return {String} CSS rule for the row height
       */
      getRowHeightStyle: function getRowHeightStyle(height) {
        if (qx.core.Environment.get("css.boxmodel") == "content") {
          height -= this._insetY;
        }

        return "height:" + height + "px;";
      },
      // interface implementation
      createRowStyle: function createRowStyle(rowInfo) {
        var rowStyle = [];
        rowStyle.push(";");
        rowStyle.push(this._fontStyleString);
        rowStyle.push("background-color:");

        if (rowInfo.focusedRow && this.getHighlightFocusRow()) {
          rowStyle.push(rowInfo.selected ? this._colors.bgcolFocusedSelected : this._colors.bgcolFocused);
        } else {
          if (rowInfo.selected) {
            rowStyle.push(this._colors.bgcolSelected);
          } else {
            rowStyle.push(rowInfo.row % 2 == 0 ? this._colors.bgcolEven : this._colors.bgcolOdd);
          }
        }

        rowStyle.push(';color:');
        rowStyle.push(rowInfo.selected ? this._colors.colSelected : this._colors.colNormal);
        rowStyle.push(';border-bottom: 1px solid ', this._colors.horLine);
        return rowStyle.join("");
      },
      getRowClass: function getRowClass(rowInfo) {
        return "";
      },

      /**
       * Add extra attributes to each row.
       *
       * @param rowInfo {Object}
       *   The following members are available in rowInfo:
       *   <dl>
       *     <dt>table {qx.ui.table.Table}</dt>
       *     <dd>The table object</dd>
       *
       *     <dt>styleHeight {Integer}</dt>
       *     <dd>The height of this (and every) row</dd>
       *
       *     <dt>row {Integer}</dt>
       *     <dd>The number of the row being added</dd>
       *
       *     <dt>selected {Boolean}</dt>
       *     <dd>Whether the row being added is currently selected</dd>
       *
       *     <dt>focusedRow {Boolean}</dt>
       *     <dd>Whether the row being added is currently focused</dd>
       *
       *     <dt>rowData {Array}</dt>
       *     <dd>The array row from the data model of the row being added</dd>
       *   </dl>
       *
       * @return {String}
       *   Any additional attributes and their values that should be added to the
       *   div tag for the row.
       */
      getRowAttributes: function getRowAttributes(rowInfo) {
        return "";
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._colors = this._fontStyle = this._fontStyleString = null; // remove dynamic theme listener

      {
        qx.theme.manager.Meta.getInstance().removeListener("changeTheme", this.initThemeValues, this);
      }
    }
  });
  qx.ui.table.rowrenderer.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.MenuButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.IColumnMenuButton": {
        "require": true
      },
      "qx.ui.core.Blocker": {
        "construct": true
      },
      "qx.ui.menu.Menu": {},
      "qx.ui.table.columnmenu.MenuItem": {},
      "qx.ui.menu.Button": {},
      "qx.ui.menu.Separator": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The traditional qx.ui.menu.MenuButton to access the column visibility menu.
   */
  qx.Class.define("qx.ui.table.columnmenu.Button", {
    extend: qx.ui.form.MenuButton,
    implement: qx.ui.table.IColumnMenuButton,

    /**
     * Create a new instance of a column visibility menu button. This button
     * also contains the factory for creating each of the sub-widgets.
     */
    construct: function construct() {
      qx.ui.form.MenuButton.constructor.call(this); // add blocker

      this.__blocker__P_510_0 = new qx.ui.core.Blocker(this);
    },
    members: {
      __columnMenuButtons__P_510_1: null,
      __blocker__P_510_0: null,
      // Documented in qx.ui.table.IColumnMenu
      factory: function factory(item, options) {
        switch (item) {
          case "menu":
            var menu = new qx.ui.menu.Menu();
            this.setMenu(menu);
            return menu;

          case "menu-button":
            var menuButton = new qx.ui.table.columnmenu.MenuItem(options.text);
            menuButton.setColumnVisible(options.bVisible);
            this.getMenu().add(menuButton);
            return menuButton;

          case "user-button":
            var button = new qx.ui.menu.Button(options.text);
            button.set({
              appearance: "table-column-reset-button"
            });
            return button;

          case "separator":
            return new qx.ui.menu.Separator();

          default:
            throw new Error("Unrecognized factory request: " + item);
        }
      },

      /**
       * Returns the blocker of the columnmenu button.
       *
       * @return {qx.ui.core.Blocker} the blocker.
       */
      getBlocker: function getBlocker() {
        return this.__blocker__P_510_0;
      },
      // Documented in qx.ui.table.IColumnMenu
      empty: function empty() {
        var menu = this.getMenu();
        var entries = menu.getChildren();

        for (var i = 0, l = entries.length; i < l; i++) {
          entries[0].destroy();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__blocker__P_510_0.dispose();
    }
  });
  qx.ui.table.columnmenu.Button.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.event.type.Dom": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A selection manager. This is a helper class that handles all selection
   * related events and updates a SelectionModel.
   * <p>
   * Widgets that support selection should use this manager. This way the only
   * thing the widget has to do is mapping pointer or key events to indexes and
   * call the corresponding handler method.
   *
   * @see SelectionModel
   */
  qx.Class.define("qx.ui.table.selection.Manager", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The selection model where to set the selection changes.
       */
      selectionModel: {
        check: "qx.ui.table.selection.Model"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __lastPointerDownHandled__P_522_0: null,

      /**
       * Handles the tap event.
       *
       * @param index {Integer} the index the pointer is pointing at.
       * @param evt {qx.event.type.Tap} the pointer event.
       */
      handleTap: function handleTap(index, evt) {
        if (evt.isLeftPressed()) {
          var selectionModel = this.getSelectionModel();

          if (!selectionModel.isSelectedIndex(index)) {
            // This index is not selected -> We react when the pointer is pressed (because of drag and drop)
            this._handleSelectEvent(index, evt);

            this.__lastPointerDownHandled__P_522_0 = true;
          } else {
            // This index is already selected -> We react when the pointer is released (because of drag and drop)
            this.__lastPointerDownHandled__P_522_0 = false;
          }
        } else if (evt.isRightPressed() && evt.getModifiers() == 0) {
          var selectionModel = this.getSelectionModel();

          if (!selectionModel.isSelectedIndex(index)) {
            // This index is not selected -> Set the selection to this index
            selectionModel.setSelectionInterval(index, index);
          }
        }

        if (evt.isLeftPressed() && !this.__lastPointerDownHandled__P_522_0) {
          this._handleSelectEvent(index, evt);
        }
      },

      /**
       * Handles the key down event that is used as replacement for pointer taps
       * (Normally space).
       *
       * @param index {Integer} the index that is currently focused.
       * @param evt {Map} the key event.
       */
      handleSelectKeyDown: function handleSelectKeyDown(index, evt) {
        this._handleSelectEvent(index, evt);
      },

      /**
       * Handles a key down event that moved the focus (E.g. up, down, home, end, ...).
       *
       * @param index {Integer} the index that is currently focused.
       * @param evt {Map} the key event.
       */
      handleMoveKeyDown: function handleMoveKeyDown(index, evt) {
        var selectionModel = this.getSelectionModel();

        switch (evt.getModifiers()) {
          case 0:
            selectionModel.setSelectionInterval(index, index);
            break;

          case qx.event.type.Dom.SHIFT_MASK:
            var anchor = selectionModel.getAnchorSelectionIndex();

            if (anchor == -1) {
              selectionModel.setSelectionInterval(index, index);
            } else {
              selectionModel.setSelectionInterval(anchor, index);
            }

            break;
        }
      },

      /**
       * Handles a select event.
       *
       * @param index {Integer} the index the event is pointing at.
       * @param evt {Map} the pointer event.
       */
      _handleSelectEvent: function _handleSelectEvent(index, evt) {
        var selectionModel = this.getSelectionModel();
        var leadIndex = selectionModel.getLeadSelectionIndex();
        var anchorIndex = selectionModel.getAnchorSelectionIndex();

        if (evt.isShiftPressed()) {
          if (index != leadIndex || selectionModel.isSelectionEmpty()) {
            // The lead selection index was changed
            if (anchorIndex == -1) {
              anchorIndex = index;
            }

            if (evt.isCtrlOrCommandPressed()) {
              selectionModel.addSelectionInterval(anchorIndex, index);
            } else {
              selectionModel.setSelectionInterval(anchorIndex, index);
            }
          }
        } else if (evt.isCtrlOrCommandPressed()) {
          if (selectionModel.isSelectedIndex(index)) {
            selectionModel.removeSelectionInterval(index, index);
          } else {
            selectionModel.addSelectionInterval(index, index);
          }
        } else {
          // setSelectionInterval checks to see if the change is really necessary
          selectionModel.setSelectionInterval(index, index);
        }
      }
    }
  });
  qx.ui.table.selection.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * David Perez Carmona (david-perez)
  
  ************************************************************************ */

  /**
   * A selection model.
   */
  qx.Class.define("qx.ui.table.selection.Model", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__selectedRangeArr__P_523_0 = [];
      this.__anchorSelectionIndex__P_523_1 = -1;
      this.__leadSelectionIndex__P_523_2 = -1;
      this.hasBatchModeRefCount = 0;
      this.__hadChangeEventInBatchMode__P_523_3 = false;
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the selection has changed. */
      "changeSelection": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {int} The selection mode "none". Nothing can ever be selected. */
      NO_SELECTION: 1,

      /** @type {int} The selection mode "single". This mode only allows one selected item. */
      SINGLE_SELECTION: 2,

      /**
       * @type {int} The selection mode "single interval". This mode only allows one
       * continuous interval of selected items.
       */
      SINGLE_INTERVAL_SELECTION: 3,

      /**
       * @type {int} The selection mode "multiple interval". This mode only allows any
       * selection.
       */
      MULTIPLE_INTERVAL_SELECTION: 4,

      /**
       * @type {int} The selection mode "multiple interval". This mode only allows any
       * selection. The difference with the previous one, is that multiple
       * selection is eased. A tap on an item, toggles its selection state.
       * On the other hand, MULTIPLE_INTERVAL_SELECTION does this behavior only
       * when Ctrl-tapping an item.
       */
      MULTIPLE_INTERVAL_SELECTION_TOGGLE: 5
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Set the selection mode. Valid values are {@link #NO_SELECTION},
       * {@link #SINGLE_SELECTION}, {@link #SINGLE_INTERVAL_SELECTION},
       * {@link #MULTIPLE_INTERVAL_SELECTION} and
       * {@link #MULTIPLE_INTERVAL_SELECTION_TOGGLE}.
       */
      selectionMode: {
        init: 2,
        //SINGLE_SELECTION,
        check: [1, 2, 3, 4, 5],
        //[ NO_SELECTION, SINGLE_SELECTION, SINGLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION_TOGGLE ],
        apply: "_applySelectionMode"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __hadChangeEventInBatchMode__P_523_3: null,
      __anchorSelectionIndex__P_523_1: null,
      __leadSelectionIndex__P_523_2: null,
      __selectedRangeArr__P_523_0: null,
      // selectionMode property modifier
      _applySelectionMode: function _applySelectionMode(selectionMode) {
        this.resetSelection();
      },

      /**
       *
       * Activates / Deactivates batch mode. In batch mode, no change events will be thrown but
       * will be collected instead. When batch mode is turned off again and any events have
       * been collected, one event is thrown to inform the listeners.
       *
       * This method supports nested calling, i. e. batch mode can be turned more than once.
       * In this case, batch mode will not end until it has been turned off once for each
       * turning on.
       *
       * @param batchMode {Boolean} true to activate batch mode, false to deactivate
       * @return {Boolean} true if batch mode is active, false otherwise
       * @throws {Error} if batch mode is turned off once more than it has been turned on
       */
      setBatchMode: function setBatchMode(batchMode) {
        if (batchMode) {
          this.hasBatchModeRefCount += 1;
        } else {
          if (this.hasBatchModeRefCount == 0) {
            throw new Error("Try to turn off batch mode althoug it was not turned on.");
          }

          this.hasBatchModeRefCount -= 1;

          if (this.__hadChangeEventInBatchMode__P_523_3) {
            this.__hadChangeEventInBatchMode__P_523_3 = false;

            this._fireChangeSelection();
          }
        }

        return this.hasBatchMode();
      },

      /**
       *
       * Returns whether batch mode is active. See setter for a description of batch mode.
       *
       * @return {Boolean} true if batch mode is active, false otherwise
       */
      hasBatchMode: function hasBatchMode() {
        return this.hasBatchModeRefCount > 0;
      },

      /**
       * Returns the first argument of the last call to {@link #setSelectionInterval()},
       * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.
       *
       * @return {Integer} the anchor selection index.
       */
      getAnchorSelectionIndex: function getAnchorSelectionIndex() {
        return this.__anchorSelectionIndex__P_523_1;
      },

      /**
       * Sets the anchor selection index. Only use this function, if you want manipulate
       * the selection manually.
       *
       * @param index {Integer} the index to set.
       */
      _setAnchorSelectionIndex: function _setAnchorSelectionIndex(index) {
        this.__anchorSelectionIndex__P_523_1 = index;
      },

      /**
       * Returns the second argument of the last call to {@link #setSelectionInterval()},
       * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.
       *
       * @return {Integer} the lead selection index.
       */
      getLeadSelectionIndex: function getLeadSelectionIndex() {
        return this.__leadSelectionIndex__P_523_2;
      },

      /**
       * Sets the lead selection index. Only use this function, if you want manipulate
       * the selection manually.
       *
       * @param index {Integer} the index to set.
       */
      _setLeadSelectionIndex: function _setLeadSelectionIndex(index) {
        this.__leadSelectionIndex__P_523_2 = index;
      },

      /**
       * Returns an array that holds all the selected ranges of the table. Each
       * entry is a map holding information about the "minIndex" and "maxIndex" of the
       * selection range.
       *
       * @return {Map[]} array with all the selected ranges.
       */
      _getSelectedRangeArr: function _getSelectedRangeArr() {
        return this.__selectedRangeArr__P_523_0;
      },

      /**
       * Resets (clears) the selection.
       */
      resetSelection: function resetSelection() {
        if (!this.isSelectionEmpty()) {
          this._resetSelection();

          this._fireChangeSelection();
        }
      },

      /**
       * Returns whether the selection is empty.
       *
       * @return {Boolean} whether the selection is empty.
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__selectedRangeArr__P_523_0.length == 0;
      },

      /**
       * Returns the number of selected items.
       *
       * @return {Integer} the number of selected items.
       */
      getSelectedCount: function getSelectedCount() {
        var selectedCount = 0;

        for (var i = 0; i < this.__selectedRangeArr__P_523_0.length; i++) {
          var range = this.__selectedRangeArr__P_523_0[i];
          selectedCount += range.maxIndex - range.minIndex + 1;
        }

        return selectedCount;
      },

      /**
       * Returns whether an index is selected.
       *
       * @param index {Integer} the index to check.
       * @return {Boolean} whether the index is selected.
       */
      isSelectedIndex: function isSelectedIndex(index) {
        for (var i = 0; i < this.__selectedRangeArr__P_523_0.length; i++) {
          var range = this.__selectedRangeArr__P_523_0[i];

          if (index >= range.minIndex && index <= range.maxIndex) {
            return true;
          }
        }

        return false;
      },

      /**
       * Returns the selected ranges as an array. Each array element has a
       * <code>minIndex</code> and a <code>maxIndex</code> property.
       *
       * @return {Map[]} the selected ranges.
       */
      getSelectedRanges: function getSelectedRanges() {
        // clone the selection array and the individual elements - this prevents the
        // caller from messing with the internal model
        var retVal = [];

        for (var i = 0; i < this.__selectedRangeArr__P_523_0.length; i++) {
          retVal.push({
            minIndex: this.__selectedRangeArr__P_523_0[i].minIndex,
            maxIndex: this.__selectedRangeArr__P_523_0[i].maxIndex
          });
        }

        return retVal;
      },

      /**
       * Calls an iterator function for each selected index.
       *
       * Usage Example:
       * <pre class='javascript'>
       * var selectedRowData = [];
       * mySelectionModel.iterateSelection(function(index) {
       *   selectedRowData.push(myTableModel.getRowData(index));
       * });
       * </pre>
       *
       * @param iterator {Function} the function to call for each selected index.
       *          Gets the current index as parameter.
       * @param object {var ? null} the object to use when calling the handler.
       *          (this object will be available via "this" in the iterator)
       */
      iterateSelection: function iterateSelection(iterator, object) {
        for (var i = 0; i < this.__selectedRangeArr__P_523_0.length; i++) {
          for (var j = this.__selectedRangeArr__P_523_0[i].minIndex; j <= this.__selectedRangeArr__P_523_0[i].maxIndex; j++) {
            iterator.call(object, j);
          }
        }
      },

      /**
       * Sets the selected interval. This will clear the former selection.
       *
       * @param fromIndex {Integer} the first index of the selection (including).
       * @param toIndex {Integer} the last index of the selection (including).
       */
      setSelectionInterval: function setSelectionInterval(fromIndex, toIndex) {
        var me = qx.ui.table.selection.Model;

        switch (this.getSelectionMode()) {
          case me.NO_SELECTION:
            return;

          case me.SINGLE_SELECTION:
            // Ensure there is actually a change of selection
            if (this.isSelectedIndex(toIndex)) {
              return;
            }

            fromIndex = toIndex;
            break;

          case me.MULTIPLE_INTERVAL_SELECTION_TOGGLE:
            this.setBatchMode(true);

            try {
              for (var i = fromIndex; i <= toIndex; i++) {
                if (!this.isSelectedIndex(i)) {
                  this._addSelectionInterval(i, i);
                } else {
                  this.removeSelectionInterval(i, i);
                }
              }
            } catch (e) {
              throw e;
            } finally {
              this.setBatchMode(false);
            }

            this._fireChangeSelection();

            return;
        }

        this._resetSelection();

        this._addSelectionInterval(fromIndex, toIndex);

        this._fireChangeSelection();
      },

      /**
       * Adds a selection interval to the current selection.
       *
       * @param fromIndex {Integer} the first index of the selection (including).
       * @param toIndex {Integer} the last index of the selection (including).
       */
      addSelectionInterval: function addSelectionInterval(fromIndex, toIndex) {
        var SelectionModel = qx.ui.table.selection.Model;

        switch (this.getSelectionMode()) {
          case SelectionModel.NO_SELECTION:
            return;

          case SelectionModel.MULTIPLE_INTERVAL_SELECTION:
          case SelectionModel.MULTIPLE_INTERVAL_SELECTION_TOGGLE:
            this._addSelectionInterval(fromIndex, toIndex);

            this._fireChangeSelection();

            break;

          default:
            this.setSelectionInterval(fromIndex, toIndex);
            break;
        }
      },

      /**
       * Removes an interval from the current selection.
       *
       * @param fromIndex {Integer} the first index of the interval (including).
       * @param toIndex {Integer} the last index of the interval (including).
       * @param rowsRemoved {Boolean?} rows were removed that caused this selection to change.
       *   If rows were removed, move the selections over so the same rows are selected as before.
       */
      removeSelectionInterval: function removeSelectionInterval(fromIndex, toIndex, rowsRemoved) {
        this.__anchorSelectionIndex__P_523_1 = fromIndex;
        this.__leadSelectionIndex__P_523_2 = toIndex;
        var minIndex = Math.min(fromIndex, toIndex);
        var maxIndex = Math.max(fromIndex, toIndex);
        var removeCount = maxIndex + 1 - minIndex; // Crop the affected ranges

        var newRanges = [];
        var extraRange = null;

        for (var i = 0; i < this.__selectedRangeArr__P_523_0.length; i++) {
          var range = this.__selectedRangeArr__P_523_0[i];

          if (range.minIndex > maxIndex) {
            if (rowsRemoved) {
              // Move whole selection up.
              range.minIndex -= removeCount;
              range.maxIndex -= removeCount;
            }
          } else if (range.maxIndex >= minIndex) {
            // This range is affected
            var minIsIn = range.minIndex >= minIndex;
            var maxIsIn = range.maxIndex >= minIndex && range.maxIndex <= maxIndex;

            if (minIsIn && maxIsIn) {
              // This range is removed completely
              range = null;
            } else if (minIsIn) {
              if (rowsRemoved) {
                range.minIndex = minIndex;
                range.maxIndex -= removeCount;
              } else {
                // The range is cropped from the left
                range.minIndex = maxIndex + 1;
              }
            } else if (maxIsIn) {
              // The range is cropped from the right
              range.maxIndex = minIndex - 1;
            } else {
              if (rowsRemoved) {
                range.maxIndex -= removeCount;
              } else {
                // The range is split
                extraRange = {
                  minIndex: maxIndex + 1,
                  maxIndex: range.maxIndex
                };
                range.maxIndex = minIndex - 1;
              }
            }
          }

          if (range) {
            newRanges.push(range);
            range = null;
          }

          if (extraRange) {
            newRanges.push(extraRange);
            extraRange = null;
          }
        }

        this.__selectedRangeArr__P_523_0 = newRanges;

        this._fireChangeSelection();
      },

      /**
       * Resets (clears) the selection, but doesn't inform the listeners.
       */
      _resetSelection: function _resetSelection() {
        this.__selectedRangeArr__P_523_0 = [];
        this.__anchorSelectionIndex__P_523_1 = -1;
        this.__leadSelectionIndex__P_523_2 = -1;
      },

      /**
       * Adds a selection interval to the current selection, but doesn't inform
       * the listeners.
       *
       * @param fromIndex {Integer} the first index of the selection (including).
       * @param toIndex {Integer} the last index of the selection (including).
       */
      _addSelectionInterval: function _addSelectionInterval(fromIndex, toIndex) {
        this.__anchorSelectionIndex__P_523_1 = fromIndex;
        this.__leadSelectionIndex__P_523_2 = toIndex;
        var minIndex = Math.min(fromIndex, toIndex);
        var maxIndex = Math.max(fromIndex, toIndex); // Find the index where the new range should be inserted

        var newRangeIndex = 0;

        for (; newRangeIndex < this.__selectedRangeArr__P_523_0.length; newRangeIndex++) {
          var range = this.__selectedRangeArr__P_523_0[newRangeIndex];

          if (range.minIndex > minIndex) {
            break;
          }
        } // Add the new range


        this.__selectedRangeArr__P_523_0.splice(newRangeIndex, 0, {
          minIndex: minIndex,
          maxIndex: maxIndex
        }); // Merge overlapping ranges


        var lastRange = this.__selectedRangeArr__P_523_0[0];

        for (var i = 1; i < this.__selectedRangeArr__P_523_0.length; i++) {
          var range = this.__selectedRangeArr__P_523_0[i];

          if (lastRange.maxIndex + 1 >= range.minIndex) {
            // The ranges are overlapping -> merge them
            lastRange.maxIndex = Math.max(lastRange.maxIndex, range.maxIndex); // Remove the current range

            this.__selectedRangeArr__P_523_0.splice(i, 1); // Check this index another time


            i--;
          } else {
            lastRange = range;
          }
        }
      },
      // this._dumpRanges();

      /**
       * Logs the current ranges for debug purposes.
       *
       */
      _dumpRanges: function _dumpRanges() {
        var text = "Ranges:";

        for (var i = 0; i < this.__selectedRangeArr__P_523_0.length; i++) {
          var range = this.__selectedRangeArr__P_523_0[i];
          text += " [" + range.minIndex + ".." + range.maxIndex + "]";
        }

        this.debug(text);
      },

      /**
       * Fires the "changeSelection" event to all registered listeners. If the selection model
       * currently is in batch mode, only one event will be thrown when batch mode is ended.
       *
       */
      _fireChangeSelection: function _fireChangeSelection() {
        if (this.hasBatchMode()) {
          // In batch mode, remember event but do not throw (yet)
          this.__hadChangeEventInBatchMode__P_523_3 = true;
        } else {
          // If not in batch mode, throw event
          this.fireEvent("changeSelection");
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__selectedRangeArr__P_523_0 = null;
    }
  });
  qx.ui.table.selection.Model.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.table.IHeaderRenderer": {
        "require": true
      },
      "qx.ui.table.headerrenderer.HeaderCell": {},
      "qx.ui.tooltip.ToolTip": {},
      "qx.util.DisposeUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * The default header cell renderer.
   */
  qx.Class.define("qx.ui.table.headerrenderer.Default", {
    extend: qx.core.Object,
    implement: qx.ui.table.IHeaderRenderer,

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * @type {String} The state which will be set for header cells of sorted columns.
       */
      STATE_SORTED: "sorted",

      /**
       * @type {String} The state which will be set when sorting is ascending.
       */
      STATE_SORTED_ASCENDING: "sortedAscending"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * ToolTip to show if the pointer hovers of the icon
       */
      toolTip: {
        check: "String",
        init: null,
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      createHeaderCell: function createHeaderCell(cellInfo) {
        var widget = new qx.ui.table.headerrenderer.HeaderCell();
        this.updateHeaderCell(cellInfo, widget);
        return widget;
      },
      // overridden
      updateHeaderCell: function updateHeaderCell(cellInfo, cellWidget) {
        var DefaultHeaderCellRenderer = qx.ui.table.headerrenderer.Default; // check for localization [BUG #2699]

        if (cellInfo.name && cellInfo.name.translate) {
          cellWidget.setLabel(cellInfo.name.translate());
        } else {
          cellWidget.setLabel(cellInfo.name);
        } // Set image tooltip if given


        var widgetToolTip = cellWidget.getToolTip();

        if (this.getToolTip() != null) {
          if (widgetToolTip == null) {
            // We have no tooltip yet -> Create one
            widgetToolTip = new qx.ui.tooltip.ToolTip(this.getToolTip());
            cellWidget.setToolTip(widgetToolTip); // Link disposer to cellwidget to prevent memory leak

            qx.util.DisposeUtil.disposeTriggeredBy(widgetToolTip, cellWidget);
          } else {
            // Update tooltip text
            widgetToolTip.setLabel(this.getToolTip());
          }
        }

        cellInfo.sorted ? cellWidget.addState(DefaultHeaderCellRenderer.STATE_SORTED) : cellWidget.removeState(DefaultHeaderCellRenderer.STATE_SORTED);
        cellInfo.sortedAscending ? cellWidget.addState(DefaultHeaderCellRenderer.STATE_SORTED_ASCENDING) : cellWidget.removeState(DefaultHeaderCellRenderer.STATE_SORTED_ASCENDING);
      }
    }
  });
  qx.ui.table.headerrenderer.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.bom.Stylesheet": {
        "require": true
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.ICellRenderer": {
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.theme.manager.Meta": {
        "construct": true
      },
      "qx.theme.manager.Color": {},
      "qx.bom.element.Style": {},
      "qx.bom.client.Css": {},
      "qx.bom.element.BoxSizing": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxsizing": {
          "className": "qx.bom.client.Css"
        },
        "css.boxmodel": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * An abstract data cell renderer that does the basic coloring
   * (borders, selected look, ...).
   *
   * @require(qx.bom.Stylesheet)
   */
  qx.Class.define("qx.ui.table.cellrenderer.Abstract", {
    type: "abstract",
    implement: qx.ui.table.ICellRenderer,
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      var cr = qx.ui.table.cellrenderer.Abstract;

      if (!cr.__clazz__P_505_0) {
        cr.__clazz__P_505_0 = qx.ui.table.cellrenderer.Abstract;

        this._createStyleSheet(); // add dynamic theme listener


        {
          qx.theme.manager.Meta.getInstance().addListener("changeTheme", this._onChangeTheme, this);
        }
      }
    },
    properties: {
      /**
       * The default cell style. The value of this property will be provided
       * to the cell renderer as cellInfo.style.
       */
      defaultCellStyle: {
        init: null,
        check: "String",
        nullable: true
      }
    },
    members: {
      /**
       * Handler for the theme change.
       * @signature function()
       */
      _onChangeTheme: function _onChangeTheme() {
        qx.bom.Stylesheet.removeAllRules(qx.ui.table.cellrenderer.Abstract.__clazz__P_505_0.stylesheet);

        this._createStyleSheet();
      },

      /**
       * the sum of the horizontal insets. This is needed to compute the box model
       * independent size
       */
      _insetX: 13,
      // paddingLeft + paddingRight + borderRight

      /**
       * the sum of the vertical insets. This is needed to compute the box model
       * independent size
       */
      _insetY: 0,

      /**
       * Creates the style sheet used for the table cells.
       */
      _createStyleSheet: function _createStyleSheet() {
        var colorMgr = qx.theme.manager.Color.getInstance();
        var stylesheet = ".qooxdoo-table-cell {" + qx.bom.element.Style.compile({
          position: "absolute",
          top: "0px",
          overflow: "hidden",
          whiteSpace: "nowrap",
          borderRight: "1px solid " + colorMgr.resolve("table-column-line"),
          padding: "0px 6px",
          cursor: "default",
          textOverflow: "ellipsis",
          userSelect: "none"
        }) + "} " + ".qooxdoo-table-cell-right { text-align:right } " + ".qooxdoo-table-cell-italic { font-style:italic} " + ".qooxdoo-table-cell-bold { font-weight:bold } ";

        if (qx.core.Environment.get("css.boxsizing")) {
          stylesheet += ".qooxdoo-table-cell {" + qx.bom.element.BoxSizing.compile("content-box") + "}";
        }

        qx.ui.table.cellrenderer.Abstract.__clazz__P_505_0.stylesheet = qx.bom.Stylesheet.createElement(stylesheet);
      },

      /**
       * Get a string of the cell element's HTML classes.
       *
       * This method may be overridden by sub classes.
       *
       * @param cellInfo {Map} cellInfo of the cell
       * @return {String} The table cell HTML classes as string.
       */
      _getCellClass: function _getCellClass(cellInfo) {
        return "qooxdoo-table-cell";
      },

      /**
       * Returns the CSS styles that should be applied to the main div of this
       * cell.
       *
       * This method may be overridden by sub classes.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {var} the CSS styles of the main div.
       */
      _getCellStyle: function _getCellStyle(cellInfo) {
        return cellInfo.style || "";
      },

      /**
        * Retrieve any extra attributes the cell renderer wants applied to this
        * cell.
        *
        * @param cellInfo {Map} The information about the cell.
        *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
        *
        * @return {String}
        *   The extra attributes to be applied to this cell.
        */
      _getCellAttributes: function _getCellAttributes(cellInfo) {
        return "";
      },

      /**
       * Returns the HTML that should be used inside the main div of this cell.
       *
       * This method may be overridden by sub classes.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {String} the inner HTML of the cell.
       */
      _getContentHtml: function _getContentHtml(cellInfo) {
        return cellInfo.value || "";
      },

      /**
       * Get the cell size taking the box model into account
       *
       * @param width {Integer} The cell's (border-box) width in pixel
       * @param height {Integer} The cell's (border-box) height in pixel
       * @param insetX {Integer} The cell's horizontal insets, i.e. the sum of
       *    horizontal paddings and borders
       * @param insetY {Integer} The cell's vertical insets, i.e. the sum of
       *    vertical paddings and borders
       * @return {String} The CSS style string for the cell size
       */
      _getCellSizeStyle: function _getCellSizeStyle(width, height, insetX, insetY) {
        var style = "";

        if (qx.core.Environment.get("css.boxmodel") == "content") {
          width -= insetX;
          height -= insetY;
        }

        style += "width:" + Math.max(width, 0) + "px;";
        style += "height:" + Math.max(height, 0) + "px;";
        return style;
      },
      // interface implementation
      createDataCellHtml: function createDataCellHtml(cellInfo, htmlArr) {
        htmlArr.push('<div class="', this._getCellClass(cellInfo), '" style="', 'left:', cellInfo.styleLeft, 'px;', this._getCellSizeStyle(cellInfo.styleWidth, cellInfo.styleHeight, this._insetX, this._insetY), this._getCellStyle(cellInfo), '" ', this._getCellAttributes(cellInfo), '>' + this._getContentHtml(cellInfo), '</div>');
      }
    },
    destruct: function destruct() {
      // remove dynamic theme listener
      {
        qx.theme.manager.Meta.getInstance().removeListener("changeTheme", this._onChangeTheme, this);
      }
    }
  });
  qx.ui.table.cellrenderer.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Abstract": {
        "require": true
      },
      "qx.bom.String": {},
      "qx.util.format.NumberFormat": {},
      "qx.util.format.DateFormat": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * The default data cell renderer.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Default", {
    extend: qx.ui.table.cellrenderer.Abstract,

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      STYLEFLAG_ALIGN_RIGHT: 1,
      STYLEFLAG_BOLD: 2,
      STYLEFLAG_ITALIC: 4,
      _numberFormat: null
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether the alignment should automatically be set according to the cell value.
       * If true numbers will be right-aligned.
       */
      useAutoAlign: {
        check: "Boolean",
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Determines the styles to apply to the cell
       *
       * @param cellInfo {Map} cellInfo of the cell
       *     See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {Integer} the sum of any of the STYLEFLAGS defined below
       */
      _getStyleFlags: function _getStyleFlags(cellInfo) {
        if (this.getUseAutoAlign()) {
          if (typeof cellInfo.value == "number") {
            return qx.ui.table.cellrenderer.Default.STYLEFLAG_ALIGN_RIGHT;
          }
        }

        return 0;
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        var cellClass = qx.ui.table.cellrenderer.Default.prototype._getCellClass.base.call(this, cellInfo);

        if (!cellClass) {
          return "";
        }

        var stylesToApply = this._getStyleFlags(cellInfo);

        if (stylesToApply & qx.ui.table.cellrenderer.Default.STYLEFLAG_ALIGN_RIGHT) {
          cellClass += " qooxdoo-table-cell-right";
        }

        if (stylesToApply & qx.ui.table.cellrenderer.Default.STYLEFLAG_BOLD) {
          cellClass += " qooxdoo-table-cell-bold";
        }

        if (stylesToApply & qx.ui.table.cellrenderer.Default.STYLEFLAG_ITALIC) {
          cellClass += " qooxdoo-table-cell-italic";
        }

        return cellClass;
      },
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        return qx.bom.String.escape(this._formatValue(cellInfo));
      },

      /**
       * Formats a value.
       *
       * @param cellInfo {Map} A map containing the information about the cell to
       *          create. This map has the same structure as in
       *          {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {String} the formatted value.
       */
      _formatValue: function _formatValue(cellInfo) {
        var value = cellInfo.value;
        var res;

        if (value == null) {
          return "";
        }

        if (typeof value == "string") {
          return value;
        } else if (typeof value == "number") {
          if (!qx.ui.table.cellrenderer.Default._numberFormat) {
            qx.ui.table.cellrenderer.Default._numberFormat = new qx.util.format.NumberFormat();

            qx.ui.table.cellrenderer.Default._numberFormat.setMaximumFractionDigits(2);
          }

          res = qx.ui.table.cellrenderer.Default._numberFormat.format(value);
        } else if (value instanceof Date) {
          res = qx.util.format.DateFormat.getDateInstance().format(value);
        } else {
          res = value.toString();
        }

        return res;
      }
    }
  });
  qx.ui.table.cellrenderer.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.table.ICellEditorFactory": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * An abstract cell editor factory creating text/password/spinner/... fields.
   */
  qx.Class.define("qx.ui.table.celleditor.AbstractField", {
    extend: qx.core.Object,
    implement: qx.ui.table.ICellEditorFactory,
    type: "abstract",
    properties: {
      /**
       * function that validates the result
       * the function will be called with the new value and the old value and is
       * supposed to return the value that is set as the table value.
       **/
      validationFunction: {
        check: "Function",
        nullable: true,
        init: null
      }
    },
    members: {
      /**
       * Factory to create the editor widget
       *
       * @return {qx.ui.core.Widget} The editor widget
       */
      _createEditor: function _createEditor() {
        throw new Error("Abstract method call!");
      },
      // interface implementation
      createCellEditor: function createCellEditor(cellInfo) {
        var cellEditor = this._createEditor();

        cellEditor.originalValue = cellInfo.value;

        if (cellInfo.value === null || cellInfo.value === undefined) {
          cellInfo.value = "";
        }

        cellEditor.setValue("" + cellInfo.value);
        cellEditor.addListener("appear", function () {
          cellEditor.selectAllText();
        });
        return cellEditor;
      },
      // interface implementation
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        var value = cellEditor.getValue(); // validation function will be called with new and old value

        var validationFunc = this.getValidationFunction();

        if (validationFunc) {
          value = validationFunc(value, cellEditor.originalValue);
        }

        if (typeof cellEditor.originalValue == "number") {
          value = parseFloat(value);
        }

        return value;
      }
    }
  });
  qx.ui.table.celleditor.AbstractField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.celleditor.AbstractField": {
        "require": true
      },
      "qx.ui.form.TextField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A cell editor factory creating text fields.
   */
  qx.Class.define("qx.ui.table.celleditor.TextField", {
    extend: qx.ui.table.celleditor.AbstractField,
    members: {
      // overridden
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        var value = cellEditor.getValue(); // validation function will be called with new and old value

        var validationFunc = this.getValidationFunction();

        if (validationFunc) {
          value = validationFunc(value, cellEditor.originalValue);
        }

        if (typeof cellEditor.originalValue == "number") {
          // Correct problem of NaN displaying when value is null string.
          //if (value != null) {
          if (value != null && value != '') {
            value = parseFloat(value);
          }
        }

        return value;
      },
      _createEditor: function _createEditor() {
        var cellEditor = new qx.ui.form.TextField();
        cellEditor.setAppearance("table-editor-textfield");
        return cellEditor;
      }
    }
  });
  qx.ui.table.celleditor.TextField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.headerrenderer.Default": {
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "require": true
      },
      "qx.ui.table.celleditor.TextField": {
        "require": true
      },
      "qx.ui.table.IHeaderRenderer": {},
      "qx.ui.table.ICellRenderer": {},
      "qx.ui.table.ICellEditorFactory": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A model that contains all meta data about columns, such as width, renderer,
   * visibility and order.
   *
   * @see qx.ui.table.ITableModel
   */
  qx.Class.define("qx.ui.table.columnmodel.Basic", {
    extend: qx.core.Object,
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__overallColumnArr__P_511_0 = [];
      this.__visibleColumnArr__P_511_1 = [];
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when the width of a column has changed. The data property of the event is
       * a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column the width of which has changed.</li>
       *   <li>newWidth: The new width of the column in pixels.</li>
       *   <li>oldWidth: The old width of the column in pixels.</li>
       * </ul>
       */
      "widthChanged": "qx.event.type.Data",

      /**
       * Fired when the visibility of a column has changed. This event is equal to
        * "visibilityChanged", but is fired right before.
       */
      "visibilityChangedPre": "qx.event.type.Data",

      /**
       * Fired when the visibility of a column has changed. The data property of the
       * event is a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column the visibility of which has changed.</li>
       *   <li>visible: Whether the column is now visible.</li>
       * </ul>
       */
      "visibilityChanged": "qx.event.type.Data",

      /**
       * Fired when the column order has changed. The data property of the
       * event is a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column that was moved.</li>
       *   <li>fromOverXPos: The old overall x position of the column.</li>
       *   <li>toOverXPos: The new overall x position of the column.</li>
       * </ul>
       */
      "orderChanged": "qx.event.type.Data",

      /**
       * Fired when the cell renderer of a column has changed.
       * The data property of the event is a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column that was moved.</li>
       * </ul>
       */
      "headerCellRendererChanged": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {Integer} the default width of a column in pixels. */
      DEFAULT_WIDTH: 100,

      /** @type {qx.ui.table.headerrenderer.Default} the default header cell renderer. */
      DEFAULT_HEADER_RENDERER: qx.ui.table.headerrenderer.Default,

      /** @type {qx.ui.table.cellrenderer.Default} the default data cell renderer. */
      DEFAULT_DATA_RENDERER: qx.ui.table.cellrenderer.Default,

      /** @type {qx.ui.table.celleditor.TextField} the default editor factory. */
      DEFAULT_EDITOR_FACTORY: qx.ui.table.celleditor.TextField
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __internalChange__P_511_2: null,
      __colToXPosMap__P_511_3: null,
      __visibleColumnArr__P_511_1: null,
      __overallColumnArr__P_511_0: null,
      __columnDataArr__P_511_4: null,
      __headerRenderer__P_511_5: null,
      __dataRenderer__P_511_6: null,
      __editorFactory__P_511_7: null,

      /**
       * Initializes the column model.
       *
       * @param colCount {Integer}
       *   The number of columns the model should have.
       *
       * @param table {qx.ui.table.Table}
       *   The table to which this column model is attached.
       */
      init: function init(colCount, table) {
        {
          this.assertInteger(colCount, "Invalid argument 'colCount'.");
        }
        this.__columnDataArr__P_511_4 = [];
        var width = qx.ui.table.columnmodel.Basic.DEFAULT_WIDTH;
        var headerRenderer = this.__headerRenderer__P_511_5 || (this.__headerRenderer__P_511_5 = new qx.ui.table.columnmodel.Basic.DEFAULT_HEADER_RENDERER());
        var dataRenderer = this.__dataRenderer__P_511_6 || (this.__dataRenderer__P_511_6 = new qx.ui.table.columnmodel.Basic.DEFAULT_DATA_RENDERER());
        var editorFactory = this.__editorFactory__P_511_7 || (this.__editorFactory__P_511_7 = new qx.ui.table.columnmodel.Basic.DEFAULT_EDITOR_FACTORY());
        this.__overallColumnArr__P_511_0 = [];
        this.__visibleColumnArr__P_511_1 = []; // Get the initially hidden column array, if one was provided. Older
        // subclasses may not provide the 'table' argument, so we treat them
        // traditionally with no initially hidden columns.

        var initiallyHiddenColumns; // Was a table provided to us?

        if (table) {
          // Yup. Get its list of initially hidden columns, if the user provided
          // such a list.
          initiallyHiddenColumns = table.getInitiallyHiddenColumns();
        } // If no table was specified, or if the user didn't provide a list of
        // initially hidden columns, use an empty list.


        initiallyHiddenColumns = initiallyHiddenColumns || [];

        for (var col = 0; col < colCount; col++) {
          this.__columnDataArr__P_511_4[col] = {
            width: width,
            headerRenderer: headerRenderer,
            dataRenderer: dataRenderer,
            editorFactory: editorFactory
          };
          this.__overallColumnArr__P_511_0[col] = col;
          this.__visibleColumnArr__P_511_1[col] = col;
        }

        this.__colToXPosMap__P_511_3 = null; // If any columns are initially hidden, hide them now. Make it an
        // internal change so that events are not generated.

        this.__internalChange__P_511_2 = true;

        for (var hidden = 0; hidden < initiallyHiddenColumns.length; hidden++) {
          this.setColumnVisible(initiallyHiddenColumns[hidden], false);
        }

        this.__internalChange__P_511_2 = false;

        for (col = 0; col < colCount; col++) {
          var data = {
            col: col,
            visible: this.isColumnVisible(col)
          };
          this.fireDataEvent("visibilityChangedPre", data);
          this.fireDataEvent("visibilityChanged", data);
        }
      },

      /**
       * Return the array of visible columns
       *
       * @return {Array} List of all visible columns
       */
      getVisibleColumns: function getVisibleColumns() {
        return this.__visibleColumnArr__P_511_1 != null ? this.__visibleColumnArr__P_511_1 : [];
      },

      /**
       * Sets the width of a column.
       *
       * @param col {Integer}
       *   The model index of the column.
       *
       * @param width {Integer}
       *   The new width the column should get in pixels.
       *
       * @param isPointerAction {Boolean}
       *   <i>true</i> if the column width is being changed as a result of a
       *   pointer drag in the header; false or undefined otherwise.
       *
       */
      setColumnWidth: function setColumnWidth(col, width, isPointerAction) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertInteger(width, "Invalid argument 'width'.");
          this.assertNotUndefined(this.__columnDataArr__P_511_4[col], "Column not found in table model");
        }
        var oldWidth = this.__columnDataArr__P_511_4[col].width;

        if (oldWidth != width) {
          this.__columnDataArr__P_511_4[col].width = width;
          var data = {
            col: col,
            newWidth: width,
            oldWidth: oldWidth,
            isPointerAction: isPointerAction || false
          };
          this.fireDataEvent("widthChanged", data);
        }
      },

      /**
       * Returns the width of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the width of the column in pixels.
       */
      getColumnWidth: function getColumnWidth(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertNotUndefined(this.__columnDataArr__P_511_4[col], "Column not found in table model");
        }
        return this.__columnDataArr__P_511_4[col].width;
      },

      /**
       * Sets the header renderer of a column. Use setHeaderCellRenderers
       * instead of this method if you want to set the header renderer of many
       * columns.
       *
       * @param col {Integer} the model index of the column.
       * @param renderer {qx.ui.table.IHeaderRenderer} the new header renderer the column
       *      should get.
       */
      setHeaderCellRenderer: function setHeaderCellRenderer(col, renderer) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertInterface(renderer, qx.ui.table.IHeaderRenderer, "Invalid argument 'renderer'.");
          this.assertNotUndefined(this.__columnDataArr__P_511_4[col], "Column not found in table model");
        }
        var oldRenderer = this.__columnDataArr__P_511_4[col].headerRenderer;

        if (oldRenderer !== this.__headerRenderer__P_511_5) {
          oldRenderer.dispose();
        }

        this.__columnDataArr__P_511_4[col].headerRenderer = renderer;

        if (!this.__internalChange__P_511_2) {
          this.fireDataEvent("headerCellRendererChanged", {
            col: col
          });
        }
      },

      /**
       * Sets the header renderer of one or more columns. Use this method, in
       * favor of setHeaderCellRenderer, if you want to set the header renderer
       * of many columns. This method fires the "headerCellRendererChanged"
       * event only once, after setting all renderers, whereas
       * setHeaderCellRenderer fires it for each changed renderer which can be
       * slow with many columns.
       *
       * @param renderers {Map}
       *   Map, where the keys are column numbers and values are the renderers,
       *   implementing qx.ui.table.IHeaderRenderer, of the the new header
       *   renderers for that column
       */
      setHeaderCellRenderers: function setHeaderCellRenderers(renderers) {
        var col; // Prevent firing "headerCellRendererChanged" for each column. Instead,
        // we'll fire it once at the end.

        this.__internalChange__P_511_2 = true; // For each listed column...

        for (col in renderers) {
          // ... set that column's renderer
          this.setHeaderCellRenderer(+col, renderers[col]);
        } // Turn off the internal-change flag so operation returns to normal


        this.__internalChange__P_511_2 = false; // Now we can fire the event once. The data indicates which columns
        // changed. Internally to qooxdoo, nothing cares about the event data.

        this.fireDataEvent("headerCellRendererChanged", {
          cols: Object.keys(renderers)
        });
      },

      /**
       * Returns the header renderer of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {qx.ui.table.IHeaderRenderer} the header renderer of the column.
       */
      getHeaderCellRenderer: function getHeaderCellRenderer(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertNotUndefined(this.__columnDataArr__P_511_4[col], "Column not found in table model");
        }
        return this.__columnDataArr__P_511_4[col].headerRenderer;
      },

      /**
       * Sets the data renderer of a column.
       *
       * @param col {Integer} the model index of the column.
       * @param renderer {qx.ui.table.ICellRenderer} the new data renderer
       *   the column should get.
       * @return {qx.ui.table.ICellRenderer?null} If an old renderer was set and
       *   it was not the default renderer, the old renderer is returned for
       *   pooling or disposing.
       */
      setDataCellRenderer: function setDataCellRenderer(col, renderer) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertInterface(renderer, qx.ui.table.ICellRenderer, "Invalid argument 'renderer'.");
          this.assertNotUndefined(this.__columnDataArr__P_511_4[col], "Column not found in table model");
        }
        var oldRenderer = this.__columnDataArr__P_511_4[col].dataRenderer;
        this.__columnDataArr__P_511_4[col].dataRenderer = renderer;

        if (oldRenderer !== this.__dataRenderer__P_511_6) {
          return oldRenderer;
        }

        return null;
      },

      /**
       * Returns the data renderer of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {qx.ui.table.ICellRenderer} the data renderer of the column.
       */
      getDataCellRenderer: function getDataCellRenderer(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertNotUndefined(this.__columnDataArr__P_511_4[col], "Column not found in table model");
        }
        return this.__columnDataArr__P_511_4[col].dataRenderer;
      },

      /**
       * Sets the cell editor factory of a column.
       *
       * @param col {Integer} the model index of the column.
       * @param factory {qx.ui.table.ICellEditorFactory} the new cell editor factory the column should get.
       */
      setCellEditorFactory: function setCellEditorFactory(col, factory) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertInterface(factory, qx.ui.table.ICellEditorFactory, "Invalid argument 'factory'.");
          this.assertNotUndefined(this.__columnDataArr__P_511_4[col], "Column not found in table model");
        }
        var oldFactory = this.__columnDataArr__P_511_4[col].editorFactory;

        if (oldFactory === factory) {
          return;
        }

        if (oldFactory !== this.__editorFactory__P_511_7) {
          oldFactory.dispose();
        }

        this.__columnDataArr__P_511_4[col].editorFactory = factory;
      },

      /**
       * Returns the cell editor factory of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {qx.ui.table.ICellEditorFactory} the cell editor factory of the column.
       */
      getCellEditorFactory: function getCellEditorFactory(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertNotUndefined(this.__columnDataArr__P_511_4[col], "Column not found in table model");
        }
        return this.__columnDataArr__P_511_4[col].editorFactory;
      },

      /**
       * Returns the map that translates model indexes to x positions.
       *
       * The returned map contains for a model index (int) a map having two
       * properties: overX (the overall x position of the column, int) and
       * visX (the visible x position of the column, int). visX is missing for
       * hidden columns.
       *
       * @return {Map} the "column to x position" map.
       */
      _getColToXPosMap: function _getColToXPosMap() {
        if (this.__colToXPosMap__P_511_3 == null) {
          this.__colToXPosMap__P_511_3 = {};

          for (var overX = 0; overX < this.__overallColumnArr__P_511_0.length; overX++) {
            var col = this.__overallColumnArr__P_511_0[overX];
            this.__colToXPosMap__P_511_3[col] = {
              overX: overX
            };
          }

          for (var visX = 0; visX < this.__visibleColumnArr__P_511_1.length; visX++) {
            var col = this.__visibleColumnArr__P_511_1[visX];
            this.__colToXPosMap__P_511_3[col].visX = visX;
          }
        }

        return this.__colToXPosMap__P_511_3;
      },

      /**
       * Returns the number of visible columns.
       *
       * @return {Integer} the number of visible columns.
       */
      getVisibleColumnCount: function getVisibleColumnCount() {
        return this.__visibleColumnArr__P_511_1 != null ? this.__visibleColumnArr__P_511_1.length : 0;
      },

      /**
       * Returns the model index of a column at a certain visible x position.
       *
       * @param visXPos {Integer} the visible x position of the column.
       * @return {Integer} the model index of the column.
       */
      getVisibleColumnAtX: function getVisibleColumnAtX(visXPos) {
        {
          this.assertInteger(visXPos, "Invalid argument 'visXPos'.");
        }
        return this.__visibleColumnArr__P_511_1[visXPos];
      },

      /**
       * Returns the visible x position of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the visible x position of the column.
       */
      getVisibleX: function getVisibleX(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
        }
        return this._getColToXPosMap()[col].visX;
      },

      /**
       * Returns the overall number of columns (including hidden columns).
       *
       * @return {Integer} the overall number of columns.
       */
      getOverallColumnCount: function getOverallColumnCount() {
        return this.__overallColumnArr__P_511_0.length;
      },

      /**
       * Returns the model index of a column at a certain overall x position.
       *
       * @param overXPos {Integer} the overall x position of the column.
       * @return {Integer} the model index of the column.
       */
      getOverallColumnAtX: function getOverallColumnAtX(overXPos) {
        {
          this.assertInteger(overXPos, "Invalid argument 'overXPos'.");
        }
        return this.__overallColumnArr__P_511_0[overXPos];
      },

      /**
       * Returns the overall x position of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the overall x position of the column.
       */
      getOverallX: function getOverallX(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
        }
        return this._getColToXPosMap()[col].overX;
      },

      /**
       * Returns whether a certain column is visible.
       *
       * @param col {Integer} the model index of the column.
       * @return {Boolean} whether the column is visible.
       */
      isColumnVisible: function isColumnVisible(col) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
        }
        return this._getColToXPosMap()[col].visX != null;
      },

      /**
       * Sets whether a certain column is visible.
       *
       * @param col {Integer} the model index of the column.
       * @param visible {Boolean} whether the column should be visible.
       */
      setColumnVisible: function setColumnVisible(col, visible) {
        {
          this.assertInteger(col, "Invalid argument 'col'.");
          this.assertBoolean(visible, "Invalid argument 'visible'.");
        }

        if (visible != this.isColumnVisible(col)) {
          if (visible) {
            var colToXPosMap = this._getColToXPosMap();

            var overX = colToXPosMap[col].overX;

            if (overX == null) {
              throw new Error("Showing column failed: " + col + ". The column is not added to this TablePaneModel.");
            } // get the visX of the next visible column after the column to show


            var nextVisX;

            for (var x = overX + 1; x < this.__overallColumnArr__P_511_0.length; x++) {
              var currCol = this.__overallColumnArr__P_511_0[x];
              var currVisX = colToXPosMap[currCol].visX;

              if (currVisX != null) {
                nextVisX = currVisX;
                break;
              }
            } // If there comes no visible column any more, then show the column
            // at the end


            if (nextVisX == null) {
              nextVisX = this.__visibleColumnArr__P_511_1.length;
            } // Add the column to the visible columns


            this.__visibleColumnArr__P_511_1.splice(nextVisX, 0, col);
          } else {
            var visX = this.getVisibleX(col);

            this.__visibleColumnArr__P_511_1.splice(visX, 1);
          } // Invalidate the __colToXPosMap


          this.__colToXPosMap__P_511_3 = null; // Inform the listeners

          if (!this.__internalChange__P_511_2) {
            var data = {
              col: col,
              visible: visible
            };
            this.fireDataEvent("visibilityChangedPre", data);
            this.fireDataEvent("visibilityChanged", data);
          }
        }
      },

      /**
       * Moves a column.
       *
       * @param fromOverXPos {Integer} the overall x position of the column to move.
       * @param toOverXPos {Integer} the overall x position of where the column should be
       *      moved to.
       */
      moveColumn: function moveColumn(fromOverXPos, toOverXPos) {
        {
          this.assertInteger(fromOverXPos, "Invalid argument 'fromOverXPos'.");
          this.assertInteger(toOverXPos, "Invalid argument 'toOverXPos'.");
        }
        this.__internalChange__P_511_2 = true;
        var col = this.__overallColumnArr__P_511_0[fromOverXPos];
        var visible = this.isColumnVisible(col);

        if (visible) {
          this.setColumnVisible(col, false);
        }

        this.__overallColumnArr__P_511_0.splice(fromOverXPos, 1);

        this.__overallColumnArr__P_511_0.splice(toOverXPos, 0, col); // Invalidate the __colToXPosMap


        this.__colToXPosMap__P_511_3 = null;

        if (visible) {
          this.setColumnVisible(col, true);
        }

        this.__internalChange__P_511_2 = false; // Inform the listeners

        var data = {
          col: col,
          fromOverXPos: fromOverXPos,
          toOverXPos: toOverXPos
        };
        this.fireDataEvent("orderChanged", data);
      },

      /**
       * Reorders all columns to new overall positions. Will fire one "orderChanged" event
       * without data afterwards
       *
       * @param newPositions {Integer[]} Array mapping the index of a column in table model to its wanted overall
       *                            position on screen (both zero based). If the table models holds
       *                            col0, col1, col2 and col3 and you give [1,3,2,0], the new column order
       *                            will be col3, col0, col2, col1
       */
      setColumnsOrder: function setColumnsOrder(newPositions) {
        {
          this.assertArray(newPositions, "Invalid argument 'newPositions'.");
        }

        if (newPositions.length == this.__overallColumnArr__P_511_0.length) {
          this.__internalChange__P_511_2 = true; // Go through each column an switch visible ones to invisible. Reason is unknown,
          // this just mimicks the behaviour of moveColumn. Possibly useful because setting
          // a column visible later updates a map with its screen coords.

          var isVisible = new Array(newPositions.length);

          for (var colIdx = 0; colIdx < this.__overallColumnArr__P_511_0.length; colIdx++) {
            var visible = this.isColumnVisible(colIdx);
            isVisible[colIdx] = visible; //Remember, as this relies on this.__colToXPosMap which is cleared below

            if (visible) {
              this.setColumnVisible(colIdx, false);
            }
          } // Store new position values


          this.__overallColumnArr__P_511_0 = qx.lang.Array.clone(newPositions); // Invalidate the __colToXPosMap

          this.__colToXPosMap__P_511_3 = null; // Go through each column an switch invisible ones back to visible

          for (var colIdx = 0; colIdx < this.__overallColumnArr__P_511_0.length; colIdx++) {
            if (isVisible[colIdx]) {
              this.setColumnVisible(colIdx, true);
            }
          }

          this.__internalChange__P_511_2 = false; // Inform the listeners. Do not add data as all known listeners in qooxdoo
          // only take this event to mean "total repaint necesscary". Fabian will look
          // after deprecating the data part of the orderChanged - event

          this.fireDataEvent("orderChanged");
        } else {
          throw new Error("setColumnsOrder: Invalid number of column positions given, expected " + this.__overallColumnArr__P_511_0.length + ", got " + newPositions.length);
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      for (var i = 0; i < this.__columnDataArr__P_511_4.length; i++) {
        this.__columnDataArr__P_511_4[i].headerRenderer.dispose();

        this.__columnDataArr__P_511_4[i].dataRenderer.dispose();

        this.__columnDataArr__P_511_4[i].editorFactory.dispose();
      }

      this.__overallColumnArr__P_511_0 = this.__visibleColumnArr__P_511_1 = this.__columnDataArr__P_511_4 = this.__colToXPosMap__P_511_3 = null;

      this._disposeObjects("__headerRenderer__P_511_5", "__dataRenderer__P_511_6", "__editorFactory__P_511_7");
    }
  });
  qx.ui.table.columnmodel.Basic.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The table pane that shows a certain section from a table. This class handles
   * the display of the data part of a table and is therefore the base for virtual
   * scrolling.
   */
  qx.Class.define("qx.ui.table.pane.Pane", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param paneScroller {qx.ui.table.pane.Scroller} the TablePaneScroller the header belongs to.
     */
    construct: function construct(paneScroller) {
      qx.ui.core.Widget.constructor.call(this);
      this.__paneScroller__P_520_0 = paneScroller;
      this.__lastColCount__P_520_1 = 0;
      this.__lastRowCount__P_520_2 = 0;
      this.__rowCache__P_520_3 = [];
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Whether the current view port of the pane has not loaded data.
       * The data object of the event indicates if the table pane has to reload
       * data or not. Can be used to give the user feedback of the loading state
       * of the rows.
       */
      "paneReloadsData": "qx.event.type.Data",

      /**
       * Whenever the content of the table pane has been updated (rendered)
       * trigger a paneUpdated event. This allows the canvas cellrenderer to act
       * once the new cells have been integrated in the dom.
       */
      "paneUpdated": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The index of the first row to show. */
      firstVisibleRow: {
        check: "Number",
        init: 0,
        apply: "_applyFirstVisibleRow"
      },

      /** The number of rows to show. */
      visibleRowCount: {
        check: "Number",
        init: 0,
        apply: "_applyVisibleRowCount"
      },

      /**
       * Maximum number of cached rows. If the value is <code>-1</code> the cache
       * size is unlimited
       */
      maxCacheLines: {
        check: "Number",
        init: 1000,
        apply: "_applyMaxCacheLines"
      },
      // overridden
      allowShrinkX: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __lastRowCount__P_520_2: null,
      __lastColCount__P_520_1: null,
      __paneScroller__P_520_0: null,
      __tableContainer__P_520_4: null,
      __focusedRow__P_520_5: null,
      __focusedCol__P_520_6: null,
      // sparse array to cache rendered rows
      __rowCache__P_520_3: null,
      __rowCacheCount__P_520_7: 0,
      // property modifier
      _applyFirstVisibleRow: function _applyFirstVisibleRow(value, old) {
        this.updateContent(false, value - old);
      },
      // property modifier
      _applyVisibleRowCount: function _applyVisibleRowCount(value, old) {
        this.updateContent(true);
      },
      // overridden
      _getContentHint: function _getContentHint() {
        // the preferred height is 400 pixel. We don't use rowCount * rowHeight
        // because this is typically too large.
        return {
          width: this.getPaneScroller().getTablePaneModel().getTotalWidth(),
          height: 400
        };
      },

      /**
       * Returns the TablePaneScroller this pane belongs to.
       *
       * @return {qx.ui.table.pane.Scroller} the TablePaneScroller.
       */
      getPaneScroller: function getPaneScroller() {
        return this.__paneScroller__P_520_0;
      },

      /**
       * Returns the table this pane belongs to.
       *
       * @return {qx.ui.table.Table} the table.
       */
      getTable: function getTable() {
        return this.__paneScroller__P_520_0.getTable();
      },

      /**
       * Sets the currently focused cell.
       *
       * @param col {Integer?null} the model index of the focused cell's column.
       * @param row {Integer?null} the model index of the focused cell's row.
       * @param massUpdate {Boolean ? false} Whether other updates are planned as well.
       *          If true, no repaint will be done.
       */
      setFocusedCell: function setFocusedCell(col, row, massUpdate) {
        if (col != this.__focusedCol__P_520_6 || row != this.__focusedRow__P_520_5) {
          var oldRow = this.__focusedRow__P_520_5;
          this.__focusedCol__P_520_6 = col;
          this.__focusedRow__P_520_5 = row; // Update the focused row background

          if (row != oldRow && !massUpdate) {
            if (oldRow !== null) {
              this.updateContent(false, null, oldRow, true);
            }

            if (row !== null) {
              this.updateContent(false, null, row, true);
            }
          }
        }
      },

      /**
       * Event handler. Called when the selection has changed.
       */
      onSelectionChanged: function onSelectionChanged() {
        this.updateContent(false, null, null, true);
      },

      /**
       * Event handler. Called when the table gets or looses the focus.
       */
      onFocusChanged: function onFocusChanged() {
        this.updateContent(false, null, null, true);
      },

      /**
       * Sets the column width.
       *
       * @param col {Integer} the column to change the width for.
       * @param width {Integer} the new width.
       */
      setColumnWidth: function setColumnWidth(col, width) {
        this.updateContent(true);
      },

      /**
       * Event handler. Called the column order has changed.
       *
       */
      onColOrderChanged: function onColOrderChanged() {
        this.updateContent(true);
      },

      /**
       * Event handler. Called when the pane model has changed.
       */
      onPaneModelChanged: function onPaneModelChanged() {
        this.updateContent(true);
      },

      /**
       * Event handler. Called when the table model data has changed.
       *
       * @param firstRow {Integer} The index of the first row that has changed.
       * @param lastRow {Integer} The index of the last row that has changed.
       * @param firstColumn {Integer} The model index of the first column that has changed.
       * @param lastColumn {Integer} The model index of the last column that has changed.
       */
      onTableModelDataChanged: function onTableModelDataChanged(firstRow, lastRow, firstColumn, lastColumn) {
        this.__rowCacheClear__P_520_8();

        var paneFirstRow = this.getFirstVisibleRow();
        var rowCount = this.getVisibleRowCount();

        if (lastRow == -1 || lastRow >= paneFirstRow && firstRow < paneFirstRow + rowCount) {
          // The change intersects this pane
          this.updateContent();
        }
      },

      /**
       * Event handler. Called when the table model meta data has changed.
       *
       */
      onTableModelMetaDataChanged: function onTableModelMetaDataChanged() {
        this.updateContent(true);
      },
      // property apply method
      _applyMaxCacheLines: function _applyMaxCacheLines(value, old) {
        if (this.__rowCacheCount__P_520_7 >= value && value !== -1) {
          this.__rowCacheClear__P_520_8();
        }
      },

      /**
       * Clear the row cache
       */
      __rowCacheClear__P_520_8: function __rowCacheClear__P_520_8() {
        this.__rowCache__P_520_3 = [];
        this.__rowCacheCount__P_520_7 = 0;
      },

      /**
       * Get a line from the row cache.
       *
       * @param row {Integer} Row index to get
       * @param selected {Boolean} Whether the row is currently selected
       * @param focused {Boolean} Whether the row is currently focused
       * @return {String|null} The cached row or null if a row with the given
       *     index is not cached.
       */
      __rowCacheGet__P_520_9: function __rowCacheGet__P_520_9(row, selected, focused) {
        if (!selected && !focused && this.__rowCache__P_520_3[row]) {
          return this.__rowCache__P_520_3[row];
        } else {
          return null;
        }
      },

      /**
       * Add a line to the row cache.
       *
       * @param row {Integer} Row index to set
       * @param rowString {String} computed row string to cache
       * @param selected {Boolean} Whether the row is currently selected
       * @param focused {Boolean} Whether the row is currently focused
       */
      __rowCacheSet__P_520_10: function __rowCacheSet__P_520_10(row, rowString, selected, focused) {
        var maxCacheLines = this.getMaxCacheLines();

        if (!selected && !focused && !this.__rowCache__P_520_3[row] && maxCacheLines > 0) {
          this._applyMaxCacheLines(maxCacheLines);

          this.__rowCache__P_520_3[row] = rowString;
          this.__rowCacheCount__P_520_7 += 1;
        }
      },

      /**
       * Updates the content of the pane.
       *
       * @param completeUpdate {Boolean ? false} if true a complete update is performed.
       *      On a complete update all cell widgets are recreated.
       * @param scrollOffset {Integer ? null} If set specifies how many rows to scroll.
       * @param onlyRow {Integer ? null} if set only the specified row will be updated.
       * @param onlySelectionOrFocusChanged {Boolean ? false} if true, cell values won't
       *          be updated. Only the row background will.
       */
      updateContent: function updateContent(completeUpdate, scrollOffset, onlyRow, onlySelectionOrFocusChanged) {
        if (completeUpdate) {
          this.__rowCacheClear__P_520_8();
        }

        if (scrollOffset && Math.abs(scrollOffset) <= Math.min(10, this.getVisibleRowCount())) {
          this._scrollContent(scrollOffset);
        } else if (onlySelectionOrFocusChanged && !this.getTable().getAlwaysUpdateCells()) {
          this._updateRowStyles(onlyRow);
        } else {
          this._updateAllRows();
        }
      },

      /**
       * If only focus or selection changes it is sufficient to only update the
       * row styles. This method updates the row styles of all visible rows or
       * of just one row.
       *
       * @param onlyRow {Integer|null ? null} If this parameter is set only the row
       *     with this index is updated.
       */
      _updateRowStyles: function _updateRowStyles(onlyRow) {
        var elem = this.getContentElement().getDomElement();

        if (!elem || !elem.firstChild) {
          this._updateAllRows();

          return;
        }

        var table = this.getTable();
        var selectionModel = table.getSelectionModel();
        var tableModel = table.getTableModel();
        var rowRenderer = table.getDataRowRenderer();
        var rowNodes = elem.firstChild.childNodes;
        var cellInfo = {
          table: table
        }; // We don't want to execute the row loop below more than necessary. If
        // onlyRow is not null, we want to do the loop only for that row.
        // In that case, we start at (set the "row" variable to) that row, and
        // stop at (set the "end" variable to the offset of) the next row.

        var row = this.getFirstVisibleRow();
        var y = 0; // How many rows do we need to update?

        var end = rowNodes.length;

        if (onlyRow != null) {
          // How many rows are we skipping?
          var offset = onlyRow - row;

          if (offset >= 0 && offset < end) {
            row = onlyRow;
            y = offset;
            end = offset + 1;
          } else {
            return;
          }
        }

        for (; y < end; y++, row++) {
          cellInfo.row = row;
          cellInfo.selected = selectionModel.isSelectedIndex(row);
          cellInfo.focusedRow = this.__focusedRow__P_520_5 == row;
          cellInfo.rowData = tableModel.getRowData(row);
          rowRenderer.updateDataRowElement(cellInfo, rowNodes[y]);
        }

        ;
      },

      /**
       * Get the HTML table fragment for the given row range.
       *
       * @param firstRow {Integer} Index of the first row
       * @param rowCount {Integer} Number of rows
       * @return {String} The HTML table fragment for the given row range.
       */
      _getRowsHtml: function _getRowsHtml(firstRow, rowCount) {
        var table = this.getTable();
        var selectionModel = table.getSelectionModel();
        var tableModel = table.getTableModel();
        var columnModel = table.getTableColumnModel();
        var paneModel = this.getPaneScroller().getTablePaneModel();
        var rowRenderer = table.getDataRowRenderer();
        tableModel.prefetchRows(firstRow, firstRow + rowCount - 1);
        var rowHeight = table.getRowHeight();
        var colCount = paneModel.getColumnCount();
        var left = 0;
        var cols = []; // precompute column properties

        for (var x = 0; x < colCount; x++) {
          var col = paneModel.getColumnAtX(x);
          var cellWidth = columnModel.getColumnWidth(col);
          cols.push({
            col: col,
            xPos: x,
            editable: tableModel.isColumnEditable(col),
            focusedCol: this.__focusedCol__P_520_6 == col,
            styleLeft: left,
            styleWidth: cellWidth
          });
          left += cellWidth;
        }

        var rowsArr = [];
        var paneReloadsData = false;

        for (var row = firstRow; row < firstRow + rowCount; row++) {
          var selected = selectionModel.isSelectedIndex(row);
          var focusedRow = this.__focusedRow__P_520_5 == row;

          var cachedRow = this.__rowCacheGet__P_520_9(row, selected, focusedRow);

          if (cachedRow) {
            rowsArr.push(cachedRow);
            continue;
          }

          var rowHtml = [];
          var cellInfo = {
            table: table
          };
          cellInfo.styleHeight = rowHeight;
          cellInfo.row = row;
          cellInfo.selected = selected;
          cellInfo.focusedRow = focusedRow;
          cellInfo.rowData = tableModel.getRowData(row);

          if (!cellInfo.rowData) {
            paneReloadsData = true;
          }

          rowHtml.push('<div ');
          var rowAttributes = rowRenderer.getRowAttributes(cellInfo);

          if (rowAttributes) {
            rowHtml.push(rowAttributes);
          }

          var rowClass = rowRenderer.getRowClass(cellInfo);

          if (rowClass) {
            rowHtml.push('class="', rowClass, '" ');
          }

          var rowStyle = rowRenderer.createRowStyle(cellInfo);
          rowStyle += ";position:relative;" + rowRenderer.getRowHeightStyle(rowHeight) + "width:100%;";

          if (rowStyle) {
            rowHtml.push('style="', rowStyle, '" ');
          }

          rowHtml.push('>');
          var stopLoop = false;

          for (x = 0; x < colCount && !stopLoop; x++) {
            var col_def = cols[x];

            for (var attr in col_def) {
              cellInfo[attr] = col_def[attr];
            }

            var col = cellInfo.col; // Use the "getValue" method of the tableModel to get the cell's
            // value working directly on the "rowData" object
            // (-> cellInfo.rowData[col];) is not a solution because you can't
            // work with the columnIndex -> you have to use the columnId of the
            // columnIndex This is exactly what the method "getValue" does

            cellInfo.value = tableModel.getValue(col, row);
            var cellRenderer = columnModel.getDataCellRenderer(col); // Retrieve the current default cell style for this column.

            cellInfo.style = cellRenderer.getDefaultCellStyle(); // Allow a cell renderer to tell us not to draw any further cells in
            // the row. Older, or traditional cell renderers don't return a
            // value, however, from createDataCellHtml, so assume those are
            // returning false.
            //
            // Tested with http://tinyurl.com/333hyhv

            stopLoop = cellRenderer.createDataCellHtml(cellInfo, rowHtml) || false;
          }

          rowHtml.push('</div>');
          var rowString = rowHtml.join("");

          this.__rowCacheSet__P_520_10(row, rowString, selected, focusedRow);

          rowsArr.push(rowString);
        }

        this.fireDataEvent("paneReloadsData", paneReloadsData);
        return rowsArr.join("");
      },

      /**
       * Scrolls the pane's contents by the given offset.
       *
       * @param rowOffset {Integer} Number of lines to scroll. Scrolling up is
       *     represented by a negative offset.
       */
      _scrollContent: function _scrollContent(rowOffset) {
        var el = this.getContentElement().getDomElement();

        if (!(el && el.firstChild)) {
          this._updateAllRows();

          return;
        }

        var tableBody = el.firstChild;
        var tableChildNodes = tableBody.childNodes;
        var rowCount = this.getVisibleRowCount();
        var firstRow = this.getFirstVisibleRow();
        var tabelModel = this.getTable().getTableModel();
        var modelRowCount = 0;
        modelRowCount = tabelModel.getRowCount(); // don't handle this special case here

        if (firstRow + rowCount > modelRowCount) {
          this._updateAllRows();

          return;
        } // remove old lines


        var removeRowBase = rowOffset < 0 ? rowCount + rowOffset : 0;
        var addRowBase = rowOffset < 0 ? 0 : rowCount - rowOffset;

        for (var i = Math.abs(rowOffset) - 1; i >= 0; i--) {
          var rowElem = tableChildNodes[removeRowBase];

          try {
            tableBody.removeChild(rowElem);
          } catch (exp) {
            break;
          }
        } // render new lines


        if (!this.__tableContainer__P_520_4) {
          this.__tableContainer__P_520_4 = document.createElement("div");
        }

        var tableDummy = '<div>';
        tableDummy += this._getRowsHtml(firstRow + addRowBase, Math.abs(rowOffset));
        tableDummy += '</div>';
        this.__tableContainer__P_520_4.innerHTML = tableDummy;
        var newTableRows = this.__tableContainer__P_520_4.firstChild.childNodes; // append new lines

        if (rowOffset > 0) {
          for (var i = newTableRows.length - 1; i >= 0; i--) {
            var rowElem = newTableRows[0];
            tableBody.appendChild(rowElem);
          }
        } else {
          for (var i = newTableRows.length - 1; i >= 0; i--) {
            var rowElem = newTableRows[newTableRows.length - 1];
            tableBody.insertBefore(rowElem, tableBody.firstChild);
          }
        } // update focus indicator


        if (this.__focusedRow__P_520_5 !== null) {
          this._updateRowStyles(this.__focusedRow__P_520_5 - rowOffset);

          this._updateRowStyles(this.__focusedRow__P_520_5);
        }

        this.fireEvent("paneUpdated");
      },

      /**
       * Updates the content of the pane (implemented using array joins).
       */
      _updateAllRows: function _updateAllRows() {
        var elem = this.getContentElement().getDomElement();

        if (!elem) {
          // pane has not yet been rendered
          this.addListenerOnce("appear", this._updateAllRows, this);
          return;
        }

        var table = this.getTable();
        var tableModel = table.getTableModel();
        var paneModel = this.getPaneScroller().getTablePaneModel();
        var colCount = paneModel.getColumnCount();
        var rowHeight = table.getRowHeight();
        var firstRow = this.getFirstVisibleRow();
        var rowCount = this.getVisibleRowCount();
        var modelRowCount = tableModel.getRowCount();

        if (firstRow + rowCount > modelRowCount) {
          rowCount = Math.max(0, modelRowCount - firstRow);
        }

        var rowWidth = paneModel.getTotalWidth();
        var htmlArr; // If there are any rows...

        if (rowCount > 0) {
          // ... then create a div for them and add the rows to it.
          htmlArr = ["<div style='", "width: 100%;", table.getForceLineHeight() ? "line-height: " + rowHeight + "px;" : "", "overflow: hidden;", "'>", this._getRowsHtml(firstRow, rowCount), "</div>"];
        } else {
          // Otherwise, don't create the div, as even an empty div creates a
          // white row in IE.
          htmlArr = [];
        }

        var data = htmlArr.join("");
        elem.innerHTML = data;
        this.setWidth(rowWidth);
        this.__lastColCount__P_520_1 = colCount;
        this.__lastRowCount__P_520_2 = rowCount;
        this.fireEvent("paneUpdated");
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__tableContainer__P_520_4 = this.__paneScroller__P_520_0 = this.__rowCache__P_520_3 = null;
      this.removeListener("track", this._onTrack, this);
    }
  });
  qx.ui.table.pane.Pane.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.ui.core.Blocker": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * Shows the header of a table.
   */
  qx.Class.define("qx.ui.table.pane.Header", {
    extend: qx.ui.core.Widget,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param paneScroller {qx.ui.table.pane.Scroller} the TablePaneScroller the header belongs to.
     */
    construct: function construct(paneScroller) {
      qx.ui.core.Widget.constructor.call(this);

      this._setLayout(new qx.ui.layout.HBox()); // add blocker


      this.__blocker__P_518_0 = new qx.ui.core.Blocker(this);
      this.__paneScroller__P_518_1 = paneScroller;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __paneScroller__P_518_1: null,
      __moveFeedback__P_518_2: null,
      __lastPointerOverColumn__P_518_3: null,
      __blocker__P_518_0: null,

      /**
       * Returns the TablePaneScroller this header belongs to.
       *
       * @return {qx.ui.table.pane.Scroller} the TablePaneScroller.
       */
      getPaneScroller: function getPaneScroller() {
        return this.__paneScroller__P_518_1;
      },

      /**
       * Returns the table this header belongs to.
       *
       * @return {qx.ui.table.Table} the table.
       */
      getTable: function getTable() {
        return this.__paneScroller__P_518_1.getTable();
      },

      /**
       * Returns the blocker of the header.
       *
       * @return {qx.ui.core.Blocker} the blocker.
       */
      getBlocker: function getBlocker() {
        return this.__blocker__P_518_0;
      },

      /**
       * Event handler. Called the column order has changed.
       *
       */
      onColOrderChanged: function onColOrderChanged() {
        this._updateContent(true);
      },

      /**
       * Event handler. Called when the pane model has changed.
       */
      onPaneModelChanged: function onPaneModelChanged() {
        this._updateContent(true);
      },

      /**
       * Event handler. Called when the table model meta data has changed.
       *
       */
      onTableModelMetaDataChanged: function onTableModelMetaDataChanged() {
        this._updateContent();
      },

      /**
       * Sets the column width. This overrides the width from the column model.
       *
       * @param col {Integer}
       *   The column to change the width for.
       *
       * @param width {Integer}
       *   The new width.
       *
       * @param isPointerAction {Boolean}
       *   <i>true</i> if the column width is being changed as a result of a
       *   pointer drag in the header; false or undefined otherwise.
       *
       */
      setColumnWidth: function setColumnWidth(col, width, isPointerAction) {
        var child = this.getHeaderWidgetAtColumn(col);

        if (child != null) {
          child.setWidth(width);
        }
      },

      /**
       * Sets the column the pointer is currently over.
       *
       * @param col {Integer} the model index of the column the pointer is currently over or
       *      null if the pointer is over no column.
       */
      setPointerOverColumn: function setPointerOverColumn(col) {
        if (col != this.__lastPointerOverColumn__P_518_3) {
          if (this.__lastPointerOverColumn__P_518_3 != null) {
            var widget = this.getHeaderWidgetAtColumn(this.__lastPointerOverColumn__P_518_3);

            if (widget != null) {
              widget.removeState("hovered");
            }
          }

          if (col != null) {
            this.getHeaderWidgetAtColumn(col).addState("hovered");
          }

          this.__lastPointerOverColumn__P_518_3 = col;
        }
      },

      /**
       * Get the header widget for the given column
       *
       * @param col {Integer} The column number
       * @return {qx.ui.table.headerrenderer.HeaderCell} The header cell widget
       */
      getHeaderWidgetAtColumn: function getHeaderWidgetAtColumn(col) {
        var xPos = this.getPaneScroller().getTablePaneModel().getX(col);
        return this._getChildren()[xPos];
      },

      /**
       * Shows the feedback shown while a column is moved by the user.
       *
       * @param col {Integer} the model index of the column to show the move feedback for.
       * @param x {Integer} the x position the left side of the feedback should have
       *      (in pixels, relative to the left side of the header).
       */
      showColumnMoveFeedback: function showColumnMoveFeedback(col, x) {
        var pos = this.getContentLocation();

        if (this.__moveFeedback__P_518_2 == null) {
          var table = this.getTable();
          var xPos = this.getPaneScroller().getTablePaneModel().getX(col);

          var cellWidget = this._getChildren()[xPos];

          var tableModel = table.getTableModel();
          var columnModel = table.getTableColumnModel();
          var cellInfo = {
            xPos: xPos,
            col: col,
            name: tableModel.getColumnName(col),
            table: table
          };
          var cellRenderer = columnModel.getHeaderCellRenderer(col);
          var feedback = cellRenderer.createHeaderCell(cellInfo);
          var size = cellWidget.getBounds(); // Configure the feedback

          feedback.setWidth(size.width);
          feedback.setHeight(size.height);
          feedback.setZIndex(1000000);
          feedback.setOpacity(0.8);
          feedback.setLayoutProperties({
            top: pos.top
          });
          this.getApplicationRoot().add(feedback);
          this.__moveFeedback__P_518_2 = feedback;
        }

        this.__moveFeedback__P_518_2.setLayoutProperties({
          left: pos.left + x
        });

        this.__moveFeedback__P_518_2.show();
      },

      /**
       * Hides the feedback shown while a column is moved by the user.
       */
      hideColumnMoveFeedback: function hideColumnMoveFeedback() {
        if (this.__moveFeedback__P_518_2 != null) {
          this.__moveFeedback__P_518_2.destroy();

          this.__moveFeedback__P_518_2 = null;
        }
      },

      /**
       * Returns whether the column move feedback is currently shown.
       *
       * @return {Boolean} <code>true</code> whether the column move feedback is
       *    currently shown, <code>false</code> otherwise.
       */
      isShowingColumnMoveFeedback: function isShowingColumnMoveFeedback() {
        return this.__moveFeedback__P_518_2 != null;
      },

      /**
       * Updates the content of the header.
       *
       * @param completeUpdate {Boolean} if true a complete update is performed. On a
       *      complete update all header widgets are recreated.
       */
      _updateContent: function _updateContent(completeUpdate) {
        var table = this.getTable();
        var tableModel = table.getTableModel();
        var columnModel = table.getTableColumnModel();
        var paneModel = this.getPaneScroller().getTablePaneModel();

        var children = this._getChildren();

        var colCount = paneModel.getColumnCount();
        var sortedColumn = tableModel.getSortColumnIndex(); // Remove all widgets on the complete update

        if (completeUpdate) {
          this._cleanUpCells();
        } // Update the header


        var cellInfo = {};
        cellInfo.sortedAscending = tableModel.isSortAscending();

        for (var x = 0; x < colCount; x++) {
          var col = paneModel.getColumnAtX(x);

          if (col === undefined) {
            continue;
          }

          var colWidth = columnModel.getColumnWidth(col);
          var cellRenderer = columnModel.getHeaderCellRenderer(col);
          cellInfo.xPos = x;
          cellInfo.col = col;
          cellInfo.name = tableModel.getColumnName(col);
          cellInfo.editable = tableModel.isColumnEditable(col);
          cellInfo.sorted = col == sortedColumn;
          cellInfo.table = table; // Get the cached widget

          var cachedWidget = children[x]; // Create or update the widget

          if (cachedWidget == null) {
            // We have no cached widget -> create it
            cachedWidget = cellRenderer.createHeaderCell(cellInfo);
            cachedWidget.set({
              width: colWidth
            });

            this._add(cachedWidget);
          } else {
            // This widget already created before -> recycle it
            cellRenderer.updateHeaderCell(cellInfo, cachedWidget);
          } // set the states


          if (x === 0) {
            cachedWidget.addState("first");
            cachedWidget.removeState("last");
          } else if (x === colCount - 1) {
            cachedWidget.removeState("first");
            cachedWidget.addState("last");
          } else {
            cachedWidget.removeState("first");
            cachedWidget.removeState("last");
          }
        }
      },

      /**
       * Cleans up all header cells.
       *
       */
      _cleanUpCells: function _cleanUpCells() {
        var children = this._getChildren();

        for (var x = children.length - 1; x >= 0; x--) {
          var cellWidget = children[x];
          cellWidget.destroy();
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__blocker__P_518_0.dispose();

      this._disposeObjects("__paneScroller__P_518_1");
    }
  });
  qx.ui.table.pane.Header.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.scroll.MScrollBarFactory": {
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.container.Composite": {
        "construct": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.bom.client.Device": {
        "construct": true
      },
      "qx.bom.client.Scroll": {
        "construct": true
      },
      "qx.ui.layout.Canvas": {
        "construct": true
      },
      "qx.event.Timer": {
        "construct": true
      },
      "qx.ui.table.pane.FocusIndicator": {},
      "qx.ui.core.scroll.AbstractScrollArea": {},
      "qx.ui.table.pane.Clipper": {},
      "qx.ui.table.pane.CellEvent": {},
      "qx.lang.Number": {},
      "qx.ui.window.Window": {},
      "qx.event.GlobalError": {
        "usage": "dynamic",
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "device.type": {
          "construct": true,
          "className": "qx.bom.client.Device"
        },
        "os.scrollBarOverlayed": {
          "construct": true,
          "className": "qx.bom.client.Scroll"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Shows a whole meta column. This includes a {@link Header},
   * a {@link Pane} and the needed scroll bars. This class handles the
   * virtual scrolling and does all the pointer event handling.
   *
   * @childControl header {qx.ui.table.pane.Header} header pane
   * @childControl pane {qx.ui.table.pane.Pane} table pane to show the data
   * @childControl focus-indicator {qx.ui.table.pane.FocusIndicator} shows the current focused cell
   * @childControl resize-line {qx.ui.core.Widget} resize line widget
   * @childControl scrollbar-x {qx.ui.core.scroll.ScrollBar?qx.ui.core.scroll.NativeScrollBar}
   *               horizontal scrollbar widget (depends on the "qx.nativeScrollBars" setting which implementation is used)
   * @childControl scrollbar-y {qx.ui.core.scroll.ScrollBar?qx.ui.core.scroll.NativeScrollBar}
   *               vertical scrollbar widget (depends on the "qx.nativeScrollBars" setting which implementation is used)
   */
  qx.Class.define("qx.ui.table.pane.Scroller", {
    extend: qx.ui.core.Widget,
    include: [qx.ui.core.scroll.MScrollBarFactory],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param table {qx.ui.table.Table} the table the scroller belongs to.
     */
    construct: function construct(table) {
      qx.ui.core.Widget.constructor.call(this);
      this.__table__P_521_0 = table; // init layout

      var grid = new qx.ui.layout.Grid();
      grid.setColumnFlex(0, 1);
      grid.setRowFlex(1, 1);

      this._setLayout(grid); // init child controls


      this.__header__P_521_1 = this._showChildControl("header");
      this.__tablePane__P_521_2 = this._showChildControl("pane"); // the top line containing the header clipper and the top right widget

      this.__top__P_521_3 = new qx.ui.container.Composite(new qx.ui.layout.HBox()).set({
        minWidth: 0
      });

      this._add(this.__top__P_521_3, {
        row: 0,
        column: 0,
        colSpan: 2
      }); // embed header into a scrollable container


      this._headerClipper = this._createHeaderClipper();

      this._headerClipper.add(this.__header__P_521_1);

      this._headerClipper.addListener("losecapture", this._onChangeCaptureHeader, this);

      this._headerClipper.addListener("pointermove", this._onPointermoveHeader, this);

      this._headerClipper.addListener("pointerdown", this._onPointerdownHeader, this);

      this._headerClipper.addListener("pointerup", this._onPointerupHeader, this);

      this._headerClipper.addListener("tap", this._onTapHeader, this);

      this.__top__P_521_3.add(this._headerClipper, {
        flex: 1
      }); // embed pane into a scrollable container


      this._paneClipper = this._createPaneClipper();

      this._paneClipper.add(this.__tablePane__P_521_2);

      this._paneClipper.addListener("roll", this._onRoll, this);

      this._paneClipper.addListener("pointermove", this._onPointermovePane, this);

      this._paneClipper.addListener("pointerdown", this._onPointerdownPane, this);

      this._paneClipper.addListener("tap", this._onTapPane, this);

      this._paneClipper.addListener("contextmenu", this._onTapPane, this);

      this._paneClipper.addListener("contextmenu", this._onContextMenu, this);

      if (qx.core.Environment.get("device.type") === "desktop") {
        this._paneClipper.addListener("dblclick", this._onDbltapPane, this);
      } else {
        this._paneClipper.addListener("dbltap", this._onDbltapPane, this);
      }

      this._paneClipper.addListener("resize", this._onResizePane, this); // if we have overlayed scroll bars, we should use a separate container


      if (qx.core.Environment.get("os.scrollBarOverlayed")) {
        this.__clipperContainer__P_521_4 = new qx.ui.container.Composite();

        this.__clipperContainer__P_521_4.setLayout(new qx.ui.layout.Canvas());

        this.__clipperContainer__P_521_4.add(this._paneClipper, {
          edge: 0
        });

        this._add(this.__clipperContainer__P_521_4, {
          row: 1,
          column: 0
        });
      } else {
        this._add(this._paneClipper, {
          row: 1,
          column: 0
        });
      } // init scroll bars


      this.__horScrollBar__P_521_5 = this._showChildControl("scrollbar-x");
      this.__verScrollBar__P_521_6 = this._showChildControl("scrollbar-y"); // init focus indicator

      this.__focusIndicator__P_521_7 = this.getChildControl("focus-indicator"); // need to run the apply method at least once [BUG #4057]

      this.initShowCellFocusIndicator(); // force creation of the resize line

      this.getChildControl("resize-line").hide();
      this.addListener("pointerout", this._onPointerout, this);
      this.addListener("appear", this._onAppear, this);
      this.addListener("disappear", this._onDisappear, this);
      this.__timer__P_521_8 = new qx.event.Timer();

      this.__timer__P_521_8.addListener("interval", this._oninterval, this);

      this.initScrollTimeout();
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {int} The minimum width a column could get in pixels. */
      MIN_COLUMN_WIDTH: 10,

      /** @type {int} The radius of the resize region in pixels. */
      RESIZE_REGION_RADIUS: 5,

      /**
       * (int) The number of pixels the pointer may move between pointer down and pointer up
       * in order to count as a tap.
       */
      TAP_TOLERANCE: 5,

      /**
       * (int) The mask for the horizontal scroll bar.
       * May be combined with {@link #VERTICAL_SCROLLBAR}.
       *
       * @see #getNeededScrollBars
       */
      HORIZONTAL_SCROLLBAR: 1,

      /**
       * (int) The mask for the vertical scroll bar.
       * May be combined with {@link #HORIZONTAL_SCROLLBAR}.
       *
       * @see #getNeededScrollBars
       */
      VERTICAL_SCROLLBAR: 2
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    events: {
      /** Dispatched if the pane is scrolled horizontally */
      "changeScrollY": "qx.event.type.Data",

      /** Dispatched if the pane is scrolled vertically */
      "changeScrollX": "qx.event.type.Data",

      /**See {@link qx.ui.table.Table#cellTap}.*/
      "cellTap": "qx.ui.table.pane.CellEvent",

      /*** See {@link qx.ui.table.Table#cellDbltap}.*/
      "cellDbltap": "qx.ui.table.pane.CellEvent",

      /**See {@link qx.ui.table.Table#cellContextmenu}.*/
      "cellContextmenu": "qx.ui.table.pane.CellEvent",

      /** Dispatched when a sortable header was tapped */
      "beforeSort": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether to show the horizontal scroll bar. This is a tri-state
       * value. `true` means show the scroll bar; `false` means exclude it; null
       * means hide it so it retains its space but doesn't show a scroll bar.
       */
      horizontalScrollBarVisible: {
        check: "Boolean",
        init: false,
        apply: "_applyHorizontalScrollBarVisible",
        event: "changeHorizontalScrollBarVisible",
        nullable: true
      },

      /** Whether to show the vertical scroll bar */
      verticalScrollBarVisible: {
        check: "Boolean",
        init: false,
        apply: "_applyVerticalScrollBarVisible",
        event: "changeVerticalScrollBarVisible"
      },

      /** The table pane model. */
      tablePaneModel: {
        check: "qx.ui.table.pane.Model",
        apply: "_applyTablePaneModel",
        event: "changeTablePaneModel"
      },

      /**
       * Whether column resize should be live. If false, during resize only a line is
       * shown and the real resize happens when the user releases the pointer button.
       */
      liveResize: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether the focus should moved when the pointer is moved over a cell. If false
       * the focus is only moved on pointer taps.
       */
      focusCellOnPointerMove: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether to handle selections via the selection manager before setting the
       * focus.  The traditional behavior is to handle selections after setting the
       * focus, but setting the focus means redrawing portions of the table, and
       * some subclasses may want to modify the data to be displayed based on the
       * selection.
       */
      selectBeforeFocus: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether the cell focus indicator should be shown
       */
      showCellFocusIndicator: {
        check: "Boolean",
        init: true,
        apply: "_applyShowCellFocusIndicator"
      },

      /**
       * By default, the "cellContextmenu" event is fired only when a data cell
       * is right-clicked. It is not fired when a right-click occurs in the
       * empty area of the table below the last data row. By turning on this
       * property, "cellContextMenu" events will also be generated when a
       * right-click occurs in that empty area. In such a case, row identifier
       * in the event data will be null, so event handlers can check (row ===
       * null) to handle this case.
       */
      contextMenuFromDataCellsOnly: {
        check: "Boolean",
        init: true
      },

      /**
       * Whether to reset the selection when a header cell is tapped. Since
       * most data models do not have provisions to retain a selection after
       * sorting, the default is to reset the selection in this case. Some data
       * models, however, do have the capability to retain the selection, so
       * when using those, this property should be set to false.
       */
      resetSelectionOnHeaderTap: {
        check: "Boolean",
        init: true
      },

      /**
       * Whether to reset the selection when the unpopulated table area is tapped.
       * The default is false which keeps the behaviour as before
       */
      resetSelectionOnTapBelowRows: {
        check: "Boolean",
        init: false
      },

      /**
       * Interval time (in milliseconds) for the table update timer.
       * Setting this to 0 clears the timer.
       */
      scrollTimeout: {
        check: "Integer",
        init: 100,
        apply: "_applyScrollTimeout"
      },
      appearance: {
        refine: true,
        init: "table-scroller"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __lastRowCount__P_521_9: null,
      __table__P_521_0: null,
      __updateInterval__P_521_10: null,
      __updateContentPlanned__P_521_11: null,
      __onintervalWrapper__P_521_12: null,
      _moveColumn: null,
      __lastMoveColPos__P_521_13: null,
      _lastMoveTargetX: null,
      _lastMoveTargetScroller: null,
      __lastMovePointerPageX__P_521_14: null,
      __resizeColumn__P_521_15: null,
      __lastResizePointerPageX__P_521_16: null,
      __lastResizeWidth__P_521_17: null,
      __lastPointerDownCell__P_521_18: null,
      __firedTapEvent__P_521_19: false,
      __ignoreTap__P_521_20: null,
      __lastPointerPageX__P_521_21: null,
      __lastPointerPageY__P_521_22: null,
      __focusedCol__P_521_23: null,
      __focusedRow__P_521_24: null,
      _cellEditor: null,
      __cellEditorFactory__P_521_25: null,
      __topRightWidget__P_521_26: null,
      __horScrollBar__P_521_5: null,
      __verScrollBar__P_521_6: null,
      __header__P_521_1: null,
      _headerClipper: null,
      __tablePane__P_521_2: null,
      _paneClipper: null,
      __clipperContainer__P_521_4: null,
      __focusIndicator__P_521_7: null,
      __top__P_521_3: null,
      __timer__P_521_8: null,
      __focusIndicatorPointerDownListener__P_521_27: null,

      /**
       * The right inset of the pane. The right inset is the maximum of the
       * top right widget width and the scrollbar width (if visible).
       *
       * @return {Integer} The right inset of the pane
       */
      getPaneInsetRight: function getPaneInsetRight() {
        var topRight = this.getTopRightWidget();
        var topRightWidth = topRight && topRight.isVisible() && topRight.getBounds() ? topRight.getBounds().width + topRight.getMarginLeft() + topRight.getMarginRight() : 0;
        var scrollBar = this.__verScrollBar__P_521_6;
        var scrollBarWidth = this.getVerticalScrollBarVisible() ? this.getVerticalScrollBarWidth() + scrollBar.getMarginLeft() + scrollBar.getMarginRight() : 0;
        return Math.max(topRightWidth, scrollBarWidth);
      },

      /**
       * Set the pane's width
       *
       * @param width {Integer} The pane's width
       */
      setPaneWidth: function setPaneWidth(width) {
        if (this.isVerticalScrollBarVisible()) {
          width += this.getPaneInsetRight();
        }

        this.setWidth(width);
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "header":
            control = this.getTable().getNewTablePaneHeader()(this);
            break;

          case "pane":
            control = this.getTable().getNewTablePane()(this);
            break;

          case "focus-indicator":
            control = new qx.ui.table.pane.FocusIndicator(this);
            control.setUserBounds(0, 0, 0, 0);
            control.setZIndex(1000);
            control.addListener("pointerup", this._onPointerupFocusIndicator, this);

            this._paneClipper.add(control);

            control.show(); // must be active for editor to operate

            control.setDecorator(null); // it can be initially invisible, though.

            break;

          case "resize-line":
            control = new qx.ui.core.Widget();
            control.setUserBounds(0, 0, 0, 0);
            control.setZIndex(1000);

            this._paneClipper.add(control);

            break;

          case "scrollbar-x":
            control = this._createScrollBar("horizontal").set({
              alignY: "bottom"
            });
            control.addListener("scroll", this._onScrollX, this);

            if (this.__clipperContainer__P_521_4 != null) {
              control.setMinHeight(qx.ui.core.scroll.AbstractScrollArea.DEFAULT_SCROLLBAR_WIDTH);

              this.__clipperContainer__P_521_4.add(control, {
                bottom: 0,
                right: 0,
                left: 0
              });
            } else {
              this._add(control, {
                row: 2,
                column: 0
              });
            }

            break;

          case "scrollbar-y":
            control = this._createScrollBar("vertical");
            control.addListener("scroll", this._onScrollY, this);

            if (this.__clipperContainer__P_521_4 != null) {
              this.__clipperContainer__P_521_4.add(control, {
                right: 0,
                bottom: 0,
                top: 0
              });
            } else {
              this._add(control, {
                row: 1,
                column: 1
              });
            }

            break;
        }

        return control || qx.ui.table.pane.Scroller.prototype._createChildControlImpl.base.call(this, id);
      },
      // property modifier
      _applyHorizontalScrollBarVisible: function _applyHorizontalScrollBarVisible(value, old) {
        if (value === null) {
          this.__horScrollBar__P_521_5.setVisibility("hidden");
        } else {
          this.__horScrollBar__P_521_5.setVisibility(value ? "visible" : "excluded");
        }
      },
      // property modifier
      _applyVerticalScrollBarVisible: function _applyVerticalScrollBarVisible(value, old) {
        this.__verScrollBar__P_521_6.setVisibility(value ? "visible" : "excluded");
      },
      // property modifier
      _applyTablePaneModel: function _applyTablePaneModel(value, old) {
        if (old != null) {
          old.removeListener("modelChanged", this._onPaneModelChanged, this);
        }

        value.addListener("modelChanged", this._onPaneModelChanged, this);
      },
      // property modifier
      _applyShowCellFocusIndicator: function _applyShowCellFocusIndicator(value, old) {
        if (value) {
          this.__focusIndicator__P_521_7.setDecorator("table-scroller-focus-indicator");

          this._updateFocusIndicator();
        } else {
          if (this.__focusIndicator__P_521_7) {
            this.__focusIndicator__P_521_7.setDecorator(null);
          }
        }
      },

      /**
       * Get the current position of the vertical scroll bar.
       *
       * @return {Integer} The current scroll position.
       */
      getScrollY: function getScrollY() {
        return this.__verScrollBar__P_521_6.getPosition();
      },

      /**
       * Set the current position of the vertical scroll bar.
       *
       * @param scrollY {Integer} The new scroll position.
       * @param renderSync {Boolean?false} Whether the table update should be
       *     performed synchronously.
       */
      setScrollY: function setScrollY(scrollY, renderSync) {
        this.__verScrollBar__P_521_6.scrollTo(scrollY);

        if (renderSync) {
          this._updateContent();
        }
      },

      /**
       * Get the current position of the vertical scroll bar.
       *
       * @return {Integer} The current scroll position.
       */
      getScrollX: function getScrollX() {
        return this.__horScrollBar__P_521_5.getPosition();
      },

      /**
       * Set the current position of the vertical scroll bar.
       *
       * @param scrollX {Integer} The new scroll position.
       */
      setScrollX: function setScrollX(scrollX) {
        this.__horScrollBar__P_521_5.scrollTo(scrollX);
      },

      /**
       * Returns the table this scroller belongs to.
       *
       * @return {qx.ui.table.Table} the table.
       */
      getTable: function getTable() {
        return this.__table__P_521_0;
      },

      /**
       * Creates and returns an instance of pane clipper.
       *
       * @return {qx.ui.table.pane.Clipper} pane clipper.
       */
      _createPaneClipper: function _createPaneClipper() {
        return new qx.ui.table.pane.Clipper();
      },

      /**
       * Creates and returns an instance of header clipper.
       *
       * @return {qx.ui.table.pane.Clipper} pane clipper.
       */
      _createHeaderClipper: function _createHeaderClipper() {
        return new qx.ui.table.pane.Clipper();
      },

      /**
       * Event handler. Called when the visibility of a column has changed.
       */
      onColVisibilityChanged: function onColVisibilityChanged() {
        this.updateHorScrollBarMaximum();

        this._updateFocusIndicator();
      },

      /**
       * Sets the column width.
       *
       * @param col {Integer} the column to change the width for.
       * @param width {Integer} the new width.
       */
      setColumnWidth: function setColumnWidth(col, width) {
        this.__header__P_521_1.setColumnWidth(col, width);

        this.__tablePane__P_521_2.setColumnWidth(col, width);

        var paneModel = this.getTablePaneModel();
        var x = paneModel.getX(col);

        if (x != -1) {
          // The change was in this scroller
          this.updateHorScrollBarMaximum();

          this._updateFocusIndicator();
        }
      },

      /**
       * Event handler. Called when the column order has changed.
       *
       */
      onColOrderChanged: function onColOrderChanged() {
        this.__header__P_521_1.onColOrderChanged();

        this.__tablePane__P_521_2.onColOrderChanged();

        this.updateHorScrollBarMaximum();
      },

      /**
       * Event handler. Called when the table model has changed.
       *
       * @param firstRow {Integer} The index of the first row that has changed.
       * @param lastRow {Integer} The index of the last row that has changed.
       * @param firstColumn {Integer} The model index of the first column that has changed.
       * @param lastColumn {Integer} The model index of the last column that has changed.
       */
      onTableModelDataChanged: function onTableModelDataChanged(firstRow, lastRow, firstColumn, lastColumn) {
        this.__tablePane__P_521_2.onTableModelDataChanged(firstRow, lastRow, firstColumn, lastColumn);

        var rowCount = this.getTable().getTableModel().getRowCount();

        var colCount = this.__table__P_521_0.getTableColumnModel().getOverallColumnCount();

        if (rowCount != this.__lastRowCount__P_521_9) {
          this.updateVerScrollBarMaximum();

          if (this.getFocusedRow() === null && rowCount > 0 && colCount > 0) {
            this.setFocusedCell(this.getFocusedColumn() || 0, 0);
          } else if (this.getFocusedRow() >= rowCount) {
            if (rowCount == 0) {
              this.setFocusedCell(null, null);
            } else {
              this.setFocusedCell(this.getFocusedColumn(), rowCount - 1);
            }
          }

          this.__lastRowCount__P_521_9 = rowCount;
        }
      },

      /**
       * Event handler. Called when the selection has changed.
       */
      onSelectionChanged: function onSelectionChanged() {
        this.__tablePane__P_521_2.onSelectionChanged();
      },

      /**
       * Event handler. Called when the table gets or looses the focus.
       */
      onFocusChanged: function onFocusChanged() {
        this.__tablePane__P_521_2.onFocusChanged();
      },

      /**
       * Event handler. Called when the table model meta data has changed.
       *
       */
      onTableModelMetaDataChanged: function onTableModelMetaDataChanged() {
        this.__header__P_521_1.onTableModelMetaDataChanged();

        this.__tablePane__P_521_2.onTableModelMetaDataChanged();
      },

      /**
       * Event handler. Called when the pane model has changed.
       */
      _onPaneModelChanged: function _onPaneModelChanged() {
        this.__header__P_521_1.onPaneModelChanged();

        this.__tablePane__P_521_2.onPaneModelChanged();
      },

      /**
       * Event listener for the pane clipper's resize event
       */
      _onResizePane: function _onResizePane() {
        this.updateHorScrollBarMaximum();
        this.updateVerScrollBarMaximum(); // The height has changed -> Update content

        this._updateContent();

        this.__header__P_521_1._updateContent();

        this.__table__P_521_0._updateScrollBarVisibility();
      },

      /**
       * Updates the maximum of the horizontal scroll bar, so it corresponds to the
       * total width of the columns in the table pane.
       */
      updateHorScrollBarMaximum: function updateHorScrollBarMaximum() {
        var paneSize = this._paneClipper.getInnerSize();

        if (!paneSize) {
          // will be called on the next resize event again
          return;
        }

        var scrollSize = this.getTablePaneModel().getTotalWidth();
        var scrollBar = this.__horScrollBar__P_521_5;

        if (paneSize.width < scrollSize) {
          var max = Math.max(0, scrollSize - paneSize.width);
          scrollBar.setMaximum(max);
          scrollBar.setKnobFactor(paneSize.width / scrollSize);
          var pos = scrollBar.getPosition();
          scrollBar.setPosition(Math.min(pos, max));
        } else {
          scrollBar.setMaximum(0);
          scrollBar.setKnobFactor(1);
          scrollBar.setPosition(0);
        }
      },

      /**
       * Updates the maximum of the vertical scroll bar, so it corresponds to the
       * number of rows in the table.
       */
      updateVerScrollBarMaximum: function updateVerScrollBarMaximum() {
        var paneSize = this._paneClipper.getInnerSize();

        if (!paneSize) {
          // will be called on the next resize event again
          return;
        }

        var tableModel = this.getTable().getTableModel();
        var rowCount = tableModel.getRowCount();

        if (this.getTable().getKeepFirstVisibleRowComplete()) {
          rowCount += 1;
        }

        var rowHeight = this.getTable().getRowHeight();
        var scrollSize = rowCount * rowHeight;
        var scrollBar = this.__verScrollBar__P_521_6;

        if (paneSize.height < scrollSize) {
          var max = Math.max(0, scrollSize - paneSize.height);
          scrollBar.setMaximum(max);
          scrollBar.setKnobFactor(paneSize.height / scrollSize);
          var pos = scrollBar.getPosition();
          scrollBar.setPosition(Math.min(pos, max));
        } else {
          scrollBar.setMaximum(0);
          scrollBar.setKnobFactor(1);
          scrollBar.setPosition(0);
        }
      },

      /**
       * Event handler. Called when the table property "keepFirstVisibleRowComplete"
       * changed.
       */
      onKeepFirstVisibleRowCompleteChanged: function onKeepFirstVisibleRowCompleteChanged() {
        this.updateVerScrollBarMaximum();

        this._updateContent();
      },

      /**
       * Event handler for the scroller's appear event
       */
      _onAppear: function _onAppear() {
        // after the Scroller appears we start the interval again
        this._startInterval(this.getScrollTimeout());
      },

      /**
       * Event handler for the disappear event
       */
      _onDisappear: function _onDisappear() {
        // before the scroller disappears we need to stop it
        this._stopInterval();
      },

      /**
       * Event handler. Called when the horizontal scroll bar moved.
       *
       * @param e {Map} the event.
       */
      _onScrollX: function _onScrollX(e) {
        var scrollLeft = e.getData();
        this.fireDataEvent("changeScrollX", scrollLeft, e.getOldData());

        this._headerClipper.scrollToX(scrollLeft);

        this._paneClipper.scrollToX(scrollLeft);
      },

      /**
       * Event handler. Called when the vertical scroll bar moved.
       *
       * @param e {Map} the event.
       */
      __inOnScrollY__P_521_28: false,
      _onScrollY: function _onScrollY(e) {
        if (this.__inOnScrollY__P_521_28) {
          return;
        }

        var scrollbar = this.__verScrollBar__P_521_6;
        this.__inOnScrollY__P_521_28 = true; // calculate delta so that one row is scrolled at an minimum

        var rowHeight = this.getTable().getRowHeight();
        var delta = e.getData() - e.getOldData();

        if (Math.abs(delta) > 1 && Math.abs(delta) < rowHeight) {
          delta = delta < 0 ? e.getOldData() - rowHeight : e.getOldData() + rowHeight;

          if (delta >= 0 && delta <= scrollbar.getMaximum()) {
            scrollbar.setPosition(delta);
          }
        }

        this.__inOnScrollY__P_521_28 = false;
        this.fireDataEvent("changeScrollY", scrollbar.getPosition(), e.getOldData());

        this._postponedUpdateContent();
      },

      /**
       * Event handler. Called when the user moved the mouse wheel.
       *
       * @param e {qx.event.type.Roll} the event.
       */
      _onRoll: function _onRoll(e) {
        var table = this.getTable();

        if (e.getPointerType() == "mouse" || !table.getEnabled()) {
          return;
        } // vertical scrolling


        var delta = e.getDelta(); // normalize that at least one step is scrolled at a time

        if (delta.y > 0 && delta.y < 1) {
          delta.y = 1;
        } else if (delta.y < 0 && delta.y > -1) {
          delta.y = -1;
        }

        this.__verScrollBar__P_521_6.scrollBy(parseInt(delta.y, 10));

        var scrolled = delta.y != 0 && !this.__isAtEdge__P_521_29(this.__verScrollBar__P_521_6, delta.y); // horizontal scrolling
        // normalize that at least one step is scrolled at a time

        if (delta.x > 0 && delta.x < 1) {
          delta.x = 1;
        } else if (delta.x < 0 && delta.x > -1) {
          delta.x = -1;
        }

        this.__horScrollBar__P_521_5.scrollBy(parseInt(delta.x, 10)); // Update the focus


        if (this.__lastPointerPageX__P_521_21 && this.getFocusCellOnPointerMove()) {
          this._focusCellAtPagePos(this.__lastPointerPageX__P_521_21, this.__lastPointerPageY__P_521_22);
        }

        scrolled = scrolled || delta.x != 0 && !this.__isAtEdge__P_521_29(this.__horScrollBar__P_521_5, delta.x); // pass the event to the parent if the scrollbar is at an edge

        if (scrolled) {
          e.stop();
        } else {
          e.stopMomentum();
        }
      },

      /**
       * Checks if the table has been scrolled.
       * @param scrollBar {qx.ui.core.scroll.IScrollBar} The scrollbar to check
       * @param delta {Number} The scroll delta.
       * @return {Boolean} <code>true</code>, if the scrolling is a the edge
       */
      __isAtEdge__P_521_29: function __isAtEdge__P_521_29(scrollBar, delta) {
        var position = scrollBar.getPosition();
        return delta < 0 && position <= 0 || delta > 0 && position >= scrollBar.getMaximum();
      },

      /**
       * Common column resize logic.
       *
       * @param pageX {Integer} the current pointer x position.
       */
      __handleResizeColumn__P_521_30: function __handleResizeColumn__P_521_30(pageX) {
        var table = this.getTable(); // We are currently resizing -> Update the position

        var headerCell = this.__header__P_521_1.getHeaderWidgetAtColumn(this.__resizeColumn__P_521_15);

        var minColumnWidth = headerCell.getSizeHint().minWidth;
        var newWidth = Math.max(minColumnWidth, this.__lastResizeWidth__P_521_17 + pageX - this.__lastResizePointerPageX__P_521_16);

        if (this.getLiveResize()) {
          var columnModel = table.getTableColumnModel();
          columnModel.setColumnWidth(this.__resizeColumn__P_521_15, newWidth, true);
        } else {
          var paneModel = this.getTablePaneModel();

          this._showResizeLine(paneModel.getColumnLeft(this.__resizeColumn__P_521_15) + newWidth);
        }

        this.__lastResizePointerPageX__P_521_16 += newWidth - this.__lastResizeWidth__P_521_17;
        this.__lastResizeWidth__P_521_17 = newWidth;
      },

      /**
       * Common column move logic.
       *
       * @param pageX {Integer} the current pointer x position.
       *
       */
      __handleMoveColumn__P_521_31: function __handleMoveColumn__P_521_31(pageX) {
        // We are moving a column
        // Check whether we moved outside the tap tolerance so we can start
        // showing the column move feedback
        // (showing the column move feedback prevents the ontap event)
        var tapTolerance = qx.ui.table.pane.Scroller.TAP_TOLERANCE;

        if (this.__header__P_521_1.isShowingColumnMoveFeedback() || pageX > this.__lastMovePointerPageX__P_521_14 + tapTolerance || pageX < this.__lastMovePointerPageX__P_521_14 - tapTolerance) {
          this.__lastMoveColPos__P_521_13 += pageX - this.__lastMovePointerPageX__P_521_14;

          this.__header__P_521_1.showColumnMoveFeedback(this._moveColumn, this.__lastMoveColPos__P_521_13); // Get the responsible scroller


          var targetScroller = this.__table__P_521_0.getTablePaneScrollerAtPageX(pageX);

          if (this._lastMoveTargetScroller && this._lastMoveTargetScroller != targetScroller) {
            this._lastMoveTargetScroller.hideColumnMoveFeedback();
          }

          if (targetScroller != null) {
            this._lastMoveTargetX = targetScroller.showColumnMoveFeedback(pageX);
          } else {
            this._lastMoveTargetX = null;
          }

          this._lastMoveTargetScroller = targetScroller;
          this.__lastMovePointerPageX__P_521_14 = pageX;
        }
      },

      /**
       * Event handler. Called when the user moved the pointer over the header.
       *
       * @param e {Map} the event.
       */
      _onPointermoveHeader: function _onPointermoveHeader(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        var useResizeCursor = false;
        var pointerOverColumn = null;
        var pageX = e.getDocumentLeft();
        var pageY = e.getDocumentTop(); // Workaround: In onmousewheel the event has wrong coordinates for pageX
        //       and pageY. So we remember the last move event.

        this.__lastPointerPageX__P_521_21 = pageX;
        this.__lastPointerPageY__P_521_22 = pageY;

        if (this.__resizeColumn__P_521_15 != null) {
          // We are currently resizing -> Update the position
          this.__handleResizeColumn__P_521_30(pageX);

          useResizeCursor = true;
          e.stopPropagation();
        } else if (this._moveColumn != null) {
          // We are moving a column
          this.__handleMoveColumn__P_521_31(pageX);

          e.stopPropagation();
        } else {
          var resizeCol = this._getResizeColumnForPageX(pageX);

          if (resizeCol != -1) {
            // The pointer is over a resize region -> Show the right cursor
            useResizeCursor = true;
          } else {
            var tableModel = table.getTableModel();

            var col = this._getColumnForPageX(pageX);

            if (col != null && tableModel.isColumnSortable(col)) {
              pointerOverColumn = col;
            }
          }
        }

        var cursor = useResizeCursor ? "col-resize" : null;
        this.getApplicationRoot().setGlobalCursor(cursor);
        this.setCursor(cursor);

        this.__header__P_521_1.setPointerOverColumn(pointerOverColumn);
      },

      /**
       * Event handler. Called when the user moved the pointer over the pane.
       *
       * @param e {Map} the event.
       */
      _onPointermovePane: function _onPointermovePane(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        } //var useResizeCursor = false;


        var pageX = e.getDocumentLeft();
        var pageY = e.getDocumentTop(); // Workaround: In onpointerwheel the event has wrong coordinates for pageX
        //       and pageY. So we remember the last move event.

        this.__lastPointerPageX__P_521_21 = pageX;
        this.__lastPointerPageY__P_521_22 = pageY;
        var useResizeCursor = false;

        var resizeCol = this._getResizeColumnForPageX(pageX);

        if (resizeCol != -1) {
          // The pointer is over a resize region -> Show the right cursor
          useResizeCursor = true;
        }

        var cursor = useResizeCursor ? "col-resize" : null;
        this.getApplicationRoot().setGlobalCursor(cursor);
        this.setCursor(cursor);

        var row = this._getRowForPagePos(pageX, pageY);

        if (row != null && this._getColumnForPageX(pageX) != null) {
          // The pointer is over the data -> update the focus
          if (this.getFocusCellOnPointerMove()) {
            this._focusCellAtPagePos(pageX, pageY);
          }
        }

        this.__header__P_521_1.setPointerOverColumn(null);
      },

      /**
       * Event handler. Called when the user pressed a pointer button over the header.
       *
       * @param e {Map} the event.
       */
      _onPointerdownHeader: function _onPointerdownHeader(e) {
        if (!this.getTable().getEnabled()) {
          return;
        }

        var pageX = e.getDocumentLeft(); // pointer is in header

        var resizeCol = this._getResizeColumnForPageX(pageX);

        if (resizeCol != -1) {
          // The pointer is over a resize region -> Start resizing
          this._startResizeHeader(resizeCol, pageX);

          e.stop();
        } else {
          // The pointer is not in a resize region
          var moveCol = this._getColumnForPageX(pageX);

          if (moveCol != null) {
            this._startMoveHeader(moveCol, pageX);

            e.stop();
          }
        }
      },

      /**
       * Start a resize session of the header.
       *
       * @param resizeCol {Integer} the column index
       * @param pageX {Integer} x coordinate of the pointer event
       */
      _startResizeHeader: function _startResizeHeader(resizeCol, pageX) {
        var columnModel = this.getTable().getTableColumnModel(); // The pointer is over a resize region -> Start resizing

        this.__resizeColumn__P_521_15 = resizeCol;
        this.__lastResizePointerPageX__P_521_16 = pageX;
        this.__lastResizeWidth__P_521_17 = columnModel.getColumnWidth(this.__resizeColumn__P_521_15);

        this._headerClipper.capture();
      },

      /**
       * Start a move session of the header.
       *
       * @param moveCol {Integer} the column index
       * @param pageX {Integer} x coordinate of the pointer event
       */
      _startMoveHeader: function _startMoveHeader(moveCol, pageX) {
        // Prepare column moving
        this._moveColumn = moveCol;
        this.__lastMovePointerPageX__P_521_14 = pageX;
        this.__lastMoveColPos__P_521_13 = this.getTablePaneModel().getColumnLeft(moveCol);

        this._headerClipper.capture();
      },

      /**
       * Event handler. Called when the user pressed a pointer button over the pane.
       *
       * @param e {Map} the event.
       */
      _onPointerdownPane: function _onPointerdownPane(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        if (table.isEditing()) {
          table.stopEditing();
        }

        var pageX = e.getDocumentLeft(); // pointer is in header

        var resizeCol = this._getResizeColumnForPageX(pageX);

        if (resizeCol != -1) {
          // The pointer is over a resize region -> Start resizing
          this._startResizeHeader(resizeCol, pageX);

          e.stop();
          return;
        }

        var pageY = e.getDocumentTop();

        var row = this._getRowForPagePos(pageX, pageY);

        var col = this._getColumnForPageX(pageX);

        if (row !== null) {
          // The focus indicator blocks the tap event on the scroller so we
          // store the current cell and listen for the pointerup event on the
          // focus indicator
          //
          // INVARIANT:
          //  The members of this object always contain the last position of
          //  the cell on which the pointerdown event occurred.
          //  *** These values are never cleared! ***.
          //  Different browsers/OS combinations issue events in different
          //  orders, and the context menu event, in particular, can be issued
          //  early or late (Firefox on Linux issues it early; Firefox on
          //  Windows issues it late) so no one may clear these values.
          //
          this.__lastPointerDownCell__P_521_18 = {
            row: row,
            col: col
          }; // On the other hand, we need to know if we've issued the tap event
          // so we don't issue it twice, both from pointer-up on the focus
          // indicator, and from the tap even on the pane. Both possibilities
          // are necessary, however, to maintain the qooxdoo order of events.

          this.__firedTapEvent__P_521_19 = false;
        }
      },

      /**
       * Event handler for the focus indicator's pointerup event
       *
       * @param e {qx.event.type.Pointer} The pointer event
       */
      _onPointerupFocusIndicator: function _onPointerupFocusIndicator(e) {
        if (this.__lastPointerDownCell__P_521_18 && !this.__firedTapEvent__P_521_19 && !this.isEditing() && this.__focusIndicator__P_521_7.getRow() == this.__lastPointerDownCell__P_521_18.row && this.__focusIndicator__P_521_7.getColumn() == this.__lastPointerDownCell__P_521_18.col) {
          this.fireEvent("cellTap", qx.ui.table.pane.CellEvent, [this, e, this.__lastPointerDownCell__P_521_18.row, this.__lastPointerDownCell__P_521_18.col], true);
          this.__firedTapEvent__P_521_19 = true;
        } else if (!this.isEditing()) {
          // if no cellTap event should be fired, act like a pointerdown which
          // invokes the change of the selection e.g. [BUG #1632]
          this._onPointerdownPane(e);
        }
      },

      /**
       * Event handler. Called when the event capturing of the header changed.
       * Stops/finishes an active header resize/move session if it lost capturing
       * during the session to stay in a stable state.
       *
       * @param e {qx.event.type.Data} The data event
       */
      _onChangeCaptureHeader: function _onChangeCaptureHeader(e) {
        if (this.__resizeColumn__P_521_15 != null) {
          this._stopResizeHeader();
        }

        if (this._moveColumn != null) {
          this._stopMoveHeader();
        }
      },

      /**
       * Stop a resize session of the header.
       *
       */
      _stopResizeHeader: function _stopResizeHeader() {
        var columnModel = this.getTable().getTableColumnModel(); // We are currently resizing -> Finish resizing

        if (!this.getLiveResize()) {
          this._hideResizeLine();

          columnModel.setColumnWidth(this.__resizeColumn__P_521_15, this.__lastResizeWidth__P_521_17, true);
        }

        this.__resizeColumn__P_521_15 = null;

        this._headerClipper.releaseCapture();

        this.getApplicationRoot().setGlobalCursor(null);
        this.setCursor(null);
      },

      /**
       * Stop a move session of the header.
       *
       */
      _stopMoveHeader: function _stopMoveHeader() {
        var columnModel = this.getTable().getTableColumnModel();
        var paneModel = this.getTablePaneModel(); // We are moving a column -> Drop the column

        this.__header__P_521_1.hideColumnMoveFeedback();

        if (this._lastMoveTargetScroller) {
          this._lastMoveTargetScroller.hideColumnMoveFeedback();
        }

        if (this._lastMoveTargetX != null) {
          var fromVisXPos = paneModel.getFirstColumnX() + paneModel.getX(this._moveColumn);
          var toVisXPos = this._lastMoveTargetX;

          if (toVisXPos != fromVisXPos && toVisXPos != fromVisXPos + 1) {
            // The column was really moved to another position
            // (and not moved before or after itself, which is a noop)
            // Translate visible positions to overall positions
            var fromCol = columnModel.getVisibleColumnAtX(fromVisXPos);
            var toCol = columnModel.getVisibleColumnAtX(toVisXPos);
            var fromOverXPos = columnModel.getOverallX(fromCol);
            var toOverXPos = toCol != null ? columnModel.getOverallX(toCol) : columnModel.getOverallColumnCount();

            if (toOverXPos > fromOverXPos) {
              // Don't count the column itself
              toOverXPos--;
            } // Move the column


            columnModel.moveColumn(fromOverXPos, toOverXPos); // update the focus indicator including the editor

            this._updateFocusIndicator();
          }
        }

        this._moveColumn = null;
        this._lastMoveTargetX = null;

        this._headerClipper.releaseCapture();
      },

      /**
       * Event handler. Called when the user released a pointer button over the header.
       *
       * @param e {Map} the event.
       */
      _onPointerupHeader: function _onPointerupHeader(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        if (this.__resizeColumn__P_521_15 != null) {
          this._stopResizeHeader();

          this.__ignoreTap__P_521_20 = true;
          e.stop();
        } else if (this._moveColumn != null) {
          this._stopMoveHeader();

          e.stop();
        }
      },

      /**
       * Event handler. Called when the user tapped a pointer button over the header.
       *
       * @param e {Map} the event.
       */
      _onTapHeader: function _onTapHeader(e) {
        if (this.__ignoreTap__P_521_20) {
          this.__ignoreTap__P_521_20 = false;
          return;
        }

        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        var tableModel = table.getTableModel();
        var pageX = e.getDocumentLeft();

        var resizeCol = this._getResizeColumnForPageX(pageX);

        if (resizeCol == -1) {
          // pointer is not in a resize region
          var col = this._getColumnForPageX(pageX);

          if (col != null && tableModel.isColumnSortable(col)) {
            // Sort that column
            var sortCol = tableModel.getSortColumnIndex();
            var ascending = col != sortCol ? true : !tableModel.isSortAscending();
            var data = {
              column: col,
              ascending: ascending,
              tapEvent: e
            };

            if (this.fireDataEvent("beforeSort", data, null, true)) {
              // Stop cell editing
              if (table.isEditing()) {
                table.stopEditing();
              }

              tableModel.sortByColumn(col, ascending);

              if (this.getResetSelectionOnHeaderTap()) {
                table.getSelectionModel().resetSelection();
              }
            }
          }
        }

        e.stop();
      },

      /**
       * Event handler. Called when the user tapped a pointer button over the pane.
       *
       * @param e {Map} the event.
       */
      _onTapPane: function _onTapPane(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        var pageX = e.getDocumentLeft();
        var pageY = e.getDocumentTop();

        var row = this._getRowForPagePos(pageX, pageY);

        var col = this._getColumnForPageX(pageX);

        if (row != null && col != null) {
          var selectBeforeFocus = this.getSelectBeforeFocus();

          if (selectBeforeFocus) {
            table.getSelectionManager().handleTap(row, e);
          } // The pointer is over the data -> update the focus


          if (!this.getFocusCellOnPointerMove()) {
            this._focusCellAtPagePos(pageX, pageY);
          }

          if (!selectBeforeFocus) {
            table.getSelectionManager().handleTap(row, e);
          }

          if (this.__focusIndicator__P_521_7.isHidden() || this.__lastPointerDownCell__P_521_18 && !this.__firedTapEvent__P_521_19 && !this.isEditing() && row == this.__lastPointerDownCell__P_521_18.row && col == this.__lastPointerDownCell__P_521_18.col) {
            this.fireEvent("cellTap", qx.ui.table.pane.CellEvent, [this, e, row, col], true);
            this.__firedTapEvent__P_521_19 = true;
          }
        } else {
          if (row == null && this.getResetSelectionOnTapBelowRows()) {
            table.getSelectionModel().resetSelection();
          }
        }
      },

      /**
       * Event handler. Called when a context menu is invoked in a cell.
       *
       * @param e {qx.event.type.Pointer} the event.
       */
      _onContextMenu: function _onContextMenu(e) {
        var pageX = e.getDocumentLeft();
        var pageY = e.getDocumentTop();

        var row = this._getRowForPagePos(pageX, pageY);

        var col = this._getColumnForPageX(pageX);
        /*
         * The 'row' value will be null if the right-click was in the blank
         * area below the last data row. Some applications desire to receive
         * the context menu event anyway, and can set the property value of
         * contextMenuFromDataCellsOnly to false to achieve that.
         */


        if (row === null && this.getContextMenuFromDataCellsOnly()) {
          return;
        }

        if (!this.getShowCellFocusIndicator() || row === null || this.__lastPointerDownCell__P_521_18 && row == this.__lastPointerDownCell__P_521_18.row && col == this.__lastPointerDownCell__P_521_18.col) {
          this.fireEvent("cellContextmenu", qx.ui.table.pane.CellEvent, [this, e, row, col], true); // Now that the cellContextmenu handler has had a chance to build
          // the menu for this cell, display it (if there is one).

          var menu = this.getTable().getContextMenu();

          if (menu) {
            // A menu with no children means don't display any context menu
            // including the default context menu even if the default context
            // menu is allowed to be displayed normally. There's no need to
            // actually show an empty menu, though.
            if (menu.getChildren().length > 0) {
              menu.openAtPointer(e);
            } else {
              menu.exclude();
            } // Do not show native menu


            e.preventDefault();
          }
        }
      },
      // overridden
      _onContextMenuOpen: function _onContextMenuOpen(e) {// This is Widget's context menu handler which typically retrieves
        // and displays the menu as soon as it receives a "contextmenu" event.
        // We want to allow the cellContextmenu handler to create the menu,
        // so we'll override this method with a null one, and do the menu
        // placement and display handling in our _onContextMenu method.
      },

      /**
       * Event handler. Called when the user double tapped a pointer button over the pane.
       *
       * @param e {Map} the event.
       */
      _onDbltapPane: function _onDbltapPane(e) {
        var pageX = e.getDocumentLeft();
        var pageY = e.getDocumentTop();

        var col = this._getColumnForPageX(pageX);

        if (col !== null) {
          this._focusCellAtPagePos(pageX, pageY);

          this.startEditing();

          var row = this._getRowForPagePos(pageX, pageY);

          if (row != -1 && row != null) {
            this.fireEvent("cellDbltap", qx.ui.table.pane.CellEvent, [this, e, row], true);
          }
        }
      },

      /**
       * Event handler. Called when the pointer moved out.
       *
       * @param e {Map} the event.
       */
      _onPointerout: function _onPointerout(e) {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        } // Reset the resize cursor when the pointer leaves the header
        // If currently a column is resized then do nothing
        // (the cursor will be reset on pointerup)


        if (this.__resizeColumn__P_521_15 == null) {
          this.setCursor(null);
          this.getApplicationRoot().setGlobalCursor(null);
        }

        this.__header__P_521_1.setPointerOverColumn(null); // in case the focus follows the pointer, it should be remove on pointerout


        if (this.getFocusCellOnPointerMove()) {
          this.__table__P_521_0.setFocusedCell();
        }
      },

      /**
       * Shows the resize line.
       *
       * @param x {Integer} the position where to show the line (in pixels, relative to
       *      the left side of the pane).
       */
      _showResizeLine: function _showResizeLine(x) {
        var resizeLine = this._showChildControl("resize-line");

        var width = resizeLine.getWidth();

        var paneBounds = this._paneClipper.getBounds();

        resizeLine.setUserBounds(x - Math.round(width / 2), 0, width, paneBounds.height);
      },

      /**
       * Hides the resize line.
       */
      _hideResizeLine: function _hideResizeLine() {
        this._excludeChildControl("resize-line");
      },

      /**
       * Shows the feedback shown while a column is moved by the user.
       *
       * @param pageX {Integer} the x position of the pointer in the page (in pixels).
       * @return {Integer} the visible x position of the column in the whole table.
       */
      showColumnMoveFeedback: function showColumnMoveFeedback(pageX) {
        var paneModel = this.getTablePaneModel();
        var columnModel = this.getTable().getTableColumnModel();

        var paneLeft = this.__tablePane__P_521_2.getContentLocation().left;

        var colCount = paneModel.getColumnCount();
        var targetXPos = 0;
        var targetX = 0;
        var currX = paneLeft;

        for (var xPos = 0; xPos < colCount; xPos++) {
          var col = paneModel.getColumnAtX(xPos);
          var colWidth = columnModel.getColumnWidth(col);

          if (pageX < currX + colWidth / 2) {
            break;
          }

          currX += colWidth;
          targetXPos = xPos + 1;
          targetX = currX - paneLeft;
        } // Ensure targetX is visible


        var scrollerLeft = this._paneClipper.getContentLocation().left;

        var scrollerWidth = this._paneClipper.getBounds().width;

        var scrollX = scrollerLeft - paneLeft; // NOTE: +2/-1 because of feedback width

        targetX = qx.lang.Number.limit(targetX, scrollX + 2, scrollX + scrollerWidth - 1);

        this._showResizeLine(targetX); // Return the overall target x position


        return paneModel.getFirstColumnX() + targetXPos;
      },

      /**
       * Hides the feedback shown while a column is moved by the user.
       */
      hideColumnMoveFeedback: function hideColumnMoveFeedback() {
        this._hideResizeLine();
      },

      /**
       * Sets the focus to the cell that's located at the page position
       * <code>pageX</code>/<code>pageY</code>. If there is no cell at that position,
       * nothing happens.
       *
       * @param pageX {Integer} the x position in the page (in pixels).
       * @param pageY {Integer} the y position in the page (in pixels).
       */
      _focusCellAtPagePos: function _focusCellAtPagePos(pageX, pageY) {
        var row = this._getRowForPagePos(pageX, pageY);

        if (row != -1 && row != null) {
          // The pointer is over the data -> update the focus
          var col = this._getColumnForPageX(pageX);

          this.__table__P_521_0.setFocusedCell(col, row);
        }
      },

      /**
       * Sets the currently focused cell.
       *
       * @param col {Integer} the model index of the focused cell's column.
       * @param row {Integer} the model index of the focused cell's row.
       */
      setFocusedCell: function setFocusedCell(col, row) {
        if (!this.isEditing()) {
          this.__tablePane__P_521_2.setFocusedCell(col, row, this.__updateContentPlanned__P_521_11);

          this.__focusedCol__P_521_23 = col;
          this.__focusedRow__P_521_24 = row;

          this._updateFocusIndicator();
        }
      },

      /**
       * Returns the column of currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedColumn: function getFocusedColumn() {
        return this.__focusedCol__P_521_23;
      },

      /**
       * Returns the row of currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedRow: function getFocusedRow() {
        return this.__focusedRow__P_521_24;
      },

      /**
       * Scrolls a cell visible.
       *
       * @param col {Integer} the model index of the column the cell belongs to.
       * @param row {Integer} the model index of the row the cell belongs to.
       */
      scrollCellVisible: function scrollCellVisible(col, row) {
        var paneModel = this.getTablePaneModel();
        var xPos = paneModel.getX(col);

        if (xPos != -1) {
          var clipperSize = this._paneClipper.getInnerSize();

          if (!clipperSize) {
            return;
          }

          var columnModel = this.getTable().getTableColumnModel();
          var colLeft = paneModel.getColumnLeft(col);
          var colWidth = columnModel.getColumnWidth(col);
          var rowHeight = this.getTable().getRowHeight();
          var rowTop = row * rowHeight;
          var scrollX = this.getScrollX();
          var scrollY = this.getScrollY(); // NOTE: We don't use qx.lang.Number.limit, because min should win if max < min

          var minScrollX = Math.min(colLeft, colLeft + colWidth - clipperSize.width);
          var maxScrollX = colLeft;
          this.setScrollX(Math.max(minScrollX, Math.min(maxScrollX, scrollX)));
          var minScrollY = rowTop + rowHeight - clipperSize.height;

          if (this.getTable().getKeepFirstVisibleRowComplete()) {
            minScrollY += rowHeight;
          }

          var maxScrollY = rowTop;
          this.setScrollY(Math.max(minScrollY, Math.min(maxScrollY, scrollY)), true);
        }
      },

      /**
       * Returns whether currently a cell is editing.
       *
       * @return {var} whether currently a cell is editing.
       */
      isEditing: function isEditing() {
        return this._cellEditor != null;
      },

      /**
       * Starts editing the currently focused cell. Does nothing if already
       * editing, if the column is not editable, or if the cell editor for the
       * column ascertains that the particular cell is not editable.
       *
       * @return {Boolean} whether editing was started
       */
      startEditing: function startEditing() {
        var table = this.getTable();
        var tableModel = table.getTableModel();
        var col = this.__focusedCol__P_521_23;

        if (!this.isEditing() && col != null && tableModel.isColumnEditable(col)) {
          var row = this.__focusedRow__P_521_24;
          var xPos = this.getTablePaneModel().getX(col);
          var value = tableModel.getValue(col, row); // scroll cell into view

          this.scrollCellVisible(col, row);
          this.__cellEditorFactory__P_521_25 = table.getTableColumnModel().getCellEditorFactory(col);
          var cellInfo = {
            col: col,
            row: row,
            xPos: xPos,
            value: value,
            table: table
          }; // Get a cell editor

          this._cellEditor = this.__cellEditorFactory__P_521_25.createCellEditor(cellInfo); // We handle two types of cell editors: the traditional in-place
          // editor, where the cell editor returned by the factory must fit in
          // the space of the table cell; and a modal window in which the
          // editing takes place.  Additionally, if the cell editor determines
          // that it does not want to edit the particular cell being requested,
          // it may return null to indicate that that cell is not editable.

          if (this._cellEditor === null) {
            // This cell is not editable even though its column is.
            return false;
          } else if (this._cellEditor instanceof qx.ui.window.Window) {
            // It's a window.  Ensure that it's modal.
            this._cellEditor.setModal(true); // At least for the time being, we disallow the close button.  It
            // acts differently than a cellEditor.close(), and invokes a bug
            // someplace.  Modal window cell editors should provide their own
            // buttons or means to activate a cellEditor.close() or equivalently
            // cellEditor.hide().


            this._cellEditor.setShowClose(false); // Arrange to be notified when it is closed.


            this._cellEditor.addListener("close", this._onCellEditorModalWindowClose, this); // If there's a pre-open function defined for the table...


            var f = table.getModalCellEditorPreOpenFunction();

            if (f != null) {
              f(this._cellEditor, cellInfo);
            } // Open it now.


            this._cellEditor.open();
          } else {
            // prevent tap event from bubbling up to the table
            this.__focusIndicatorPointerDownListener__P_521_27 = this.__focusIndicator__P_521_7.addListener("pointerdown", function (e) {
              this.__lastPointerDownCell__P_521_18 = {
                row: this.__focusedRow__P_521_24,
                col: this.__focusedCol__P_521_23
              };
              e.stopPropagation();
            }, this);

            this.__focusIndicator__P_521_7.add(this._cellEditor);

            this.__focusIndicator__P_521_7.addState("editing");

            this.__focusIndicator__P_521_7.setKeepActive(false); // Make the focus indicator visible during editing


            this.__focusIndicator__P_521_7.setDecorator("table-scroller-focus-indicator");

            this._cellEditor.focus();

            this._cellEditor.activate();
          }

          return true;
        }

        return false;
      },

      /**
       * Stops editing and writes the editor's value to the model.
       */
      stopEditing: function stopEditing() {
        // If the focus indicator is not being shown normally...
        if (!this.getShowCellFocusIndicator()) {
          // ... then hide it again
          this.__focusIndicator__P_521_7.setDecorator(null);
        }

        this.flushEditor(true);
      },

      /**
       * Writes the editor's value to the model
       * 
       * @param cancel {Boolean ? false} Whether to also cancel 
       *      editing before firing the 'dateEdited' event.
       */
      flushEditor: function flushEditor(cancel) {
        if (this.isEditing()) {
          var value = this.__cellEditorFactory__P_521_25.getCellEditorValue(this._cellEditor);

          var oldValue = this.getTable().getTableModel().getValue(this.__focusedCol__P_521_23, this.__focusedRow__P_521_24);
          this.getTable().getTableModel().setValue(this.__focusedCol__P_521_23, this.__focusedRow__P_521_24, value);

          this.__table__P_521_0.focus();

          if (cancel) {
            this.cancelEditing();
          } // Fire an event containing the value change.


          this.__table__P_521_0.fireDataEvent("dataEdited", {
            row: this.__focusedRow__P_521_24,
            col: this.__focusedCol__P_521_23,
            oldValue: oldValue,
            value: value
          });
        }
      },

      /**
       * Stops editing without writing the editor's value to the model.
       */
      cancelEditing: function cancelEditing() {
        if (this.isEditing()) {
          if (!(this._cellEditor instanceof qx.ui.window.Window)) {
            this.__focusIndicator__P_521_7.removeState("editing");

            this.__focusIndicator__P_521_7.setKeepActive(true);

            if (this.__focusIndicatorPointerDownListener__P_521_27 !== null) {
              this.__focusIndicator__P_521_7.removeListenerById(this.__focusIndicatorPointerDownListener__P_521_27);

              this.__focusIndicatorPointerDownListener__P_521_27 = null;
            }
          }

          this._cellEditor.destroy();

          this._cellEditor = null;
          this.__cellEditorFactory__P_521_25 = null;
        }
      },

      /**
       * Event handler. Called when the modal window of the cell editor closes.
       *
       * @param e {Map} the event.
       */
      _onCellEditorModalWindowClose: function _onCellEditorModalWindowClose(e) {
        this.stopEditing();
      },

      /**
       * Returns the model index of the column the pointer is over or null if the pointer
       * is not over a column.
       *
       * @param pageX {Integer} the x position of the pointer in the page (in pixels).
       * @return {Integer} the model index of the column the pointer is over.
       */
      _getColumnForPageX: function _getColumnForPageX(pageX) {
        var columnModel = this.getTable().getTableColumnModel();
        var paneModel = this.getTablePaneModel();
        var colCount = paneModel.getColumnCount();

        var currX = this.__tablePane__P_521_2.getContentLocation().left;

        for (var x = 0; x < colCount; x++) {
          var col = paneModel.getColumnAtX(x);
          var colWidth = columnModel.getColumnWidth(col);
          currX += colWidth;

          if (pageX < currX) {
            return col;
          }
        }

        return null;
      },

      /**
       * Returns the model index of the column that should be resized when dragging
       * starts here. Returns -1 if the pointer is in no resize region of any column.
       *
       * @param pageX {Integer} the x position of the pointer in the page (in pixels).
       * @return {Integer} the column index.
       */
      _getResizeColumnForPageX: function _getResizeColumnForPageX(pageX) {
        var contentLocation = this.__header__P_521_1.getContentLocation() || this.__tablePane__P_521_2.getContentLocation();

        if (contentLocation) {
          var currX = contentLocation.left;
          var columnModel = this.getTable().getTableColumnModel();
          var paneModel = this.getTablePaneModel();
          var colCount = paneModel.getColumnCount();
          var regionRadius = qx.ui.table.pane.Scroller.RESIZE_REGION_RADIUS;

          for (var x = 0; x < colCount; x++) {
            var col = paneModel.getColumnAtX(x);
            var colWidth = columnModel.getColumnWidth(col);
            currX += colWidth;

            if (pageX >= currX - regionRadius && pageX <= currX + regionRadius) {
              return col;
            }
          }
        }

        return -1;
      },

      /**
       * Returns the model index of the row the pointer is currently over. Returns -1 if
       * the pointer is over the header. Returns null if the pointer is not over any
       * column.
       *
       * @param pageX {Integer} the pointer x position in the page.
       * @param pageY {Integer} the pointer y position in the page.
       * @return {Integer} the model index of the row the pointer is currently over.
       */
      _getRowForPagePos: function _getRowForPagePos(pageX, pageY) {
        var panePos = this.__tablePane__P_521_2.getContentLocation();

        if (pageX < panePos.left || pageX > panePos.right) {
          // There was no cell or header cell hit
          return null;
        }

        if (pageY >= panePos.top && pageY <= panePos.bottom) {
          // This event is in the pane -> Get the row
          var rowHeight = this.getTable().getRowHeight();

          var scrollY = this.__verScrollBar__P_521_6.getPosition();

          if (this.getTable().getKeepFirstVisibleRowComplete()) {
            scrollY = Math.floor(scrollY / rowHeight) * rowHeight;
          }

          var tableY = scrollY + pageY - panePos.top;
          var row = Math.floor(tableY / rowHeight);
          var tableModel = this.getTable().getTableModel();
          var rowCount = tableModel.getRowCount();
          return row < rowCount ? row : null;
        }

        var headerPos = this.__header__P_521_1.getContentLocation();

        if (pageY >= headerPos.top && pageY <= headerPos.bottom && pageX <= headerPos.right) {
          // This event is in the pane -> Return -1 for the header
          return -1;
        }

        return null;
      },

      /**
       * Sets the widget that should be shown in the top right corner.
       *
       * The widget will not be disposed, when this table scroller is disposed. So the
       * caller has to dispose it.
       *
       * @param widget {qx.ui.core.Widget} The widget to set. May be null.
       */
      setTopRightWidget: function setTopRightWidget(widget) {
        var oldWidget = this.__topRightWidget__P_521_26;

        if (oldWidget != null) {
          this.__top__P_521_3.remove(oldWidget);
        }

        if (widget != null) {
          this.__top__P_521_3.add(widget);
        }

        this.__topRightWidget__P_521_26 = widget;
      },

      /**
       * Get the top right widget
       *
       * @return {qx.ui.core.Widget} The top right widget.
       */
      getTopRightWidget: function getTopRightWidget() {
        return this.__topRightWidget__P_521_26;
      },

      /**
       * Returns the header.
       *
       * @return {qx.ui.table.pane.Header} the header.
       */
      getHeader: function getHeader() {
        return this.__header__P_521_1;
      },

      /**
       * Returns the table pane.
       *
       * @return {qx.ui.table.pane.Pane} the table pane.
       */
      getTablePane: function getTablePane() {
        return this.__tablePane__P_521_2;
      },

      /**
       * Get the rendered width of the vertical scroll bar. The return value is
       * <code>0</code> if the scroll bar is invisible or not yet rendered.
       *
       * @internal
       * @return {Integer} The width of the vertical scroll bar
       */
      getVerticalScrollBarWidth: function getVerticalScrollBarWidth() {
        var scrollBar = this.__verScrollBar__P_521_6;
        return scrollBar.isVisible() ? scrollBar.getSizeHint().width || 0 : 0;
      },

      /**
       * Returns which scrollbars are needed.
       *
       * @param forceHorizontal {Boolean ? false} Whether to show the horizontal
       *      scrollbar always.
       * @param preventVertical {Boolean ? false} Whether to show the vertical scrollbar
       *      never.
       * @return {Integer} which scrollbars are needed. This may be any combination of
       *      {@link #HORIZONTAL_SCROLLBAR} or {@link #VERTICAL_SCROLLBAR}
       *      (combined by OR).
       */
      getNeededScrollBars: function getNeededScrollBars(forceHorizontal, preventVertical) {
        var verScrollBar = this.__verScrollBar__P_521_6;
        var verBarWidth = verScrollBar.getSizeHint().width + verScrollBar.getMarginLeft() + verScrollBar.getMarginRight();
        var horScrollBar = this.__horScrollBar__P_521_5;
        var horBarHeight = horScrollBar.getSizeHint().height + horScrollBar.getMarginTop() + horScrollBar.getMarginBottom(); // Get the width and height of the view (without scroll bars)

        var clipperSize = this._paneClipper.getInnerSize();

        var viewWidth = clipperSize ? clipperSize.width : 0;

        if (this.getVerticalScrollBarVisible()) {
          viewWidth += verBarWidth;
        }

        var viewHeight = clipperSize ? clipperSize.height : 0;

        if (this.getHorizontalScrollBarVisible()) {
          viewHeight += horBarHeight;
        }

        var tableModel = this.getTable().getTableModel();
        var rowCount = tableModel.getRowCount(); // Get the (virtual) width and height of the pane

        var paneWidth = this.getTablePaneModel().getTotalWidth();
        var paneHeight = this.getTable().getRowHeight() * rowCount; // Check which scrollbars are needed

        var horNeeded = false;
        var verNeeded = false;

        if (paneWidth > viewWidth) {
          horNeeded = true;

          if (paneHeight > viewHeight - horBarHeight) {
            verNeeded = true;
          }
        } else if (paneHeight > viewHeight) {
          verNeeded = true;

          if (!preventVertical && paneWidth > viewWidth - verBarWidth) {
            horNeeded = true;
          }
        } // Create the mask


        var horBar = qx.ui.table.pane.Scroller.HORIZONTAL_SCROLLBAR;
        var verBar = qx.ui.table.pane.Scroller.VERTICAL_SCROLLBAR;
        return (forceHorizontal || horNeeded ? horBar : 0) | (preventVertical || !verNeeded ? 0 : verBar);
      },

      /**
       * Return the pane clipper. It is sometimes required for special activities
       * such as tracking events for drag&drop.
       *
       * @return {qx.ui.table.pane.Clipper}
       *   The pane clipper for this scroller.
       */
      getPaneClipper: function getPaneClipper() {
        return this._paneClipper;
      },

      /**
       * Returns the scroll area container widget (which enables more precise
       * operations e.g. bounds retrieval for drag session scrolling).
       *
       * @see qx.ui.core.MDragDropScrolling#_getBounds
       * @return {qx.ui.table.pane.Clipper}
       *   The pane clipper for this scroller.
       */
      getScrollAreaContainer: function getScrollAreaContainer() {
        return this.getPaneClipper();
      },
      // property apply method
      _applyScrollTimeout: function _applyScrollTimeout(value, old) {
        this._startInterval(value);
      },

      /**
       * Starts the current running interval
       *
       * @param timeout {Integer} The timeout between two table updates
       */
      _startInterval: function _startInterval(timeout) {
        this.__timer__P_521_8.setInterval(timeout);

        this.__timer__P_521_8.start();
      },

      /**
       * stops the current running interval
       */
      _stopInterval: function _stopInterval() {
        this.__timer__P_521_8.stop();
      },

      /**
       * Does a postponed update of the content.
       *
       * @see #_updateContent
       */
      _postponedUpdateContent: function _postponedUpdateContent() {
        //this.__updateContentPlanned = true;
        this._updateContent();
      },

      /**
       * Timer event handler. Periodically checks whether a table update is
       * required. The update interval is controlled by the {@link #scrollTimeout}
       * property.
       *
       * @signature function()
       */
      _oninterval: qx.event.GlobalError.observeMethod(function () {
        if (this.__updateContentPlanned__P_521_11 && !this.__tablePane__P_521_2._layoutPending) {
          this.__updateContentPlanned__P_521_11 = false;

          this._updateContent();
        }
      }),

      /**
       * Updates the content. Sets the right section the table pane should show and
       * does the scrolling.
       */
      _updateContent: function _updateContent() {
        var paneSize = this._paneClipper.getInnerSize();

        if (!paneSize) {
          return;
        }

        var paneHeight = paneSize.height;

        var scrollX = this.__horScrollBar__P_521_5.getPosition();

        var scrollY = this.__verScrollBar__P_521_6.getPosition();

        var rowHeight = this.getTable().getRowHeight();
        var firstRow = Math.floor(scrollY / rowHeight);

        var oldFirstRow = this.__tablePane__P_521_2.getFirstVisibleRow();

        this.__tablePane__P_521_2.setFirstVisibleRow(firstRow);

        var visibleRowCount = Math.ceil(paneHeight / rowHeight);
        var paneOffset = 0;
        var firstVisibleRowComplete = this.getTable().getKeepFirstVisibleRowComplete();

        if (!firstVisibleRowComplete) {
          // NOTE: We don't consider paneOffset, because this may cause alternating
          //       adding and deleting of one row when scrolling. Instead we add one row
          //       in every case.
          visibleRowCount++;
          paneOffset = scrollY % rowHeight;
        }

        this.__tablePane__P_521_2.setVisibleRowCount(visibleRowCount);

        if (firstRow != oldFirstRow) {
          this._updateFocusIndicator();
        }

        this._paneClipper.scrollToX(scrollX); // Avoid expensive calls to setScrollTop if
        // scrolling is not needed


        if (!firstVisibleRowComplete) {
          this._paneClipper.scrollToY(paneOffset);
        }
      },

      /**
       * Updates the location and the visibility of the focus indicator.
       *
       */
      _updateFocusIndicator: function _updateFocusIndicator() {
        var table = this.getTable();

        if (!table.getEnabled()) {
          return;
        }

        this.__focusIndicator__P_521_7.moveToCell(this.__focusedCol__P_521_23, this.__focusedRow__P_521_24);
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._stopInterval(); // this object was created by the table on init so we have to clean it up.


      var tablePaneModel = this.getTablePaneModel();

      if (tablePaneModel) {
        tablePaneModel.dispose();
      }

      this.__lastPointerDownCell__P_521_18 = this.__topRightWidget__P_521_26 = this.__table__P_521_0 = null;

      this._disposeObjects("__horScrollBar__P_521_5", "__verScrollBar__P_521_6", "_headerClipper", "_paneClipper", "__focusIndicator__P_521_7", "__header__P_521_1", "__tablePane__P_521_2", "__top__P_521_3", "__timer__P_521_8", "__clipperContainer__P_521_4");
    }
  });
  qx.ui.table.pane.Scroller.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * The model of a table pane. This model works as proxy to a
   * {@link qx.ui.table.columnmodel.Basic} and manages the visual order of the columns shown in
   * a {@link Pane}.
   */
  qx.Class.define("qx.ui.table.pane.Model", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     *
     * @param tableColumnModel {qx.ui.table.columnmodel.Basic} The TableColumnModel of which this
     *    model is the proxy.
     */
    construct: function construct(tableColumnModel) {
      qx.core.Object.constructor.call(this);
      this.setTableColumnModel(tableColumnModel);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fired when the model changed. */
      "modelChanged": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {string} The type of the event fired when the model changed. */
      EVENT_TYPE_MODEL_CHANGED: "modelChanged"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The visible x position of the first column this model should contain. */
      firstColumnX: {
        check: "Integer",
        init: 0,
        apply: "_applyFirstColumnX"
      },

      /**
       * The maximum number of columns this model should contain. If -1 this model will
       * contain all remaining columns.
       */
      maxColumnCount: {
        check: "Number",
        init: -1,
        apply: "_applyMaxColumnCount"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __columnCount__P_519_0: null,
      __tableColumnModel__P_519_1: null,
      // property modifier
      _applyFirstColumnX: function _applyFirstColumnX(value, old) {
        this.__columnCount__P_519_0 = null;
        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },
      // property modifier
      _applyMaxColumnCount: function _applyMaxColumnCount(value, old) {
        this.__columnCount__P_519_0 = null;
        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },

      /**
       * Connects the table model to the column model
       *
       * @param tableColumnModel {qx.ui.table.columnmodel.Basic} the column model
       */
      setTableColumnModel: function setTableColumnModel(tableColumnModel) {
        if (this.__tableColumnModel__P_519_1) {
          this.__tableColumnModel__P_519_1.removeListener("visibilityChangedPre", this._onColVisibilityChanged, this);

          this.__tableColumnModel__P_519_1.removeListener("headerCellRendererChanged", this._onHeaderCellRendererChanged, this);
        }

        this.__tableColumnModel__P_519_1 = tableColumnModel;

        this.__tableColumnModel__P_519_1.addListener("visibilityChangedPre", this._onColVisibilityChanged, this);

        this.__tableColumnModel__P_519_1.addListener("headerCellRendererChanged", this._onHeaderCellRendererChanged, this);

        this.__columnCount__P_519_0 = null;
      },

      /**
       * Event handler. Called when the visibility of a column has changed.
       *
       * @param evt {Map} the event.
       */
      _onColVisibilityChanged: function _onColVisibilityChanged(evt) {
        this.__columnCount__P_519_0 = null;
        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },

      /**
       * Event handler. Called when the cell renderer of a column has changed.
       *
       * @param evt {Map} the event.
       */
      _onHeaderCellRendererChanged: function _onHeaderCellRendererChanged(evt) {
        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },

      /**
       * Returns the number of columns in this model.
       *
       * @return {Integer} the number of columns in this model.
       */
      getColumnCount: function getColumnCount() {
        if (this.__columnCount__P_519_0 == null) {
          var firstX = this.getFirstColumnX();
          var maxColCount = this.getMaxColumnCount();

          var totalColCount = this.__tableColumnModel__P_519_1.getVisibleColumnCount();

          if (maxColCount == -1 || firstX + maxColCount > totalColCount) {
            this.__columnCount__P_519_0 = totalColCount - firstX;
          } else {
            this.__columnCount__P_519_0 = maxColCount;
          }
        }

        return this.__columnCount__P_519_0;
      },

      /**
       * Returns the model index of the column at the position <code>xPos</code>.
       *
       * @param xPos {Integer} the x position in the table pane of the column.
       * @return {Integer} the model index of the column.
       */
      getColumnAtX: function getColumnAtX(xPos) {
        var firstX = this.getFirstColumnX();
        return this.__tableColumnModel__P_519_1.getVisibleColumnAtX(firstX + xPos);
      },

      /**
       * Returns the x position of the column <code>col</code>.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the x position in the table pane of the column.
       */
      getX: function getX(col) {
        var firstX = this.getFirstColumnX();
        var maxColCount = this.getMaxColumnCount();
        var x = this.__tableColumnModel__P_519_1.getVisibleX(col) - firstX;

        if (x >= 0 && (maxColCount == -1 || x < maxColCount)) {
          return x;
        } else {
          return -1;
        }
      },

      /**
       * Gets the position of the left side of a column (in pixels, relative to the
       * left side of the table pane).
       *
       * This value corresponds to the sum of the widths of all columns left of the
       * column.
       *
       * @param col {Integer} the model index of the column.
       * @return {var} the position of the left side of the column.
       */
      getColumnLeft: function getColumnLeft(col) {
        var left = 0;
        var colCount = this.getColumnCount();

        for (var x = 0; x < colCount; x++) {
          var currCol = this.getColumnAtX(x);

          if (currCol == col) {
            return left;
          }

          left += this.__tableColumnModel__P_519_1.getColumnWidth(currCol);
        }

        return -1;
      },

      /**
       * Returns the total width of all columns in the model.
       *
       * @return {Integer} the total width of all columns in the model.
       */
      getTotalWidth: function getTotalWidth() {
        var totalWidth = 0;
        var colCount = this.getColumnCount();

        for (var x = 0; x < colCount; x++) {
          var col = this.getColumnAtX(x);
          totalWidth += this.__tableColumnModel__P_519_1.getColumnWidth(col);
        }

        return totalWidth;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      if (this.__tableColumnModel__P_519_1) {
        this.__tableColumnModel__P_519_1.removeListener("visibilityChangedPre", this._onColVisibilityChanged, this);

        this.__tableColumnModel__P_519_1.removeListener("headerCellRendererChanged", this._onHeaderCellRendererChanged, this);
      }

      this.__tableColumnModel__P_519_1 = null;
    }
  });
  qx.ui.table.pane.Model.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.ITableModel": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * An abstract table model that performs the column handling, so subclasses only
   * need to care for row handling.
   */
  qx.Class.define("qx.ui.table.model.Abstract", {
    type: "abstract",
    extend: qx.core.Object,
    implement: qx.ui.table.ITableModel,
    events: {
      /**
       * Fired when the table data changed (the stuff shown in the table body).
       * The data property of the event will be a map having the following
       * attributes:
       * <ul>
       *   <li>firstRow: The index of the first row that has changed.</li>
       *   <li>lastRow: The index of the last row that has changed.</li>
       *   <li>firstColumn: The model index of the first column that has changed.</li>
       *   <li>lastColumn: The model index of the last column that has changed.</li>
       * </ul>
       *
       * Additionally, if the data changed as a result of rows being removed
       * from the data model, then these additional attributes will be in the
       * data:
       * <ul>
       *   <li>removeStart: The model index of the first row that was removed.</li>
       *   <li>removeCount: The number of rows that were removed.</li>
       * </ul>
       */
      "dataChanged": "qx.event.type.Data",

      /**
       * Fired when the meta data changed (the stuff shown in the table header).
       */
      "metaDataChanged": "qx.event.type.Event",

      /**
       * Fired after the table is sorted (but before the metaDataChanged event)
       */
      "sorted": "qx.event.type.Data"
    },
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      this.__columnIdArr__P_514_0 = [];
      this.__columnNameArr__P_514_1 = [];
      this.__columnIndexMap__P_514_2 = {};
    },
    members: {
      __columnIdArr__P_514_0: null,
      __columnNameArr__P_514_1: null,
      __columnIndexMap__P_514_2: null,
      __internalChange__P_514_3: null,

      /**
       * Initialize the table model <--> table interaction. The table model is
       * passed to the table constructor, but the table model doesn't otherwise
       * know anything about the table nor can it operate on table
       * properties. This function provides the capability for the table model
       * to specify characteristics of the table. It is called when the table
       * model is applied to the table.
       *
       * @param table {qx.ui.table.Table}
       *   The table to which this model is attached
       */
      init: function init(table) {// default implementation has nothing to do
      },

      /**
       * Abstract method
       * @throws {Error} An error if this method is called.
       */
      getRowCount: function getRowCount() {
        throw new Error("getRowCount is abstract");
      },
      getRowData: function getRowData(rowIndex) {
        return null;
      },
      isColumnEditable: function isColumnEditable(columnIndex) {
        return false;
      },
      isColumnSortable: function isColumnSortable(columnIndex) {
        return false;
      },
      sortByColumn: function sortByColumn(columnIndex, ascending) {},
      getSortColumnIndex: function getSortColumnIndex() {
        return -1;
      },
      isSortAscending: function isSortAscending() {
        return true;
      },
      prefetchRows: function prefetchRows(firstRowIndex, lastRowIndex) {},

      /**
       * Abstract method
       *
       * @param columnIndex {Integer} the index of the column
       * @param rowIndex {Integer} the index of the row
       *
       * @throws {Error} An error if this method is called.
       */
      getValue: function getValue(columnIndex, rowIndex) {
        throw new Error("getValue is abstract");
      },
      getValueById: function getValueById(columnId, rowIndex) {
        return this.getValue(this.getColumnIndexById(columnId), rowIndex);
      },

      /**
       * Abstract method
       *
       * @param columnIndex {Integer} index of the column
       * @param rowIndex {Integer} index of the row
       * @param value {var} Value to be set
       *
       * @throws {Error} An error if this method is called.
       */
      setValue: function setValue(columnIndex, rowIndex, value) {
        throw new Error("setValue is abstract");
      },
      setValueById: function setValueById(columnId, rowIndex, value) {
        this.setValue(this.getColumnIndexById(columnId), rowIndex, value);
      },
      // overridden
      getColumnCount: function getColumnCount() {
        return this.__columnIdArr__P_514_0.length;
      },
      // overridden
      getColumnIndexById: function getColumnIndexById(columnId) {
        return this.__columnIndexMap__P_514_2[columnId];
      },
      // overridden
      getColumnId: function getColumnId(columnIndex) {
        return this.__columnIdArr__P_514_0[columnIndex];
      },
      // overridden
      getColumnName: function getColumnName(columnIndex) {
        return this.__columnNameArr__P_514_1[columnIndex];
      },

      /**
       * Sets the column IDs. These IDs may be used internally to identify a
       * column.
       *
       * Note: This will clear previously set column names.
       *
       *
       * @param columnIdArr {String[]} the IDs of the columns.
       * @see #setColumns
       */
      setColumnIds: function setColumnIds(columnIdArr) {
        this.__columnIdArr__P_514_0 = columnIdArr; // Create the reverse map

        this.__columnIndexMap__P_514_2 = {};

        for (var i = 0; i < columnIdArr.length; i++) {
          this.__columnIndexMap__P_514_2[columnIdArr[i]] = i;
        }

        this.__columnNameArr__P_514_1 = new Array(columnIdArr.length); // Inform the listeners

        if (!this.__internalChange__P_514_3) {
          this.fireEvent("metaDataChanged");
        }
      },

      /**
       * Sets the column names. These names will be shown to the user.
       *
       * Note: The column IDs have to be defined before.
       *
       *
       * @param columnNameArr {String[]} the names of the columns.
       * @throws {Error} If the amount of given columns is different from the table.
       * @see #setColumnIds
       */
      setColumnNamesByIndex: function setColumnNamesByIndex(columnNameArr) {
        if (this.__columnIdArr__P_514_0.length != columnNameArr.length) {
          throw new Error("this.__columnIdArr and columnNameArr have different length: " + this.__columnIdArr__P_514_0.length + " != " + columnNameArr.length);
        }

        this.__columnNameArr__P_514_1 = columnNameArr; // Inform the listeners

        this.fireEvent("metaDataChanged");
      },

      /**
       * Sets the column names. These names will be shown to the user.
       *
       * Note: The column IDs have to be defined before.
       *
       *
       * @param columnNameMap {Map} a map containing the column IDs as keys and the
       *          column name as values.
       * @see #setColumnIds
       */
      setColumnNamesById: function setColumnNamesById(columnNameMap) {
        this.__columnNameArr__P_514_1 = new Array(this.__columnIdArr__P_514_0.length);

        for (var i = 0; i < this.__columnIdArr__P_514_0.length; ++i) {
          this.__columnNameArr__P_514_1[i] = columnNameMap[this.__columnIdArr__P_514_0[i]];
        }
      },

      /**
       * Sets the column names (and optionally IDs)
       *
       * Note: You can not change the _number_ of columns this way.  The number
       *       of columns is highly intertwined in the entire table operation,
       *       and dynamically changing it would require as much work as just
       *       recreating your table.  If you must change the number of columns
       *       in a table then you should remove the table and add a new one.
       *
       * @param columnNameArr {String[]}
       *   The column names. These names will be shown to the user.
       *
       * @param columnIdArr {String[] ? null}
       *   The column IDs. These IDs may be used internally to identify a
       *   column. If null, the column names are used as IDs unless ID values
       *   have already been set. If ID values have already been set, they will
       *   continue to be used if no ID values are explicitly provided here.
       *
       * @throws {Error} If the amount of given columns is different from the table.
       *
       */
      setColumns: function setColumns(columnNameArr, columnIdArr) {
        var bSetIds = this.__columnIdArr__P_514_0.length == 0 || columnIdArr;

        if (columnIdArr == null) {
          if (this.__columnIdArr__P_514_0.length == 0) {
            columnIdArr = columnNameArr;
          } else {
            columnIdArr = this.__columnIdArr__P_514_0;
          }
        }

        if (columnIdArr.length != columnNameArr.length) {
          throw new Error("columnIdArr and columnNameArr have different length: " + columnIdArr.length + " != " + columnNameArr.length);
        }

        if (bSetIds) {
          this.__internalChange__P_514_3 = true;
          this.setColumnIds(columnIdArr);
          this.__internalChange__P_514_3 = false;
        }

        this.setColumnNamesByIndex(columnNameArr);
      }
    },
    destruct: function destruct() {
      this.__columnIdArr__P_514_0 = this.__columnNameArr__P_514_1 = this.__columnIndexMap__P_514_2 = null;
    }
  });
  qx.ui.table.model.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.model.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A simple table model that provides an API for changing the model data.
   */
  qx.Class.define("qx.ui.table.model.Simple", {
    extend: qx.ui.table.model.Abstract,
    construct: function construct() {
      qx.ui.table.model.Abstract.constructor.call(this);
      this._rowArr = [];
      this.__sortColumnIndex__P_516_0 = -1; // Array of objects, each with property "ascending" and "descending"

      this.__sortMethods__P_516_1 = [];
      this.__editableColArr__P_516_2 = null;
    },
    properties: {
      /**
       * Whether sorting should be case sensitive
       */
      caseSensitiveSorting: {
        check: "Boolean",
        init: true
      }
    },
    statics: {
      /**
       * Default ascending sort method to use if no custom method has been
       * provided.
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @param columnIndex {Integer} the column to be sorted
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorAscending: function _defaultSortComparatorAscending(row1, row2, columnIndex) {
        var obj1 = row1[columnIndex];
        var obj2 = row2[columnIndex];

        if (qx.lang.Type.isNumber(obj1) && qx.lang.Type.isNumber(obj2)) {
          var result = isNaN(obj1) ? isNaN(obj2) ? 0 : 1 : isNaN(obj2) ? -1 : null;

          if (result != null) {
            return result;
          }
        }

        return obj1 > obj2 ? 1 : obj1 == obj2 ? 0 : -1;
      },

      /**
       * Same as the Default ascending sort method but using case insensitivity
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @param columnIndex {Integer} the column to be sorted
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorInsensitiveAscending: function _defaultSortComparatorInsensitiveAscending(row1, row2, columnIndex) {
        var obj1 = row1[columnIndex].toLowerCase ? row1[columnIndex].toLowerCase() : row1[columnIndex];
        var obj2 = row2[columnIndex].toLowerCase ? row2[columnIndex].toLowerCase() : row2[columnIndex];

        if (qx.lang.Type.isNumber(obj1) && qx.lang.Type.isNumber(obj2)) {
          var result = isNaN(obj1) ? isNaN(obj2) ? 0 : 1 : isNaN(obj2) ? -1 : null;

          if (result != null) {
            return result;
          }
        }

        return obj1 > obj2 ? 1 : obj1 == obj2 ? 0 : -1;
      },

      /**
       * Default descending sort method to use if no custom method has been
       * provided.
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @param columnIndex {Integer} the column to be sorted
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorDescending: function _defaultSortComparatorDescending(row1, row2, columnIndex) {
        var obj1 = row1[columnIndex];
        var obj2 = row2[columnIndex];

        if (qx.lang.Type.isNumber(obj1) && qx.lang.Type.isNumber(obj2)) {
          var result = isNaN(obj1) ? isNaN(obj2) ? 0 : 1 : isNaN(obj2) ? -1 : null;

          if (result != null) {
            return result;
          }
        }

        return obj1 < obj2 ? 1 : obj1 == obj2 ? 0 : -1;
      },

      /**
       * Same as the Default descending sort method but using case insensitivity
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @param columnIndex {Integer} the column to be sorted
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorInsensitiveDescending: function _defaultSortComparatorInsensitiveDescending(row1, row2, columnIndex) {
        var obj1 = row1[columnIndex].toLowerCase ? row1[columnIndex].toLowerCase() : row1[columnIndex];
        var obj2 = row2[columnIndex].toLowerCase ? row2[columnIndex].toLowerCase() : row2[columnIndex];

        if (qx.lang.Type.isNumber(obj1) && qx.lang.Type.isNumber(obj2)) {
          var result = isNaN(obj1) ? isNaN(obj2) ? 0 : 1 : isNaN(obj2) ? -1 : null;

          if (result != null) {
            return result;
          }
        }

        return obj1 < obj2 ? 1 : obj1 == obj2 ? 0 : -1;
      }
    },
    members: {
      _rowArr: null,
      __editableColArr__P_516_2: null,
      __sortableColArr__P_516_3: null,
      __sortMethods__P_516_1: null,
      __sortColumnIndex__P_516_0: null,
      __sortAscending__P_516_4: null,
      // overridden
      getRowData: function getRowData(rowIndex) {
        var rowData = this._rowArr[rowIndex];

        if (rowData == null || rowData.originalData == null) {
          return rowData;
        } else {
          return rowData.originalData;
        }
      },

      /**
       * Returns the data of one row as map containing the column IDs as key and
       * the cell values as value. Also the meta data is included.
       *
       * @param rowIndex {Integer} the model index of the row.
       * @return {Map} a Map containing the column values.
       */
      getRowDataAsMap: function getRowDataAsMap(rowIndex) {
        var rowData = this._rowArr[rowIndex];

        if (rowData != null) {
          var map = {}; // get the current set data

          for (var col = 0; col < this.getColumnCount(); col++) {
            map[this.getColumnId(col)] = rowData[col];
          }

          if (rowData.originalData != null) {
            // merge in the meta data
            for (var key in rowData.originalData) {
              if (map[key] == undefined) {
                map[key] = rowData.originalData[key];
              }
            }
          }

          return map;
        } // may be null, which is ok


        return rowData && rowData.originalData ? rowData.originalData : null;
      },

      /**
       * Gets the whole data as an array of maps.
       *
       * Note: Individual items are retrieved by {@link #getRowDataAsMap}.
       * @return {Map[]} Array of row data maps
       */
      getDataAsMapArray: function getDataAsMapArray() {
        var len = this.getRowCount();
        var data = [];

        for (var i = 0; i < len; i++) {
          data.push(this.getRowDataAsMap(i));
        }

        return data;
      },

      /**
       * Sets all columns editable or not editable.
       *
       * @param editable {Boolean} whether all columns are editable.
       */
      setEditable: function setEditable(editable) {
        this.__editableColArr__P_516_2 = [];

        for (var col = 0; col < this.getColumnCount(); col++) {
          this.__editableColArr__P_516_2[col] = editable;
        }

        this.fireEvent("metaDataChanged");
      },

      /**
       * Sets whether a column is editable.
       *
       * @param columnIndex {Integer} the column of which to set the editable state.
       * @param editable {Boolean} whether the column should be editable.
       */
      setColumnEditable: function setColumnEditable(columnIndex, editable) {
        if (editable != this.isColumnEditable(columnIndex)) {
          if (this.__editableColArr__P_516_2 == null) {
            this.__editableColArr__P_516_2 = [];
          }

          this.__editableColArr__P_516_2[columnIndex] = editable;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      isColumnEditable: function isColumnEditable(columnIndex) {
        return this.__editableColArr__P_516_2 ? this.__editableColArr__P_516_2[columnIndex] == true : false;
      },

      /**
       * Sets whether a column is sortable.
       *
       * @param columnIndex {Integer} the column of which to set the sortable state.
       * @param sortable {Boolean} whether the column should be sortable.
       */
      setColumnSortable: function setColumnSortable(columnIndex, sortable) {
        if (sortable != this.isColumnSortable(columnIndex)) {
          if (this.__sortableColArr__P_516_3 == null) {
            this.__sortableColArr__P_516_3 = [];
          }

          this.__sortableColArr__P_516_3[columnIndex] = sortable;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      isColumnSortable: function isColumnSortable(columnIndex) {
        return this.__sortableColArr__P_516_3 ? this.__sortableColArr__P_516_3[columnIndex] !== false : true;
      },
      // overridden
      sortByColumn: function sortByColumn(columnIndex, ascending) {
        // NOTE: We use different comparators for ascending and descending,
        //     because comparators should be really fast.
        var comparator;
        var sortMethods = this.__sortMethods__P_516_1[columnIndex];

        if (sortMethods) {
          comparator = ascending ? sortMethods.ascending : sortMethods.descending;
        } else {
          if (this.getCaseSensitiveSorting()) {
            comparator = ascending ? qx.ui.table.model.Simple._defaultSortComparatorAscending : qx.ui.table.model.Simple._defaultSortComparatorDescending;
          } else {
            comparator = ascending ? qx.ui.table.model.Simple._defaultSortComparatorInsensitiveAscending : qx.ui.table.model.Simple._defaultSortComparatorInsensitiveDescending;
          }
        }

        comparator.columnIndex = columnIndex;

        this._rowArr.sort(function (row1, row2) {
          return comparator(row1, row2, columnIndex);
        });

        this.__sortColumnIndex__P_516_0 = columnIndex;
        this.__sortAscending__P_516_4 = ascending;
        var data = {
          columnIndex: columnIndex,
          ascending: ascending
        };
        this.fireDataEvent("sorted", data);
        this.fireEvent("metaDataChanged");
      },

      /**
       * Specify the methods to use for ascending and descending sorts of a
       * particular column.
       *
       * @param columnIndex {Integer}
       *   The index of the column for which the sort methods are being
       *   provided.
       *
       * @param compare {Function|Map}
       *   If provided as a Function, this is the comparator function to sort in
       *   ascending order. It takes three parameters: the two arrays of row data,
       *   row1 and row2, being compared and the column index sorting was requested 
       *   for. 
       *
       *   For backwards compatability, user-supplied compare functions may still 
       *   take only two parameters, the two arrays of row data, row1 and row2, 
       *   being compared and obtain the column index as arguments.callee.columnIndex. 
       *   This is deprecated, however, as arguments.callee is disallowed in ES5 strict
       *   mode and ES6.
       *
       *   The comparator function must return 1, 0 or -1, when the column in row1
       *   is greater than, equal to, or less than, respectively, the column in
       *   row2.
       *
       *   If this parameter is a Map, it shall have two properties: "ascending"
       *   and "descending". The property value of each is a comparator
       *   function, as described above.
       *
       *   If only the "ascending" function is provided (i.e. this parameter is
       *   a Function, not a Map), then the "descending" function is built
       *   dynamically by passing the two parameters to the "ascending" function
       *   in reversed order. <i>Use of a dynamically-built "descending" function
       *   generates at least one extra function call for each row in the table,
       *   and possibly many more. If the table is expected to have more than
       *   about 1000 rows, you will likely want to provide a map with a custom
       *   "descending" sort function as well as the "ascending" one.</i>
       *
       */
      setSortMethods: function setSortMethods(columnIndex, compare) {
        var methods;

        if (qx.lang.Type.isFunction(compare)) {
          methods = {
            ascending: compare,
            descending: function descending(row1, row2, columnIndex) {
              /* assure backwards compatibility for sort functions using
               * arguments.callee.columnIndex and fix a bug where retreiveing
               * column index via this way did not work for the case where a 
               * single comparator function was used. 
               * Note that arguments.callee is not available in ES5 strict mode and ES6. 
               * See discussion in 
               * https://github.com/qooxdoo/qooxdoo/pull/9499#pullrequestreview-99655182
               */
              compare.columnIndex = columnIndex;
              return compare(row2, row1, columnIndex);
            }
          };
        } else {
          methods = compare;
        }

        this.__sortMethods__P_516_1[columnIndex] = methods;
      },

      /**
       * Returns the sortMethod(s) for a table column.
       *
       * @param columnIndex {Integer} The index of the column for which the sort
       *   methods are being  provided.
       *
       * @return {Map} a map with the two properties "ascending"
       *   and "descending" for the specified column.
       *   The property value of each is a comparator function, as described
       *   in {@link #setSortMethods}.
       */
      getSortMethods: function getSortMethods(columnIndex) {
        return this.__sortMethods__P_516_1[columnIndex];
      },

      /**
       * Clears the sorting.
       */
      clearSorting: function clearSorting() {
        if (this.__sortColumnIndex__P_516_0 != -1) {
          this.__sortColumnIndex__P_516_0 = -1;
          this.__sortAscending__P_516_4 = true;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      getSortColumnIndex: function getSortColumnIndex() {
        return this.__sortColumnIndex__P_516_0;
      },

      /**
       * Set the sort column index
       *
       * WARNING: This should be called only by subclasses with intimate
       *          knowledge of what they are doing!
       *
       * @param columnIndex {Integer} index of the column
       */
      _setSortColumnIndex: function _setSortColumnIndex(columnIndex) {
        this.__sortColumnIndex__P_516_0 = columnIndex;
      },
      // overridden
      isSortAscending: function isSortAscending() {
        return this.__sortAscending__P_516_4;
      },

      /**
       * Set whether to sort in ascending order or not.
       *
       * WARNING: This should be called only by subclasses with intimate
       *          knowledge of what they are doing!
       *
       * @param ascending {Boolean}
       *   <i>true</i> for an ascending sort;
       *   <i> false</i> for a descending sort.
       */
      _setSortAscending: function _setSortAscending(ascending) {
        this.__sortAscending__P_516_4 = ascending;
      },
      // overridden
      getRowCount: function getRowCount() {
        return this._rowArr.length;
      },
      // overridden
      getValue: function getValue(columnIndex, rowIndex) {
        if (rowIndex < 0 || rowIndex >= this._rowArr.length) {
          throw new Error("this._rowArr out of bounds: " + rowIndex + " (0.." + this._rowArr.length + ")");
        }

        return this._rowArr[rowIndex][columnIndex];
      },
      // overridden
      setValue: function setValue(columnIndex, rowIndex, value) {
        if (this._rowArr[rowIndex][columnIndex] != value) {
          this._rowArr[rowIndex][columnIndex] = value; // Inform the listeners

          if (this.hasListener("dataChanged")) {
            var data = {
              firstRow: rowIndex,
              lastRow: rowIndex,
              firstColumn: columnIndex,
              lastColumn: columnIndex
            };
            this.fireDataEvent("dataChanged", data);
          }

          if (columnIndex == this.__sortColumnIndex__P_516_0) {
            this.clearSorting();
          }
        }
      },

      /**
       * Sets the whole data in a bulk.
       *
       * @param rowArr {var[][]} An array containing an array for each row. Each
       *          row-array contains the values in that row in the order of the columns
       *          in this model.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      setData: function setData(rowArr, clearSorting) {
        this._rowArr = rowArr; // Inform the listeners

        if (this.hasListener("dataChanged")) {
          var data = {
            firstRow: 0,
            lastRow: rowArr.length - 1,
            firstColumn: 0,
            lastColumn: this.getColumnCount() - 1
          };
          this.fireDataEvent("dataChanged", data);
        }

        if (clearSorting !== false) {
          this.clearSorting();
        }
      },

      /**
       * Returns the data of this model.
       *
       * Warning: Do not alter this array! If you want to change the data use
       * {@link #setData}, {@link #setDataAsMapArray} or {@link #setValue} instead.
       *
       * @return {var[][]} An array containing an array for each row. Each
       *           row-array contains the values in that row in the order of the columns
       *           in this model.
       */
      getData: function getData() {
        return this._rowArr;
      },

      /**
       * Sets the whole data in a bulk.
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *        row-map contains the column IDs as key and the cell values as value.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      setDataAsMapArray: function setDataAsMapArray(mapArr, rememberMaps, clearSorting) {
        this.setData(this._mapArray2RowArr(mapArr, rememberMaps), clearSorting);
      },

      /**
       * Adds some rows to the model.
       *
       * Warning: The given array will be altered!
       *
       * @param rowArr {var[][]} An array containing an array for each row. Each
       *          row-array contains the values in that row in the order of the columns
       *          in this model.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *          the rows are appended to the end.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      addRows: function addRows(rowArr, startIndex, clearSorting) {
        if (startIndex == null) {
          startIndex = this._rowArr.length;
        } // Prepare the rowArr so it can be used for apply


        rowArr.splice(0, 0, startIndex, 0); // Insert the new rows

        Array.prototype.splice.apply(this._rowArr, rowArr); // Inform the listeners

        var data = {
          firstRow: startIndex,
          lastRow: this._rowArr.length - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1
        };
        this.fireDataEvent("dataChanged", data);

        if (clearSorting !== false) {
          this.clearSorting();
        }
      },

      /**
       * Adds some rows to the model.
       *
       * Warning: The given array (mapArr) will be altered!
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *        row-map contains the column IDs as key and the cell values as value.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *        the rows are appended to the end.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      addRowsAsMapArray: function addRowsAsMapArray(mapArr, startIndex, rememberMaps, clearSorting) {
        this.addRows(this._mapArray2RowArr(mapArr, rememberMaps), startIndex, clearSorting);
      },

      /**
       * Sets rows in the model. The rows overwrite the old rows starting at
       * <code>startIndex</code> to <code>startIndex+rowArr.length</code>.
       *
       * Warning: The given array will be altered!
       *
       * @param rowArr {var[][]} An array containing an array for each row. Each
       *          row-array contains the values in that row in the order of the columns
       *          in this model.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *          the rows are set from the beginning (0).
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      setRows: function setRows(rowArr, startIndex, clearSorting) {
        if (startIndex == null) {
          startIndex = 0;
        } // Prepare the rowArr so it can be used for apply


        rowArr.splice(0, 0, startIndex, rowArr.length); // Replace rows

        Array.prototype.splice.apply(this._rowArr, rowArr); // Inform the listeners

        var data = {
          firstRow: startIndex,
          lastRow: this._rowArr.length - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1
        };
        this.fireDataEvent("dataChanged", data);

        if (clearSorting !== false) {
          this.clearSorting();
        }
      },

      /**
       * Set rows in the model. The rows overwrite the old rows starting at
       * <code>startIndex</code> to <code>startIndex+rowArr.length</code>.
       *
       * Warning: The given array (mapArr) will be altered!
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *        row-map contains the column IDs as key and the cell values as value.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *        the rows are appended to the end.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      setRowsAsMapArray: function setRowsAsMapArray(mapArr, startIndex, rememberMaps, clearSorting) {
        this.setRows(this._mapArray2RowArr(mapArr, rememberMaps), startIndex, clearSorting);
      },

      /**
       * Removes some rows from the model.
       *
       * @param startIndex {Integer} the index of the first row to remove.
       * @param howMany {Integer} the number of rows to remove.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      removeRows: function removeRows(startIndex, howMany, clearSorting) {
        this._rowArr.splice(startIndex, howMany); // Inform the listeners


        var data = {
          firstRow: startIndex,
          lastRow: this._rowArr.length - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1,
          removeStart: startIndex,
          removeCount: howMany
        };
        this.fireDataEvent("dataChanged", data);

        if (clearSorting !== false) {
          this.clearSorting();
        }
      },

      /**
       * Creates an array of maps to an array of arrays.
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *          row-map contains the column IDs as key and the cell values as value.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @return {var[][]} An array containing an array for each row. Each
       *           row-array contains the values in that row in the order of the columns
       *           in this model.
       */
      _mapArray2RowArr: function _mapArray2RowArr(mapArr, rememberMaps) {
        var rowCount = mapArr.length;
        var columnCount = this.getColumnCount();
        var dataArr = new Array(rowCount);
        var columnArr;

        for (var i = 0; i < rowCount; ++i) {
          columnArr = [];

          if (rememberMaps) {
            columnArr.originalData = mapArr[i];
          }

          for (var j = 0; j < columnCount; ++j) {
            columnArr[j] = mapArr[i][this.getColumnId(j)];
          }

          dataArr[i] = columnArr;
        }

        return dataArr;
      }
    },
    destruct: function destruct() {
      this._rowArr = this.__editableColArr__P_516_2 = this.__sortMethods__P_516_1 = this.__sortableColArr__P_516_3 = null;
    }
  });
  qx.ui.table.model.Simple.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Grow": {
        "construct": true
      },
      "qx.theme.manager.Decoration": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The focus indicator widget
   */
  qx.Class.define("qx.ui.table.pane.FocusIndicator", {
    extend: qx.ui.container.Composite,

    /**
     * @param scroller {qx.ui.table.pane.Scroller} The scroller, which contains this focus indicator
     */
    construct: function construct(scroller) {
      // use the grow layout to make sure that the editing control
      // always fills the focus indicator box.
      qx.ui.container.Composite.constructor.call(this, new qx.ui.layout.Grow());
      this.__scroller__P_517_0 = scroller;
      this.setKeepActive(true);
      this.addListener("keypress", this._onKeyPress, this);
    },
    properties: {
      // overridden
      visibility: {
        refine: true,
        init: "excluded"
      },

      /** Table row, where the indicator is placed. */
      row: {
        check: "Integer",
        nullable: true
      },

      /** Table column, where the indicator is placed. */
      column: {
        check: "Integer",
        nullable: true
      }
    },
    members: {
      __scroller__P_517_0: null,

      /**
       * Keypress handler. Suppress all key events but "Enter" and "Escape"
       *
       * @param e {qx.event.type.KeySequence} key event
       */
      _onKeyPress: function _onKeyPress(e) {
        var iden = e.getKeyIdentifier();

        if (iden !== "Escape" && iden !== "Enter") {
          e.stopPropagation();
        }
      },

      /**
       * Move the focus indicator to the given table cell.
       *
       * @param col {Integer?null} The table column
       * @param row {Integer?null} The table row
       */
      moveToCell: function moveToCell(col, row) {
        // check if the focus indicator is shown and if the new column is
        // editable. if not, just exclude the indicator because the pointer events
        // should go to the cell itself linked with HTML links [BUG #4250]
        if (!this.__scroller__P_517_0.getShowCellFocusIndicator() && !this.__scroller__P_517_0.getTable().getTableModel().isColumnEditable(col)) {
          this.exclude();
          return;
        } else {
          this.show();
        }

        if (col == null) {
          this.hide();
          this.setRow(null);
          this.setColumn(null);
        } else {
          var xPos = this.__scroller__P_517_0.getTablePaneModel().getX(col);

          if (xPos == -1) {
            this.hide();
            this.setRow(null);
            this.setColumn(null);
          } else {
            var table = this.__scroller__P_517_0.getTable();

            var columnModel = table.getTableColumnModel();

            var paneModel = this.__scroller__P_517_0.getTablePaneModel();

            var firstRow = this.__scroller__P_517_0.getTablePane().getFirstVisibleRow();

            var rowHeight = table.getRowHeight();
            var wt = 0;
            var wr = 0;
            var wb = 0;
            var wl = 0;
            var decoKey = this.getDecorator();

            if (decoKey) {
              var deco = qx.theme.manager.Decoration.getInstance().resolve(decoKey);

              if (deco) {
                wt = deco.getWidthTop();
                wr = deco.getWidthRight();
                wb = deco.getWidthBottom();
                wl = deco.getWidthLeft();
              }
            }

            this.setUserBounds(paneModel.getColumnLeft(col) - (wt - 1), (row - firstRow) * rowHeight - (wr - 1), columnModel.getColumnWidth(col) + (wt + wb - 3), rowHeight + (wl + wr - 2));
            this.show();
            this.setRow(row);
            this.setColumn(col);
          }
        }
      }
    },
    destruct: function destruct() {
      this.__scroller__P_517_0 = null;
    }
  });
  qx.ui.table.pane.FocusIndicator.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menu.CheckBox": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.IColumnMenuItem": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A menu item.
   */
  qx.Class.define("qx.ui.table.columnmenu.MenuItem", {
    extend: qx.ui.menu.CheckBox,
    implement: qx.ui.table.IColumnMenuItem,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Create a new instance of an item for insertion into the table column
     * visibility menu.
     *
     * @param text {String}
     *   Text for the menu item, most typically the name of the column in the
     *   table.
     */
    construct: function construct(text) {
      qx.ui.menu.CheckBox.constructor.call(this, text); // Two way binding this.columnVisible <--> this.value

      this.bind("value", this, "columnVisible");
      this.bind("columnVisible", this, "value");
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      columnVisible: {
        check: "Boolean",
        init: true,
        event: "changeColumnVisible"
      }
    }
  });
  qx.ui.table.columnmenu.MenuItem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.basic.Label": {},
      "qx.ui.basic.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The default header cell widget
   *
   * @childControl label {qx.ui.basic.Label} label of the header cell
   * @childControl sort-icon {qx.ui.basic.Image} sort icon of the header cell
   * @childControl icon {qx.ui.basic.Image} icon of the header cell
   */
  qx.Class.define("qx.ui.table.headerrenderer.HeaderCell", {
    extend: qx.ui.container.Composite,
    construct: function construct() {
      qx.ui.container.Composite.constructor.call(this);
      var layout = new qx.ui.layout.Grid();
      layout.setRowFlex(0, 1);
      layout.setColumnFlex(1, 1);
      layout.setColumnFlex(2, 1);
      this.setLayout(layout);
    },
    properties: {
      appearance: {
        refine: true,
        init: "table-header-cell"
      },

      /** header cell label */
      label: {
        check: "String",
        init: null,
        nullable: true,
        apply: "_applyLabel"
      },

      /** The icon URL of the sorting indicator */
      sortIcon: {
        check: "String",
        init: null,
        nullable: true,
        apply: "_applySortIcon",
        themeable: true
      },

      /** Icon URL */
      icon: {
        check: "String",
        init: null,
        nullable: true,
        apply: "_applyIcon"
      }
    },
    members: {
      // property apply
      _applyLabel: function _applyLabel(value, old) {
        if (value) {
          this._showChildControl("label").setValue(value);
        } else {
          this._excludeChildControl("label");
        }
      },
      // property apply
      _applySortIcon: function _applySortIcon(value, old) {
        if (value) {
          this._showChildControl("sort-icon").setSource(value);
        } else {
          this._excludeChildControl("sort-icon");
        }
      },
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        if (value) {
          this._showChildControl("icon").setSource(value);
        } else {
          this._excludeChildControl("icon");
        }
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "label":
            control = new qx.ui.basic.Label(this.getLabel()).set({
              anonymous: true,
              allowShrinkX: true
            });

            this._add(control, {
              row: 0,
              column: 1
            });

            break;

          case "sort-icon":
            control = new qx.ui.basic.Image(this.getSortIcon());
            control.setAnonymous(true);

            this._add(control, {
              row: 0,
              column: 2
            });

            break;

          case "icon":
            control = new qx.ui.basic.Image(this.getIcon()).set({
              anonymous: true,
              allowShrinkX: true
            });

            this._add(control, {
              row: 0,
              column: 0
            });

            break;
        }

        return control || qx.ui.table.headerrenderer.HeaderCell.prototype._createChildControlImpl.base.call(this, id);
      }
    }
  });
  qx.ui.table.headerrenderer.HeaderCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.Grow": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Clipping area for the table header and table pane.
   */
  qx.Class.define("qx.ui.table.pane.Clipper", {
    extend: qx.ui.container.Composite,
    construct: function construct() {
      qx.ui.container.Composite.constructor.call(this, new qx.ui.layout.Grow());
      this.setMinWidth(0);
    },
    members: {
      /**
       * Scrolls the element's content to the given left coordinate
       *
       * @param value {Integer} The vertical position to scroll to.
       */
      scrollToX: function scrollToX(value) {
        this.getContentElement().scrollToX(value, false);
      },

      /**
       * Scrolls the element's content to the given top coordinate
       *
       * @param value {Integer} The horizontal position to scroll to.
       */
      scrollToY: function scrollToY(value) {
        this.getContentElement().scrollToY(value, true);
      }
    }
  });
  qx.ui.table.pane.Clipper.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.type.Pointer": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * David Perez Carmona (david-perez)
  
  ************************************************************************ */

  /**
   * A cell event instance contains all data for pointer events related to cells in
   * a table.
   **/
  qx.Class.define("qx.ui.table.pane.CellEvent", {
    extend: qx.event.type.Pointer,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The table row of the event target */
      row: {
        check: "Integer",
        nullable: true
      },

      /** The table column of the event target */
      column: {
        check: "Integer",
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
       *****************************************************************************
          CONSTRUCTOR
       *****************************************************************************
       */

      /**
       * Initialize the event
       *
       * @param scroller {qx.ui.table.pane.Scroller} The tables pane scroller
       * @param me {qx.event.type.Pointer} The original pointer event
       * @param row {Integer?null} The cell's row index
       * @param column {Integer?null} The cell's column index
       */
      init: function init(scroller, me, row, column) {
        me.clone(this);
        this.setBubbles(false);

        if (row != null) {
          this.setRow(row);
        } else {
          this.setRow(scroller._getRowForPagePos(this.getDocumentLeft(), this.getDocumentTop()));
        }

        if (column != null) {
          this.setColumn(column);
        } else {
          this.setColumn(scroller._getColumnForPageX(this.getDocumentLeft()));
        }
      },
      // overridden
      clone: function clone(embryo) {
        var clone = qx.ui.table.pane.CellEvent.prototype.clone.base.call(this, embryo);
        clone.set({
          row: this.getRow(),
          column: this.getColumn()
        });
        return clone;
      }
    }
  });
  qx.ui.table.pane.CellEvent.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.table.ICellEditorFactory": {
        "require": true
      },
      "qx.ui.container.Composite": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.form.CheckBox": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 David Perez
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * David Perez (david-perez)
  
  ************************************************************************ */

  /**
   * For editing boolean data in a checkbox. It is advisable to use this in
   * conjunction with {@link qx.ui.table.cellrenderer.Boolean}.
   */
  qx.Class.define("qx.ui.table.celleditor.CheckBox", {
    extend: qx.core.Object,
    implement: qx.ui.table.ICellEditorFactory,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // interface implementation
      createCellEditor: function createCellEditor(cellInfo) {
        var editor = new qx.ui.container.Composite(new qx.ui.layout.HBox().set({
          alignX: "center",
          alignY: "middle"
        })).set({
          focusable: true
        });
        var checkbox = new qx.ui.form.CheckBox().set({
          value: cellInfo.value
        });
        editor.add(checkbox); // propagate focus

        editor.addListener("focus", function () {
          checkbox.focus();
        }); // propagate active state

        editor.addListener("activate", function () {
          checkbox.activate();
        });
        return editor;
      },
      // interface implementation
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        return cellEditor.getChildren()[0].getValue();
      }
    }
  });
  qx.ui.table.celleditor.CheckBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.table.ICellEditorFactory": {
        "require": true
      },
      "qx.ui.form.ComboBox": {},
      "qx.ui.form.ListItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */

  /**
   * A cell editor factory creating combo boxes.
   */
  qx.Class.define("qx.ui.table.celleditor.ComboBox", {
    extend: qx.core.Object,
    implement: qx.ui.table.ICellEditorFactory,
    properties: {
      /**
       * function that validates the result
       * the function will be called with the new value and the old value and is
       * supposed to return the value that is set as the table value.
       **/
      validationFunction: {
        check: "Function",
        nullable: true,
        init: null
      },

      /** array of data to construct ListItem widgets with */
      listData: {
        check: "Array",
        init: null,
        nullable: true
      }
    },
    members: {
      // interface implementation
      createCellEditor: function createCellEditor(cellInfo) {
        var cellEditor = new qx.ui.form.ComboBox().set({
          appearance: "table-editor-combobox"
        });
        var value = cellInfo.value;
        cellEditor.originalValue = value; // check if renderer does something with value

        var cellRenderer = cellInfo.table.getTableColumnModel().getDataCellRenderer(cellInfo.col);

        var label = cellRenderer._getContentHtml(cellInfo);

        if (value != label) {
          value = label;
        } // replace null values


        if (value === null || value === undefined) {
          value = "";
        }

        var list = this.getListData();

        if (list) {
          var item;

          for (var i = 0, l = list.length; i < l; i++) {
            var row = list[i];

            if (row instanceof Array) {
              item = new qx.ui.form.ListItem(row[0], row[1]);
            } else {
              item = new qx.ui.form.ListItem(row, null);
            }

            cellEditor.add(item);
          }

          ;
        }

        cellEditor.setValue("" + value);
        cellEditor.addListener("appear", function () {
          cellEditor.selectAllText();
        });
        return cellEditor;
      },
      // interface implementations
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        var value = cellEditor.getValue() || ""; // validation function will be called with new and old value

        var validationFunc = this.getValidationFunction();

        if (validationFunc) {
          value = validationFunc(value, cellEditor.originalValue);
        }

        if (typeof cellEditor.originalValue == "number") {
          value = parseFloat(value);
        }

        return value;
      }
    }
  });
  qx.ui.table.celleditor.ComboBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.table.ICellEditorFactory": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */

  /**
   * A cell editor factory which can dynamically exchange the cell editor
   * based on information retrieved at runtime. This is useful when different
   * rows in a column should have different cellEditors based on cell content
   * or row meta data. A typical example would be a spreadsheet that has different
   * kind of data in one column.
   *
   */
  qx.Class.define("qx.ui.table.celleditor.Dynamic", {
    extend: qx.core.Object,
    implement: qx.ui.table.ICellEditorFactory,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param cellEditorFactoryFunction {Function?null} the factory function
     *    {@link #cellEditorFactoryFunction}.
     */
    construct: function construct(cellEditorFactoryFunction) {
      qx.core.Object.constructor.call(this);

      if (cellEditorFactoryFunction) {
        this.setCellEditorFactoryFunction(cellEditorFactoryFunction);
      }

      this.__infos__P_504_0 = {};
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Function that returns a cellEditorFactory instance which will be
       * used for the row that is currently being edited. The function is
       * defined like this:
       * <pre class="javascript">
       * myTable.getTableColumnModel().setCellEditorFactory(function(cellInfo){
       *   // based on the cellInfo map or other information, return the
       *   // appropriate cellEditorFactory
       *   if (cellInfo.row == 5)
       *     return new qx.ui.table.celleditor.CheckBox;
       *   else
       *     return new qx.ui.table.celleditor.TextField;
       * });
       * </pre>
       **/
      cellEditorFactoryFunction: {
        check: "Function",
        nullable: true,
        init: null
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __cellEditorFactory__P_504_1: null,
      __infos__P_504_0: null,

      /**
       * Creates the cell editor based on the cellEditorFactory instance
       * returned by the function stored in the cellEditorFactoryFunction
       * property. Passes the cellInfo map to the function.
       *
       * @param cellInfo {Map} A map containing the information about the cell to
       *      create.
       * @return {qx.ui.core.Widget}
       */
      createCellEditor: function createCellEditor(cellInfo) {
        var cellEditorFactoryFunction = this.getCellEditorFactoryFunction();
        {
          this.assertFunction(cellEditorFactoryFunction, "No function provided! Aborting.");
        }
        this.__cellEditorFactory__P_504_1 = cellEditorFactoryFunction(cellInfo);

        var cellEditor = this.__cellEditorFactory__P_504_1.createCellEditor(cellInfo); // save the cell info to the editor (needed for getting the value)


        this.__infos__P_504_0[cellEditor.toHashCode()] = cellInfo;
        return cellEditor;
      },
      // interface implementation
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        var cellEditorFactoryFunction = this.getCellEditorFactoryFunction();
        {
          this.assertFunction(cellEditorFactoryFunction, "No function provided! Aborting.");
        }

        var cellInfo = this.__infos__P_504_0[cellEditor.toHashCode()]; // update the propper factory


        this.__cellEditorFactory__P_504_1 = cellEditorFactoryFunction(cellInfo);

        var value = this.__cellEditorFactory__P_504_1.getCellEditorValue(cellEditor);

        return value;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__cellEditorFactory__P_504_1 = null;
    }
  });
  qx.ui.table.celleditor.Dynamic.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.celleditor.AbstractField": {
        "require": true
      },
      "qx.ui.form.PasswordField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A cell editor factory creating password fields fields.
   */
  qx.Class.define("qx.ui.table.celleditor.PasswordField", {
    extend: qx.ui.table.celleditor.AbstractField,
    members: {
      _createEditor: function _createEditor() {
        var cellEditor = new qx.ui.form.PasswordField();
        cellEditor.setAppearance("table-editor-textfield");
        return cellEditor;
      }
    }
  });
  qx.ui.table.celleditor.PasswordField.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.ui.table.ICellEditorFactory": {
        "require": true
      },
      "qx.ui.form.SelectBox": {},
      "qx.ui.form.ListItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A cell editor factory creating select boxes.
   */
  qx.Class.define("qx.ui.table.celleditor.SelectBox", {
    extend: qx.core.Object,
    implement: qx.ui.table.ICellEditorFactory,
    properties: {
      /**
       * function that validates the result
       * the function will be called with the new value and the old value and is
       * supposed to return the value that is set as the table value.
       **/
      validationFunction: {
        check: "Function",
        nullable: true,
        init: null
      },

      /** array of data to construct ListItem widgets with */
      listData: {
        check: "Array",
        init: null,
        nullable: true
      }
    },
    members: {
      // interface implementation
      createCellEditor: function createCellEditor(cellInfo) {
        var cellEditor = new qx.ui.form.SelectBox().set({
          appearance: "table-editor-selectbox"
        });
        var value = cellInfo.value;
        cellEditor.originalValue = value; // check if renderer does something with value

        var cellRenderer = cellInfo.table.getTableColumnModel().getDataCellRenderer(cellInfo.col);

        var label = cellRenderer._getContentHtml(cellInfo);

        if (value != label) {
          value = label;
        } // replace null values


        if (value === null) {
          value = "";
        }

        var list = this.getListData();

        if (list) {
          var item;

          for (var i = 0, l = list.length; i < l; i++) {
            var row = list[i];

            if (row instanceof Array) {
              item = new qx.ui.form.ListItem(row[0], row[1]);
              item.setUserData("row", row[2]);

              if (value == row[2]) {
                label = row[0];
              }
            } else {
              item = new qx.ui.form.ListItem(row, null);
              item.setUserData("row", row);
            }

            cellEditor.add(item);
          }

          ;
        }

        if (label != null) {
          var itemToSelect = cellEditor.getChildrenContainer().findItem(label + "");
        }

        if (itemToSelect) {
          cellEditor.setSelection([itemToSelect]);
        } else {
          cellEditor.resetSelection();
        }

        cellEditor.addListener("appear", function () {
          cellEditor.open();
        });
        return cellEditor;
      },
      // interface implementation
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        var selection = cellEditor.getSelection();
        var value = "";

        if (selection && selection[0]) {
          var userValue = selection[0].getUserData("row");
          value = userValue === undefined ? selection[0].getLabel() : userValue;
        } // validation function will be called with new and old value


        var validationFunc = this.getValidationFunction();

        if (validationFunc) {
          value = validationFunc(value, cellEditor.originalValue);
        }

        if (typeof cellEditor.originalValue == "number") {
          value = parseFloat(value);
        }

        return value;
      }
    }
  });
  qx.ui.table.celleditor.SelectBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.bom.Stylesheet": {
        "construct": true
      },
      "qx.util.ResourceManager": {},
      "qx.io.ImageLoader": {},
      "qx.bom.client.Css": {},
      "qx.bom.element.Decoration": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.inlineblock": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
  
  ************************************************************************ */

  /**
   * A template class for cell renderer, which display images. Concrete
   * implementations must implement the method {@link #_identifyImage}.
   */
  qx.Class.define("qx.ui.table.cellrenderer.AbstractImage", {
    extend: qx.ui.table.cellrenderer.Abstract,
    type: "abstract",

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.cellrenderer.Abstract.constructor.call(this);
      var clazz = qx.ui.table.cellrenderer.AbstractImage;

      if (!clazz.stylesheet) {
        clazz.stylesheet = qx.bom.Stylesheet.createElement(".qooxdoo-table-cell-icon {  text-align:center;}");
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether to repeat or scale the image.
       *
       * @param repeat {String}
       *   One of
       *     <code>scale</code>,
       *     <code>scale-x</code>,
       *     <code>scale-y</code>,
       *     <code>repeat</code>,
       *     <code>repeat-x</code>,
       *     <code>repeat-y</code>,
       *     <code>no-repeat</code>
      */
      repeat: {
        check: function check(value) {
          var valid = ["scale", "scale-x", "scale-y", "repeat", "repeat-x", "repeat-y", "no-repeat"];
          return valid.includes(value);
        },
        init: "no-repeat"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __defaultWidth__P_506_0: 16,
      __defaultHeight__P_506_1: 16,
      __imageData__P_506_2: null,

      /**
       * Identifies the Image to show. This is a template method, which must be
       * implemented by sub classes.
       *
       * @abstract
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {Map} A map having the following attributes:
       *           <ul>
       *           <li>
       *             "url": (type string) must be the URL of the image to show.
       *             The url given must either be managed by the {@link qx.util.ResourceManager}
       *             or pre-loaded with {@link qx.io.ImageLoader}. This is to make sure that
       *             the renderer knows the dimensions and the format of the image.
       *           </li>
       *           <li>"imageWidth": (type int) the width of the image in pixels.</li>
       *           <li>"imageHeight": (type int) the height of the image in pixels.</li>
       *           <li>"tooltip": (type string) must be the image tooltip text.</li>
       *           </ul>
       * @throws {Error} the abstract function warning.
       */
      _identifyImage: function _identifyImage(cellInfo) {
        throw new Error("_identifyImage is abstract");
      },

      /**
       * Retrieves the image infos.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {Map} Map with an "url" attribute (type string)
       *                 holding the URL of the image to show
       *                 and a "tooltip" attribute
       *                 (type string) being the tooltip text (or null if none was specified)
       */
      _getImageInfos: function _getImageInfos(cellInfo) {
        // Query the subclass about image and tooltip
        var imageData = this._identifyImage(cellInfo); // If subclass refuses to give map, construct it with required properties
        // If no map is given, but instead a string, assume that this string is
        // the URL of the image [BUG #4289]


        if (imageData == null || typeof imageData == "string") {
          imageData = {
            url: imageData,
            tooltip: null
          };
        } // If sizes are not included in map given by subclass,
        // fall-back to calculated image size


        if (!imageData.imageWidth || !imageData.imageHeight) {
          var sizes = this.__getImageSize__P_506_3(imageData.url);

          imageData.imageWidth = sizes.width;
          imageData.imageHeight = sizes.height;
        } // Add width and height keys to map [BUG #4289]
        // - [width|height] is read by _getContentHtml()
        // - [imageWidth|imageHeight] is possibly read in legacy applications


        imageData.width = imageData.imageWidth;
        imageData.height = imageData.imageHeight;
        return imageData;
      },

      /**
       * Compute the size of the given image
       *
       * @param source {String} the image URL
       * @return {Map} A map containing the image's <code>width</code> and
       *    <code>height</code>
       */
      __getImageSize__P_506_3: function __getImageSize__P_506_3(source) {
        var ResourceManager = qx.util.ResourceManager.getInstance();
        var ImageLoader = qx.io.ImageLoader;
        var width, height; // Detect if the image registry knows this image

        if (ResourceManager.has(source)) {
          width = ResourceManager.getImageWidth(source);
          height = ResourceManager.getImageHeight(source);
        } else if (ImageLoader.isLoaded(source)) {
          width = ImageLoader.getWidth(source);
          height = ImageLoader.getHeight(source);
        } else {
          width = this.__defaultWidth__P_506_0;
          height = this.__defaultHeight__P_506_1;
        }

        return {
          width: width,
          height: height
        };
      },
      // overridden
      createDataCellHtml: function createDataCellHtml(cellInfo, htmlArr) {
        this.__imageData__P_506_2 = this._getImageInfos(cellInfo);
        return qx.ui.table.cellrenderer.AbstractImage.prototype.createDataCellHtml.base.call(this, cellInfo, htmlArr);
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        return qx.ui.table.cellrenderer.AbstractImage.prototype._getCellClass.base.call(this) + " qooxdoo-table-cell-icon";
      },
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        var content = "<div></div>"; // set image

        if (this.__imageData__P_506_2.url) {
          var srcUrl = this.__imageData__P_506_2.url;
          var highResolutionSource = qx.util.ResourceManager.getInstance().findHighResolutionSource(this.__imageData__P_506_2.url);

          if (highResolutionSource) {
            srcUrl = highResolutionSource;
          }

          var style = {
            width: this.__imageData__P_506_2.width + "px",
            height: this.__imageData__P_506_2.height + "px",
            display: qx.core.Environment.get("css.inlineblock"),
            verticalAlign: "middle",
            position: "static"
          };

          if (qx.util.ResourceManager.getInstance().getCombinedFormat(this.__imageData__P_506_2.url) === "") {
            // background size is critical for high-resolution images but breaks combined images
            style["background-size"] = this.__imageData__P_506_2.width + "px " + this.__imageData__P_506_2.height + "px";
          }

          content = qx.bom.element.Decoration.create(srcUrl, this.getRepeat(), style);
        }

        return content;
      },
      // overridden
      _getCellAttributes: function _getCellAttributes(cellInfo) {
        var tooltip = this.__imageData__P_506_2.tooltip;

        if (tooltip) {
          return "title='" + tooltip + "'";
        } else {
          return "";
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__imageData__P_506_2 = null;
    }
  });
  qx.ui.table.cellrenderer.AbstractImage.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.AbstractImage": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      },
      "qx.theme.manager.Meta": {
        "construct": true
      },
      "qx.util.ResourceManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
  
  ************************************************************************ */

  /**
   * A data cell renderer for boolean values.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Boolean", {
    extend: qx.ui.table.cellrenderer.AbstractImage,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.cellrenderer.AbstractImage.constructor.call(this);
      this.__aliasManager__P_507_0 = qx.util.AliasManager.getInstance();
      this.initIconTrue();
      this.initIconFalse(); // dynamic theme switch

      {
        qx.theme.manager.Meta.getInstance().addListener("changeTheme", this._onChangeTheme, this);
      }
    },

    /*
     *****************************************************************************
       PROPERTIES
     *****************************************************************************
     */
    properties: {
      /**
       * The icon used to indicate the true state
       */
      iconTrue: {
        check: "String",
        init: "decoration/table/boolean-true.png",
        apply: "_applyIconTrue"
      },

      /**
      * The icon used to indicate the false state
      */
      iconFalse: {
        check: "String",
        init: "decoration/table/boolean-false.png",
        apply: "_applyIconFalse"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __iconUrlTrue__P_507_1: null,
      __iconUrlFalse__P_507_2: false,
      __aliasManager__P_507_0: null,

      /**
       * Handler for theme changes.
       * @signature function()
       */
      _onChangeTheme: function _onChangeTheme() {
        this._applyIconTrue(this.getIconTrue());

        this._applyIconFalse(this.getIconFalse());
      },
      // property apply
      _applyIconTrue: function _applyIconTrue(value) {
        this.__iconUrlTrue__P_507_1 = this.__aliasManager__P_507_0.resolve(value);
      },
      // property apply
      _applyIconFalse: function _applyIconFalse(value) {
        this.__iconUrlFalse__P_507_2 = this.__aliasManager__P_507_0.resolve(value);
      },
      // overridden
      _identifyImage: function _identifyImage(cellInfo) {
        var w;
        var h;
        var rm;
        var id;
        var ids;
        var imageHints; // Retrieve the ID

        rm = qx.util.ResourceManager.getInstance();
        ids = rm.getIds(this.__iconUrlTrue__P_507_1); // If ID was found, we'll use its first (likely only) element here.

        if (ids) {
          id = ids[0]; // Get the natural size of the image

          w = rm.getImageWidth(id);
          h = rm.getImageHeight(id);
        } // Create the size portion of the hint.
        //
        // The traditional (fixed) size of the image was 11x11px. Use that if we
        // weren't able to retrieve the actual size of the image, and never
        // exceed that size.


        imageHints = {
          imageWidth: w ? Math.min(w, 11) : 11,
          imageHeight: h ? Math.min(h, 11) : 11
        }; // Add the URL portion of the hint

        switch (cellInfo.value) {
          case true:
            imageHints.url = this.__iconUrlTrue__P_507_1;
            break;

          case false:
            imageHints.url = this.__iconUrlFalse__P_507_2;
            break;

          default:
            imageHints.url = null;
            break;
        }

        return imageHints;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__aliasManager__P_507_0 = null; // remove dynamic theme listener

      {
        qx.theme.manager.Meta.getInstance().removeListener("changeTheme", this._onChangeTheme, this);
      }
    }
  });
  qx.ui.table.cellrenderer.Boolean.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.util.format.NumberFormat": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Tartan Solutions, Inc, http://www.tartansolutions.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
  
     Authors:
       * Dan Hummon
  
  ************************************************************************ */

  /**
   * The conditional cell renderer allows special per cell formatting based on
   * conditions on the cell's value.
   *
   * @require(qx.util.format.NumberFormat)
   */
  qx.Class.define("qx.ui.table.cellrenderer.Conditional", {
    extend: qx.ui.table.cellrenderer.Default,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param align {String|null}
     *   The default text alignment to format the cell with by default.
     *
     * @param color {String|null}
     *   The default font color to format the cell with by default.
     *
     * @param style {String|null}
     *   The default font style to format the cell with by default.
     *
     * @param weight {String|null}
     *   The default font weight to format the cell with by default.
     */
    construct: function construct(align, color, style, weight) {
      qx.ui.table.cellrenderer.Default.constructor.call(this);
      this.numericAllowed = ["==", "!=", ">", "<", ">=", "<="];
      this.betweenAllowed = ["between", "!between"];
      this.conditions = [];
      this.__defaultTextAlign__P_508_0 = align || "";
      this.__defaultColor__P_508_1 = color || "";
      this.__defaultFontStyle__P_508_2 = style || "";
      this.__defaultFontWeight__P_508_3 = weight || "";
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __defaultTextAlign__P_508_0: null,
      __defaultColor__P_508_1: null,
      __defaultFontStyle__P_508_2: null,
      __defaultFontWeight__P_508_3: null,

      /**
       * Applies the cell styles to the style map.
       * @param condition {Array} The matched condition
       * @param style {Map} map of already applied styles.
       */
      __applyFormatting__P_508_4: function __applyFormatting__P_508_4(condition, style) {
        if (condition[1] != null) {
          style["text-align"] = condition[1];
        }

        if (condition[2] != null) {
          style["color"] = condition[2];
        }

        if (condition[3] != null) {
          style["font-style"] = condition[3];
        }

        if (condition[4] != null) {
          style["font-weight"] = condition[4];
        }
      },

      /**
       * The addNumericCondition method is used to add a basic numeric condition to
       * the cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the align,
       * color, style and weight arguments. Null will allow pre-existing formatting
       * to pass through, where an empty string will clear it back to the default
       * formatting set in the constructor.
       *
       *
       * @param condition {String} The type of condition. Accepted strings are "==", "!=", ">", "<", ">=",
       *     and "<=".
       * @param value1 {Integer} The value to compare against.
       * @param align {String|null} The text alignment to format the cell with if the condition matches.
       * @param color {String|null} The font color to format the cell with if the condition matches.
       * @param style {String|null} The font style to format the cell with if the condition matches.
       * @param weight {String|null} The font weight to format the cell with if the condition matches.
       * @param target {String|null} The text value of the column to compare against. If this is null,
       *     comparisons will be against the contents of this cell.
       * @throws {Error} If the condition can not be recognized or value is null.
       */
      addNumericCondition: function addNumericCondition(condition, value1, align, color, style, weight, target) {
        var temp = null;

        if (this.numericAllowed.includes(condition)) {
          if (value1 != null) {
            temp = [condition, align, color, style, weight, value1, target];
          }
        }

        if (temp != null) {
          this.conditions.push(temp);
        } else {
          throw new Error("Condition not recognized or value is null!");
        }
      },

      /**
       * The addBetweenCondition method is used to add a between condition to the
       * cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the align,
       * color, style and weight arguments. Null will allow pre-existing formatting
       * to pass through, where an empty string will clear it back to the default
       * formatting set in the constructor.
       *
       *
       * @param condition {String} The type of condition. Accepted strings are "between" and "!between".
       * @param value1 {Integer} The first value to compare against.
       * @param value2 {Integer} The second value to compare against.
       * @param align {String|null} The text alignment to format the cell with if the condition matches.
       * @param color {String|null} The font color to format the cell with if the condition matches.
       * @param style {String|null} The font style to format the cell with if the condition matches.
       * @param weight {String|null} The font weight to format the cell with if the condition matches.
       * @param target {String|null} The text value of the column to compare against. If this is null,
       *     comparisons will be against the contents of this cell.
       * @throws {Error} If the condition can not be recognized or value is null.
       */
      addBetweenCondition: function addBetweenCondition(condition, value1, value2, align, color, style, weight, target) {
        if (this.betweenAllowed.includes(condition)) {
          if (value1 != null && value2 != null) {
            var temp = [condition, align, color, style, weight, value1, value2, target];
          }
        }

        if (temp != null) {
          this.conditions.push(temp);
        } else {
          throw new Error("Condition not recognized or value1/value2 is null!");
        }
      },

      /**
       * The addRegex method is used to add a regular expression condition to the
       * cell renderer.
       *
       * Note: Passing null is different from passing an empty string in the align,
       * color, style and weight arguments. Null will allow pre-existing formatting
       * to pass through, where an empty string will clear it back to the default
       * formatting set in the constructor.
       *
       *
       * @param regex {String} The regular expression to match against.
       * @param align {String|null} The text alignment to format the cell with if the condition matches.
       * @param color {String|null} The font color to format the cell with if the condition matches.
       * @param style {String|null} The font style to format the cell with if the condition matches.
       * @param weight {String|null} The font weight to format the cell with if the condition matches.
       * @param target {String|null} The text value of the column to compare against. If this is null,
       *     comparisons will be against the contents of this cell.
       * @throws {Error} If the regex is null.
       */
      addRegex: function addRegex(regex, align, color, style, weight, target) {
        if (regex != null) {
          var temp = ["regex", align, color, style, weight, regex, target];
        }

        if (temp != null) {
          this.conditions.push(temp);
        } else {
          throw new Error("regex cannot be null!");
        }
      },

      /**
       * Overridden; called whenever the cell updates. The cell will iterate through
       * each available condition and apply formatting for those that
       * match. Multiple conditions can match, but later conditions will override
       * earlier ones. Conditions with null values will stack with other conditions
       * that apply to that value.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {Map}
       */
      _getCellStyle: function _getCellStyle(cellInfo) {
        var tableModel = cellInfo.table.getTableModel();
        var i;
        var cond_test;
        var compareValue;
        var style = {
          "text-align": this.__defaultTextAlign__P_508_0,
          "color": this.__defaultColor__P_508_1,
          "font-style": this.__defaultFontStyle__P_508_2,
          "font-weight": this.__defaultFontWeight__P_508_3
        };

        for (i in this.conditions) {
          cond_test = false;

          if (this.numericAllowed.includes(this.conditions[i][0])) {
            if (this.conditions[i][6] == null) {
              compareValue = cellInfo.value;
            } else {
              compareValue = tableModel.getValueById(this.conditions[i][6], cellInfo.row);
            }

            switch (this.conditions[i][0]) {
              case "==":
                if (compareValue == this.conditions[i][5]) {
                  cond_test = true;
                }

                break;

              case "!=":
                if (compareValue != this.conditions[i][5]) {
                  cond_test = true;
                }

                break;

              case ">":
                if (compareValue > this.conditions[i][5]) {
                  cond_test = true;
                }

                break;

              case "<":
                if (compareValue < this.conditions[i][5]) {
                  cond_test = true;
                }

                break;

              case ">=":
                if (compareValue >= this.conditions[i][5]) {
                  cond_test = true;
                }

                break;

              case "<=":
                if (compareValue <= this.conditions[i][5]) {
                  cond_test = true;
                }

                break;
            }
          } else if (this.betweenAllowed.includes(this.conditions[i][0])) {
            if (this.conditions[i][7] == null) {
              compareValue = cellInfo.value;
            } else {
              compareValue = tableModel.getValueById(this.conditions[i][7], cellInfo.row);
            }

            switch (this.conditions[i][0]) {
              case "between":
                if (compareValue >= this.conditions[i][5] && compareValue <= this.conditions[i][6]) {
                  cond_test = true;
                }

                break;

              case "!between":
                if (compareValue < this.conditions[i][5] || compareValue > this.conditions[i][6]) {
                  cond_test = true;
                }

                break;
            }
          } else if (this.conditions[i][0] == "regex") {
            if (this.conditions[i][6] == null) {
              compareValue = cellInfo.value;
            } else {
              compareValue = tableModel.getValueById(this.conditions[i][6], cellInfo.row);
            }

            var the_pattern = new RegExp(this.conditions[i][5], 'g');
            cond_test = the_pattern.test(compareValue);
          } // Apply formatting, if any.


          if (cond_test == true) {
            this.__applyFormatting__P_508_4(this.conditions[i], style);
          }
        }

        var styleString = [];

        for (var key in style) {
          if (style[key]) {
            styleString.push(key, ":", style[key], ";");
          }
        }

        return styleString.join("");
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.numericAllowed = this.betweenAllowed = this.conditions = null;
    }
  });
  qx.ui.table.cellrenderer.Conditional.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Conditional": {
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 OpenHex SPRL, http://www.openhex.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gaetan de Menten (ged)
  
  ************************************************************************ */

  /**
   * Specific data cell renderer for dates.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Date", {
    extend: qx.ui.table.cellrenderer.Conditional,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * DateFormat used to format the data.
       */
      dateFormat: {
        check: "qx.util.format.DateFormat",
        init: null,
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _getContentHtml: function _getContentHtml(cellInfo) {
        var df = this.getDateFormat();

        if (df) {
          if (cellInfo.value) {
            return qx.bom.String.escape(df.format(cellInfo.value));
          } else {
            return "";
          }
        } else {
          return cellInfo.value || "";
        }
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        return "qooxdoo-table-cell";
      }
    }
  });
  qx.ui.table.cellrenderer.Date.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Abstract": {
        "require": true
      },
      "qx.dev.Debug": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A debug cell editor.  This displays cellInfo.value using
   * {@link qx.dev.Debug#debugObjectToString} so is useful as a starting point
   * during development of a table, before writing each of the cell renderers.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Debug", {
    extend: qx.ui.table.cellrenderer.Abstract,
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        var html = "<div style='height:" + cellInfo.styleHeight + "px;overflow:auto;'>" + qx.dev.Debug.debugObjectToString(cellInfo.value, "row=" + cellInfo.row + ", col=" + cellInfo.col, 10, true) + "</div>";
        return html;
      }
    }
  });
  qx.ui.table.cellrenderer.Debug.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */

  /**
   * A cell renderer factory which can dynamically exchange the cell renderer
   * based on information retrieved at runtime. This is useful when different
   * rows in a column should have different cell renderer based on cell content
   * or row metadata. A typical example would be a spreadsheet that has different
   * kind of data in one column.
   *
   */
  qx.Class.define("qx.ui.table.cellrenderer.Dynamic", {
    extend: qx.ui.table.cellrenderer.Default,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param cellRendererFactoryFunction {Function?null} The initial value for
     *    the property {@link #cellRendererFactoryFunction}.
     */
    construct: function construct(cellRendererFactoryFunction) {
      qx.ui.table.cellrenderer.Default.constructor.call(this);

      if (cellRendererFactoryFunction) {
        this.setCellRendererFactoryFunction(cellRendererFactoryFunction);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Function that returns a cellRenderer instance which will be
       * used for the row that is currently being edited. The function is
       * defined like this:
       *
       * <pre class="javascript">
       * myTable.getTableColumnModel().setCellRenderer(function(cellInfo){
       *   // based on the cellInfo map or other information, return the
       *   // appropriate cell renderer
       *   if (cellInfo.row == 5)
       *     return new qx.ui.table.cellrenderer.Boolean;
       *   else
       *     return new qx.ui.table.cellrenderer.Default;
       * });
       * </pre>
       *
       * the function MUST return at least a qx.ui.table.cellrenderer.Default
       **/
      cellRendererFactoryFunction: {
        check: "Function",
        nullable: true,
        init: null
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Overridden; called whenever the cell updates. The cell will call the
       * function stored in the cellRendererFactoryFunction to retrieve the
       * cell renderer which should be used for this particular cell
       *
       * @param cellInfo {Map} A map containing the information about the cell to
       *     create.
       * @param htmlArr {String[]} Target string container. The HTML of the data
       *     cell should be appended to this array.
       * @return {String} Data cell HTML
       */
      createDataCellHtml: function createDataCellHtml(cellInfo, htmlArr) {
        var cellRendererFactoryFunction = this.getCellRendererFactoryFunction();

        if (!cellRendererFactoryFunction) {
          throw new Error("No function provided! Aborting.");
        }

        var cellRenderer = cellRendererFactoryFunction(cellInfo);
        return cellRenderer.createDataCellHtml(cellInfo, htmlArr);
      }
    }
  });
  qx.ui.table.cellrenderer.Dynamic.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Conditional": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 OpenHex SPRL, http://www.openhex.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Dirk Wellmann (dw(at)piponline.net)
  
  ************************************************************************ */

  /**
   * This Cellrender is for transparent use, without escaping! Use this Cellrender
   * to output plain HTML content.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Html", {
    extend: qx.ui.table.cellrenderer.Conditional,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        return cellInfo.value || "";
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        return "qooxdoo-table-cell";
      }
    }
  });
  qx.ui.table.cellrenderer.Html.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.AbstractImage": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Tartan Solutions, Inc, http://www.tartansolutions.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
  
     Authors:
       * Dan Hummon
  
  ************************************************************************ */

  /**
   * The image cell renderer renders image into table cells.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Image", {
    extend: qx.ui.table.cellrenderer.AbstractImage,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param height {Integer?16} The height of the image. The default is 16.
     * @param width {Integer?16} The width of the image. The default is 16.
     */
    construct: function construct(width, height) {
      qx.ui.table.cellrenderer.AbstractImage.constructor.call(this);

      if (width) {
        this.__imageWidth__P_509_0 = width;
      }

      if (height) {
        this.__imageHeight__P_509_1 = height;
      }

      this.__am__P_509_2 = qx.util.AliasManager.getInstance();
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __am__P_509_2: null,
      __imageHeight__P_509_1: 16,
      __imageWidth__P_509_0: 16,
      // overridden
      _identifyImage: function _identifyImage(cellInfo) {
        var imageHints = {
          imageWidth: this.__imageWidth__P_509_0,
          imageHeight: this.__imageHeight__P_509_1
        };

        if (cellInfo.value == "") {
          imageHints.url = null;
        } else {
          imageHints.url = this.__am__P_509_2.resolve(cellInfo.value);
        }

        imageHints.tooltip = cellInfo.tooltip;
        return imageHints;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__am__P_509_2 = null;
    }
  });
  qx.ui.table.cellrenderer.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Conditional": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 OpenHex SPRL, http://www.openhex.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gaetan de Menten (ged)
  
  ************************************************************************ */

  /**
   * Specific data cell renderer for numbers.
   */
  qx.Class.define("qx.ui.table.cellrenderer.Number", {
    extend: qx.ui.table.cellrenderer.Conditional,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * NumberFormat used to format data. If the numberFormat contains a
       * prefix and/or postfix containing characters which needs to be escaped,
       * those need to be given to the numberFormat in their escaped form
       * because no escaping happens at the cellrenderer level.
       */
      numberFormat: {
        check: "qx.util.format.NumberFormat",
        init: null,
        nullable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _getContentHtml: function _getContentHtml(cellInfo) {
        var nf = this.getNumberFormat();

        if (nf) {
          if (cellInfo.value || cellInfo.value == 0) {
            // I don't think we need to escape the resulting string, as I
            // don't know of any decimal or separator which use a character
            // which needs escaping. It is much more plausible to have a
            // prefix, postfix containing such characters but those can be
            // (should be) added in their escaped form to the number format.
            return nf.format(cellInfo.value);
          } else {
            return "";
          }
        } else {
          return cellInfo.value == 0 ? "0" : cellInfo.value || "";
        }
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        return "qooxdoo-table-cell qooxdoo-table-cell-right";
      }
    }
  });
  qx.ui.table.cellrenderer.Number.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */

  /**
   * A cell renderer which hides cell values such as passwords form view
   * by masking them by *s
   *
   */
  qx.Class.define("qx.ui.table.cellrenderer.Password", {
    extend: qx.ui.table.cellrenderer.Default,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Overridden; called whenever the cell updates.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {String}
       */
      _getContentHtml: function _getContentHtml(cellInfo) {
        var value = cellInfo.value;

        if (value === null) {
          value = "";
        }

        cellInfo.value = value.replace(/./g, "*");
        return qx.bom.String.escape(this._formatValue(cellInfo));
      }
    }
  });
  qx.ui.table.cellrenderer.Password.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */

  /**
   * The cell will use, if given, the
   * replaceMap property and/or the replaceFunction to look up labels for a
   * specific cell value. if the replaceMap, which does not need to be used but
   * takes precedence if given, has no entry for a specific value, you can implement
   * a fallback lookup in the replacementFunction, or use the replacementFunction exclusively.
   *
   * In editable cells, you need to make sure that the method returning the data
   * to the data storage (for example, a database backend) translates the replaced
   * cell value (the label) back into the corresponding value. Thus, both map and
   * function MUST also take care of the reverse translation of labels into
   * values. Example: if you have a field that should display "Active" on a "1"
   * value and "Inactive" on a "0" value, you must use the following map:
   *
   * <pre class='javascript'>
   * {
   *   0 : "Inactive",
   *   1 : "Active",
   *   "Inactive" : 0,
   *   "Active" : 1
   * }
   * </pre>
   *
   * You can use the addReversedReplaceMap() method to do this for you:
   * <pre class='javascript'>
   * var propertyCellRenderer = new qx.ui.table.cellrenderer.Replace;
   * propertyCellRenderer.setReplaceMap({
   *    1 : "Active",
   *   0 : "Inactive",
   *   2  : "Waiting",
   *   'admin' : "System Administrator",
   *   'manager' : "User Manager",
   *   'user' : "Website User"
   * });
   * propertyCellRenderer.addReversedReplaceMap();
   * </pre>
   *
   * @param cellInfo {Map} The information about the cell.
   *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
   * @return {String}
   */
  qx.Class.define("qx.ui.table.cellrenderer.Replace", {
    extend: qx.ui.table.cellrenderer.Default,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** a hashmap which is used to replace values by labels */
      replaceMap: {
        check: "Object",
        nullable: true,
        init: null
      },

      /**
       * function that provides the label for a specific value
       **/
      replaceFunction: {
        check: "Function",
        nullable: true,
        init: null
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        var value = cellInfo.value;
        var replaceMap = this.getReplaceMap();
        var replaceFunc = this.getReplaceFunction();
        var label; // use map

        if (replaceMap) {
          label = replaceMap[value];

          if (typeof label != "undefined") {
            cellInfo.value = label;
            return qx.bom.String.escape(this._formatValue(cellInfo));
          }
        } // use function


        if (replaceFunc) {
          cellInfo.value = replaceFunc(value);
        }

        return qx.bom.String.escape(this._formatValue(cellInfo));
      },

      /**
       * adds a reversed replaceMap to itself to translate labels back to the original values
       * @return {Boolean} <code>true</code>
       */
      addReversedReplaceMap: function addReversedReplaceMap() {
        var map = this.getReplaceMap();

        for (var key in map) {
          var value = map[key];
          map[value] = key;
        }

        return true;
      }
    }
  });
  qx.ui.table.cellrenderer.Replace.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Conditional": {
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 OpenHex SPRL, http://www.openhex.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Gaetan de Menten (ged)
  
  ************************************************************************ */

  /**
   * The string data cell renderer. All it does is escape the incoming String
   * values.
   */
  qx.Class.define("qx.ui.table.cellrenderer.String", {
    extend: qx.ui.table.cellrenderer.Conditional,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        return qx.bom.String.escape(cellInfo.value || "");
      },
      // overridden
      _getCellClass: function _getCellClass(cellInfo) {
        return "qooxdoo-table-cell";
      }
    }
  });
  qx.ui.table.cellrenderer.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.columnmodel.Basic": {
        "construct": true,
        "require": true
      },
      "qx.locale.MTranslation": {
        "require": true
      },
      "qx.ui.table.columnmodel.resizebehavior.Default": {},
      "qx.event.Timer": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.tableResizeDebug": {}
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A table column model that automatically resizes columns based on a
   * selected behavior.
   *
   * @see qx.ui.table.columnmodel.Basic
   */
  qx.Class.define("qx.ui.table.columnmodel.Resize", {
    extend: qx.ui.table.columnmodel.Basic,
    include: qx.locale.MTranslation,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.columnmodel.Basic.constructor.call(this); // We don't want to recursively call ourself based on our resetting of
      // column sizes.  Track when we're resizing.

      this.__bInProgress__P_512_0 = false; // Track when the table has appeared.  We want to ignore resize events
      // until then since we won't be able to determine the available width
      // anyway.

      this.__bAppeared__P_512_1 = false;
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The behavior to use.
       *
       * The provided behavior must extend {@link qx.ui.table.columnmodel.resizebehavior.Abstract} and
       * implement the <i>onAppear</i>, <i>onTableWidthChanged</i>,
       * <i>onColumnWidthChanged</i> and <i>onVisibilityChanged</i>methods.
       */
      behavior: {
        check: "qx.ui.table.columnmodel.resizebehavior.Abstract",
        init: null,
        nullable: true,
        apply: "_applyBehavior",
        event: "changeBehavior"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __bAppeared__P_512_1: null,
      __bInProgress__P_512_0: null,
      __table__P_512_2: null,
      // Behavior modifier
      _applyBehavior: function _applyBehavior(value, old) {
        if (old != null) {
          old.dispose();
          old = null;
        } // Tell the new behavior how many columns there are


        value._setNumColumns(this.getOverallColumnCount());

        value.setTableColumnModel(this);
      },

      /**
       * Initializes the column model.
       *
       * @param numColumns {Integer} the number of columns the model should have.
       * @param table {qx.ui.table.Table}
       *   The table which this model is used for. This allows us access to
       *   other aspects of the table, as the <i>behavior</i> sees fit.
       */
      init: function init(numColumns, table) {
        // Call our superclass
        qx.ui.table.columnmodel.Resize.prototype.init.base.call(this, numColumns, table);

        if (this.__table__P_512_2 == null) {
          this.__table__P_512_2 = table; // We'll do our column resizing when the table appears, ...

          table.addListener("appear", this._onappear, this); // ... when the inner width of the table changes, ...

          table.addListener("tableWidthChanged", this._onTableWidthChanged, this); // ... when a vertical scroll bar appears or disappears

          table.addListener("verticalScrollBarChanged", this._onverticalscrollbarchanged, this); // We want to manipulate the button visibility menu

          table.addListener("columnVisibilityMenuCreateEnd", this._addResetColumnWidthButton, this); // ... when columns are resized, ...

          this.addListener("widthChanged", this._oncolumnwidthchanged, this); // ... and when a column visibility changes.

          this.addListener("visibilityChanged", this._onvisibilitychanged, this);
        } // Set the initial resize behavior


        if (this.getBehavior() == null) {
          this.setBehavior(new qx.ui.table.columnmodel.resizebehavior.Default());
        } // Tell the behavior how many columns there are


        this.getBehavior()._setNumColumns(numColumns);
      },

      /**
       * Get the table widget
       *
       * @return {qx.ui.table.Table} the table widget
       */
      getTable: function getTable() {
        return this.__table__P_512_2;
      },

      /**
       * Reset the column widths to their "onappear" defaults.
       *
       * @param event {qx.event.type.Data}
       *   The "columnVisibilityMenuCreateEnd" event indicating that the menu is
       *   being generated.  The data is a map containing properties <i>table</i>
       *   and <i>menu</i>.
       *
       */
      _addResetColumnWidthButton: function _addResetColumnWidthButton(event) {
        var data = event.getData();
        var columnButton = data.columnButton;
        var menu = data.menu;
        var o; // Add a separator between the column names and our reset button

        o = columnButton.factory("separator");
        menu.add(o); // Add a button to reset the column widths

        o = columnButton.factory("user-button", {
          text: this.tr("Reset column widths")
        });
        menu.add(o);
        o.addListener("execute", this._onappear, this);
      },

      /**
       * Event handler for the "appear" event.
       *
       * @param event {qx.event.type.Event}
       *   The "onappear" event object.
       *
       */
      _onappear: function _onappear(event) {
        // Is this a recursive call?
        if (this.__bInProgress__P_512_0) {
          // Yup.  Ignore it.
          return;
        }

        this.__bInProgress__P_512_0 = true;
        {
          if (qx.core.Environment.get("qx.tableResizeDebug")) {
            this.debug("onappear");
          }
        } // this handler is also called by the "execute" event of the menu button

        this.getBehavior().onAppear(event, event.getType() !== "appear");

        this.__table__P_512_2._updateScrollerWidths();

        this.__table__P_512_2._updateScrollBarVisibility();

        this.__bInProgress__P_512_0 = false;
        this.__bAppeared__P_512_1 = true;
      },

      /**
       * Event handler for the "tableWidthChanged" event.
       *
       * @param event {qx.event.type.Event}
       *   The "onwindowresize" event object.
       *
       */
      _onTableWidthChanged: function _onTableWidthChanged(event) {
        // Is this a recursive call or has the table not yet been rendered?
        if (this.__bInProgress__P_512_0 || !this.__bAppeared__P_512_1) {
          // Yup.  Ignore it.
          return;
        }

        this.__bInProgress__P_512_0 = true;
        {
          if (qx.core.Environment.get("qx.tableResizeDebug")) {
            this.debug("ontablewidthchanged");
          }
        }
        this.getBehavior().onTableWidthChanged(event);
        this.__bInProgress__P_512_0 = false;
      },

      /**
       * Event handler for the "verticalScrollBarChanged" event.
       *
       * @param event {qx.event.type.Data}
       *   The "verticalScrollBarChanged" event object.  The data is a boolean
       *   indicating whether a vertical scroll bar is now present.
       *
       */
      _onverticalscrollbarchanged: function _onverticalscrollbarchanged(event) {
        // Is this a recursive call or has the table not yet been rendered?
        if (this.__bInProgress__P_512_0 || !this.__bAppeared__P_512_1) {
          // Yup.  Ignore it.
          return;
        }

        this.__bInProgress__P_512_0 = true;
        {
          if (qx.core.Environment.get("qx.tableResizeDebug")) {
            this.debug("onverticalscrollbarchanged");
          }
        }
        this.getBehavior().onVerticalScrollBarChanged(event);
        qx.event.Timer.once(function () {
          if (this.__table__P_512_2 && !this.__table__P_512_2.isDisposed()) {
            this.__table__P_512_2._updateScrollerWidths();

            this.__table__P_512_2._updateScrollBarVisibility();
          }
        }, this, 0);
        this.__bInProgress__P_512_0 = false;
      },

      /**
       * Event handler for the "widthChanged" event.
       *
       * @param event {qx.event.type.Data}
       *   The "widthChanged" event object.
       *
       */
      _oncolumnwidthchanged: function _oncolumnwidthchanged(event) {
        // Is this a recursive call or has the table not yet been rendered?
        if (this.__bInProgress__P_512_0 || !this.__bAppeared__P_512_1) {
          // Yup.  Ignore it.
          return;
        }

        this.__bInProgress__P_512_0 = true;
        {
          if (qx.core.Environment.get("qx.tableResizeDebug")) {
            this.debug("oncolumnwidthchanged");
          }
        }
        this.getBehavior().onColumnWidthChanged(event);
        this.__bInProgress__P_512_0 = false;
      },

      /**
       * Event handler for the "visibilityChanged" event.
       *
       * @param event {qx.event.type.Data}
       *   The "visibilityChanged" event object.
       *
       */
      _onvisibilitychanged: function _onvisibilitychanged(event) {
        // Is this a recursive call or has the table not yet been rendered?
        if (this.__bInProgress__P_512_0 || !this.__bAppeared__P_512_1) {
          // Yup.  Ignore it.
          return;
        }

        this.__bInProgress__P_512_0 = true;
        {
          if (qx.core.Environment.get("qx.tableResizeDebug")) {
            this.debug("onvisibilitychanged");
          }
        }
        this.getBehavior().onVisibilityChanged(event);
        this.__bInProgress__P_512_0 = false;
      }
    },

    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct: function destruct() {
      var behavior = this.getBehavior();

      if (behavior) {
        behavior.dispose();
      }

      this.__table__P_512_2 = null;
    }
  });
  qx.ui.table.columnmodel.Resize.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * An abstract resize behavior.  All resize behaviors should extend this
   * class.
   */
  qx.Class.define("qx.ui.table.columnmodel.resizebehavior.Abstract", {
    type: "abstract",
    extend: qx.core.Object,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Called when the ResizeTableColumnModel is initialized, and upon loading of
       * a new TableModel, to allow the Resize Behaviors to know how many columns
       * are in use.
       *
       * @abstract
       * @param numColumns {Integer} The number of columns in use.
       * @throws {Error} the abstract function warning.
       */
      _setNumColumns: function _setNumColumns(numColumns) {
        throw new Error("_setNumColumns is abstract");
      },

      /**
       * Called when the table has first been rendered.
       *
       * @abstract
       * @param event {var} The <i>onappear</i> event object.
       * @param forceRefresh {Boolean?false} Whether a refresh should be forced
       * @throws {Error} the abstract function warning.
       */
      onAppear: function onAppear(event, forceRefresh) {
        throw new Error("onAppear is abstract");
      },

      /**
       * Called when the table width changes due to either a window size change
       * or a parent object changing size causing the table to change size.
       *
       * @abstract
       * @param event {var} The <i>tableWidthChanged</i> event object.
       * @throws {Error} the abstract function warning.
       */
      onTableWidthChanged: function onTableWidthChanged(event) {
        throw new Error("onTableWidthChanged is abstract");
      },

      /**
       * Called when the use of vertical scroll bar in the table changes, either
       * from present to not present, or vice versa.
       *
       * @abstract
       * @param event {var} The <i>verticalScrollBarChanged</i> event object.  This event has data,
       *     obtained via event.getValue(), which is a boolean indicating whether a
       *     vertical scroll bar is now present.
       * @throws {Error} the abstract function warning.
       */
      onVerticalScrollBarChanged: function onVerticalScrollBarChanged(event) {
        throw new Error("onVerticalScrollBarChanged is abstract");
      },

      /**
       * Called when a column width is changed.
       *
       * @abstract
       * @param event {var} The <i>widthChanged</i> event object.  This event has data, obtained via
       *     event.getValue(), which is an object with three properties: the column
       *     which changed width (data.col), the old width (data.oldWidth) and the new
       *     width (data.newWidth).
       * @throws {Error} the abstract function warning.
       */
      onColumnWidthChanged: function onColumnWidthChanged(event) {
        throw new Error("onColumnWidthChanged is abstract");
      },

      /**
       * Called when a column visibility is changed.
       *
       * @abstract
       * @param event {var} The <i>visibilityChanged</i> event object.  This event has data, obtained
       *     via event.getValue(), which is an object with two properties: the column
       *     which changed width (data.col) and the new visibility of the column
       *     (data.visible).
       * @throws {Error} the abstract function warning.
       */
      onVisibilityChanged: function onVisibilityChanged(event) {
        throw new Error("onVisibilityChanged is abstract");
      },

      /**
       * Determine the inner width available to columns in the table.
       *
       * @return {Integer} The available width
       */
      _getAvailableWidth: function _getAvailableWidth() {
        var tableColumnModel = this.getTableColumnModel(); // Get the inner width off the table

        var table = tableColumnModel.getTable();

        var scrollerArr = table._getPaneScrollerArr();

        if (!scrollerArr[0] || !scrollerArr[0].getLayoutParent().getBounds()) {
          return null;
        }

        ;
        var scrollerParentWidth = scrollerArr[0].getLayoutParent().getBounds().width;
        var lastScroller = scrollerArr[scrollerArr.length - 1];
        scrollerParentWidth -= lastScroller.getPaneInsetRight();
        return scrollerParentWidth;
      }
    }
  });
  qx.ui.table.columnmodel.resizebehavior.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.ui.core.ColumnData": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.columnmodel.resizebehavior.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.layout.HBox": {
        "construct": true
      },
      "qx.util.DeferredCall": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * The default resize behavior.  Until a resize model is loaded, the default
   * behavior is to:
   * <ol>
   *   <li>
   *     Upon the table initially appearing, and upon any window resize, divide
   *     the table space equally between the visible columns.
   *   </li>
   *   <li>
   *     When a column is increased in width, all columns to its right are
   *     pushed to the right with no change to their widths.  This may push some
   *     columns off the right edge of the table, causing a horizontal scroll
   *     bar to appear.
   *   </li>
   *   <li>
   *     When a column is decreased in width, if the total width of all columns
   *     is <i>greater than</i> the table width, no additional column width
   *     change is made.
   *   </li>
   *   <li>
   *     When a column is decreased in width, if the total width of all columns
   *     is <i>less than</i> the table width, the visible column
   *     immediately to the right of the column which decreased in width has its
   *     width increased to fill the remaining space.
   *   </li>
   * </ol>
   *
   * A resize model may be loaded to provide more guidance on how to adjust
   * column width upon each of the events: initial appear, window resize, and
   * column resize. *** TO BE FILLED IN ***
   *
   * @require(qx.ui.core.ColumnData)
   */
  qx.Class.define("qx.ui.table.columnmodel.resizebehavior.Default", {
    extend: qx.ui.table.columnmodel.resizebehavior.Abstract,
    construct: function construct() {
      qx.ui.table.columnmodel.resizebehavior.Abstract.constructor.call(this);
      this.__resizeColumnData__P_513_0 = []; // This layout is not connected to a widget but to this class. This class
      // must implement the method "getLayoutChildren", which must return all
      // columns (LayoutItems) which should be recalculated. The call
      // "layout.renderLayout" will call the method "renderLayout" on each column
      // data object
      // The advantage of the use of the normal layout manager is that the
      // semantics of flex and percent are exactly the same as in the widget code.

      this.__layout__P_513_1 = new qx.ui.layout.HBox();

      this.__layout__P_513_1.connectToWidget(this);

      this.__deferredComputeColumnsFlexWidth__P_513_2 = new qx.util.DeferredCall(this._computeColumnsFlexWidth, this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * A function to instantiate a resize behavior column data object.
       */
      newResizeBehaviorColumnData: {
        check: "Function",
        init: function init(obj) {
          return new qx.ui.core.ColumnData();
        }
      },

      /**
       * Whether to reinitialize default widths on each appear event.
       * Typically, one would want to initialize the default widths only upon
       * the first appearance of the table, but the original behavior was to
       * reinitialize it even if the table is hidden and then reshown
       * (e.g. it's in a pageview and the page is switched and then switched
       * back).
       */
      initializeWidthsOnEveryAppear: {
        check: "Boolean",
        init: false
      },

      /**
       * The table column model in use.  Of particular interest is the method
       * <i>getTable</i> which is a reference to the table widget.  This allows
       * access to any other features of the table, for use in calculating widths
       * of columns.
       */
      tableColumnModel: {
        check: "qx.ui.table.columnmodel.Resize"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __layout__P_513_1: null,
      __layoutChildren__P_513_3: null,
      __resizeColumnData__P_513_0: null,
      __deferredComputeColumnsFlexWidth__P_513_2: null,

      /**
       * Whether we have initialized widths on the first appear yet
       */
      __widthsInitialized__P_513_4: false,

      /**
       * Set the width of a column.
       *
       * @param col {Integer} The column whose width is to be set
       *
       * @param width {Integer|String}
       *   The width of the specified column.  The width may be specified as
       *   integer number of pixels (e.g. 100), a string representing percentage
       *   of the inner width of the Table (e.g. "25%"), or a string
       *   representing a flex width (e.g. "1*").
       *
       * @param flex {Integer?0} Optional flex value of the column
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setWidth: function setWidth(col, width, flex) {
        // Ensure the column is within range
        if (col >= this.__resizeColumnData__P_513_0.length) {
          throw new Error("Column number out of range");
        } // Set the new width


        this.__resizeColumnData__P_513_0[col].setColumnWidth(width, flex);

        this.__deferredComputeColumnsFlexWidth__P_513_2.schedule();
      },

      /**
       * Set the minimum width of a column.
       *
       * @param col {Integer}
       *   The column whose minimum width is to be set
       *
       * @param width {Integer}
       *   The minimum width of the specified column.
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setMinWidth: function setMinWidth(col, width) {
        // Ensure the column is within range
        if (col >= this.__resizeColumnData__P_513_0.length) {
          throw new Error("Column number out of range");
        } // Set the new width


        this.__resizeColumnData__P_513_0[col].setMinWidth(width);

        this.__deferredComputeColumnsFlexWidth__P_513_2.schedule();
      },

      /**
       * Set the maximum width of a column.
       *
       * @param col {Integer}
       *   The column whose maximum width is to be set
       *
       * @param width {Integer}
       *   The maximum width of the specified column.
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      setMaxWidth: function setMaxWidth(col, width) {
        // Ensure the column is within range
        if (col >= this.__resizeColumnData__P_513_0.length) {
          throw new Error("Column number out of range");
        } // Set the new width


        this.__resizeColumnData__P_513_0[col].setMaxWidth(width);

        this.__deferredComputeColumnsFlexWidth__P_513_2.schedule();
      },

      /**
       * Set any or all of the width, minimum width, and maximum width of a
       * column in a single call.
       *
       * @param col {Integer}
       *   The column whose attributes are to be changed
       *
       * @param map {Map}
       *   A map containing any or all of the property names "width", "minWidth",
       *   and "maxWidth".  The property values are as described for
       *   {@link #setWidth}, {@link #setMinWidth} and {@link #setMaxWidth}
       *   respectively.
       *
       *
       * @throws {Error}
       *   Error is thrown if the provided column number is out of the range.
       */
      set: function set(col, map) {
        for (var prop in map) {
          switch (prop) {
            case "width":
              this.setWidth(col, map[prop]);
              break;

            case "minWidth":
              this.setMinWidth(col, map[prop]);
              break;

            case "maxWidth":
              this.setMaxWidth(col, map[prop]);
              break;

            default:
              throw new Error("Unknown property: " + prop);
          }
        }
      },
      // overloaded
      onAppear: function onAppear(event, forceRefresh) {
        // If we haven't initialized widths at least once, or
        // they want us to reinitialize widths on every appear event...
        if (forceRefresh === true || !this.__widthsInitialized__P_513_4 || this.getInitializeWidthsOnEveryAppear()) {
          // Calculate column widths
          this._computeColumnsFlexWidth(); // Track that we've initialized widths at least once


          this.__widthsInitialized__P_513_4 = true;
        }
      },
      // overloaded
      onTableWidthChanged: function onTableWidthChanged(event) {
        this._computeColumnsFlexWidth();
      },
      // overloaded
      onVerticalScrollBarChanged: function onVerticalScrollBarChanged(event) {
        this._computeColumnsFlexWidth();
      },
      // overloaded
      onColumnWidthChanged: function onColumnWidthChanged(event) {
        // Extend the next column to fill blank space
        this._extendNextColumn(event);
      },
      // overloaded
      onVisibilityChanged: function onVisibilityChanged(event) {
        // Event data properties: col, visible
        var data = event.getData(); // If a column just became visible, resize all columns.

        if (data.visible) {
          this._computeColumnsFlexWidth();

          return;
        } // Extend the last column to fill blank space


        this._extendLastColumn(event);
      },
      // overloaded
      _setNumColumns: function _setNumColumns(numColumns) {
        var colData = this.__resizeColumnData__P_513_0; // Are there now fewer (or the same number of) columns than there were
        // previously?

        if (numColumns <= colData.length) {
          // Yup.  Delete the extras.
          colData.splice(numColumns, colData.length);
          return;
        } // There are more columns than there were previously.  Allocate more.


        for (var i = colData.length; i < numColumns; i++) {
          colData[i] = this.getNewResizeBehaviorColumnData()();
          colData[i].columnNumber = i;
        }
      },

      /**
       * This method is required by the box layout. If returns an array of items
       * to relayout.
       *
       * @return {qx.ui.core.ColumnData[]} The list of column data object to layout.
       */
      getLayoutChildren: function getLayoutChildren() {
        return this.__layoutChildren__P_513_3;
      },

      /**
       * Computes the width of all flexible children.
       *
       */
      _computeColumnsFlexWidth: function _computeColumnsFlexWidth() {
        this.__deferredComputeColumnsFlexWidth__P_513_2.cancel();

        var width = this._getAvailableWidth();

        if (width === null) {
          return;
        }

        var tableColumnModel = this.getTableColumnModel();
        var visibleColumns = tableColumnModel.getVisibleColumns();
        var visibleColumnsLength = visibleColumns.length;
        var colData = this.__resizeColumnData__P_513_0;
        var i, l;

        if (visibleColumnsLength === 0) {
          return;
        } // Create an array of the visible columns


        var columns = [];

        for (i = 0; i < visibleColumnsLength; i++) {
          columns.push(colData[visibleColumns[i]]);
        }

        this.__layoutChildren__P_513_3 = columns;

        this.__clearLayoutCaches__P_513_5(); // Use a horizontal box layout to determine the available width.


        this.__layout__P_513_1.renderLayout(width, 100, {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }); // Now that we've calculated the width, set it.


        for (i = 0, l = columns.length; i < l; i++) {
          var colWidth = columns[i].getComputedWidth();
          tableColumnModel.setColumnWidth(visibleColumns[i], colWidth);
        }
      },

      /**
       * Clear all layout caches of the column datas.
       */
      __clearLayoutCaches__P_513_5: function __clearLayoutCaches__P_513_5() {
        this.__layout__P_513_1.invalidateChildrenCache();

        var children = this.__layoutChildren__P_513_3;

        for (var i = 0, l = children.length; i < l; i++) {
          children[i].invalidateLayoutCache();
        }
      },

      /**
       * Extend the visible column to right of the column which just changed
       * width, to fill any available space within the inner width of the table.
       * This means that if the sum of the widths of all columns exceeds the
       * inner width of the table, no change is made.  If, on the other hand,
       * the sum of the widths of all columns is less than the inner width of
       * the table, the visible column to the right of the column which just
       * changed width is extended to take up the width available within the
       * inner width of the table.
       *
       *
       * @param event {qx.event.type.Data}
       *   The event object.
       *
       */
      _extendNextColumn: function _extendNextColumn(event) {
        var tableColumnModel = this.getTableColumnModel(); // Event data properties: col, oldWidth, newWidth

        var data = event.getData();
        var visibleColumns = tableColumnModel.getVisibleColumns(); // Determine the available width

        var width = this._getAvailableWidth(); // Determine the number of visible columns


        var numColumns = visibleColumns.length; // Did this column become longer than it was?

        if (data.newWidth > data.oldWidth) {
          // Yup.  Don't resize anything else.  The other columns will just get
          // pushed off and require scrollbars be added (if not already there).
          return;
        } // This column became shorter.  See if we no longer take up the full
        // space that's available to us.


        var i;
        var nextCol;
        var widthUsed = 0;

        for (i = 0; i < numColumns; i++) {
          widthUsed += tableColumnModel.getColumnWidth(visibleColumns[i]);
        } // If the used width is less than the available width...


        if (widthUsed < width) {
          // ... then determine the next visible column
          for (i = 0; i < visibleColumns.length; i++) {
            if (visibleColumns[i] == data.col) {
              nextCol = visibleColumns[i + 1];
              break;
            }
          }

          if (nextCol) {
            // Make the next column take up the available space.
            var newWidth = width - (widthUsed - tableColumnModel.getColumnWidth(nextCol));
            tableColumnModel.setColumnWidth(nextCol, newWidth);
          }
        }
      },

      /**
       * If a column was just made invisible, extend the last column to fill any
       * available space within the inner width of the table.  This means that
       * if the sum of the widths of all columns exceeds the inner width of the
       * table, no change is made.  If, on the other hand, the sum of the widths
       * of all columns is less than the inner width of the table, the last
       * column is extended to take up the width available within the inner
       * width of the table.
       *
       *
       * @param event {qx.event.type.Data}
       *   The event object.
       *
       */
      _extendLastColumn: function _extendLastColumn(event) {
        var tableColumnModel = this.getTableColumnModel(); // Event data properties: col, visible

        var data = event.getData(); // If the column just became visible, don't make any width changes

        if (data.visible) {
          return;
        } // Get the array of visible columns


        var visibleColumns = tableColumnModel.getVisibleColumns(); // If no columns are visible...

        if (visibleColumns.length == 0) {
          return;
        } // Determine the available width


        var width = this._getAvailableWidth(tableColumnModel); // Determine the number of visible columns


        var numColumns = visibleColumns.length; // See if we no longer take up the full space that's available to us.

        var i;
        var lastCol;
        var widthUsed = 0;

        for (i = 0; i < numColumns; i++) {
          widthUsed += tableColumnModel.getColumnWidth(visibleColumns[i]);
        } // If the used width is less than the available width...


        if (widthUsed < width) {
          // ... then get the last visible column
          lastCol = visibleColumns[visibleColumns.length - 1]; // Make the last column take up the available space.

          var newWidth = width - (widthUsed - tableColumnModel.getColumnWidth(lastCol));
          tableColumnModel.setColumnWidth(lastCol, newWidth);
        }
      },

      /**
       * Returns an array of the resizing information of a column.
       *
       * @return {qx.ui.core.ColumnData[]} array of the resizing information of a column.
       */
      _getResizeColumnData: function _getResizeColumnData() {
        return this.__resizeColumnData__P_513_0;
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this.__resizeColumnData__P_513_0 = this.__layoutChildren__P_513_3 = null;

      this._disposeObjects("__layout__P_513_1", "__deferredComputeColumnsFlexWidth__P_513_2");
    }
  });
  qx.ui.table.columnmodel.resizebehavior.Default.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.headerrenderer.Default": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
  
  ************************************************************************ */

  /**
   * A header cell renderer which renders an icon (only). The icon cannot be combined
   * with text.
   */
  qx.Class.define("qx.ui.table.headerrenderer.Icon", {
    extend: qx.ui.table.headerrenderer.Default,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param iconUrl {String} URL to the icon to show
     * @param tooltip {String ? ""} Text of the tooltip to show if the pointer hovers over the
     *                             icon
     */
    construct: function construct(iconUrl, tooltip) {
      qx.ui.table.headerrenderer.Default.constructor.call(this);

      if (iconUrl == null) {
        iconUrl = "";
      }

      this.setIconUrl(iconUrl);

      if (tooltip) {
        this.setToolTip(tooltip);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * URL of the icon to show
       */
      iconUrl: {
        check: "String",
        init: ""
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      updateHeaderCell: function updateHeaderCell(cellInfo, cellWidget) {
        qx.ui.table.headerrenderer.Icon.prototype.updateHeaderCell.base.call(this, cellInfo, cellWidget);
        cellWidget.setIcon(this.getIconUrl());
      }
    }
  });
  qx.ui.table.headerrenderer.Icon.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.model.Simple": {
        "construct": true,
        "require": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 by Tartan Solutions, Inc, http://www.tartansolutions.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Dan Hummon
  
  ************************************************************************ */

  /**
   * A filtered table model to provide support for hiding and filtering table
   * rows. Any rows that match any applied filters will be hidden.
  
  <pre class='javascript'>
  var model = new qx.ui.table.model.Filtered();
  model.setColumns(["Login", "Name", "Email"], ["login", "name", "email"]);
  
  var table = new qx.ui.table.Table(model);
  
  var data = [{
    login : "darthvader",
    name : "Darth Vader",
    email : "darthvader@tatooine.org"
  }, {
    login : "anakin",
    name : "Anakin Skywalker",
    email : "anakin@skywalker.org"
  }, {
    login : "luke",
    name : "Luke Skywalker",
    email : "luke@tatooine.org"
  }, {
    login : "obi-wan",
    name : "Obi-Wan Kenobi",
    email : "obiwan@jedi.org"
  }, {
    login : "rey",
    name : "Rey",
    email : "rey@jakku.sw"
  }];
  
  model.setDataAsMapArray(data);
  
  this.getRoot().add(table);
  
  var search = new qx.ui.form.TextField();
  search.set({
    liveUpdate : true,
    placeholder : "Search login"
  });
  
  search.addListener("changeValue", function(e) {
    var value = e.getData();
  
    model.resetHiddenRows();
    model.addNotRegex(value, "login", true);
    model.applyFilters();
  });
  
  this.getRoot().add(search, {top : 500, left : 10});
  </pre>
   *
   * @deprecated {6.0} You should use
   * <a href='http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter' target='_blank'>Array.filter</a>
   * method to filter the table model
   */
  qx.Class.define("qx.ui.table.model.Filtered", {
    extend: qx.ui.table.model.Simple,
    construct: function construct() {
      qx.ui.table.model.Simple.constructor.call(this);
      this.__filterTypes__P_515_0 = {
        "==": "numeric",
        "!=": "numeric",
        ">": "numeric",
        "<": "numeric",
        "<=": "numeric",
        ">=": "numeric",
        "between": "between",
        "!between": "between"
      };
      this.__applyingFilters__P_515_1 = false;
      this.Filters = [];
    },
    members: {
      __fullArr__P_515_2: null,
      __applyingFilters__P_515_1: null,
      __filterTypes__P_515_0: null,

      /**
       * Function to get the full array of the filtered model
       * @return {Array} the full array of model (with no changes)
       */
      getFullArray: function getFullArray() {
        return this.__fullArr__P_515_2;
      },

      /**
       * Whether the given string (needle) is in the array (haystack)
       *
       * @param the_needle {String} String to search
       * @param the_haystack {Array} Array, which should be searched
       * @return {Boolean} whether the search string was found.
       * @deprecated {6.0}
       */
      _js_in_array: function _js_in_array(the_needle, the_haystack) {
        var the_hay = the_haystack.toString();

        if (the_hay == '') {
          return false;
        }

        var the_pattern = new RegExp(the_needle, 'g');
        var matched = the_pattern.test(the_haystack);
        return matched;
      },

      /**
       * The addBetweenFilter method is used to add a between filter to the
       * table model.
       *
       * @param filter {String}
       *    The type of filter. Accepted strings are "between" and "!between".
       *
       * @param value1 {Integer}
       *    The first value to compare against.
       *
       * @param value2 {Integer}
       *    The second value to compare against.
       *
       * @param target {String}
       *    The text value of the column to compare against.
       *
       *
       * @throws {Error} If the filter can not recognized or one of the values
       * is null.
       */
      addBetweenFilter: function addBetweenFilter(filter, value1, value2, target) {
        if (this.__filterTypes__P_515_0[filter] === "between" && target != null) {
          if (value1 != null && value2 != null) {
            var temp = new Array(filter, value1, value2, target);
          }
        }

        if (temp != null) {
          this.Filters.push(temp);
        } else {
          throw new Error("Filter not recognized or value1/value2 is null!");
        }
      },

      /**
       * The addNumericFilter method is used to add a basic numeric filter to
       * the table model.
       *
       * @param filter {String}
       *    The type of filter. Accepted strings are:
       *    "==", "!=", ">", "<", ">=", and "<=".
       *
       * @param value1 {Integer}
       *    The value to compare against.
       *
       * @param target {String}
       *    The text value of the column to compare against.
       *
       *
       * @throws {Error} If the filter can not recognized or the target is null.
       */
      addNumericFilter: function addNumericFilter(filter, value1, target) {
        var temp = null;

        if (this.__filterTypes__P_515_0[filter] === "numeric" && target != null) {
          if (value1 != null) {
            temp = [filter, value1, target];
          }
        }

        if (temp != null) {
          this.Filters.push(temp);
        } else {
          throw new Error("Filter not recognized: value or target is null!");
        }
      },

      /**
       * The addRegex method is used to add a regular expression filter to the
       * table model.
       *
       * @param regex {String}
       *    The regular expression to match against.
       *
       * @param target {String}
       *    The text value of the column to compare against.
       *
       * @param ignorecase {Boolean}
       *    If true, the regular expression will ignore case.
       *
       *
       * @throws {Error} If the regex is not valid.
       */
      addRegex: function addRegex(regex, target, ignorecase) {
        var regexarg;

        if (ignorecase) {
          regexarg = 'gi';
        } else {
          regexarg = 'g';
        }

        if (regex != null && target != null) {
          var temp = new Array("regex", regex, target, regexarg);
        }

        if (temp != null) {
          this.Filters.push(temp);
        } else {
          throw new Error("regex cannot be null!");
        }
      },

      /**
       * The addNotRegex method is used to add a regular expression filter to the
       * table model and filter cells that do not match.
       *
       * @param regex {String}
       *    The regular expression to match against.
       *
       * @param target {String}
       *    The text value of the column to compare against.
       *
       * @param ignorecase {Boolean}
       *    If true, the regular expression will ignore case.
       *
       *
       * @throws {Error} If the regex is null.
       */
      addNotRegex: function addNotRegex(regex, target, ignorecase) {
        var regexarg;

        if (ignorecase) {
          regexarg = 'gi';
        } else {
          regexarg = 'g';
        }

        if (regex != null && target != null) {
          var temp = new Array("notregex", regex, target, regexarg);
        }

        if (temp != null) {
          this.Filters.push(temp);
        } else {
          throw new Error("notregex cannot be null!");
        }
      },

      /**
      * The applyFilters method is called to apply filters to the table model.
      */
      applyFilters: function applyFilters() {
        var i;
        var filter_test;
        var compareValue;
        var rowArr = this.getData();
        var rowLength = rowArr.length;
        var rowsToHide = [];

        for (var row = 0; row < rowLength; row++) {
          filter_test = false;

          for (i in this.Filters) {
            if (this.__filterTypes__P_515_0[this.Filters[i][0]] === "numeric") {
              compareValue = this.getValueById(this.Filters[i][2], row);

              switch (this.Filters[i][0]) {
                case "==":
                  if (compareValue == this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;

                case "!=":
                  if (compareValue != this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;

                case ">":
                  if (compareValue > this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;

                case "<":
                  if (compareValue < this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;

                case ">=":
                  if (compareValue >= this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;

                case "<=":
                  if (compareValue <= this.Filters[i][1]) {
                    filter_test = true;
                  }

                  break;
              }
            } else if (this.__filterTypes__P_515_0[this.Filters[i][0]] === "between") {
              compareValue = this.getValueById(this.Filters[i][3], row);

              switch (this.Filters[i][0]) {
                case "between":
                  if (compareValue >= this.Filters[i][1] && compareValue <= this.Filters[i][2]) {
                    filter_test = true;
                  }

                  break;

                case "!between":
                  if (compareValue < this.Filters[i][1] || compareValue > this.Filters[i][2]) {
                    filter_test = true;
                  }

                  break;
              }
            } else if (this.Filters[i][0] === "regex") {
              compareValue = this.getValueById(this.Filters[i][2], row);
              var the_pattern = new RegExp(this.Filters[i][1], this.Filters[i][3]);
              filter_test = the_pattern.test(compareValue);
            } else if (this.Filters[i][0] === "notregex") {
              compareValue = this.getValueById(this.Filters[i][2], row);
              var the_pattern = new RegExp(this.Filters[i][1], this.Filters[i][3]);
              filter_test = !the_pattern.test(compareValue);
            }

            if (filter_test === true) {
              break;
            }
          } // instead of hiding a single row, push it into the hiding-store for later hiding.


          if (filter_test === true) {
            rowsToHide.push(row);
          }
        }

        if (!this.__applyingFilters__P_515_1) {
          this.__fullArr__P_515_2 = rowArr.slice(0);
          this.__applyingFilters__P_515_1 = true;
        }

        rowArr = rowArr.filter(function (row, index) {
          return !rowsToHide.includes(index);
        });
        this._rowArr = rowArr;
        var data = {
          firstRow: 0,
          lastRow: this._rowArr.length - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1
        }; // Inform the listeners

        this.fireDataEvent("dataChanged", data);
      },

      /**
       * Hides a specified number of rows.
       *
       * @param rowNum {Integer}
       *    Index of the first row to be hidden in the table.
       *
       * @param numOfRows {Integer}
       *    The number of rows to be hidden sequentially after rowNum.
       *
       * @param dispatchEvent {Boolean?true} Whether a model change event should
       *    be fired.
       *
       */
      hideRows: function hideRows(rowNum, numOfRows, dispatchEvent) {
        var rowArr = this.getData();
        dispatchEvent = dispatchEvent != null ? dispatchEvent : true;

        if (!this.__applyingFilters__P_515_1) {
          this.__fullArr__P_515_2 = rowArr.slice(0);
          this.__applyingFilters__P_515_1 = true;
        }

        if (numOfRows == null || numOfRows < 1) {
          numOfRows = 1;
        }

        for (var kludge = rowNum; kludge < rowArr.length - numOfRows; kludge++) {
          rowArr[kludge] = rowArr[kludge + numOfRows];
        }

        this.removeRows(kludge, numOfRows); // Inform the listeners

        if (dispatchEvent) {
          var data = {
            firstRow: 0,
            lastRow: rowArr.length - 1,
            firstColumn: 0,
            lastColumn: this.getColumnCount() - 1
          };
          this.fireDataEvent("dataChanged", data);
        }
      },

      /**
       * Return the table to the original state with all rows shown and clears
       * all filters.
       *
       */
      resetHiddenRows: function resetHiddenRows() {
        if (!this.__fullArr__P_515_2) {
          // nothing to reset
          return;
        }

        this.Filters = [];
        this.setData(qx.lang.Array.clone(this.__fullArr__P_515_2));
      },
      // overridden
      setData: function setData(rowArr, clearSorting) {
        this.__fullArr__P_515_2 = qx.lang.Array.clone(rowArr);
        this.Filters = [];
        qx.ui.table.model.Filtered.prototype.setData.base.call(this, rowArr, clearSorting);
      }
    },
    destruct: function destruct() {
      this.__fullArr__P_515_2 = this.__filterTypes__P_515_0 = this.Filters = null;
    }
  });
  qx.ui.table.model.Filtered.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.model.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */

  /**
   * A table model that loads its data from a backend.
   * <p>
   * Only a subset of the available rows, those which are within or near the
   * currently visible area, are loaded. If a quick scroll operation occurs,
   * rows will soon be displayed using asynchronous loading in the background.
   * All loaded data is managed through a cache which automatically removes
   * the oldest used rows when it gets full.
   * <p>
   * This class is abstract: The actual loading of row data must be done by
   * subclasses.
   */
  qx.Class.define("qx.ui.table.model.Remote", {
    type: "abstract",
    extend: qx.ui.table.model.Abstract,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.model.Abstract.constructor.call(this);
      this._sortColumnIndex = -1;
      this._sortAscending = true;
      this._rowCount = -1;
      this._lruCounter = 0; // Holds the index of the first block that is currently loading.
      // Is -1 if there is currently no request on its way.

      this._firstLoadingBlock = -1; // Holds the index of the first row that should be loaded when the response of
      // the current request arrives. Is -1 we need no following request.

      this._firstRowToLoad = -1; // Counterpart to _firstRowToLoad

      this._lastRowToLoad = -1; // Holds whether the current request will bring obsolete data. When true the
      // response of the current request will be ignored.

      this._ignoreCurrentRequest = false;
      this._rowBlockCache = {};
      this._rowBlockCount = 0;
      this._sortableColArr = null;
      this._editableColArr = null;
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The number of rows that are stored in one cache block. */
      blockSize: {
        check: "Integer",
        init: 50
      },

      /** The maximum number of row blocks kept in the cache. */
      maxCachedBlockCount: {
        check: "Integer",
        init: 15
      },

      /**
       * Whether to clear the cache when some rows are removed.
       * If true the rows are removed locally in the cache.
       */
      clearCacheOnRemove: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether to block remote requests for the row count while a request for
       * the row count is pending. Row counts are requested at various times and
       * from various parts of the code, resulting in numerous requests to the
       * user-provided _loadRowCount() method, often while other requests are
       * already pending. The default behavior now ignores requests to load a
       * new row count if such a request is already pending. It is therefore now
       * conceivable that the row count changes between an initial request for
       * the row count and a later (ignored) request. Since the chance of this
       * is low, the desirability of reducing the server requests outweighs the
       * slight possibility of an altered count (which will, by the way, be
       * detected soon thereafter upon the next request for the row count). If
       * the old behavior is desired, set this property to false.
       */
      blockConcurrentLoadRowCount: {
        check: "Boolean",
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      _rowCount: null,
      _ignoreCurrentRequest: null,
      _lruCounter: null,
      _firstLoadingBlock: null,
      _firstRowToLoad: null,
      _lastRowToLoad: null,
      _rowBlockCache: null,
      _rowBlockCount: null,
      _sortColumnIndex: null,
      _sortAscending: null,
      _editableColArr: null,
      _sortableColArr: null,
      _loadRowCountRequestRunning: false,
      _clearCache: false,

      /**
       * Returns whether the current request is ignored by the model.
       *
       * @return {Boolean} true when the current request is ignored by the model.
       */
      _getIgnoreCurrentRequest: function _getIgnoreCurrentRequest() {
        return this._ignoreCurrentRequest;
      },
      // overridden
      getRowCount: function getRowCount() {
        if (this._rowCount == -1) {
          if (!this._loadRowCountRequestRunning || !this.getBlockConcurrentLoadRowCount()) {
            this._loadRowCountRequestRunning = true;

            this._loadRowCount();
          } // NOTE: _loadRowCount may set this._rowCount


          return this._rowCount == -1 ? 0 : this._rowCount;
        } else {
          return this._rowCount;
        }
      },

      /**
       * Implementing classes have to call {@link #_onRowCountLoaded} when the
       * server response arrived. That method has to be called! Even when there
       * was an error.
       *
       * @abstract
       * @throws {Error} the abstract function warning.
       */
      _loadRowCount: function _loadRowCount() {
        throw new Error("_loadRowCount is abstract");
      },

      /**
       * Sets the row count.
       *
       * Has to be called by {@link #_loadRowCount}.
       *
       * @param rowCount {Integer} the number of rows in this model or null if loading.
       */
      _onRowCountLoaded: function _onRowCountLoaded(rowCount) {
        if (this.getBlockConcurrentLoadRowCount()) {
          // There's no longer a loadRowCount() in progress
          this._loadRowCountRequestRunning = false;
        } // this.debug("row count loaded: " + rowCount);


        if (rowCount == null || rowCount < 0) {
          rowCount = 0;
        }

        this._rowCount = Number(rowCount); // Inform the listeners

        var data = {
          firstRow: 0,
          lastRow: rowCount - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1
        };
        this.fireDataEvent("dataChanged", data);
      },

      /**
       * Reloads the model and clears the local cache.
       *
       */
      reloadData: function reloadData() {
        // If there is currently a request on its way, then this request will bring
        // obsolete data -> Ignore it
        if (this._firstLoadingBlock != -1) {
          var cancelingSucceed = this._cancelCurrentRequest();

          if (cancelingSucceed) {
            // The request was canceled -> We're not loading any blocks any more
            this._firstLoadingBlock = -1;
            this._ignoreCurrentRequest = false;
          } else {
            // The request was not canceled -> Ignore it
            this._ignoreCurrentRequest = true;
          }
        } // Force clearing row cache, because of reloading data.


        this._clearCache = true; // Forget a possibly outstanding request
        // (_loadRowCount will tell the listeners anyway, that the whole table
        // changed)
        //
        // NOTE: This will inform the listeners as soon as the new row count is
        // known

        this._firstRowToLoad = -1;
        this._lastRowToLoad = -1;
        this._loadRowCountRequestRunning = true;

        this._loadRowCount();
      },

      /**
       * Clears the cache.
       *
       */
      clearCache: function clearCache() {
        this._rowBlockCache = {};
        this._rowBlockCount = 0;
      },

      /**
       * Returns the current state of the cache.
       * <p>
       * Do not change anything in the returned data. This breaks the model state.
       * Use this method only together with {@link #restoreCacheContent} for backing
       * up state for a later restore.
       *
       * @return {Map} the current cache state.
       */
      getCacheContent: function getCacheContent() {
        return {
          sortColumnIndex: this._sortColumnIndex,
          sortAscending: this._sortAscending,
          rowCount: this._rowCount,
          lruCounter: this._lruCounter,
          rowBlockCache: this._rowBlockCache,
          rowBlockCount: this._rowBlockCount
        };
      },

      /**
       * Restores a cache state created by {@link #getCacheContent}.
       *
       * @param cacheContent {Map} An old cache state.
       */
      restoreCacheContent: function restoreCacheContent(cacheContent) {
        // If there is currently a request on its way, then this request will bring
        // obsolete data -> Ignore it
        if (this._firstLoadingBlock != -1) {
          // Try to cancel the current request
          var cancelingSucceed = this._cancelCurrentRequest();

          if (cancelingSucceed) {
            // The request was canceled -> We're not loading any blocks any more
            this._firstLoadingBlock = -1;
            this._ignoreCurrentRequest = false;
          } else {
            // The request was not canceled -> Ignore it
            this._ignoreCurrentRequest = true;
          }
        } // Restore the cache content


        this._sortColumnIndex = cacheContent.sortColumnIndex;
        this._sortAscending = cacheContent.sortAscending;
        this._rowCount = cacheContent.rowCount;
        this._lruCounter = cacheContent.lruCounter;
        this._rowBlockCache = cacheContent.rowBlockCache;
        this._rowBlockCount = cacheContent.rowBlockCount; // Inform the listeners

        var data = {
          firstRow: 0,
          lastRow: this._rowCount - 1,
          firstColumn: 0,
          lastColumn: this.getColumnCount() - 1
        };
        this.fireDataEvent("dataChanged", data);
      },

      /**
       * Cancels the current request if possible.
       *
       * Should be overridden by subclasses if they are able to cancel requests. This
       * allows sending a new request directly after a call of {@link #reloadData}.
       *
       * @return {Boolean} whether the request was canceled.
       */
      _cancelCurrentRequest: function _cancelCurrentRequest() {
        return false;
      },

      /**
       * Iterates through all cached rows.
       *
       * The iterator will be called for each cached row with two parameters: The row
       * index of the current row (Integer) and the row data of that row (var[]). If
       * the iterator returns something this will be used as new row data.
       *
       * The iterator is called in the same order as the rows are in the model
       * (the row index is always ascending).
       *
       * @param iterator {Function} The iterator function to call.
       * @param object {Object} context of the iterator
       */
      iterateCachedRows: function iterateCachedRows(iterator, object) {
        var blockSize = this.getBlockSize();
        var blockCount = Math.ceil(this.getRowCount() / blockSize); // Remove the row and move the rows of all following blocks

        for (var block = 0; block <= blockCount; block++) {
          var blockData = this._rowBlockCache[block];

          if (blockData != null) {
            var rowOffset = block * blockSize;
            var rowDataArr = blockData.rowDataArr;

            for (var relRow = 0; relRow < rowDataArr.length; relRow++) {
              // Call the iterator for this row
              var rowData = rowDataArr[relRow];
              var newRowData = iterator.call(object, rowOffset + relRow, rowData);

              if (newRowData != null) {
                rowDataArr[relRow] = newRowData;
              }
            }
          }
        }
      },
      // overridden
      prefetchRows: function prefetchRows(firstRowIndex, lastRowIndex) {
        // this.debug("Prefetch wanted: " + firstRowIndex + ".." + lastRowIndex);
        if (this._firstLoadingBlock == -1) {
          var blockSize = this.getBlockSize();
          var totalBlockCount = Math.ceil(this._rowCount / blockSize); // There is currently no request running -> Start a new one
          // NOTE: We load one more block above and below to have a smooth
          //       scrolling into the next block without blank cells

          var firstBlock = parseInt(firstRowIndex / blockSize, 10) - 1;

          if (firstBlock < 0) {
            firstBlock = 0;
          }

          var lastBlock = parseInt(lastRowIndex / blockSize, 10) + 1;

          if (lastBlock >= totalBlockCount) {
            lastBlock = totalBlockCount - 1;
          } // Check which blocks we have to load


          var firstBlockToLoad = -1;
          var lastBlockToLoad = -1;

          for (var block = firstBlock; block <= lastBlock; block++) {
            if (this._clearCache && !this._loadRowCountRequestRunning || this._rowBlockCache[block] == null || this._rowBlockCache[block].isDirty) {
              // We don't have this block
              if (firstBlockToLoad == -1) {
                firstBlockToLoad = block;
              }

              lastBlockToLoad = block;
            }
          } // Load the blocks


          if (firstBlockToLoad != -1) {
            this._firstRowToLoad = -1;
            this._lastRowToLoad = -1;
            this._firstLoadingBlock = firstBlockToLoad; // this.debug("Starting server request. rows: " + firstRowIndex + ".." + lastRowIndex + ", blocks: " + firstBlockToLoad + ".." + lastBlockToLoad);

            this._loadRowData(firstBlockToLoad * blockSize, (lastBlockToLoad + 1) * blockSize - 1);
          }
        } else {
          // There is already a request running -> Remember this request
          // so it can be executed after the current one is finished.
          this._firstRowToLoad = firstRowIndex;
          this._lastRowToLoad = lastRowIndex;
        }
      },

      /**
       * Loads some row data from the server.
       *
       * Implementing classes have to call {@link #_onRowDataLoaded} when the server
       * response arrived. That method has to be called! Even when there was an error.
       *
       * @abstract
       * @param firstRow {Integer} The index of the first row to load.
       * @param lastRow {Integer} The index of the last row to load.
       * @throws {Error} the abstract function warning.
       */
      _loadRowData: function _loadRowData(firstRow, lastRow) {
        throw new Error("_loadRowData is abstract");
      },

      /**
       * Sets row data.
       *
       * Has to be called by {@link #_loadRowData}.
       *
       * @param rowDataArr {Map[]} the loaded row data or null if there was an error.
       */
      _onRowDataLoaded: function _onRowDataLoaded(rowDataArr) {
        // Clear cache if function was called because of a reload.
        if (this._clearCache) {
          this.clearCache();
          this._clearCache = false;
        }

        if (rowDataArr != null && !this._ignoreCurrentRequest) {
          var blockSize = this.getBlockSize();
          var blockCount = Math.ceil(rowDataArr.length / blockSize);

          if (blockCount == 1) {
            // We got one block -> Use the rowData directly
            this._setRowBlockData(this._firstLoadingBlock, rowDataArr);
          } else {
            // We got more than one block -> We've to split the rowData
            for (var i = 0; i < blockCount; i++) {
              var rowOffset = i * blockSize;
              var blockRowData = [];
              var mailCount = Math.min(blockSize, rowDataArr.length - rowOffset);

              for (var row = 0; row < mailCount; row++) {
                blockRowData.push(rowDataArr[rowOffset + row]);
              }

              this._setRowBlockData(this._firstLoadingBlock + i, blockRowData);
            }
          } // this.debug("Got server answer. blocks: " + this._firstLoadingBlock + ".." + (this._firstLoadingBlock + blockCount - 1) + ". mail count: " + rowDataArr.length + " block count:" + blockCount);
          // Inform the listeners


          var data = {
            firstRow: this._firstLoadingBlock * blockSize,
            lastRow: (this._firstLoadingBlock + blockCount + 1) * blockSize - 1,
            firstColumn: 0,
            lastColumn: this.getColumnCount() - 1
          };
          this.fireDataEvent("dataChanged", data);
        } // We're not loading any blocks any more


        this._firstLoadingBlock = -1;
        this._ignoreCurrentRequest = false; // Check whether we have to start a new request

        if (this._firstRowToLoad != -1) {
          this.prefetchRows(this._firstRowToLoad, this._lastRowToLoad);
        }
      },

      /**
       * Sets the data of one block.
       *
       * @param block {Integer} the index of the block.
       * @param rowDataArr {var[][]} the data to set.
       */
      _setRowBlockData: function _setRowBlockData(block, rowDataArr) {
        if (this._rowBlockCache[block] == null) {
          // This is a new block -> Check whether we have to remove another block first
          this._rowBlockCount++;

          while (this._rowBlockCount > this.getMaxCachedBlockCount()) {
            // Find the last recently used block
            // NOTE: We never remove block 0 and 1
            var lruBlock;
            var minLru = this._lruCounter;

            for (var currBlock in this._rowBlockCache) {
              var currLru = this._rowBlockCache[currBlock].lru;

              if (currLru < minLru && currBlock > 1) {
                minLru = currLru;
                lruBlock = currBlock;
              }
            } // Remove that block
            // this.debug("Removing block: " + lruBlock + ". current LRU: " + this._lruCounter);


            delete this._rowBlockCache[lruBlock];
            this._rowBlockCount--;
          }
        }

        this._rowBlockCache[block] = {
          lru: ++this._lruCounter,
          rowDataArr: rowDataArr
        };
      },

      /**
       * Removes a row from the model.
       *
       * @param rowIndex {Integer} the index of the row to remove.
       */
      removeRow: function removeRow(rowIndex) {
        if (this.getClearCacheOnRemove()) {
          this.clearCache(); // Inform the listeners

          var data = {
            firstRow: 0,
            lastRow: this.getRowCount() - 1,
            firstColumn: 0,
            lastColumn: this.getColumnCount() - 1
          };
          this.fireDataEvent("dataChanged", data);
        } else {
          var blockSize = this.getBlockSize();
          var blockCount = Math.ceil(this.getRowCount() / blockSize);
          var startBlock = parseInt(rowIndex / blockSize, 10); // Remove the row and move the rows of all following blocks

          for (var block = startBlock; block <= blockCount; block++) {
            var blockData = this._rowBlockCache[block];

            if (blockData != null) {
              // Remove the row in the start block
              // NOTE: In the other blocks the first row is removed
              //       (This is the row that was)
              var removeIndex = 0;

              if (block == startBlock) {
                removeIndex = rowIndex - block * blockSize;
              }

              blockData.rowDataArr.splice(removeIndex, 1);

              if (block == blockCount - 1) {
                // This is the last block
                if (blockData.rowDataArr.length == 0) {
                  // It is empty now -> Remove it
                  delete this._rowBlockCache[block];
                }
              } else {
                // Try to copy the first row of the next block to the end of this block
                // so this block can stays clean
                var nextBlockData = this._rowBlockCache[block + 1];

                if (nextBlockData != null) {
                  blockData.rowDataArr.push(nextBlockData.rowDataArr[0]);
                } else {
                  // There is no row to move -> Mark this block as dirty
                  blockData.isDirty = true;
                }
              }
            }
          }

          if (this._rowCount != -1) {
            this._rowCount--;
          } // Inform the listeners


          if (this.hasListener("dataChanged")) {
            var data = {
              firstRow: rowIndex,
              lastRow: this.getRowCount() - 1,
              firstColumn: 0,
              lastColumn: this.getColumnCount() - 1
            };
            this.fireDataEvent("dataChanged", data);
          }
        }
      },

      /**
       *
       * See overridden method for details.
       *
       * @param rowIndex {Integer} the model index of the row.
       * @return {Object} Map containing a value for each column.
       */
      getRowData: function getRowData(rowIndex) {
        var blockSize = this.getBlockSize();
        var block = parseInt(rowIndex / blockSize, 10);
        var blockData = this._rowBlockCache[block];

        if (blockData == null) {
          // This block is not (yet) loaded
          return null;
        } else {
          var rowData = blockData.rowDataArr[rowIndex - block * blockSize]; // Update the last recently used counter

          if (blockData.lru != this._lruCounter) {
            blockData.lru = ++this._lruCounter;
          }

          return rowData;
        }
      },
      // overridden
      getValue: function getValue(columnIndex, rowIndex) {
        var rowData = this.getRowData(rowIndex);

        if (rowData == null) {
          return null;
        } else {
          var columnId = this.getColumnId(columnIndex);
          return rowData[columnId];
        }
      },
      // overridden
      setValue: function setValue(columnIndex, rowIndex, value) {
        var rowData = this.getRowData(rowIndex);

        if (rowData == null) {
          // row has not yet been loaded or does not exist
          return;
        } else {
          var columnId = this.getColumnId(columnIndex);
          rowData[columnId] = value; // Inform the listeners

          if (this.hasListener("dataChanged")) {
            var data = {
              firstRow: rowIndex,
              lastRow: rowIndex,
              firstColumn: columnIndex,
              lastColumn: columnIndex
            };
            this.fireDataEvent("dataChanged", data);
          }
        }
      },

      /**
       * Sets all columns editable or not editable.
       *
       * @param editable {Boolean} whether all columns are editable.
       */
      setEditable: function setEditable(editable) {
        this._editableColArr = [];

        for (var col = 0; col < this.getColumnCount(); col++) {
          this._editableColArr[col] = editable;
        }

        this.fireEvent("metaDataChanged");
      },

      /**
       * Sets whether a column is editable.
       *
       * @param columnIndex {Integer} the column of which to set the editable state.
       * @param editable {Boolean} whether the column should be editable.
       */
      setColumnEditable: function setColumnEditable(columnIndex, editable) {
        if (editable != this.isColumnEditable(columnIndex)) {
          if (this._editableColArr == null) {
            this._editableColArr = [];
          }

          this._editableColArr[columnIndex] = editable;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      isColumnEditable: function isColumnEditable(columnIndex) {
        return this._editableColArr ? this._editableColArr[columnIndex] == true : false;
      },

      /**
        * Sets whether a column is sortable.
        *
        * @param columnIndex {Integer} the column of which to set the sortable state.
        * @param sortable {Boolean} whether the column should be sortable.
        */
      setColumnSortable: function setColumnSortable(columnIndex, sortable) {
        if (sortable != this.isColumnSortable(columnIndex)) {
          if (this._sortableColArr == null) {
            this._sortableColArr = [];
          }

          this._sortableColArr[columnIndex] = sortable;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      isColumnSortable: function isColumnSortable(columnIndex) {
        return this._sortableColArr ? this._sortableColArr[columnIndex] !== false : true;
      },
      // overridden
      sortByColumn: function sortByColumn(columnIndex, ascending) {
        if (this._sortColumnIndex != columnIndex || this._sortAscending != ascending) {
          this._sortColumnIndex = columnIndex;
          this._sortAscending = ascending;
          this.clearCache(); // Inform the listeners

          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      getSortColumnIndex: function getSortColumnIndex() {
        return this._sortColumnIndex;
      },
      // overridden
      isSortAscending: function isSortAscending() {
        return this._sortAscending;
      },

      /**
       * Sets the sorted column without sorting the data.
       * Use this method, if you want to mark the column as the sorted column,
       * (e.g. for appearance reason), but the sorting of the data will be done
       * in another step.
       *
       * @param sortColumnIndex {Integer} the column, which shall be marked as the sorted column.
       */
      setSortColumnIndexWithoutSortingData: function setSortColumnIndexWithoutSortingData(sortColumnIndex) {
        this._sortColumnIndex = sortColumnIndex;
      },

      /**
       * Sets the direction of the sorting without sorting the data.
       * Use this method, if you want to set the direction of sorting, (e.g
       * for appearance reason), but the sorting of the data will be done in
       * another step.
       *
       * @param sortAscending {Boolean} whether the sorting direction is ascending
       *        (true) or not (false).
       */
      setSortAscendingWithoutSortingData: function setSortAscendingWithoutSortingData(sortAscending) {
        this._sortAscending = sortAscending;
      }
    },
    destruct: function destruct() {
      this._sortableColArr = this._editableColArr = this._rowBlockCache = null;
    }
  });
  qx.ui.table.model.Remote.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true,
        "require": true
      },
      "qx.ui.tabview.TabButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A page is the way to add content to a {@link TabView}. Each page gets a
   * button to switch to the page. Only one page is visible at a time.
   *
   * @childControl button {qx.ui.tabview.TabButton} tab button connected to the page
   */
  qx.Class.define("qx.ui.tabview.Page", {
    extend: qx.ui.container.Composite,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param label {String} Initial label of the tab
     * @param icon {String} Initial icon of the tab
     */
    construct: function construct(label, icon) {
      qx.ui.container.Composite.constructor.call(this);

      this._createChildControl("button"); // init


      if (label != null) {
        this.setLabel(label);
      }

      if (icon != null) {
        this.setIcon(icon);
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired by {@link qx.ui.tabview.TabButton} if the close button is tapped.
       */
      "close": "qx.event.type.Event"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "tabview-page"
      },

      /** The label/caption/text of the Page's button. */
      label: {
        check: "String",
        init: "",
        apply: "_applyLabel"
      },

      /** Any URI String supported by qx.ui.basic.Image to display an icon in Page's button. */
      icon: {
        check: "String",
        init: "",
        apply: "_applyIcon",
        nullable: true
      },

      /** Indicates if the close button of a TabButton should be shown. */
      showCloseButton: {
        check: "Boolean",
        init: false,
        apply: "_applyShowCloseButton"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        barTop: 1,
        barRight: 1,
        barBottom: 1,
        barLeft: 1,
        firstTab: 1,
        lastTab: 1
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyIcon: function _applyIcon(value, old) {
        var btn = this.getChildControl("button");

        if (value) {
          btn.setIcon(value);

          btn._showChildControl("icon");
        } else {
          btn._excludeChildControl("icon");
        }
      },
      // property apply
      _applyLabel: function _applyLabel(value, old) {
        this.getChildControl("button").setLabel(value);
      },
      // overridden
      _applyEnabled: function _applyEnabled(value, old) {
        qx.ui.tabview.Page.prototype._applyEnabled.base.call(this, value, old); // delegate to non-child widget button
        // since enabled is inheritable value may be null


        var btn = this.getChildControl("button");
        value == null ? btn.resetEnabled() : btn.setEnabled(value);
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "button":
            control = new qx.ui.tabview.TabButton();
            control.setAllowGrowX(true);
            control.setAllowGrowY(true);
            control.setUserData("page", this);
            control.addListener("close", this._onButtonClose, this);
            break;
        }

        return control || qx.ui.tabview.Page.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyShowCloseButton: function _applyShowCloseButton(value, old) {
        this.getChildControl("button").setShowCloseButton(value);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Fires an "close" event when the close button of the TabButton of the page
       * is tapped.
       */
      _onButtonClose: function _onButtonClose() {
        this.fireEvent("close");
      },

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the button used within this page. This method is used by
       * the TabView to access the button.
       *
       * @internal
       * @return {qx.ui.form.RadioButton} The button associated with this page.
       */
      getButton: function getButton() {
        return this.getChildControl("button");
      }
    }
  });
  qx.ui.tabview.Page.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.RadioButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      },
      "qx.ui.layout.Grid": {
        "construct": true
      },
      "qx.ui.basic.Label": {},
      "qx.ui.basic.Image": {},
      "qx.ui.form.Button": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A TabButton is the tapable part sitting on the {@link qx.ui.tabview.Page}.
   * By tapping on the TabButton the user can set a Page active.
   *
   * @childControl label {qx.ui.basic.Label} label of the tab button
   * @childControl icon {qx.ui.basic.Image} icon of the tab button
   * @childControl close-button {qx.ui.form.Button} close button of the tab button
   */
  qx.Class.define("qx.ui.tabview.TabButton", {
    extend: qx.ui.form.RadioButton,
    implement: qx.ui.form.IRadioItem,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.form.RadioButton.constructor.call(this);
      var layout = new qx.ui.layout.Grid(2, 0);
      layout.setRowAlign(0, "left", "middle");
      layout.setColumnAlign(0, "right", "middle");

      this._getLayout().dispose();

      this._setLayout(layout);

      this.initShowCloseButton();
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired by {@link qx.ui.tabview.Page} if the close button is tapped.
       *
       * Event data: The tab button.
       */
      "close": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Indicates if the close button of a TabButton should be shown. */
      showCloseButton: {
        check: "Boolean",
        init: false,
        apply: "_applyShowCloseButton"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        focused: true,
        checked: true
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      _applyIconPosition: function _applyIconPosition(value, old) {
        var children = {
          icon: this.getChildControl("icon"),
          label: this.getChildControl("label"),
          closeButton: this.getShowCloseButton() ? this.getChildControl("close-button") : null
        }; // Remove all children before adding them again

        for (var child in children) {
          if (children[child]) {
            this._remove(children[child]);
          }
        }

        switch (value) {
          case "top":
            this._add(children.label, {
              row: 3,
              column: 2
            });

            this._add(children.icon, {
              row: 1,
              column: 2
            });

            if (children.closeButton) {
              this._add(children.closeButton, {
                row: 0,
                column: 4
              });
            }

            break;

          case "bottom":
            this._add(children.label, {
              row: 1,
              column: 2
            });

            this._add(children.icon, {
              row: 3,
              column: 2
            });

            if (children.closeButton) {
              this._add(children.closeButton, {
                row: 0,
                column: 4
              });
            }

            break;

          case "left":
            this._add(children.label, {
              row: 0,
              column: 2
            });

            this._add(children.icon, {
              row: 0,
              column: 0
            });

            if (children.closeButton) {
              this._add(children.closeButton, {
                row: 0,
                column: 4
              });
            }

            break;

          case "right":
            this._add(children.label, {
              row: 0,
              column: 0
            });

            this._add(children.icon, {
              row: 0,
              column: 2
            });

            if (children.closeButton) {
              this._add(children.closeButton, {
                row: 0,
                column: 4
              });
            }

            break;
        }
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "label":
            var control = new qx.ui.basic.Label(this.getLabel());
            control.setAnonymous(true);

            this._add(control, {
              row: 0,
              column: 2
            });

            this._getLayout().setColumnFlex(2, 1);

            break;

          case "icon":
            control = new qx.ui.basic.Image(this.getIcon());
            control.setAnonymous(true);

            this._add(control, {
              row: 0,
              column: 0
            });

            break;

          case "close-button":
            control = new qx.ui.form.Button();
            control.setFocusable(false);
            control.setKeepActive(true);
            control.addListener("tap", this._onCloseButtonTap, this);

            this._add(control, {
              row: 0,
              column: 4
            });

            if (!this.getShowCloseButton()) {
              control.exclude();
            }

            break;
        }

        return control || qx.ui.tabview.TabButton.prototype._createChildControlImpl.base.call(this, id);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Fires a "close" event when the close button is tapped.
       */
      _onCloseButtonTap: function _onCloseButtonTap() {
        this.fireDataEvent("close", this);
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyShowCloseButton: function _applyShowCloseButton(value, old) {
        if (value) {
          this._showChildControl("close-button");
        } else {
          this._excludeChildControl("close-button");
        }
      },
      // property apply
      _applyCenter: function _applyCenter(value) {
        var layout = this._getLayout();

        if (value) {
          layout.setColumnAlign(2, "center", "middle");
        } else {
          layout.setColumnAlign(2, "left", "middle");
        }
      }
    }
  });
  qx.ui.tabview.TabButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.Widget": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.ISingleSelection": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.ui.tabview.Page": {},
      "qx.ui.container.SlideBar": {},
      "qx.ui.container.Stack": {},
      "qx.ui.form.RadioGroup": {},
      "qx.ui.layout.HBox": {},
      "qx.ui.layout.VBox": {},
      "qx.event.type.Event": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Jonathan Weiß (jonathan_rass)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * A tab view is a multi page view where only one page is visible
   * at each moment. It is possible to switch the pages using the
   * buttons rendered by each page.
   * 
   * Note that prior to v6.0, when changing the currently selected tab via code
   * (ie changing the selection property) TabView would automatically set the 
   * focus to that tab; this is undesirable (and inconsistent with other parts
   * of the framework) and is no longer done automatically.
   *
   * @childControl bar {qx.ui.container.SlideBar} slidebar for all tab buttons
   * @childControl pane {qx.ui.container.Stack} stack container to show one tab page
   */
  qx.Class.define("qx.ui.tabview.TabView", {
    extend: qx.ui.core.Widget,
    implement: qx.ui.core.ISingleSelection,
    include: [qx.ui.core.MContentPadding],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param barPosition {String} Initial bar position ({@link #barPosition})
     */
    construct: function construct(barPosition) {
      qx.ui.core.Widget.constructor.call(this);
      this.__barPositionToState__P_524_0 = {
        top: "barTop",
        right: "barRight",
        bottom: "barBottom",
        left: "barLeft"
      };

      this._createChildControl("bar");

      this._createChildControl("pane"); // Create manager


      var mgr = this.__radioGroup__P_524_1 = this._createRadioGroupInstance();

      mgr.setWrap(false);
      mgr.addListener("changeSelection", this._onChangeSelection, this); // Initialize bar position

      if (barPosition != null) {
        this.setBarPosition(barPosition);
      } else {
        this.initBarPosition();
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /** Fires after the selection was modified */
      "changeSelection": "qx.event.type.Data",

      /** Fires after the value was modified */
      "changeValue": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "tabview"
      },

      /**
       * This property defines on which side of the TabView the bar should be positioned.
       */
      barPosition: {
        check: ["left", "right", "top", "bottom"],
        init: "top",
        apply: "_applyBarPosition"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {qx.ui.form.RadioGroup} instance containing the radio group */
      __radioGroup__P_524_1: null,

      /**
       * setValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @param item {null|qx.ui.tabview.Page} Page to set as selected value.
       * @returns {null|TypeError} The status of this operation.
       */
      setValue: function setValue(item) {
        if (null === item) {
          this.resetSelection();
          return null;
        }

        if (item instanceof qx.ui.tabview.Page) {
          this.setSelection([item]);
          return null;
        } else {
          return new TypeError("Given argument is not null or a {qx.ui.tabview.Page}.");
        }
      },

      /**
       * getValue implements part of the {@link qx.ui.form.IField} interface.
       *
       * @returns {null|qx.ui.tabview.Page} The currently selected page or null if there is none.
       */
      getValue: function getValue() {
        var pages = this.getSelection();

        if (pages.length) {
          return pages[0];
        } else {
          return null;
        }
      },

      /**
       * resetValue implements part of the {@link qx.ui.form.IField} interface.
       */
      resetValue: function resetValue() {
        this.resetSelection();
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "bar":
            control = new qx.ui.container.SlideBar();
            control.setZIndex(10);

            this._add(control);

            break;

          case "pane":
            control = new qx.ui.container.Stack();
            control.setZIndex(5);

            this._add(control, {
              flex: 1
            });

            break;
        }

        return control || qx.ui.tabview.TabView.prototype._createChildControlImpl.base.call(this, id);
      },

      /**
       * Creates the radio group manager instance.
       * 
       * Allows override customizations of the instance 
       * 
       * @return {qx.ui.form.RadioGroup} 
       */
      _createRadioGroupInstance: function _createRadioGroupInstance() {
        return new qx.ui.form.RadioGroup();
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getChildControl("pane");
      },

      /*
      ---------------------------------------------------------------------------
        CHILDREN HANDLING
      ---------------------------------------------------------------------------
      */

      /**
       * Adds a page to the tabview including its needed button
       * (contained in the page).
       *
       * @param page {qx.ui.tabview.Page} The page which should be added.
       */
      add: function add(page) {
        {
          if (!(page instanceof qx.ui.tabview.Page)) {
            throw new Error("Incompatible child for TabView: " + page);
          }
        }
        var button = page.getButton();
        var bar = this.getChildControl("bar");
        var pane = this.getChildControl("pane"); // Exclude page

        page.exclude(); // Add button and page

        bar.add(button);
        pane.add(page); // Register button

        this.__radioGroup__P_524_1.add(button); // Add state to page


        page.addState(this.__barPositionToState__P_524_0[this.getBarPosition()]); // Update states

        page.addState("lastTab");
        var children = this.getChildren();

        if (children[0] == page) {
          page.addState("firstTab");
        } else {
          children[children.length - 2].removeState("lastTab");
        }

        page.addListener("close", this._onPageClose, this);
      },

      /**
       * Adds a page to the tabview including its needed button
       * (contained in the page).
       *
       * @param page {qx.ui.tabview.Page} The page which should be added.
       * @param index {Integer?null} Optional position where to add the page.
       */
      addAt: function addAt(page, index) {
        {
          if (!(page instanceof qx.ui.tabview.Page)) {
            throw new Error("Incompatible child for TabView: " + page);
          }
        }
        var children = this.getChildren();

        if (!(index == null) && index > children.length) {
          throw new Error("Index should be less than : " + children.length);
        }

        if (index == null) {
          index = children.length;
        }

        var button = page.getButton();
        var bar = this.getChildControl("bar");
        var pane = this.getChildControl("pane"); // Exclude page

        page.exclude(); // Add button and page

        bar.addAt(button, index);
        pane.addAt(page, index); // Register button

        this.__radioGroup__P_524_1.add(button); // Add state to page


        page.addState(this.__barPositionToState__P_524_0[this.getBarPosition()]); // Update states

        children = this.getChildren();

        if (index == children.length - 1) {
          page.addState("lastTab");
        }

        if (children[0] == page) {
          page.addState("firstTab");
        } else {
          children[children.length - 2].removeState("lastTab");
        }

        page.addListener("close", this._onPageClose, this);
      },

      /**
       * Removes a page (and its corresponding button) from the TabView.
       *
       * @param page {qx.ui.tabview.Page} The page to be removed.
       */
      remove: function remove(page) {
        var pane = this.getChildControl("pane");
        var bar = this.getChildControl("bar");
        var button = page.getButton();
        var children = pane.getChildren(); // Try to select next page

        if (this.getSelection()[0] == page) {
          var index = children.indexOf(page);

          if (index == 0) {
            if (children[1]) {
              this.setSelection([children[1]]);
            } else {
              this.resetSelection();
            }
          } else {
            this.setSelection([children[index - 1]]);
          }
        } // Remove the button and page


        bar.remove(button);
        pane.remove(page); // Remove the button from the radio group

        this.__radioGroup__P_524_1.remove(button); // Remove state from page


        page.removeState(this.__barPositionToState__P_524_0[this.getBarPosition()]); // Update states

        if (page.hasState("firstTab")) {
          page.removeState("firstTab");

          if (children[0]) {
            children[0].addState("firstTab");
          }
        }

        if (page.hasState("lastTab")) {
          page.removeState("lastTab");

          if (children.length > 0) {
            children[children.length - 1].addState("lastTab");
          }
        }

        page.removeListener("close", this._onPageClose, this);
      },

      /**
       * Returns TabView's children widgets.
       *
       * @return {qx.ui.tabview.Page[]} List of children.
       */
      getChildren: function getChildren() {
        return this.getChildControl("pane").getChildren();
      },

      /**
       * Returns the position of the given page in the TabView.
       *
       * @param page {qx.ui.tabview.Page} The page to query for.
       * @return {Integer} Position of the page in the TabView.
       */
      indexOf: function indexOf(page) {
        return this.getChildControl("pane").indexOf(page);
      },

      /**
       * Returns the radio group manager.
       *
       * @return {qx.ui.form.RadioGroup} the radio group.
       */
      getRadioGroup: function getRadioGroup() {
        return this.__radioGroup__P_524_1;
      },

      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */

      /** @type {Map} Maps the bar position to an appearance state */
      __barPositionToState__P_524_0: null,

      /**
       * Apply method for the placeBarOnTop-Property.
       *
       * Passes the desired value to the layout of the tabview so
       * that the layout can handle it.
       * It also sets the states to all buttons so they know the
       * position of the bar.
       *
       * @param value {Boolean} The new value.
       * @param old {Boolean} The old value.
       */
      _applyBarPosition: function _applyBarPosition(value, old) {
        var bar = this.getChildControl("bar");
        var pane = this.getChildControl("pane");
        var horizontal = value == "left" || value == "right";
        var reversed = value == "right" || value == "bottom";
        var layoutClass = horizontal ? qx.ui.layout.HBox : qx.ui.layout.VBox;

        var layout = this._getLayout();

        if (layout && layout instanceof layoutClass) {// pass
        } else {
          this._setLayout(layout = new layoutClass());
        } // Update reversed


        layout.setReversed(reversed); // Sync orientation to bar

        bar.setOrientation(horizontal ? "vertical" : "horizontal"); // Read children

        var children = this.getChildren();
        var i, l; // Toggle state to bar

        if (old) {
          var oldState = this.__barPositionToState__P_524_0[old]; // Update bar

          bar.removeState(oldState); // Update pane

          pane.removeState(oldState); // Update pages

          for (i = 0, l = children.length; i < l; i++) {
            children[i].removeState(oldState);
          }
        }

        if (value) {
          var newState = this.__barPositionToState__P_524_0[value]; // Update bar

          bar.addState(newState); // Update pane

          pane.addState(newState); // Update pages

          for (i = 0, l = children.length; i < l; i++) {
            children[i].addState(newState);
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION API
      ---------------------------------------------------------------------------
      */

      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {qx.ui.tabview.Page[]} List of items.
       */
      getSelection: function getSelection() {
        var buttons = this.__radioGroup__P_524_1.getSelection();

        var result = [];

        for (var i = 0; i < buttons.length; i++) {
          result.push(buttons[i].getUserData("page"));
        }

        return result;
      },

      /**
       * Replaces current selection with the given items.
       *
       * @param items {qx.ui.tabview.Page[]} Items to select.
       * @throws {Error} if one of the items is not a child element and if
       *    items contains more than one elements.
       */
      setSelection: function setSelection(items) {
        var buttons = [];

        for (var i = 0; i < items.length; i++) {
          buttons.push(items[i].getChildControl("button"));
        }

        this.__radioGroup__P_524_1.setSelection(buttons);
      },

      /**
       * Clears the whole selection at once.
       */
      resetSelection: function resetSelection() {
        this.__radioGroup__P_524_1.resetSelection();
      },

      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {qx.ui.tabview.Page} Any valid selectable item.
       * @return {Boolean} Whether the item is selected.
       * @throws {Error} if one of the items is not a child element.
       */
      isSelected: function isSelected(item) {
        var button = item.getChildControl("button");
        return this.__radioGroup__P_524_1.isSelected(button);
      },

      /**
       * Whether the selection is empty.
       *
       * @return {Boolean} Whether the selection is empty.
       */
      isSelectionEmpty: function isSelectionEmpty() {
        return this.__radioGroup__P_524_1.isSelectionEmpty();
      },

      /**
       * Returns all elements which are selectable.
       *
       * @return {qx.ui.tabview.Page[]} The contained items.
       * @param all {Boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       */
      getSelectables: function getSelectables(all) {
        var buttons = this.__radioGroup__P_524_1.getSelectables(all);

        var result = [];

        for (var i = 0; i < buttons.length; i++) {
          result.push(buttons[i].getUserData("page"));
        }

        return result;
      },

      /**
       * Event handler for <code>changeSelection</code>.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      _onChangeSelection: function _onChangeSelection(e) {
        var pane = this.getChildControl("pane");
        var button = e.getData()[0];
        var oldButton = e.getOldData()[0];
        var value = [];
        var old = [];

        if (button) {
          value = [button.getUserData("page")];
          pane.setSelection(value);
          this.scrollChildIntoView(button, null, null, false);
        } else {
          pane.resetSelection();
        }

        if (oldButton) {
          old = [oldButton.getUserData("page")];
        }

        this.fireDataEvent("changeSelection", value, old);
      },

      /**
       * Event handler for <code>beforeChangeSelection</code>.
       *
       * @param e {qx.event.type.Event} Data event.
       */
      _onBeforeChangeSelection: function _onBeforeChangeSelection(e) {
        if (!this.fireNonBubblingEvent("beforeChangeSelection", qx.event.type.Event, [false, true])) {
          e.preventDefault();
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the change of the selected item of the radio group.
       * @param e {qx.event.type.Data} The data event
       */
      _onRadioChangeSelection: function _onRadioChangeSelection(e) {
        var element = e.getData()[0];

        if (element) {
          this.setSelection([element.getUserData("page")]);
        } else {
          this.resetSelection();
        }
      },

      /**
       * Removes the Page widget on which the close button was tapped.
       *
       * @param e {qx.event.type.Pointer} pointer event
       */
      _onPageClose: function _onPageClose(e) {
        // reset the old close button states, before remove page
        // see http://bugzilla.qooxdoo.org/show_bug.cgi?id=3763 for details
        var page = e.getTarget();
        var closeButton = page.getButton().getChildControl("close-button");
        closeButton.reset();
        this.remove(page);
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__radioGroup__P_524_1");

      this.__barPositionToState__P_524_0 = null;
    }
  });
  qx.ui.tabview.TabView.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.ToggleButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.toolbar.PartContainer": {},
      "qx.ui.core.queue.Appearance": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A button which is toggle-able for toolbars.
   */
  qx.Class.define("qx.ui.toolbar.CheckBox", {
    extend: qx.ui.form.ToggleButton,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct(label, icon) {
      qx.ui.form.ToggleButton.constructor.call(this, label, icon); // Toolbar buttons should not support the keyboard events

      this.removeListener("keydown", this._onKeyDown);
      this.removeListener("keyup", this._onKeyUp);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "toolbar-button"
      },
      show: {
        refine: true,
        init: "inherit"
      },
      focusable: {
        refine: true,
        init: false
      }
    },
    members: {
      // overridden
      _applyVisibility: function _applyVisibility(value, old) {
        qx.ui.toolbar.CheckBox.prototype._applyVisibility.base.call(this, value, old); // trigger a appearance recalculation of the parent


        var parent = this.getLayoutParent();

        if (parent && parent instanceof qx.ui.toolbar.PartContainer) {
          qx.ui.core.queue.Appearance.add(parent);
        }
      }
    }
  });
  qx.ui.toolbar.CheckBox.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.menubar.Button": {
        "require": true
      },
      "qx.ui.toolbar.PartContainer": {},
      "qx.ui.core.queue.Appearance": {},
      "qx.ui.basic.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * The button to fill the menubar
   *
   * @childControl arrow {qx.ui.basic.Image} arrow widget to show a submenu is available
   */
  qx.Class.define("qx.ui.toolbar.MenuButton", {
    extend: qx.ui.menubar.Button,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** Appearance of the widget */
      appearance: {
        refine: true,
        init: "toolbar-menubutton"
      },

      /** Whether the button should show an arrow to indicate the menu behind it */
      showArrow: {
        check: "Boolean",
        init: false,
        themeable: true,
        apply: "_applyShowArrow"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _applyVisibility: function _applyVisibility(value, old) {
        qx.ui.toolbar.MenuButton.prototype._applyVisibility.base.call(this, value, old); // hide the menu too


        var menu = this.getMenu();

        if (value != "visible" && menu) {
          menu.hide();
        } // trigger a appearance recalculation of the parent


        var parent = this.getLayoutParent();

        if (parent && parent instanceof qx.ui.toolbar.PartContainer) {
          qx.ui.core.queue.Appearance.add(parent);
        }
      },
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "arrow":
            control = new qx.ui.basic.Image();
            control.setAnonymous(true);

            this._addAt(control, 10);

            break;
        }

        return control || qx.ui.toolbar.MenuButton.prototype._createChildControlImpl.base.call(this, id);
      },
      // property apply routine
      _applyShowArrow: function _applyShowArrow(value, old) {
        if (value) {
          this._showChildControl("arrow");
        } else {
          this._excludeChildControl("arrow");
        }
      }
    }
  });
  qx.ui.toolbar.MenuButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.toolbar.CheckBox": {
        "require": true
      },
      "qx.ui.form.MModelProperty": {
        "require": true
      },
      "qx.ui.form.IModel": {
        "require": true
      },
      "qx.ui.form.IRadioItem": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Radio buttons are used to manage a single selection. Radio buttons only
   * make sense used in a group of two or more of them. They are managed (connected)
   * to a {@link qx.ui.form.RadioGroup} to handle the selection.
   */
  qx.Class.define("qx.ui.toolbar.RadioButton", {
    extend: qx.ui.toolbar.CheckBox,
    include: [qx.ui.form.MModelProperty],
    implement: [qx.ui.form.IModel, qx.ui.form.IRadioItem],

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyValue: function _applyValue(value, old) {
        qx.ui.toolbar.RadioButton.prototype._applyValue.base.call(this, value, old);

        if (value) {
          var grp = this.getGroup();

          if (grp) {
            grp.setSelection([this]);
          }
        }
      },
      // overridden
      _onExecute: function _onExecute(e) {
        var grp = this.getGroup();

        if (grp && grp.getAllowEmptySelection()) {
          this.toggleValue();
        } else {
          this.setValue(true);
        }
      }
    }
  });
  qx.ui.toolbar.RadioButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.form.SplitButton": {
        "construct": true,
        "require": true
      },
      "qx.ui.toolbar.Button": {},
      "qx.ui.toolbar.MenuButton": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * A button which acts as a normal button and shows a menu on one
   * of the sides to open something like a history list.
   *
   * @childControl button {qx.ui.toolbar.Button} button to interact with
   * @childControl arrow {qx.ui.toolbar.MenuButton} menu button to show the menu connected to the split button
   */
  qx.Class.define("qx.ui.toolbar.SplitButton", {
    extend: qx.ui.form.SplitButton,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct(label, icon, menu, command) {
      qx.ui.form.SplitButton.constructor.call(this, label, icon, menu, command); // Toolbar buttons should not support the keyboard events

      this.removeListener("keydown", this._onKeyDown);
      this.removeListener("keyup", this._onKeyUp);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "toolbar-splitbutton"
      },
      // overridden
      focusable: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        hovered: true,
        focused: true,
        left: true,
        middle: true,
        right: true
      },

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl: function _createChildControlImpl(id, hash) {
        var control;

        switch (id) {
          case "button":
            control = new qx.ui.toolbar.Button();
            control.addListener("execute", this._onButtonExecute, this);

            this._addAt(control, 0);

            break;

          case "arrow":
            control = new qx.ui.toolbar.MenuButton();

            this._addAt(control, 1);

            break;
        }

        return control || qx.ui.toolbar.SplitButton.prototype._createChildControlImpl.base.call(this, id);
      }
    }
  });
  qx.ui.toolbar.SplitButton.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.selection.ScrollArea": {
        "require": true
      },
      "qx.ui.tree.core.AbstractTreeItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Responsible for the selection management of the {@link qx.ui.tree.Tree}.
   *
   * @internal
   */
  qx.Class.define("qx.ui.tree.selection.SelectionManager", {
    extend: qx.ui.core.selection.ScrollArea,
    members: {
      // overridden
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        var computed = item.getBounds();

        if (computed) {
          var top = this._getWidget().getItemTop(item);

          return {
            top: top,
            bottom: top + computed.height
          };
        }
      },
      // overridden
      _isSelectable: function _isSelectable(item) {
        return this._isItemSelectable(item) && item instanceof qx.ui.tree.core.AbstractTreeItem;
      },
      // overridden
      _getSelectableFromPointerEvent: function _getSelectableFromPointerEvent(event) {
        return this._getWidget().getTreeItem(event.getTarget());
      },
      // overridden
      getSelectables: function getSelectables(all) {
        // if only the user selectables should be returned
        var oldUserInteraction = false;

        if (!all) {
          oldUserInteraction = this._userInteraction;
          this._userInteraction = true;
        }

        var widget = this._getWidget();

        var result = [];

        if (widget.getRoot() != null) {
          var items = widget.getRoot().getItems(true, !!all, widget.getHideRoot());

          for (var i = 0; i < items.length; i++) {
            if (this._isSelectable(items[i])) {
              result.push(items[i]);
            }
          }
        } // reset to the former user interaction state


        this._userInteraction = oldUserInteraction;
        return result;
      },
      // overridden
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        // Fast path for identical items
        if (item1 === item2) {
          return [item1];
        }

        var selectables = this.getSelectables();
        var item1Index = selectables.indexOf(item1);
        var item2Index = selectables.indexOf(item2);

        if (item1Index < 0 || item2Index < 0) {
          return [];
        }

        if (item1Index < item2Index) {
          return selectables.slice(item1Index, item2Index + 1);
        } else {
          return selectables.slice(item2Index, item1Index + 1);
        }
      },
      // overridden
      _getFirstSelectable: function _getFirstSelectable() {
        return this.getSelectables()[0] || null;
      },
      // overridden
      _getLastSelectable: function _getLastSelectable() {
        var selectables = this.getSelectables();

        if (selectables.length > 0) {
          return selectables[selectables.length - 1];
        } else {
          return null;
        }
      },
      // overridden
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        var widget = this._getWidget();

        var related = null;

        switch (relation) {
          case "above":
            related = widget.getPreviousNodeOf(item, false);
            break;

          case "under":
            related = widget.getNextNodeOf(item, false);
            break;

          case "left":
          case "right":
            break;
        }

        if (!related) {
          return null;
        }

        if (this._isSelectable(related)) {
          return related;
        } else {
          return this._getRelatedSelectable(related, relation);
        }
      }
    }
  });
  qx.ui.tree.selection.SelectionManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.core.scroll.AbstractScrollArea": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.IMultiSelection": {
        "require": true
      },
      "qx.ui.form.IModelSelection": {
        "require": true
      },
      "qx.ui.form.IField": {
        "require": true
      },
      "qx.ui.form.IForm": {
        "require": true
      },
      "qx.ui.core.MMultiSelectionHandling": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.ui.form.MModelSelection": {
        "require": true
      },
      "qx.ui.form.MForm": {
        "require": true
      },
      "qx.ui.container.Composite": {
        "construct": true
      },
      "qx.ui.layout.VBox": {
        "construct": true
      },
      "qx.ui.tree.selection.SelectionManager": {
        "require": true
      },
      "qx.ui.tree.core.AbstractTreeItem": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Derrell Lipman (derrell)
       * Christian Hagendorn (chris_schmidt)
       * Daniel Wagner (d_wagner)
  
  ************************************************************************ */

  /**
   * The Tree class implements a tree widget, with collapsible and expandable
   * container nodes and terminal leaf nodes. You instantiate a Tree object and
   * then assign the tree a root folder using the {@link #root} property.
   *
   * If you don't want to show the root item, you can hide it with the
   * {@link #hideRoot} property.
   *
   * The handling of <b>selections</b> within a tree is somewhat distributed
   * between the root tree object and the attached {@link qx.ui.tree.selection.SelectionManager}.
   * To get the currently selected element of a tree use the tree {@link #getSelection}
   * method and tree {@link #setSelection} to set it. The TreeSelectionManager
   * handles more coarse-grained issues like providing {@link #selectAll} and
   * {@link #resetSelection} methods.
   */
  qx.Class.define("qx.ui.tree.Tree", {
    extend: qx.ui.core.scroll.AbstractScrollArea,
    implement: [qx.ui.core.IMultiSelection, qx.ui.form.IModelSelection, qx.ui.form.IField, qx.ui.form.IForm],
    include: [qx.ui.core.MMultiSelectionHandling, qx.ui.core.MContentPadding, qx.ui.form.MModelSelection, qx.ui.form.MForm],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.core.scroll.AbstractScrollArea.constructor.call(this);
      this.__content__P_528_0 = new qx.ui.container.Composite(new qx.ui.layout.VBox()).set({
        allowShrinkY: false,
        allowGrowX: true
      });
      this.getChildControl("pane").add(this.__content__P_528_0);
      this.initOpenMode();
      this.initRootOpenClose();
      this.addListener("changeSelection", this._onChangeSelection, this);
      this.addListener("keypress", this._onKeyPress, this);
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * This event is fired after a tree item was added to the tree. The
       * {@link qx.event.type.Data#getData} method of the event returns the
       * added item.
       */
      addItem: "qx.event.type.Data",

      /**
       * This event is fired after a tree item has been removed from the tree.
       * The {@link qx.event.type.Data#getData} method of the event returns the
       * removed item.
       */
      removeItem: "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Control whether tap or double tap should open or close the tapped
       * folder.
       */
      openMode: {
        check: ["tap", "dbltap", "none"],
        init: "dbltap",
        apply: "_applyOpenMode",
        event: "changeOpenMode",
        themeable: true
      },

      /**
       * The root tree item of the tree to display
       */
      root: {
        check: "qx.ui.tree.core.AbstractTreeItem",
        init: null,
        nullable: true,
        event: "changeRoot",
        apply: "_applyRoot"
      },

      /**
       * Hide the root (Tree) node.  This differs from the visibility property in
       * that this property hides *only* the root node, not the node's children.
       */
      hideRoot: {
        check: "Boolean",
        init: false,
        apply: "_applyHideRoot"
      },

      /**
       * Whether the Root should have an open/close button.  This may also be
       * used in conjunction with the hideNode property to provide for virtual root
       * nodes.  In the latter case, be very sure that the virtual root nodes are
       * expanded programmatically, since there will be no open/close button for the
       * user to open them.
       */
      rootOpenClose: {
        check: "Boolean",
        init: false,
        apply: "_applyRootOpenClose"
      },
      // overridden
      appearance: {
        refine: true,
        init: "tree"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __content__P_528_0: null,

      /** @type {Class} Pointer to the selection manager to use */
      SELECTION_MANAGER: qx.ui.tree.selection.SelectionManager,

      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */

      /**
       * Get the widget, which contains the root tree item. This widget must
       * have a vertical box layout.
       *
       * @return {qx.ui.core.Widget} the children container
       */
      getChildrenContainer: function getChildrenContainer() {
        return this.__content__P_528_0;
      },
      // property apply
      _applyRoot: function _applyRoot(value, old) {
        var container = this.getChildrenContainer();

        if (old && !old.isDisposed()) {
          container.remove(old);

          if (old.hasChildren()) {
            container.remove(old.getChildrenContainer());
          }
        }

        if (value) {
          container.add(value);

          if (value.hasChildren()) {
            container.add(value.getChildrenContainer());
          }

          value.setVisibility(this.getHideRoot() ? "excluded" : "visible");
          value.recursiveAddToWidgetQueue();
        }
      },
      // property apply
      _applyHideRoot: function _applyHideRoot(value, old) {
        var root = this.getRoot();

        if (!root) {
          return;
        }

        root.setVisibility(value ? "excluded" : "visible");
        root.recursiveAddToWidgetQueue();
      },
      // property apply
      _applyRootOpenClose: function _applyRootOpenClose(value, old) {
        var root = this.getRoot();

        if (!root) {
          return;
        }

        root.recursiveAddToWidgetQueue();
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.__content__P_528_0;
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION MANAGER API
      ---------------------------------------------------------------------------
      */

      /**
       * Get the tree item following the given item in the tree hierarchy.
       *
       * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the item after
       * @param invisible {Boolean?true} Whether invisible/closed tree items
       *     should be returned as well.
       *
       * @return {qx.ui.tree.core.AbstractTreeItem?null} The item after the given item. May be
       *     <code>null</code> if the item is the last item.
       */
      getNextNodeOf: function getNextNodeOf(treeItem, invisible) {
        if ((invisible !== false || treeItem.isOpen()) && treeItem.hasChildren()) {
          return treeItem.getChildren()[0];
        }

        while (treeItem) {
          var parent = treeItem.getParent();

          if (!parent) {
            return null;
          }

          var parentChildren = parent.getChildren();
          var index = parentChildren.indexOf(treeItem);

          if (index > -1 && index < parentChildren.length - 1) {
            return parentChildren[index + 1];
          }

          treeItem = parent;
        }

        return null;
      },

      /**
       * Get the tree item preceding the given item in the tree hierarchy.
       *
       * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the item before
       * @param invisible {Boolean?true} Whether invisible/closed tree items
       *     should be returned as well.
       *
       * @return {qx.ui.tree.core.AbstractTreeItem?null} The item before the given item. May be
       *     <code>null</code> if the given item is the tree's root.
       */
      getPreviousNodeOf: function getPreviousNodeOf(treeItem, invisible) {
        var parent = treeItem.getParent();

        if (!parent) {
          return null;
        }

        if (this.getHideRoot()) {
          if (parent == this.getRoot()) {
            if (parent.getChildren()[0] == treeItem) {
              return null;
            }
          }
        } else {
          if (treeItem == this.getRoot()) {
            return null;
          }
        }

        var parentChildren = parent.getChildren();
        var index = parentChildren.indexOf(treeItem);

        if (index > 0) {
          var folder = parentChildren[index - 1];

          while ((invisible !== false || folder.isOpen()) && folder.hasChildren()) {
            var children = folder.getChildren();
            folder = children[children.length - 1];
          }

          return folder;
        } else {
          return parent;
        }
      },

      /**
       * Get the tree item's next sibling.
       *
       * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the following
       * sibling of.
       *
       * @return {qx.ui.tree.core.AbstractTreeItem?null} The item following the given item. May be
       *     <code>null</code> if the given item is the last in it's nesting
       *     level.
       */
      getNextSiblingOf: function getNextSiblingOf(treeItem) {
        if (treeItem == this.getRoot()) {
          return null;
        }

        var parent = treeItem.getParent();
        var siblings = parent.getChildren();
        var index = siblings.indexOf(treeItem);

        if (index < siblings.length - 1) {
          return siblings[index + 1];
        }

        return null;
      },

      /**
       * Get the tree item's previous sibling.
       *
       * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the previous
       * sibling of.
       *
       * @return {qx.ui.tree.core.AbstractTreeItem?null} The item preceding the given item. May be
       *     <code>null</code> if the given item is the first in it's nesting
       *     level.
       */
      getPreviousSiblingOf: function getPreviousSiblingOf(treeItem) {
        if (treeItem == this.getRoot()) {
          return null;
        }

        var parent = treeItem.getParent();
        var siblings = parent.getChildren();
        var index = siblings.indexOf(treeItem);

        if (index > 0) {
          return siblings[index - 1];
        }

        return null;
      },

      /**
       * Returns all children of the tree.
       *
       * @param recursive {Boolean ? false} whether children of subfolder should be
       *     included
       * @param invisible {Boolean ? true} whether invisible children should be
       *     included
       * @return {qx.ui.tree.core.AbstractTreeItem[]} list of children
       */
      getItems: function getItems(recursive, invisible) {
        if (this.getRoot() != null) {
          return this.getRoot().getItems(recursive, invisible, this.getHideRoot());
        } else {
          return [];
        }
      },

      /**
       * Returns the tree's only "external" child, namely the root node.
       *
       * @return {qx.ui.tree.core.AbstractTreeItem[]} Array containing the root node
       */
      getChildren: function getChildren() {
        if (this.getRoot() != null) {
          return [this.getRoot()];
        } else {
          return [];
        }
      },

      /*
      ---------------------------------------------------------------------------
        POINTER EVENT HANDLER
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the tree item, which contains the given widget.
       *
       * @param widget {qx.ui.core.Widget} The widget to get the containing tree
       *   item for.
       * @return {qx.ui.tree.core.AbstractTreeItem|null} The tree item containing the widget. If the
       *     widget is not inside of any tree item <code>null</code> is returned.
       */
      getTreeItem: function getTreeItem(widget) {
        while (widget) {
          if (widget == this) {
            return null;
          }

          if (widget instanceof qx.ui.tree.core.AbstractTreeItem) {
            return widget;
          }

          widget = widget.getLayoutParent();
        }

        return null;
      },
      // property apply
      _applyOpenMode: function _applyOpenMode(value, old) {
        if (old == "tap") {
          this.removeListener("tap", this._onOpen, this);
        } else if (old == "dbltap") {
          this.removeListener("dbltap", this._onOpen, this);
        }

        if (value == "tap") {
          this.addListener("tap", this._onOpen, this);
        } else if (value == "dbltap") {
          this.addListener("dbltap", this._onOpen, this);
        }
      },

      /**
       * Event handler for tap events, which could change a tree item's open
       * state.
       *
       * @param e {qx.event.type.Pointer} The tap event object
       */
      _onOpen: function _onOpen(e) {
        var treeItem = this.getTreeItem(e.getTarget());

        if (!treeItem || !treeItem.isOpenable()) {
          return;
        }

        treeItem.setOpen(!treeItem.isOpen());
        e.stopPropagation();
      },

      /**
       * Event handler for changeSelection events, which opens all parent folders
       * of the selected folders.
       *
       * @param e {qx.event.type.Data} The selection data event.
       */
      _onChangeSelection: function _onChangeSelection(e) {
        var selection = e.getData(); // for every selected folder

        for (var i = 0; i < selection.length; i++) {
          var folder = selection[i]; // go up all parents and open them

          while (folder.getParent() != null) {
            folder = folder.getParent();
            folder.setOpen(true);
          }
        }
      },

      /**
       * Event handler for key press events. Open and close the current selected
       * item on key left and right press. Jump to parent on key left if already
       * closed.
       *
       * @param e {qx.event.type.KeySequence} key event.
       */
      _onKeyPress: function _onKeyPress(e) {
        var item = this._getLeadItem();

        if (item !== null) {
          switch (e.getKeyIdentifier()) {
            case "Left":
              if (item.isOpenable() && item.isOpen()) {
                item.setOpen(false);
              } else if (item.getParent()) {
                this.setSelection([item.getParent()]);
              }

              break;

            case "Right":
              if (item.isOpenable() && !item.isOpen()) {
                item.setOpen(true);
              }

              break;

            case "Enter":
            case "Space":
              if (item.isOpenable()) {
                item.toggleOpen();
              }

              break;
          }
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("__content__P_528_0");
    }
  });
  qx.ui.tree.Tree.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.tree.core.AbstractTreeItem": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
       2006 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Derrell Lipman (derrell)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The tree file is a leaf tree item. It cannot contain any nested tree items.
   */
  qx.Class.define("qx.ui.tree.TreeFile", {
    extend: qx.ui.tree.core.AbstractTreeItem,
    properties: {
      appearance: {
        refine: true,
        init: "tree-file"
      }
    },
    members: {
      // overridden
      _addWidgets: function _addWidgets() {
        this.addSpacer();
        this.addIcon();
        this.addLabel();
      }
    }
  });
  qx.ui.tree.TreeFile.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Interface describes the methods which the {@link qx.ui.tree.provider.WidgetProvider}
   * uses for communication.
   */
  qx.Interface.define("qx.ui.tree.core.IVirtualTree", {
    members: {
      /**
       * Return whether top level items should have an open/close button. The top
       * level item item is normally the root item, but when the root is hidden,
       * the root children are the top level items.
       *
       * @return {Boolean} Returns <code>true</code> when top level items should
       *   show open/close buttons, <code>false</code> otherwise.
       */
      isShowTopLevelOpenCloseIcons: function isShowTopLevelOpenCloseIcons() {},

      /**
       * Returns the internal data structure. The Array index is the row and the
       * value is the model item.
       *
       * @internal
       * @return {qx.data.Array} The internal data structure.
       */
      getLookupTable: function getLookupTable() {},

      /**
       * Returns if the passed item is a note or a leaf.
       *
       * @internal
       * @param item {qx.core.Object} Item to check.
       * @return {Boolean} <code>True</code> when item is a node,
       *   </code>false</code> when item is a leaf.
       */
      isNode: function isNode(item) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(item, qx.core.Object);
      },

      /**
       * Return whether the node is opened or closed.
       *
       * @param node {qx.core.Object} Node to check.
       * @return {Boolean} Returns <code>true</code> when the node is opened,
       *   <code>false</code> otherwise.
       */
      isNodeOpen: function isNodeOpen(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Returns the row's nesting level.
       *
       * @param row {Integer} The row to get the nesting level.
       * @return {Integer} The row's nesting level or <code>null</code>.
       */
      getLevel: function getLevel(row) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInteger(row);
      },

      /**
       * Return whether the node has visible children or not.
       *
       * @internal
       * @param node {qx.core.Object} Node to check.
       * @return {Boolean} <code>True</code> when the node has visible children,
       *   <code>false</code> otherwise.
       */
      hasChildren: function hasChildren(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Opens the passed node.
       *
       * @param node {qx.core.Object} Node to open.
       */
      openNode: function openNode(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Opens the passed node without scrolling selected item into view.
       *
       * @param node {qx.core.Object} Node to open.
       */
      openNodeWithoutScrolling: function openNodeWithoutScrolling(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Closes the passed node.
       *
       * @param node {qx.core.Object} Node to close.
       */
      closeNode: function closeNode(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Closes the passed node without scrolling selected item into view.
       *
       * @param node {qx.core.Object} Node to close.
       */
      closeNodeWithoutScrolling: function closeNodeWithoutScrolling(node) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInterface(node, qx.core.Object);
      },

      /**
       * Returns the current selection.
       *
       * @return {qx.data.Array} The current selected elements.
       */
      getSelection: function getSelection() {}
    }
  });
  qx.ui.tree.core.IVirtualTree.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.core.Scroller": {
        "construct": true,
        "require": true
      },
      "qx.ui.tree.core.IVirtualTree": {
        "require": true
      },
      "qx.data.controller.ISelection": {
        "require": true
      },
      "qx.ui.virtual.selection.MModel": {
        "require": true
      },
      "qx.ui.core.MContentPadding": {
        "require": true
      },
      "qx.lang.Array": {},
      "qx.ui.tree.core.OpenCloseController": {},
      "qx.data.Array": {},
      "qx.ui.tree.provider.WidgetProvider": {},
      "qx.ui.tree.core.Util": {},
      "qx.data.marshal.MEventBubbling": {},
      "qx.data.SingleValueBinding": {},
      "qx.util.DeferredCall": {},
      "qx.ui.core.queue.Widget": {},
      "qx.util.Delegate": {},
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /*
   * Virtual tree implementation.
   *
   * The virtual tree can be used to render node and leafs. Nodes and leafs are
   * both items for a tree. The difference between a node and a leaf is that a
   * node has child items, but a leaf not.
   *
   * With the {@link qx.ui.tree.core.IVirtualTreeDelegate} interface it is possible
   * to configure the tree's behavior (item renderer configuration, etc.).
   *
   * Here's an example of how to use the widget, including using a model
   * property to open/close branches. See the two timers at the end. The first
   * one opens all branches after two seconds; the second cleans up the tree
   * after five seconds.
   *
   * <pre class="javascript">
   *   var nodes = 
   *   [
   *     {
   *       name : "Root",
   *       open : false,
   *       children :
   *       [
   *         {
   *           name : "Branch 1",
   *           open : false,
   *           children :
   *           [
   *             {
   *               name : "Leaf 1.1"
   *             },
   *             {
   *               name : "Leaf 1.2"
   *             },
   *             {
   *               name : "Branch 1.3",
   *               open : false,
   *               children :
   *               [
   *                 {
   *                   name : "Branch 1.3.1",
   *                   open : false,
   *                   children :
   *                   [
   *                     {
   *                       name : "Leaf 1.3.1.1"
   *                     }
   *                   ]
   *                 }
   *               ]
   *             }
   *           ]
   *         }
   *       ]
   *     }
   *   ];
   *
   *   // convert the raw nodes to qooxdoo objects
   *   nodes = qx.data.marshal.Json.createModel(nodes, true);
   *
   *   // create the tree and synchronize the model property 'open'
   *   // to nodes being open
   *   var tree =
   *     new qx.ui.tree.VirtualTree(
   *       nodes.getItem(0), "name", "children", "open").set({
   *         width : 200,
   *         height : 400
   *       });
   *
   *   //log selection changes
   *   tree.getSelection().addListener("change", function(e) {
   *     this.debug("Selection: " + tree.getSelection().getItem(0).getName());
   *   }, this);
   *
   *   tree.set(
   *     {
   *       width : 200,
   *       height : 400,
   *       showTopLevelOpenCloseIcons : true
   *     });
   *
   *   var doc = this.getRoot();
   *   doc.add(tree,
   *   {
   *     left : 100,
   *     top  : 50
   *   });
   *
   *   // After two seconds, open up all branches by setting their open
   *   // property to true.
   *   qx.event.Timer.once(
   *     function()
   *     {
   *       ;(function allOpen(root)
   *         {
   *           if (root.setOpen)     root.setOpen(true);
   *           if (root.getChildren) root.getChildren().forEach(allOpen);
   *         })(nodes.getItem(0));
   *     },
   *     this,
   *     2000);
   *
   *   // After five seconds, remove and dispose the tree.
   *   qx.event.Timer.once(
   *     function()
   *     {
   *       doc.remove(tree);
   *       tree.dispose();
   *       console.warn("All cleaned up.");
   *     },
   *     this,
   *     5000);
   * </pre>
   */
  qx.Class.define("qx.ui.tree.VirtualTree", {
    extend: qx.ui.virtual.core.Scroller,
    implement: [qx.ui.tree.core.IVirtualTree, qx.data.controller.ISelection],
    include: [qx.ui.virtual.selection.MModel, qx.ui.core.MContentPadding],

    /**
     * @param rootModel {qx.core.Object?null} The model structure representing
     *   the root of the tree, for more details have a look at the 'model'
     *   property.
     * @param labelPath {String?null} The name of the label property, for more
     *   details have a look at the 'labelPath' property.
     * @param childProperty {String?null} The name of the child property, for
     *   more details have a look at the 'childProperty' property.
     * @param openProperty {String|null} the name of the model property which
     *   represents the open state of a branch. If this value is provided, so, 
     *   too, must be rootModel.
     */
    construct: function construct(rootModel, labelPath, childProperty, openProperty) {
      qx.ui.virtual.core.Scroller.constructor.call(this, 0, 1, 20, 100);

      this._init();

      if (labelPath != null) {
        this.setLabelPath(labelPath);
      }

      if (childProperty != null) {
        this.setChildProperty(childProperty);
      }

      if (rootModel != null) {
        this.initModel(rootModel);
      }

      this.initItemHeight();
      this.initOpenMode();
      this.addListener("keypress", this._onKeyPress, this); // If an open property and root model are provided, start up the open-close controller.

      if (openProperty && rootModel) {
        this.openViaModelChanges(openProperty);
      }
    },
    events: {
      /**
       * Fired when a node is opened.
       */
      open: "qx.event.type.Data",

      /**
       * Fired when a node is closed.
       */
      close: "qx.event.type.Data"
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "virtual-tree"
      },
      // overridden
      focusable: {
        refine: true,
        init: true
      },
      // overridden
      width: {
        refine: true,
        init: 100
      },
      // overridden
      height: {
        refine: true,
        init: 200
      },

      /** Default item height. */
      itemHeight: {
        check: "Integer",
        init: 25,
        apply: "_applyRowHeight",
        themeable: true
      },

      /**
      * Control whether tap or double tap should open or close the tapped
      * item.
      */
      openMode: {
        check: ["tap", "dbltap", "none"],
        init: "dbltap",
        apply: "_applyOpenMode",
        event: "changeOpenMode",
        themeable: true
      },

      /**
       * Hides *only* the root node, not the node's children when the property is
       * set to <code>true</code>.
       */
      hideRoot: {
        check: "Boolean",
        init: false,
        apply: "_applyHideRoot"
      },

      /**
       * Whether top level items should have an open/close button. The top level
       * item item is normally the root item, but when the root is hidden, the
       * root children are the top level items.
       */
      showTopLevelOpenCloseIcons: {
        check: "Boolean",
        init: false,
        apply: "_applyShowTopLevelOpenCloseIcons"
      },

      /**
       * Configures the tree to show also the leafs. When the property is set to
       * <code>false</code> *only* the nodes are shown.
       */
      showLeafs: {
        check: "Boolean",
        init: true,
        apply: "_applyShowLeafs"
      },

      /**
       * The name of the property, where the children are stored in the model.
       * Instead of the {@link #labelPath} must the child property a direct
       * property form the model instance.
       */
      childProperty: {
        check: "String",
        apply: "_applyChildProperty",
        nullable: true
      },

      /**
       * The name of the property, where the value for the tree folders label
       * is stored in the model classes.
       */
      labelPath: {
        check: "String",
        apply: "_applyLabelPath",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * shown as an icon.
       */
      iconPath: {
        check: "String",
        apply: "_applyIconPath",
        nullable: true
      },

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      labelOptions: {
        apply: "_applyLabelOptions",
        nullable: true
      },

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      iconOptions: {
        apply: "_applyIconOptions",
        nullable: true
      },

      /**
       * The model containing the data (nodes and/or leafs) which should be shown
       * in the tree.
       */
      model: {
        check: "qx.core.Object",
        apply: "_applyModel",
        event: "changeModel",
        nullable: true,
        deferredInit: true
      },

      /**
       * Delegation object, which can have one or more functions defined by the
       * {@link qx.ui.tree.core.IVirtualTreeDelegate} interface.
       */
      delegate: {
        event: "changeDelegate",
        apply: "_applyDelegate",
        init: null,
        nullable: true
      }
    },
    members: {
      /** @type {qx.ui.tree.provider.WidgetProvider} Provider for widget rendering. */
      _provider: null,

      /** @type {qx.ui.virtual.layer.Abstract} Layer which contains the items. */
      _layer: null,

      /**
       * @type {qx.data.Array} The internal lookup table data structure to get the model item
       * from a row.
       */
      __lookupTable__P_529_0: null,

      /** @type {Array} HashMap which contains all open nodes. */
      __openNodes__P_529_1: null,

      /**
       * @type {Array} The internal data structure to get the nesting level from a
       * row.
       */
      __nestingLevel__P_529_2: null,

      /**
       * @type {qx.util.DeferredCall} Adds this instance to the widget queue on a
       * deferred call.
       */
      __deferredCall__P_529_3: null,

      /** @type {Integer} Holds the max item width from a rendered widget. */
      _itemWidth: 0,

      /** @type {Array} internal parent chain form the last selected node */
      __parentChain__P_529_4: null,

      /** 
       * @type {String|null} the name of the model property which represents the
       *   open state of a branch.
       */
      __openProperty__P_529_5: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */
      // overridden
      syncWidget: function syncWidget(jobs) {
        var firstRow = this._layer.getFirstRow();

        var rowSize = this._layer.getRowSizes().length;

        for (var row = firstRow; row < firstRow + rowSize; row++) {
          var widget = this._layer.getRenderedCellWidget(row, 0);

          if (widget != null) {
            this._itemWidth = Math.max(this._itemWidth, widget.getSizeHint().width);
          }
        }

        var paneWidth = this.getPane().getInnerSize().width;
        this.getPane().getColumnConfig().setItemSize(0, Math.max(this._itemWidth, paneWidth));
      },
      // Interface implementation
      openNode: function openNode(node) {
        this.__openNode__P_529_6(node);

        this.buildLookupTable();
      },
      // Interface implementation
      openNodeWithoutScrolling: function openNodeWithoutScrolling(node) {
        var autoscroll = this.getAutoScrollIntoView(); // suspend automatically scrolling selection into view

        this.setAutoScrollIntoView(false);
        this.openNode(node); // re set to original value

        this.setAutoScrollIntoView(autoscroll);
      },

      /**
       * Trigger a rebuild from the internal data structure.
       */
      refresh: function refresh() {
        this.buildLookupTable();
      },

      /**
       * Opens the passed node and all his parents. *Note!* The algorithm
       * implements a depth-first search with a complexity: <code>O(n)</code> and
       * <code>n</code> are all model items.
       *
       * @param node {qx.core.Object} Node to open.
       */
      openNodeAndParents: function openNodeAndParents(node) {
        this.__openNodeAndAllParents__P_529_7(this.getModel(), node);

        this.buildLookupTable();
      },
      // Interface implementation
      closeNode: function closeNode(node) {
        if (this.__openNodes__P_529_1.includes(node)) {
          qx.lang.Array.remove(this.__openNodes__P_529_1, node);
          this.fireDataEvent("close", node);
          this.buildLookupTable();
        }
      },
      // Interface implementation
      closeNodeWithoutScrolling: function closeNodeWithoutScrolling(node) {
        var autoscroll = this.getAutoScrollIntoView(); // suspend automatically scrolling selection into view

        this.setAutoScrollIntoView(false);
        this.closeNode(node); // re set to original value

        this.setAutoScrollIntoView(autoscroll);
      },
      // Interface implementation
      isNodeOpen: function isNodeOpen(node) {
        return this.__openNodes__P_529_1.includes(node);
      },

      /**
       * Open and close branches via changes to a property in the model.
       * 
       * @param openProperty {String|null} 
       *   The name of the open property, which determines the open state of a
       *   branch in the tree. If null, turn off opening and closing branches
       *   via changes to the model.
       */
      openViaModelChanges: function openViaModelChanges(openProperty) {
        // Save the open property
        this.__openProperty__P_529_5 = openProperty; // if no name is provided, just remove any prior open-close controller

        if (!openProperty) {
          if (this._openCloseController) {
            this._openCloseController.dispose();

            this._openCloseController = null;
          }

          return;
        } // we have a property name, so create controller


        this._openCloseController = new qx.ui.tree.core.OpenCloseController(this, this.getModel(), openProperty);
      },

      /**
       * Getter for the open property
       */
      getOpenProperty: function getOpenProperty() {
        return this.__openProperty__P_529_5;
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */

      /**
       * Initializes the virtual tree.
       */
      _init: function _init() {
        this.__lookupTable__P_529_0 = new qx.data.Array();
        this.__openNodes__P_529_1 = [];
        this.__nestingLevel__P_529_2 = [];

        this._initLayer();
      },

      /**
       * Initializes the virtual tree layer.
       */
      _initLayer: function _initLayer() {
        this._provider = new qx.ui.tree.provider.WidgetProvider(this);
        this._layer = this._provider.createLayer();

        this._layer.addListener("updated", this._onUpdated, this);

        this.getPane().addLayer(this._layer);
        this.getPane().addListenerOnce("resize", function (e) {
          // apply width to pane on first rendering pass
          // to avoid visible flickering
          this.getPane().getColumnConfig().setItemSize(0, e.getData().width);
        }, this);
      },
      // Interface implementation
      getLookupTable: function getLookupTable() {
        return this.__lookupTable__P_529_0;
      },

      /**
       * Performs a lookup from model index to row.
       *
       * @param index {Number} The index to look at.
       * @return {Number} The row or <code>-1</code>
       *  if the index is not a model index.
       */
      _reverseLookup: function _reverseLookup(index) {
        return index;
      },

      /**
       * Returns the model data for the given row.
       *
       * @param row {Integer} row to get data for.
       * @return {var|null} the row's model data.
       */
      _getDataFromRow: function _getDataFromRow(row) {
        return this.__lookupTable__P_529_0.getItem(row);
      },

      /**
       * Returns the selectable model items.
       *
       * @return {qx.data.Array} The selectable items.
       */
      _getSelectables: function _getSelectables() {
        return this.__lookupTable__P_529_0;
      },

      /**
       * Returns all open nodes.
       *
       * @internal
       * @return {Array} All open nodes.
       */
      getOpenNodes: function getOpenNodes() {
        return this.__openNodes__P_529_1;
      },
      // Interface implementation
      isNode: function isNode(item) {
        return qx.ui.tree.core.Util.isNode(item, this.getChildProperty());
      },
      // Interface implementation
      getLevel: function getLevel(row) {
        return this.__nestingLevel__P_529_2[row];
      },
      // Interface implementation
      hasChildren: function hasChildren(node) {
        return qx.ui.tree.core.Util.hasChildren(node, this.getChildProperty(), !this.isShowLeafs());
      },

      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget: function _getContentPaddingTarget() {
        return this.getPane();
      },

      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY METHODS
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyRowHeight: function _applyRowHeight(value, old) {
        this.getPane().getRowConfig().setDefaultItemSize(value);
      },
      // property apply
      _applyOpenMode: function _applyOpenMode(value, old) {
        var pane = this.getPane(); //"tap", "dbltap", "none"

        if (value === "dbltap") {
          pane.addListener("cellDbltap", this._onOpen, this);
        } else if (value === "tap") {
          pane.addListener("cellTap", this._onOpen, this);
        }

        if (old === "dbltap") {
          pane.removeListener("cellDbltap", this._onOpen, this);
        } else if (old === "tap") {
          pane.removeListener("cellTap", this._onOpen, this);
        }
      },
      // property apply
      _applyHideRoot: function _applyHideRoot(value, old) {
        this.buildLookupTable();
      },
      // property apply
      _applyShowTopLevelOpenCloseIcons: function _applyShowTopLevelOpenCloseIcons(value, old) {
        // force rebuild of the lookup table
        // fixes https://github.com/qooxdoo/qooxdoo/issues/9128
        this.getLookupTable().removeAll();
        this.buildLookupTable();
      },
      // property apply
      _applyShowLeafs: function _applyShowLeafs(value, old) {
        // force rebuild of the lookup table
        // fixes https://github.com/qooxdoo/qooxdoo/issues/9128
        this.getLookupTable().removeAll();
        this.buildLookupTable();
      },
      // property apply
      _applyChildProperty: function _applyChildProperty(value, old) {
        this._provider.setChildProperty(value);
      },
      // property apply
      _applyLabelPath: function _applyLabelPath(value, old) {
        this._provider.setLabelPath(value);
      },
      // property apply
      _applyIconPath: function _applyIconPath(value, old) {
        this._provider.setIconPath(value);
      },
      // property apply
      _applyLabelOptions: function _applyLabelOptions(value, old) {
        this._provider.setLabelOptions(value);
      },
      // property apply
      _applyIconOptions: function _applyIconOptions(value, old) {
        this._provider.setIconOptions(value);
      },
      // property apply
      _applyModel: function _applyModel(value, old) {
        this.__openNodes__P_529_1 = [];

        if (value != null) {
          {
            if (!qx.Class.hasMixin(value.constructor, qx.data.marshal.MEventBubbling)) {
              this.warn("The model item doesn't support the Mixin 'qx.data.marshal.MEventBubbling'. Therefore the tree can not update the view automatically on model changes.");
            }
          }
          value.addListener("changeBubble", this._onChangeBubble, this);

          this.__openNode__P_529_6(value);
        } // If the model changes, an existing OpenCloseController is no longer
        // valid, so dispose it. The user should call openViaModelChanges again.


        if (this._openCloseController) {
          this._openCloseController.dispose();

          this._openCloseController = null;
        }

        if (old != null) {
          old.removeListener("changeBubble", this._onChangeBubble, this);
        }

        this.__applyModelChanges__P_529_8();
      },
      // property apply
      _applyDelegate: function _applyDelegate(value, old) {
        this._provider.setDelegate(value);

        this.buildLookupTable();
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the changeBubble event. The handler rebuild the lookup
       * table when the child structure changed.
       *
       * @param event {qx.event.type.Data} The data event.
       */
      _onChangeBubble: function _onChangeBubble(event) {
        var data = event.getData();
        var propertyName = data.name;
        var index = propertyName.lastIndexOf(".");

        if (index != -1) {
          propertyName = propertyName.substr(index + 1, propertyName.length);
        } // only continue when the effected property is the child property


        if (propertyName.startsWith(this.getChildProperty())) {
          var item = data.item;

          if (qx.Class.isSubClassOf(item.constructor, qx.data.Array)) {
            if (index === -1) {
              item = this.getModel();
            } else {
              var propertyChain = data.name.substr(0, index);
              item = qx.data.SingleValueBinding.resolvePropertyChain(this.getModel(), propertyChain);
            }
          }

          if (this.__lookupTable__P_529_0.indexOf(item) != -1) {
            this.__applyModelChanges__P_529_8();
          }
        }
      },

      /**
       * Event handler for the update event.
       *
       * @param event {qx.event.type.Event} The event.
       */
      _onUpdated: function _onUpdated(event) {
        if (this.__deferredCall__P_529_3 == null) {
          this.__deferredCall__P_529_3 = new qx.util.DeferredCall(function () {
            qx.ui.core.queue.Widget.add(this);
          }, this);
        }

        this.__deferredCall__P_529_3.schedule();
      },

      /**
       * Event handler to open/close tapped nodes.
       *
       * @param event {qx.ui.virtual.core.CellEvent} The cell tap event.
       */
      _onOpen: function _onOpen(event) {
        var row = event.getRow();

        var item = this.__lookupTable__P_529_0.getItem(row);

        if (this.isNode(item)) {
          if (this.isNodeOpen(item)) {
            this.closeNode(item);
          } else {
            this.openNode(item);
          }
        }
      },

      /**
       * Event handler for key press events. Open and close the current selected
       * item on key left and right press. Jump to parent on key left if already
       * closed.
       *
       * @param e {qx.event.type.KeySequence} key event.
       */
      _onKeyPress: function _onKeyPress(e) {
        var selection = this.getSelection();

        if (selection.getLength() > 0) {
          var item = selection.getItem(0);
          var isNode = this.isNode(item);

          switch (e.getKeyIdentifier()) {
            case "Left":
              if (isNode && this.isNodeOpen(item)) {
                this.closeNode(item);
              } else {
                var parent = this.getParent(item);

                if (parent != null) {
                  selection.splice(0, 1, parent);
                }
              }

              break;

            case "Right":
              if (isNode && !this.isNodeOpen(item)) {
                this.openNode(item);
              } else {
                if (isNode) {
                  var children = item.get(this.getChildProperty());

                  if (children != null && children.getLength() > 0) {
                    selection.splice(0, 1, children.getItem(0));
                  }
                }
              }

              break;

            case "Enter":
            case "Space":
              if (!isNode) {
                return;
              }

              if (this.isNodeOpen(item)) {
                this.closeNode(item);
              } else {
                this.openNode(item);
              }

              break;
          }
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTION HOOK METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Hook method which is called from the {@link qx.ui.virtual.selection.MModel}.
       * The hook method sets the first visible parent not as new selection when
       * the current selection is empty and the selection mode is one selection.
       *
       * @param newSelection {Array} The newSelection which will be set to the selection manager.
       */
      _beforeApplySelection: function _beforeApplySelection(newSelection) {
        if (newSelection.length === 0 && this.getSelectionMode() === "one") {
          var visibleParent = this.__getVisibleParent__P_529_9();

          var row = this.getLookupTable().indexOf(visibleParent);

          if (row >= 0) {
            newSelection.push(row);
          }
        }
      },

      /**
       * Hook method which is called from the {@link qx.ui.virtual.selection.MModel}.
       * The hook method builds the parent chain form the current selected item.
       */
      _afterApplySelection: function _afterApplySelection() {
        var selection = this.getSelection();

        if (selection.getLength() > 0 && this.getSelectionMode() === "one") {
          this.__buildParentChain__P_529_10(selection.getItem(0));
        } else {
          this.__parentChain__P_529_4 = [];
        }
      },

      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Helper method to apply model changes. Normally build the lookup table and
       * apply the default selection.
       */
      __applyModelChanges__P_529_8: function __applyModelChanges__P_529_8() {
        this.buildLookupTable();

        this._applyDefaultSelection();
      },

      /**
       * Helper method to build the internal data structure.
       *
       * @internal
       */
      buildLookupTable: function buildLookupTable() {
        if (this.getModel() != null && (this.getChildProperty() == null || this.getLabelPath() == null)) {
          throw new Error("Could not build tree, because 'childProperty' and/or 'labelPath' is 'null'!");
        }

        this._itemWidth = 0;
        var lookupTable = [];
        this.__nestingLevel__P_529_2 = [];
        var nestedLevel = -1;
        var root = this.getModel();

        if (root != null) {
          if (!this.isHideRoot()) {
            nestedLevel++;
            lookupTable.push(root);

            this.__nestingLevel__P_529_2.push(nestedLevel);
          }

          if (this.isNodeOpen(root)) {
            var visibleChildren = this.__getVisibleChildrenFrom__P_529_11(root, nestedLevel);

            lookupTable = lookupTable.concat(visibleChildren);
          }
        }

        if (!qx.lang.Array.equals(this.__lookupTable__P_529_0.toArray(), lookupTable)) {
          this._provider.removeBindings();

          this.__lookupTable__P_529_0.removeAll();

          this.__lookupTable__P_529_0.append(lookupTable);

          this.__updateRowCount__P_529_12();

          this._updateSelection();
        }
      },

      /**
       * Helper method to get all visible children form the passed parent node.
       * The algorithm implements a depth-first search with a complexity:
       * <code>O(n)</code> and <code>n</code> are all visible items.
       *
       * @param node {qx.core.Object} The start node to start search.
       * @param nestedLevel {Integer} The nested level from the start node.
       * @return {Array} All visible children form the parent.
       */
      __getVisibleChildrenFrom__P_529_11: function __getVisibleChildrenFrom__P_529_11(node, nestedLevel) {
        var visible = [];
        nestedLevel++;

        if (!this.isNode(node)) {
          return visible;
        }

        var children = node.get(this.getChildProperty());

        if (children == null) {
          return visible;
        } // clone children to keep original model unmodified


        children = children.copy();
        var delegate = this.getDelegate();
        var filter = qx.util.Delegate.getMethod(delegate, "filter");
        var sorter = qx.util.Delegate.getMethod(delegate, "sorter");

        if (sorter != null) {
          children.sort(sorter);
        }

        for (var i = 0; i < children.getLength(); i++) {
          var child = children.getItem(i);

          if (filter && !filter(child)) {
            continue;
          }

          if (this.isNode(child)) {
            this.__nestingLevel__P_529_2.push(nestedLevel);

            visible.push(child);

            if (this.isNodeOpen(child)) {
              var visibleChildren = this.__getVisibleChildrenFrom__P_529_11(child, nestedLevel);

              visible = visible.concat(visibleChildren);
            }
          } else {
            if (this.isShowLeafs()) {
              this.__nestingLevel__P_529_2.push(nestedLevel);

              visible.push(child);
            }
          }
        } // dispose children clone


        children.dispose();
        return visible;
      },

      /**
       * Helper method to set the node to the open nodes data structure when it
       * is not included.
       *
       * @param node {qx.core.Object} Node to set to open nodes.
       */
      __openNode__P_529_6: function __openNode__P_529_6(node) {
        if (!this.__openNodes__P_529_1.includes(node)) {
          this.__openNodes__P_529_1.push(node);

          this.fireDataEvent("open", node);
        }
      },

      /**
       * Helper method to set the target node and all his parents to the open
       * nodes data structure. The algorithm implements a depth-first search with
       * a complexity: <code>O(n)</code> and <code>n</code> are all model items.
       *
       * @param startNode {qx.core.Object} Start (root) node to search.
       * @param targetNode {qx.core.Object} Target node to open (and his parents).
       * @return {Boolean} <code>True</code> when the targetNode and his
       *  parents could opened, <code>false</code> otherwise.
       */
      __openNodeAndAllParents__P_529_7: function __openNodeAndAllParents__P_529_7(startNode, targetNode) {
        if (startNode === targetNode) {
          this.__openNode__P_529_6(targetNode);

          return true;
        }

        if (!this.isNode(startNode)) {
          return false;
        }

        var children = startNode.get(this.getChildProperty());

        if (children == null) {
          return false;
        }

        for (var i = 0; i < children.getLength(); i++) {
          var child = children.getItem(i);

          var result = this.__openNodeAndAllParents__P_529_7(child, targetNode);

          if (result === true) {
            this.__openNode__P_529_6(child);

            return true;
          }
        }

        return false;
      },

      /**
       * Helper method to update the row count.
       */
      __updateRowCount__P_529_12: function __updateRowCount__P_529_12() {
        this.getPane().getRowConfig().setItemCount(this.__lookupTable__P_529_0.getLength());
        this.getPane().fullUpdate();
      },

      /**
       * Helper method to get the parent node. Node! This only works with leaf and
       * nodes which are in the internal lookup table.
       *
       * @param item {qx.core.Object} Node or leaf to get parent.
       * @return {qx.core.Object|null} The parent note or <code>null</code> when
       *   no parent found.
       *
       * @internal
       */
      getParent: function getParent(item) {
        var index = this.__lookupTable__P_529_0.indexOf(item);

        if (index < 0) {
          return null;
        }

        var level = this.__nestingLevel__P_529_2[index];

        while (index > 0) {
          index--;
          var levelBefore = this.__nestingLevel__P_529_2[index];

          if (levelBefore < level) {
            return this.__lookupTable__P_529_0.getItem(index);
          }
        }

        return null;
      },

      /**
       * Builds the parent chain form the passed item.
       *
       * @param item {var} Item to build parent chain.
       */
      __buildParentChain__P_529_10: function __buildParentChain__P_529_10(item) {
        this.__parentChain__P_529_4 = [];
        var parent = this.getParent(item);

        while (parent != null) {
          this.__parentChain__P_529_4.unshift(parent);

          parent = this.getParent(parent);
        }
      },

      /**
       * Return the first visible parent node from the last selected node.
       *
       * @return {var} The first visible node.
       */
      __getVisibleParent__P_529_9: function __getVisibleParent__P_529_9() {
        if (this.__parentChain__P_529_4 == null) {
          return this.getModel();
        }

        var lookupTable = this.getLookupTable();

        var parent = this.__parentChain__P_529_4.pop();

        while (parent != null) {
          if (lookupTable.contains(parent)) {
            return parent;
          }

          parent = this.__parentChain__P_529_4.pop();
        }

        return this.getModel();
      }
    },
    destruct: function destruct() {
      if (this._openCloseController) {
        this._openCloseController.dispose();
      }

      var pane = this.getPane();

      if (pane != null) {
        if (pane.hasListener("cellDbltap")) {
          pane.removeListener("cellDbltap", this._onOpen, this);
        }

        if (pane.hasListener("cellTap")) {
          pane.removeListener("cellTap", this._onOpen, this);
        }
      }

      if (!qx.core.ObjectRegistry.inShutDown && this.__deferredCall__P_529_3 != null) {
        this.__deferredCall__P_529_3.cancel();

        this.__deferredCall__P_529_3.dispose();
      }

      var model = this.getModel();

      if (model != null) {
        model.removeListener("changeBubble", this._onChangeBubble, this);
      }

      this._layer.removeListener("updated", this._onUpdated, this);

      this._layer.destroy();

      this._provider.dispose();

      this.__lookupTable__P_529_0.dispose();

      this._layer = this._provider = this.__lookupTable__P_529_0 = this.__openNodes__P_529_1 = this.__deferredCall__P_529_3 = null;
    }
  });
  qx.ui.tree.VirtualTree.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "construct": true,
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Cajus Pollmeier
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Cajus Pollmeier
       * Derrell Lipman
  
  ************************************************************************ */

  /**
   * Because of the virtual nature of the VirtualTree, and the fact that
   * rendering occurs asynchronously, it is not a simple matter to bind a
   * property in the model that will open or close branches in the
   * tree. Instead, this controller listens to both the model and the tree, and
   * synchronizes the openness of branches in the tree.
   * 
   * To use this controller, simply instantiate it with the requisite
   * constructor arguments.
   */
  qx.Class.define("qx.ui.tree.core.OpenCloseController", {
    extend: qx.core.Object,

    /**
     * @param tree {qx.ui.tree.VirtualTree}
     *   The tree whose branch open or closed state is to be synchronized to a
     *   model property.
     * 
     * @param rootModel {qx.data.Array}
     *   The tree root model wherein a property is to be synchronized to the
     *   tree branches' open or closed states
     */
    construct: function construct(tree, rootModel) {
      var openProperty = tree.getOpenProperty();
      qx.core.Object.constructor.call(this); // Save the tree and initialize storage of listener IDs

      this._tree = tree;
      this._lids = []; // Sync tree nodes

      var sync = function (node) {
        if (qx.Class.hasProperty(node.constructor, "children")) {
          node.getChildren().forEach(sync);
        }

        if (qx.Class.hasProperty(node.constructor, openProperty)) {
          if (node.get(openProperty)) {
            tree.openNode(node);
          } else {
            tree.closeNode(node);
          }
        }
      }.bind(this);

      sync(rootModel); // Wire change listeners

      var lid = tree.addListener("open", this._onOpen, this);

      this._lids.push([tree, lid]);

      lid = tree.addListener("close", this._onClose, this);

      this._lids.push([tree, lid]);

      lid = rootModel.addListener("changeBubble", this._onChangeBubble, this);

      this._lids.push([rootModel, lid]);
    },
    members: {
      /** The tree which is synced to the model */
      _tree: null,

      /** Listener IDs that we manage */
      _lids: null,
      // event listener for "open" on the tree
      _onOpen: function _onOpen(ev) {
        ev.getData().set(this._tree.getOpenProperty(), true);
      },
      // event listener for "close" on the tree
      _onClose: function _onClose(ev) {
        ev.getData().set(this._tree.getOpenProperty(), false);
      },
      // event listener for model changes
      _onChangeBubble: function _onChangeBubble(ev) {
        var index;
        var item;
        var isOpen;
        var bubble = ev.getData(); // Extract the index of the current item

        index = bubble.name.replace(/.*\[([0-9]+)\]$/, "$1"); // Retrieve that indexed array item if it's an array; otherwise the item itself

        item = bubble.item.getItem ? bubble.item.getItem(index) : bubble.item; // If this item isn't being deleted and has an open property...

        if (item && qx.Class.hasProperty(item.constructor, this._tree.getOpenProperty())) {
          // ... then find out if this branch is open
          isOpen = item.get(this._tree.getOpenProperty()); // Open or close the tree branch as necessary

          if (isOpen && !this._tree.isNodeOpen(item)) {
            this._tree.openNode(item);
          } else if (!isOpen && this._tree.isNodeOpen(item)) {
            this._tree.closeNode(item);
          }
        } // Rebuild the internal lookup table


        this._tree.refresh();
      }
    },
    destruct: function destruct() {
      this._tree = null;

      this._lids.forEach(function (data) {
        data[0].removeListenerById(data[1]);
      });
    }
  });
  qx.ui.tree.core.OpenCloseController.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * This interface needs to implemented from all {@link qx.ui.tree.VirtualTree}
   * providers.
   *
   * @internal
   */
  qx.Interface.define("qx.ui.tree.provider.IVirtualTreeProvider", {
    members: {
      /**
       * Creates a layer for node and leaf rendering.
       *
       * @return {qx.ui.virtual.layer.Abstract} new layer.
       */
      createLayer: function createLayer() {},

      /**
       * Creates a renderer for rendering.
       *
       * @return {var} new node renderer.
       */
      createRenderer: function createRenderer() {},

      /**
       * Sets the name of the property, where the children are stored in the model.
       *
       * @param value {String} The child property name.
       */
      setChildProperty: function setChildProperty(value) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertString(value);
      },

      /**
       * Sets the name of the property, where the value for the tree folders label
       * is stored in the model classes.
       *
       * @param value {String} The label path.
       */
      setLabelPath: function setLabelPath(value) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertString(value);
      },

      /**
       * Styles a selected item.
       *
       * @param row {Integer} row to style.
       */
      styleSelectabled: function styleSelectabled(row) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInteger(row);
      },

      /**
       * Styles a not selected item.
       *
       * @param row {Integer} row to style.
       */
      styleUnselectabled: function styleUnselectabled(row) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInteger(row);
      },

      /**
       * Returns if the passed row can be selected or not.
       *
       * @param row {Integer} row to select.
       * @return {Boolean} <code>true</code> when the row can be selected,
       *    <code>false</code> otherwise.
       */
      isSelectable: function isSelectable(row) {
        this.assertArgumentsCount(arguments, 1, 1);
        this.assertInteger(row);
      }
    }
  });
  qx.ui.tree.provider.IVirtualTreeProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.data.SingleValueBinding": {},
      "qx.util.OOUtil": {},
      "qx.util.Delegate": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The mixin controls the binding between model and item.
   *
   * @internal
   */
  qx.Mixin.define("qx.ui.tree.core.MWidgetController", {
    construct: function construct() {
      this.__boundItems__P_532_0 = [];
    },
    properties: {
      /**
       * The name of the property, where the value for the tree node/leaf label
       * is stored in the model classes.
       */
      labelPath: {
        check: "String",
        nullable: true
      },

      /**
       * The path to the property which holds the information that should be
       * shown as an icon.
       */
      iconPath: {
        check: "String",
        nullable: true
      },

      /**
       * A map containing the options for the label binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      labelOptions: {
        nullable: true
      },

      /**
       * A map containing the options for the icon binding. The possible keys
       * can be found in the {@link qx.data.SingleValueBinding} documentation.
       */
      iconOptions: {
        nullable: true
      },

      /**
       * The name of the property, where the children are stored in the model.
       * Instead of the {@link #labelPath} must the child property a direct
       * property form the model instance.
       */
      childProperty: {
        check: "String",
        nullable: true
      },

      /**
       * Delegation object, which can have one or more functions defined by the
       * {@link qx.ui.tree.core.IVirtualTreeDelegate} interface.
       */
      delegate: {
        event: "changeDelegate",
        init: null,
        nullable: true
      }
    },
    members: {
      /** @type {Array} which contains the bounded items */
      __boundItems__P_532_0: null,

      /**
       * Helper-Method for binding the default properties from the model to the
       * target widget. The used default properties  depends on the passed item.
       *
       * This method should only be called in the {@link IVirtualTreeDelegate#bindItem}
       * function implemented by the {@link #delegate} property.
       *
       * @param item {qx.ui.core.Widget} The internally created and used node or
       *   leaf.
       * @param index {Integer} The index of the item (node or leaf).
       */
      bindDefaultProperties: function bindDefaultProperties(item, index) {
        // bind model first
        this.bindProperty("", "model", null, item, index);
        this.bindProperty(this.getLabelPath(), "label", this.getLabelOptions(), item, index);

        var bindPath = this.__getBindPath__P_532_1(index);

        var bindTarget = this._tree.getLookupTable();

        bindTarget = qx.data.SingleValueBinding.resolvePropertyChain(bindTarget, bindPath);

        if (qx.util.OOUtil.hasProperty(bindTarget.constructor, this.getChildProperty())) {
          this.bindProperty(this.getChildProperty() + ".length", "appearance", {
            converter: function converter() {
              return "virtual-tree-folder";
            }
          }, item, index);
        } else {
          item.setAppearance("virtual-tree-file");
        }

        if (this.getIconPath() != null) {
          this.bindProperty(this.getIconPath(), "icon", this.getIconOptions(), item, index);
        }
      },

      /**
       * Helper-Method for binding a given property from the model to the target
       * widget.
       *
       * This method should only be called in the {@link IVirtualTreeDelegate#bindItem}
       * function implemented by the {@link #delegate} property.
       *
       * @param sourcePath {String | null} The path to the property in the model.
       *   If you use an empty string, the whole model item will be bound.
       * @param targetProperty {String} The name of the property in the target widget.
       * @param options {Map | null} The options to use for the binding.
       * @param targetWidget {qx.ui.core.Widget} The target widget.
       * @param index {Integer} The index of the current binding.
       */
      bindProperty: function bindProperty(sourcePath, targetProperty, options, targetWidget, index) {
        var bindPath = this.__getBindPath__P_532_1(index, sourcePath);

        var bindTarget = this._tree.getLookupTable();

        var id = bindTarget.bind(bindPath, targetWidget, targetProperty, options);

        this.__addBinding__P_532_2(targetWidget, id);
      },

      /**
       * Helper-Method for binding a given property from the target widget to
       * the model.
       * This method should only be called in the
       * {@link qx.ui.tree.core.IVirtualTreeDelegate#bindItem} function implemented by the
       * {@link #delegate} property.
       *
       * @param targetPath {String | null} The path to the property in the model.
       * @param sourceProperty {String} The name of the property in the target.
       * @param options {Map | null} The options to use for the binding.
       * @param sourceWidget {qx.ui.core.Widget} The source widget.
       * @param index {Integer} The index of the current binding.
       */
      bindPropertyReverse: function bindPropertyReverse(targetPath, sourceProperty, options, sourceWidget, index) {
        var bindPath = this.__getBindPath__P_532_1(index, targetPath);

        var bindTarget = this._tree.getLookupTable();

        var id = sourceWidget.bind(sourceProperty, bindTarget, bindPath, options);

        this.__addBinding__P_532_2(sourceWidget, id);
      },

      /**
       * Remove all bindings from all bounded items.
       */
      removeBindings: function removeBindings() {
        while (this.__boundItems__P_532_0.length > 0) {
          var item = this.__boundItems__P_532_0.pop();

          this._removeBindingsFrom(item);
        }
      },

      /**
       * Sets up the binding for the given item and index.
       *
       * @param item {qx.ui.core.Widget} The internally created and used item.
       * @param index {Integer} The index of the item.
       */
      _bindItem: function _bindItem(item, index) {
        var bindItem = qx.util.Delegate.getMethod(this.getDelegate(), "bindItem");

        if (bindItem != null) {
          bindItem(this, item, index);
        } else {
          this.bindDefaultProperties(item, index);
        }
      },

      /**
       * Removes the binding of the given item.
       *
       * @param item {qx.ui.core.Widget} The item which the binding should be
       *   removed.
       */
      _removeBindingsFrom: function _removeBindingsFrom(item) {
        var bindings = this.__getBindings__P_532_3(item);

        while (bindings.length > 0) {
          var id = bindings.pop();

          try {
            this._tree.getLookupTable().removeBinding(id);
          } catch (e) {
            item.removeBinding(id);
          }
        }

        if (this.__boundItems__P_532_0.includes(item)) {
          qx.lang.Array.remove(this.__boundItems__P_532_0, item);
        }
      },

      /**
       * Helper method to create the path for binding.
       *
       * @param index {Integer} The index of the item.
       * @param path {String|null} The path to the property.
       * @return {String} The binding path
       */
      __getBindPath__P_532_1: function __getBindPath__P_532_1(index, path) {
        var bindPath = "[" + index + "]";

        if (path != null && path != "") {
          bindPath += "." + path;
        }

        return bindPath;
      },

      /**
       * Helper method to save the binding for the widget.
       *
       * @param widget {qx.ui.core.Widget} widget to save binding.
       * @param id {var} the id from the binding.
       */
      __addBinding__P_532_2: function __addBinding__P_532_2(widget, id) {
        var bindings = this.__getBindings__P_532_3(widget);

        if (!bindings.includes(id)) {
          bindings.push(id);
        }

        if (!this.__boundItems__P_532_0.includes(widget)) {
          this.__boundItems__P_532_0.push(widget);
        }
      },

      /**
       * Helper method which returns all bound id from the widget.
       *
       * @param widget {qx.ui.core.Widget} widget to get all binding.
       * @return {Array} all bound id's.
       */
      __getBindings__P_532_3: function __getBindings__P_532_3(widget) {
        var bindings = widget.getUserData("BindingIds");

        if (bindings == null) {
          bindings = [];
          widget.setUserData("BindingIds", bindings);
        }

        return bindings;
      }
    },
    destruct: function destruct() {
      this.__boundItems__P_532_0 = null;
    }
  });
  qx.ui.tree.core.MWidgetController.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.IWidgetCellProvider": {
        "require": true
      },
      "qx.ui.tree.provider.IVirtualTreeProvider": {
        "require": true
      },
      "qx.ui.tree.core.MWidgetController": {
        "require": true
      },
      "qx.ui.core.queue.Widget": {},
      "qx.ui.virtual.layer.WidgetCell": {},
      "qx.util.Delegate": {},
      "qx.ui.tree.VirtualTreeItem": {},
      "qx.ui.virtual.cell.WidgetCell": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The provider implements the {@link qx.ui.virtual.core.IWidgetCellProvider}
   * API, which can be used as delegate for the widget cell rendering and it
   * provides a API to bind the model with the rendered item.
   *
   * @internal
   */
  qx.Class.define("qx.ui.tree.provider.WidgetProvider", {
    extend: qx.core.Object,
    implement: [qx.ui.virtual.core.IWidgetCellProvider, qx.ui.tree.provider.IVirtualTreeProvider],
    include: [qx.ui.tree.core.MWidgetController],

    /**
     * @param tree {qx.ui.tree.VirtualTree} tree to provide.
     */
    construct: function construct(tree) {
      qx.core.Object.constructor.call(this);
      this._tree = tree;
      this.addListener("changeDelegate", this._onChangeDelegate, this);

      this._onChangeDelegate();
    },
    members: {
      /** @type {qx.ui.tree.VirtualTree} tree to provide. */
      _tree: null,

      /** @type {qx.ui.virtual.cell.WidgetCell} the used item renderer. */
      _renderer: null,

      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */
      // interface implementation
      getCellWidget: function getCellWidget(row, column) {
        var item = this._tree.getLookupTable().getItem(row);

        var hasChildren = false;

        if (this._tree.isNode(item)) {
          hasChildren = this._tree.hasChildren(item);
        }

        var widget = this._renderer.getCellWidget();

        widget.setOpen(hasChildren && this._tree.isNodeOpen(item));
        widget.addListener("changeOpen", this.__onOpenChanged__P_533_0, this);
        widget.setUserData("cell.childProperty", this.getChildProperty());
        widget.setUserData("cell.showLeafs", this._tree.isShowLeafs());

        if (this._tree.getSelection().contains(item)) {
          this._styleSelectabled(widget);
        } else {
          this._styleUnselectabled(widget);
        }

        var level = this._tree.getLevel(row);

        if (!this._tree.isShowTopLevelOpenCloseIcons()) {
          level -= 1;
        }

        widget.setUserData("cell.level", level);

        if (!this._tree.isShowTopLevelOpenCloseIcons() && level == -1) {
          widget.setOpenSymbolMode("never");
        } else {
          widget.setOpenSymbolMode("auto");
        }

        if (this._tree.getOpenProperty()) {
          widget.setModel(item);
        }

        this._bindItem(widget, row);

        qx.ui.core.queue.Widget.add(widget);
        return widget;
      },
      // interface implementation
      poolCellWidget: function poolCellWidget(widget) {
        widget.removeListener("changeOpen", this.__onOpenChanged__P_533_0, this);

        this._removeBindingsFrom(widget);

        this._renderer.pool(widget);

        this._onPool(widget);
      },
      // Interface implementation
      createLayer: function createLayer() {
        return new qx.ui.virtual.layer.WidgetCell(this);
      },
      // Interface implementation
      createRenderer: function createRenderer() {
        var createItem = qx.util.Delegate.getMethod(this.getDelegate(), "createItem");

        if (createItem == null) {
          createItem = function createItem() {
            return new qx.ui.tree.VirtualTreeItem();
          };
        }

        var renderer = new qx.ui.virtual.cell.WidgetCell();
        renderer.setDelegate({
          createWidget: createItem
        });
        return renderer;
      },
      // interface implementation
      styleSelectabled: function styleSelectabled(row) {
        var widget = this._tree._layer.getRenderedCellWidget(row, 0);

        this._styleSelectabled(widget);
      },
      // interface implementation
      styleUnselectabled: function styleUnselectabled(row) {
        var widget = this._tree._layer.getRenderedCellWidget(row, 0);

        this._styleUnselectabled(widget);
      },
      // interface implementation
      isSelectable: function isSelectable(row) {
        var widget = this._tree._layer.getRenderedCellWidget(row, 0);

        if (widget != null) {
          return widget.isEnabled();
        } else {
          return true;
        }
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL API
      ---------------------------------------------------------------------------
      */

      /**
       * Styles a selected item.
       *
       * @param widget {qx.ui.core.Widget} widget to style.
       */
      _styleSelectabled: function _styleSelectabled(widget) {
        if (widget == null) {
          return;
        }

        this._renderer.updateStates(widget, {
          selected: 1
        });
      },

      /**
       * Styles a not selected item.
       *
       * @param widget {qx.ui.core.Widget} widget to style.
       */
      _styleUnselectabled: function _styleUnselectabled(widget) {
        if (widget == null) {
          return;
        }

        this._renderer.updateStates(widget, {});
      },

      /**
       * Calls the delegate <code>onPool</code> method when it is used in the
       * {@link #delegate} property.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      _onPool: function _onPool(item) {
        var onPool = qx.util.Delegate.getMethod(this.getDelegate(), "onPool");

        if (onPool != null) {
          onPool(item);
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLERS
      ---------------------------------------------------------------------------
      */

      /**
       * Event handler for the created item's.
       *
       * @param event {qx.event.type.Data} fired event.
       */
      _onItemCreated: function _onItemCreated(event) {
        var configureItem = qx.util.Delegate.getMethod(this.getDelegate(), "configureItem");

        if (configureItem != null) {
          var leaf = event.getData();
          configureItem(leaf);
        }
      },

      /**
       * Event handler for the change delegate event.
       *
       * @param event {qx.event.type.Data} fired event.
       */
      _onChangeDelegate: function _onChangeDelegate(event) {
        if (this._renderer != null) {
          this._renderer.dispose();

          this.removeBindings();
        }

        this._renderer = this.createRenderer();

        this._renderer.addListener("created", this._onItemCreated, this);
      },

      /**
       * Handler when a node changes opened or closed state.
       *
       * @param event {qx.event.type.Data} The data event.
       */
      __onOpenChanged__P_533_0: function __onOpenChanged__P_533_0(event) {
        var widget = event.getTarget();
        var row = widget.getUserData("cell.row");

        var item = this._tree.getLookupTable().getItem(row);

        if (event.getData()) {
          this._tree.openNodeWithoutScrolling(item);
        } else {
          this._tree.closeNodeWithoutScrolling(item);
        }
      }
    },
    destruct: function destruct() {
      this.removeBindings();

      this._renderer.dispose();

      this._tree = this._renderer = null;
    }
  });
  qx.ui.tree.provider.WidgetProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * This utility class implements some methods for the <code>VirtualTree</code>.
   */
  qx.Class.define("qx.ui.tree.core.Util", {
    statics: {
      /**
       * Returns if the passed item is a node or a leaf.
       *
       * @param node {qx.core.Object} Node to check.
       * @param childProperty {String} The property name to find the children.
       * @return {Boolean} <code>True</code> when the passed item is a node,
       *   </code>false</code> when it is a leaf.
       */
      isNode: function isNode(node, childProperty) {
        if (node == null || childProperty == null) {
          return false;
        }

        return qx.Class.hasProperty(node.constructor, childProperty);
      },

      /**
       * Returns whether the node has visible children or not.
       *
       * @param node {qx.core.Object} Node to check.
       * @param childProperty {String} The property name to find the children.
       * @param ignoreLeafs {Boolean?} Indicates whether leafs are ignored. This means when it is set to
       *    <code>true</code> a node which contains only leafs has no children. The default value is <code>false</code>.
       * @return {Boolean} <code>True</code> when the node has visible children,
       *   <code>false</code> otherwise.
       */
      hasChildren: function hasChildren(node, childProperty, ignoreLeafs) {
        if (node == null || childProperty == null || !this.isNode(node, childProperty)) {
          return false;
        }

        var children = node.get(childProperty);

        if (children == null) {
          return false;
        }

        if (!ignoreLeafs) {
          return children.length > 0;
        } else {
          for (var i = 0; i < children.getLength(); i++) {
            var child = children.getItem(i);

            if (this.isNode(child, childProperty)) {
              return true;
            }
          }
        }

        return false;
      }
    }
  });
  qx.ui.tree.core.Util.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.tree.core.AbstractItem": {
        "require": true
      },
      "qx.ui.tree.core.Util": {},
      "qx.lang.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * The tree item is a tree element for the {@link VirtualTree}, which can have
   * nested tree elements.
   */
  qx.Class.define("qx.ui.tree.VirtualTreeItem", {
    extend: qx.ui.tree.core.AbstractItem,
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "virtual-tree-folder"
      }
    },
    members: {
      // overridden

      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates: {
        selected: true
      },
      // overridden
      _addWidgets: function _addWidgets() {
        this.addSpacer();
        this.addOpenButton();
        this.addIcon();
        this.addLabel();
      },
      // overridden
      _shouldShowOpenSymbol: function _shouldShowOpenSymbol() {
        var open = this.getChildControl("open", true);

        if (open == null) {
          return false;
        }

        return this.isOpenable();
      },
      // overridden
      getLevel: function getLevel() {
        return this.getUserData("cell.level");
      },
      // overridden
      hasChildren: function hasChildren() {
        var model = this.getModel();
        var childProperty = this.getUserData("cell.childProperty");
        var showLeafs = this.getUserData("cell.showLeafs");
        return qx.ui.tree.core.Util.hasChildren(model, childProperty, !showLeafs);
      },
      // apply method
      _applyModel: function _applyModel(value, old) {
        var childProperty = this.getUserData("cell.childProperty");
        var showLeafs = this.getUserData("cell.showLeafs");

        if (value != null && qx.ui.tree.core.Util.isNode(value, childProperty)) {
          var eventType = "change" + qx.lang.String.firstUp(childProperty); // listen to children property changes

          if (qx.Class.hasProperty(value.constructor, childProperty)) {
            value.addListener(eventType, this._onChangeChildProperty, this);
          } // children property has been set already, immediately add
          // listener for indent updating


          if (qx.ui.tree.core.Util.hasChildren(value, childProperty, !showLeafs)) {
            value.get(childProperty).addListener("changeLength", this._onChangeLength, this);

            this._updateIndent();
          }
        }

        if (old != null && qx.ui.tree.core.Util.isNode(old, childProperty)) {
          var eventType = "change" + qx.lang.String.firstUp(childProperty);
          old.removeListener(eventType, this._onChangeChildProperty, this);
          var oldChildren = old.get(childProperty);

          if (oldChildren) {
            oldChildren.removeListener("changeLength", this._onChangeLength, this);
          }
        }
      },

      /**
       * Handler to update open/close icon when model length changed.
       */
      _onChangeLength: function _onChangeLength() {
        this._updateIndent();
      },

      /**
       * Handler to add listener to array of children property.
       *
       * @param e {qx.event.type.Data} Data event; provides children array
       */
      _onChangeChildProperty: function _onChangeChildProperty(e) {
        var children = e.getData();
        var old = e.getOldData();

        if (children) {
          this._updateIndent();

          children.addListener("changeLength", this._onChangeLength, this);
        }

        if (old) {
          old.removeListener("changeLength", this._onChangeLength, this);
        }
      }
    }
  });
  qx.ui.tree.VirtualTreeItem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Objects which are used as delegates for the <code>qx.ui.tree.VirtualTree</code> may
   * implement any of the methods described in this interface. The delegate does
   * not need to implement all the methods of this interface. If a method is not
   * implemented the <code>qx.ui.tree.VirtualTree</code> provides a default
   * implementation.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * actually implemented.
   */
  qx.Interface.define("qx.ui.tree.core.IVirtualTreeDelegate", {
    members: {
      /**
       * Gives the user the opportunity to set individual styles and properties
       * on the widget cells created by the controller.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      configureItem: function configureItem(item) {},

      /**
       * Creates a widget cell which will be used for rendering. Be sure to
       * implement the {@link #bindItem} function as well to get the needed
       * properties bound.
       *
       * @return {qx.ui.core.Widget} A new created item cell.
       */
      createItem: function createItem() {},

      /**
       * Sets up the binding for the given widget cell and index.
       *
       * For every property you want to bind, use
       * {@link MWidgetController#bindProperty} like this:
       * <code>
       * controller.bindProperty(null, "value", options, item, id);
       * </code>
       *
       * @param controller {qx.ui.list.core.MWidgetController} The currently used controller.
       * @param item {qx.ui.core.Widget} The created and used item.
       * @param id {Integer} The id for the binding.
       */
      bindItem: function bindItem(controller, item, id) {},

      /**
       * Gives the user the opportunity to reset properties or states.
       *
       * @param item {qx.ui.core.Widget} Item to modify.
       */
      onPool: function onPool(item) {},

      /**
       * Filter checks the current data and returns a boolean if the data should
       * appear in the filtered data set or not.
       *
       * @param data {var} The data which will be checked.
       * @return {Boolean} True, if the data passes the filter, false otherwise.
       */
      filter: function filter(data) {},

      /**
       * Gives the user the opportunity to sort the children items from a node.
       * The sorting method should return a negative value if a < b, zero
       * if a = b, or a positive value if a > b.
       *
       * @param a {var} value to compare.
       * @param b {var} value to compare.
       * @return {Integer} should return a negative value if a < b, zero
       *   if a = b, or a positive value if a > b.
       */
      sorter: function sorter(a, b) {}
    }
  });
  qx.ui.tree.core.IVirtualTreeDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Default": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * The default data cell renderer for a virtual tree (columns other than the
   * tree column)
   */
  qx.Class.define("qx.ui.treevirtual.DefaultDataCellRenderer", {
    extend: qx.ui.table.cellrenderer.Default
  });
  qx.ui.treevirtual.DefaultDataCellRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A set of methods which may be used to retrieve various siblings of nodes.
   */
  qx.Mixin.define("qx.ui.treevirtual.MFamily", {
    members: {
      /**
       * Get the first child of the specified node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the first child is desired.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Integer}
       *   The node id of the first child.
       */
      familyGetFirstChild: function familyGetFirstChild(nodeReference) {
        var node;

        if (typeof nodeReference == "object") {
          node = nodeReference;
        } else if (typeof nodeReference == "number") {
          node = this.getTableModel().getData()[nodeReference];
        } else {
          throw new Error("Expected node object or node id");
        }

        if (node.children.length > 0) {
          return node.children[0];
        }

        return null;
      },

      /**
       * Get the last child of the specified node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the last child is desired.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Integer}
       *   The node id of the last child.
       */
      familyGetLastChild: function familyGetLastChild(nodeReference) {
        var node;

        if (typeof nodeReference == "object") {
          node = nodeReference;
        } else if (typeof nodeReference == "number") {
          node = this.getTableModel().getData()[nodeReference];
        } else {
          throw new Error("Expected node object or node id");
        }

        if (node.children.length > 0) {
          return node.children[node.children.length - 1];
        }

        return null;
      },

      /**
       * Get the next sibling of the specified node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the next sibling is desired.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Integer}
       *   The node id of the next sibling.
       */
      familyGetNextSibling: function familyGetNextSibling(nodeReference) {
        var node;
        var nodeId;
        var nodes = this.getTableModel().getData();

        if (typeof nodeReference == "object") {
          node = nodeReference;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
          node = nodes[nodeId];
        } else {
          throw new Error("Expected node object or node id");
        }

        var myNodeId = node.nodeId;
        var parentChildren = nodes[node.parentNodeId].children; // Find this node id in our parent's children array

        for (var i = 0; i < parentChildren.length; i++) {
          // Is this our id?
          if (parentChildren[i] == myNodeId) {
            // Yup.  Ensure there is a next sibling.
            if (i < parentChildren.length - 1) {
              // There is.  Return the next sibling.
              return parentChildren[i + 1];
            } // There's no next sibling


            return null;
          }
        }
      },

      /**
       * Get the previous sibling of the specified node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the previous sibling is desired.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Integer}
       *   The node id of the previous sibling.
       */
      familyGetPrevSibling: function familyGetPrevSibling(nodeReference) {
        var node;
        var nodeId;
        var nodes = this.getTableModel().getData();

        if (typeof nodeReference == "object") {
          node = nodeReference;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
          node = nodes[nodeId];
        } else {
          throw new Error("Expected node object or node id");
        }

        var myNodeId = node.nodeId;
        var parentChildren = nodes[node.parentNodeId].children; // Find this node id in our parent's children array

        for (var i = 0; i < parentChildren.length; i++) {
          // Is this our id?
          if (parentChildren[i] == myNodeId) {
            // Yup.  Ensure there is a previous sibling.
            if (i > 0) {
              // There is.  Return the previous sibling.
              return parentChildren[i - 1];
            } // There's no previous sibling


            return null;
          }
        }
      }
    }
  });
  qx.ui.treevirtual.MFamily.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Utility functions for working with nodes.  These methods allow reference
   * to a node by either the object itself or the object's node id.
   */
  qx.Mixin.define("qx.ui.treevirtual.MNode", {
    members: {
      /**
       * Get a node object given its node id.
       *
       * @param nodeReference {Object | Integer}
       *   The node to have its opened/closed state toggled.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.).
       *
       * @return {Object}
       *   If the nodeReference is a node object itself, that same node object
       *   is returned (identity).  Otherwise, the node object is looked up
       *   using the specified node id.
       */
      nodeGet: function nodeGet(nodeReference) {
        if (typeof nodeReference == "object") {
          return nodeReference;
        } else if (typeof nodeReference == "number") {
          return this.getTableModel().getData()[nodeReference];
        } else {
          throw new Error("Expected node object or node id");
        }
      },

      /**
       * Toggle the opened state of the node: if the node is opened, close
       * it; if it is closed, open it.
       *
       * @param nodeReference {Object | Integer}
       *   The node to have its opened/closed state toggled.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       */
      nodeToggleOpened: function nodeToggleOpened(nodeReference) {
        var node;
        var nodeId;

        if (typeof nodeReference == "object") {
          node = nodeReference;
          nodeId = node.nodeId;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
          node = this.getTableModel().getData()[nodeId];
        } else {
          throw new Error("Expected node object or node id");
        }

        this.getTableModel().setState(nodeId, {
          bOpened: !node.bOpened
        });
      },

      /**
       * Set state attributes of a tree node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which attributes are being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param attributes {Map}
       *   Map with the node properties to be set.  The map may contain any of
       *   the properties described in
       *   {@link qx.ui.treevirtual.SimpleTreeDataModel}
       *
       */
      nodeSetState: function nodeSetState(nodeReference, attributes) {
        var nodeId;

        if (typeof nodeReference == "object") {
          nodeId = nodeReference.nodeId;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
        } else {
          throw new Error("Expected node object or node id");
        }

        this.getTableModel().setState(nodeId, attributes);
      },

      /**
       * Set the label for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the label is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param label {String}
       *   The new label for the specified node
       *
       */
      nodeSetLabel: function nodeSetLabel(nodeReference, label) {
        this.nodeSetState(nodeReference, {
          label: label
        });
      },

      /**
       * Get the label for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the label is being retrieved.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {String}
       *   The label for the specified node
       */
      nodeGetLabel: function nodeGetLabel(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.label;
      },

      /**
       * Set the selected state for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the selected state is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param b {Boolean}
       *   The new selected state for the specified node.
       *
       */
      nodeSetSelected: function nodeSetSelected(nodeReference, b) {
        this.nodeSetState(nodeReference, {
          bSelected: b
        });
      },

      /**
       * Get the selected state for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the selected state is being retrieved.  The node
       *   can be represented either by the node object, or the node id (as
       *   would have been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Boolean}
       *   The selected state for the specified node.
       */
      nodeGetSelected: function nodeGetSelected(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.bSelected;
      },

      /**
       * Set the opened state for a node.  (Note that this method has no effect
       * if the requested state is the same as the current state.)
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the opened state is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param b {Boolean}
       *   The new opened state for the specified node.
       *
       */
      nodeSetOpened: function nodeSetOpened(nodeReference, b) {
        var node;

        if (typeof nodeReference == "object") {
          node = nodeReference;
        } else if (typeof nodeReference == "number") {
          node = this.getTableModel().getData()[nodeReference];
        } else {
          throw new Error("Expected node object or node id");
        } // Only set new state if not already in the requested state, since
        // setting new state involves dispatching events.


        if (b != node.bOpened) {
          this.nodeToggleOpened(node);
        }
      },

      /**
       * Get the opened state for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the opened state is being retrieved.  The node can
       *   be represented either by the node object, or the node id (as would
       *   have been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Boolean}
       *   The opened state for the specified node.
       */
      nodeGetOpened: function nodeGetOpened(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.bOpened;
      },

      /**
       * Set the hideOpenClose state for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the hideOpenClose state is being set.  The node
       *   can be represented either by the node object, or the node id (as
       *   would have been returned by addBranch(), addLeaf(), etc.)
       *
       * @param b {Boolean}
       *   The new hideOpenClose state for the specified node.
       *
       */
      nodeSetHideOpenClose: function nodeSetHideOpenClose(nodeReference, b) {
        this.nodeSetState(nodeReference, {
          bHideOpenClose: b
        });
      },

      /**
       * Get the hideOpenClose state for a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the hideOpenClose state is being retrieved.  The
       *   node can be represented either by the node object, or the node id (as
       *   would have been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Boolean}
       *   The new hideOpenClose state for the specified node.
       */
      nodeGetHideOpenClose: function nodeGetHideOpenClose(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.bHideOpenClose;
      },

      /**
       * Set the icon for a node when in its unselected (normal) state.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the icon is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param path {String}
       *   The path to the icon to be used when the node is not selected
       *
       */
      nodeSetIcon: function nodeSetIcon(nodeReference, path) {
        this.nodeSetState(nodeReference, {
          icon: path
        });
      },

      /**
       * Get the icon for a node when in its unselected (normal) state.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the icon is being retrieved.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {String}
       *   The path to the icon to be used when the node is not selected, if a
       *   path has been previously provided (i.e. not using the default icon).
       */
      nodeGetIcon: function nodeGetIcon(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.icon;
      },

      /**
       * Set the icon for a node when in its selected state.
       * <p>
       * NOTE: As of 13 Mar 2009, this feature is disabled by default, by
       *       virtue of the fact that the tree's "alwaysUpdateCells" property
       *       has a setting of 'false' now instead of 'true'. Setting this
       *       property to true allows the icon to change upon selection, but
       *       causes problems such as single clicks not always selecting a
       *       row, and, in IE, double click operations failing
       *       completely. (For more information, see bugs 605 and 2021.) To
       *       re-enable the option to have an unique icon that is displayed
       *       when the node is selected, issue
       *       <code>tree.setAlwaysUpdateCells(true);</code>
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the icon is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param path {String}
       *   The path to the icon to be used when the node is selected
       *
       */
      nodeSetSelectedIcon: function nodeSetSelectedIcon(nodeReference, path) {
        this.nodeSetState(nodeReference, {
          iconSelected: path
        });
      },

      /**
       * Get the icon for a node when in its selected state.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the icon is being retrieved.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {String}
       *   The path to the icon to be used when the node is selected, if a path
       *   has been previously provided (i.e. not using the default icon).
       */
      nodeGetSelectedIcon: function nodeGetSelectedIcon(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.iconSelected;
      },

      /**
       * Set the cell style for a node
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the cell style is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param style {String}
        *   The CSS style to be applied for the tree column cell for this node,
       *   if a style has been previously provided (i.e. not using the default
       *   style).
       *
       */
      nodeSetCellStyle: function nodeSetCellStyle(nodeReference, style) {
        this.nodeSetState(nodeReference, {
          cellStyle: style
        });
      },

      /**
       * Get the cell style for a node
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the cell style is being retrieved.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {String}
       *   The CSS style being applied for the tree column cell for this node.
       */
      nodeGetCellStyle: function nodeGetCellStyle(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.cellStyle;
      },

      /**
       * Set the label style for a node
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the label style is being set.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @param style {String}
       *   The CSS style to be applied for the label for this node.
       *
       */
      nodeSetLabelStyle: function nodeSetLabelStyle(nodeReference, style) {
        this.nodeSetState(nodeReference, {
          labelStyle: style
        });
      },

      /**
       * Get the label style for a node
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the label style is being retrieved.  The node can
       *   be represented either by the node object, or the node id (as would
       *   have been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {String}
       *   The CSS style being applied for the label for this node, if a style
       *   has been previously provided (i.e. not using the default style).
       */
      nodeGetLabelStyle: function nodeGetLabelStyle(nodeReference) {
        var node = this.nodeGet(nodeReference);
        return node.cellStyle;
      }
    }
  });
  qx.ui.treevirtual.MNode.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2010 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * Primitives for building trees and tree nodes.
   *
   * The methods in this mixin are included directly in the SimpleTreeDataModel
   * but are also useful for other types of trees (not TreeVirtual) that need
   * similar tree and node creation.
   */
  qx.Mixin.define("qx.ui.treevirtual.MTreePrimitive", {
    statics: {
      /** Primitive types of tree nodes */
      Type: {
        LEAF: 1,
        BRANCH: 2
      },

      /**
       * Add a node to the tree.
       *
       * NOTE: This method is for <b>internal use</b> and should not be called by
       *       users of this class. There is no guarantee that the interface to this
       *       method will remain unchanged over time.
       *
       * @param nodeArr {Array|Map}
       *   The array to which new nodes are to be added. See, however, the
       *   nodeId parameter. If nodeId values will be provided, then nodeArr can
       *   be a map. The traditional TreeVirtual does not provide node ids, and
       *   passes an array for this parameter.
       *
       * @param parentNodeId {Integer}
       *   The node id of the parent of the node being added
       *
       * @param label {String}
       *   The string to display as the label for this node
       *
       * @param bOpened {Boolean}
       *   <i>true</i> if the tree should be rendered in its opened state;
       *   <i>false</i> otherwise.
       *
       * @param bHideOpenCloseButton {Boolean}
       *   <i>true</i> if the open/close button should be hidden (not displayed);
       *   </i>false</i> to display the open/close button for this node.
       *
       * @param type {Integer}
       *   The type of node being added.  The type determines whether children
       *   may be added, and determines the default icons to use.  This
       *   parameter must be one of the following values:
       *   <dl>
       *     <dt>qx.ui.treevirtual.MTreePrimitive.Type.BRANCH</dt>
       *     <dd>
       *       This node is a branch.  A branch node may have children.
       *     </dd>
       *     <dt>qx.ui.treevirtual.MTreePrimitive.Type.LEAF</dt>
       *     <dd>
       *       This node is a leaf, and may not have children
       *     </dd>
       *   </dl>
       *
       * @param icon {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is not a selected node.
       *
       * @param iconSelected {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is a selected node.
       *   <p>
       *   NOTE: As of 13 Mar 2009, this feature is disabled by default, by
       *         virtue of the fact that the tree's "alwaysUpdateCells" property
       *         has a setting of 'false' now instead of 'true'. Setting this
       *         property to true allows the icon to change upon selection, but
       *         causes problems such as single clicks not always selecting a
       *         row, and, in IE, double click operations failing
       *         completely. (For more information, see bugs 605 and 2021.) To
       *         re-enable the option to have an unique icon that is displayed
       *         when the node is selected, issue
       *         <code>tree.setAlwaysUpdateCells(true);</code>
       *
       * @param nodeId {Integer?}
       *   The requested node id for this new node. If not provided, nodeArr
       *   will be assumed to be an array, not a map, and the next available
       *   index of the array will be used. If it is provided, then nodeArr may
       *   be either an array or a map.
       *
       * @return {Integer} The node id of the newly-added node.
       *
       * @throws {Error} If one tries to add a child to a non-existent parent.
       * @throws {Error} If one tries to add a node to a leaf.
       */
      _addNode: function _addNode(nodeArr, parentNodeId, label, bOpened, bHideOpenCloseButton, type, icon, iconSelected, nodeId) {
        var parentNode; // Ensure that if parent was specified, it exists

        if (parentNodeId) {
          parentNode = nodeArr[parentNodeId];

          if (!parentNode) {
            throw new Error("Request to add a child to a non-existent parent");
          } // Ensure parent isn't a leaf


          if (parentNode.type == qx.ui.treevirtual.MTreePrimitive.Type.LEAF) {
            throw new Error("Sorry, a LEAF may not have children.");
          }
        } else {
          // This is a child of the root
          parentNode = nodeArr[0];
          parentNodeId = 0;
        } // If this is a leaf, we don't present open/close icon


        if (type == qx.ui.treevirtual.MTreePrimitive.Type.LEAF) {
          // mask off the opened bit but retain the hide open/close button bit
          bOpened = false;
          bHideOpenCloseButton = false;
        } // Determine the node id of this new node


        if (nodeId === undefined) {
          nodeId = nodeArr.length;
        } // Set the data for this node.


        var node = {
          type: type,
          nodeId: nodeId,
          parentNodeId: parentNodeId,
          label: label,
          bSelected: false,
          bOpened: bOpened,
          bHideOpenClose: bHideOpenCloseButton,
          bCanEdit: true,
          icon: icon,
          iconSelected: iconSelected,
          children: [],
          columnData: []
        }; // Add this node to the array

        nodeArr[nodeId] = node; // Add this node to its parent's child array.

        parentNode.children.push(nodeId); // Return the node id we just added

        return nodeId;
      },

      /**
       * An empty tree contains only this one node
       *
       * @return {Map}
       *   Returns a root node with all relevant fields filled.
       */
      _getEmptyTree: function _getEmptyTree() {
        return {
          label: "<virtual root>",
          nodeId: 0,
          bOpened: true,
          children: []
        };
      }
    }
  });
  qx.ui.treevirtual.MTreePrimitive.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.selection.Manager": {
        "construct": true,
        "require": true
      },
      "qx.event.type.Mouse": {},
      "qx.ui.treevirtual.SimpleTreeDataModel": {},
      "qx.bom.element.Location": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A selection manager. This is a helper class that handles all selection
   * related events and updates a SelectionModel.
   * <p>
   * This Selection Manager differs from its superclass in that we do not want
   * rows to be selected when moving around with the keyboard.
   */
  qx.Class.define("qx.ui.treevirtual.SelectionManager", {
    extend: qx.ui.table.selection.Manager,

    /**
     * @param table {qx.ui.table.Table}
     *    The table whose selections are being managed
     */
    construct: function construct(table) {
      qx.ui.table.selection.Manager.constructor.call(this);
      this.__table__P_534_0 = table;
    },
    members: {
      __table__P_534_0: null,

      /**
       * Getter for the table being managed
       *
       * @return {qx.ui.table.Table}
       *   Table being managed
       */
      getTable: function getTable() {
        return this.__table__P_534_0;
      },

      /**
       * Handles a select event.  First we determine if the click was on the
       * open/close button and toggle the opened/closed state as necessary.
       * Then, if the click was not on the open/close button or if the table's
       * "openCloseClickSelectsRow" property so indicates, call our superclass to
       * handle the actual row selection.
       *
       * @param index {Integer} the index the event is pointing at.
       * @param evt {Map} the mouse event.
       */
      _handleSelectEvent: function _handleSelectEvent(index, evt) {
        var _this = this;

        function handleButtonClick(tree, index, evt) {
          // Get the data model
          var dataModel = tree.getDataModel(); // Determine the column containing the tree

          var treeCol = dataModel.getTreeColumn(); // Get the focused column

          var focusedCol = tree.getFocusedColumn(); // If the click is not in the tree column, ...

          if (focusedCol != treeCol) {
            // ... then let the Table selection manager deal with it
            return false;
          } // If the cell hasn't been focused automatically...


          if (evt instanceof qx.event.type.Mouse) {
            if (!tree.getFocusCellOnPointerMove()) {
              // ... then focus it now so we can determine the node to open/close
              var scrollers = tree._getPaneScrollerArr();

              for (var i = 0; i < scrollers.length; i++) {
                scrollers[i]._focusCellAtPagePos(evt.getViewportLeft(), evt.getViewportTop());
              }
            }
          } // Get the node to which this event applies


          var node = dataModel.getNode(tree.getFocusedRow());

          if (!node) {
            return false;
          } // Was this a mouse event?


          if (evt instanceof qx.event.type.Mouse) {
            // Was the click on the open/close button? We get the position and add a bit of
            // latitude to that
            var x = evt.getViewportLeft();
            var latitude = 2;
            var buttonPos = tree.getOpenCloseButtonPosition(node);

            if (x >= buttonPos.left - latitude && x <= buttonPos.left + buttonPos.width + latitude) {
              // Yup.  Toggle the opened state for this node if open/close is allowed
              if (!node.bHideOpenClose && node.type !== qx.ui.treevirtual.SimpleTreeDataModel.Type.LEAF) {
                dataModel.setState(node, {
                  bOpened: !node.bOpened
                });
              }

              return tree.getOpenCloseClickSelectsRow() ? false : true;
            } else {
              // Yup.  Get the order of the columns
              var tcm = tree.getTableColumnModel();

              var columnPositions = tcm._getColToXPosMap(); // Calculate the position of the beginning of the tree column


              var left = qx.bom.element.Location.getLeft(tree.getContentElement().getDomElement());

              for (var i = 0; i < columnPositions[treeCol].visX; i++) {
                left += tcm.getColumnWidth(columnPositions[i].visX);
              }

              return _this._handleExtendedClick(tree, evt, node, left);
            }
          } else {
            // See which key generated the event
            var identifier = evt.getKeyIdentifier();

            switch (identifier) {
              case "Space":
                // This should only select the row, not toggle the opened state
                return false;

              case "Enter":
                // Toggle the open state if open/close is allowed
                if (!node.bHideOpenClose && node.type != qx.ui.treevirtual.SimpleTreeDataModel.Type.LEAF) {
                  dataModel.setState(node, {
                    bOpened: !node.bOpened
                  });
                }

                return tree.getOpenCloseClickSelectsRow() ? false : true;

              default:
                // Unrecognized key.  Ignore it.
                return true;
            }
          }
        } // Call our local method to toggle the open/close state, if necessary


        var bNoSelect = handleButtonClick(this.__table__P_534_0, index, evt); // If we haven't been told not to do the selection...

        if (!bNoSelect) {
          // then call the superclass to handle it.
          qx.ui.treevirtual.SelectionManager.prototype._handleSelectEvent.base.call(this, index, evt);
        }
      },

      /**
       * Handle a mouse click event that is not normally handled by the simple
       * tree.  This is intended for more sophisticated trees where clicks in
       * different places, e.g. on various icons or on the label itself, should
       * be handled specially.
       *
       * @param tree {qx.ui.treevirtual.TreeVirtual}
       *   The tree on which the event has occurred.
       *
       * @param evt {Map}
       *   The mouse event.  Of particular interest is evt.getViewportLeft()
       *   which is the horizontal offset from the left border of the click.
       *
       * @param node {Map}
       *   The node which the tree row is displaying
       *
       * @param left {Integer}
       *   The offset from the left, of the beginning of the tree column.
       *
       * @return {Boolean}
       *   <i>true</i> if the row should be prevented from being selected;
       *   <i>false</i> otherwise.
       */
      _handleExtendedClick: function _handleExtendedClick(tree, evt, node, left) {
        return false;
      }
    },
    destruct: function destruct() {
      this.__table__P_534_0 = null;
    }
  });
  qx.ui.treevirtual.SelectionManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.model.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.treevirtual.MTreePrimitive": {
        "construct": true,
        "defer": "runtime",
        "require": true
      },
      "qx.lang.Object": {},
      "qx.lang.Array": {},
      "qx.ui.treevirtual.TreeVirtual": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2010 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A simple tree data model used as the table model
   *
   * The object structure of a single node of the tree is:
   *
   * <pre class='javascript'>
   * {
   *   // USER-PROVIDED ATTRIBUTES
   *   // ------------------------
   *   type           : qx.ui.treevirtual.MTreePrimitive.Type.LEAF,
   *   parentNodeId   : 23,    // index of the parent node in _nodeArr
   *
   *   label          : "My Documents",
   *   bSelected      : true,  // true if node is selected; false otherwise.
   *   bOpened        : true,  // true (-), false (+)
   *   bHideOpenClose : false, // whether to hide the open/close button
   *   bCanEdit       : true,  // true if the node label can be edited, false to prevent edit
   *   icon           : "images/folder.gif",
   *   iconSelected   : "images/folder_selected.gif",
   *
   *   cellStyle      : "background-color:cyan"
   *   labelStyle     : "background-color:red;color:white"
   *
   *   // USER-PROVIDED COLUMN DATA
   *   columnData     : [
   *                      null, // null at index of tree column (typically 0)
   *                      "text of column 1",
   *                      "text of column 2"
   *                    ],
   *
   *   // APPLICATION-, MIXIN-, and SUBCLASS-PROVIDED CUSTOM DATA
   *   data           : {
   *                      application :
   *                      {
   *                          // application-specific user data goes in here
   *                          foo: "bar",
   *                          ...
   *                      },
   *                      MDragAndDropSupport :
   *                      {
   *                          // Data required for the Drag & Drop mixin.
   *                          // When a mixin is included, its constructor
   *                          // should create this object, named according
   *                          // to the mixin or subclass name (empty or
   *                          // otherwise)
   *                      },
   *                      ... // Additional mixins or subclasses.
   *                    },
   *
   *   // INTERNALLY-CALCULATED ATTRIBUTES
   *   // --------------------------------
   *   // The following properties need not (and should not) be set by the
   *   // caller, but are automatically calculated.  Some are used internally,
   *   // while others may be of use to event listeners.
   *
   *   nodeId         : 42,   // The index in _nodeArr, useful to event listeners.
   *   children       : [ ],  // each value is an index into _nodeArr
   *
   *   level          : 2,    // The indentation level of this tree node
   *   labelPos       : 40,   // The left position of the label text - stored when the cell is rendered
   *
   *   bFirstChild    : true,
   *   lastChild      : [ false ],  // Array where the index is the column of
   *                                // indentation, and the value is a boolean.
   *                                // These are used to locate the
   *                                // appropriate "tree line" icon.
   * }
   * </pre>
   */
  qx.Class.define("qx.ui.treevirtual.SimpleTreeDataModel", {
    extend: qx.ui.table.model.Abstract,
    include: qx.ui.treevirtual.MTreePrimitive,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.model.Abstract.constructor.call(this);
      this._rowArr = []; // rows, resorted into tree order as necessary

      this._nodeArr = []; // tree nodes, organized with hierarchy

      this._nodeRowMap = []; // map nodeArr index to rowArr index.  The
      // index of this array is the index of
      // _nodeArr, and the values in this array are
      // the indexes into _rowArr.

      this._treeColumn = 0; // default column for tree nodes

      this._selections = {}; // list of indexes of selected nodes
      // the root node, needed to store its children

      this._nodeArr.push(qx.ui.treevirtual.MTreePrimitive._getEmptyTree()); // Track which columns are editable


      this.__editableColArr__P_536_0 = null;
    },
    properties: {
      /**
       * Gives the user the opportunity to filter the model. The filter
       * function is called for every node in the model. It gets as an argument the
       * <code>node</code> object and has to return
       * <code>true</code> if the given data should be shown and
       * <code>false</code> if the given data should be ignored.
       */
      filter: {
        check: "Function",
        nullable: true,
        apply: "_applyFilter"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __tree__P_536_1: null,
      __editableColArr__P_536_0: null,
      __tempTreeData__P_536_2: null,
      __recalculateLastChildFlags__P_536_3: null,

      /** Rows, resorted into tree order as necessary */
      _rowArr: null,

      /** Tree nodes, organized with hierarchy */
      _nodeArr: null,

      /**
       * Map nodeArr index to rowArr index.  The index of this array is the
       * index of _nodeArr, and the values in this array are the indexes into
       * _rowArr.
       */
      _nodeRowMap: null,

      /** Column for tree nodes */
      _treeColumn: null,

      /** list of indexes of selected nodes */
      _selections: null,

      /**
       * Set the tree object for which this data model is used.
       *
       * @param tree {qx.ui.treevirtual.TreeVirtual}
       *    The tree used to render the data in this model.
       *
       */
      setTree: function setTree(tree) {
        this.__tree__P_536_1 = tree;
      },

      /**
       * Get the tree object for which this data model is used.
       *
       * @return {qx.ui.treevirtual.TreeVirtual}
       */
      getTree: function getTree() {
        return this.__tree__P_536_1;
      },

      /**
       * Sets all columns editable or not editable.
       *
       * @param editable {Boolean}
       *   Whether all columns are editable.
       *
       */
      setEditable: function setEditable(editable) {
        this.__editableColArr__P_536_0 = [];

        for (var col = 0; col < this.getColumnCount(); col++) {
          this.__editableColArr__P_536_0[col] = editable;
        }

        this.fireEvent("metaDataChanged");
      },

      /**
       * Sets whether a column is editable.
       *
       * @param columnIndex {Integer}
       *   The column of which to set the editable state.
       *
       * @param editable {Boolean}
       *   Whether the column should be editable.
       *
       */
      setColumnEditable: function setColumnEditable(columnIndex, editable) {
        if (editable != this.isColumnEditable(columnIndex)) {
          if (this.__editableColArr__P_536_0 == null) {
            this.__editableColArr__P_536_0 = [];
          }

          this.__editableColArr__P_536_0[columnIndex] = editable;
          this.fireEvent("metaDataChanged");
        }
      },
      // overridden
      isColumnEditable: function isColumnEditable(columnIndex) {
        if (columnIndex == this._treeColumn) {
          return this.__tree__P_536_1.getAllowNodeEdit();
        }

        return this.__editableColArr__P_536_0 ? this.__editableColArr__P_536_0[columnIndex] == true : false;
      },
      // overridden
      isColumnSortable: function isColumnSortable(columnIndex) {
        return false;
      },

      /**
       * Sorts the model by a column.
       *
       * @param columnIndex {Integer} the column to sort by.
       * @param ascending {Boolean} whether to sort ascending.
       * @throws {Error} If one tries to sort the tree by column
       */
      sortByColumn: function sortByColumn(columnIndex, ascending) {
        throw new Error("Trees can not be sorted by column");
      },

      /**
       * Returns the column index the model is sorted by. This model is never
       * sorted, so -1 is returned.
       *
       * @return {Integer}
       *   -1, to indicate that the model is not sorted.
       */
      getSortColumnIndex: function getSortColumnIndex() {
        return -1;
      },

      /**
       * Specifies which column the tree is to be displayed in.  The tree is
       * displayed using the SimpleTreeDataCellRenderer.  Other columns may be
       * provided which use different cell renderers.
       *
       * Setting the tree column involves more than simply setting this column
       * index; it also requires setting an appropriate cell renderer for this
       * column, that knows how to render a tree. The expected and typical
       * method of setting the tree column is to provide it in the 'custom'
       * parameter to the TreeVirtual constructor, which also initializes the
       * proper cell renderers. This method does not set any cell renderers. If
       * you wish to call this method on your own, you should also manually set
       * the cell renderer for the specified column, and likely also set the
       * cell renderer for column 0 (the former tree column) to something
       * appropriate to your data.
       *
       *
       * @param columnIndex {Integer}
       *   The index of the column in which the tree should be displayed.
       *
       */
      setTreeColumn: function setTreeColumn(columnIndex) {
        this._treeColumn = columnIndex;
      },

      /**
       * Get the column in which the tree is to be displayed.
       *
       * @return {Integer}
       *   The column in which the tree is to be displayed
       */
      getTreeColumn: function getTreeColumn() {
        return this._treeColumn;
      },
      // overridden
      getRowCount: function getRowCount() {
        return this._rowArr.length;
      },
      // overridden
      getRowData: function getRowData(rowIndex) {
        return this._rowArr[rowIndex];
      },

      /**
       * Returns a cell value by column index.
       *
       * @throws {Error} if the row index is out of bounds.
       * @param columnIndex {Integer} the index of the column.
       * @param rowIndex {Integer} the index of the row.
       * @return {var} The value of the cell.
       * @see #getValueById
       */
      getValue: function getValue(columnIndex, rowIndex) {
        if (rowIndex < 0 || rowIndex >= this._rowArr.length) {
          throw new Error("this._rowArr row (" + rowIndex + ") out of bounds: " + this._rowArr + " (0.." + (this._rowArr.length - 1) + ")");
        }

        if (columnIndex < 0 || columnIndex >= this._rowArr[rowIndex].length) {
          throw new Error("this._rowArr column (" + columnIndex + ") out of bounds: " + this._rowArr[rowIndex] + " (0.." + (this._rowArr[rowIndex].length - 1) + ")");
        }

        return this._rowArr[rowIndex][columnIndex];
      },
      // overridden
      setValue: function setValue(columnIndex, rowIndex, value) {
        // convert from rowArr to nodeArr, and get the requested node
        var node = this.getNodeFromRow(rowIndex);

        if (columnIndex === this._treeColumn) {
          if (!this.__tree__P_536_1.getAllowNodeEdit() || value["label"] === undefined) {
            return;
          } // only allow to set the node label via this method, clone the original node


          var updatedNode = qx.lang.Object.clone(node);
          updatedNode.label = value.label;
          this._nodeArr[node.nodeId] = updatedNode;
        } else {
          if (node.columnData[columnIndex] == value) {
            return;
          }

          node.columnData[columnIndex] = value;
        }

        this.setData(); // Inform the listeners

        if (this.hasListener("dataChanged")) {
          var data = {
            firstRow: rowIndex,
            lastRow: rowIndex,
            firstColumn: columnIndex,
            lastColumn: columnIndex
          };
          this.fireDataEvent("dataChanged", data);
        }
      },

      /**
       * Returns the node object specific to a currently visible row. In this
       * simple tree data model, that's the same as retrieving the value of the
       * tree column of the specified row.
       *
       * @throws {Error}
       *   Thrown if the row index is out of bounds.
       *
       * @param rowIndex {Integer}
       *   The index of the row.
       *
       * @return {Object}
       *   The node object associated with the specified row.
       */
      getNode: function getNode(rowIndex) {
        if (rowIndex < 0 || rowIndex >= this._rowArr.length) {
          throw new Error("this._rowArr row (" + rowIndex + ") out of bounds: " + this._rowArr + " (0.." + (this._rowArr.length - 1) + ")");
        }

        return this._rowArr[rowIndex][this._treeColumn];
      },

      /**
       * Add a branch to the tree.
       *
       * @param parentNodeId {Integer}
       *   The node id of the parent of the node being added
       *
       * @param label {String}
       *   The string to display as the label for this node
       *
       * @param bOpened {Boolean}
       *   <i>True</i> if the branch should be rendered in its opened state;
       *   <i>false</i> otherwise.
       *
       * @param bHideOpenCloseButton {Boolean}
       *   <i>True</i> if the open/close button should not be displayed;
       *   <i>false</i> if the open/close button should be displayed
       *
       * @param icon {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is not a selected node.
       *
       * @param iconSelected {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is a selected node.
       *
       * @return {Integer}
       *   The node id of the newly-added branch.
       */
      addBranch: function addBranch(parentNodeId, label, bOpened, bHideOpenCloseButton, icon, iconSelected) {
        return qx.ui.treevirtual.MTreePrimitive._addNode(this._nodeArr, parentNodeId, label, bOpened, bHideOpenCloseButton, qx.ui.treevirtual.MTreePrimitive.Type.BRANCH, icon, iconSelected);
      },

      /**
       * Add a leaf to the tree.
       *
       * @param parentNodeId {Integer}
       *   The node id of the parent of the node being added
       *
       * @param label {String}
       *   The string to display as the label for this node
       *
       * @param icon {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is not a selected node.
       *
       * @param iconSelected {String}
       *   The relative (subject to alias expansion) or full path of the icon to
       *   display for this node when it is a selected node.
       *
       * @return {Integer} The node id of the newly-added leaf.
       */
      addLeaf: function addLeaf(parentNodeId, label, icon, iconSelected) {
        return qx.ui.treevirtual.MTreePrimitive._addNode(this._nodeArr, parentNodeId, label, false, false, qx.ui.treevirtual.MTreePrimitive.Type.LEAF, icon, iconSelected);
      },

      /**
       * Prune the tree by removing, recursively, all of a node's children.  If
       * requested, also remove the node itself.
       *
       * @param nodeReference {Object | Integer}
       *   The node to be pruned from the tree.  The node can be represented
       *   either by the node object, or the node id (as would have been
       *   returned by addBranch(), addLeaf(), etc.)
       *
       * @param bSelfAlso {Boolean}
       *   If <i>true</i> then remove the node identified by <i>nodeId</i> as
       *   well as all of the children.
       *
       * @throws {Error} If the node object or id is not valid.
       *
       */
      prune: function prune(nodeReference, bSelfAlso) {
        var node;
        var nodeId;

        if (typeof nodeReference == "object") {
          node = nodeReference;
          nodeId = node.nodeId;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
        } else {
          throw new Error("Expected node object or node id");
        } // First, recursively remove all children


        for (var i = this._nodeArr[nodeId].children.length - 1; i >= 0; i--) {
          this.prune(this._nodeArr[nodeId].children[i], true);
        } // Now remove ourself, if requested. (Don't try to remove the root node)


        if (bSelfAlso && nodeId != 0) {
          // Delete ourself from our parent's children list
          node = this._nodeArr[nodeId];
          qx.lang.Array.remove(this._nodeArr[node.parentNodeId].children, nodeId); // Delete ourself from the selections list, if we're in it.

          if (this._selections[nodeId]) {
            delete this._selections[nodeId];
          } // We can't splice the node itself out, because that would muck up the
          // nodeId == index correspondence.  Instead, just replace the node
          // with null so its index just becomes unused.


          this._nodeArr[nodeId] = null;
        }
      },

      /**
       * Move a node in the tree.
       *
       * @param moveNodeReference {Object | Integer}
       *   The node to be moved.  The node can be represented
       *   either by the node object, or the node id (as would have been
       *   returned by addBranch(), addLeaf(), etc.)
       *
       * @param parentNodeReference {Object | Integer}
       *   The new parent node, which must not be a LEAF.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @throws {Error} If the node object or id is not valid.
       * @throws {Error} If one tries to add a child to a non-existent parent.
       * @throws {Error} If one tries to add a node to a leaf.
       */
      move: function move(moveNodeReference, parentNodeReference) {
        var moveNode;
        var moveNodeId;
        var parentNode;
        var parentNodeId; // Replace null parent with node id 0

        parentNodeReference = parentNodeReference || 0;

        if (typeof moveNodeReference == "object") {
          moveNode = moveNodeReference;
          moveNodeId = moveNode.nodeId;
        } else if (typeof moveNodeReference == "number") {
          moveNodeId = moveNodeReference;
          moveNode = this._nodeArr[moveNodeId];
        } else {
          throw new Error("Expected move node object or node id");
        }

        if (typeof parentNodeReference == "object") {
          parentNode = parentNodeReference;
          parentNodeId = parentNode.nodeId;
        } else if (typeof parentNodeReference == "number") {
          parentNodeId = parentNodeReference;
          parentNode = this._nodeArr[parentNodeId];
        } else {
          throw new Error("Expected parent node object or node id");
        } // Ensure parent isn't a leaf


        if (parentNode.type == qx.ui.treevirtual.MTreePrimitive.Type.LEAF) {
          throw new Error("Sorry, a LEAF may not have children.");
        } // Remove the node from its current parent's children list


        var oldParent = this._nodeArr[moveNode.parentNodeId];
        qx.lang.Array.remove(oldParent.children, moveNodeId); // Add the node to its new parent's children list

        parentNode.children.push(moveNodeId); // Replace this node's parent reference

        this._nodeArr[moveNodeId].parentNodeId = parentNodeId;
      },

      /**
       * Orders the node and creates all data needed to render the tree.
       *
       * @param nodeId {Integer}
       *   A node identifier, as previously returned by {@link #addBranch} or
       *   {@link #addLeaf}.
       * @param level {Integer} the level in the hierarchy
       */
      __inorder__P_536_4: function __inorder__P_536_4(nodeId, level) {
        var filter = this.getFilter();
        var child = null;
        var childNodeId; // For each child of the specified node...

        var numChildren = this._nodeArr[nodeId].children.length;
        var index = 0;
        var children = this.__tempTreeData__P_536_2[nodeId] = [];

        for (var i = 0; i < numChildren; i++) {
          // Determine the node id of this child
          childNodeId = this._nodeArr[nodeId].children[i]; // Get the child node

          child = this._nodeArr[childNodeId]; // Skip deleted nodes or apply the filter

          if (child == null || filter && !filter.call(this, child)) {
            this.__recalculateLastChildFlags__P_536_3 = true;
            continue;
          } // Remember the children so that we can add the lastChild flags later


          children.push(child); // (Re-)assign this node's level

          child.level = level; // Determine if we're the first child of our parent

          child.bFirstChild = index == 0; // Set the last child flag of the node only when no node was skipped.
          // Otherwise we will have to recalculate the last child flags, as
          // the parent or sibling node might become the first child.

          if (!this.__recalculateLastChildFlags__P_536_3) {
            this.__setLastChildFlag__P_536_5(child, i == numChildren - 1);
          } // Ensure there's an entry in the columnData array for each column


          if (!child.columnData) {
            child.columnData = [];
          }

          if (child.columnData.length < this.getColumnCount()) {
            child.columnData[this.getColumnCount() - 1] = null;
          } // Add this node to the row array.  Initialize a row data array.


          var rowData = []; // If additional column data is provided...

          if (child.columnData) {
            // ... then add each column data.
            for (var j = 0; j < child.columnData.length; j++) {
              // Is this the tree column?
              if (j == this._treeColumn) {
                // Yup.  Add the tree node data
                rowData.push(child);
              } else {
                // Otherwise, add the column data verbatim.
                rowData.push(child.columnData[j]);
              }
            }
          } else {
            // No column data.  Just add the tree node.
            rowData.push(child);
          } // Track the _rowArr index for each node so we can handle
          // selections.


          this._nodeRowMap[child.nodeId] = this._rowArr.length; // Add the row data to the row array

          this._rowArr.push(rowData); // If this node is selected, ...


          if (child.bSelected) {
            // ... indicate so for the row.
            rowData.selected = true;
            this._selections[child.nodeId] = true;
          } // If this child is opened, ...


          if (child.bOpened) {
            // ... then add its children too.
            this.__inorder__P_536_4(childNodeId, level + 1);
          }

          index++;
        }
      },

      /**
       * Calculates the lastChild flags to the nodes, so that the tree can render the
       * tree lines right.
       *
       * @param nodeId {Integer}
       *   A node identifier, as previously returned by {@link #addBranch} or
       *   {@link #addLeaf}.
       */
      __calculateLastChildFlags__P_536_6: function __calculateLastChildFlags__P_536_6(nodeId) {
        var tempTreeData = this.__tempTreeData__P_536_2;
        var children = tempTreeData[nodeId];
        var numChildren = children.length;

        for (var i = 0; i < numChildren; i++) {
          var child = children[i];

          this.__setLastChildFlag__P_536_5(child, i == numChildren - 1);

          var hasChildren = tempTreeData[child.nodeId] && tempTreeData[child.nodeId].length > 0;

          if (hasChildren) {
            this.__calculateLastChildFlags__P_536_6(child.nodeId);
          }
        }
      },

      /**
       * Sets the last child flag for a node and all it's parents.
       *
       * @param node {Object} the node object
       * @param isLastChild {Boolean} whether the node is the last child
       */
      __setLastChildFlag__P_536_5: function __setLastChildFlag__P_536_5(node, isLastChild) {
        // Determine if we're the last child of our parent
        node.lastChild = [isLastChild]; // Get our parent.

        var parent = this._nodeArr[node.parentNodeId]; // For each parent node, determine if it is a last child

        while (parent.nodeId) {
          var bLast = parent.lastChild[parent.lastChild.length - 1];
          node.lastChild.unshift(bLast);
          parent = this._nodeArr[parent.parentNodeId];
        }
      },

      /**
       * Renders the tree data.
       */
      __render__P_536_7: function __render__P_536_7() {
        // Reset the __tempTreeData
        this.__tempTreeData__P_536_2 = [];
        this.__recalculateLastChildFlags__P_536_3 = false; // Reset the row array

        this._rowArr = []; // Reset the _nodeArr -> _rowArr map

        this._nodeRowMap = []; // Reset the set of selections

        this._selections = {}; // Begin in-order traversal of the tree from the root to regenerate
        // _rowArr.

        this.__inorder__P_536_4(0, 1); // Reset the lastChild flags when needed, so that the tree can render the
        // tree lines right.


        if (this.__recalculateLastChildFlags__P_536_3) {
          this.__calculateLastChildFlags__P_536_6(0);
        } // Give the memory free


        this.__tempTreeData__P_536_2 = null; // Inform the listeners

        if (this.hasListener("dataChanged")) {
          var data = {
            firstRow: 0,
            lastRow: this._rowArr.length - 1,
            firstColumn: 0,
            lastColumn: this.getColumnCount() - 1
          };
          this.fireDataEvent("dataChanged", data);
        }
      },

      /**
       * Sets the whole data en bulk, or notifies the data model that node
       * modifications are complete.
       *
       * @param nodeArr {Array | null}
       *   Pass either an Array of node objects, or null.
       *
       *   If non-null, nodeArr is an array of node objects containing the
       *   entire tree to be displayed.  If loading the whole data en bulk in
       *   this way, it is assumed that the data is correct!  No error checking
       *   or validation is done.  You'd better know what you're doing!  Caveat
       *   emptor.
       *
       *
       *   If nodeArr is null, then this call is a notification that the user
       *   has completed building or modifying a tree by issuing a series of
       *   calls to {@link #addBranch} and/or {@link #addLeaf}.
       *
       *
       * @throws {Error} If the parameter has the wrong type.
       */
      setData: function setData(nodeArr) {
        if (nodeArr instanceof Array) {
          // Save the user-supplied data.
          this._nodeArr = nodeArr;
        } else if (nodeArr !== null && nodeArr !== undefined) {
          throw new Error("Expected array of node objects or null/undefined; got " + typeof nodeArr);
        } // Re-render the row array


        this.__render__P_536_7(); // Set selections in the selection model now


        var selectionModel = this.getTree().getSelectionModel();
        var selections = this._selections;

        for (var nodeId in selections) {
          var nRowIndex = this.getRowFromNodeId(nodeId);
          selectionModel.setSelectionInterval(nRowIndex, nRowIndex);
        }
      },

      /**
       * Return the array of node data.
       *
       * @return {Array}
       *  Array of node objects.
       *  See {@link qx.ui.treevirtual.SimpleTreeDataModel} for a description
       *  nodes in this array.
       */
      getData: function getData() {
        return this._nodeArr;
      },

      /**
       * Clears the tree of all nodes
       *
       */
      clearData: function clearData() {
        this._clearSelections();

        this.setData([qx.ui.treevirtual.MTreePrimitive._getEmptyTree()]);
      },

      /**
       * Add data to an additional column (a column other than the tree column)
       * of the tree.
       *
       * @param nodeId {Integer}
       *   A node identifier, as previously returned by {@link #addBranch} or
       *   {@link #addLeaf}.
       *
       * @param columnIndex {Integer}
       *   The column number to which the provided data applies
       *
       * @param data {var}
       *   The cell data for the specified column
       *
       */
      setColumnData: function setColumnData(nodeId, columnIndex, data) {
        this._nodeArr[nodeId].columnData[columnIndex] = data;
      },

      /**
       * Retrieve the data from an additional column (a column other than the
       * tree column) of the tree.
       *
       * @param nodeId {Integer}
       *   A node identifier, as previously returned by {@link #addBranch} or
       *   {@link #addLeaf}.
       *
       * @param columnIndex {Integer}
       *   The column number to which the provided data applies
       *
       * @return {var} The cell data for the specified column
       */
      getColumnData: function getColumnData(nodeId, columnIndex) {
        return this._nodeArr[nodeId].columnData[columnIndex];
      },

      /**
       * Set state attributes of a node.
       *
       * @param nodeReference {Object | Integer}
       *   The node to have its attributes set.  The node can be represented
       *   either by the node object, or the node id (as would have been
       *   returned by addBranch(), addLeaf(), etc.)
       *
       * @param attributes {Map}
       *   Each property name in the map may correspond to the property names of
       *   a node which are specified as <i>USER-PROVIDED ATTRIBUTES</i> in
       *   {@link SimpleTreeDataModel}.  Each property value will be assigned
       *   to the corresponding property of the node specified by nodeId.
       *
       * @throws {Error} If the node object or id is not valid.
       */
      setState: function setState(nodeReference, attributes) {
        var node;
        var nodeId;

        if (typeof nodeReference == "object") {
          node = nodeReference;
          nodeId = node.nodeId;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
          node = this._nodeArr[nodeId];
        } else {
          throw new Error("Expected node object or node id");
        }

        for (var attribute in attributes) {
          // Do any attribute-specific processing
          switch (attribute) {
            case "bSelected":
              var nRowIndex = this.getRowFromNodeId(nodeId);
              var selectionModel = this.getTree().getSelectionModel();
              var TV = qx.ui.treevirtual.TreeVirtual;
              var bChangeSelection = typeof nRowIndex === "number" && this.getTree().getSelectionMode() != TV.SelectionMode.NONE; // The selected state is changing. Keep track of what is selected

              if (attributes[attribute]) {
                this._selections[nodeId] = true; // Add selection range for node

                if (bChangeSelection && !selectionModel.isSelectedIndex(nRowIndex)) {
                  selectionModel.setSelectionInterval(nRowIndex, nRowIndex);
                }
              } else {
                delete this._selections[nodeId]; // Delete selection range for node

                if (bChangeSelection && selectionModel.isSelectedIndex(nRowIndex)) {
                  selectionModel.removeSelectionInterval(nRowIndex, nRowIndex);
                }
              }

              break;

            case "bOpened":
              // Don't do anything if this is a leaf, leaf has no opened/closed
              if (node.type === qx.ui.treevirtual.MTreePrimitive.Type.LEAF) {
                break;
              } // Don't do anything if the requested state is the same as the
              // current state.


              if (attributes[attribute] == node.bOpened) {
                break;
              } // Get the tree to which this data model is attached


              var tree = this.__tree__P_536_1; // Are we opening or closing?

              if (node.bOpened) {
                // We're closing.  If there are listeners, generate a treeClose
                // event.
                tree.fireDataEvent("treeClose", node);
              } else {
                // We're opening.  Are there any children?
                if (node.children.length > 0) {
                  // Yup.  If there any listeners, generate a "treeOpenWithContent"
                  // event.
                  tree.fireDataEvent("treeOpenWithContent", node);
                } else {
                  // No children.  If there are listeners, generate a
                  // "treeOpenWhileEmpty" event.
                  tree.fireDataEvent("treeOpenWhileEmpty", node);
                }
              } // Event handler may have modified the opened state.  Check before
              // toggling.


              if (!node.bHideOpenClose) {
                // It's still boolean.  Toggle the state
                node.bOpened = !node.bOpened; // Clear the old selections in the tree

                tree.getSelectionModel()._resetSelection();
              } // Re-render the row data since formerly visible rows may now be
              // invisible, or vice versa.


              this.setData();
              break;

            default:
              // no attribute-specific processing required
              break;
          } // Set the new attribute value


          node[attribute] = attributes[attribute];
        }
      },

      /**
       * Return the mapping of nodes to rendered rows.  This function is intended
       * for use by the cell renderer, not by users of this class.
       * It is also useful to select a node.
       *
       * @return {Array}
       *   The array containing mappings of nodes to rendered rows.
       */
      getNodeRowMap: function getNodeRowMap() {
        return this._nodeRowMap;
      },

      /**
       * This operation maps nodes to rowIndexes.  It does the opposite job to {@link #getNodeFromRow}.
       *
       * @param nodeId {Integer}
       *   The id of the node (as would have been returned by addBranch(),
       *   addLeaf(), etc.) to get the row index for.
       * @return {Integer} row index for the given node ID
       */
      getRowFromNodeId: function getRowFromNodeId(nodeId) {
        return this._nodeRowMap[nodeId];
      },

      /**
       * This operation maps rowIndexes to nodes.  It does the opposite job to {@link #getRowFromNodeId}.
       * This function is useful to map selection (row based) to nodes.
       *
       * @param rowIndex {Integer} zero-based row index.
       * @return {Object} node associated to <tt>rowIndex</tt>.
       */
      getNodeFromRow: function getNodeFromRow(rowIndex) {
        return this._nodeArr[this._rowArr[rowIndex][this._treeColumn].nodeId];
      },

      /**
       * Clear all selections in the data model.  This method does not clear
       * selections displayed in the widget, and is intended for internal use,
       * not by users of this class.
       *
       */
      _clearSelections: function _clearSelections() {
        // Clear selected state for any selected nodes.
        for (var selection in this._selections) {
          this._nodeArr[selection].bSelected = false;
        } // Reinitialize selections array.


        this._selections = {};
      },

      /**
       * Return the nodes that are currently selected.
       *
       * @return {Array}
       *   An array containing the nodes that are currently selected.
       */
      getSelectedNodes: function getSelectedNodes() {
        var nodes = [];

        for (var nodeId in this._selections) {
          nodes.push(this._nodeArr[nodeId]);
        }

        return nodes;
      },
      // property apply
      _applyFilter: function _applyFilter(value, old) {
        this.setData();
      },

      /**
       * This checks whether a node label is editable
       * Used in the NodeEditor to check if edit is permitted
       *
       * @param rowIndex {Integer} zero-based row index.
       * @return {Boolean} If the node has edit permitted
       */
      isNodeEditable: function isNodeEditable(rowIndex) {
        return this.__tree__P_536_1.getAllowNodeEdit() && this.getNodeFromRow(rowIndex).bCanEdit;
      }
    },
    destruct: function destruct() {
      this._rowArr = this._nodeArr = this._nodeRowMap = this._selections = this.__tree__P_536_1 = this.__tempTreeData__P_536_2 = null;
    },
    defer: function defer(statics) {
      // For backward compatibility, ensure the Type values are available from
      // this class as well as from the mixin.
      statics.Type = qx.ui.treevirtual.MTreePrimitive.Type;
    }
  });
  qx.ui.treevirtual.SimpleTreeDataModel.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.Table": {
        "construct": true,
        "require": true
      },
      "qx.ui.treevirtual.SimpleTreeDataModel": {
        "construct": true
      },
      "qx.ui.treevirtual.SimpleTreeDataCellRenderer": {
        "construct": true
      },
      "qx.ui.treevirtual.DefaultDataCellRenderer": {
        "construct": true
      },
      "qx.ui.treevirtual.SimpleTreeDataRowRenderer": {
        "construct": true
      },
      "qx.ui.treevirtual.SelectionManager": {
        "construct": true
      },
      "qx.ui.table.columnmodel.Resize": {
        "construct": true
      },
      "qx.ui.treevirtual.pane.Scroller": {
        "construct": true
      },
      "qx.lang.Type": {
        "construct": true
      },
      "qx.ui.treevirtual.celleditor.NodeEditor": {
        "construct": true
      },
      "qx.ui.table.selection.Model": {
        "require": true
      },
      "qx.bom.element.Location": {},
      "qx.event.type.Dom": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A "virtual" tree
   * <p>
   *   A number of convenience methods are available in the following mixins:
   *   <ul>
   *     <li>{@link qx.ui.treevirtual.MNode}</li>
   *     <li>{@link qx.ui.treevirtual.MFamily}</li>
   *   </ul>
   * </p>
   */
  qx.Class.define("qx.ui.treevirtual.TreeVirtual", {
    extend: qx.ui.table.Table,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param headings {Array | String}
     *   An array containing a list of strings, one for each column, representing
     *   the headings for each column.  As a special case, if only one column is
     *   to exist, the string representing its heading need not be enclosed in an
     *   array.
     *
     * @param custom {Map ? null}
     *   A map provided (typically) by subclasses, to override the various
     *   supplemental classes allocated within this constructor.  For normal
     *   usage, this parameter may be omitted.  Each property must be an object
     *   instance or a function which returns an object instance, as indicated by
     *   the defaults listed here:
     *
     *   <dl>
     *     <dt>initiallyHiddenColumns</dt>
     *       <dd>
     *         {Array?}
     *         A list of column numbers that should be initially invisible. Any
     *         column not mentioned will be initially visible, and if no array
     *         is provided, all columns will be initially visible.
     *       </dd>
     *     <dt>dataModel</dt>
     *       <dd>new qx.ui.treevirtual.SimpleTreeDataModel()</dd>
     *     <dt>treeDataCellRenderer</dt>
     *       <dd>
     *         Instance of {@link qx.ui.treevirtual.SimpleTreeDataCellRenderer}.
     *         Custom data cell renderer for the tree column.
     *       </dd>
     *     <dt>treeColumn</dt>
     *       <dd>
     *         The column number in which the tree is to reside, i.e., which
     *         column uses the SimpleTreeDataCellRenderer or a subclass of it.
     *       </dd>
     *     <dt>defaultDataCellRenderer</dt>
     *       <dd>
     *         Instance of {@link qx.ui.treevirtual.DefaultDataCellRenderer}.
     *         Custom data cell renderer for all columns other than the tree
     *         column.
     *       </dd>
     *     <dt>dataRowRenderer</dt>
     *       <dd>new qx.ui.treevirtual.SimpleTreeDataRowRenderer()</dd>
     *     <dt>selectionManager</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.treevirtual.SelectionManager(obj);
     *         }
     *       </pre></dd>
     *     <dt>tableColumnModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.columnmodel.Resize(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneScroller</dt>
     *       <dd>
     *         Instance of {@link qx.ui.treevirtual.pane.Scroller}.
     *         Custom table pane scroller for the tree
     *         <pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.columnmodel.Resize(obj);
     *         }
     *       </pre>
     *       </dd>
     *   </dl>
     */
    construct: function construct(headings, custom) {
      //
      // Allocate default objects if custom objects are not specified
      //
      if (!custom) {
        custom = {};
      }

      if (!custom.dataModel) {
        custom.dataModel = new qx.ui.treevirtual.SimpleTreeDataModel();
      }

      if (custom.treeColumn === undefined) {
        custom.treeColumn = 0;
        custom.dataModel.setTreeColumn(custom.treeColumn);
      }

      if (!custom.treeDataCellRenderer) {
        custom.treeDataCellRenderer = new qx.ui.treevirtual.SimpleTreeDataCellRenderer();
      }

      if (!custom.defaultDataCellRenderer) {
        custom.defaultDataCellRenderer = new qx.ui.treevirtual.DefaultDataCellRenderer();
      }

      if (!custom.dataRowRenderer) {
        custom.dataRowRenderer = new qx.ui.treevirtual.SimpleTreeDataRowRenderer();
      }

      if (!custom.selectionManager) {
        custom.selectionManager = function (obj) {
          return new qx.ui.treevirtual.SelectionManager(obj);
        };
      }

      if (!custom.tableColumnModel) {
        custom.tableColumnModel = function (obj) {
          return new qx.ui.table.columnmodel.Resize(obj);
        };
      }

      if (!custom.tablePaneScroller) {
        custom.tablePaneScroller = function (obj) {
          return new qx.ui.treevirtual.pane.Scroller(obj);
        };
      } // Specify the column headings.  We accept a single string (one single
      // column) or an array of strings (one or more columns).


      if (qx.lang.Type.isString(headings)) {
        headings = [headings];
      }

      custom.dataModel.setColumns(headings);
      custom.dataModel.setTreeColumn(custom.treeColumn); // Save a reference to the tree with the data model

      custom.dataModel.setTree(this); // Call our superclass constructor

      qx.ui.table.Table.constructor.call(this, custom.dataModel, custom); // Arrange to redisplay edited data following editing

      this.addListener("dataEdited", function (e) {
        this.getDataModel().setData();
      }, this); // By default, present the column visibility button only if there are
      // multiple columns.

      this.setColumnVisibilityButtonVisible(headings.length > 1); // Set sizes

      this.setRowHeight(16);
      this.setMetaColumnCounts(headings.length > 1 ? [1, -1] : [1]); // Overflow on trees is always hidden.  The internal elements scroll.

      this.setOverflow("hidden"); // Set the data cell render.  We use the SimpleTreeDataCellRenderer for the
      // tree column, and our DefaultDataCellRenderer for all other columns.

      var stdcr = custom.treeDataCellRenderer;
      var ddcr = custom.defaultDataCellRenderer;
      var tcm = this.getTableColumnModel();
      var treeCol = this.getDataModel().getTreeColumn();

      for (var i = 0; i < headings.length; i++) {
        tcm.setDataCellRenderer(i, i == treeCol ? stdcr : ddcr);
      } // Set the data row renderer.


      this.setDataRowRenderer(custom.dataRowRenderer); // Set the editor for the tree column, for use if allowNodeEdit is true

      tcm.setCellEditorFactory(treeCol, new qx.ui.treevirtual.celleditor.NodeEditor()); // Move the focus with the mouse.  This controls the ROW focus indicator.

      this.setFocusCellOnPointerMove(true); // In a tree we don't typically want a visible cell focus indicator

      this.setShowCellFocusIndicator(false); // Get the list of pane scrollers

      var scrollers = this._getPaneScrollerArr(); // For each scroller...


      for (var i = 0; i < scrollers.length; i++) {
        // Set the pane scrollers to handle the selection before
        // displaying the focus, so we can manipulate the selected icon.
        scrollers[i].setSelectBeforeFocus(true);
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * Fired when a tree branch which already has content is opened.
       *
       * Event data: the node object from the data model (of the node
       * being opened) as described in
       * {@link qx.ui.treevirtual.SimpleTreeDataModel}
       */
      "treeOpenWithContent": "qx.event.type.Data",

      /**
       * Fired when an empty tree branch is opened.
       *
       * Event data: the node object from the data model (of the node
       * being opened) as described in
       * {@link qx.ui.treevirtual.SimpleTreeDataModel}
       */
      "treeOpenWhileEmpty": "qx.event.type.Data",

      /**
       * Fired when a tree branch is closed.
       *
       * Event data: the node object from the data model (of the node
       * being closed) as described in
       * {@link qx.ui.treevirtual.SimpleTreeDataModel}
       */
      "treeClose": "qx.event.type.Data",

      /**
       * Fired when the selected rows change.
       *
       * Event data: An array of node objects (the selected rows' nodes)
       * from the data model.  Each node object is described in
       * {@link qx.ui.treevirtual.SimpleTreeDataModel}
       */
      "changeSelection": "qx.event.type.Data"
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * Selection Modes {int}
       *
       *   NONE
       *     Nothing can ever be selected.
       *
       *   SINGLE
       *     Allow only one selected item.
       *
       *   SINGLE_INTERVAL
       *     Allow one contiguous interval of selected items.
       *
       *   MULTIPLE_INTERVAL
       *     Allow any set of selected items, whether contiguous or not.
       *
       *   MULTIPLE_INTERVAL_TOGGLE
       *     Like MULTIPLE_INTERVAL, but clicking on an item toggles its selection state.
       */
      SelectionMode: {
        NONE: qx.ui.table.selection.Model.NO_SELECTION,
        SINGLE: qx.ui.table.selection.Model.SINGLE_SELECTION,
        SINGLE_INTERVAL: qx.ui.table.selection.Model.SINGLE_INTERVAL_SELECTION,
        MULTIPLE_INTERVAL: qx.ui.table.selection.Model.MULTIPLE_INTERVAL_SELECTION,
        MULTIPLE_INTERVAL_TOGGLE: qx.ui.table.selection.Model.MULTIPLE_INTERVAL_SELECTION_TOGGLE
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Whether a click on the open/close button should also cause selection of
       * the row.
       */
      openCloseClickSelectsRow: {
        check: "Boolean",
        init: false
      },
      appearance: {
        refine: true,
        init: "treevirtual"
      },
      allowNodeEdit: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Return the data model for this tree.
       *
       * @return {qx.ui.table.ITableModel} The data model.
       */
      getDataModel: function getDataModel() {
        return this.getTableModel();
      },

      /**
       * Set whether lines linking tree children shall be drawn on the tree.
       * Note that not all themes support tree lines.  As of the time of this
       * writing, the Classic theme supports tree lines (and uses +/- icons
       * which lend themselves to tree lines), while the Modern theme, which
       * uses right-facing and downward-facing arrows instead of +/-, does not.
       *
       * @param b {Boolean}
       *   <i>true</i> if tree lines should be shown; <i>false</i> otherwise.
       *
       */
      setUseTreeLines: function setUseTreeLines(b) {
        var dataModel = this.getDataModel();
        var treeCol = dataModel.getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        dcr.setUseTreeLines(b); // Inform the listeners

        if (dataModel.hasListener("dataChanged")) {
          var data = {
            firstRow: 0,
            lastRow: dataModel.getRowCount() - 1,
            firstColumn: 0,
            lastColumn: dataModel.getColumnCount() - 1
          };
          dataModel.fireDataEvent("dataChanged", data);
        }
      },

      /**
       * Get whether lines linking tree children shall be drawn on the tree.
       *
       * @return {Boolean}
       *   <i>true</i> if tree lines are in use;
       *   <i>false</i> otherwise.
       */
      getUseTreeLines: function getUseTreeLines() {
        var treeCol = this.getDataModel().getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        return dcr.getUseTreeLines();
      },

      /**
       * Set whether the open/close button should be displayed on a branch,
       * even if the branch has no children.
       *
       * @param b {Boolean}
       *   <i>true</i> if the open/close button should be shown;
       *   <i>false</i> otherwise.
       *
       */
      setAlwaysShowOpenCloseSymbol: function setAlwaysShowOpenCloseSymbol(b) {
        var dataModel = this.getDataModel();
        var treeCol = dataModel.getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        dcr.setAlwaysShowOpenCloseSymbol(b); // Inform the listeners

        if (dataModel.hasListener("dataChanged")) {
          var data = {
            firstRow: 0,
            lastRow: dataModel.getRowCount() - 1,
            firstColumn: 0,
            lastColumn: dataModel.getColumnCount() - 1
          };
          dataModel.fireDataEvent("dataChanged", data);
        }
      },

      /**
       * Set whether drawing of first-level tree-node lines are disabled even
       * if drawing of tree lines is enabled.
       *
       * @param b {Boolean}
       *   <i>true</i> if first-level tree lines should be disabled;
       *   <i>false</i> for normal operation.
       *
       */
      setExcludeFirstLevelTreeLines: function setExcludeFirstLevelTreeLines(b) {
        var dataModel = this.getDataModel();
        var treeCol = dataModel.getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        dcr.setExcludeFirstLevelTreeLines(b); // Inform the listeners

        if (dataModel.hasListener("dataChanged")) {
          var data = {
            firstRow: 0,
            lastRow: dataModel.getRowCount() - 1,
            firstColumn: 0,
            lastColumn: dataModel.getColumnCount() - 1
          };
          dataModel.fireDataEvent("dataChanged", data);
        }
      },

      /**
       * Get whether drawing of first-level tree lines should be disabled even
       * if drawing of tree lines is enabled.
       * (See also {@link #getUseTreeLines})
       *
       * @return {Boolean}
       *   <i>true</i> if tree lines are in use;
       *   <i>false</i> otherwise.
       */
      getExcludeFirstLevelTreeLines: function getExcludeFirstLevelTreeLines() {
        var treeCol = this.getDataModel().getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        return dcr.getExcludeFirstLevelTreeLines();
      },

      /**
       * Set whether the open/close button should be displayed on a branch,
       * even if the branch has no children.
       *
       * @return {Boolean}
       *   <i>true</i> if tree lines are in use;
       *   <i>false</i> otherwise.
       */
      getAlwaysShowOpenCloseSymbol: function getAlwaysShowOpenCloseSymbol() {
        var treeCol = this.getDataModel().getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        return dcr.getAlwaysShowOpenCloseSymbol();
      },

      /**
       * Returns the position of the open/close button for a node
       *
       * @return {Object} The position of the open/close button within the tree row
       */
      getOpenCloseButtonPosition: function getOpenCloseButtonPosition(node) {
        var treeCol = this.getDataModel().getTreeColumn();
        var dcr = this.getTableColumnModel().getDataCellRenderer(treeCol);
        var rowPos = dcr.getOpenCloseButtonPosition(this, node); // Get the order of the columns

        var tcm = this.getTableColumnModel();

        var columnPositions = tcm._getColToXPosMap(); // Calculate the position of the beginning of the tree column


        var left = qx.bom.element.Location.getLeft(this.getContentElement().getDomElement());

        for (var i = 0; i < columnPositions[treeCol].visX; i++) {
          left += tcm.getColumnWidth(columnPositions[i].visX);
        }

        rowPos.left += left;
        return rowPos;
      },

      /**
       * Set the selection mode.
       *
       * @param mode {Integer}
       *   The selection mode to be used.  It may be any of:
       *     <pre>
       *       qx.ui.treevirtual.TreeVirtual.SelectionMode.NONE:
       *          Nothing can ever be selected.
       *
       *       qx.ui.treevirtual.TreeVirtual.SelectionMode.SINGLE
       *          Allow only one selected item.
       *
       *       qx.ui.treevirtual.TreeVirtual.SelectionMode.SINGLE_INTERVAL
       *          Allow one contiguous interval of selected items.
       *
       *       qx.ui.treevirtual.TreeVirtual.SelectionMode.MULTIPLE_INTERVAL
       *          Allow any selected items, whether contiguous or not.
       *     </pre>
       *
       */
      setSelectionMode: function setSelectionMode(mode) {
        this.getSelectionModel().setSelectionMode(mode);
      },

      /**
       * Get the selection mode currently in use.
       *
       * @return {Integer}
       *   One of the values documented in {@link #setSelectionMode}
       */
      getSelectionMode: function getSelectionMode() {
        return this.getSelectionModel().getSelectionMode();
      },

      /**
       * Obtain the entire hierarchy of labels from the root down to the
       * specified node.
       *
       * @param nodeReference {Object | Integer}
       *   The node for which the hierarchy is desired.  The node can be
       *   represented either by the node object, or the node id (as would have
       *   been returned by addBranch(), addLeaf(), etc.)
       *
       * @return {Array}
       *   The returned array contains one string for each label in the
       *   hierarchy of the node specified by the parameter.  Element 0 of the
       *   array contains the label of the root node, element 1 contains the
       *   label of the node immediately below root in the specified node's
       *   hierarchy, etc., down to the last element in the array contain the
       *   label of the node referenced by the parameter.
       */
      getHierarchy: function getHierarchy(nodeReference) {
        var _this = this;

        var components = [];
        var node;
        var nodeId;

        if (typeof nodeReference == "object") {
          node = nodeReference;
          nodeId = node.nodeId;
        } else if (typeof nodeReference == "number") {
          nodeId = nodeReference;
        } else {
          throw new Error("Expected node object or node id");
        }

        function addHierarchy(nodeId) {
          // If we're at the root...
          if (!nodeId) {
            // ... then we're done
            return;
          } // Get the requested node


          var node = _this.getDataModel().getData()[nodeId]; // Add its label to the hierarchy components


          components.unshift(node.label); // Call recursively to our parent node.

          addHierarchy(node.parentNodeId);
        }

        addHierarchy(nodeId);
        return components;
      },

      /**
       * Return the nodes that are currently selected.
       *
       * @return {Array}
       *   An array containing the nodes that are currently selected.
       */
      getSelectedNodes: function getSelectedNodes() {
        return this.getDataModel().getSelectedNodes();
      },

      /**
       * Event handler. Called when a key was pressed.
       *
       * We handle the Enter key to toggle opened/closed tree state.  All
       * other keydown events are passed to our superclass.
       *
       * @param evt {Map}
       *   The event.
       *
       */
      _onKeyDown: function _onKeyDown(evt) {
        if (!this.getEnabled()) {
          return;
        }

        var identifier = evt.getKeyIdentifier();
        var consumed = false;
        var modifiers = evt.getModifiers();

        if (modifiers == 0) {
          switch (identifier) {
            case "Enter":
              // Get the data model
              var dm = this.getDataModel();
              var focusedCol = this.getFocusedColumn();
              var treeCol = dm.getTreeColumn();

              if (focusedCol == treeCol) {
                // Get the focused node
                var focusedRow = this.getFocusedRow();
                var node = dm.getNode(focusedRow);

                if (!node.bHideOpenClose && node.type != qx.ui.treevirtual.SimpleTreeDataModel.Type.LEAF) {
                  dm.setState(node, {
                    bOpened: !node.bOpened
                  });
                }

                consumed = true;
              }

              break;

            case "Left":
              this.moveFocusedCell(-1, 0);
              break;

            case "Right":
              this.moveFocusedCell(1, 0);
              break;
          }
        } else if (modifiers == qx.event.type.Dom.CTRL_MASK) {
          switch (identifier) {
            case "Left":
              // Get the data model
              var dm = this.getDataModel(); // Get the focused node

              var focusedRow = this.getFocusedRow();
              var treeCol = dm.getTreeColumn();
              var node = dm.getNode(focusedRow); // If it's an open branch and open/close is allowed...

              if (node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.BRANCH && !node.bHideOpenClose && node.bOpened) {
                // ... then close it
                dm.setState(node, {
                  bOpened: !node.bOpened
                });
              } // Reset the focus to the current node


              this.setFocusedCell(treeCol, focusedRow, true);
              consumed = true;
              break;

            case "Right":
              // Get the data model
              var dm = this.getDataModel(); // Get the focused node

              focusedRow = this.getFocusedRow();
              treeCol = dm.getTreeColumn();
              node = dm.getNode(focusedRow); // If it's a closed branch and open/close is allowed...

              if (node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.BRANCH && !node.bHideOpenClose && !node.bOpened) {
                // ... then open it
                dm.setState(node, {
                  bOpened: !node.bOpened
                });
              } // Reset the focus to the current node


              this.setFocusedCell(treeCol, focusedRow, true);
              consumed = true;
              break;
          }
        } else if (modifiers == qx.event.type.Dom.SHIFT_MASK) {
          switch (identifier) {
            case "Left":
              // Get the data model
              var dm = this.getDataModel(); // Get the focused node

              var focusedRow = this.getFocusedRow();
              var treeCol = dm.getTreeColumn();
              var node = dm.getNode(focusedRow); // If we're not at the top-level already...

              if (node.parentNodeId) {
                // Find out what rendered row our parent node is at
                var rowIndex = dm.getRowFromNodeId(node.parentNodeId); // Set the focus to our parent

                this.setFocusedCell(this._focusedCol, rowIndex, true);
              }

              consumed = true;
              break;

            case "Right":
              // Get the data model
              var dm = this.getDataModel(); // Get the focused node

              focusedRow = this.getFocusedRow();
              treeCol = dm.getTreeColumn();
              node = dm.getNode(focusedRow); // If we're on a branch and open/close is allowed...

              if (node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.BRANCH && !node.bHideOpenClose) {
                // ... then first ensure the branch is open
                if (!node.bOpened) {
                  dm.setState(node, {
                    bOpened: !node.bOpened
                  });
                } // If this node has children...


                if (node.children.length > 0) {
                  // ... then move the focus to the first child
                  this.moveFocusedCell(0, 1);
                }
              }

              consumed = true;
              break;
          }
        } // Was this one of our events that we handled?


        if (consumed) {
          // Yup.  Don't propagate it.
          evt.preventDefault();
          evt.stopPropagation();
        } else {
          // It's not one of ours.  Let our superclass handle this event
          qx.ui.treevirtual.TreeVirtual.prototype._onKeyDown.base.call(this, evt);
        }
      },

      /**
       * Event handler. Called when the selection has changed.
       *
       * @param evt {Map}
       *   The event.
       *
       */
      _onSelectionChanged: function _onSelectionChanged(evt) {
        // Clear the old list of selected nodes
        this.getDataModel()._clearSelections(); // If selections are allowed, pass an event to our listeners


        if (this.getSelectionMode() != qx.ui.treevirtual.TreeVirtual.SelectionMode.NONE) {
          var selectedNodes = this._calculateSelectedNodes(); // Get the now-focused


          this.fireDataEvent("changeSelection", selectedNodes);
        } // Call the superclass method


        qx.ui.treevirtual.TreeVirtual.prototype._onSelectionChanged.base.call(this, evt);
      },

      /**
       * Calculate and return the set of nodes which are currently selected by
       * the user, on the screen.  In the process of calculating which nodes
       * are selected, the nodes corresponding to the selected rows on the
       * screen are marked as selected by setting their <i>bSelected</i>
       * property to true, and all previously-selected nodes have their
       * <i>bSelected</i> property reset to false.
       *
       * @return {Array}
       *   An array of nodes matching the set of rows which are selected on the
       *   screen.
       */
      _calculateSelectedNodes: function _calculateSelectedNodes() {
        // Create an array of nodes that are now selected
        var stdcm = this.getDataModel();
        var selectedRanges = this.getSelectionModel().getSelectedRanges();
        var selectedNodes = [];
        var node;

        for (var i = 0; i < selectedRanges.length; i++) {
          for (var j = selectedRanges[i].minIndex; j <= selectedRanges[i].maxIndex; j++) {
            node = stdcm.getNode(j);
            stdcm.setState(node, {
              bSelected: true
            });
            selectedNodes.push(node);
          }
        }

        return selectedNodes;
      },

      /**
       * Set the overflow mode.
       *
       * @param s {String}
       *   Overflow mode.  The only allowable mode is "hidden".
       *
       *
       * @throws {Error}
       *   Error if tree overflow mode is other than "hidden"
       */
      setOverflow: function setOverflow(s) {
        if (s != "hidden") {
          throw new Error("Tree overflow must be hidden.  The internal elements of it will scroll.");
        }
      }
    }
  });
  qx.ui.treevirtual.TreeVirtual.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.cellrenderer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      },
      "qx.util.ResourceManager": {
        "construct": true
      },
      "qx.theme.manager.Appearance": {
        "construct": true
      },
      "qx.io.ImageLoader": {},
      "qx.bom.client.Css": {},
      "qx.bom.element.BoxSizing": {},
      "qx.ui.treevirtual.SimpleTreeDataModel": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxsizing": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
       * David Perez Carmona (david-perez)
  
  ************************************************************************ */

  /**
   * A data cell renderer for the tree column of a simple tree
   *
   * This cell renderer has provisions for subclasses to easily extend the
   * appearance of the tree. If the tree should contain images, labels,
   * etc. before the indentation, the subclass should override the method
   * _addExtraContentBeforeIndentation(). Similarly, content can be added before
   * the icon by overriding _addExtraContentBeforeIcon(), and before the label
   * by overriding _addExtraContentBeforeLabel().
   *
   * Each of these overridden methods that calls _addImage() can provide, as
   * part of the map passed to _addImage(), a member called "tooltip" which
   * contains the tool tip to present when the mouse is hovered over the image.
   *
   * If this class is subclassed to form a new cell renderer, an instance of it
   * must be provided, via the 'custom' parameter, to the TreeVirtual
   * constructor.
   */
  qx.Class.define("qx.ui.treevirtual.SimpleTreeDataCellRenderer", {
    extend: qx.ui.table.cellrenderer.Abstract,
    construct: function construct() {
      var STDCR = qx.ui.treevirtual.SimpleTreeDataCellRenderer; // Begin preloading of the tree images, if not already requested.

      if (STDCR.__bVirgin__P_535_0) {
        STDCR.__preloadImages__P_535_1();

        STDCR.__bVirgin__P_535_0 = false;
      }

      qx.ui.table.cellrenderer.Abstract.constructor.call(this);
      this.__am__P_535_2 = qx.util.AliasManager.getInstance();
      this.__rm__P_535_3 = qx.util.ResourceManager.getInstance();
      this.__tm__P_535_4 = qx.theme.manager.Appearance.getInstance(); // Base URL used for indentation

      this.BLANK = this.__rm__P_535_3.toUri(this.__am__P_535_2.resolve("static/blank.png"));
    },
    statics: {
      /** File names of each of the tree icons */
      __icon__P_535_5: {},

      /** Whether we have not yet requested pre-loading of images */
      __bVirgin__P_535_0: true,

      /**
       * Request preloading of images so they appear immediately upon rendering
       */
      __preloadImages__P_535_1: function __preloadImages__P_535_1() {
        var STDCR = qx.ui.treevirtual.SimpleTreeDataCellRenderer;
        var ImageLoader = qx.io.ImageLoader;
        var am = qx.util.AliasManager.getInstance();
        var rm = qx.util.ResourceManager.getInstance();
        var tm = qx.theme.manager.Appearance.getInstance();

        var loadImage = function loadImage(f) {
          ImageLoader.load(rm.toUri(am.resolve(f)));
        };

        STDCR.__icon__P_535_5.line = tm.styleFrom("treevirtual-line");
        loadImage(STDCR.__icon__P_535_5.line.icon);
        STDCR.__icon__P_535_5.contract = tm.styleFrom("treevirtual-contract");
        loadImage(STDCR.__icon__P_535_5.contract.icon);
        STDCR.__icon__P_535_5.expand = tm.styleFrom("treevirtual-expand");
        loadImage(STDCR.__icon__P_535_5.expand.icon);
        STDCR.__icon__P_535_5.onlyContract = tm.styleFrom("treevirtual-only-contract");
        loadImage(STDCR.__icon__P_535_5.onlyContract.icon);
        STDCR.__icon__P_535_5.onlyExpand = tm.styleFrom("treevirtual-only-expand");
        loadImage(STDCR.__icon__P_535_5.onlyExpand.icon);
        STDCR.__icon__P_535_5.startContract = tm.styleFrom("treevirtual-start-contract");
        loadImage(STDCR.__icon__P_535_5.startContract.icon);
        STDCR.__icon__P_535_5.startExpand = tm.styleFrom("treevirtual-start-expand");
        loadImage(STDCR.__icon__P_535_5.startExpand.icon);
        STDCR.__icon__P_535_5.endContract = tm.styleFrom("treevirtual-end-contract");
        loadImage(STDCR.__icon__P_535_5.endContract.icon);
        STDCR.__icon__P_535_5.endExpand = tm.styleFrom("treevirtual-end-expand");
        loadImage(STDCR.__icon__P_535_5.endExpand.icon);
        STDCR.__icon__P_535_5.crossContract = tm.styleFrom("treevirtual-cross-contract");
        loadImage(STDCR.__icon__P_535_5.crossContract.icon);
        STDCR.__icon__P_535_5.crossExpand = tm.styleFrom("treevirtual-cross-expand");
        loadImage(STDCR.__icon__P_535_5.crossExpand.icon);
        STDCR.__icon__P_535_5.end = tm.styleFrom("treevirtual-end");
        loadImage(STDCR.__icon__P_535_5.end.icon);
        STDCR.__icon__P_535_5.cross = tm.styleFrom("treevirtual-cross");
        loadImage(STDCR.__icon__P_535_5.cross.icon);
      }
    },
    properties: {
      /**
       * Set whether lines linking tree children shall be drawn on the tree
       * if the theme supports tree lines.
       */
      useTreeLines: {
        check: "Boolean",
        init: true
      },

      /**
       * When true, exclude only the first-level tree lines, creating,
       * effectively, multiple unrelated root nodes.
       */
      excludeFirstLevelTreeLines: {
        check: "Boolean",
        init: false
      },

      /**
       * Set whether the open/close button should be displayed on a branch, even
       * if the branch has no children.
       */
      alwaysShowOpenCloseSymbol: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __am__P_535_2: null,
      __tm__P_535_4: null,
      __rm__P_535_3: null,
      // overridden
      _onChangeTheme: function _onChangeTheme() {
        qx.ui.treevirtual.SimpleTreeDataCellRenderer.prototype._onChangeTheme.base.call(this);

        qx.ui.treevirtual.SimpleTreeDataCellRenderer.__preloadImages__P_535_1();
      },
      // overridden
      _getCellStyle: function _getCellStyle(cellInfo) {
        var node = cellInfo.value; // Return the style for the div for the cell.  If there's cell-specific
        // style information provided, append it.

        var html = qx.ui.treevirtual.SimpleTreeDataCellRenderer.prototype._getCellStyle.base.call(this, cellInfo) + (node.cellStyle ? node.cellStyle + ";" : "");
        return html;
      },
      // overridden
      _getContentHtml: function _getContentHtml(cellInfo) {
        var html = ""; // Horizontal position

        var pos = 0; // If needed, add extra content before indentation

        var extra = this._addExtraContentBeforeIndentation(cellInfo, pos);

        html += extra.html;
        pos = extra.pos; // Add the indentation (optionally with tree lines)

        var indentation = this._addIndentation(cellInfo, pos);

        html += indentation.html;
        pos = indentation.pos; // If needed, add extra content before icon

        extra = this._addExtraContentBeforeIcon(cellInfo, pos);
        html += extra.html;
        pos = extra.pos; // Add the node icon

        var icon = this._addIcon(cellInfo, pos);

        html += icon.html;
        pos = icon.pos; // If needed, add extra content before label

        extra = this._addExtraContentBeforeLabel(cellInfo, pos);
        html += extra.html;
        pos = extra.pos; // store this position on the node so we can use it for the NodeEditor without recalculation

        cellInfo.value.labelPos = pos; // Add the node's label

        html += this._addLabel(cellInfo, pos);
        return html;
      },

      /**
       * Add an image to the tree.  This might be a visible icon or it may be
       * part of the indentation.
       *
       * @param imageInfo {Map}
       *   How to display the image.  It optionally includes any of the
       *   following:
       *   <dl>
       *     <dt>position {Map}</dt>
       *     <dd>
       *       If provided, a div is created to hold the image.  The div's top,
       *       right, bottom, left, width, and/or height may be specified with
       *       members of this map.  Each is expected to be an integer value.
       *     </dd>
       *     <dt>imageWidth, imageHeight</dt>
       *     <dd>
       *       The image's width and height.  These are used only if both are
       *       specified.
       *     </dd>
       *   </dl>
       *
       * @return {String}
       *   The html for this image, possibly with a surrounding div (see
       *   'position', above).
       */
      _addImage: function _addImage(imageInfo) {
        var html = []; // Resolve the URI

        var source = this.__rm__P_535_3.toUri(this.__am__P_535_2.resolve(imageInfo.url)); // If we've been given positioning attributes, enclose image in a div


        if (imageInfo.position) {
          var pos = imageInfo.position;
          html.push('<div style="position:absolute;');

          if (qx.core.Environment.get("css.boxsizing")) {
            html.push(qx.bom.element.BoxSizing.compile("content-box"));
          }

          if (pos.top !== undefined) {
            html.push('top:' + pos.top + 'px;');
          }

          if (pos.right !== undefined) {
            html.push('right:' + pos.right + 'px;');
          }

          if (pos.bottom !== undefined) {
            html.push('bottom:' + pos.bottom + 'px;');
          }

          if (pos.left !== undefined) {
            html.push('left:' + pos.left + 'px;');
          }

          if (pos.width !== undefined) {
            html.push('width:' + pos.width + 'px;');
          }

          if (pos.height !== undefined) {
            html.push('height:' + pos.height + 'px;');
          }

          html.push('">');
        } // Don't use an image tag.  They render differently in Firefox and IE7
        // even if both are enclosed in a div specified as content box.  Instead,
        // add the image as the background image of a div.


        html.push('<div style="');
        html.push('background-image:url(' + source + ');');
        html.push('background-repeat:no-repeat;');

        if (imageInfo.imageWidth && imageInfo.imageHeight) {
          html.push(';width:' + imageInfo.imageWidth + 'px' + ';height:' + imageInfo.imageHeight + 'px');
        }

        var tooltip = imageInfo.tooltip;

        if (tooltip != null) {
          html.push('" title="' + tooltip);
        }

        html.push('">&nbsp;</div>');

        if (imageInfo.position) {
          html.push('</div>');
        }

        return html.join("");
      },

      /**
       * Add the indentation for this node of the tree.
       *
       * The indentation optionally includes tree lines.  Whether tree lines are
       * used depends on (a) the properties 'useTreeLines' and
       * 'excludeFirstLevelTreelines' within this class; and (b) the widget
       * theme in use (some themes don't support tree lines).
       *
       * @param cellInfo {Map} The information about the cell.
       *   See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {Map}
       *   The returned map contains an 'html' member which contains the html for
       *   the indentation, and a 'pos' member which is the starting position
       *   plus the width of the indentation.
       */
      _addIndentation: function _addIndentation(cellInfo, pos) {
        var node = cellInfo.value;
        var imageData;
        var html = ""; // Generate the indentation.  Obtain icon determination values once
        // rather than each time through the loop.

        var bUseTreeLines = this.getUseTreeLines();
        var bExcludeFirstLevelTreeLines = this.getExcludeFirstLevelTreeLines();
        var bAlwaysShowOpenCloseSymbol = this.getAlwaysShowOpenCloseSymbol();

        for (var i = 0; i < node.level; i++) {
          imageData = this._getIndentSymbol(i, node, bUseTreeLines, bAlwaysShowOpenCloseSymbol, bExcludeFirstLevelTreeLines);
          var rowHeight = cellInfo.table.getRowHeight();
          html += this._addImage({
            url: imageData.icon,
            position: {
              top: 0 + (imageData.paddingTop || 0),
              left: pos + (imageData.paddingLeft || 0),
              width: rowHeight + 3,
              height: rowHeight
            },
            imageWidth: rowHeight,
            imageHeight: rowHeight
          });
          pos += rowHeight + 3;
        }

        return {
          html: html,
          pos: pos
        };
      },

      /**
       * Add the icon for this node of the tree.
       *
       * @param cellInfo {Map} The information about the cell.
       *   See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {Map}
       *   The returned map contains an 'html' member which contains the html for
       *   the icon, and a 'pos' member which is the starting position plus the
       *   width of the icon.
       */
      _addIcon: function _addIcon(cellInfo, pos) {
        var node = cellInfo.value; // Add the node's icon

        var imageUrl = node.bSelected ? node.iconSelected : node.icon;

        if (!imageUrl) {
          if (node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.LEAF) {
            var o = this.__tm__P_535_4.styleFrom("treevirtual-file");
          } else {
            var states = {
              opened: node.bOpened
            };

            var o = this.__tm__P_535_4.styleFrom("treevirtual-folder", states);
          }

          imageUrl = o.icon;
        }

        var rowHeight = cellInfo.table.getRowHeight();

        var html = this._addImage({
          url: imageUrl,
          position: {
            top: 0,
            left: pos,
            width: rowHeight + 3,
            height: rowHeight
          },
          imageWidth: rowHeight,
          imageHeight: rowHeight
        });

        return {
          html: html,
          pos: pos + rowHeight + 3
        };
      },

      /**
       * Add the label for this node of the tree.
       *
       * @param cellInfo {Map} The information about the cell.
       *   See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *   Additionally, if defined, the labelSpanStyle member is used to apply
       *   style to the span containing the label.  (This member is for use by
       *   subclasses; it's not otherwise used by this class.)
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {String}
       *   The html for the label.
       */
      _addLabel: function _addLabel(cellInfo, pos) {
        var node = cellInfo.value;
        var label = node.label;
        {
          if (label && label.translate) {
            label = label.translate();
          }
        } // Add the node's label.  We calculate the "left" property with: each
        // tree line (indentation) icon is 19 pixels wide; the folder icon is 16
        // pixels wide, there are two pixels of padding at the left, and we want
        // 2 pixels between the folder icon and the label

        var html = "<div style=\"position:absolute;left:" + pos + 'px;' + 'top:0;' + (node.labelStyle ? node.labelStyle + ";" : "") + '">' + '<span' + (cellInfo.labelSpanStyle ? 'style="' + cellInfo.labelSpanStyle + ';"' : "") + '>' + label + '</span>' + '</div>';
        return html;
      },

      /**
       * Adds extra content just before the indentation.
       *
       * @param cellInfo {Map} The information about the cell.
       *      See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {Map}
       *   The returned map contains an 'html' member which contains the html for
       *   the indentation, and a 'pos' member which is the starting position
       *   plus the width of the indentation.
       */
      _addExtraContentBeforeIndentation: function _addExtraContentBeforeIndentation(cellInfo, pos) {
        return {
          html: '',
          pos: pos
        };
      },

      /**
       * Adds extra content just before the icon.
       *
       * @param cellInfo {Map} The information about the cell.
       *      See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {Map}
       *   The returned map contains an 'html' member which contains the html for
       *   the indentation, and a 'pos' member which is the starting position
       *   plus the width of the indentation.
       */
      _addExtraContentBeforeIcon: function _addExtraContentBeforeIcon(cellInfo, pos) {
        return {
          html: '',
          pos: pos
        };
      },

      /**
       * Adds extra content just before the label.
       *
       * @param cellInfo {Map} The information about the cell.
       *      See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       *
       * @param pos {Integer}
       *   The position from the left edge of the column at which to render this
       *   item.
       *
       * @return {Map}
       *   The returned map contains an 'html' member which contains the html for
       *   the indentation, and a 'pos' member which is the starting position
       *   plus the width of the indentation.
       */
      _addExtraContentBeforeLabel: function _addExtraContentBeforeLabel(cellInfo, pos) {
        return {
          html: '',
          pos: pos
        };
      },

      /**
       * Determine the symbol to use for indentation of a tree row, at a
       * particular column.  The indentation to use may be just white space or
       * may be a tree line.  Tree lines come in numerous varieties, so the
       * appropriate one is selected.
       *
       * @param column {Integer}
       *   The column of indentation being requested, zero-relative
       *
       * @param node {Node}
       *   The node being displayed in the row.  The properties of a node are
       *   described in {@link qx.ui.treevirtual.SimpleTreeDataModel}
       *
       * @param bUseTreeLines {Boolean}
       *   Whether to find an appropriate tree line icon, or simply provide
       *   white space.
       *
       * @param bAlwaysShowOpenCloseSymbol {Boolean}
       *   Whether to display the open/close icon for a node even if it has no
       *   children.
       *
       * @param bExcludeFirstLevelTreeLines {Boolean}
       *   If bUseTreeLines is enabled, then further filtering of the left-most
       *   tree line may be specified here.  If <i>true</i> then the left-most
       *   tree line, between top-level siblings, will not be displayed.
       *   If <i>false</i>, then the left-most tree line will be displayed
       *   just like all of the other tree lines.
       *
       * @return {Map} map of image properties.
       */
      _getIndentSymbol: function _getIndentSymbol(column, node, bUseTreeLines, bAlwaysShowOpenCloseSymbol, bExcludeFirstLevelTreeLines) {
        var STDCR = qx.ui.treevirtual.SimpleTreeDataCellRenderer; // If we're in column 0 and excludeFirstLevelTreeLines is enabled, then
        // we treat this as if no tree lines were requested.

        if (column == 0 && bExcludeFirstLevelTreeLines) {
          bUseTreeLines = false;
        } // If we're not on the final column...


        if (column < node.level - 1) {
          // then return either a line or a blank icon, depending on
          // bUseTreeLines
          return bUseTreeLines && !node.lastChild[column] ? STDCR.__icon__P_535_5.line : {
            icon: this.BLANK
          };
        }

        var bLastChild = node.lastChild[node.lastChild.length - 1]; // Is this a branch node that does not have the open/close button hidden?

        if (node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.BRANCH && !node.bHideOpenClose) {
          // Does this node have any children, or do we always want the
          // open/close symbol to be shown?
          if (node.children.length > 0 || bAlwaysShowOpenCloseSymbol) {
            // If we're not showing tree lines...
            if (!bUseTreeLines) {
              // ... then just use an expand or contract
              return node.bOpened ? STDCR.__icon__P_535_5.contract : STDCR.__icon__P_535_5.expand;
            } // Are we looking at a top-level, first child of its parent?


            if (column == 0 && node.bFirstChild) {
              // Yup.  If it's also a last child...
              if (bLastChild) {
                // ... then use no tree lines.
                return node.bOpened ? STDCR.__icon__P_535_5.onlyContract : STDCR.__icon__P_535_5.onlyExpand;
              } else {
                // otherwise, use descender lines but no ascender.
                return node.bOpened ? STDCR.__icon__P_535_5.startContract : STDCR.__icon__P_535_5.startExpand;
              }
            } // It's not a top-level, first child.  Is this the last child of its
            // parent?


            if (bLastChild) {
              // Yup.  Return an ending expand or contract.
              return node.bOpened ? STDCR.__icon__P_535_5.endContract : STDCR.__icon__P_535_5.endExpand;
            } // Otherwise, return a crossing expand or contract.


            return node.bOpened ? STDCR.__icon__P_535_5.crossContract : STDCR.__icon__P_535_5.crossExpand;
          }
        } // This node does not have any children.  Return an end or cross, if
        // we're using tree lines.


        if (bUseTreeLines) {
          // If this is a child of the root node...
          if (node.parentNodeId == 0) {
            // If this is the only child...
            if (bLastChild && node.bFirstChild) {
              // ... then return a blank.
              return {
                icon: this.BLANK
              };
            } // Otherwise, if this is the last child...


            if (bLastChild) {
              // ... then return an end line.
              return STDCR.__icon__P_535_5.end;
            } // Otherwise if this is the first child and is a branch...


            if (node.bFirstChild && node.type == qx.ui.treevirtual.SimpleTreeDataModel.Type.BRANCH) {
              // ... then return a start line.
              return node.bOpened ? STDCR.__icon__P_535_5.startContract : STDCR.__icon__P_535_5.startExpand;
            }
          } // If this is a last child, return and ending line; otherwise cross.


          return bLastChild ? STDCR.__icon__P_535_5.end : STDCR.__icon__P_535_5.cross;
        }

        return {
          icon: this.BLANK
        };
      },

      /**
       * Determine the position in the cell of the open/close button image
       *
       * @param table {Table}
       *   The column of indentation being requested, zero-relative
       *
       * @param node {Node}
       *   The node being displayed in the row.  The properties of a node are
       *   described in {@link qx.ui.treevirtual.SimpleTreeDataModel}
       *
       * @return {Object} Position of the Open/Close Button
       */
      getOpenCloseButtonPosition: function getOpenCloseButtonPosition(table, node) {
        var padding = 2;
        var width = table.getRowHeight() + 3;
        return {
          top: 0,
          left: (node.level - 1) * width + padding,
          width: width,
          height: table.getRowHeight()
        };
      }
    },
    destruct: function destruct() {
      this.__am__P_535_2 = this.__rm__P_535_3 = this.__tm__P_535_4 = null;
    }
  });
  qx.ui.treevirtual.SimpleTreeDataCellRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.rowrenderer.Default": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 Derrell Lipman
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */

  /**
   * A data row renderer for a simple tree row
   */
  qx.Class.define("qx.ui.treevirtual.SimpleTreeDataRowRenderer", {
    extend: qx.ui.table.rowrenderer.Default,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.table.rowrenderer.Default.constructor.call(this);
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      updateDataRowElement: function updateDataRowElement(rowInfo, rowElem) {
        // If the node is selected, select the row
        var tree = rowInfo.table;
        var rowData = rowInfo.rowData;
        var tableModel = tree.getTableModel();
        var treeCol = tableModel.getTreeColumn();
        var node = rowData[treeCol]; // Set the row's selected state based on the data model

        rowInfo.selected = node.bSelected;

        if (node.bSelected) {
          // Ensure that the selection model knows it's selected
          var row = rowInfo.row;

          tree.getSelectionModel()._addSelectionInterval(row, row);
        } // Now call our superclass


        qx.ui.treevirtual.SimpleTreeDataRowRenderer.prototype.updateDataRowElement.base.call(this, rowInfo, rowElem);
      }
    }
  });
  qx.ui.treevirtual.SimpleTreeDataRowRenderer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.pane.Scroller": {
        "require": true
      },
      "qx.ui.core.scroll.MScrollBarFactory": {
        "require": true
      },
      "qx.ui.treevirtual.SimpleTreeDataModel": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 Tartan Solutions, Inc, http://www.tartansolutions.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Patrick Buxton
  
  ************************************************************************ */

  /**
   * An overridden pane Scroller for the treevirtual to allow capture of
   * the mouse dblclick event in the tree column. To prevent starting an
   * edit when the tree node editing is turned on and the open/close button
   * is tapped quickly
   */
  qx.Class.define("qx.ui.treevirtual.pane.Scroller", {
    extend: qx.ui.table.pane.Scroller,
    include: [qx.ui.core.scroll.MScrollBarFactory],

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Event handler. Called when the user double tapped a pointer button over the pane.
       *
       * @param e {Map} the event.
       */
      _onDbltapPane: function _onDbltapPane(e) {
        var pageX = e.getDocumentLeft();
        var pageY = e.getDocumentTop();

        var col = this._getColumnForPageX(pageX);

        var row = this._getRowForPagePos(pageX, pageY);

        if (col !== null && row !== null) {
          // check if the user is tapping on the open/close button of the tree
          var tree = this.getTable();
          var tableModel = tree.getTableModel();

          if (tableModel instanceof qx.ui.treevirtual.SimpleTreeDataModel && col === tableModel.getTreeColumn()) {
            // Was the click on the open/close button? We get the position and add a bit of
            // latitude to that
            var x = e.getViewportLeft();
            var latitude = 2; // Get the node to which this event applies

            var node = tree.getDataModel().getNode(row);
            var buttonPos = tree.getOpenCloseButtonPosition(node);

            if (x >= buttonPos.left - latitude && x <= buttonPos.left + buttonPos.width + latitude) {
              return;
            }
          }
        }

        qx.ui.treevirtual.pane.Scroller.prototype._onDbltapPane.base.call(this, e);
      }
    }
  });
  qx.ui.treevirtual.pane.Scroller.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.table.celleditor.TextField": {
        "require": true
      },
      "qx.lang.Object": {},
      "qx.ui.form.TextField": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 Patrick Buxton
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Pat Buxton (rad-pat)
  
  ************************************************************************ */

  /**
   * A cell editor factory for editing a virtualtree node label
   */
  qx.Class.define("qx.ui.treevirtual.celleditor.NodeEditor", {
    extend: qx.ui.table.celleditor.TextField,
    members: {
      // overridden
      getCellEditorValue: function getCellEditorValue(cellEditor) {
        var label = cellEditor.getValue(); // This will be the new label for the Tree Node
        // validation function will be called with new and old label

        var validationFunc = this.getValidationFunction();

        if (validationFunc) {
          label = validationFunc(label, cellEditor.originalLabel);
        }

        var newValue = qx.lang.Object.clone(cellEditor.originalValue);
        newValue.label = label;
        return newValue;
      },
      // interface implementation
      createCellEditor: function createCellEditor(cellInfo) {
        if (!cellInfo.table.getTableModel().isNodeEditable(cellInfo.row)) {
          return null;
        }

        var cellEditor = this._createEditor(); // The value in the case of a Tree is a Node and we want the label


        if (cellInfo.value === null || typeof cellInfo.value != "object") {
          cellInfo.value = {
            label: "",
            labelPos: 0
          };
        }

        var label = cellInfo.value.label;
        cellEditor.originalValue = cellInfo.value;
        cellEditor.originalLabel = label;
        cellEditor.setValue("" + label); // dynamically pad to the position of the node label - calculated in CellRenderer

        cellEditor.setPaddingLeft(cellInfo.value.labelPos);
        cellEditor.addListener("appear", function () {
          cellEditor.selectAllText();
        });
        return cellEditor;
      },
      _createEditor: function _createEditor() {
        var cellEditor = new qx.ui.form.TextField();
        cellEditor.setAppearance("treevirtual-node-editor-textfield");
        return cellEditor;
      }
    }
  });
  qx.ui.treevirtual.celleditor.NodeEditor.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.event.Timer": {
        "construct": true
      },
      "qx.ui.core.queue.Manager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Behavior to support pre-rendering of invisible areas of a virtual scroller.
   * If applied to a scroller it will start a timer and increase the rendered area
   * of the scroller after a certain period of time. Subsequent scrolling will not
   * have to render this pre-computed area again.
   *
   */
  qx.Class.define("qx.ui.virtual.behavior.Prefetch", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param scroller {qx.ui.virtual.core.Scroller} The scroller to prefetch
     * @param settings {Map} This map contains minimum and maximum pixels to
     * prefetch near the view port.
     * <ul>
     *   <li>minLeft: minimum pixels to prefetch left to the view port</li>
     *   <li>maxLeft: maximum pixels to prefetch left to the view port</li>
     *   <li>minRight: minimum pixels to prefetch right to the view port</li>
     *   <li>maxRight: maximum pixels to prefetch right to the view port</li>
     *   <li>minAbove: minimum pixels to prefetch above the view port</li>
     *   <li>maxAbove: maximum pixels to prefetch above the view port</li>
     *   <li>minBelow: minimum pixels to prefetch below the view port</li>
     *   <li>maxBelow: maximum pixels to prefetch below the view port</li>
     * </ul>
     */
    construct: function construct(scroller, settings) {
      {
        this.assertObject(settings);
        this.assertPositiveInteger(settings.minLeft);
        this.assertPositiveInteger(settings.maxLeft);
        this.assertPositiveInteger(settings.minRight);
        this.assertPositiveInteger(settings.maxRight);
        this.assertPositiveInteger(settings.minAbove);
        this.assertPositiveInteger(settings.maxAbove);
        this.assertPositiveInteger(settings.minBelow);
        this.assertPositiveInteger(settings.maxBelow);
      }
      qx.core.Object.constructor.call(this);
      this.setPrefetchX(settings.minLeft, settings.maxLeft, settings.minRight, settings.maxRight);
      this.setPrefetchY(settings.minAbove, settings.maxAbove, settings.minBelow, settings.maxBelow);
      this.__timer__P_537_0 = new qx.event.Timer(this.getInterval());

      this.__timer__P_537_0.addListener("interval", this._onInterval, this);

      if (scroller) {
        this.setScroller(scroller);
      }
    },

    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties: {
      /** @type {qx.ui.virtual.core.Scroller} The scroller to prefetch */
      scroller: {
        check: "qx.ui.virtual.core.Scroller",
        nullable: true,
        init: null,
        apply: "_applyScroller"
      },

      /** @type {Integer} Polling interval */
      interval: {
        check: "Integer",
        init: 200,
        apply: "_applyInterval"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __prefetchX__P_537_1: null,
      __prefetchY__P_537_2: null,
      __timer__P_537_0: null,
      __onScrollXId__P_537_3: null,
      __onScrollYId__P_537_4: null,

      /**
       * Configure horizontal prefetching
       *
       * @param minLeft {Integer} minimum pixels to prefetch left to the view port
       * @param maxLeft {Integer} maximum pixels to prefetch left to the view port
       * @param minRight {Integer} minimum pixels to prefetch right to the view port
       * @param maxRight {Integer} maximum pixels to prefetch right to the view port
       */
      setPrefetchX: function setPrefetchX(minLeft, maxLeft, minRight, maxRight) {
        this.__prefetchX__P_537_1 = [minLeft, maxLeft, minRight, maxRight];
      },

      /**
       * Configure vertical prefetching
       *
       * @param minAbove {Integer} minimum pixels to prefetch above the view port
       * @param maxAbove {Integer} maximum pixels to prefetch above the view port
       * @param minBelow {Integer} minimum pixels to prefetch below the view port
       * @param maxBelow {Integer} maximum pixels to prefetch below the view port
       */
      setPrefetchY: function setPrefetchY(minAbove, maxAbove, minBelow, maxBelow) {
        this.__prefetchY__P_537_2 = [minAbove, maxAbove, minBelow, maxBelow];
      },

      /**
       * Update prefetching
       */
      _onInterval: function _onInterval() {
        var px = this.__prefetchX__P_537_1;

        if (px[1] && px[3]) {
          this.getScroller().getPane().prefetchX(px[0], px[1], px[2], px[3]);
          qx.ui.core.queue.Manager.flush();
        }

        var py = this.__prefetchY__P_537_2;

        if (py[1] && py[3]) {
          this.getScroller().getPane().prefetchY(py[0], py[1], py[2], py[3]);
          qx.ui.core.queue.Manager.flush();
        }
      },
      // property apply
      _applyScroller: function _applyScroller(value, old) {
        if (old) {
          if (this.__onScrollXId__P_537_3) {
            old.getChildControl("scrollbar-x").removeListenerById(this.__onScrollXId__P_537_3);
          }

          if (this.__onScrollYId__P_537_4) {
            old.getChildControl("scrollbar-y").removeListenerById(this.__onScrollYId__P_537_4);
          }
        }

        if (value) {
          if (!value.getContentElement().getDomElement()) {
            this.__timer__P_537_0.stop();

            value.addListenerOnce("appear", this.__timer__P_537_0.start, this.__timer__P_537_0);
          } else {
            this.__timer__P_537_0.restart();
          } //        if (value.hasChildControl("scrollbar-x"))
          //        {


          this.__onScrollXId__P_537_3 = value.getChildControl("scrollbar-x").addListener("scroll", this.__timer__P_537_0.restart, this.__timer__P_537_0); //        }
          //        if (value.hasChildControl("scrollbar-y"))
          //        {

          this.__onScrollYId__P_537_4 = value.getChildControl("scrollbar-y").addListener("scroll", this.__timer__P_537_0.restart, this.__timer__P_537_0); //        }
        } else {
          this.__timer__P_537_0.stop();
        }
      },
      // property apply
      _applyInterval: function _applyInterval(value, old) {
        this.__timer__P_537_0.setInterval(value);
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this.setScroller(null);
      this.__prefetchX__P_537_1 = this.__prefetchY__P_537_2 = null;

      this._disposeObjects("__timer__P_537_0");
    }
  });
  qx.ui.virtual.behavior.Prefetch.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * A HTML cell provider provides the {@link qx.ui.virtual.layer.HtmlCell}
   * with HTML fragments to render the cells.
   */
  qx.Interface.define("qx.ui.virtual.cell.ICell", {
    members: {
      /**
       * Returns all relevant properties of the cell:
       * <ul>
       * <li>classes (String): Space separated class names</li>
       * <li>style (String): CSS styles</li>
       * <li>attributes (String): Space separated attributes</li>
       * <li>content (String): HTML fragment of the innerHTML of the cell</li>
       * <li>insets (Array): insets (padding + border) of the cell as
       * two-dimensional array.</li>
       * </ul>
       *
       * @param data {var} Data needed for the cell to render.
       * @param states {Map} The states set on the cell (e.g. <i>selected</i>,
       * <i>focused</i>, <i>editable</i>).
       *
       * @return {Map} Cell properties (see above.)
       */
      getCellProperties: function getCellProperties(data, states) {}
    }
  });
  qx.ui.virtual.cell.ICell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.bom.Stylesheet": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.cell.ICell": {
        "require": true
      },
      "qx.ui.virtual.cell.CellStylesheet": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Abstract base class for HTML based cell renderer.
   *
   * HTML cell renderer are used to construct an HTML string, which is used to
   * render the cell.
   *
   * @require(qx.bom.Stylesheet)
   *
   */
  qx.Class.define("qx.ui.virtual.cell.Abstract", {
    type: "abstract",
    extend: qx.core.Object,
    implement: qx.ui.virtual.cell.ICell,
    construct: function construct() {
      qx.core.Object.constructor.call(this); // initialize stylesheet

      qx.ui.virtual.cell.CellStylesheet.getInstance();
    },
    members: {
      /**
       * Get the css classes for the cell
       *
       * @param value {var} The cell's data value
       * @param states {Object} A map containing the cell's state names as map keys.
       * @return {String} Space separated list of CSS classes
       */
      getCssClasses: function getCssClasses(value, states) {
        return "qx-cell";
      },

      /**
       * Get the element attributes for the cell
       *
       * @param value {var} The cell's data value
       * @param states {Object} A map containing the cell's state names as map keys.
       * @return {String} Compiled string of cell attributes. e.g.
       *   <code>'tabIndex="1" readonly="false"'</code>
       */
      getAttributes: function getAttributes(value, states) {
        return "";
      },

      /**
       * Get the CSS styles for the cell
       *
       * @param value {var} The cell's data value
       * @param states {Object} A map containing the cell's state names as map keys.
       * @return {String} Compiled string of CSS styles. e.g.
       *   <code>'color="red; padding: 10px'</code>
       */
      getStyles: function getStyles(value, states) {
        return "";
      },

      /**
       * Get the cell's insets. Insets are the sum of the cell's padding and
       * border width.
       *
       * @param value {var} The cell's data value
       * @param states {Object} A map containing the cell's state names as map keys.
       * @return {Integer[]} An array containing the sum of horizontal insets at index
       *   <code>0</code> and the sum of vertical insets at index <code>1</code>.
       */
      getInsets: function getInsets(value, states) {
        return [0, 0];
      },

      /**
       * Get cell'S HTML content
       *
       * @param value {var} The cell's data value
       * @param states {Object} A map containing the cell's state names as map keys.
       * @return {String} The cell's content as HTML fragment.
       */
      getContent: function getContent(value, states) {
        return value;
      },
      getCellProperties: function getCellProperties(value, states) {
        return {
          classes: this.getCssClasses(value, states),
          style: this.getStyles(value, states),
          attributes: this.getAttributes(value, states),
          content: this.getContent(value, states),
          insets: this.getInsets(value, states)
        };
      }
    }
  });
  qx.ui.virtual.cell.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.bom.element.Style": {
        "construct": true
      },
      "qx.bom.client.Css": {
        "construct": true
      },
      "qx.bom.element.BoxSizing": {
        "construct": true
      },
      "qx.bom.Stylesheet": {
        "construct": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxsizing": {
          "construct": true,
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Singleton wrapper for the stylesheet containing the CSS rules for HTML cells.
   *
   */
  qx.Class.define("qx.ui.virtual.cell.CellStylesheet", {
    extend: qx.core.Object,
    type: "singleton",
    construct: function construct() {
      qx.core.Object.constructor.call(this);
      var stylesheet = ".qx-cell {" + qx.bom.element.Style.compile({
        position: "absolute",
        overflow: "hidden",
        cursor: "default",
        textOverflow: "ellipsis",
        userSelect: "none"
      }) + "} ";

      if (qx.core.Environment.get("css.boxsizing")) {
        stylesheet += ".qx-cell {" + qx.bom.element.BoxSizing.compile("content-box") + "}";
      }

      this.__stylesheet__P_542_0 = qx.bom.Stylesheet.createElement(stylesheet);
      this.__classes__P_542_1 = {};
      this.__styles__P_542_2 = {};
    },
    members: {
      __stylesheet__P_542_0: null,
      __classes__P_542_1: null,
      __styles__P_542_2: null,

      /**
       * Get the DOM stylesheet element
       *
       * @return {StyleSheet} The DOM stylesheet element
       */
      getStylesheet: function getStylesheet() {
        return this.__stylesheet__P_542_0;
      },

      /**
       * Get the CSS class stored under the given key
       *
       * @param key {String} The key under which the class name is stored
       * @return {String|null} The CSS class stored under the given key or
       *   <code>null</code>.
       */
      getCssClass: function getCssClass(key) {
        return this.__classes__P_542_1[key] || null;
      },

      /**
       * Dynamically create a CSS rule for the given style string. The selector is
       * an unique class name, which is returned. The class is stored under the
       * given key name and can be queried using {@link #getCssClass}.
       *
       * @param key {String} The key under which the class name should be stored
       * @param styleString {String} A compiled string of CSS rules.
       * @return {String} The CSS class name.
       */
      computeClassForStyles: function computeClassForStyles(key, styleString) {
        var cssClass = this.__styles__P_542_2[styleString];

        if (!cssClass) {
          // generate stylesheet rule
          var cssClass = this.__getNextClassname__P_542_3();

          qx.bom.Stylesheet.addRule(this.__stylesheet__P_542_0, "." + cssClass, styleString);
          this.__styles__P_542_2[styleString] = cssClass;
        }

        this.__classes__P_542_1[key] = cssClass;
        return cssClass;
      },

      /**
       * Get the next unique CSS class name
       *
       * @return {String} The next unique CSS class name
       */
      __getNextClassname__P_542_3: function __getNextClassname__P_542_3() {
        return "qx-cell-" + this.toHashCode() + "-" + this.__classCounter__P_542_4++;
      },
      __classCounter__P_542_4: 0
    },
    destruct: function destruct() {
      this.__stylesheet__P_542_0 = this.__classes__P_542_1 = this.__styles__P_542_2 = null;
    }
  });
  qx.ui.virtual.cell.CellStylesheet.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.cell.CellStylesheet": {
        "construct": true
      },
      "qx.util.PropertyUtil": {},
      "qx.lang.Object": {},
      "qx.theme.manager.Color": {},
      "qx.theme.manager.Font": {},
      "qx.bom.element.Style": {},
      "qx.bom.Style": {},
      "qx.theme.manager.Appearance": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Themeable Cell renderer.
   *
   * This cell renderer can be styled by an appearance theme.
   */
  qx.Class.define("qx.ui.virtual.cell.Cell", {
    extend: qx.ui.virtual.cell.Abstract,
    construct: function construct() {
      qx.ui.virtual.cell.Abstract.constructor.call(this);
      this.__stylesheet__P_541_0 = qx.ui.virtual.cell.CellStylesheet.getInstance();
      this.__userStyles__P_541_1 = {};
      this.__themeStyles__P_541_2 = {};
      this.__userPaddings__P_541_3 = {};
      this.__themePaddings__P_541_4 = {};
      this.__states__P_541_5 = {};
      this.__themeValues__P_541_6 = {};
      this.initAppearance();

      this.__initializeThemableProperties__P_541_7();
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * The appearance ID. This ID is used to identify the appearance theme
       * entry to use for this cell.
       */
      appearance: {
        check: "String",
        init: "cell",
        apply: "_applyAppearance"
      },

      /** The cell's background color */
      backgroundColor: {
        nullable: true,
        check: "Color",
        apply: "_applyBackgroundColor",
        themeable: true
      },

      /** The cell's text color */
      textColor: {
        nullable: true,
        check: "Color",
        apply: "_applyTextColor",
        themeable: true
      },

      /** The text alignment of the cell's content */
      textAlign: {
        check: ["left", "center", "right", "justify"],
        nullable: true,
        themeable: true,
        apply: "_applyTextAlign"
      },

      /**
       * The cell's font. The value is either a font name defined in the font
       * theme or an instance of {@link qx.bom.Font}.
       */
      font: {
        nullable: true,
        apply: "_applyFont",
        check: "Font",
        themeable: true
      },

      /*
      ---------------------------------------------------------------------------
        PADDING
      ---------------------------------------------------------------------------
      */

      /** Padding of the widget (top) */
      paddingTop: {
        check: "Integer",
        init: 0,
        apply: "_applyPadding",
        themeable: true
      },

      /** Padding of the widget (right) */
      paddingRight: {
        check: "Integer",
        nullable: true,
        apply: "_applyPadding",
        themeable: true
      },

      /** Padding of the widget (bottom) */
      paddingBottom: {
        check: "Integer",
        nullable: true,
        apply: "_applyPadding",
        themeable: true
      },

      /** Padding of the widget (left) */
      paddingLeft: {
        check: "Integer",
        nullable: true,
        apply: "_applyPadding",
        themeable: true
      },

      /**
       * The 'padding' property is a shorthand property for setting 'paddingTop',
       * 'paddingRight', 'paddingBottom' and 'paddingLeft' at the same time.
       *
       * If four values are specified they apply to top, right, bottom and left
       * respectively. If there is only one value, it applies to all sides, if
       * there are two or three, the missing values are taken from the opposite
       * side.
       */
      padding: {
        group: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
        mode: "shorthand",
        themeable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {Array} List of all non CSS themable properties */
      __themableProperties__P_541_8: null,

      /** @type {String} Unique key over the current set of states */
      __statesKey__P_541_9: null,
      __states__P_541_5: null,
      __themeValues__P_541_6: null,
      __themeStyles__P_541_2: null,
      __userStyles__P_541_1: null,
      __userPaddings__P_541_3: null,
      __themePaddings__P_541_4: null,
      __isThemed__P_541_10: false,
      __stylesheet__P_541_0: null,

      /**
       * Collect all themable properties, which are not CSS properties
       */
      __initializeThemableProperties__P_541_7: function __initializeThemableProperties__P_541_7() {
        var PropertyUtil = qx.util.PropertyUtil;
        var cssProperties = qx.lang.Object.fromArray(this._getCssProperties());
        this.__themableProperties__P_541_8 = [];
        var clazz = this.constructor;

        while (clazz) {
          var properties = PropertyUtil.getProperties(clazz);

          for (var prop in properties) {
            if (!cssProperties[prop]) {
              this.__themableProperties__P_541_8.push(prop);
            }
          }

          clazz = clazz.superclass;
        }
      },

      /**
       * Get a list of all properties, which should be applied as CSS styles.
       *
       * @return {Array} List of property names
       */
      _getCssProperties: function _getCssProperties() {
        return ["backgroundColor", "textColor", "font", "textAlign", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"];
      },
      // property apply
      _applyAppearance: function _applyAppearance(value, old) {
        if (old) {
          this.__themeStyles__P_541_2 = {};
        }
      },

      /**
       * Compute the value of the given property
       *
       * @param propertyName {String} Name of the property
       * @return {var} The Property value
       */
      _getValue: function _getValue(propertyName) {
        if (this.__isThemed__P_541_10) {
          return qx.util.PropertyUtil.getThemeValue(this, propertyName);
        } else {
          return qx.util.PropertyUtil.getUserValue(this, propertyName);
        }
      },

      /**
       * Store a properties computed style string either in the user or in the
       * theme values. User values will be applied as inline styles, while theme
       * values are stored in a stylesheet.
       *
       * @param propertyName {String} The property name
       * @param styles {String} String with computed CSS styles
       */
      _storeStyle: function _storeStyle(propertyName, styles) {
        var store;

        if (this.__isThemed__P_541_10) {
          store = this.__themeStyles__P_541_2;
        } else {
          store = this.__userStyles__P_541_1;
        }

        if (styles === null) {
          delete store[propertyName];
        } else {
          store[propertyName] = styles;
        }
      },
      // property apply
      _applyBackgroundColor: function _applyBackgroundColor(value, old, name) {
        var value = this._getValue(name);

        if (!value) {
          this._storeStyle(name, null);
        } else {
          this._storeStyle(name, "background-color:" + qx.theme.manager.Color.getInstance().resolve(value));
        }
      },
      // property apply
      _applyTextColor: function _applyTextColor(value, old, name) {
        var value = this._getValue(name);

        if (!value) {
          this._storeStyle(name, null);
        } else {
          this._storeStyle(name, "color:" + qx.theme.manager.Color.getInstance().resolve(value));
        }
      },
      // property apply
      _applyTextAlign: function _applyTextAlign(value, old, name) {
        var value = this._getValue(name);

        if (!value) {
          this._storeStyle(name, null);
        } else {
          this._storeStyle(name, "text-align:" + value);
        }
      },
      // property apply
      _applyFont: function _applyFont(value, old, name) {
        var value = this._getValue(name);

        if (!value) {
          this._storeStyle(name, null);
        } else {
          var font = qx.theme.manager.Font.getInstance().resolve(value);

          this._storeStyle(name, qx.bom.element.Style.compile(font.getStyles()));
        }
      },
      // property apply
      _applyPadding: function _applyPadding(value, old, name) {
        var value = this._getValue(name);

        if (this.__isThemed__P_541_10) {
          var paddingStore = this.__themePaddings__P_541_4;
        } else {
          paddingStore = this.__userPaddings__P_541_3;
        }

        if (value === null) {
          delete paddingStore[name];
        } else {
          paddingStore[name] = value;
        }

        if (value === null) {
          this._storeStyle(name, null);
        } else {
          var cssKey = qx.bom.Style.getCssName(name);

          this._storeStyle(name, cssKey + ":" + value + "px");
        }
      },

      /*
      ---------------------------------------------------------------------------
        IMPLEMENT CELL API
      ---------------------------------------------------------------------------
      */
      // overridden
      getCellProperties: function getCellProperties(value, states) {
        this.__setStates__P_541_11(states);

        return {
          classes: this.getCssClasses(value, states),
          style: this.getStyles(value, states),
          attributes: this.getAttributes(value, states),
          content: this.getContent(value, states),
          insets: this.getInsets(value, states)
        };
      },
      // overridden
      getAttributes: function getAttributes(value, states) {
        return "";
      },
      // overridden
      getContent: function getContent(value, states) {
        return value;
      },
      // overridden
      getCssClasses: function getCssClasses(value, states) {
        var cssClass = this.__stylesheet__P_541_0.getCssClass(this.__statesKey__P_541_9) || "";
        return "qx-cell " + cssClass;
      },

      /**
       * Set the cell states and set the correct CSS class for the given state
       * combination
       *
       * @param states {Object} A map containing the cell's state names as map keys.
       */
      __setStates__P_541_11: function __setStates__P_541_11(states) {
        // Avoid errors if no states are set
        if (!states) {
          states = {};
        }

        var appearance = this.getAppearance();
        var statesKey = appearance + "-" + Object.keys(states).sort().join(" ");

        if (this.__statesKey__P_541_9 == statesKey) {
          return;
        }

        this.__statesKey__P_541_9 = statesKey;
        var themeStyles = this.__states__P_541_5[this.__statesKey__P_541_9];

        if (!themeStyles) {
          this.__clearThemedPropertyValues__P_541_12();

          this.__updateThemeableProperties__P_541_13(states);

          this.__computeCssClassForStates__P_541_14(states);

          this.__cacheThemedValues__P_541_15();

          this.__states__P_541_5[this.__statesKey__P_541_9] = 1;
        }

        this.__applyThemeValues__P_541_16();
      },

      /**
       * Remove the themed value from all CSS properties
       */
      __clearThemedPropertyValues__P_541_12: function __clearThemedPropertyValues__P_541_12() {
        var PropertyUtil = qx.util.PropertyUtil;

        var themableProperties = this._getCssProperties();

        for (var i = 0; i < themableProperties.length; i++) {
          PropertyUtil.deleteThemeValue(this, themableProperties[i]);
        }
      },

      /**
       * Set the new themed value for all CSS properties given the set of states
       *
       * @param states {Object} A map containing the cell's state names as map keys.
       */
      __updateThemeableProperties__P_541_13: function __updateThemeableProperties__P_541_13(states) {
        this.__themeStyles__P_541_2 = {};
        this.__isThemed__P_541_10 = true;
        var appearance = this.getAppearance();
        var PropertyUtil = qx.util.PropertyUtil;
        var styles = qx.theme.manager.Appearance.getInstance().styleFrom(appearance, states);

        for (var prop in styles) {
          if (styles[prop] !== undefined) {
            PropertyUtil.setThemed(this, prop, styles[prop]);
          }
        }

        this.__isThemed__P_541_10 = false;
      },

      /**
       * Compute a CSS class for the current values of all CSS properties
       */
      __computeCssClassForStates__P_541_14: function __computeCssClassForStates__P_541_14() {
        var styleString = Object.values(this.__themeStyles__P_541_2).join(";");

        this.__stylesheet__P_541_0.computeClassForStyles(this.__statesKey__P_541_9, styleString);
      },

      /**
       * Cache the themed values for the current state combination
       */
      __cacheThemedValues__P_541_15: function __cacheThemedValues__P_541_15() {
        var properties = this.__themableProperties__P_541_8;
        var PropertyUtil = qx.util.PropertyUtil;
        var themeValues = {};

        for (var i = 0; i < properties.length; i++) {
          var key = properties[i];
          var value = PropertyUtil.getThemeValue(this, key);

          if (value !== undefined) {
            themeValues[key] = value;
          }
        }

        this.__themeValues__P_541_6[this.__statesKey__P_541_9] = themeValues;
      },

      /**
       * Apply the themed values to the properties
       */
      __applyThemeValues__P_541_16: function __applyThemeValues__P_541_16() {
        var PropertyUtil = qx.util.PropertyUtil;
        var themeValues = this.__themeValues__P_541_6[this.__statesKey__P_541_9] || {};

        for (var key in themeValues) {
          PropertyUtil.setThemed(this, key, themeValues[key]);
        }
      },
      // overridden
      getStyles: function getStyles(value, states) {
        return Object.values(this.__userStyles__P_541_1).join(";");
      },
      // overridden
      getInsets: function getInsets(value, states) {
        var user = this.__userPaddings__P_541_3;
        var theme = this.__themePaddings__P_541_4;
        var top = (user.paddingTop !== undefined ? user.paddingTop : theme.paddingTop) || 0;
        var right = (user.paddingRight !== undefined ? user.paddingRight : theme.paddingRight) || 0;
        var bottom = (user.paddingBottom !== undefined ? user.paddingBottom : theme.paddingBottom) || 0;
        var left = (user.paddingLeft !== undefined ? user.paddingLeft : theme.paddingLeft) || 0;
        return [left + right, top + bottom];
      }
    },
    destruct: function destruct() {
      this.__stylesheet__P_541_0 = this.__userStyles__P_541_1 = this.__themeStyles__P_541_2 = this.__userPaddings__P_541_3 = this.__themePaddings__P_541_4 = this.__states__P_541_5 = this.__themeValues__P_541_6 = this.__themableProperties__P_541_8 = null;
    }
  });
  qx.ui.virtual.cell.Cell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      },
      "qx.util.ResourceManager": {},
      "qx.io.ImageLoader": {},
      "qx.bom.element.Decoration": {},
      "qx.bom.element.Style": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Abstract base class for image cell renderer.
   */
  qx.Class.define("qx.ui.virtual.cell.AbstractImage", {
    extend: qx.ui.virtual.cell.Cell,
    type: "abstract",

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.virtual.cell.Cell.constructor.call(this);
      this._aliasManager = qx.util.AliasManager.getInstance();
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __defaultWidth__P_538_0: 16,
      __defaultHeight__P_538_1: 16,
      _aliasManager: null,

      /**
       * Compute the size of the given image
       *
       * @param source {String} the image URL
       * @return {Map} A map containing the image's <code>width</code> and
       *    <code>height</code>
       */
      __getImageSize__P_538_2: function __getImageSize__P_538_2(source) {
        var ResourceManager = qx.util.ResourceManager.getInstance();
        var ImageLoader = qx.io.ImageLoader;
        var width, height; // Detect if the image registry knows this image

        if (ResourceManager.has(source)) {
          width = ResourceManager.getImageWidth(source), height = ResourceManager.getImageHeight(source);
        } else if (ImageLoader.isLoaded(source)) {
          width = ImageLoader.getWidth(source);
          height = ImageLoader.getHeight(source);
        } else {
          width = this.__defaultWidth__P_538_0;
          height = this.__defaultHeight__P_538_1;
        }

        return {
          width: width,
          height: height
        };
      },

      /**
       * Compute image meta data
       *
       * @param imageData {Object|String} Either a string containing the image URL
       *   or a map, which describes the image. Map keys:
       *   <ul>
       *     <li>url (required)</li>
       *     <li>width</li>
       *     <li>height</li>
       *     <li>tooltip</li>
       *   </ul>
       * @return {Object} A map describing the image. Map keys:
       *   <ul>
       *     <li>url</li>
       *     <li>width</li>
       *     <li>height</li>
       *     <li>tooltip (optional)</li>
       *   </ul>
       */
      __createImage__P_538_3: function __createImage__P_538_3(imageData) {
        if (typeof imageData == "string") {
          imageData = {
            url: imageData
          };
        }

        var url = this._aliasManager.resolve(imageData.url || null);

        var sizes;

        if (imageData.width && imageData.height) {
          sizes = {
            width: imageData.width,
            height: imageData.height
          };
        } else {
          sizes = this.__getImageSize__P_538_2(url);
        }

        return {
          width: sizes.width,
          height: sizes.height,
          url: url,
          tooltip: imageData.tooltip
        };
      },

      /**
       * Identifies the Image to show. This is a template method, which must be
       * implements by sub classes.
       *
       * @abstract
       * @param value {var} The cell's data value
       * @return {Map} A map having the following attributes:
       *           <ul>
       *           <li>"url": (type string) must be the URL of the image to show.</li>
       *           <li>"width": (type int) the width of the image in pixels.</li>
       *           <li>"height": (type int) the height of the image in pixels.</li>
       *           <li>"tooltip": (type string) must be the image tooltip text.</li>
       *           </ul>
       */
      _identifyImage: function _identifyImage(value) {
        throw new Error("_identifyImage is abstract");
      },
      // overridden
      getContent: function getContent(value, states) {
        if (value === null) {
          return "";
        }

        var content = "";

        var imageData = this.__createImage__P_538_3(this._identifyImage(value));

        var tooltip = imageData.tooltip ? 'title="' + imageData.tooltip + '"' : "";
        var styles = {
          width: imageData.width + "px",
          height: imageData.height + "px",
          display: "inline-block",
          verticalAlign: "top",
          position: "static"
        };
        var tag = qx.bom.element.Decoration.getTagName("no-repeat", imageData.url);
        var ret = qx.bom.element.Decoration.getAttributes(imageData.url, "no-repeat", styles);
        var css = qx.bom.element.Style.compile(ret.style);

        if (tag === "img") {
          content = '<img src="' + ret.src + '" style="' + css + '" ';
          content += tooltip + '/>';
        } else {
          content = '<div style="' + css + '" ';
          content += tooltip + '></div>';
        }

        return content;
      }
    }
  });
  qx.ui.virtual.cell.AbstractImage.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.AbstractImage": {
        "construct": true,
        "require": true
      },
      "qx.util.AliasManager": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.ui.virtual.cell.Boolean", {
    extend: qx.ui.virtual.cell.AbstractImage,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function construct() {
      qx.ui.virtual.cell.AbstractImage.constructor.call(this);
      this.__aliasManager__P_540_0 = qx.util.AliasManager.getInstance();
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "cell-boolean"
      },

      /**
      * The icon used to indicate the true state
      */
      iconTrue: {
        check: "String",
        themeable: true,
        apply: "_applyIconTrue"
      },

      /**
      * The icon used to indicate the false state
      */
      iconFalse: {
        check: "String",
        themeable: true,
        apply: "_applyIconFalse"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __imageTrue__P_540_1: null,
      __imageFalse__P_540_2: null,
      __aliasManager__P_540_0: null,
      // property apply
      _applyIconTrue: function _applyIconTrue(value) {
        this.__imageTrue__P_540_1 = this.__aliasManager__P_540_0.resolve(value);
      },
      // property apply
      _applyIconFalse: function _applyIconFalse(value) {
        this.__imageFalse__P_540_2 = this.__aliasManager__P_540_0.resolve(value);
      },
      // overridden
      _identifyImage: function _identifyImage(value) {
        return value == true ? this.__imageTrue__P_540_1 : this.__imageFalse__P_540_2;
      }
    }
  });
  qx.ui.virtual.cell.Boolean.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {
        "construct": true,
        "require": true
      },
      "qx.util.format.DateFormat": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Date cell renderer.
   *
   * Renders a date according to the configured date formatter.
   *
   */
  qx.Class.define("qx.ui.virtual.cell.Date", {
    extend: qx.ui.virtual.cell.Cell,

    /**
     * @param dateFormat {qx.util.format.DateFormat|null} optional date formatter
     *   to use
     */
    construct: function construct(dateFormat) {
      qx.ui.virtual.cell.Cell.constructor.call(this);

      if (dateFormat) {
        this.setDateFormat(dateFormat);
      } else {
        this.initDateFormat(qx.util.format.DateFormat.getDateTimeInstance());
      }
    },
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "cell-date"
      },

      /** The date format used to render the cell */
      dateFormat: {
        check: "qx.util.format.DateFormat",
        deferredInit: true
      }
    },
    members: {
      // overridden
      getContent: function getContent(value, states) {
        return value ? this.getDateFormat().format(value) : "";
      }
    }
  });
  qx.ui.virtual.cell.Date.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.ui.virtual.cell.Html", {
    extend: qx.ui.virtual.cell.Cell,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "cell-html"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        IMPLEMENT CELL API
      ---------------------------------------------------------------------------
      */
      getContent: function getContent(value, states) {
        return value;
      }
    }
  });
  qx.ui.virtual.cell.Html.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */

  /**
   * Objects, which are used as delegates for {@link qx.ui.virtual.cell.WidgetCell} may
   * implement any of the methods described in this interface. The delegate does
   * not need implement all of the methods of this interface. If a method is not
   * implemented the {@link qx.ui.virtual.cell.WidgetCell} provides a default implementation.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * really implemented.
   */
  qx.Interface.define("qx.ui.virtual.cell.IWidgetCellDelegate", {
    members: {
      /**
       * Creates a <code>Widget</code> which will be used for rendering.
       *
       * @return {qx.ui.core.LayoutItem} A new created <code>Widget</code>.
       */
      createWidget: function createWidget() {}
    }
  });
  qx.ui.virtual.cell.IWidgetCellDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.AbstractImage": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.ui.virtual.cell.Image", {
    extend: qx.ui.virtual.cell.AbstractImage,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "cell-image"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _identifyImage: function _identifyImage(value) {
        return value;
      }
    }
  });
  qx.ui.virtual.cell.Image.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {
        "construct": true,
        "require": true
      },
      "qx.util.format.NumberFormat": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Number cell renderer.
   *
   * Renders the call using the configured number formatter.
   */
  qx.Class.define("qx.ui.virtual.cell.Number", {
    extend: qx.ui.virtual.cell.Cell,

    /**
     * @param numberFormat {qx.util.format.NumberFormat|null} Optional number
     *   format to use.
     */
    construct: function construct(numberFormat) {
      qx.ui.virtual.cell.Cell.constructor.call(this);

      if (numberFormat) {
        this.setNumberFormat(numberFormat);
      }
    },
    properties: {
      /** The number format used to render the cell */
      numberFormat: {
        check: "qx.util.format.NumberFormat",
        // it is on intension that only one number format is used for
        // all instances
        init: new qx.util.format.NumberFormat()
      },
      // overridden
      appearance: {
        refine: true,
        init: "cell-number"
      }
    },
    members: {
      // overridden
      getContent: function getContent(value, states) {
        return value !== null ? this.getNumberFormat().format(value) : "";
      }
    }
  });
  qx.ui.virtual.cell.Number.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.cell.Cell": {
        "construct": true,
        "require": true
      },
      "qx.bom.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  qx.Class.define("qx.ui.virtual.cell.String", {
    extend: qx.ui.virtual.cell.Cell,
    construct: function construct() {
      qx.ui.virtual.cell.Cell.constructor.call(this);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      appearance: {
        refine: true,
        init: "cell-string"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        IMPLEMENT CELL API
      ---------------------------------------------------------------------------
      */
      getContent: function getContent(value, states) {
        return value ? qx.bom.String.escape(value) : "";
      }
    }
  });
  qx.ui.virtual.cell.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A HTML cell provider provides the {@link qx.ui.virtual.layer.HtmlCell}
   * with HTML fragments to render the cells.
   */
  qx.Interface.define("qx.ui.virtual.core.IHtmlCellProvider", {
    members: {
      /**
       * Returns all relevant properties of the cell:
       * <ul>
       * <li>classes (String): Space separated class names</li>
       * <li>style (String): CSS styles</li>
       * <li>attributes (String): Space separated attributes</li>
       * <li>content (String): HTML fragment of the innerHTML of the cell</li>
       * <li>insets (Array): insets (padding + border) of the cell as
       * two-dimensional array.</li>
       * </ul>
       *
       * @param row {Integer} The cell's row index.
       * @param column {Integer} The cell's column index.
       *
       * @return {Map} Cell properties (see above.)
       */
      getCellProperties: function getCellProperties(row, column) {}
    }
  });
  qx.ui.virtual.core.IHtmlCellProvider.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.Axis": {
        "construct": true
      },
      "qx.lang.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The CellSpanManager manages cells, which span several rows or columns.
   *
   * It provides functionality to compute, which spanning cells are visible
   * in a given view port and how they have to be placed.
   */
  qx.Class.define("qx.ui.virtual.layer.CellSpanManager", {
    extend: qx.core.Object,

    /**
     * @param rowConfig {qx.ui.virtual.core.Axis} The row configuration of the pane
     *    in which the cells will be rendered
     * @param columnConfig {qx.ui.virtual.core.Axis} The column configuration of the pane
     *    in which the cells will be rendered
     */
    construct: function construct(rowConfig, columnConfig) {
      qx.core.Object.constructor.call(this);
      {
        this.assertInstance(rowConfig, qx.ui.virtual.core.Axis);
        this.assertInstance(columnConfig, qx.ui.virtual.core.Axis);
      }
      this._cells = {};

      this._invalidateSortCache();

      this._invalidatePositionCache();

      rowConfig.addListener("change", this._onRowConfigChange, this);
      columnConfig.addListener("change", this._onColumnConfigChange, this);
      this._rowConfig = rowConfig;
      this._columnConfig = columnConfig;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Add a spanning cell to the manager.
       *
       * @param id {String} Unique id for the cell definition. This id is required
       *    for removing the cell from the manager
       * @param row {PositiveInteger} The cell's row
       * @param column {PositiveInteger} The cell's column
       * @param rowSpan {PositiveInteger} The number of rows the cells spans
       * @param columnSpan {PositiveInteger} The number of columns the cells spans
       */
      addCell: function addCell(id, row, column, rowSpan, columnSpan) {
        this._cells[id] = {
          firstRow: row,
          lastRow: row + rowSpan - 1,
          firstColumn: column,
          lastColumn: column + columnSpan - 1,
          id: id
        };

        this._invalidateSortCache();
      },

      /**
       * Remove a cell from the manager
       *
       * @param id {String} The id of the cell to remove
       */
      removeCell: function removeCell(id) {
        delete this._cells[id];

        this._invalidateSortCache();
      },

      /**
       * Invalidate the sort cache
       */
      _invalidateSortCache: function _invalidateSortCache() {
        this._sorted = {};
      },

      /**
       * Get the cell array sorted by the given key (ascending)
       *
       * @param key {String} The sort key. One of <code>firstRow</code>,
       *     <code>lastRow</code>, <code>firstColumn</code> or <code>lastColumn</code>
       * @return {Map[]} sorted array of cell descriptions
       */
      _getSortedCells: function _getSortedCells(key) {
        if (this._sorted[key]) {
          return this._sorted[key];
        }

        var sorted = this._sorted[key] = Object.values(this._cells);
        sorted.sort(function (a, b) {
          return a[key] < b[key] ? -1 : 1;
        });
        return sorted;
      },

      /**
       * Finds all cells with a sort key within the given range.
       *
       * Complexity: O(log n)
       *
       * @param key {String} The key to search for
       * @param min {Integer} minimum value
       * @param max {Integer} maximum value (inclusive)
       * @return {Map} Map, which will contain the search results
       */
      _findCellsInRange: function _findCellsInRange(key, min, max) {
        var cells = this._getSortedCells(key);

        if (cells.length == 0) {
          return {};
        }

        var start = 0;
        var end = cells.length - 1; // find first cell, which is >= "min"

        while (true) {
          var pivot = start + (end - start >> 1);
          var cell = cells[pivot];

          if (cell[key] >= min && (pivot == 0 || cells[pivot - 1][key] < min)) {
            // the start cell was found
            break;
          }

          if (cell[key] >= min) {
            end = pivot - 1;
          } else {
            start = pivot + 1;
          }

          if (start > end) {
            // nothing found
            return {};
          }
        }

        var result = {};
        var cell = cells[pivot];

        while (cell && cell[key] >= min && cell[key] <= max) {
          result[cell.id] = cell;
          cell = cells[pivot++];
        }

        return result;
      },

      /**
       * Find all cells, which are visible in the given grid window.
       *
       * @param firstRow {PositiveInteger} first visible row
       * @param firstColumn {PositiveInteger} first visible column
       * @param rowCount {PositiveInteger} number of rows in the window
       * @param columnCount {PositiveInteger} number of columns in the window
       * @return {Map[]} The array of found cell descriptions. A cell description
       *    contains the keys <code>firstRow</code>, <code>lastRow</code>,
       *    <code>firstColumn</code> or <code>lastColumn</code>
       */
      findCellsInWindow: function findCellsInWindow(firstRow, firstColumn, rowCount, columnCount) {
        var verticalInWindow = {};

        if (rowCount > 0) {
          var lastRow = firstRow + rowCount - 1;
          qx.lang.Object.mergeWith(verticalInWindow, this._findCellsInRange("firstRow", firstRow, lastRow));
          qx.lang.Object.mergeWith(verticalInWindow, this._findCellsInRange("lastRow", firstRow, lastRow));
        }

        var horizontalInWindow = {};

        if (columnCount > 0) {
          var lastColumn = firstColumn + columnCount - 1;
          qx.lang.Object.mergeWith(horizontalInWindow, this._findCellsInRange("firstColumn", firstColumn, lastColumn));
          qx.lang.Object.mergeWith(horizontalInWindow, this._findCellsInRange("lastColumn", firstColumn, lastColumn));
        }

        return this.__intersectionAsArray__P_548_0(horizontalInWindow, verticalInWindow);
      },

      /**
       * Return the intersection of two maps as an array. The objects intersect if
       * they have the same keys.
       *
       * @param setA {Object} The first map
       * @param setB {Object} The second map
       * @return {String[]} An array keys found in both maps
       */
      __intersectionAsArray__P_548_0: function __intersectionAsArray__P_548_0(setA, setB) {
        var intersection = [];

        for (var key in setA) {
          if (setB[key]) {
            intersection.push(setB[key]);
          }
        }

        return intersection;
      },

      /**
       * Event handler for row configuration changes
       *
       * @param e {qx.event.type.Event} the event object
       */
      _onRowConfigChange: function _onRowConfigChange(e) {
        this._rowPos = [];
      },

      /**
       * Event handler for column configuration changes
       *
       * @param e {qx.event.type.Event} the event object
       */
      _onColumnConfigChange: function _onColumnConfigChange(e) {
        this._columnPos = [];
      },

      /**
       * Invalidates the row/column position cache
       */
      _invalidatePositionCache: function _invalidatePositionCache() {
        this._rowPos = [];
        this._columnPos = [];
      },

      /**
       * Get the pixel start position of the given row
       *
       * @param row {Integer} The row index
       * @return {Integer} The pixel start position of the given row
       */
      _getRowPosition: function _getRowPosition(row) {
        var pos = this._rowPos[row];

        if (pos !== undefined) {
          return pos;
        }

        pos = this._rowPos[row] = this._rowConfig.getItemPosition(row);
        return pos;
      },

      /**
       * Get the pixel start position of the given column
       *
       * @param column {Integer} The column index
       * @return {Integer} The pixel start position of the given column
       */
      _getColumnPosition: function _getColumnPosition(column) {
        var pos = this._columnPos[column];

        if (pos !== undefined) {
          return pos;
        }

        pos = this._columnPos[column] = this._columnConfig.getItemPosition(column);
        return pos;
      },

      /**
       * Get the bounds of a single cell
       *
       * @param cell {Map} the cell description as returned by
       *    {@link #findCellsInWindow} to get the bounds for
       * @param firstVisibleRow {Map} The pane's first visible row
       * @param firstVisibleColumn {Map} The pane's first visible column
       * @return {Map} Boundaries map with the keys <code>left</code>,
       * <code>top</code>, <code>width</code> and <code>height</code>
       */
      _getSingleCellBounds: function _getSingleCellBounds(cell, firstVisibleRow, firstVisibleColumn) {
        var bounds = {
          left: 0,
          top: 0,
          width: 0,
          height: 0
        };
        bounds.height = this._getRowPosition(cell.lastRow) + this._rowConfig.getItemSize(cell.lastRow) - this._getRowPosition(cell.firstRow);
        bounds.top = this._getRowPosition(cell.firstRow) - this._getRowPosition(firstVisibleRow);
        bounds.width = this._getColumnPosition(cell.lastColumn) + this._columnConfig.getItemSize(cell.lastColumn) - this._getColumnPosition(cell.firstColumn);
        bounds.left = this._getColumnPosition(cell.firstColumn) - this._getColumnPosition(firstVisibleColumn);
        return bounds;
      },

      /**
       * Get the bounds of a list of cells as returned by {@link #findCellsInWindow}
       *
       * @param cells {Map[]} Array of cell descriptions
       * @param firstVisibleRow {Map} The pane's first visible row
       * @param firstVisibleColumn {Map} The pane's first visible column
       * @return {Map[]} Array, which contains a bounds map for each cell.
       */
      getCellBounds: function getCellBounds(cells, firstVisibleRow, firstVisibleColumn) {
        var bounds = [];

        for (var i = 0, l = cells.length; i < l; i++) {
          bounds.push(this._getSingleCellBounds(cells[i], firstVisibleRow, firstVisibleColumn));
        }

        return bounds;
      },

      /**
       * Compute a bitmap, which marks for each visible cell, whether the cell
       * is covered by a spanning cell.
       *
       * @param cells {Map[]} Array of cell descriptions as returned by
       *     {@link #findCellsInWindow}.
       * @param firstRow {PositiveInteger} first visible row
       * @param firstColumn {PositiveInteger} first visible column
       * @param rowCount {PositiveInteger} number of rows in the window
       * @param columnCount {PositiveInteger} number of columns in the window
       * @return {Map[][]} Two dimensional array, which contains a <code>1</code>
       *    for each visible cell, which is covered by a spanned cell.
       */
      computeCellSpanMap: function computeCellSpanMap(cells, firstRow, firstColumn, rowCount, columnCount) {
        var map = [];

        if (rowCount <= 0) {
          return map;
        }

        var lastRow = firstRow + rowCount - 1;

        for (var i = firstRow; i <= lastRow; i++) {
          map[i] = [];
        }

        if (columnCount <= 0) {
          return map;
        }

        var lastColumn = firstColumn + columnCount - 1;

        for (var i = 0, l = cells.length; i < l; i++) {
          var cell = cells[i];
          var rowStartIndex = Math.max(firstRow, cell.firstRow);
          var rowEndIndex = Math.min(lastRow, cell.lastRow);
          var row;

          for (var rowIndex = rowStartIndex; rowIndex <= rowEndIndex; rowIndex++) {
            row = map[rowIndex];
            var columnStartIndex = Math.max(firstColumn, cell.firstColumn);
            var columnEndIndex = Math.min(lastColumn, cell.lastColumn);

            for (var columnIndex = columnStartIndex; columnIndex <= columnEndIndex; columnIndex++) {
              row[columnIndex] = 1;
            }
          }
        }

        return map;
      }
    },
    destruct: function destruct() {
      this._rowConfig.removeListener("change", this._onRowConfigChange, this);

      this._columnConfig.removeListener("change", this._onColumnConfigChange, this);

      this._cells = this._sorted = this._rowPos = this._columnPos = this._rowConfig = this._columnConfig = null;
    }
  });
  qx.ui.virtual.layer.CellSpanManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.AbstractBackground": {
        "require": true
      },
      "qx.lang.Array": {},
      "qx.bom.element.Style": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The Row layer renders row background colors.
   */
  qx.Class.define("qx.ui.virtual.layer.Column", {
    extend: qx.ui.virtual.layer.AbstractBackground,

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      appearance: {
        refine: true,
        init: "column-layer"
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];
        var height = qx.lang.Array.sum(rowSizes);
        var left = 0;
        var column = firstColumn;
        var childIndex = 0;

        for (var x = 0; x < columnSizes.length; x++) {
          var color = this.getColor(column);
          var backgroundColor = color ? "background-color:" + color + ";" : "";
          var decorator = this.getBackground(column);
          var styles = decorator ? qx.bom.element.Style.compile(decorator.getStyles()) : "";
          html.push("<div style='", "position: absolute;", "top: 0;", "left:", left, "px;", "width:", columnSizes[x], "px;", "height:", height, "px;", backgroundColor, styles, "'>", "</div>");
          childIndex++;
          left += columnSizes[x];
          column += 1;
        }

        var el = this.getContentElement().getDomElement(); // hide element before changing the child nodes to avoid
        // premature reflow calculations

        el.style.display = "none";
        el.innerHTML = html.join("");
        el.style.display = "block";
        this._height = height;
      },
      updateLayerWindow: function updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        if (firstColumn !== this.getFirstColumn() || columnSizes.length !== this.getColumnSizes().length || this._height < qx.lang.Array.sum(rowSizes)) {
          this._fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
        }
      },
      // overridden
      setColor: function setColor(index, color) {
        qx.ui.virtual.layer.Column.prototype.setColor.base.call(this, index, color);
        var firstColumn = this.getFirstColumn();
        var lastColumn = firstColumn + this.getColumnSizes().length - 1;

        if (index >= firstColumn && index <= lastColumn) {
          this.updateLayerData();
        }
      }
    }
  });
  qx.ui.virtual.layer.Column.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Represents horizontal or vertical lines.
   */
  qx.Class.define("qx.ui.virtual.layer.GridLines", {
    extend: qx.ui.virtual.layer.Abstract,

    /**
     * @param orientation {String?"horizontal"} The grid line orientation.
     * @param lineColor {Color?null} The default color for grid lines
     * @param lineSize {PositiveInteger|null} The default width/height for grid
     *    lines.
     */
    construct: function construct(orientation, lineColor, lineSize) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this.setZIndex(11);

      if (lineColor) {
        this.setDefaultLineColor(lineColor);
      }

      if (lineSize !== undefined) {
        this.setDefaultLineSize(lineSize);
      }

      this.__lineColors__P_549_0 = [];
      this.__lineSizes__P_549_1 = [];
      this._isHorizontal = (orientation || "horizontal") == "horizontal";
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /** The default color for grid lines.*/
      defaultLineColor: {
        init: "gray",
        check: "Color",
        themeable: true
      },

      /** The default width/height for grid lines.*/
      defaultLineSize: {
        init: 1,
        check: "PositiveInteger",
        themeable: true
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** Stores the colors for deviant grid lines. */
      __lineColors__P_549_0: null,

      /** Stores the width/height for deviant grid lines. */
      __lineSizes__P_549_1: null,

      /**
       * Whether horizontal lines are rendered
       *
       * @return {Boolean} Whether horizontal lines are rendered
       */
      isHorizontal: function isHorizontal() {
        return this._isHorizontal;
      },

      /**
       * Sets the color for the grid line with the given index.
       *
       * @param index {PositiveNumber} The index of the line.
       * @param color {Color} The color.
       */
      setLineColor: function setLineColor(index, color) {
        {
          qx.core.Assert.assertPositiveNumber(index);
          qx.core.Assert.assertString(color);
        }
        this.__lineColors__P_549_0[index] = color;

        if (this.__isLineRendered__P_549_2(index)) {
          this.updateLayerData();
        }
      },

      /**
       * Sets the width/height for the grid line with the given index.
       *
       * @param index {PositiveNumber} The index of the line.
       * @param size {PositiveInteger} The size.
       */
      setLineSize: function setLineSize(index, size) {
        {
          qx.core.Assert.assertPositiveInteger(index);
          qx.core.Assert.assertPositiveInteger(size);
        }
        this.__lineSizes__P_549_1[index] = size;

        if (this.__isLineRendered__P_549_2(index)) {
          this.updateLayerData();
        }
      },

      /**
       * Whether the line with the given index is currently rendered (i.e. in the
       * layer's view port).
       *
       * @param index {Integer} The line's index
       * @return {Boolean} Whether the line is rendered
       */
      __isLineRendered__P_549_2: function __isLineRendered__P_549_2(index) {
        if (this._isHorizontal) {
          var firstColumn = this.getFirstColumn();
          var lastColumn = firstColumn + this.getColumnSizes().length - 1;
          return index >= firstColumn && index <= lastColumn;
        } else {
          var firstRow = this.getFirstRow();
          var lastRow = firstRow + this.getRowSizes().length - 1;
          return index >= firstRow && index <= lastRow;
        }
      },

      /**
       * Returns the size of the grid line with the given index.
       *
       * @param index {PositiveNumber} The index of the line.
       * @return {PositiveInteger} The size.
       */
      getLineSize: function getLineSize(index) {
        return this.__lineSizes__P_549_1[index] || this.getDefaultLineSize();
      },

      /**
       * Returns the color of the grid line with the given index.
       *
       * @param index {PositiveNumber} The index of the line.
       * @return {String} The color.
       */
      getLineColor: function getLineColor(index) {
        return this.__lineColors__P_549_0[index] || this.getDefaultLineColor();
      },

      /**
       * Helper function to render horizontal lines.
       *
       * @param htmlArr {Array} An array to store the generated HTML in.
       * @param firstRow {Integer} The first visible row
       * @param rowSizes {Array} An array containing the row sizes.
       */
      __renderHorizontalLines__P_549_3: function __renderHorizontalLines__P_549_3(htmlArr, firstRow, rowSizes) {
        var top = 0;
        var color, height;

        for (var y = 0; y < rowSizes.length - 1; y++) {
          color = this.getLineColor(firstRow + y);
          height = this.getLineSize(firstRow + y);
          top += rowSizes[y];
          htmlArr.push("<div style='", "position: absolute;", "height: " + height + "px;", "width: 100%;", "top:", top - (height > 1 ? Math.floor(height / 2) : 1), "px;", "background-color:", color, "'>", "</div>");
        }
      },

      /**
       * Helper function to render vertical lines.
       *
       * @param htmlArr {Array} The array to store the generated HTML in.
       * @param firstColumn {Integer} The first visible column
       * @param columnSizes {Array} An array containing the column sizes.
       */
      __renderVerticalLines__P_549_4: function __renderVerticalLines__P_549_4(htmlArr, firstColumn, columnSizes) {
        var left = 0;
        var color, width;

        for (var x = 0; x < columnSizes.length - 1; x++) {
          color = this.getLineColor(firstColumn + x);
          width = this.getLineSize(firstColumn + x);
          left += columnSizes[x];
          htmlArr.push("<div style='", "position: absolute;", "width: " + width + "px;", "height: 100%;", "top: 0px;", "left:", left - (width > 1 ? Math.floor(width / 2) : 1), "px;", "background-color:", color, "'>", "</div>");
        }
      },
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];

        if (this._isHorizontal) {
          this.__renderHorizontalLines__P_549_3(html, firstRow, rowSizes);
        } else {
          this.__renderVerticalLines__P_549_4(html, firstColumn, columnSizes);
        }

        this.getContentElement().setAttribute("html", html.join(""));
      },
      // overridden
      _updateLayerWindow: function _updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        var rowChanged = firstRow !== this.getFirstRow() || rowSizes.length !== this.getRowSizes().length;
        var columnChanged = firstColumn !== this.getFirstColumn() || columnSizes.length !== this.getColumnSizes().length;

        if (this._isHorizontal && rowChanged || !this._isHorizontal && columnChanged) {
          this._fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
        }
      }
    },

    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct: function destruct() {
      this.__lineColors__P_549_0 = this.__lineSizes__P_549_1 = null;
    }
  });
  qx.ui.virtual.layer.GridLines.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.core.IHtmlCellProvider": {
        "construct": true
      },
      "qx.bom.client.Css": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "css.boxmodel": {
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * The HtmlCell layer renders each cell with custom HTML markup. The concrete
   * markup for each cell is provided by a cell provider.
   */
  qx.Class.define("qx.ui.virtual.layer.HtmlCell", {
    extend: qx.ui.virtual.layer.Abstract,

    /**
     * @param htmlCellProvider {qx.ui.virtual.core.IHtmlCellProvider} This class
     *    provides the HTML markup for each cell.
     */
    construct: function construct(htmlCellProvider) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this.setZIndex(12);
      {
        this.assertInterface(htmlCellProvider, qx.ui.virtual.core.IHtmlCellProvider);
      }
      this._cellProvider = htmlCellProvider;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Get the cell size taking the box model into account
       *
       * @param width {Integer} The cell's (border-box) width in pixel
       * @param height {Integer} The cell's (border-box) height in pixel
       * @param insetX {Integer} The cell's horizontal insets, i.e. the sum of
       *    horizontal paddings and borders
       * @param insetY {Integer} The cell's vertical insets, i.e. the sum of
       *    vertical paddings and borders
       * @return {String} The CSS style string for the cell size
       */
      _getCellSizeStyle: function _getCellSizeStyle(width, height, insetX, insetY) {
        var style = "";

        if (qx.core.Environment.get("css.boxmodel") == "content") {
          width -= insetX;
          height -= insetY;
        }

        style += "width:" + width + "px;";
        style += "height:" + height + "px;";
        return style;
      },
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];
        var left = 0;
        var top = 0;
        var row = firstRow;
        var column = firstColumn;

        for (var y = 0; y < rowSizes.length; y++) {
          var left = 0;
          var column = firstColumn;
          var height = rowSizes[y];

          for (var x = 0; x < columnSizes.length; x++) {
            var width = columnSizes[x];

            var cellProperties = this._cellProvider.getCellProperties(row, column);

            var insets = cellProperties.insets || [0, 0];
            html.push("<div ", "style='", "left:", left, "px;", "top:", top, "px;", this._getCellSizeStyle(width, height, insets[0], insets[1]), cellProperties.style || "", "' ", "class='", cellProperties.classes || "", "' ", cellProperties.attributes || "", ">", cellProperties.content || "", "</div>");
            column++;
            left += width;
          }

          top += height;
          row++;
        }

        this.getContentElement().setAttribute("html", html.join(""));
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._cellProvider = null;
    }
  });
  qx.ui.virtual.layer.HtmlCell.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.HtmlCell": {
        "construct": true,
        "require": true
      },
      "qx.ui.virtual.layer.CellSpanManager": {
        "construct": true
      },
      "qx.ui.core.queue.Widget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * An extended HtmlCell layer, which adds the possibility to specify row and
   * column spans for specific cells.
   */
  qx.Class.define("qx.ui.virtual.layer.HtmlCellSpan", {
    extend: qx.ui.virtual.layer.HtmlCell,

    /**
     * @param htmlCellProvider {qx.ui.virtual.core.IHtmlCellProvider} This class
     *    provides the HTML markup for each cell.
     * @param rowConfig {qx.ui.virtual.core.Axis} The row configuration of the pane
     *    in which the cells will be rendered
     * @param columnConfig {qx.ui.virtual.core.Axis} The column configuration of
     *    the pane in which the cells will be rendered
     */
    construct: function construct(htmlCellProvider, rowConfig, columnConfig) {
      qx.ui.virtual.layer.HtmlCell.constructor.call(this, htmlCellProvider);
      this._spanManager = new qx.ui.virtual.layer.CellSpanManager(rowConfig, columnConfig);
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Set the row and column span for a specific cell
       *
       * @param row {PositiveInteger} The cell's row
       * @param column {PositiveInteger} The cell's column
       * @param rowSpan {PositiveInteger} The number of rows the cells spans
       * @param columnSpan {PositiveInteger} The number of columns the cells spans
       */
      setCellSpan: function setCellSpan(row, column, rowSpan, columnSpan) {
        var id = row + "x" + column;

        this._spanManager.removeCell(id);

        if (rowSpan > 1 || columnSpan > 1) {
          this._spanManager.addCell(id, row, column, rowSpan, columnSpan);
        }

        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * Renders a cell
       *
       * @param htmlArr {String[]} the output array
       * @param row {Integer} The cell's row index
       * @param column {Integer} The cell's column index
       * @param left {Integer} The cell's CSS left position (in pixel)
       * @param top {Integer} The cell's CSS top position (in pixel)
       * @param width {Integer} The cell's width
       * @param height {Integer} The cell's height
       */
      __renderCell__P_550_0: function __renderCell__P_550_0(htmlArr, row, column, left, top, width, height) {
        var cellProperties = this._cellProvider.getCellProperties(row, column);

        var insets = cellProperties.insets || [0, 0];
        htmlArr.push("<div ", "style='", "left:", left, "px;", "top:", top, "px;", this._getCellSizeStyle(width, height, insets[0], insets[1]), cellProperties.style || "", "' ", "class='", cellProperties.classes || "", "' ", cellProperties.attributes || "", ">", cellProperties.content || "", "</div>");
      },
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        var html = [];

        var cells = this._spanManager.findCellsInWindow(firstRow, firstColumn, rowSizes.length, columnSizes.length);

        if (cells.length > 0) {
          var bounds = this._spanManager.getCellBounds(cells, firstRow, firstColumn);

          var spanMap = this._spanManager.computeCellSpanMap(cells, firstRow, firstColumn, rowSizes.length, columnSizes.length); // render spanning cells


          for (var i = 0, l = cells.length; i < l; i++) {
            var cell = cells[i];
            var cellBounds = bounds[i];

            this.__renderCell__P_550_0(html, cell.firstRow, cell.firstColumn, cellBounds.left, cellBounds.top, cellBounds.width, cellBounds.height);
          }
        } else {
          // create empty dummy map
          spanMap = [];

          for (var i = 0; i < rowSizes.length; i++) {
            spanMap[firstRow + i] = [];
          }
        } // render non spanning cells


        var left = 0;
        var top = 0;
        var row = firstRow;
        var column = firstColumn;

        for (var x = 0; x < rowSizes.length; x++) {
          var left = 0;
          var column = firstColumn;
          var height = rowSizes[x];

          for (var y = 0; y < columnSizes.length; y++) {
            var width = columnSizes[y];

            if (!spanMap[row][column]) {
              this.__renderCell__P_550_0(html, row, column, left, top, width, height);
            }

            column++;
            left += width;
          }

          top += height;
          row++;
        }

        this.getContentElement().setAttribute("html", html.join(""));
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function destruct() {
      this._disposeObjects("_spanManager");
    }
  });
  qx.ui.virtual.layer.HtmlCellSpan.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.layer.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.ui.core.MChildrenHandling": {
        "require": true
      },
      "qx.ui.virtual.layer.CellSpanManager": {
        "construct": true
      },
      "qx.ui.virtual.layer.WidgetCell": {
        "construct": true
      },
      "qx.ui.layout.Grow": {
        "construct": true
      },
      "qx.ui.core.queue.Widget": {},
      "qx.ui.core.Spacer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * An extended WidgetCell layer, which adds the possibility to specify row and
   * column spans for specific cells.
   */
  qx.Class.define("qx.ui.virtual.layer.WidgetCellSpan", {
    extend: qx.ui.virtual.layer.Abstract,
    include: [qx.ui.core.MChildrenHandling],

    /**
    * @param widgetCellProvider {qx.ui.virtual.core.IWidgetCellProvider} This
     *    class manages the life cycle of the cell widgets.
     * @param rowConfig {qx.ui.virtual.core.Axis} The row configuration of the pane
     *    in which the cells will be rendered
     * @param columnConfig {qx.ui.virtual.core.Axis} The column configuration of the pane
     *    in which the cells will be rendered
     */
    construct: function construct(widgetCellProvider, rowConfig, columnConfig) {
      qx.ui.virtual.layer.Abstract.constructor.call(this);
      this.setZIndex(12);
      this._spanManager = new qx.ui.virtual.layer.CellSpanManager(rowConfig, columnConfig);
      this._cellProvider = widgetCellProvider;
      this.__spacerPool__P_553_0 = [];
      this._cellLayer = new qx.ui.virtual.layer.WidgetCell(this.__getCellProviderForNonSpanningCells__P_553_1());

      this._cellLayer.setZIndex(0);

      this._setLayout(new qx.ui.layout.Grow());

      this._add(this._cellLayer);
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      // overridden
      anonymous: {
        refine: true,
        init: false
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the widget used to render the given cell. May return null if the
       * cell isn’t rendered currently rendered.
       *
       * @param row {Integer} The cell's row index
       * @param column {Integer} The cell's column index
       * @return {qx.ui.core.LayoutItem|null} the widget used to render the given
       *    cell or <code>null</code>
       */
      getRenderedCellWidget: function getRenderedCellWidget(row, column) {
        var widget = this._cellLayer.getRenderedCellWidget(row, column);

        if (!widget || widget.getUserData("cell.spanning")) {
          var children = this._getChildren();

          for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];

            if (child == this._cellLayer) {
              continue;
            }

            var cell = {
              row: child.getUserData("cell.row"),
              column: child.getUserData("cell.column"),
              rowSpan: child.getUserData("cell.rowspan"),
              colSpan: child.getUserData("cell.colspan")
            };

            if (cell.row <= row && row < cell.row + cell.rowSpan && cell.column <= column && column < cell.column + cell.colSpan) {
              return child;
            }
          }

          return null;
        }

        return widget;
      },
      __spacerPool__P_553_0: null,

      /**
       * Set the row and column span for a specific cell
       *
       * @param row {PositiveInteger} The cell's row
       * @param column {PositiveInteger} The cell's column
       * @param rowSpan {PositiveInteger} The number of rows the cells spans
       * @param columnSpan {PositiveInteger} The number of columns the cells spans
       */
      setCellSpan: function setCellSpan(row, column, rowSpan, columnSpan) {
        var id = row + "x" + column;

        this._spanManager.removeCell(id);

        if (rowSpan > 1 || columnSpan > 1) {
          this._spanManager.addCell(id, row, column, rowSpan, columnSpan);
        }

        qx.ui.core.queue.Widget.add(this);
      },

      /**
       * Get the spacer widget, for span cells
       *
       * @return {qx.ui.core.Spacer} The spacer widget.
       */
      _getSpacer: function _getSpacer() {
        var spacer = this.__spacerPool__P_553_0.pop();

        if (!spacer) {
          spacer = new qx.ui.core.Spacer();
          spacer.setUserData("cell.empty", 1);
          spacer.setUserData("cell.spanning", 1);
        }

        return spacer;
      },

      /**
       * Get the cell provider for the non spanning cells
       *
       * @return {qx.ui.virtual.core.IWidgetCellProvider} the cell provider
       */
      __getCellProviderForNonSpanningCells__P_553_1: function __getCellProviderForNonSpanningCells__P_553_1() {
        var self = this;
        var cellProvider = this._cellProvider;
        var spacerPool = this.__spacerPool__P_553_0;
        var nonSpanningCellProvider = {
          getCellWidget: function getCellWidget(row, column) {
            if (!self._spanMap[row][column]) {
              var widget = cellProvider.getCellWidget(row, column);
            } else {
              var widget = self._getSpacer();
            }

            return widget;
          },
          poolCellWidget: function poolCellWidget(widget) {
            if (widget.getUserData("cell.spanning")) {
              spacerPool.push(widget);
            } else {
              cellProvider.poolCellWidget(widget);
            }
          }
        };
        return nonSpanningCellProvider;
      },

      /**
       * Updates the fields <code>_cells</code>, <code>_bounds</code> and
       * <code>_spanMap</code> according to the given grid window.
       *
       * @param firstRow {PositiveInteger} first visible row
       * @param firstColumn {PositiveInteger} first visible column
       * @param rowCount {PositiveInteger} number of rows to update
       * @param columnCount {PositiveInteger} number columns to update
       */
      __updateCellSpanData__P_553_2: function __updateCellSpanData__P_553_2(firstRow, firstColumn, rowCount, columnCount) {
        this._cells = this._spanManager.findCellsInWindow(firstRow, firstColumn, rowCount, columnCount);

        if (this._cells.length > 0) {
          this._bounds = this._spanManager.getCellBounds(this._cells, firstRow, firstColumn);
          this._spanMap = this._spanManager.computeCellSpanMap(this._cells, firstRow, firstColumn, rowCount, columnCount);
        } else {
          this._bounds = []; // create empty dummy map

          this._spanMap = [];

          for (var i = 0; i < rowCount; i++) {
            this._spanMap[firstRow + i] = [];
          }
        }
      },

      /**
       * Updates the widget in spanned cells.
       *
       * Note: The method {@link #__updateCellSpanData} must be called before
       * this method is called:
       */
      __updateCellSpanWidgets__P_553_3: function __updateCellSpanWidgets__P_553_3() {
        // remove and pool existing cells
        var children = this.getChildren();

        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];

          if (child !== this._cellLayer) {
            this._cellProvider.poolCellWidget(child);

            this._remove(child);
          }
        }

        for (var i = 0, l = this._cells.length; i < l; i++) {
          var cell = this._cells[i];
          var cellBounds = this._bounds[i];

          var cellWidget = this._cellProvider.getCellWidget(cell.firstRow, cell.firstColumn);

          if (cellWidget) {
            cellWidget.setUserBounds(cellBounds.left, cellBounds.top, cellBounds.width, cellBounds.height);
            cellWidget.setUserData("cell.row", cell.firstRow);
            cellWidget.setUserData("cell.column", cell.firstColumn);
            cellWidget.setUserData("cell.rowspan", cell.lastRow - cell.firstRow + 1);
            cellWidget.setUserData("cell.colspan", cell.lastColumn - cell.firstColumn + 1);

            this._add(cellWidget);
          }
        }
      },
      // overridden
      _fullUpdate: function _fullUpdate(firstRow, firstColumn, rowSizes, columnSizes) {
        this.__updateCellSpanData__P_553_2(firstRow, firstColumn, rowSizes.length, columnSizes.length);

        this.__updateCellSpanWidgets__P_553_3();

        this._cellLayer.fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);
      },
      // overridden
      _updateLayerWindow: function _updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes) {
        this.__updateCellSpanData__P_553_2(firstRow, firstColumn, rowSizes.length, columnSizes.length);

        this.__updateCellSpanWidgets__P_553_3();

        this._cellLayer.updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes);
      }
    },
    destruct: function destruct() {
      var children = this._getChildren();

      for (var i = 0; i < children.length; i++) {
        children[i].dispose();
      }

      this._disposeObjects("_spanManager", "_cellLayer");

      this._cellProvider = this.__spacerPool__P_553_0 = this._cells = this._bounds = this._spanMap = null;
    }
  });
  qx.ui.virtual.layer.WidgetCellSpan.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.selection.Abstract": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Cell selection manager
   */
  qx.Class.define("qx.ui.virtual.selection.CellRectangle", {
    extend: qx.ui.virtual.selection.Abstract,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the number of all items in the pane. This number may contain
       * unselectable items as well.
       *
       * @return {Integer} number of items
       */
      _getItemCount: function _getItemCount() {
        return this._pane.getRowConfig().getItemCount() * this._pane.getColumnConfig().getItemCount();
      },

      /*
      ---------------------------------------------------------------------------
        IMPLEMENT ABSTRACT METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _getSelectableFromPointerEvent: function _getSelectableFromPointerEvent(event) {
        var cell = this._pane.getCellAtPosition(event.getDocumentLeft(), event.getDocumentTop());

        if (!cell) {
          return null;
        }

        return this._isSelectable(cell) ? cell : null;
      },
      // overridden
      getSelectables: function getSelectables(all) {
        var selectables = [];

        var rowCount = this._pane.getRowConfig().getItemCount();

        var columnCount = this._pane.getColumnConfig().getItemCount();

        for (var row = 0; row < rowCount; row++) {
          for (var column = 0; column < columnCount; column++) {
            var cell = {
              row: row,
              column: column
            };

            if (this._isSelectable(cell)) {
              selectables.push(cell);
            }
          }
        }

        return selectables;
      },
      // overridden
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        var selectables = [];
        var minRow = Math.min(item1.row, item2.row);
        var maxRow = Math.max(item1.row, item2.row);
        var minColumn = Math.min(item1.column, item2.column);
        var maxColumn = Math.max(item1.column, item2.column);

        for (var row = minRow; row <= maxRow; row++) {
          for (var column = minColumn; column <= maxColumn; column++) {
            var cell = {
              row: row,
              column: column
            };

            if (this._isSelectable(cell)) {
              selectables.push(cell);
            }
          }
        }

        return selectables;
      },
      // overridden
      _getFirstSelectable: function _getFirstSelectable() {
        var rowCount = this._pane.getRowConfig().getItemCount();

        var columnCount = this._pane.getColumnConfig().getItemCount();

        for (var row = 0; row < rowCount; row++) {
          for (var column = 0; column < columnCount; column++) {
            var cell = {
              row: row,
              column: column
            };

            if (this._isSelectable(cell)) {
              return cell;
            }
          }
        }

        return null;
      },
      // overridden
      _getLastSelectable: function _getLastSelectable() {
        var rowCount = this._pane.getRowConfig().getItemCount();

        var columnCount = this._pane.getColumnConfig().getItemCount();

        for (var column = columnCount - 1; column >= 0; column--) {
          for (var row = rowCount - 1; row >= 0; row--) {
            var cell = {
              row: row,
              column: column
            };

            if (this._isSelectable(cell)) {
              return cell;
            }
          }
        }

        return null;
      },
      // overridden
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        var cell = {
          row: item.row,
          column: item.column
        };

        switch (relation) {
          case "above":
            for (var row = item.row - 1; row >= 0; row--) {
              cell.row = row;

              if (this._isSelectable(cell)) {
                return cell;
              }
            }

            break;

          case "under":
            var rowCount = this._pane.getRowConfig().getItemCount();

            for (var row = item.row + 1; row < rowCount; row++) {
              cell.row = row;

              if (this._isSelectable(cell)) {
                return cell;
              }
            }

            break;

          case "left":
            for (var column = item.column - 1; column >= 0; column--) {
              cell.column = column;

              if (this._isSelectable(cell)) {
                return cell;
              }
            }

            break;

          case "right":
            var columnCount = this._pane.getColumnConfig().getItemCount();

            for (var column = item.column + 1; column < columnCount; column++) {
              cell.column = column;

              if (this._isSelectable(cell)) {
                return cell;
              }
            }

            break;
        }

        return null;
      },
      // overridden
      _getPage: function _getPage(lead, up) {
        if (up) {
          return this._getFirstSelectable();
        } else {
          return this._getLastSelectable();
        }
      },
      // overridden
      _selectableToHashCode: function _selectableToHashCode(item) {
        return item.column + "x" + item.row;
      },
      // overridden
      _scrollItemIntoView: function _scrollItemIntoView(item) {
        if (this._autoScrollIntoView) {
          this._pane.scrollCellIntoView(item.column, item.row);
        }
      },
      // overridden
      _getSelectableLocationX: function _getSelectableLocationX(item) {
        var columnConfig = this._pane.getColumnConfig();

        var itemLeft = columnConfig.getItemPosition(item.column);
        var itemRight = itemLeft + columnConfig.getItemSize(item.column) - 1;
        return {
          left: itemLeft,
          right: itemRight
        };
      },
      // overridden
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        var rowConfig = this._pane.getRowConfig();

        var itemTop = rowConfig.getItemPosition(item.row);
        var itemBottom = itemTop + rowConfig.getItemSize(item.row) - 1;
        return {
          top: itemTop,
          bottom: itemBottom
        };
      }
    }
  });
  qx.ui.virtual.selection.CellRectangle.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.selection.CellRectangle": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */

  /**
   * Cell selection manager
   */
  qx.Class.define("qx.ui.virtual.selection.CellLines", {
    extend: qx.ui.virtual.selection.CellRectangle,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        IMPLEMENT ABSTRACT METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _getSelectableRange: function _getSelectableRange(item1, item2) {
        var selectables = [];

        var columnCount = this._pane.getColumnConfig().getItemCount();

        if (item1.row < item2.row || item1.row == item2.row && item1.column < item2.column) {
          var start = item1.row * columnCount + item1.column;
          var end = item2.row * columnCount + item2.column;
        } else {
          var start = item2.row * columnCount + item2.column;
          var end = item1.row * columnCount + item1.column;
        }

        for (var i = start; i <= end; i++) {
          var cell = {
            row: Math.floor(i / columnCount),
            column: i % columnCount
          };

          if (this._isSelectable(cell)) {
            selectables.push(cell);
          }
        }

        return selectables;
      }
    }
  });
  qx.ui.virtual.selection.CellLines.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.virtual.selection.Row": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Column selection manager
   */
  qx.Class.define("qx.ui.virtual.selection.Column", {
    extend: qx.ui.virtual.selection.Row,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Returns the number of all items in the pane. This number may contain
       * unselectable items as well.
       *
       * @return {Integer} number of items
       */
      _getItemCount: function _getItemCount() {
        return this._pane.getColumnConfig().getItemCount();
      },

      /*
      ---------------------------------------------------------------------------
        IMPLEMENT ABSTRACT METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      _getSelectableFromPointerEvent: function _getSelectableFromPointerEvent(event) {
        var cell = this._pane.getCellAtPosition(event.getDocumentLeft(), event.getDocumentTop());

        if (!cell) {
          return null;
        }

        return this._isSelectable(cell.column) ? cell.column : null;
      },
      // overridden
      _getRelatedSelectable: function _getRelatedSelectable(item, relation) {
        if (relation == "left") {
          var startIndex = item - 1;
          var endIndex = 0;
          var increment = -1;
        } else if (relation == "right") {
          var startIndex = item + 1;
          var endIndex = this._getItemCount() - 1;
          var increment = 1;
        } else {
          return null;
        }

        for (var i = startIndex; i !== endIndex + increment; i += increment) {
          if (this._isSelectable(i)) {
            return i;
          }
        }

        return null;
      },
      // overridden
      _scrollItemIntoView: function _scrollItemIntoView(item) {
        if (this._autoScrollIntoView) {
          this._pane.scrollColumnIntoView(item);
        }
      },
      // overridden
      _getSelectableLocationX: function _getSelectableLocationX(item) {
        var columnConfig = this._pane.getColumnConfig();

        var itemLeft = columnConfig.getItemPosition(item);
        var itemRight = itemLeft + columnConfig.getItemSize(item) - 1;
        return {
          left: itemLeft,
          right: itemRight
        };
      },
      // overridden
      _getSelectableLocationY: function _getSelectableLocationY(item) {
        return {
          top: 0,
          bottom: this._pane.getRowConfig().getTotalSize() - 1
        };
      }
    }
  });
  qx.ui.virtual.selection.Column.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Objects, which are used as delegates for a virtual selection manager may
   * implement any of the methods described in this interface. The delegate does
   * not need implement all of the methods of this interface. If a method is not
   * implemented the selection manager provides a default implementation.
   *
   * Note: This interface is meant to document the delegate but should not be
   * listed in the <code>implement</code> key of a class unless all methods are
   * really implemented.
   */
  qx.Interface.define("qx.ui.virtual.selection.ISelectionDelegate", {
    members: {
      /**
       * Returns whether the given item is selectable. The type of the item
       * depends on the concrete selection manager implementation. The
       * {@link Row} and {@link Column} selection manager use row/column indexes
       * as items. The {@link qx.ui.virtual.cell.Cell} uses cells as items. Cells are represented by
       * a map containing <code>row</code> and <code>column</code> keys.
       *
       * If this method is not implemented by the delegate all items are selectable.
       *
       * @param item {var} The item to be checked
       * @return {Boolean} Whether the given item is selectable
       */
      isItemSelectable: function isItemSelectable(item) {},

      /**
       * Update the style (appearance) of the given item.
       *
       * @param item {var} Item to modify
       * @param type {String} Any of <code>selected</code>, <code>anchor</code>
       *    or <code>lead</code>
       * @param wasAdded {Boolean} Whether the given style should be added or removed.
       */
      styleSelectable: function styleSelectable(item, type, wasAdded) {}
    }
  });
  qx.ui.virtual.selection.ISelectionDelegate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Dataset": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.util.String": {
        "require": true,
        "defer": "runtime"
      },
      "qx.module.event.Native": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qxWeb": {
        "construct": true,
        "defer": "runtime",
        "require": true
      },
      "qx.core.IDisposable": {
        "require": true
      },
      "qx.core.Wrapper": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * This is the base collection for all widgets and offers a good foundation
   * for all widgets including enabled state handling, config and template storage
   * and event handling to name a few key features.
   *
   * @require(qx.module.Dataset)
   * @require(qx.module.util.String)
   * @require(qx.module.event.Native)
   *
   * @group (Widget)
   */
  qx.Bootstrap.define("qx.ui.website.Widget", {
    extend: qxWeb,
    implement: [qx.core.IDisposable],
    statics: {
      /**
       * Factory method for the widget which converts a standard
       * collection into a collection of widgets.
       *
       * @return {qx.ui.website.Widget} A widget.
       *
       * @attach {qxWeb}
       */
      widget: function widget() {
        var widget = new qx.ui.website.Widget(this);
        widget.init();
        return widget;
      },

      /**
       * Creates a new collection from the given argument. This can either be an
       * HTML string, a single DOM element or an array of elements
       *
       * @param html {String|Element[]} HTML string or DOM element(s)
       * @return {qxWeb} Collection of elements
       */
      create: function create(html) {
        return new qx.ui.website.Widget(qxWeb.create(html));
      },

      /**
       * Fetches elements with a data attribute named <code>data-qx-class</code>
       * containing the class name of the desired widget and initializes them as
       * widgets.
       *
       * @param selector {String?} Optional selector expression or filter function to
       * restrict the list of elements
       * @attachStatic {qxWeb}
       */
      initWidgets: function initWidgets(selector) {
        var elements = qxWeb("*[data-qx-class]");

        if (selector) {
          elements = elements.filter(selector);
        }

        elements._forEachElementWrapped(function (widget) {
          widget.init();
        });
      },

      /**
       * Returns a wrapper Array that maps the widget API available on
       * the first item in the current collection to all items in the
       * collection.
       *
       * @attach {qxWeb}
       * @return {qxWeb[]} Collection of widgets
       */
      toWidgetCollection: function toWidgetCollection() {
        var args = this.toArray().map(function (el) {
          return qxWeb(el);
        }); // Set the context for the 'bind' call (will be replaced by new)

        Array.prototype.unshift.call(args, null); // Create temporary constructor with bound arguments

        var Temp = qx.core.Wrapper.bind.apply(qx.core.Wrapper, args);
        return new Temp();
      }
    },
    construct: function construct(selector, context) {
      var col = qxWeb.constructor.call(this, selector, context);

      if (col.length > 1) {
        throw new Error("The collection must not contain more than one element.");
      }

      Array.prototype.push.apply(this, Array.prototype.slice.call(col, 0, col.length));
    },
    members: {
      __cssPrefix__P_561_0: null,

      /**
       * Responsible for initializing of the widget. This checks for the data attribute
       * named <code>data-qx-class</code> and initializes the widget if necessary.
       * @return {Boolean} <code>true</code> if the widget has been initialized
       */
      init: function init() {
        if (this.getProperty("$$qx-widget-initialized")) {
          return false;
        }

        this.setAttribute("data-qx-class", this.classname);
        this.addClass("qx-widget");
        this.addClass(this.getCssPrefix());
        this.setProperty("$$qx-widget-initialized", true);

        if (this[0]) {
          this[0].$widget = this;
        }

        return true;
      },

      /**
       * Return the proper CSS prefix for the current widget. This prefix is
       * based on the current classname.
       *
       * @return {String} The CSS prefix for the current object.
       */
      getCssPrefix: function getCssPrefix() {
        if (!this.__cssPrefix__P_561_0) {
          var split = this.classname.split(".");
          this.__cssPrefix__P_561_0 = "qx-" + split[split.length - 1].toLowerCase();
        }

        return this.__cssPrefix__P_561_0;
      },

      /**
       * Changes the enabled state of the current collection, which means all
       * widgets in the collection. This sets the disabled attribute on the
       * elements and all its children.
       *
       * @param value {Boolean} The enabled value.
       * @return {qx.ui.website.Widget} The collection for chaining
       */
      setEnabled: function setEnabled(value) {
        this.setAttribute("disabled", !value);
        this.find("*").setAttribute("disabled", !value);
        return this;
      },

      /**
       * Returns weather the first widget in the collection is enabled or not.
       *
       * @return {Boolean} The enabled state of the collection.
       */
      getEnabled: function getEnabled() {
        return !this.getAttribute("disabled");
      },

      /**
       * Setter for the widget-specific templates. The available templates can
       * be found in the documentation of the corresponding widget. The templates
       * will be rendered using
       * <a href='https://github.com/janl/mustache.js/'>mustache.js</a>.
       *
       * Please keep in mind to call {@link #render} after you change any
       * template or config setting.
       *
       * @param name {String} The name of the template.
       * @param template {String} The template string.
       *
       * @return {qx.ui.website.Widget} The widget instance for chaining.
       */
      setTemplate: function setTemplate(name, template) {
        return this._setData("templates", name, template);
      },

      /**
       * Setter for the widget-specific config. The available config settings can
       * be found in the documentation of the corresponding widget. Each config
       * setting can be set in the markup as data-attribute, prefixed with
       * <code>data-qx</code> e.g. <code>data-qx-length="5"</code>.
       *
       * Please keep in mind to call {@link #render} after you change any
       * template or config setting.
       *
       * @param name {String} The name of the config setting.
       * @param config {var} The value of the config setting.
       * @return {qx.ui.website.Widget} The widget instance for chaining.
       */
      setConfig: function setConfig(name, config) {
        return this._setData("config", name, config);
      },

      /**
       * Helper to set either config or template values.
       *
       * @param type {String} Either <code>templates</code> or <code>config</code>.
       * @param name {String} The name for the value to store.
       * @param data {var} The data to store.
       * @return {qx.ui.website.Widget} The widget instance for chaining.
       */
      _setData: function _setData(type, name, data) {
        if (!this["$$storage_" + type]) {
          this["$$storage_" + type] = {};
        }

        this["$$storage_" + type][name] = data;
        return this;
      },

      /**
       * Returns the used template. This includes custom templates
       * as the default templates defined by the widgets.
       *
       * @param name {String} The name of the template.
       * @return {String} The template string or <code>undefined</code>.
       */
      getTemplate: function getTemplate(name) {
        return this._getData("templates", name);
      },

      /**
       * Returns the config setting currently in use for the given widget.
       * This can either be the user set config value, the value set in
       * the markup via data-attribute, the widgets default config value or
       * <code>undefined</code>, if non is set.
       *
       * @param name {String} The name of the config.
       * @return {var} The value of the config or <code>undefined</code>.
       */
      getConfig: function getConfig(name) {
        return this._getData("config", name);
      },

      /**
       * Internal helper for querying the values for templates and configs. In the
       * case of a config value, the method also reads the corresponding data-attribute
       * for possible values.
       *
       * @param type {String} Either <code>templates</code> or <code>config</code>.
       * @param name {String} The name for the value to fetch.
       * @return {var} The value store for the given arguments.
       */
      _getData: function _getData(type, name) {
        var storage = this["$$storage_" + type];
        var item;

        if (storage) {
          item = storage[name];
        }

        if (item === undefined && type == "config") {
          var attribName = "qx" + qxWeb.string.firstUp(type) + qxWeb.string.firstUp(name);
          item = this.getData(attribName); // not defined HTML attributes result in 'null' values

          if (!this[0] || !this[0].dataset && item === null) {
            item = undefined;
          }

          try {
            item = JSON.parse(item);
          } catch (e) {}
        }

        if (item === undefined && this.constructor["_" + type]) {
          return this.constructor["_" + type][name];
        }

        return item;
      },

      /**
       * The render method is responsible for applying changed config
       * and template settings. This method is usually overridden and specified
       * by the subclassing widgets like the slider or tabs.
       *
       * @return {qx.ui.website.Widget} The widget collection for chaining.
       */
      render: function render() {
        // empty method
        return this;
      },

      /**
       * Dispose the widget, making sure all objects are ready for
       * garbage collection. This mainly means deleting connections to the
       * DOM including event listeners.
       * @return {qxWeb} Plain qxWeb collection
       */
      dispose: function dispose() {
        this.removeAttribute("data-qx-class");
        this.setProperty("config", undefined);
        this.setProperty("templates", undefined);
        var contextProperty = this.classname.replace(/\./g, "-") + "-context";
        this.setProperty(contextProperty, undefined);
        this.setProperty("$$qx-widget-initialized", undefined);
        this.removeClass("qx-widget");
        this.removeClass(this.getCssPrefix());

        for (var name in this.constructor.$$events) {
          this.allOff(name);
        }

        this[0].$widget = null;
        return qxWeb.$init(this, qxWeb);
      }
    },
    defer: function defer(statics) {
      qxWeb.$attach({
        widget: statics.widget,
        toWidgetCollection: statics.toWidgetCollection
      });
      qxWeb.$attachStatic({
        initWidgets: statics.initWidgets
      });
    }
  });
  qx.ui.website.Widget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.Template": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.website.Widget": {
        "construct": true,
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      },
      "q": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013-2014 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * A row of buttons used to switch between connected pages. The buttons can be
   * right- or left-aligned, or they can be justified, i.e. they will be stretched
   * to fill the available width.
   *
   * <h2>Markup</h2>
   * Each Tabs widget contains an unordered list element (<code>ul</code>), which
   * will be created if not already present.
   * The tabs are list items (<code>li</code>). Each tab can contain
   * a button with a <code>tabsPage</code> data attribute where the value is a
   * CSS selector string identifying the corresponding page. Headers and pages
   * will not be created automatically. They can be predefined in the DOM before
   * the <code>q().tabs()</code> factory method is called, or added programmatically.
   *
   * <h2>CSS Classes</h2>
   * <table>
   *   <thead>
   *     <tr>
   *       <td>Class Name</td>
   *       <td>Applied to</td>
   *       <td>Description</td>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><code>qx-tabs</code></td>
   *       <td>Container element</td>
   *       <td>Identifies the Tabs widget</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-horizontal</code></td>
   *       <td>Container element</td>
   *       <td>Styles the widget in horizontal orientation</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-vertical</code></td>
   *       <td>Container element</td>
   *       <td>Styles the widget in vertical orientation</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-container</code></td>
   *       <td>Tab page container (<code>div</code>)</td>
   *       <td>Styles the tab pages' container (horizontal orientation only)</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-flex-justify-end</code></td>
   *       <td>Tab container (<code>ul</code>)</td>
   *       <td>Browsers with flexbox support only: Styles the tab buttons when they are right-aligned</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-left</code></td>
   *       <td>Container element</td>
   *       <td>Internet Explorer < 10 only: Styles the tab buttons when they are left-aligned</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-justify</code></td>
   *       <td>Container element</td>
   *       <td>Internet Explorer < 10 only: Styles the tab buttons when they are stretched to fill out the available width</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-right</code></td>
   *       <td>Container element</td>
   *       <td>Internet Explorer < 10 only: Styles the tab buttons when they are right-aligned</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-button</code></td>
   *       <td>Tab button (<code>li</code>)</td>
   *       <td>Identifies and styles the tabs</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-button-active</code></td>
   *       <td>Tab button (<code>li</code>)</td>
   *       <td>Identifies and styles the currently selected tab. Applied in addition to <code>qx-tabs-button</code></td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-flex-1</code></td>
   *       <td>Tab button (<code>li</code>)</td>
   *       <td>Browsers with flexbox support only: Styles the tab buttons when they are stretched to fill out the available width</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-tabs-page</code></td>
   *       <td>Tab page (<code>div</code> in horizontal mode, <code>li</code>)</td>
   *       <td>Styles the tab pages.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <h2 class="widget-markup">Generated DOM Structure</h2>
   *
   * @require(qx.module.Template)
   *
   * @group (Widget)
   */
  qx.Bootstrap.define("qx.ui.website.Tabs", {
    extend: qx.ui.website.Widget,
    statics: {
      /**
       * Factory method which converts the current collection into a collection of
       * tabs widgets.
       *
       * @attach{qxWeb}
       * @param align {String?} Tab button alignment. Default: <code>left</code>
       * @param preselected {Integer?} The (zero-based) index of the tab that
       * should initially be selected. Default: <code>0</code>
       * @param orientation {String?} <code>horizontal</code> (default) or <code>vertical</code>
       * @return {qx.ui.website.Tabs}
       */
      tabs: function tabs(align, preselected, orientation) {
        var tabs = new qx.ui.website.Tabs(this);

        if (typeof preselected !== "undefined") {
          tabs.setConfig("preselected", preselected);
        }

        tabs.init();

        if (align) {
          tabs.setConfig("align", align);
        }

        if (orientation) {
          tabs.setConfig("orientation", orientation);
        }

        if (align || orientation) {
          tabs.render();
        }

        return tabs;
      },

      /**
       * *button*
       *
       * Template used by {@link #addButton} to create a new button.
       *
       * Default value: <pre><li><button>{{{content}}}</button></li></pre>
       */
      _templates: {
        button: "<li><button>{{{content}}}</button></li>"
      },

      /**
       * *preselected*
       * The index of the page that should be opened after initial
       * rendering, or <code>null</code> if no page should be opened.
       *
       * Default value: <pre>0</pre>
       *
       * *align*
       * Configuration for the alignment of the tab buttons in horizontal
       * mode. This possible values are <code>left</code>,
       * <code>justify</code> and
       * <code>right</code>
       *
       * Default value: <pre>left</pre>
       *
       * *orientation*
       * Controls the layout of the widget. "horizontal" renders it as a
       * tab bar appropriate for wide screens. "vertical" renders it as a
       * stack of collapsible panes (sometimes called an accordion) that
       * is better suited for narrow screens.
       *
       * *mediaQuery*
       * A CSS media query string that will be used with a
       * media query listener to dynamically set the widget's
       * orientation. The widget will be rendered in vertical mode unless
       * the query matches.
       */
      _config: {
        preselected: 0,
        align: "left",
        orientation: "horizontal",
        mediaQuery: null
      }
    },
    construct: function construct(selector, context) {
      qx.ui.website.Widget.constructor.call(this, selector, context);
    },
    events: {
      /**
       * Fired when the selected page has changed. The value is
       * the newly selected page's index
       */
      "changeSelected": "Number"
    },
    members: {
      __mediaQueryListener__P_560_0: null,
      init: function init() {
        if (!qx.ui.website.Tabs.prototype.init.base.call(this)) {
          return false;
        }

        var mediaQuery = this.getConfig("mediaQuery");

        if (mediaQuery) {
          this.setConfig("orientation", this._initMediaQueryListener(mediaQuery));
        }

        var orientation = this.getConfig("orientation");
        this.addClasses([this.getCssPrefix(), this.getCssPrefix() + "-" + orientation, "qx-flex-ready"]);

        if (this.getChildren("ul").length === 0) {
          var list = qxWeb.create("<ul/>");
          var content = this.getChildren();

          if (content.length > 0) {
            list.insertBefore(content.eq(0));
          } else {
            this.append(list);
          }
        }

        var container = this.find("> ." + this.getCssPrefix() + "-container");
        var buttons = this.getChildren("ul").getFirst().getChildren("li").not("." + this.getCssPrefix() + "-page");

        buttons._forEachElementWrapped(function (button) {
          button.addClass(this.getCssPrefix() + "-button");
          var pageSelector = button.getData(this.getCssPrefix() + "-page");

          if (!pageSelector) {
            return;
          }

          button.addClass(this.getCssPrefix() + "-button").on("tap", this._onTap, this);

          var page = this._getPage(button);

          if (page.length > 0) {
            page.addClass(this.getCssPrefix() + "-page");

            if (orientation == "vertical") {
              this.__deactivateTransition__P_560_1(page);

              if (q.getNodeName(page[0]) == "div") {
                var li = q.create("<li>").addClass(this.getCssPrefix() + "-page").setAttribute("id", page.getAttribute("id")).insertAfter(button[0]);
                page.remove().getChildren().appendTo(li);
                page = li;
              }

              this._storePageHeight(page);
            } else if (orientation == "horizontal") {
              if (q.getNodeName(page[0]) == "li") {
                var div = q.create("<div>").addClass(this.getCssPrefix() + "-page").setAttribute("id", page.getAttribute("id"));
                page.remove().getChildren().appendTo(div);
                page = div;
              }
            }

            if (orientation == "horizontal") {
              if (container.length === 0) {
                container = qxWeb.create("<div class='" + this.getCssPrefix() + "-container'>").insertAfter(this.find("> ul")[0]);
              }

              page.appendTo(container[0]);
            }
          }

          this._showPage(null, button);

          this.__activateTransition__P_560_2(page);
        }.bind(this));

        if (orientation == "vertical" && container.length == 1 && container.getChildren().length === 0) {
          container.remove();
        }

        if (orientation == "horizontal" && this.getConfig("align") == "right" && q.env.get("engine.name") == "mshtml" && q.env.get("browser.documentmode") < 10) {
          buttons.remove();

          for (var i = buttons.length - 1; i >= 0; i--) {
            this.find("> ul").append(buttons[i]);
          }
        }

        var active = buttons.filter("." + this.getCssPrefix() + "-button-active");
        var preselected = this.getConfig("preselected");

        if (active.length === 0 && typeof preselected == "number") {
          active = buttons.eq(preselected).addClass(this.getCssPrefix() + "-button-active");
        }

        if (active.length > 0) {
          var activePage = this._getPage(active);

          this.__deactivateTransition__P_560_1(activePage);

          this._showPage(active, null);

          this.__activateTransition__P_560_2(activePage);
        }

        this.getChildren("ul").getFirst().on("keydown", this._onKeyDown, this);

        if (orientation === "horizontal") {
          this._applyAlignment(this);
        }

        qxWeb(window).on("resize", this._onResize, this);
        return true;
      },
      render: function render() {
        var mediaQuery = this.getConfig("mediaQuery");

        if (mediaQuery) {
          this.setConfig("orientation", this._initMediaQueryListener(mediaQuery));
        }

        var orientation = this.getConfig("orientation");

        if (orientation === "horizontal") {
          return this._renderHorizontal();
        } else if (orientation === "vertical") {
          return this._renderVertical();
        }
      },

      /**
       * Initiates a media query listener for dynamic orientation switching
       * @param mediaQuery {String} CSS media query string
       * @return {String} The appropriate orientation: "horizontal" if the
       * media query matches, "vertical" if it doesn't
       */
      _initMediaQueryListener: function _initMediaQueryListener(mediaQuery) {
        var mql = this.__mediaQueryListener__P_560_0;

        if (!mql) {
          mql = q.matchMedia(mediaQuery);
          this.__mediaQueryListener__P_560_0 = mql;
          mql.on("change", function (query) {
            this.render();
          }.bind(this));
        }

        if (mql.matches) {
          return "horizontal";
        } else {
          return "vertical";
        }
      },

      /**
       * Render the widget in horizontal mode
       * @return {qx.ui.website.Tabs} The collection for chaining
       */
      _renderHorizontal: function _renderHorizontal() {
        this.removeClass(this.getCssPrefix() + "-vertical").addClasses([this.getCssPrefix() + "", this.getCssPrefix() + "-horizontal"]).find("> ul").addClass("qx-hbox");
        var container = this.find("> ." + this.getCssPrefix() + "-container");

        if (container.length == 0) {
          container = qxWeb.create("<div class='" + this.getCssPrefix() + "-container'>").insertAfter(this.find("> ul")[0]);
        }

        var selectedPage;

        this.find("> ul > ." + this.getCssPrefix() + "-button")._forEachElementWrapped(function (li) {
          var page = this.find(li.getData(this.getCssPrefix() + "-page"));

          if (q.getNodeName(page[0]) == "li") {
            var div = q.create("<div>").addClass(this.getCssPrefix() + "-page").setAttribute("id", page.getAttribute("id"));
            page.remove().getChildren().appendTo(div);
            page = div;
          }

          page.appendTo(container[0]);

          this._switchPages(page, null);

          if (li.hasClass(this.getCssPrefix() + "-button-active")) {
            selectedPage = page;
          }
        }.bind(this));

        if (!selectedPage) {
          var firstButton = this.find("> ul > ." + this.getCssPrefix() + "-button").eq(0).addClass(this.getCssPrefix() + "-button-active");
          selectedPage = this._getPage(firstButton);
        }

        this._switchPages(null, selectedPage);

        this._applyAlignment(this);

        this.setEnabled(this.getEnabled());
        return this;
      },

      /**
       * Render the widget in vertical mode
       * @return {qx.ui.website.Tabs} The collection for chaining
       */
      _renderVertical: function _renderVertical() {
        this.find("> ul.qx-hbox").removeClass("qx-hbox");

        this.removeClasses([this.getCssPrefix() + "-horizontal"]).addClasses([this.getCssPrefix() + "", this.getCssPrefix() + "-vertical"]).getChildren("ul").getFirst().getChildren("li").not("." + this.getCssPrefix() + "-page")._forEachElementWrapped(function (button) {
          button.addClass(this.getCssPrefix() + "-button");

          var page = this._getPage(button);

          if (page.length === 0) {
            return;
          }

          this.__deactivateTransition__P_560_1(page);

          if (q.getNodeName(page[0]) == "div") {
            var li = q.create("<li>").addClass(this.getCssPrefix() + "-page").setAttribute("id", page.getAttribute("id"));
            page.getChildren().appendTo(li);
            li.insertAfter(button[0]);
            page.remove();
            page = li;
          }

          this._storePageHeight(page);

          if (button.hasClass(this.getCssPrefix() + "-button-active")) {
            this._switchPages(null, page);
          } else {
            this._switchPages(page, null);
          }

          this.__activateTransition__P_560_2(page);
        }.bind(this));

        this.setEnabled(this.getEnabled());
        return this;
      },

      /**
       * Re-render on browser window resize (page heights must be re-
       * calculated)
       */
      _onResize: function _onResize() {
        // make sure this runs after a MediaQueryListener callback
        // which might have changed the orientation
        setTimeout(function () {
          if (this.getConfig("orientation") == "vertical") {
            this._renderVertical();
          }
        }.bind(this), 100);
      },

      /**
       * Adds a new tab button
       *
       * @param label {String} The button's content. Can include markup.
       * @param pageSelector {String} CSS Selector that identifies the associated page
       * @return {qx.ui.website.Tabs} The collection for chaining
       */
      addButton: function addButton(label, pageSelector) {
        var link = qxWeb.create(qxWeb.template.render(this.getTemplate("button"), {
          content: label
        })).addClass(this.getCssPrefix() + "-button");
        var list = this.find("> ul");
        var links = list.getChildren("li");

        if (list.hasClass(this.getCssPrefix() + "-right") && links.length > 0) {
          link.insertBefore(links.getFirst());
        } else {
          link.appendTo(list);
        }

        link.on("tap", this._onTap, this).addClass(this.getCssPrefix() + "-button");

        if (this.find("> ul ." + this.getCssPrefix() + "-button").length === 1) {
          link.addClass(this.getCssPrefix() + "-button-active");
        }

        if (pageSelector) {
          link.setData(this.getCssPrefix() + "-page", pageSelector);

          var page = this._getPage(link);

          page.addClass(this.getCssPrefix() + "-page");

          if (link.hasClass(this.getCssPrefix() + "-button-active")) {
            this._switchPages(null, page);
          } else {
            this._switchPages(page, null);
          }
        }

        return this;
      },

      /**
       * Selects a tab button
       *
       * @param index {Integer} index of the button to select
       * @return {qx.ui.website.Tabs} The collection for chaining
       */
      select: function select(index) {
        var buttons = this.find("> ul > ." + this.getCssPrefix() + "-button");
        var oldButton = this.find("> ul > ." + this.getCssPrefix() + "-button-active").removeClass(this.getCssPrefix() + "-button-active");

        if (this.getConfig("align") == "right") {
          index = buttons.length - 1 - index;
        }

        var newButton = buttons.eq(index).addClass(this.getCssPrefix() + "-button-active");

        this._showPage(newButton, oldButton);

        this.emit("changeSelected", index);
        return this;
      },

      /**
       * Initiates the page switch when a button was clicked/tapped
       *
       * @param e {Event} Tap event
       */
      _onTap: function _onTap(e) {
        if (!this.getEnabled()) {
          return;
        }

        var orientation = this.getConfig("orientation");
        var tappedButton = e.getCurrentTarget();
        var oldButton = this.find("> ul > ." + this.getCssPrefix() + "-button-active");

        if (oldButton[0] == tappedButton && orientation == "horizontal") {
          return;
        }

        oldButton.removeClass(this.getCssPrefix() + "-button-active");

        if (orientation == "vertical") {
          this._showPage(null, oldButton);

          if (oldButton[0] == tappedButton && orientation == "vertical") {
            return;
          }
        }

        var newButton;

        var buttons = this.find("> ul > ." + this.getCssPrefix() + "-button")._forEachElementWrapped(function (button) {
          if (tappedButton === button[0]) {
            newButton = button;
          }
        });

        this._showPage(newButton, oldButton);

        newButton.addClass(this.getCssPrefix() + "-button-active");
        var index = buttons.indexOf(newButton[0]);

        if (this.getConfig("align") == "right") {
          index = buttons.length - 1 - index;
        }

        this.emit("changeSelected", index);
      },

      /**
       * Allows tab selection using the left and right arrow keys
       *
       * @param e {Event} keydown event
       */
      _onKeyDown: function _onKeyDown(e) {
        var key = e.getKeyIdentifier();

        if (!(key == "Left" || key == "Right")) {
          return;
        }

        var rightAligned = this.getConfig("align") == "right";
        var buttons = this.find("> ul > ." + this.getCssPrefix() + "-button");

        if (rightAligned) {
          buttons.reverse();
        }

        var active = this.find("> ul > ." + this.getCssPrefix() + "-button-active");
        var next;

        if (key == "Right") {
          if (!rightAligned) {
            next = active.getNext("." + this.getCssPrefix() + "-button");
          } else {
            next = active.getPrev("." + this.getCssPrefix() + "-button");
          }
        } else {
          if (!rightAligned) {
            next = active.getPrev("." + this.getCssPrefix() + "-button");
          } else {
            next = active.getNext("." + this.getCssPrefix() + "-button");
          }
        }

        if (next.length > 0) {
          var idx = buttons.indexOf(next);
          this.select(idx);
          next.getChildren("button").focus();
        }
      },

      /**
       * Initiates the page switch if a tab button is selected
       *
       * @param newButton {qxWeb} selected button
       * @param oldButton {qxWeb} previously active button
       */
      _showPage: function _showPage(newButton, oldButton) {
        var oldPage = this._getPage(oldButton);

        var newPage = this._getPage(newButton);

        if (this.getConfig("orientation") === "horizontal" && oldPage[0] == newPage[0]) {
          return;
        }

        this._switchPages(oldPage, newPage);
      },

      /**
       * Executes a page switch
       *
       * @param oldPage {qxWeb} the previously selected page
       * @param newPage {qxWeb} the newly selected page
       */
      _switchPages: function _switchPages(oldPage, newPage) {
        var orientation = this.getConfig("orientation");

        if (orientation === "horizontal") {
          if (oldPage) {
            oldPage.hide();
          }

          if (newPage) {
            newPage.show();
          }
        } else if (orientation === "vertical") {
          if (oldPage && oldPage.length > 0) {
            oldPage.setStyle("height", oldPage.getHeight() + "px");
            oldPage[0].offsetHeight;
            oldPage.setStyles({
              "height": "0px",
              "paddingTop": "0px",
              "paddingBottom": "0px"
            });
            oldPage.addClass(this.getCssPrefix() + "-page-closed");
          }

          if (newPage && newPage.length > 0) {
            newPage.removeClass(this.getCssPrefix() + "-page-closed");

            if (!newPage.getStyle("transition") || newPage.getStyle("transition").indexOf("none") === 0) {
              newPage.setStyle("height", "");
            } else {
              var openedHeight = newPage.getProperty("openedHeight");

              if (qxWeb.type.get(openedHeight) == "String") {
                newPage.setStyle("height", openedHeight);
              }
            }
          }
        }
      },

      /**
       * Returns the tab page associated with the given button
       *
       * @param button {qxWeb} Tab button
       * @return {qxWeb} Tab page
       */
      _getPage: function _getPage(button) {
        var pageSelector;

        if (button) {
          pageSelector = button.getData(this.getCssPrefix() + "-page");
        }

        return this.find(pageSelector);
      },

      /**
       * Apply the CSS classes for the alignment
       *
       * @param tabs {qx.ui.website.Tabs[]} tabs collection
       */
      _applyAlignment: function _applyAlignment(tabs) {
        var align = tabs.getConfig("align");
        var buttons = tabs.find("> ul > li");

        if (q.env.get("engine.name") == "mshtml" && q.env.get("browser.documentmode") < 10) {
          if (align == "left") {
            tabs.addClass(this.getCssPrefix() + "-left");
          } else {
            tabs.removeClass(this.getCssPrefix() + "-left");
          }

          if (align == "justify") {
            tabs.addClass(this.getCssPrefix() + "-justify");
          } else {
            tabs.removeClass(this.getCssPrefix() + "-justify");
          }

          if (align == "right") {
            tabs.addClass(this.getCssPrefix() + "-right");
          } else {
            tabs.removeClass(this.getCssPrefix() + "-right");
          }
        } else {
          tabs.find("> ul").addClass("qx-hbox");

          if (align == "justify") {
            buttons.addClass("qx-flex1");
          } else {
            buttons.removeClass("qx-flex1");
          }

          if (align == "right") {
            tabs.find("> ul").addClass("qx-flex-justify-end");
          } else {
            tabs.find("> ul").removeClass("qx-flex-justify-end");
          }
        }
      },

      /**
       * Stores the page's natural height for the page opening transition
       * @param page {qxWeb} page
       */
      _storePageHeight: function _storePageHeight(page) {
        var closedClass = this.getCssPrefix() + "-page-closed";
        var isClosed = page.hasClass(closedClass);

        if (isClosed) {
          page.removeClass(this.getCssPrefix() + "-page-closed");
        }

        var prevDisplay = page[0].style.display;
        var prevHeight = page[0].style.height;
        page[0].style.height = "";
        page[0].style.display = "block";
        page.setProperty("openedHeight", page.getHeight() + "px");

        if (isClosed) {
          page.addClass(this.getCssPrefix() + "-page-closed");
        }

        page[0].style.height = prevHeight;
        page[0].style.display = prevDisplay;
      },

      /**
       * Stores an element's CSS transition styles in a property
       * and removes them from the style declaration
       *
       * @param elem {qxWeb} Element
       */
      __deactivateTransition__P_560_1: function __deactivateTransition__P_560_1(elem) {
        var transition = elem.getStyles(["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"]);

        if (transition.transitionProperty.indexOf("none") == -1) {
          elem.setProperty("__qxtransition__P_560_3", transition);
          elem.setStyle("transition", "none");
        }
      },

      /**
       * Restores an element's transition styles
       *
       * @param elem {qxWeb} Element
       */
      __activateTransition__P_560_2: function __activateTransition__P_560_2(elem) {
        var transition = elem.getProperty("__qxtransition__P_560_3");
        var style = elem.getStyle("transitionProperty");

        if (transition && style.indexOf("none") != -1) {
          elem.setStyles(transition);
          elem.setProperty("__qxtransition__P_560_3", "");
        }
      },
      dispose: function dispose() {
        this.__mediaQueryListener__P_560_0 = undefined;
        var cssPrefix = this.getCssPrefix();
        qxWeb(window).off("resize", this._onResize, this);
        this.find("> ul > ." + this.getCssPrefix() + "-button").off("tap", this._onTap, this);
        this.getChildren("ul").getFirst().off("keydown", this._onKeyDown, this).setHtml("");
        this.setHtml("").removeClasses([cssPrefix, "qx-flex-ready"]);
        return qx.ui.website.Tabs.prototype.dispose.base.call(this);
      }
    },
    defer: function defer(statics) {
      qxWeb.$attach({
        tabs: statics.tabs
      });
    }
  });
  qx.ui.website.Tabs.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.module.util.Object": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.ui.website.Tabs": {
        "construct": true,
        "require": true
      },
      "qxWeb": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * The Accordion is a group of vertically stacked panels (here called pages),
   * each with a header.
   * By default, only one page is visible while the others are collapsed.
   * Clicking or tapping a collapsed page's header will expand it while collapsing the
   * previously expanded page.
   *
   * <h2>Markup</h2>
   * The Accordion contains an unordered list element (<code>ul</code>), which
   * will be created if not already present.
   * Headers and pages are list items (<code>li</code>). Each header must contain
   * a button with an <code>accordionPage</code> data attribute where the value is a
   * CSS selector string identifying the corresponding page. Headers and pages
   * will not be created automatically. They can be predefined in the DOM before
   * the <code>q().accordion()</code> factory method is called, or added programmatically.
   *
   * <h2>CSS Classes</h2>
   * <table>
   *   <thead>
   *     <tr>
   *       <td>Class Name</td>
   *       <td>Applied to</td>
   *       <td>Description</td>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><code>qx-accordion</code></td>
   *       <td>Container element</td>
   *       <td>Identifies the Accordion widget</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-accordion-button</code></td>
   *       <td>Page header (<code>li</code>)</td>
   *       <td>Identifies and styles the page headers</td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-accordion-button-active</code></td>
   *       <td>Page header (<code>li</code>)</td>
   *       <td>Identifies and styles the header of the currently expanded page. Applied in addition to <code>qx-accordion-button</code></td>
   *     </tr>
   *     <tr>
   *       <td><code>qx-accordion-page</code></td>
   *       <td>Page (<code>li</code>)</td>
   *       <td>Identifies and styles the pages</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <h2 class="widget-markup">Generated DOM Structure</h2>
   *
   * @require(qx.module.util.Object)
   *
   * @group (Widget)
   */
  qx.Bootstrap.define("qx.ui.website.Accordion", {
    extend: qx.ui.website.Tabs,
    statics: {
      /**
       * *button*
       *
       * Template used by {@link qx.ui.website.Tabs#addButton} to create a new button.
       *
       * Default value: <pre><li><button>{{{content}}}</button></li></pre>
       */
      _templates: {
        button: "<li><button>{{{content}}}</button></li>"
      },

      /**
       * Factory method which converts the current collection into a collection of
       * accordion widgets.
       *
       * @param preselected {Integer?} The (zero-based) index of the panel that
       * should initially be opened
       * @return {qx.ui.website.Accordion} A new Accordion collection.
       * @attach {qxWeb}
       */
      accordion: function accordion(preselected) {
        var accordion = new qx.ui.website.Accordion(this);
        accordion.setConfig("orientation", "vertical");

        if (preselected) {
          accordion.setConfig("preselected", preselected);
        }

        accordion.init();
        return accordion;
      }
    },
    construct: function construct(selector, context) {
      qx.ui.website.Tabs.constructor.call(this, selector, context);
    },
    defer: function defer(statics) {
      qxWeb.$attach({
        accordion: statics.accordion
      });
    }
  });
  qx.ui.website.Accordion.$$dbClassInfo = $$dbClassInfo;
})();
//# sourceMappingURL=package-7.js.map?dt=1599463069884
qx.$$packageData['7'] = {
  "locales": {},
  "resources": {},
  "translations": {
    "en": {}
  }
};
