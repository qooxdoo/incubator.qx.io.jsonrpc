{
  "version": 3,
  "sources": [
    "/home/runner/work/incubator.qx.io.jsonrpc/incubator.qx.io.jsonrpc/source/class/qx/io/jsonrpc/Client.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "statics",
    "__transports",
    "registerTransport",
    "uriRegExp",
    "transportClass",
    "io",
    "jsonrpc",
    "Client",
    "lang",
    "Type",
    "isRegExp",
    "Error",
    "Interface",
    "classImplements",
    "transport",
    "ITransport",
    "push",
    "events",
    "construct",
    "transportOrUri",
    "methodPrefix",
    "parser",
    "uri",
    "isString",
    "registeredTransport",
    "reverse",
    "match",
    "exception",
    "Transport",
    "INVALD_URI",
    "setTransport",
    "getTransport",
    "addListener",
    "evt",
    "handleIncoming",
    "getData",
    "setMethodPrefix",
    "protocol",
    "Parser",
    "setParser",
    "__requests",
    "properties",
    "check",
    "nullable",
    "members",
    "_prependMethodPrefix",
    "method",
    "getMethodPrefix",
    "startsWith",
    "_throwTransportException",
    "fireDataEvent",
    "forEach",
    "request",
    "Request",
    "handleTransportException",
    "send",
    "message",
    "Message",
    "Batch",
    "messages",
    "getBatch",
    "toArray",
    "requests",
    "filter",
    "id",
    "getId",
    "undefined",
    "INVALID_ID",
    "toObject",
    "Environment",
    "get",
    "debug",
    "toString",
    "sendRequest",
    "params",
    "getPromise",
    "sendNotification",
    "notification",
    "Notification",
    "sendBatch",
    "batch",
    "Assert",
    "assertInstance",
    "setMethod",
    "getMethod",
    "Promise",
    "all",
    "getPromises",
    "json",
    "getParser",
    "parse",
    "handleMessage",
    "e",
    "msg",
    "_cleanup",
    "dispose",
    "Result",
    "UNKNOWN_ID",
    "DUPLICATE_ID",
    "resolve",
    "getResult",
    "error",
    "getError",
    "ex",
    "JsonRpc",
    "code",
    "reject",
    "environment"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n      2020 Christian Boulanger\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Christian Boulanger (cboulanger)\n\n************************************************************************ */\n\n/**\n * This class provides a JSON-RPC client object with auto-configuration of the\n * transport used (based on the URI passed).\n */\nqx.Class.define(\"qx.io.jsonrpc.Client\",\n{\n  extend : qx.core.Object,\n\n  statics: {\n\n    __transports: null,\n\n    /**\n     * Register a transport class for use with uris that match the given\n     * regular expression. The client will use the transport which first\n     * matches, starting with the last added transport\n     * @param {RegExp} uriRegExp\n     *    A regular expression which the URI must match\n     * @param {qx.io.jsonrpc.transport.ITransport}  transportClass\n     *    The qooxdoo class implementing the transport\n     */\n    registerTransport(uriRegExp, transportClass) {\n      if (qx.io.jsonrpc.Client.__transports === null) {\n        qx.io.jsonrpc.Client.__transports = [];\n      }\n      if (!qx.lang.Type.isRegExp(uriRegExp)) {\n        throw new Error(\"First argument must be a regular expression!\");\n      }\n      if (!qx.Interface.classImplements(transportClass, qx.io.jsonrpc.transport.ITransport)) {\n        throw new Error(\"Transport class must implement qx.io.jsonrpc.transport.ITransport\");\n      }\n      qx.io.jsonrpc.Client.__transports.push({ uriRegExp, transport: transportClass});\n    }\n\n  },\n\n  events : {\n  \n    /**\n     * Event fired before a request message is sent to the server.\n     * Event data is the {@link qx.io.jsonrpc.protocol.Message} to\n     * be sent. This also allows listeners to configure the transport\n     * object beforehand.\n     */\n    \"outgoingRequest\": \"qx.event.type.Data\",\n    \n    /**\n     * Event fired when a request results in an error. Event data is an instance of\n     * {@link qx.io.jsonrpc.exception.Transport}, {@link qx.io.jsonrpc.exception.JsonRpc},\n     * or {@link qx.io.jsonrpc.exception.Cancel}.\n     * Event fired when a message is received from the endpoint. Event data\n     * is an UTF-8 encoded string\n     */\n    \"error\" : \"qx.event.type.Data\",\n\n    /**\n     * Event fired when a peer-originated JSON-RPC message has been\n     * received from the peer endpoint. Event data is an instance of {@link\n     * qx.io.jsonrpc.message.Batch}, {@link qx.io.jsonrpc.message.Request}\n     * or {@link qx.io.jsonrpc.protocol.Notification}.\n     */\n    \"incomingRequest\" : \"qx.event.type.Data\"\n  },\n\n  /**\n   * @param {qx.io.jsonrpc.transport.ITransport|String} transportOrUri\n   *    Transport object, which must implement {@link qx.io.jsonrpc.transport.ITransport}\n   *    or a string URI, which will trigger auto-detection of transport, as long as an\n   *    appropriate transport has been registered with the static `registerTransport()` function.\n   * @param {String?} methodPrefix\n   *    Optional service name which will be prepended to the method\n   * @param {qx.io.jsonrpc.protocol.Parser?} parser\n   *    Optional parser object, which needs to be an instance of a subclass of {@link qx.io.jsonrpc.protocol.Parser}\n   */\n  construct : function(transportOrUri, methodPrefix, parser) {\n    this.base(arguments);\n    let transport;\n    let uri;\n    if (qx.lang.Type.isString(transportOrUri)) {\n      uri = transportOrUri;\n      for (let registeredTransport of qx.io.jsonrpc.Client.__transports.reverse()) {\n        if (uri.match(registeredTransport.uriRegExp)) {\n          // eslint-disable-next-line new-cap\n          transport = new registeredTransport.transport(uri);\n        }\n      }\n      if (!transport) {\n        throw new qx.io.jsonrpc.exception.Transport(\n          `No matching transport for URI '${transportOrUri}'`,\n          qx.io.jsonrpc.exception.Transport.INVALD_URI\n        );\n      }\n    } else {\n      transport = transportOrUri;\n    }\n    this.setTransport(transport);\n\n    // listen for incoming messages\n    this.getTransport().addListener(\"message\", evt => this.handleIncoming(evt.getData()));\n\n    if (!methodPrefix) {\n      methodPrefix = \"\";\n    }\n    this.setMethodPrefix(methodPrefix);\n\n    if (!parser) {\n      parser = new qx.io.jsonrpc.protocol.Parser();\n    }\n    this.setParser(parser);\n\n    this.__requests = [];\n  },\n\n\n  properties :\n  {\n\n    /**\n     * An optional string which is prepended to the method name.\n     */\n    methodPrefix :\n    {\n      check : \"String\",\n      nullable : true\n    },\n\n    /**\n     * The transport object\n     */\n    transport:\n    {\n      check : \"qx.io.jsonrpc.transport.ITransport\"\n    },\n\n    /**\n     * The parser object, which must be a subclass of {@link qx.io.jsonrpc.protocol.Parser}\n      */\n    parser: {\n      check : \"qx.io.jsonrpc.protocol.Parser\"\n    }\n  },\n\n  members :\n  {\n\n    /**\n     * A cache of the requests which have been sent out and are still pending\n     */\n    __requests : null,\n\n    /**\n     * If a service name has been configured, prepend it to the method name\n     * @param {String} method\n     * @return {String}\n     * @private\n     */\n    _prependMethodPrefix(method) {\n      let methodPrefix = this.getMethodPrefix();\n      if (methodPrefix && !method.startsWith(methodPrefix + \".\")) {\n        return `${methodPrefix}.${method}`;\n      }\n      return method;\n    },\n\n    /**\n     * Fires \"error\" event and throws the error after informing pending requests\n     * about the error.\n     * @param exception\n     * @private\n     */\n    _throwTransportException(exception) {\n      this.fireDataEvent(\"error\", exception);\n      this.__requests.forEach(request => {\n        if (request instanceof qx.io.jsonrpc.protocol.Request) {\n          request.handleTransportException(exception);\n        }\n      });\n      throw exception;\n    },\n\n    /**\n     * Send the given JSON-RPC message object using the configured transport\n     *\n     * @param {qx.io.jsonrpc.protocol.Message|qx.io.jsonrpc.protocol.Batch} message\n     * @return {qx.Promise} Promise that resolves (with no data)\n     * when the message has been successfully sent out, and rejects\n     * when there is an error or a cancellation up to that point.\n     */\n    async send(message) {\n      if (!(message instanceof qx.io.jsonrpc.protocol.Message || message instanceof qx.io.jsonrpc.protocol.Batch)) {\n        throw new Error(\"Argument must be instanceof qx.io.jsonrpc.protocol.Message or qx.io.jsonrpc.protocol.Batch\");\n      }\n\n      // filter by type\n      let messages = message instanceof qx.io.jsonrpc.protocol.Batch ? message.getBatch().toArray() : [message];\n      let requests = messages.filter(message => message instanceof qx.io.jsonrpc.protocol.Request);\n\n      // store requests\n      requests.forEach(request => {\n        let id = request.getId();\n        if (this.__requests[id] !== undefined) {\n          throw new qx.io.jsonrpc.exception.Transport(`Request ID ${id} is already in use`, qx.io.jsonrpc.exception.Transport.INVALID_ID, {request: message.toObject()});\n        }\n        this.__requests[id] = request;\n      });\n      \n      // inform listeners\n      this.fireDataEvent(\"outgoingRequest\", message);\n  \n      // debugging\n      if (qx.core.Environment.get(\"qx.io.jsonrpc.debug\")) {\n        this.debug(\">>> Outgoing json-rpc message: \" + message);\n      }\n      \n      // send it async, using transport-specific implementation\n      return this.getTransport().send(message.toString());\n    },\n\n    /**\n     * Sends a single JSON-RPC request. If a service name has been configured,\n     * it is prepended to the method name with a dot.\n     * @param {String} method\n     * @param {Array|Object?} params\n     * @return {qx.Promise} Promise that resolves with the result to that request,\n     * and rejects with an exception in the {@link qx.io.jsonrpc.exception} namespace.\n     */\n    async sendRequest(method, params) {\n      const request = new qx.io.jsonrpc.protocol.Request(this._prependMethodPrefix(method), params);\n      this.send(request); // not awaited because we await the request's promise\n      return await request.getPromise();\n    },\n\n    /**\n     * Sends a single JSON-RPC notification. If a service name has been configured,\n     * it is prepended to the method name with a dot.\n     * @param {String} method\n     * @param {Array|Object?} params\n     * @return {qx.Promise} Promise that resolves immediately, (i.e. when the\n     * notification has been sent out (which is synchronous)\n     */\n    async sendNotification(method, params) {\n      const notification = new qx.io.jsonrpc.protocol.Notification(this._prependMethodPrefix(method), params);\n      await this.send(notification);\n    },\n\n    /**\n     * Send the given message batch. If a service name has been configured,\n     * it is prepended to the method name in each message with a dot.\n     * @param {qx.io.jsonrpc.protocol.Batch} batch\n     * @return {qx.Promise} Promise that resolves with an array of the responses\n     * to all requests in the batch, or rejects with any error that occurs.\n     */\n    async sendBatch(batch) {\n      qx.core.Assert.assertInstance(batch, qx.io.jsonrpc.protocol.Batch);\n      if (this.getMethodPrefix()) {\n        batch.getBatch().forEach(message => message.setMethod(this._prependMethodPrefix(message.getMethod())));\n      }\n      this.send(batch);\n      return await qx.Promise.all(batch.getPromises());\n    },\n\n    /**\n     * Receives and handles an incoming JSON-RPC compliant message data\n     * @param {String} json JSON data\n     */\n    handleIncoming(json) {\n      if (qx.core.Environment.get(\"qx.io.jsonrpc.debug\")) {\n        this.debug(\"<<< Incoming json-rpc message: \" + json);\n      }\n      let message;\n      try {\n        message = this.getParser().parse(json);\n        // act on each message\n        this.handleMessage(message);\n      } catch (e) {\n        this._throwTransportException(e);\n      } finally {\n        // cleanup\n        if (message instanceof qx.io.jsonrpc.protocol.Batch) {\n          message.getBatch().forEach(msg => this._cleanup(msg));\n        } else if (message instanceof qx.io.jsonrpc.protocol.Message) {\n          this._cleanup(message);\n        }\n      }\n    },\n\n    /**\n     * Clean up after a message has been received\n     * @param {qx.io.jsonrpc.protocol.Message} message\n     * @private\n     */\n    _cleanup(message) {\n      message.dispose();\n    },\n\n    /**\n     * Handle an incoming message or batch of messages\n     * @param {qx.io.jsonrpc.protocol.Message|qx.io.jsonrpc.protocol.Batch} message Message or Batch\n     */\n    handleMessage(message) {\n      // handle batches\n      if (message instanceof qx.io.jsonrpc.protocol.Batch) {\n        message.getBatch().forEach(msg => this.handleMessage(msg));\n        return;\n      }\n      // handle individual message\n      qx.core.Assert.assertInstance(message, qx.io.jsonrpc.protocol.Message);\n      let request;\n      let id;\n      if (message instanceof qx.io.jsonrpc.protocol.Result || message instanceof qx.io.jsonrpc.protocol.Error) {\n        // handle results and errors, which are responses to sent requests\n        id = message.getId();\n        request = this.__requests[id];\n        if (request === undefined) {\n          // no request with this id exists\n          throw new qx.io.jsonrpc.exception.Transport(\n            `Invalid jsonrpc response data: Unknown id ${id}.`,\n            qx.io.jsonrpc.exception.Transport.UNKNOWN_ID,\n            message.toObject()\n          );\n        }\n        if (request === true) {\n          // the request has already been responded to\n          throw new qx.io.jsonrpc.exception.Transport(\n              `Invalid jsonrpc response data: multiple responses with same id ${id}.`,\n              qx.io.jsonrpc.exception.Transport.DUPLICATE_ID,\n              message.toObject()\n          );\n        }\n      }\n      // handle the different message types\n      if (message instanceof qx.io.jsonrpc.protocol.Result) {\n        // resolve the individual promise\n        request.getPromise().resolve(message.getResult());\n      } else if (message instanceof qx.io.jsonrpc.protocol.Error) {\n        \n        let error = message.getError();\n        let ex = new qx.io.jsonrpc.exception.JsonRpc(\n          error.message,\n          error.code,\n          message.toObject()\n        );\n        // inform listeners\n        this.fireDataEvent(\"error\", ex);\n        // reject the individual promise\n        request.getPromise().reject(ex);\n      } else if (message instanceof qx.io.jsonrpc.protocol.Request || message instanceof qx.io.jsonrpc.protocol.Notification) {\n        // handle peer-originated requests and notifications\n        this.fireDataEvent(\"incomingRequest\", message);\n      } else {\n        throw new Error(\"Unhandled message:\" + message.toString());\n      }\n      // mark request as handled (and remove reference so it can be gc'ed)\n      this.__requests[id] = true;\n    }\n  },\n  \n  environment: {\n    \"qx.io.jsonrpc.debug\" : false\n  }\n});\n"
  ]
}